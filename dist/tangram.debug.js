(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
"use strict";

if (global._babelPolyfill) {
  throw new Error("only one instance of babel/polyfill is allowed");
}
global._babelPolyfill = true;

require("core-js/shim");

require("regenerator-babel/runtime");
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9iYWJlbC9saWIvYmFiZWwvcG9seWZpbGwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuaWYgKGdsb2JhbC5fYmFiZWxQb2x5ZmlsbCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IG9uZSBpbnN0YW5jZSBvZiBiYWJlbC9wb2x5ZmlsbCBpcyBhbGxvd2VkXCIpO1xufVxuZ2xvYmFsLl9iYWJlbFBvbHlmaWxsID0gdHJ1ZTtcblxucmVxdWlyZShcImNvcmUtanMvc2hpbVwiKTtcblxucmVxdWlyZShcInJlZ2VuZXJhdG9yLWJhYmVsL3J1bnRpbWVcIik7Il19
},{"core-js/shim":2,"regenerator-babel/runtime":3}],2:[function(require,module,exports){
/**
 * Core.js 0.6.1
 * https://github.com/zloirock/core-js
 * License: http://rock.mit-license.org
 * © 2015 Denis Pushkarev
 */
!function(global, framework, undefined){
'use strict';

/******************************************************************************
 * Module : common                                                            *
 ******************************************************************************/

  // Shortcuts for [[Class]] & property names
var OBJECT          = 'Object'
  , FUNCTION        = 'Function'
  , ARRAY           = 'Array'
  , STRING          = 'String'
  , NUMBER          = 'Number'
  , REGEXP          = 'RegExp'
  , DATE            = 'Date'
  , MAP             = 'Map'
  , SET             = 'Set'
  , WEAKMAP         = 'WeakMap'
  , WEAKSET         = 'WeakSet'
  , SYMBOL          = 'Symbol'
  , PROMISE         = 'Promise'
  , MATH            = 'Math'
  , ARGUMENTS       = 'Arguments'
  , PROTOTYPE       = 'prototype'
  , CONSTRUCTOR     = 'constructor'
  , TO_STRING       = 'toString'
  , TO_STRING_TAG   = TO_STRING + 'Tag'
  , TO_LOCALE       = 'toLocaleString'
  , HAS_OWN         = 'hasOwnProperty'
  , FOR_EACH        = 'forEach'
  , ITERATOR        = 'iterator'
  , FF_ITERATOR     = '@@' + ITERATOR
  , PROCESS         = 'process'
  , CREATE_ELEMENT  = 'createElement'
  // Aliases global objects and prototypes
  , Function        = global[FUNCTION]
  , Object          = global[OBJECT]
  , Array           = global[ARRAY]
  , String          = global[STRING]
  , Number          = global[NUMBER]
  , RegExp          = global[REGEXP]
  , Date            = global[DATE]
  , Map             = global[MAP]
  , Set             = global[SET]
  , WeakMap         = global[WEAKMAP]
  , WeakSet         = global[WEAKSET]
  , Symbol          = global[SYMBOL]
  , Math            = global[MATH]
  , TypeError       = global.TypeError
  , RangeError      = global.RangeError
  , setTimeout      = global.setTimeout
  , setImmediate    = global.setImmediate
  , clearImmediate  = global.clearImmediate
  , parseInt        = global.parseInt
  , isFinite        = global.isFinite
  , process         = global[PROCESS]
  , nextTick        = process && process.nextTick
  , document        = global.document
  , html            = document && document.documentElement
  , navigator       = global.navigator
  , define          = global.define
  , console         = global.console || {}
  , ArrayProto      = Array[PROTOTYPE]
  , ObjectProto     = Object[PROTOTYPE]
  , FunctionProto   = Function[PROTOTYPE]
  , Infinity        = 1 / 0
  , DOT             = '.';

// http://jsperf.com/core-js-isobject
function isObject(it){
  return it !== null && (typeof it == 'object' || typeof it == 'function');
}
function isFunction(it){
  return typeof it == 'function';
}
// Native function?
var isNative = ctx(/./.test, /\[native code\]\s*\}\s*$/, 1);

// Object internal [[Class]] or toStringTag
// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring
var toString = ObjectProto[TO_STRING];
function setToStringTag(it, tag, stat){
  if(it && !has(it = stat ? it : it[PROTOTYPE], SYMBOL_TAG))hidden(it, SYMBOL_TAG, tag);
}
function cof(it){
  return toString.call(it).slice(8, -1);
}
function classof(it){
  var O, T;
  return it == undefined ? it === undefined ? 'Undefined' : 'Null'
    : typeof (T = (O = Object(it))[SYMBOL_TAG]) == 'string' ? T : cof(O);
}

// Function
var call  = FunctionProto.call
  , apply = FunctionProto.apply
  , REFERENCE_GET;
// Partial apply
function part(/* ...args */){
  var fn     = assertFunction(this)
    , length = arguments.length
    , args   = Array(length)
    , i      = 0
    , _      = path._
    , holder = false;
  while(length > i)if((args[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that    = this
      , _length = arguments.length
      , i = 0, j = 0, _args;
    if(!holder && !_length)return invoke(fn, args, that);
    _args = args.slice();
    if(holder)for(;length > i; i++)if(_args[i] === _)_args[i] = arguments[j++];
    while(_length > j)_args.push(arguments[j++]);
    return invoke(fn, _args, that);
  }
}
// Optional / simple context binding
function ctx(fn, that, length){
  assertFunction(fn);
  if(~length && that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    }
    case 2: return function(a, b){
      return fn.call(that, a, b);
    }
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    }
  } return function(/* ...args */){
      return fn.apply(that, arguments);
  }
}
// Fast apply
// http://jsperf.lnkit.com/fast-apply/5
function invoke(fn, args, that){
  var un = that === undefined;
  switch(args.length | 0){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
    case 5: return un ? fn(args[0], args[1], args[2], args[3], args[4])
                      : fn.call(that, args[0], args[1], args[2], args[3], args[4]);
  } return              fn.apply(that, args);
}

// Object:
var create           = Object.create
  , getPrototypeOf   = Object.getPrototypeOf
  , setPrototypeOf   = Object.setPrototypeOf
  , defineProperty   = Object.defineProperty
  , defineProperties = Object.defineProperties
  , getOwnDescriptor = Object.getOwnPropertyDescriptor
  , getKeys          = Object.keys
  , getNames         = Object.getOwnPropertyNames
  , getSymbols       = Object.getOwnPropertySymbols
  , isFrozen         = Object.isFrozen
  , has              = ctx(call, ObjectProto[HAS_OWN], 2)
  // Dummy, fix for not array-like ES3 string in es5 module
  , ES5Object        = Object
  , Dict;
function toObject(it){
  return ES5Object(assertDefined(it));
}
function returnIt(it){
  return it;
}
function returnThis(){
  return this;
}
function get(object, key){
  if(has(object, key))return object[key];
}
function ownKeys(it){
  assertObject(it);
  return getSymbols ? getNames(it).concat(getSymbols(it)) : getNames(it);
}
// 19.1.2.1 Object.assign(target, source, ...)
var assign = Object.assign || function(target, source){
  var T = Object(assertDefined(target))
    , l = arguments.length
    , i = 1;
  while(l > i){
    var S      = ES5Object(arguments[i++])
      , keys   = getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)T[key = keys[j++]] = S[key];
  }
  return T;
}
function keyOf(object, el){
  var O      = toObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
}

// Array
// array('str1,str2,str3') => ['str1', 'str2', 'str3']
function array(it){
  return String(it).split(',');
}
var push    = ArrayProto.push
  , unshift = ArrayProto.unshift
  , slice   = ArrayProto.slice
  , splice  = ArrayProto.splice
  , indexOf = ArrayProto.indexOf
  , forEach = ArrayProto[FOR_EACH];
/*
 * 0 -> forEach
 * 1 -> map
 * 2 -> filter
 * 3 -> some
 * 4 -> every
 * 5 -> find
 * 6 -> findIndex
 */
function createArrayMethod(type){
  var isMap       = type == 1
    , isFilter    = type == 2
    , isSome      = type == 3
    , isEvery     = type == 4
    , isFindIndex = type == 6
    , noholes     = type == 5 || isFindIndex;
  return function(callbackfn/*, that = undefined */){
    var O      = Object(assertDefined(this))
      , that   = arguments[1]
      , self   = ES5Object(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = isMap ? Array(length) : isFilter ? [] : undefined
      , val, res;
    for(;length > index; index++)if(noholes || index in self){
      val = self[index];
      res = f(val, index, O);
      if(type){
        if(isMap)result[index] = res;             // map
        else if(res)switch(type){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(isEvery)return false;           // every
      }
    }
    return isFindIndex ? -1 : isSome || isEvery ? isEvery : result;
  }
}
function createArrayContains(isContains){
  return function(el /*, fromIndex = 0 */){
    var O      = toObject(this)
      , length = toLength(O.length)
      , index  = toIndex(arguments[1], length);
    if(isContains && el != el){
      for(;length > index; index++)if(sameNaN(O[index]))return isContains || index;
    } else for(;length > index; index++)if(isContains || index in O){
      if(O[index] === el)return isContains || index;
    } return !isContains && -1;
  }
}
function generic(A, B){
  // strange IE quirks mode bug -> use typeof vs isFunction
  return typeof A == 'function' ? A : B;
}

// Math
var MAX_SAFE_INTEGER = 0x1fffffffffffff // pow(2, 53) - 1 == 9007199254740991
  , pow    = Math.pow
  , abs    = Math.abs
  , ceil   = Math.ceil
  , floor  = Math.floor
  , max    = Math.max
  , min    = Math.min
  , random = Math.random
  , trunc  = Math.trunc || function(it){
      return (it > 0 ? floor : ceil)(it);
    }
// 20.1.2.4 Number.isNaN(number)
function sameNaN(number){
  return number != number;
}
// 7.1.4 ToInteger
function toInteger(it){
  return isNaN(it) ? 0 : trunc(it);
}
// 7.1.15 ToLength
function toLength(it){
  return it > 0 ? min(toInteger(it), MAX_SAFE_INTEGER) : 0;
}
function toIndex(index, length){
  var index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
}
function lz(num){
  return num > 9 ? num : '0' + num;
}

function createReplacer(regExp, replace, isStatic){
  var replacer = isObject(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(isStatic ? it : this).replace(regExp, replacer);
  }
}
function createPointAt(toString){
  return function(pos){
    var s = String(assertDefined(this))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return toString ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? toString ? s.charAt(i) : a
      : toString ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  }
}

// Assertion & errors
var REDUCE_ERROR = 'Reduce of empty object with no initial value';
function assert(condition, msg1, msg2){
  if(!condition)throw TypeError(msg2 ? msg1 + msg2 : msg1);
}
function assertDefined(it){
  if(it == undefined)throw TypeError('Function called on null or undefined');
  return it;
}
function assertFunction(it){
  assert(isFunction(it), it, ' is not a function!');
  return it;
}
function assertObject(it){
  assert(isObject(it), it, ' is not an object!');
  return it;
}
function assertInstance(it, Constructor, name){
  assert(it instanceof Constructor, name, ": use the 'new' operator!");
}

// Property descriptors & Symbol
function descriptor(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  }
}
function simpleSet(object, key, value){
  object[key] = value;
  return object;
}
function createDefiner(bitmap){
  return DESC ? function(object, key, value){
    return defineProperty(object, key, descriptor(bitmap, value));
  } : simpleSet;
}
function uid(key){
  return SYMBOL + '(' + key + ')_' + (++sid + random())[TO_STRING](36);
}
function getWellKnownSymbol(name, setter){
  return (Symbol && Symbol[name]) || (setter ? Symbol : safeSymbol)(SYMBOL + DOT + name);
}
// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.
var DESC = !!function(){
      try {
        return defineProperty({}, 'a', {get: function(){ return 2 }}).a == 2;
      } catch(e){}
    }()
  , sid    = 0
  , hidden = createDefiner(1)
  , set    = Symbol ? simpleSet : hidden
  , safeSymbol = Symbol || uid;
function assignHidden(target, src){
  for(var key in src)hidden(target, key, src[key]);
  return target;
}

var SYMBOL_UNSCOPABLES = getWellKnownSymbol('unscopables')
  , ArrayUnscopables   = ArrayProto[SYMBOL_UNSCOPABLES] || {}
  , SYMBOL_TAG         = getWellKnownSymbol(TO_STRING_TAG)
  , SYMBOL_SPECIES     = getWellKnownSymbol('species')
  , SYMBOL_ITERATOR;
function setSpecies(C){
  if(DESC && (framework || !isNative(C)))defineProperty(C, SYMBOL_SPECIES, {
    configurable: true,
    get: returnThis
  });
}

/******************************************************************************
 * Module : common.export                                                     *
 ******************************************************************************/

var NODE = cof(process) == PROCESS
  , core = {}
  , path = framework ? global : core
  , old  = global.core
  , exportGlobal
  // type bitmap
  , FORCED = 1
  , GLOBAL = 2
  , STATIC = 4
  , PROTO  = 8
  , BIND   = 16
  , WRAP   = 32;
function $define(type, name, source){
  var key, own, out, exp
    , isGlobal = type & GLOBAL
    , target   = isGlobal ? global : (type & STATIC)
        ? global[name] : (global[name] || ObjectProto)[PROTOTYPE]
    , exports  = isGlobal ? core : core[name] || (core[name] = {});
  if(isGlobal)source = name;
  for(key in source){
    // there is a similar native
    own = !(type & FORCED) && target && key in target
      && (!isFunction(target[key]) || isNative(target[key]));
    // export native or passed
    out = (own ? target : source)[key];
    // prevent global pollution for namespaces
    if(!framework && isGlobal && !isFunction(target[key]))exp = source[key];
    // bind timers to global for call from export context
    else if(type & BIND && own)exp = ctx(out, global);
    // wrap global constructors for prevent change them in library
    else if(type & WRAP && !framework && target[key] == out){
      exp = function(param){
        return this instanceof out ? new out(param) : out(param);
      }
      exp[PROTOTYPE] = out[PROTOTYPE];
    } else exp = type & PROTO && isFunction(out) ? ctx(call, out) : out;
    // extend global
    if(framework && target && !own){
      if(isGlobal)target[key] = out;
      else delete target[key] && hidden(target, key, out);
    }
    // export
    if(exports[key] != out)hidden(exports, key, exp);
  }
}
// CommonJS export
if(typeof module != 'undefined' && module.exports)module.exports = core;
// RequireJS export
else if(isFunction(define) && define.amd)define(function(){return core});
// Export to global object
else exportGlobal = true;
if(exportGlobal || framework){
  core.noConflict = function(){
    global.core = old;
    return core;
  }
  global.core = core;
}

/******************************************************************************
 * Module : common.iterators                                                  *
 ******************************************************************************/

SYMBOL_ITERATOR = getWellKnownSymbol(ITERATOR);
var ITER  = safeSymbol('iter')
  , KEY   = 1
  , VALUE = 2
  , Iterators = {}
  , IteratorPrototype = {}
    // Safari has byggy iterators w/o `next`
  , BUGGY_ITERATORS = 'keys' in ArrayProto && !('next' in [].keys());
// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
setIterator(IteratorPrototype, returnThis);
function setIterator(O, value){
  hidden(O, SYMBOL_ITERATOR, value);
  // Add iterator for FF iterator protocol
  FF_ITERATOR in ArrayProto && hidden(O, FF_ITERATOR, value);
}
function createIterator(Constructor, NAME, next, proto){
  Constructor[PROTOTYPE] = create(proto || IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
}
function defineIterator(Constructor, NAME, value, DEFAULT){
  var proto = Constructor[PROTOTYPE]
    , iter  = get(proto, SYMBOL_ITERATOR) || get(proto, FF_ITERATOR) || (DEFAULT && get(proto, DEFAULT)) || value;
  if(framework){
    // Define iterator
    setIterator(proto, iter);
    if(iter !== value){
      var iterProto = getPrototypeOf(iter.call(new Constructor));
      // Set @@toStringTag to native iterators
      setToStringTag(iterProto, NAME + ' Iterator', true);
      // FF fix
      has(proto, FF_ITERATOR) && setIterator(iterProto, returnThis);
    }
  }
  // Plug for library
  Iterators[NAME] = iter;
  // FF & v8 fix
  Iterators[NAME + ' Iterator'] = returnThis;
  return iter;
}
function defineStdIterators(Base, NAME, Constructor, next, DEFAULT, IS_SET){
  function createIter(kind){
    return function(){
      return new Constructor(this, kind);
    }
  }
  createIterator(Constructor, NAME, next);
  var entries = createIter(KEY+VALUE)
    , values  = createIter(VALUE);
  if(DEFAULT == VALUE)values = defineIterator(Base, NAME, values, 'values');
  else entries = defineIterator(Base, NAME, entries, 'entries');
  if(DEFAULT){
    $define(PROTO + FORCED * BUGGY_ITERATORS, NAME, {
      entries: entries,
      keys: IS_SET ? values : createIter(KEY),
      values: values
    });
  }
}
function iterResult(done, value){
  return {value: value, done: !!done};
}
function isIterable(it){
  var O      = Object(it)
    , Symbol = global[SYMBOL]
    , hasExt = (Symbol && Symbol[ITERATOR] || FF_ITERATOR) in O;
  return hasExt || SYMBOL_ITERATOR in O || has(Iterators, classof(O));
}
function getIterator(it){
  var Symbol  = global[SYMBOL]
    , ext     = it[Symbol && Symbol[ITERATOR] || FF_ITERATOR]
    , getIter = ext || it[SYMBOL_ITERATOR] || Iterators[classof(it)];
  return assertObject(getIter.call(it));
}
function stepCall(fn, value, entries){
  return entries ? invoke(fn, value) : fn(value);
}
function checkDangerIterClosing(fn){
  var danger = true;
  var O = {
    next: function(){ throw 1 },
    'return': function(){ danger = false }
  };
  O[SYMBOL_ITERATOR] = returnThis;
  try {
    fn(O);
  } catch(e){}
  return danger;
}
function closeIterator(iterator){
  var ret = iterator['return'];
  if(ret !== undefined)ret.call(iterator);
}
function safeIterClose(exec, iterator){
  try {
    exec(iterator);
  } catch(e){
    closeIterator(iterator);
    throw e;
  }
}
function forOf(iterable, entries, fn, that){
  safeIterClose(function(iterator){
    var f = ctx(fn, that, entries ? 2 : 1)
      , step;
    while(!(step = iterator.next()).done)if(stepCall(f, step.value, entries) === false){
      return closeIterator(iterator);
    }
  }, getIterator(iterable));
}

/******************************************************************************
 * Module : es6.symbol                                                        *
 ******************************************************************************/

// ECMAScript 6 symbols shim
!function(TAG, SymbolRegistry, AllSymbols, setter){
  // 19.4.1.1 Symbol([description])
  if(!isNative(Symbol)){
    Symbol = function(description){
      assert(!(this instanceof Symbol), SYMBOL + ' is not a ' + CONSTRUCTOR);
      var tag = uid(description)
        , sym = set(create(Symbol[PROTOTYPE]), TAG, tag);
      AllSymbols[tag] = sym;
      DESC && setter && defineProperty(ObjectProto, tag, {
        configurable: true,
        set: function(value){
          hidden(this, tag, value);
        }
      });
      return sym;
    }
    hidden(Symbol[PROTOTYPE], TO_STRING, function(){
      return this[TAG];
    });
  }
  $define(GLOBAL + WRAP, {Symbol: Symbol});
  
  var symbolStatics = {
    // 19.4.2.1 Symbol.for(key)
    'for': function(key){
      return has(SymbolRegistry, key += '')
        ? SymbolRegistry[key]
        : SymbolRegistry[key] = Symbol(key);
    },
    // 19.4.2.4 Symbol.iterator
    iterator: SYMBOL_ITERATOR || getWellKnownSymbol(ITERATOR),
    // 19.4.2.5 Symbol.keyFor(sym)
    keyFor: part.call(keyOf, SymbolRegistry),
    // 19.4.2.10 Symbol.species
    species: SYMBOL_SPECIES,
    // 19.4.2.13 Symbol.toStringTag
    toStringTag: SYMBOL_TAG = getWellKnownSymbol(TO_STRING_TAG, true),
    // 19.4.2.14 Symbol.unscopables
    unscopables: SYMBOL_UNSCOPABLES,
    pure: safeSymbol,
    set: set,
    useSetter: function(){setter = true},
    useSimple: function(){setter = false}
  };
  // 19.4.2.2 Symbol.hasInstance
  // 19.4.2.3 Symbol.isConcatSpreadable
  // 19.4.2.6 Symbol.match
  // 19.4.2.8 Symbol.replace
  // 19.4.2.9 Symbol.search
  // 19.4.2.11 Symbol.split
  // 19.4.2.12 Symbol.toPrimitive
  forEach.call(array('hasInstance,isConcatSpreadable,match,replace,search,split,toPrimitive'),
    function(it){
      symbolStatics[it] = getWellKnownSymbol(it);
    }
  );
  $define(STATIC, SYMBOL, symbolStatics);
  
  setToStringTag(Symbol, SYMBOL);
  
  $define(STATIC + FORCED * !isNative(Symbol), OBJECT, {
    // 19.1.2.7 Object.getOwnPropertyNames(O)
    getOwnPropertyNames: function(it){
      var names = getNames(toObject(it)), result = [], key, i = 0;
      while(names.length > i)has(AllSymbols, key = names[i++]) || result.push(key);
      return result;
    },
    // 19.1.2.8 Object.getOwnPropertySymbols(O)
    getOwnPropertySymbols: function(it){
      var names = getNames(toObject(it)), result = [], key, i = 0;
      while(names.length > i)has(AllSymbols, key = names[i++]) && result.push(AllSymbols[key]);
      return result;
    }
  });
  
  // 20.2.1.9 Math[@@toStringTag]
  setToStringTag(Math, MATH, true);
  // 24.3.3 JSON[@@toStringTag]
  setToStringTag(global.JSON, 'JSON', true);
}(safeSymbol('tag'), {}, {}, true);

/******************************************************************************
 * Module : es6.object.statics                                                *
 ******************************************************************************/

!function(){
  var objectStatic = {
    // 19.1.3.1 Object.assign(target, source)
    assign: assign,
    // 19.1.3.10 Object.is(value1, value2)
    is: function(x, y){
      return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
    }
  };
  // 19.1.3.19 Object.setPrototypeOf(O, proto)
  // Works with __proto__ only. Old v8 can't works with null proto objects.
  '__proto__' in ObjectProto && function(buggy, set){
    try {
      set = ctx(call, getOwnDescriptor(ObjectProto, '__proto__').set, 2);
      set({}, ArrayProto);
    } catch(e){ buggy = true }
    objectStatic.setPrototypeOf = setPrototypeOf = setPrototypeOf || function(O, proto){
      assertObject(O);
      assert(proto === null || isObject(proto), proto, ": can't set as prototype!");
      if(buggy)O.__proto__ = proto;
      else set(O, proto);
      return O;
    }
  }();
  $define(STATIC, OBJECT, objectStatic);
}();

/******************************************************************************
 * Module : es6.object.prototype                                              *
 ******************************************************************************/

!function(tmp){
  // 19.1.3.6 Object.prototype.toString()
  tmp[SYMBOL_TAG] = DOT;
  if(cof(tmp) != DOT)hidden(ObjectProto, TO_STRING, function(){
    return '[object ' + classof(this) + ']';
  });
}({});

/******************************************************************************
 * Module : es6.object.statics-accept-primitives                              *
 ******************************************************************************/

!function(){
  // Object static methods accept primitives
  function wrapObjectMethod(key, MODE){
    var fn  = Object[key]
      , exp = core[OBJECT][key]
      , f   = 0
      , o   = {};
    if(!exp || isNative(exp)){
      o[key] = MODE == 1 ? function(it){
        return isObject(it) ? fn(it) : it;
      } : MODE == 2 ? function(it){
        return isObject(it) ? fn(it) : true;
      } : MODE == 3 ? function(it){
        return isObject(it) ? fn(it) : false;
      } : MODE == 4 ? function(it, key){
        return fn(toObject(it), key);
      } : function(it){
        return fn(toObject(it));
      };
      try { fn(DOT) }
      catch(e){ f = 1 }
      $define(STATIC + FORCED * f, OBJECT, o);
    }
  }
  wrapObjectMethod('freeze', 1);
  wrapObjectMethod('seal', 1);
  wrapObjectMethod('preventExtensions', 1);
  wrapObjectMethod('isFrozen', 2);
  wrapObjectMethod('isSealed', 2);
  wrapObjectMethod('isExtensible', 3);
  wrapObjectMethod('getOwnPropertyDescriptor', 4);
  wrapObjectMethod('getPrototypeOf');
  wrapObjectMethod('keys');
  wrapObjectMethod('getOwnPropertyNames');
}();

/******************************************************************************
 * Module : es6.function                                                      *
 ******************************************************************************/

!function(NAME){
  // 19.2.4.2 name
  NAME in FunctionProto || (DESC && defineProperty(FunctionProto, NAME, {
    configurable: true,
    get: function(){
      var match = String(this).match(/^\s*function ([^ (]*)/)
        , name  = match ? match[1] : '';
      has(this, NAME) || defineProperty(this, NAME, descriptor(5, name));
      return name;
    },
    set: function(value){
      has(this, NAME) || defineProperty(this, NAME, descriptor(0, value));
    }
  }));
}('name');

/******************************************************************************
 * Module : es6.number.constructor                                            *
 ******************************************************************************/

Number('0o1') && Number('0b1') || function(_Number, NumberProto){
  function toNumber(it){
    if(isObject(it))it = toPrimitive(it);
    if(typeof it == 'string' && it.length > 2 && it.charCodeAt(0) == 48){
      var binary = false;
      switch(it.charCodeAt(1)){
        case 66 : case 98  : binary = true;
        case 79 : case 111 : return parseInt(it.slice(2), binary ? 2 : 8);
      }
    } return +it;
  }
  function toPrimitive(it){
    var fn, val;
    if(isFunction(fn = it.valueOf) && !isObject(val = fn.call(it)))return val;
    if(isFunction(fn = it[TO_STRING]) && !isObject(val = fn.call(it)))return val;
    throw TypeError("Can't convert object to number");
  }
  Number = function Number(it){
    return this instanceof Number ? new _Number(toNumber(it)) : toNumber(it);
  }
  forEach.call(DESC ? getNames(_Number)
  : array('MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY'), function(key){
    key in Number || defineProperty(Number, key, getOwnDescriptor(_Number, key));
  });
  Number[PROTOTYPE] = NumberProto;
  NumberProto[CONSTRUCTOR] = Number;
  hidden(global, NUMBER, Number);
}(Number, Number[PROTOTYPE]);

/******************************************************************************
 * Module : es6.number.statics                                                *
 ******************************************************************************/

!function(isInteger){
  $define(STATIC, NUMBER, {
    // 20.1.2.1 Number.EPSILON
    EPSILON: pow(2, -52),
    // 20.1.2.2 Number.isFinite(number)
    isFinite: function(it){
      return typeof it == 'number' && isFinite(it);
    },
    // 20.1.2.3 Number.isInteger(number)
    isInteger: isInteger,
    // 20.1.2.4 Number.isNaN(number)
    isNaN: sameNaN,
    // 20.1.2.5 Number.isSafeInteger(number)
    isSafeInteger: function(number){
      return isInteger(number) && abs(number) <= MAX_SAFE_INTEGER;
    },
    // 20.1.2.6 Number.MAX_SAFE_INTEGER
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
    // 20.1.2.10 Number.MIN_SAFE_INTEGER
    MIN_SAFE_INTEGER: -MAX_SAFE_INTEGER,
    // 20.1.2.12 Number.parseFloat(string)
    parseFloat: parseFloat,
    // 20.1.2.13 Number.parseInt(string, radix)
    parseInt: parseInt
  });
// 20.1.2.3 Number.isInteger(number)
}(Number.isInteger || function(it){
  return !isObject(it) && isFinite(it) && floor(it) === it;
});

/******************************************************************************
 * Module : es6.math                                                          *
 ******************************************************************************/

// ECMAScript 6 shim
!function(){
  // 20.2.2.28 Math.sign(x)
  var E    = Math.E
    , exp  = Math.exp
    , log  = Math.log
    , sqrt = Math.sqrt
    , sign = Math.sign || function(x){
        return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
      };
  
  // 20.2.2.5 Math.asinh(x)
  function asinh(x){
    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
  }
  // 20.2.2.14 Math.expm1(x)
  function expm1(x){
    return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
  }
    
  $define(STATIC, MATH, {
    // 20.2.2.3 Math.acosh(x)
    acosh: function(x){
      return (x = +x) < 1 ? NaN : isFinite(x) ? log(x / E + sqrt(x + 1) * sqrt(x - 1) / E) + 1 : x;
    },
    // 20.2.2.5 Math.asinh(x)
    asinh: asinh,
    // 20.2.2.7 Math.atanh(x)
    atanh: function(x){
      return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
    },
    // 20.2.2.9 Math.cbrt(x)
    cbrt: function(x){
      return sign(x = +x) * pow(abs(x), 1 / 3);
    },
    // 20.2.2.11 Math.clz32(x)
    clz32: function(x){
      return (x >>>= 0) ? 32 - x[TO_STRING](2).length : 32;
    },
    // 20.2.2.12 Math.cosh(x)
    cosh: function(x){
      return (exp(x = +x) + exp(-x)) / 2;
    },
    // 20.2.2.14 Math.expm1(x)
    expm1: expm1,
    // 20.2.2.16 Math.fround(x)
    // TODO: fallback for IE9-
    fround: function(x){
      return new Float32Array([x])[0];
    },
    // 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
    hypot: function(value1, value2){
      var sum  = 0
        , len1 = arguments.length
        , len2 = len1
        , args = Array(len1)
        , larg = -Infinity
        , arg;
      while(len1--){
        arg = args[len1] = +arguments[len1];
        if(arg == Infinity || arg == -Infinity)return Infinity;
        if(arg > larg)larg = arg;
      }
      larg = arg || 1;
      while(len2--)sum += pow(args[len2] / larg, 2);
      return larg * sqrt(sum);
    },
    // 20.2.2.18 Math.imul(x, y)
    imul: function(x, y){
      var UInt16 = 0xffff
        , xn = +x
        , yn = +y
        , xl = UInt16 & xn
        , yl = UInt16 & yn;
      return 0 | xl * yl + ((UInt16 & xn >>> 16) * yl + xl * (UInt16 & yn >>> 16) << 16 >>> 0);
    },
    // 20.2.2.20 Math.log1p(x)
    log1p: function(x){
      return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);
    },
    // 20.2.2.21 Math.log10(x)
    log10: function(x){
      return log(x) / Math.LN10;
    },
    // 20.2.2.22 Math.log2(x)
    log2: function(x){
      return log(x) / Math.LN2;
    },
    // 20.2.2.28 Math.sign(x)
    sign: sign,
    // 20.2.2.30 Math.sinh(x)
    sinh: function(x){
      return (abs(x = +x) < 1) ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
    },
    // 20.2.2.33 Math.tanh(x)
    tanh: function(x){
      var a = expm1(x = +x)
        , b = expm1(-x);
      return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
    },
    // 20.2.2.34 Math.trunc(x)
    trunc: trunc
  });
}();

/******************************************************************************
 * Module : es6.string                                                        *
 ******************************************************************************/

!function(fromCharCode){
  function assertNotRegExp(it){
    if(cof(it) == REGEXP)throw TypeError();
  }
  
  $define(STATIC, STRING, {
    // 21.1.2.2 String.fromCodePoint(...codePoints)
    fromCodePoint: function(x){
      var res = []
        , len = arguments.length
        , i   = 0
        , code
      while(len > i){
        code = +arguments[i++];
        if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
        res.push(code < 0x10000
          ? fromCharCode(code)
          : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
        );
      } return res.join('');
    },
    // 21.1.2.4 String.raw(callSite, ...substitutions)
    raw: function(callSite){
      var raw = toObject(callSite.raw)
        , len = toLength(raw.length)
        , sln = arguments.length
        , res = []
        , i   = 0;
      while(len > i){
        res.push(String(raw[i++]));
        if(i < sln)res.push(String(arguments[i]));
      } return res.join('');
    }
  });
  
  $define(PROTO, STRING, {
    // 21.1.3.3 String.prototype.codePointAt(pos)
    codePointAt: createPointAt(false),
    // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
    endsWith: function(searchString /*, endPosition = @length */){
      assertNotRegExp(searchString);
      var that = String(assertDefined(this))
        , endPosition = arguments[1]
        , len = toLength(that.length)
        , end = endPosition === undefined ? len : min(toLength(endPosition), len);
      searchString += '';
      return that.slice(end - searchString.length, end) === searchString;
    },
    // 21.1.3.7 String.prototype.includes(searchString, position = 0)
    includes: function(searchString /*, position = 0 */){
      assertNotRegExp(searchString);
      return !!~String(assertDefined(this)).indexOf(searchString, arguments[1]);
    },
    // 21.1.3.13 String.prototype.repeat(count)
    repeat: function(count){
      var str = String(assertDefined(this))
        , res = ''
        , n   = toInteger(count);
      if(0 > n || n == Infinity)throw RangeError("Count can't be negative");
      for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
      return res;
    },
    // 21.1.3.18 String.prototype.startsWith(searchString [, position ])
    startsWith: function(searchString /*, position = 0 */){
      assertNotRegExp(searchString);
      var that  = String(assertDefined(this))
        , index = toLength(min(arguments[1], that.length));
      searchString += '';
      return that.slice(index, index + searchString.length) === searchString;
    }
  });
}(String.fromCharCode);

/******************************************************************************
 * Module : es6.array.statics                                                 *
 ******************************************************************************/

!function(){
  $define(STATIC + FORCED * checkDangerIterClosing(Array.from), ARRAY, {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
      var O       = Object(assertDefined(arrayLike))
        , mapfn   = arguments[1]
        , mapping = mapfn !== undefined
        , f       = mapping ? ctx(mapfn, arguments[2], 2) : undefined
        , index   = 0
        , length, result, step;
      if(isIterable(O)){
        result = new (generic(this, Array));
        safeIterClose(function(iterator){
          for(; !(step = iterator.next()).done; index++){
            result[index] = mapping ? f(step.value, index) : step.value;
          }
        }, getIterator(O));
      } else {
        result = new (generic(this, Array))(length = toLength(O.length));
        for(; length > index; index++){
          result[index] = mapping ? f(O[index], index) : O[index];
        }
      }
      result.length = index;
      return result;
    }
  });
  
  $define(STATIC, ARRAY, {
    // 22.1.2.3 Array.of( ...items)
    of: function(/* ...args */){
      var index  = 0
        , length = arguments.length
        , result = new (generic(this, Array))(length);
      while(length > index)result[index] = arguments[index++];
      result.length = length;
      return result;
    }
  });
  
  setSpecies(Array);
}();

/******************************************************************************
 * Module : es6.array.prototype                                               *
 ******************************************************************************/

!function(){
  $define(PROTO, ARRAY, {
    // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
    copyWithin: function(target /* = 0 */, start /* = 0, end = @length */){
      var O     = Object(assertDefined(this))
        , len   = toLength(O.length)
        , to    = toIndex(target, len)
        , from  = toIndex(start, len)
        , end   = arguments[2]
        , fin   = end === undefined ? len : toIndex(end, len)
        , count = min(fin - from, len - to)
        , inc   = 1;
      if(from < to && to < from + count){
        inc  = -1;
        from = from + count - 1;
        to   = to + count - 1;
      }
      while(count-- > 0){
        if(from in O)O[to] = O[from];
        else delete O[to];
        to += inc;
        from += inc;
      } return O;
    },
    // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
    fill: function(value /*, start = 0, end = @length */){
      var O      = Object(assertDefined(this))
        , length = toLength(O.length)
        , index  = toIndex(arguments[1], length)
        , end    = arguments[2]
        , endPos = end === undefined ? length : toIndex(end, length);
      while(endPos > index)O[index++] = value;
      return O;
    },
    // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
    find: createArrayMethod(5),
    // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
    findIndex: createArrayMethod(6)
  });
  
  if(framework){
    // 22.1.3.31 Array.prototype[@@unscopables]
    forEach.call(array('find,findIndex,fill,copyWithin,entries,keys,values'), function(it){
      ArrayUnscopables[it] = true;
    });
    SYMBOL_UNSCOPABLES in ArrayProto || hidden(ArrayProto, SYMBOL_UNSCOPABLES, ArrayUnscopables);
  }
}();

/******************************************************************************
 * Module : es6.iterators                                                     *
 ******************************************************************************/

!function(at){
  // 22.1.3.4 Array.prototype.entries()
  // 22.1.3.13 Array.prototype.keys()
  // 22.1.3.29 Array.prototype.values()
  // 22.1.3.30 Array.prototype[@@iterator]()
  defineStdIterators(Array, ARRAY, function(iterated, kind){
    set(this, ITER, {o: toObject(iterated), i: 0, k: kind});
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
  }, function(){
    var iter  = this[ITER]
      , O     = iter.o
      , kind  = iter.k
      , index = iter.i++;
    if(!O || index >= O.length){
      iter.o = undefined;
      return iterResult(1);
    }
    if(kind == KEY)  return iterResult(0, index);
    if(kind == VALUE)return iterResult(0, O[index]);
                     return iterResult(0, [index, O[index]]);
  }, VALUE);
  
  // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
  Iterators[ARGUMENTS] = Iterators[ARRAY];
  
  // 21.1.3.27 String.prototype[@@iterator]()
  defineStdIterators(String, STRING, function(iterated){
    set(this, ITER, {o: String(iterated), i: 0});
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
  }, function(){
    var iter  = this[ITER]
      , O     = iter.o
      , index = iter.i
      , point;
    if(index >= O.length)return iterResult(1);
    point = at.call(O, index);
    iter.i += point.length;
    return iterResult(0, point);
  });
}(createPointAt(true));

/******************************************************************************
 * Module : es6.regexp                                                        *
 ******************************************************************************/

DESC && !function(RegExpProto, _RegExp){  
  // RegExp allows a regex with flags as the pattern
  if(!function(){try{return RegExp(/a/g, 'i') == '/a/i'}catch(e){}}()){
    RegExp = function RegExp(pattern, flags){
      return new _RegExp(cof(pattern) == REGEXP && flags !== undefined
        ? pattern.source : pattern, flags);
    }
    forEach.call(getNames(_RegExp), function(key){
      key in RegExp || defineProperty(RegExp, key, {
        configurable: true,
        get: function(){ return _RegExp[key] },
        set: function(it){ _RegExp[key] = it }
      });
    });
    RegExpProto[CONSTRUCTOR] = RegExp;
    RegExp[PROTOTYPE] = RegExpProto;
    hidden(global, REGEXP, RegExp);
  }
  
  // 21.2.5.3 get RegExp.prototype.flags()
  if(/./g.flags != 'g')defineProperty(RegExpProto, 'flags', {
    configurable: true,
    get: createReplacer(/^.*\/(\w*)$/, '$1')
  });
  
  setSpecies(RegExp);
}(RegExp[PROTOTYPE], RegExp);

/******************************************************************************
 * Module : web.immediate                                                     *
 ******************************************************************************/

// setImmediate shim
// Node.js 0.9+ & IE10+ has setImmediate, else:
isFunction(setImmediate) && isFunction(clearImmediate) || function(ONREADYSTATECHANGE){
  var postMessage      = global.postMessage
    , addEventListener = global.addEventListener
    , MessageChannel   = global.MessageChannel
    , counter          = 0
    , queue            = {}
    , defer, channel, port;
  setImmediate = function(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(isFunction(fn) ? fn : Function(fn), args);
    }
    defer(counter);
    return counter;
  }
  clearImmediate = function(id){
    delete queue[id];
  }
  function run(id){
    if(has(queue, id)){
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  }
  function listner(event){
    run(event.data);
  }
  // Node.js 0.8-
  if(NODE){
    defer = function(id){
      nextTick(part.call(run, id));
    }
  // Modern browsers, skip implementation for WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is object
  } else if(addEventListener && isFunction(postMessage) && !global.importScripts){
    defer = function(id){
      postMessage(id, '*');
    }
    addEventListener('message', listner, false);
  // WebWorkers
  } else if(isFunction(MessageChannel)){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // IE8-
  } else if(document && ONREADYSTATECHANGE in document[CREATE_ELEMENT]('script')){
    defer = function(id){
      html.appendChild(document[CREATE_ELEMENT]('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run(id);
      }
    }
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(run, 0, id);
    }
  }
}('onreadystatechange');
$define(GLOBAL + BIND, {
  setImmediate:   setImmediate,
  clearImmediate: clearImmediate
});

/******************************************************************************
 * Module : es6.promise                                                       *
 ******************************************************************************/

// ES6 promises shim
// Based on https://github.com/getify/native-promise-only/
!function(Promise, test){
  isFunction(Promise) && isFunction(Promise.resolve)
  && Promise.resolve(test = new Promise(function(){})) == test
  || function(asap, RECORD){
    function isThenable(it){
      var then;
      if(isObject(it))then = it.then;
      return isFunction(then) ? then : false;
    }
    function handledRejectionOrHasOnRejected(promise){
      var record = promise[RECORD]
        , chain  = record.c
        , i      = 0
        , react;
      if(record.h)return true;
      while(chain.length > i){
        react = chain[i++];
        if(react.fail || handledRejectionOrHasOnRejected(react.P))return true;
      }
    }
    function notify(record, reject){
      var chain = record.c;
      if(reject || chain.length)asap(function(){
        var promise = record.p
          , value   = record.v
          , ok      = record.s == 1
          , i       = 0;
        if(reject && !handledRejectionOrHasOnRejected(promise)){
          setTimeout(function(){
            if(!handledRejectionOrHasOnRejected(promise)){
              if(NODE){
                if(!process.emit('unhandledRejection', value, promise)){
                  // default node.js behavior
                }
              } else if(isFunction(console.error)){
                console.error('Unhandled promise rejection', value);
              }
            }
          }, 1e3);
        } else while(chain.length > i)!function(react){
          var cb = ok ? react.ok : react.fail
            , ret, then;
          try {
            if(cb){
              if(!ok)record.h = true;
              ret = cb === true ? value : cb(value);
              if(ret === react.P){
                react.rej(TypeError(PROMISE + '-chain cycle'));
              } else if(then = isThenable(ret)){
                then.call(ret, react.res, react.rej);
              } else react.res(ret);
            } else react.rej(value);
          } catch(err){
            react.rej(err);
          }
        }(chain[i++]);
        chain.length = 0;
      });
    }
    function resolve(value){
      var record = this
        , then, wrapper;
      if(record.d)return;
      record.d = true;
      record = record.r || record; // unwrap
      try {
        if(then = isThenable(value)){
          wrapper = {r: record, d: false}; // wrap
          then.call(value, ctx(resolve, wrapper, 1), ctx(reject, wrapper, 1));
        } else {
          record.v = value;
          record.s = 1;
          notify(record);
        }
      } catch(err){
        reject.call(wrapper || {r: record, d: false}, err); // wrap
      }
    }
    function reject(value){
      var record = this;
      if(record.d)return;
      record.d = true;
      record = record.r || record; // unwrap
      record.v = value;
      record.s = 2;
      notify(record, true);
    }
    function getConstructor(C){
      var S = assertObject(C)[SYMBOL_SPECIES];
      return S != undefined ? S : C;
    }
    // 25.4.3.1 Promise(executor)
    Promise = function(executor){
      assertFunction(executor);
      assertInstance(this, Promise, PROMISE);
      var record = {
        p: this,      // promise
        c: [],        // chain
        s: 0,         // state
        d: false,     // done
        v: undefined, // value
        h: false      // handled rejection
      };
      hidden(this, RECORD, record);
      try {
        executor(ctx(resolve, record, 1), ctx(reject, record, 1));
      } catch(err){
        reject.call(record, err);
      }
    }
    assignHidden(Promise[PROTOTYPE], {
      // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
      then: function(onFulfilled, onRejected){
        var S = assertObject(assertObject(this)[CONSTRUCTOR])[SYMBOL_SPECIES];
        var react = {
          ok:   isFunction(onFulfilled) ? onFulfilled : true,
          fail: isFunction(onRejected)  ? onRejected  : false
        } , P = react.P = new (S != undefined ? S : Promise)(function(resolve, reject){
          react.res = assertFunction(resolve);
          react.rej = assertFunction(reject);
        }), record = this[RECORD];
        record.c.push(react);
        record.s && notify(record);
        return P;
      },
      // 25.4.5.1 Promise.prototype.catch(onRejected)
      'catch': function(onRejected){
        return this.then(undefined, onRejected);
      }
    });
    assignHidden(Promise, {
      // 25.4.4.1 Promise.all(iterable)
      all: function(iterable){
        var Promise = getConstructor(this)
          , values  = [];
        return new Promise(function(resolve, reject){
          forOf(iterable, false, push, values);
          var remaining = values.length
            , results   = Array(remaining);
          if(remaining)forEach.call(values, function(promise, index){
            Promise.resolve(promise).then(function(value){
              results[index] = value;
              --remaining || resolve(results);
            }, reject);
          });
          else resolve(results);
        });
      },
      // 25.4.4.4 Promise.race(iterable)
      race: function(iterable){
        var Promise = getConstructor(this);
        return new Promise(function(resolve, reject){
          forOf(iterable, false, function(promise){
            Promise.resolve(promise).then(resolve, reject);
          });
        });
      },
      // 25.4.4.5 Promise.reject(r)
      reject: function(r){
        return new (getConstructor(this))(function(resolve, reject){
          reject(r);
        });
      },
      // 25.4.4.6 Promise.resolve(x)
      resolve: function(x){
        return isObject(x) && RECORD in x && getPrototypeOf(x) === this[PROTOTYPE]
          ? x : new (getConstructor(this))(function(resolve, reject){
            resolve(x);
          });
      }
    });
  }(nextTick || setImmediate, safeSymbol('record'));
  setToStringTag(Promise, PROMISE);
  setSpecies(Promise);
  $define(GLOBAL + FORCED * !isNative(Promise), {Promise: Promise});
}(global[PROMISE]);

/******************************************************************************
 * Module : es6.collections                                                   *
 ******************************************************************************/

// ECMAScript 6 collections shim
!function(){
  var UID   = safeSymbol('uid')
    , O1    = safeSymbol('O1')
    , WEAK  = safeSymbol('weak')
    , LEAK  = safeSymbol('leak')
    , LAST  = safeSymbol('last')
    , FIRST = safeSymbol('first')
    , SIZE  = DESC ? safeSymbol('size') : 'size'
    , uid   = 0
    , tmp   = {};
  
  function getCollection(C, NAME, methods, commonMethods, isMap, isWeak){
    var ADDER = isMap ? 'set' : 'add'
      , proto = C && C[PROTOTYPE]
      , O     = {};
    function initFromIterable(that, iterable){
      if(iterable != undefined)forOf(iterable, isMap, that[ADDER], that);
      return that;
    }
    function fixSVZ(key, chain){
      var method = proto[key];
      if(framework)proto[key] = function(a, b){
        var result = method.call(this, a === 0 ? 0 : a, b);
        return chain ? this : result;
      };
    }
    if(!isNative(C) || !(isWeak || (!BUGGY_ITERATORS && has(proto, FOR_EACH) && has(proto, 'entries')))){
      // create collection constructor
      C = isWeak
        ? function(iterable){
            assertInstance(this, C, NAME);
            set(this, UID, uid++);
            initFromIterable(this, iterable);
          }
        : function(iterable){
            var that = this;
            assertInstance(that, C, NAME);
            set(that, O1, create(null));
            set(that, SIZE, 0);
            set(that, LAST, undefined);
            set(that, FIRST, undefined);
            initFromIterable(that, iterable);
          };
      assignHidden(assignHidden(C[PROTOTYPE], methods), commonMethods);
      isWeak || !DESC || defineProperty(C[PROTOTYPE], 'size', {get: function(){
        return assertDefined(this[SIZE]);
      }});
    } else {
      var Native = C
        , inst   = new C
        , chain  = inst[ADDER](isWeak ? {} : -0, 1)
        , buggyZero;
      // wrap to init collections from iterable
      if(checkDangerIterClosing(function(O){ new C(O) })){
        C = function(iterable){
          assertInstance(this, C, NAME);
          return initFromIterable(new Native, iterable);
        }
        C[PROTOTYPE] = proto;
        if(framework)proto[CONSTRUCTOR] = C;
      }
      isWeak || inst[FOR_EACH](function(val, key){
        buggyZero = 1 / key === -Infinity;
      });
      // fix converting -0 key to +0
      if(buggyZero){
        fixSVZ('delete');
        fixSVZ('has');
        isMap && fixSVZ('get');
      }
      // + fix .add & .set for chaining
      if(buggyZero || chain !== inst)fixSVZ(ADDER, true);
    }
    setToStringTag(C, NAME);
    setSpecies(C);
    
    O[NAME] = C;
    $define(GLOBAL + WRAP + FORCED * !isNative(C), O);
    
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    isWeak || defineStdIterators(C, NAME, function(iterated, kind){
      set(this, ITER, {o: iterated, k: kind});
    }, function(){
      var iter  = this[ITER]
        , kind  = iter.k
        , entry = iter.l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!iter.o || !(iter.l = entry = entry ? entry.n : iter.o[FIRST])){
        // or finish the iteration
        iter.o = undefined;
        return iterResult(1);
      }
      // return step by kind
      if(kind == KEY)  return iterResult(0, entry.k);
      if(kind == VALUE)return iterResult(0, entry.v);
                       return iterResult(0, [entry.k, entry.v]);   
    }, isMap ? KEY+VALUE : VALUE, !isMap);
    
    return C;
  }
  
  function fastKey(it, create){
    // return primitive with prefix
    if(!isObject(it))return (typeof it == 'string' ? 'S' : 'P') + it;
    // can't set id to frozen object
    if(isFrozen(it))return 'F';
    if(!has(it, UID)){
      // not necessary to add id
      if(!create)return 'E';
      // add missing object id
      hidden(it, UID, ++uid);
    // return object id with prefix
    } return 'O' + it[UID];
  }
  function getEntry(that, key){
    // fast case
    var index = fastKey(key), entry;
    if(index != 'F')return that[O1][index];
    // frozen object case
    for(entry = that[FIRST]; entry; entry = entry.n){
      if(entry.k == key)return entry;
    }
  }
  function def(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry)entry.v = value;
    // create new entry
    else {
      that[LAST] = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that[LAST],          // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that[FIRST])that[FIRST] = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index != 'F')that[O1][index] = entry;
    } return that;
  }

  var collectionMethods = {
    // 23.1.3.1 Map.prototype.clear()
    // 23.2.3.2 Set.prototype.clear()
    clear: function(){
      for(var that = this, data = that[O1], entry = that[FIRST]; entry; entry = entry.n){
        entry.r = true;
        if(entry.p)entry.p = entry.p.n = undefined;
        delete data[entry.i];
      }
      that[FIRST] = that[LAST] = undefined;
      that[SIZE] = 0;
    },
    // 23.1.3.3 Map.prototype.delete(key)
    // 23.2.3.4 Set.prototype.delete(value)
    'delete': function(key){
      var that  = this
        , entry = getEntry(that, key);
      if(entry){
        var next = entry.n
          , prev = entry.p;
        delete that[O1][entry.i];
        entry.r = true;
        if(prev)prev.n = next;
        if(next)next.p = prev;
        if(that[FIRST] == entry)that[FIRST] = next;
        if(that[LAST] == entry)that[LAST] = prev;
        that[SIZE]--;
      } return !!entry;
    },
    // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
    // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
    forEach: function(callbackfn /*, that = undefined */){
      var f = ctx(callbackfn, arguments[1], 3)
        , entry;
      while(entry = entry ? entry.n : this[FIRST]){
        f(entry.v, entry.k, this);
        // revert to the last existing entry
        while(entry && entry.r)entry = entry.p;
      }
    },
    // 23.1.3.7 Map.prototype.has(key)
    // 23.2.3.7 Set.prototype.has(value)
    has: function(key){
      return !!getEntry(this, key);
    }
  }
  
  // 23.1 Map Objects
  Map = getCollection(Map, MAP, {
    // 23.1.3.6 Map.prototype.get(key)
    get: function(key){
      var entry = getEntry(this, key);
      return entry && entry.v;
    },
    // 23.1.3.9 Map.prototype.set(key, value)
    set: function(key, value){
      return def(this, key === 0 ? 0 : key, value);
    }
  }, collectionMethods, true);
  
  // 23.2 Set Objects
  Set = getCollection(Set, SET, {
    // 23.2.3.1 Set.prototype.add(value)
    add: function(value){
      return def(this, value = value === 0 ? 0 : value, value);
    }
  }, collectionMethods);
  
  function defWeak(that, key, value){
    if(isFrozen(assertObject(key)))leakStore(that).set(key, value);
    else {
      has(key, WEAK) || hidden(key, WEAK, {});
      key[WEAK][that[UID]] = value;
    } return that;
  }
  function leakStore(that){
    return that[LEAK] || hidden(that, LEAK, new Map)[LEAK];
  }
  
  var weakMethods = {
    // 23.3.3.2 WeakMap.prototype.delete(key)
    // 23.4.3.3 WeakSet.prototype.delete(value)
    'delete': function(key){
      if(!isObject(key))return false;
      if(isFrozen(key))return leakStore(this)['delete'](key);
      return has(key, WEAK) && has(key[WEAK], this[UID]) && delete key[WEAK][this[UID]];
    },
    // 23.3.3.4 WeakMap.prototype.has(key)
    // 23.4.3.4 WeakSet.prototype.has(value)
    has: function(key){
      if(!isObject(key))return false;
      if(isFrozen(key))return leakStore(this).has(key);
      return has(key, WEAK) && has(key[WEAK], this[UID]);
    }
  };
  
  // 23.3 WeakMap Objects
  WeakMap = getCollection(WeakMap, WEAKMAP, {
    // 23.3.3.3 WeakMap.prototype.get(key)
    get: function(key){
      if(isObject(key)){
        if(isFrozen(key))return leakStore(this).get(key);
        if(has(key, WEAK))return key[WEAK][this[UID]];
      }
    },
    // 23.3.3.5 WeakMap.prototype.set(key, value)
    set: function(key, value){
      return defWeak(this, key, value);
    }
  }, weakMethods, true, true);
  
  // IE11 WeakMap frozen keys fix
  if(framework && new WeakMap().set(Object.freeze(tmp), 7).get(tmp) != 7){
    forEach.call(array('delete,has,get,set'), function(key){
      var method = WeakMap[PROTOTYPE][key];
      WeakMap[PROTOTYPE][key] = function(a, b){
        // store frozen objects on leaky map
        if(isObject(a) && isFrozen(a)){
          var result = leakStore(this)[key](a, b);
          return key == 'set' ? this : result;
        // store all the rest on native weakmap
        } return method.call(this, a, b);
      };
    });
  }
  
  // 23.4 WeakSet Objects
  WeakSet = getCollection(WeakSet, WEAKSET, {
    // 23.4.3.1 WeakSet.prototype.add(value)
    add: function(value){
      return defWeak(this, value, true);
    }
  }, weakMethods, false, true);
}();

/******************************************************************************
 * Module : es6.reflect                                                       *
 ******************************************************************************/

!function(){
  function Enumerate(iterated){
    var keys = [], key;
    for(key in iterated)keys.push(key);
    set(this, ITER, {o: iterated, a: keys, i: 0});
  }
  createIterator(Enumerate, OBJECT, function(){
    var iter = this[ITER]
      , keys = iter.a
      , key;
    do {
      if(iter.i >= keys.length)return iterResult(1);
    } while(!((key = keys[iter.i++]) in iter.o));
    return iterResult(0, key);
  });
  
  function wrap(fn){
    return function(it){
      assertObject(it);
      try {
        return fn.apply(undefined, arguments), true;
      } catch(e){
        return false;
      }
    }
  }
  
  function reflectGet(target, propertyKey/*, receiver*/){
    var receiver = arguments.length < 3 ? target : arguments[2]
      , desc = getOwnDescriptor(assertObject(target), propertyKey), proto;
    if(desc)return has(desc, 'value')
      ? desc.value
      : desc.get === undefined
        ? undefined
        : desc.get.call(receiver);
    return isObject(proto = getPrototypeOf(target))
      ? reflectGet(proto, propertyKey, receiver)
      : undefined;
  }
  function reflectSet(target, propertyKey, V/*, receiver*/){
    var receiver = arguments.length < 4 ? target : arguments[3]
      , ownDesc  = getOwnDescriptor(assertObject(target), propertyKey)
      , existingDescriptor, proto;
    if(!ownDesc){
      if(isObject(proto = getPrototypeOf(target))){
        return reflectSet(proto, propertyKey, V, receiver);
      }
      ownDesc = descriptor(0);
    }
    if(has(ownDesc, 'value')){
      if(ownDesc.writable === false || !isObject(receiver))return false;
      existingDescriptor = getOwnDescriptor(receiver, propertyKey) || descriptor(0);
      existingDescriptor.value = V;
      return defineProperty(receiver, propertyKey, existingDescriptor), true;
    }
    return ownDesc.set === undefined
      ? false
      : (ownDesc.set.call(receiver, V), true);
  }
  var isExtensible = Object.isExtensible || returnIt;
  
  var reflect = {
    // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
    apply: ctx(call, apply, 3),
    // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
    construct: function(target, argumentsList /*, newTarget*/){
      var proto    = assertFunction(arguments.length < 3 ? target : arguments[2])[PROTOTYPE]
        , instance = create(isObject(proto) ? proto : ObjectProto)
        , result   = apply.call(target, instance, argumentsList);
      return isObject(result) ? result : instance;
    },
    // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
    defineProperty: wrap(defineProperty),
    // 26.1.4 Reflect.deleteProperty(target, propertyKey)
    deleteProperty: function(target, propertyKey){
      var desc = getOwnDescriptor(assertObject(target), propertyKey);
      return desc && !desc.configurable ? false : delete target[propertyKey];
    },
    // 26.1.5 Reflect.enumerate(target)
    enumerate: function(target){
      return new Enumerate(assertObject(target));
    },
    // 26.1.6 Reflect.get(target, propertyKey [, receiver])
    get: reflectGet,
    // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
    getOwnPropertyDescriptor: function(target, propertyKey){
      return getOwnDescriptor(assertObject(target), propertyKey);
    },
    // 26.1.8 Reflect.getPrototypeOf(target)
    getPrototypeOf: function(target){
      return getPrototypeOf(assertObject(target));
    },
    // 26.1.9 Reflect.has(target, propertyKey)
    has: function(target, propertyKey){
      return propertyKey in target;
    },
    // 26.1.10 Reflect.isExtensible(target)
    isExtensible: function(target){
      return !!isExtensible(assertObject(target));
    },
    // 26.1.11 Reflect.ownKeys(target)
    ownKeys: ownKeys,
    // 26.1.12 Reflect.preventExtensions(target)
    preventExtensions: wrap(Object.preventExtensions || returnIt),
    // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
    set: reflectSet
  }
  // 26.1.14 Reflect.setPrototypeOf(target, proto)
  if(setPrototypeOf)reflect.setPrototypeOf = function(target, proto){
    return setPrototypeOf(assertObject(target), proto), true;
  };
  
  $define(GLOBAL, {Reflect: {}});
  $define(STATIC, 'Reflect', reflect);
}();

/******************************************************************************
 * Module : es7.proposals                                                     *
 ******************************************************************************/

!function(){
  $define(PROTO, ARRAY, {
    // https://github.com/domenic/Array.prototype.includes
    includes: createArrayContains(true)
  });
  $define(PROTO, STRING, {
    // https://github.com/mathiasbynens/String.prototype.at
    at: createPointAt(true)
  });
  
  function createObjectToArray(isEntries){
    return function(object){
      var O      = toObject(object)
        , keys   = getKeys(object)
        , length = keys.length
        , i      = 0
        , result = Array(length)
        , key;
      if(isEntries)while(length > i)result[i] = [key = keys[i++], O[key]];
      else while(length > i)result[i] = O[keys[i++]];
      return result;
    }
  }
  $define(STATIC, OBJECT, {
    // https://gist.github.com/WebReflection/9353781
    getOwnPropertyDescriptors: function(object){
      var O      = toObject(object)
        , result = {};
      forEach.call(ownKeys(O), function(key){
        defineProperty(result, key, descriptor(0, getOwnDescriptor(O, key)));
      });
      return result;
    },
    // https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-04/apr-9.md#51-objectentries-objectvalues
    values:  createObjectToArray(false),
    entries: createObjectToArray(true)
  });
  $define(STATIC, REGEXP, {
    // https://gist.github.com/kangax/9698100
    escape: createReplacer(/([\\\-[\]{}()*+?.,^$|])/g, '\\$1', true)
  });
}();

/******************************************************************************
 * Module : es7.abstract-refs                                                 *
 ******************************************************************************/

// https://github.com/zenparsing/es-abstract-refs
!function(REFERENCE){
  REFERENCE_GET = getWellKnownSymbol(REFERENCE+'Get', true);
  var REFERENCE_SET = getWellKnownSymbol(REFERENCE+SET, true)
    , REFERENCE_DELETE = getWellKnownSymbol(REFERENCE+'Delete', true);
  
  $define(STATIC, SYMBOL, {
    referenceGet: REFERENCE_GET,
    referenceSet: REFERENCE_SET,
    referenceDelete: REFERENCE_DELETE
  });
  
  hidden(FunctionProto, REFERENCE_GET, returnThis);
  
  function setMapMethods(Constructor){
    if(Constructor){
      var MapProto = Constructor[PROTOTYPE];
      hidden(MapProto, REFERENCE_GET, MapProto.get);
      hidden(MapProto, REFERENCE_SET, MapProto.set);
      hidden(MapProto, REFERENCE_DELETE, MapProto['delete']);
    }
  }
  setMapMethods(Map);
  setMapMethods(WeakMap);
}('reference');

/******************************************************************************
 * Module : js.array.statics                                                  *
 ******************************************************************************/

// JavaScript 1.6 / Strawman array statics shim
!function(arrayStatics){
  function setArrayStatics(keys, length){
    forEach.call(array(keys), function(key){
      if(key in ArrayProto)arrayStatics[key] = ctx(call, ArrayProto[key], length);
    });
  }
  setArrayStatics('pop,reverse,shift,keys,values,entries', 1);
  setArrayStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
  setArrayStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +
                  'reduce,reduceRight,copyWithin,fill,turn');
  $define(STATIC, ARRAY, arrayStatics);
}({});

/******************************************************************************
 * Module : web.dom.itarable                                                  *
 ******************************************************************************/

!function(NodeList){
  if(framework && NodeList && !(SYMBOL_ITERATOR in NodeList[PROTOTYPE])){
    hidden(NodeList[PROTOTYPE], SYMBOL_ITERATOR, Iterators[ARRAY]);
  }
  Iterators.NodeList = Iterators[ARRAY];
}(global.NodeList);
}(typeof self != 'undefined' && self.Math === Math ? self : Function('return this')(), true);
},{}],3:[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var iteratorSymbol =
    typeof Symbol === "function" && Symbol.iterator || "@@iterator";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    return new Generator(innerFn, outerFn, self || null, tryLocsList || []);
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = "GeneratorFunction";

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    genFun.__proto__ = GeneratorFunctionPrototype;
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    return new Promise(function(resolve, reject) {
      var generator = wrap(innerFn, outerFn, self, tryLocsList);
      var callNext = step.bind(generator.next);
      var callThrow = step.bind(generator["throw"]);

      function step(arg) {
        var record = tryCatch(this, null, arg);
        if (record.type === "throw") {
          reject(record.arg);
          return;
        }

        var info = record.arg;
        if (info.done) {
          resolve(info.value);
        } else {
          Promise.resolve(info.value).then(callNext, callThrow);
        }
      }

      callNext();
    });
  };

  function Generator(innerFn, outerFn, self, tryLocsList) {
    var generator = outerFn ? Object.create(outerFn.prototype) : this;
    var context = new Context(tryLocsList);
    var state = GenStateSuspendedStart;

    function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var record = tryCatch(
            delegate.iterator[method],
            delegate.iterator,
            arg
          );

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;

            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedStart &&
              typeof arg !== "undefined") {
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
            throw new TypeError(
              "attempt to send " + JSON.stringify(arg) + " to newborn generator"
            );
          }

          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            delete context.sent;
          }

        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }

        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }

        } else if (record.type === "throw") {
          state = GenStateCompleted;

          if (method === "next") {
            context.dispatchException(record.arg);
          } else {
            arg = record.arg;
          }
        }
      }
    }

    generator.next = invoke.bind(generator, "next");
    generator["throw"] = invoke.bind(generator, "throw");
    generator["return"] = invoke.bind(generator, "return");

    return generator;
  }

  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset();
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function() {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      // Pre-initialize at least 20 temporary variables to enable hidden
      // class optimizations for simple generators.
      for (var tempIndex = 0, tempName;
           hasOwn.call(this, tempName = "t" + tempIndex) || tempIndex < 20;
           ++tempIndex) {
        this[tempName] = null;
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg < finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          return this.complete(entry.completion, entry.afterLoc);
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window : this
);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9iYWJlbC9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItYmFiZWwvcnVudGltZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID1cbiAgICB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHJldHVybiBuZXcgR2VuZXJhdG9yKGlubmVyRm4sIG91dGVyRm4sIHNlbGYgfHwgbnVsbCwgdHJ5TG9jc0xpc3QgfHwgW10pO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuZXJhdG9yID0gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCk7XG4gICAgICB2YXIgY2FsbE5leHQgPSBzdGVwLmJpbmQoZ2VuZXJhdG9yLm5leHQpO1xuICAgICAgdmFyIGNhbGxUaHJvdyA9IHN0ZXAuYmluZChnZW5lcmF0b3JbXCJ0aHJvd1wiXSk7XG5cbiAgICAgIGZ1bmN0aW9uIHN0ZXAoYXJnKSB7XG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaCh0aGlzLCBudWxsLCBhcmcpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICByZXNvbHZlKGluZm8udmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFByb21pc2UucmVzb2x2ZShpbmZvLnZhbHVlKS50aGVuKGNhbGxOZXh0LCBjYWxsVGhyb3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGxOZXh0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGdlbmVyYXRvciA9IG91dGVyRm4gPyBPYmplY3QuY3JlYXRlKG91dGVyRm4ucHJvdG90eXBlKSA6IHRoaXM7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCk7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSxcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yLFxuICAgICAgICAgICAgYXJnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gTGlrZSByZXR1cm5pbmcgZ2VuZXJhdG9yLnRocm93KHVuY2F1Z2h0KSwgYnV0IHdpdGhvdXQgdGhlXG4gICAgICAgICAgICAvLyBvdmVyaGVhZCBvZiBhbiBleHRyYSBmdW5jdGlvbiBjYWxsLlxuICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVsZWdhdGUgZ2VuZXJhdG9yIHJhbiBhbmQgaGFuZGxlZCBpdHMgb3duIGV4Y2VwdGlvbnMgc29cbiAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHdoYXQgdGhlIG1ldGhvZCB3YXMsIHdlIGNvbnRpbnVlIGFzIGlmIGl0IGlzXG4gICAgICAgICAgLy8gXCJuZXh0XCIgd2l0aCBhbiB1bmRlZmluZWQgYXJnLlxuICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIGFyZyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgXCJhdHRlbXB0IHRvIHNlbmQgXCIgKyBKU09OLnN0cmluZ2lmeShhcmcpICsgXCIgdG8gbmV3Ym9ybiBnZW5lcmF0b3JcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkWWllbGQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IGFyZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGNvbnRleHQuc2VudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuZGVsZWdhdGUgJiYgbWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG5cbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihyZWNvcmQuYXJnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZW5lcmF0b3IubmV4dCA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJuZXh0XCIpO1xuICAgIGdlbmVyYXRvcltcInRocm93XCJdID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcInRocm93XCIpO1xuICAgIGdlbmVyYXRvcltcInJldHVyblwiXSA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJyZXR1cm5cIik7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIHRoaXMuc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICAvLyBQcmUtaW5pdGlhbGl6ZSBhdCBsZWFzdCAyMCB0ZW1wb3JhcnkgdmFyaWFibGVzIHRvIGVuYWJsZSBoaWRkZW5cbiAgICAgIC8vIGNsYXNzIG9wdGltaXphdGlvbnMgZm9yIHNpbXBsZSBnZW5lcmF0b3JzLlxuICAgICAgZm9yICh2YXIgdGVtcEluZGV4ID0gMCwgdGVtcE5hbWU7XG4gICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIHRlbXBOYW1lID0gXCJ0XCIgKyB0ZW1wSW5kZXgpIHx8IHRlbXBJbmRleCA8IDIwO1xuICAgICAgICAgICArK3RlbXBJbmRleCkge1xuICAgICAgICB0aGlzW3RlbXBOYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuICAvLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3RcbiAgLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOiB0aGlzXG4pO1xuIl19
},{}],4:[function(require,module,exports){
'use strict'

module.exports = boxIntersectWrapper

var pool = require('typedarray-pool')
var sweep = require('./lib/sweep')
var boxIntersectIter = require('./lib/intersect')

function boxEmpty(d, box) {
  for(var j=0; j<d; ++j) {
    if(!(box[j] <= box[j+d])) {
      return true
    }
  }
  return false
}

//Unpack boxes into a flat typed array, remove empty boxes
function convertBoxes(boxes, d, data, ids) {
  var ptr = 0
  var count = 0
  for(var i=0, n=boxes.length; i<n; ++i) {
    var b = boxes[i]
    if(boxEmpty(d, b)) {
      continue
    }
    for(var j=0; j<2*d; ++j) {
      data[ptr++] = b[j]
    }
    ids[count++] = i
  }
  return count
}

//Perform type conversions, check bounds
function boxIntersect(red, blue, visit, full) {
  var n = red.length
  var m = blue.length

  //If either array is empty, then we can skip this whole thing
  if(n <= 0 || m <= 0) {
    return
  }

  //Compute dimension, if it is 0 then we skip
  var d = (red[0].length)>>>1
  if(d <= 0) {
    return
  }

  var retval

  //Convert red boxes
  var redList  = pool.mallocDouble(2*d*n)
  var redIds   = pool.mallocInt32(n)
  n = convertBoxes(red, d, redList, redIds)

  if(n > 0) {
    if(d === 1 && full) {
      //Special case: 1d complete
      sweep.init(n)
      retval = sweep.sweepComplete(
        d, visit, 
        0, n, redList, redIds,
        0, n, redList, redIds)
    } else {

      //Convert blue boxes
      var blueList = pool.mallocDouble(2*d*m)
      var blueIds  = pool.mallocInt32(m)
      m = convertBoxes(blue, d, blueList, blueIds)

      if(m > 0) {
        sweep.init(n+m)

        if(d === 1) {
          //Special case: 1d bipartite
          retval = sweep.sweepBipartite(
            d, visit, 
            0, n, redList,  redIds,
            0, m, blueList, blueIds)
        } else {
          //General case:  d>1
          retval = boxIntersectIter(
            d, visit,    full,
            n, redList,  redIds,
            m, blueList, blueIds)
        }

        pool.free(blueList)
        pool.free(blueIds)
      }
    }

    pool.free(redList)
    pool.free(redIds)
  }

  return retval
}


var RESULT

function appendItem(i,j) {
  RESULT.push([i,j])
}

function intersectFullArray(x) {
  RESULT = []
  boxIntersect(x, x, appendItem, true)
  return RESULT
}

function intersectBipartiteArray(x, y) {
  RESULT = []
  boxIntersect(x, y, appendItem, false)
  return RESULT
}

//User-friendly wrapper, handle full input and no-visitor cases
function boxIntersectWrapper(arg0, arg1, arg2) {
  var result
  switch(arguments.length) {
    case 1:
      return intersectFullArray(arg0)
    case 2:
      if(typeof arg1 === 'function') {
        return boxIntersect(arg0, arg0, arg1, true)
      } else {
        return intersectBipartiteArray(arg0, arg1)
      }
    case 3:
      return boxIntersect(arg0, arg1, arg2, false)
    default:
      throw new Error('box-intersect: Invalid arguments')
  }
}
},{"./lib/intersect":6,"./lib/sweep":10,"typedarray-pool":13}],5:[function(require,module,exports){
'use strict'

var DIMENSION   = 'd'
var AXIS        = 'ax'
var VISIT       = 'vv'
var FLIP        = 'fp'

var ELEM_SIZE   = 'es'

var RED_START   = 'rs'
var RED_END     = 're'
var RED_BOXES   = 'rb'
var RED_INDEX   = 'ri'
var RED_PTR     = 'rp'

var BLUE_START  = 'bs'
var BLUE_END    = 'be'
var BLUE_BOXES  = 'bb'
var BLUE_INDEX  = 'bi'
var BLUE_PTR    = 'bp'

var RETVAL      = 'rv'

var INNER_LABEL = 'Q'

var ARGS = [
  DIMENSION,
  AXIS,
  VISIT,
  RED_START,
  RED_END,
  RED_BOXES,
  RED_INDEX,
  BLUE_START,
  BLUE_END,
  BLUE_BOXES,
  BLUE_INDEX
]

function generateBruteForce(redMajor, flip, full) {
  var funcName = 'bruteForce' + 
    (redMajor ? 'Red' : 'Blue') + 
    (flip ? 'Flip' : '') +
    (full ? 'Full' : '')

  var code = ['function ', funcName, '(', ARGS.join(), '){',
    'var ', ELEM_SIZE, '=2*', DIMENSION, ';']

  var redLoop = 
    'for(var i=' + RED_START + ',' + RED_PTR + '=' + ELEM_SIZE + '*' + RED_START + ';' +
        'i<' + RED_END +';' +
        '++i,' + RED_PTR + '+=' + ELEM_SIZE + '){' +
        'var x0=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '],' +
            'x1=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '+' + DIMENSION + '],' +
            'xi=' + RED_INDEX + '[i];'

  var blueLoop = 
    'for(var j=' + BLUE_START + ',' + BLUE_PTR + '=' + ELEM_SIZE + '*' + BLUE_START + ';' +
        'j<' + BLUE_END + ';' +
        '++j,' + BLUE_PTR + '+=' + ELEM_SIZE + '){' +
        'var y0=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '],' +
            (full ? 'y1=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '+' + DIMENSION + '],' : '') +
            'yi=' + BLUE_INDEX + '[j];'

  if(redMajor) {
    code.push(redLoop, INNER_LABEL, ':', blueLoop)
  } else {
    code.push(blueLoop, INNER_LABEL, ':', redLoop)
  }

  if(full) {
    code.push('if(y1<x0||x1<y0)continue;')
  } else if(flip) {
    code.push('if(y0<=x0||x1<y0)continue;')
  } else {
    code.push('if(y0<x0||x1<y0)continue;')
  }

  code.push('for(var k='+AXIS+'+1;k<'+DIMENSION+';++k){'+
    'var r0='+RED_BOXES+'[k+'+RED_PTR+'],'+
        'r1='+RED_BOXES+'[k+'+DIMENSION+'+'+RED_PTR+'],'+
        'b0='+BLUE_BOXES+'[k+'+BLUE_PTR+'],'+
        'b1='+BLUE_BOXES+'[k+'+DIMENSION+'+'+BLUE_PTR+'];'+
      'if(r1<b0||b1<r0)continue ' + INNER_LABEL + ';}' +
      'var ' + RETVAL + '=' + VISIT + '(')

  if(flip) {
    code.push('yi,xi')
  } else {
    code.push('xi,yi')
  }

  code.push(');if(' + RETVAL + '!==void 0)return ' + RETVAL + ';}}}')

  return {
    name: funcName, 
    code: code.join('')
  }
}

function bruteForcePlanner(full) {
  var funcName = 'bruteForce' + (full ? 'Full' : 'Partial')
  var prefix = []
  var fargs = ARGS.slice()
  if(!full) {
    fargs.splice(3, 0, FLIP)
  }

  var code = ['function ' + funcName + '(' + fargs.join() + '){']

  function invoke(redMajor, flip) {
    var res = generateBruteForce(redMajor, flip, full)
    prefix.push(res.code)
    code.push('return ' + res.name + '(' + ARGS.join() + ');')
  }

  code.push('if(' + RED_END + '-' + RED_START + '>' +
                    BLUE_END + '-' + BLUE_START + '){')

  if(full) {
    invoke(true, false)
    code.push('}else{')
    invoke(false, false)
  } else {
    code.push('if(' + FLIP + '){')
    invoke(true, true)
    code.push('}else{')
    invoke(true, false)
    code.push('}}else{if(' + FLIP + '){')
    invoke(false, true)
    code.push('}else{')
    invoke(false, false)
    code.push('}')
  }
  code.push('}}return ' + funcName)

  var codeStr = prefix.join('') + code.join('')
  var proc = new Function(codeStr)
  return proc()
}


exports.partial = bruteForcePlanner(false)
exports.full    = bruteForcePlanner(true)
},{}],6:[function(require,module,exports){
'use strict'

module.exports = boxIntersectIter

var pool = require('typedarray-pool')
var bits = require('bit-twiddle')
var bruteForce = require('./brute')
var bruteForcePartial = bruteForce.partial
var bruteForceFull = bruteForce.full
var sweep = require('./sweep')
var findMedian = require('./median')
var genPartition = require('./partition')

//Twiddle parameters
var BRUTE_FORCE_CUTOFF    = 128       //Cut off for brute force search
var SCAN_CUTOFF           = (1<<22)   //Cut off for two way scan
var SCAN_COMPLETE_CUTOFF  = (1<<22)  

//Partition functions
var partitionInteriorContainsInterval = genPartition(
  '!(lo>=p0)&&!(p1>=hi)', 
  ['p0', 'p1'])

var partitionStartEqual = genPartition(
  'lo===p0',
  ['p0'])

var partitionStartLessThan = genPartition(
  'lo<p0',
  ['p0'])

var partitionEndLessThanEqual = genPartition(
  'hi<=p0',
  ['p0'])

var partitionContainsPoint = genPartition(
  'lo<=p0&&p0<=hi',
  ['p0'])

var partitionContainsPointProper = genPartition(
  'lo<p0&&p0<=hi',
  ['p0'])

//Frame size for iterative loop
var IFRAME_SIZE = 6
var DFRAME_SIZE = 2

//Data for box statck
var INIT_CAPACITY = 1024
var BOX_ISTACK  = pool.mallocInt32(INIT_CAPACITY)
var BOX_DSTACK  = pool.mallocDouble(INIT_CAPACITY)

//Initialize iterative loop queue
function iterInit(d, count) {
  var levels = (8 * bits.log2(count+1) * (d+1))|0
  var maxInts = bits.nextPow2(IFRAME_SIZE*levels)
  if(BOX_ISTACK.length < maxInts) {
    pool.free(BOX_ISTACK)
    BOX_ISTACK = pool.mallocInt32(maxInts)
  }
  var maxDoubles = bits.nextPow2(DFRAME_SIZE*levels)
  if(BOX_DSTACK < maxDoubles) {
    pool.free(BOX_DSTACK)
    BOX_DSTACK = pool.mallocDouble(maxDoubles)
  }
}

//Append item to queue
function iterPush(ptr,
  axis, 
  redStart, redEnd, 
  blueStart, blueEnd, 
  state, 
  lo, hi) {

  var iptr = IFRAME_SIZE * ptr
  BOX_ISTACK[iptr]   = axis
  BOX_ISTACK[iptr+1] = redStart
  BOX_ISTACK[iptr+2] = redEnd
  BOX_ISTACK[iptr+3] = blueStart
  BOX_ISTACK[iptr+4] = blueEnd
  BOX_ISTACK[iptr+5] = state

  var dptr = DFRAME_SIZE * ptr
  BOX_DSTACK[dptr]   = lo
  BOX_DSTACK[dptr+1] = hi
}

//Special case:  Intersect single point with list of intervals
function onePointPartial(
  d, axis, visit, flip,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    if(flip && blueX === r0) {
      continue
    }
    var redId = redIndex[i]
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval
    if(flip) {
      retval = visit(blueId, redId)
    } else {
      retval = visit(redId, blueId)
    }
    if(retval !== void 0) {
      return retval
    }
  }
}

//Special case:  Intersect one point with list of intervals
function onePointFull(
  d, axis, visit,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var redId = redIndex[i]
    if(redId === blueId) {
      continue
    }
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval = visit(redId, blueId)
    if(retval !== void 0) {
      return retval
    }
  }
}

//The main box intersection routine
function boxIntersectIter(
  d, visit, initFull,
  xSize, xBoxes, xIndex,
  ySize, yBoxes, yIndex) {

  //Reserve memory for stack
  iterInit(d, xSize + ySize)

  var top  = 0
  var elemSize = 2 * d
  var retval

  iterPush(top++,
      0,
      0, xSize,
      0, ySize,
      initFull ? 16 : 0, 
      -Infinity, Infinity)
  if(!initFull) {
    iterPush(top++,
      0,
      0, ySize,
      0, xSize,
      1, 
      -Infinity, Infinity)
  }

  while(top > 0) {
    top  -= 1

    var iptr = top * IFRAME_SIZE
    var axis      = BOX_ISTACK[iptr]
    var redStart  = BOX_ISTACK[iptr+1]
    var redEnd    = BOX_ISTACK[iptr+2]
    var blueStart = BOX_ISTACK[iptr+3]
    var blueEnd   = BOX_ISTACK[iptr+4]
    var state     = BOX_ISTACK[iptr+5]

    var dptr = top * DFRAME_SIZE
    var lo        = BOX_DSTACK[dptr]
    var hi        = BOX_DSTACK[dptr+1]

    //Unpack state info
    var flip      = (state & 1)
    var full      = !!(state & 16)

    //Unpack indices
    var red       = xBoxes
    var redIndex  = xIndex
    var blue      = yBoxes
    var blueIndex = yIndex
    if(flip) {
      red         = yBoxes
      redIndex    = yIndex
      blue        = xBoxes
      blueIndex   = xIndex
    }

    if(state & 2) {
      redEnd = partitionStartLessThan(
        d, axis,
        redStart, redEnd, red, redIndex,
        hi)
      if(redStart >= redEnd) {
        continue
      }
    }
    if(state & 4) {
      redStart = partitionEndLessThanEqual(
        d, axis,
        redStart, redEnd, red, redIndex,
        lo)
      if(redStart >= redEnd) {
        continue
      }
    }
    
    var redCount  = redEnd  - redStart
    var blueCount = blueEnd - blueStart

    if(full) {
      if(d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {
        retval = sweep.scanComplete(
          d, axis, visit, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    } else {
      if(d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {
        //If input small, then use brute force
        retval = bruteForcePartial(
            d, axis, visit, flip,
            redStart,  redEnd,  red,  redIndex,
            blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      } else if(d * redCount * blueCount < SCAN_CUTOFF) {
        //If input medium sized, then use sweep and prune
        retval = sweep.scanBipartite(
          d, axis, visit, flip, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    }
    
    //First, find all red intervals whose interior contains (lo,hi)
    var red0 = partitionInteriorContainsInterval(
      d, axis, 
      redStart, redEnd, red, redIndex,
      lo, hi)

    //Lower dimensional case
    if(redStart < red0) {

      if(d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {
        //Special case for small inputs: use brute force
        retval = bruteForceFull(
          d, axis+1, visit,
          redStart, red0, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
      } else if(axis === d-2) {
        if(flip) {
          retval = sweep.sweepBipartite(
            d, visit,
            blueStart, blueEnd, blue, blueIndex,
            redStart, red0, red, redIndex)
        } else {
          retval = sweep.sweepBipartite(
            d, visit,
            redStart, red0, red, redIndex,
            blueStart, blueEnd, blue, blueIndex)
        }
        if(retval !== void 0) {
          return retval
        }
      } else {
        iterPush(top++,
          axis+1,
          redStart, red0,
          blueStart, blueEnd,
          flip,
          -Infinity, Infinity)
        iterPush(top++,
          axis+1,
          blueStart, blueEnd,
          redStart, red0,
          flip^1,
          -Infinity, Infinity)
      }
    }

    //Divide and conquer phase
    if(red0 < redEnd) {

      //Cut blue into 3 parts:
      //
      //  Points < mid point
      //  Points = mid point
      //  Points > mid point
      //
      var blue0 = findMedian(
        d, axis, 
        blueStart, blueEnd, blue, blueIndex)
      var mid = blue[elemSize * blue0 + axis]
      var blue1 = partitionStartEqual(
        d, axis,
        blue0, blueEnd, blue, blueIndex,
        mid)

      //Right case
      if(blue1 < blueEnd) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blue1, blueEnd,
          (flip|4) + (full ? 16 : 0),
          mid, hi)
      }

      //Left case
      if(blueStart < blue0) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blueStart, blue0,
          (flip|2) + (full ? 16 : 0),
          lo, mid)
      }

      //Center case (the hard part)
      if(blue0 + 1 === blue1) {
        //Optimization: Range with exactly 1 point, use a brute force scan
        if(full) {
          retval = onePointFull(
            d, axis, visit,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        } else {
          retval = onePointPartial(
            d, axis, visit, flip,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        }
        if(retval !== void 0) {
          return retval
        }
      } else if(blue0 < blue1) {
        var red1
        if(full) {
          //If full intersection, need to handle special case
          red1 = partitionContainsPoint(
            d, axis,
            red0, redEnd, red, redIndex,
            mid)
          if(red0 < red1) {
            var redX = partitionStartEqual(
              d, axis,
              red0, red1, red, redIndex,
              mid)
            if(axis === d-2) {
              //Degenerate sweep intersection:
              //  [red0, redX] with [blue0, blue1]
              if(red0 < redX) {
                retval = sweep.sweepComplete(
                  d, visit,
                  red0, redX, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }

              //Normal sweep intersection:
              //  [redX, red1] with [blue0, blue1]
              if(redX < red1) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  redX, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }
            } else {
              if(red0 < redX) {
                iterPush(top++,
                  axis+1,
                  red0, redX,
                  blue0, blue1,
                  16,
                  -Infinity, Infinity)
              }
              if(redX < red1) {
                iterPush(top++,
                  axis+1,
                  redX, red1,
                  blue0, blue1,
                  0,
                  -Infinity, Infinity)
                iterPush(top++,
                  axis+1,
                  blue0, blue1,
                  redX, red1,
                  1,
                  -Infinity, Infinity)
              }
            }
          }
        } else {
          if(flip) {
            red1 = partitionContainsPointProper(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          } else {
            red1 = partitionContainsPoint(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          }
          if(red0 < red1) {
            if(axis === d-2) {
              if(flip) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  blue0, blue1, blue, blueIndex,
                  red0, red1, red, redIndex)
              } else {
                retval = sweep.sweepBipartite(
                  d, visit,
                  red0, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
              }
            } else {
              iterPush(top++,
                axis+1,
                red0, red1,
                blue0, blue1,
                flip,
                -Infinity, Infinity)
              iterPush(top++,
                axis+1,
                blue0, blue1,
                red0, red1,
                flip^1,
                -Infinity, Infinity)
            }
          }
        }
      }
    }
  }
}
},{"./brute":5,"./median":7,"./partition":8,"./sweep":10,"bit-twiddle":11,"typedarray-pool":13}],7:[function(require,module,exports){
'use strict'

module.exports = findMedian

var genPartition = require('./partition')

var partitionStartLessThan = genPartition('lo<p0', ['p0'])

var PARTITION_THRESHOLD = 8   //Cut off for using insertion sort in findMedian

//Base case for median finding:  Use insertion sort
function insertionSort(d, axis, start, end, boxes, ids) {
  var elemSize = 2 * d
  var boxPtr = elemSize * (start+1) + axis
  for(var i=start+1; i<end; ++i, boxPtr+=elemSize) {
    var x = boxes[boxPtr]
    for(var j=i, ptr=elemSize*(i-1); 
        j>start && boxes[ptr+axis] > x; 
        --j, ptr-=elemSize) {
      //Swap
      var aPtr = ptr
      var bPtr = ptr+elemSize
      for(var k=0; k<elemSize; ++k, ++aPtr, ++bPtr) {
        var y = boxes[aPtr]
        boxes[aPtr] = boxes[bPtr]
        boxes[bPtr] = y
      }
      var tmp = ids[j]
      ids[j] = ids[j-1]
      ids[j-1] = tmp
    }
  }
}

//Find median using quick select algorithm
//  takes O(n) time with high probability
function findMedian(d, axis, start, end, boxes, ids) {
  if(end <= start+1) {
    return start
  }

  var lo       = start
  var hi       = end
  var mid      = ((end + start) >>> 1)
  var elemSize = 2*d
  var pivot    = mid
  var value    = boxes[elemSize*mid+axis]
  
  while(lo < hi) {
    if(hi - lo < PARTITION_THRESHOLD) {
      insertionSort(d, axis, lo, hi, boxes, ids)
      value = boxes[elemSize*mid+axis]
      break
    }
    
    //Select pivot using median-of-3
    var count  = hi - lo
    var pivot0 = (Math.random()*count+lo)|0
    var value0 = boxes[elemSize*pivot0 + axis]
    var pivot1 = (Math.random()*count+lo)|0
    var value1 = boxes[elemSize*pivot1 + axis]
    var pivot2 = (Math.random()*count+lo)|0
    var value2 = boxes[elemSize*pivot2 + axis]
    if(value0 <= value1) {
      if(value2 >= value1) {
        pivot = pivot1
        value = value1
      } else if(value0 >= value2) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    } else {
      if(value1 >= value2) {
        pivot = pivot1
        value = value1
      } else if(value2 >= value0) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    }

    //Swap pivot to end of array
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Partition using pivot
    pivot = partitionStartLessThan(
      d, axis, 
      lo, hi-1, boxes, ids,
      value)

    //Swap pivot back
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Swap pivot to last pivot
    if(mid < pivot) {
      hi = pivot-1
      while(lo < hi && 
        boxes[elemSize*(hi-1)+axis] === value) {
        hi -= 1
      }
      hi += 1
    } else if(pivot < mid) {
      lo = pivot + 1
      while(lo < hi &&
        boxes[elemSize*lo+axis] === value) {
        lo += 1
      }
    } else {
      break
    }
  }

  //Make sure pivot is at start
  return partitionStartLessThan(
    d, axis, 
    start, mid, boxes, ids,
    boxes[elemSize*mid+axis])
}
},{"./partition":8}],8:[function(require,module,exports){
'use strict'

module.exports = genPartition

var code = 'for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var _;if($)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t}var u=f[p];f[p]=f[m],f[m++]=u}}return m'

function genPartition(predicate, args) {
  var fargs ='abcdef'.split('').concat(args)
  var reads = []
  if(predicate.indexOf('lo') >= 0) {
    reads.push('lo=e[k+n]')
  }
  if(predicate.indexOf('hi') >= 0) {
    reads.push('hi=e[k+o]')
  }
  fargs.push(
    code.replace('_', reads.join())
        .replace('$', predicate))
  return Function.apply(void 0, fargs)
}
},{}],9:[function(require,module,exports){
'use strict';

//This code is extracted from ndarray-sort
//It is inlined here as a temporary workaround

module.exports = wrapper;

var INSERT_SORT_CUTOFF = 32

function wrapper(data, n0) {
  if (n0 <= 4*INSERT_SORT_CUTOFF) {
    insertionSort(0, n0 - 1, data);
  } else {
    quickSort(0, n0 - 1, data);
  }
}

function insertionSort(left, right, data) {
  var ptr = 2*(left+1)
  for(var i=left+1; i<=right; ++i) {
    var a = data[ptr++]
    var b = data[ptr++]
    var j = i
    var jptr = ptr-2
    while(j-- > left) {
      var x = data[jptr-2]
      var y = data[jptr-1]
      if(x < a) {
        break
      } else if(x === a && y < b) {
        break
      }
      data[jptr]   = x
      data[jptr+1] = y
      jptr -= 2
    }
    data[jptr]   = a
    data[jptr+1] = b
  }
}

function swap(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = x
  data[j+1] = y
}

function move(i, j, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[i+1] = data[j+1]
}

function rotate(i, j, k, data) {
  i *= 2
  j *= 2
  k *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = data[k]
  data[j+1] = data[k+1]
  data[k] = x
  data[k+1] = y
}

function shufflePivot(i, j, px, py, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[j] = px
  data[i+1] = data[j+1]
  data[j+1] = py
}

function compare(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i],
      y = data[j]
  if(x < y) {
    return false
  } else if(x === y) {
    return data[i+1] > data[j+1]
  }
  return true
}

function comparePivot(i, y, b, data) {
  i *= 2
  var x = data[i]
  if(x < y) {
    return true
  } else if(x === y) {
    return data[i+1] < b
  }
  return false
}

function quickSort(left, right, data) {
  var sixth = (right - left + 1) / 6 | 0, 
      index1 = left + sixth, 
      index5 = right - sixth, 
      index3 = left + right >> 1, 
      index2 = index3 - sixth, 
      index4 = index3 + sixth, 
      el1 = index1, 
      el2 = index2, 
      el3 = index3, 
      el4 = index4, 
      el5 = index5, 
      less = left + 1, 
      great = right - 1, 
      tmp = 0
  if(compare(el1, el2, data)) {
    tmp = el1
    el1 = el2
    el2 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }
  if(compare(el1, el3, data)) {
    tmp = el1
    el1 = el3
    el3 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el1, el4, data)) {
    tmp = el1
    el1 = el4
    el4 = tmp
  }
  if(compare(el3, el4, data)) {
    tmp = el3
    el3 = el4
    el4 = tmp
  }
  if(compare(el2, el5, data)) {
    tmp = el2
    el2 = el5
    el5 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }

  var pivot1X = data[2*el2]
  var pivot1Y = data[2*el2+1]
  var pivot2X = data[2*el4]
  var pivot2Y = data[2*el4+1]

  var ptr0 = 2 * el1;
  var ptr2 = 2 * el3;
  var ptr4 = 2 * el5;
  var ptr5 = 2 * index1;
  var ptr6 = 2 * index3;
  var ptr7 = 2 * index5;
  for (var i1 = 0; i1 < 2; ++i1) {
    var x = data[ptr0+i1];
    var y = data[ptr2+i1];
    var z = data[ptr4+i1];
    data[ptr5+i1] = x;
    data[ptr6+i1] = y;
    data[ptr7+i1] = z;
  }

  move(index2, left, data)
  move(index4, right, data)
  for (var k = less; k <= great; ++k) {
    if (comparePivot(k, pivot1X, pivot1Y, data)) {
      if (k !== less) {
        swap(k, less, data)
      }
      ++less;
    } else {
      if (!comparePivot(k, pivot2X, pivot2Y, data)) {
        while (true) {
          if (!comparePivot(great, pivot2X, pivot2Y, data)) {
            if (--great < k) {
              break;
            }
            continue;
          } else {
            if (comparePivot(great, pivot1X, pivot1Y, data)) {
              rotate(k, less, great, data)
              ++less;
              --great;
            } else {
              swap(k, great, data)
              --great;
            }
            break;
          }
        }
      }
    }
  }
  shufflePivot(left, less-1, pivot1X, pivot1Y, data)
  shufflePivot(right, great+1, pivot2X, pivot2Y, data)
  if (less - 2 - left <= INSERT_SORT_CUTOFF) {
    insertionSort(left, less - 2, data);
  } else {
    quickSort(left, less - 2, data);
  }
  if (right - (great + 2) <= INSERT_SORT_CUTOFF) {
    insertionSort(great + 2, right, data);
  } else {
    quickSort(great + 2, right, data);
  }
  if (great - less <= INSERT_SORT_CUTOFF) {
    insertionSort(less, great, data);
  } else {
    quickSort(less, great, data);
  }
}
},{}],10:[function(require,module,exports){
'use strict'

module.exports = {
  init:           sqInit,
  sweepBipartite: sweepBipartite,
  sweepComplete:  sweepComplete,
  scanBipartite:  scanBipartite,
  scanComplete:   scanComplete
}

var pool  = require('typedarray-pool')
var bits  = require('bit-twiddle')
var isort = require('./sort')

//Flag for blue
var BLUE_FLAG = (1<<28)

//1D sweep event queue stuff (use pool to save space)
var INIT_CAPACITY      = 1024
var RED_SWEEP_QUEUE    = pool.mallocInt32(INIT_CAPACITY)
var RED_SWEEP_INDEX    = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_QUEUE   = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_INDEX   = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY)
var SWEEP_EVENTS       = pool.mallocDouble(INIT_CAPACITY * 8)

//Reserves memory for the 1D sweep data structures
function sqInit(count) {
  var rcount = bits.nextPow2(count)
  if(RED_SWEEP_QUEUE.length < rcount) {
    pool.free(RED_SWEEP_QUEUE)
    RED_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(RED_SWEEP_INDEX.length < rcount) {
    pool.free(RED_SWEEP_INDEX)
    RED_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_QUEUE.length < rcount) {
    pool.free(BLUE_SWEEP_QUEUE)
    BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_INDEX.length < rcount) {
    pool.free(BLUE_SWEEP_INDEX)
    BLUE_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_QUEUE.length < rcount) {
    pool.free(COMMON_SWEEP_QUEUE)
    COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_INDEX.length < rcount) {
    pool.free(COMMON_SWEEP_INDEX)
    COMMON_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  var eventLength = 8 * rcount
  if(SWEEP_EVENTS.length < eventLength) {
    pool.free(SWEEP_EVENTS)
    SWEEP_EVENTS = pool.mallocDouble(eventLength)
  }
}

//Remove an item from the active queue in O(1)
function sqPop(queue, index, count, item) {
  var idx = index[item]
  var top = queue[count-1]
  queue[idx] = top
  index[top] = idx
}

//Insert an item into the active queue in O(1)
function sqPush(queue, index, count, item) {
  queue[count] = item
  index[item]  = count
}

//Recursion base case: use 1D sweep algorithm
function sweepBipartite(
    d, visit,
    redStart,  redEnd, red, redIndex,
    blueStart, blueEnd, blue, blueIndex) {

  //store events as pairs [coordinate, idx]
  //
  //  red create:  -(idx+1)
  //  red destroy: idx
  //  blue create: -(idx+BLUE_FLAG)
  //  blue destroy: idx+BLUE_FLAG
  //
  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = redIndex[i]
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -(idx+1)
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = blueIndex[i]+BLUE_FLAG
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive  = 0
  var blueActive = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e >= BLUE_FLAG) {
      //blue destroy event
      e = (e-BLUE_FLAG)|0
      sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e)
    } else if(e >= 0) {
      //red destroy event
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e)
    } else if(e <= -BLUE_FLAG) {
      //blue create event
      e = (-e-BLUE_FLAG)|0
      for(var j=0; j<redActive; ++j) {
        var retval = visit(RED_SWEEP_QUEUE[j], e)
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e)
    } else {
      //red create event
      e = (-e-1)|0
      for(var j=0; j<blueActive; ++j) {
        var retval = visit(e, BLUE_SWEEP_QUEUE[j])
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e)
    }
  }
}

//Complete sweep
function sweepComplete(d, visit, 
  redStart, redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = (redIndex[i]+1)<<1
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = (blueIndex[i]+1)<<1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = (-idx)|1
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx|1
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  var blueActive   = 0
  var commonActive = 0
  for(var i=0; i<n; ++i) {
    var e     = SWEEP_EVENTS[2*i+1]|0
    var color = e&1
    if(i < n-1 && (e>>1) === (SWEEP_EVENTS[2*i+3]>>1)) {
      color = 2
      i += 1
    }
    
    if(e < 0) {
      //Create event
      var id = -(e>>1) - 1

      //Intersect with common
      for(var j=0; j<commonActive; ++j) {
        var retval = visit(COMMON_SWEEP_QUEUE[j], id)
        if(retval !== void 0) {
          return retval
        }
      }

      if(color !== 0) {
        //Intersect with red
        for(var j=0; j<redActive; ++j) {
          var retval = visit(RED_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color !== 1) {
        //Intersect with blue
        for(var j=0; j<blueActive; ++j) {
          var retval = visit(BLUE_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color === 0) {
        //Red
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id)
      } else if(color === 1) {
        //Blue
        sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id)
      } else if(color === 2) {
        //Both
        sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id)
      }
    } else {
      //Destroy event
      var id = (e>>1) - 1
      if(color === 0) {
        //Red
        sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id)
      } else if(color === 1) {
        //Blue
        sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id)
      } else if(color === 2) {
        //Both
        sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id)
      }
    }
  }
}

//Sweep and prune/scanline algorithm:
//  Scan along axis, detect intersections
//  Brute force all boxes along axis
function scanBipartite(
  d, axis, visit, flip,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {
  
  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  var redShift  = 1
  var blueShift = 1
  if(flip) {
    blueShift = BLUE_FLAG
  } else {
    redShift  = BLUE_FLAG
  }

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + redShift
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + blueShift
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      var isRed = false
      if(idx >= BLUE_FLAG) {
        isRed = !flip
        idx -= BLUE_FLAG 
      } else {
        isRed = !!flip
        idx -= 1
      }
      if(isRed) {
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx)
      } else {
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx
        
        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redPtr = elemSize * oidx

          if(b1 < red[redPtr+axis+1] || 
             red[redPtr+axis+1+d] < b0) {
            continue
          }

          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d] < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var redId  = redIndex[oidx]
          var retval
          if(flip) {
            retval = visit(blueId, redId)
          } else {
            retval = visit(redId, blueId)
          }
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift)
    }
  }
}

function scanComplete(
  d, axis, visit,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + BLUE_FLAG
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + 1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      if(idx >= BLUE_FLAG) {
        RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG
      } else {
        idx -= 1
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx

        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redId  = redIndex[oidx]

          if(redId === blueId) {
            break
          }

          var redPtr = elemSize * oidx
          if(b1 < red[redPtr+axis+1] || 
            red[redPtr+axis+1+d] < b0) {
            continue
          }
          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d]   < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var retval = visit(redId, blueId)
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      var idx = e - BLUE_FLAG
      for(var j=redActive-1; j>=0; --j) {
        if(RED_SWEEP_QUEUE[j] === idx) {
          for(var k=j+1; k<redActive; ++k) {
            RED_SWEEP_QUEUE[k-1] = RED_SWEEP_QUEUE[k]
          }
          break
        }
      }
      --redActive
    }
  }
}
},{"./sort":9,"bit-twiddle":11,"typedarray-pool":13}],11:[function(require,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict"; "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}


},{}],12:[function(require,module,exports){
"use strict"

function dupe_array(count, value, i) {
  var c = count[i]|0
  if(c <= 0) {
    return []
  }
  var result = new Array(c), j
  if(i === count.length-1) {
    for(j=0; j<c; ++j) {
      result[j] = value
    }
  } else {
    for(j=0; j<c; ++j) {
      result[j] = dupe_array(count, value, i+1)
    }
  }
  return result
}

function dupe_number(count, value) {
  var result, i
  result = new Array(count)
  for(i=0; i<count; ++i) {
    result[i] = value
  }
  return result
}

function dupe(count, value) {
  if(typeof value === "undefined") {
    value = 0
  }
  switch(typeof count) {
    case "number":
      if(count > 0) {
        return dupe_number(count|0, value)
      }
    break
    case "object":
      if(typeof (count.length) === "number") {
        return dupe_array(count, value, 0)
      }
    break
  }
  return []
}

module.exports = dupe
},{}],13:[function(require,module,exports){
(function (global,Buffer){
'use strict'

var bits = require('bit-twiddle')
var dup = require('dup')

//Legacy pool support
if(!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
      UINT8   : dup([32, 0])
    , UINT16  : dup([32, 0])
    , UINT32  : dup([32, 0])
    , INT8    : dup([32, 0])
    , INT16   : dup([32, 0])
    , INT32   : dup([32, 0])
    , FLOAT   : dup([32, 0])
    , DOUBLE  : dup([32, 0])
    , DATA    : dup([32, 0])
    , UINT8C  : dup([32, 0])
    , BUFFER  : dup([32, 0])
  }
}

var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'
var POOL = global.__TYPEDARRAY_POOL

//Upgrade pool
if(!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0])
}
if(!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0])
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA    = POOL.DATA
  , BUFFER  = POOL.BUFFER

exports.free = function free(array) {
  if(Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array)
  } else {
    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer
    }
    if(!array) {
      return
    }
    var n = array.length || array.byteLength
    var log_n = bits.log2(n)|0
    DATA[log_n].push(array)
  }
}

function freeArrayBuffer(buffer) {
  if(!buffer) {
    return
  }
  var n = buffer.length || buffer.byteLength
  var log_n = bits.log2(n)
  DATA[log_n].push(buffer)
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer)
}

exports.freeUint8 =
exports.freeUint16 =
exports.freeUint32 =
exports.freeInt8 =
exports.freeInt16 =
exports.freeInt32 =
exports.freeFloat32 = 
exports.freeFloat =
exports.freeFloat64 = 
exports.freeDouble = 
exports.freeUint8Clamped = 
exports.freeDataView = freeTypedArray

exports.freeArrayBuffer = freeArrayBuffer

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array)
}

exports.malloc = function malloc(n, dtype) {
  if(dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n)
  } else {
    switch(dtype) {
      case 'uint8':
        return mallocUint8(n)
      case 'uint16':
        return mallocUint16(n)
      case 'uint32':
        return mallocUint32(n)
      case 'int8':
        return mallocInt8(n)
      case 'int16':
        return mallocInt16(n)
      case 'int32':
        return mallocInt32(n)
      case 'float':
      case 'float32':
        return mallocFloat(n)
      case 'double':
      case 'float64':
        return mallocDouble(n)
      case 'uint8_clamped':
        return mallocUint8Clamped(n)
      case 'buffer':
        return mallocBuffer(n)
      case 'data':
      case 'dataview':
        return mallocDataView(n)

      default:
        return null
    }
  }
  return null
}

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var d = DATA[log_n]
  if(d.length > 0) {
    return d.pop()
  }
  return new ArrayBuffer(n)
}
exports.mallocArrayBuffer = mallocArrayBuffer

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocUint8 = mallocUint8

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocUint16 = mallocUint16

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocUint32 = mallocUint32

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocInt8 = mallocInt8

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocInt16 = mallocInt16

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocInt32 = mallocInt32

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8*n), 0, n)
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble

function mallocUint8Clamped(n) {
  if(hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
  } else {
    return mallocUint8(n)
  }
}
exports.mallocUint8Clamped = mallocUint8Clamped

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n)
}
exports.mallocDataView = mallocDataView

function mallocBuffer(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = BUFFER[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Buffer(n)
}
exports.mallocBuffer = mallocBuffer

exports.clearCache = function clearCache() {
  for(var i=0; i<32; ++i) {
    POOL.UINT8[i].length = 0
    POOL.UINT16[i].length = 0
    POOL.UINT32[i].length = 0
    POOL.INT8[i].length = 0
    POOL.INT16[i].length = 0
    POOL.INT32[i].length = 0
    POOL.FLOAT[i].length = 0
    POOL.DOUBLE[i].length = 0
    POOL.UINT8C[i].length = 0
    DATA[i].length = 0
    BUFFER[i].length = 0
  }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L25vZGVfbW9kdWxlcy90eXBlZGFycmF5LXBvb2wvcG9vbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG52YXIgYml0cyA9IHJlcXVpcmUoJ2JpdC10d2lkZGxlJylcbnZhciBkdXAgPSByZXF1aXJlKCdkdXAnKVxuXG4vL0xlZ2FjeSBwb29sIHN1cHBvcnRcbmlmKCFnbG9iYWwuX19UWVBFREFSUkFZX1BPT0wpIHtcbiAgZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MID0ge1xuICAgICAgVUlOVDggICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDE2ICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDMyICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UOCAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UMTYgICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UMzIgICA6IGR1cChbMzIsIDBdKVxuICAgICwgRkxPQVQgICA6IGR1cChbMzIsIDBdKVxuICAgICwgRE9VQkxFICA6IGR1cChbMzIsIDBdKVxuICAgICwgREFUQSAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDhDICA6IGR1cChbMzIsIDBdKVxuICAgICwgQlVGRkVSICA6IGR1cChbMzIsIDBdKVxuICB9XG59XG5cbnZhciBoYXNVaW50OEMgPSAodHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSAhPT0gJ3VuZGVmaW5lZCdcbnZhciBQT09MID0gZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MXG5cbi8vVXBncmFkZSBwb29sXG5pZighUE9PTC5VSU5UOEMpIHtcbiAgUE9PTC5VSU5UOEMgPSBkdXAoWzMyLCAwXSlcbn1cbmlmKCFQT09MLkJVRkZFUikge1xuICBQT09MLkJVRkZFUiA9IGR1cChbMzIsIDBdKVxufVxuXG4vL05ldyB0ZWNobmlxdWU6IE9ubHkgYWxsb2NhdGUgZnJvbSBBcnJheUJ1ZmZlclZpZXcgYW5kIEJ1ZmZlclxudmFyIERBVEEgICAgPSBQT09MLkRBVEFcbiAgLCBCVUZGRVIgID0gUE9PTC5CVUZGRVJcblxuZXhwb3J0cy5mcmVlID0gZnVuY3Rpb24gZnJlZShhcnJheSkge1xuICBpZihCdWZmZXIuaXNCdWZmZXIoYXJyYXkpKSB7XG4gICAgQlVGRkVSW2JpdHMubG9nMihhcnJheS5sZW5ndGgpXS5wdXNoKGFycmF5KVxuICB9IGVsc2Uge1xuICAgIGlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnJheSkgIT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIGFycmF5ID0gYXJyYXkuYnVmZmVyXG4gICAgfVxuICAgIGlmKCFhcnJheSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBuID0gYXJyYXkubGVuZ3RoIHx8IGFycmF5LmJ5dGVMZW5ndGhcbiAgICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobil8MFxuICAgIERBVEFbbG9nX25dLnB1c2goYXJyYXkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZnJlZUFycmF5QnVmZmVyKGJ1ZmZlcikge1xuICBpZighYnVmZmVyKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG4gPSBidWZmZXIubGVuZ3RoIHx8IGJ1ZmZlci5ieXRlTGVuZ3RoXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICBEQVRBW2xvZ19uXS5wdXNoKGJ1ZmZlcilcbn1cblxuZnVuY3Rpb24gZnJlZVR5cGVkQXJyYXkoYXJyYXkpIHtcbiAgZnJlZUFycmF5QnVmZmVyKGFycmF5LmJ1ZmZlcilcbn1cblxuZXhwb3J0cy5mcmVlVWludDggPVxuZXhwb3J0cy5mcmVlVWludDE2ID1cbmV4cG9ydHMuZnJlZVVpbnQzMiA9XG5leHBvcnRzLmZyZWVJbnQ4ID1cbmV4cG9ydHMuZnJlZUludDE2ID1cbmV4cG9ydHMuZnJlZUludDMyID1cbmV4cG9ydHMuZnJlZUZsb2F0MzIgPSBcbmV4cG9ydHMuZnJlZUZsb2F0ID1cbmV4cG9ydHMuZnJlZUZsb2F0NjQgPSBcbmV4cG9ydHMuZnJlZURvdWJsZSA9IFxuZXhwb3J0cy5mcmVlVWludDhDbGFtcGVkID0gXG5leHBvcnRzLmZyZWVEYXRhVmlldyA9IGZyZWVUeXBlZEFycmF5XG5cbmV4cG9ydHMuZnJlZUFycmF5QnVmZmVyID0gZnJlZUFycmF5QnVmZmVyXG5cbmV4cG9ydHMuZnJlZUJ1ZmZlciA9IGZ1bmN0aW9uIGZyZWVCdWZmZXIoYXJyYXkpIHtcbiAgQlVGRkVSW2JpdHMubG9nMihhcnJheS5sZW5ndGgpXS5wdXNoKGFycmF5KVxufVxuXG5leHBvcnRzLm1hbGxvYyA9IGZ1bmN0aW9uIG1hbGxvYyhuLCBkdHlwZSkge1xuICBpZihkdHlwZSA9PT0gdW5kZWZpbmVkIHx8IGR0eXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgcmV0dXJuIG1hbGxvY0FycmF5QnVmZmVyKG4pXG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoKGR0eXBlKSB7XG4gICAgICBjYXNlICd1aW50OCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50OChuKVxuICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQxNihuKVxuICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQzMihuKVxuICAgICAgY2FzZSAnaW50OCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQ4KG4pXG4gICAgICBjYXNlICdpbnQxNic6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQxNihuKVxuICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jSW50MzIobilcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jRmxvYXQobilcbiAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0RvdWJsZShuKVxuICAgICAgY2FzZSAndWludDhfY2xhbXBlZCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50OENsYW1wZWQobilcbiAgICAgIGNhc2UgJ2J1ZmZlcic6XG4gICAgICAgIHJldHVybiBtYWxsb2NCdWZmZXIobilcbiAgICAgIGNhc2UgJ2RhdGEnOlxuICAgICAgY2FzZSAnZGF0YXZpZXcnOlxuICAgICAgICByZXR1cm4gbWFsbG9jRGF0YVZpZXcobilcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gbWFsbG9jQXJyYXlCdWZmZXIobikge1xuICB2YXIgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBkID0gREFUQVtsb2dfbl1cbiAgaWYoZC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGQucG9wKClcbiAgfVxuICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKG4pXG59XG5leHBvcnRzLm1hbGxvY0FycmF5QnVmZmVyID0gbWFsbG9jQXJyYXlCdWZmZXJcblxuZnVuY3Rpb24gbWFsbG9jVWludDgobikge1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY1VpbnQ4ID0gbWFsbG9jVWludDhcblxuZnVuY3Rpb24gbWFsbG9jVWludDE2KG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShtYWxsb2NBcnJheUJ1ZmZlcigyKm4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50MTYgPSBtYWxsb2NVaW50MTZcblxuZnVuY3Rpb24gbWFsbG9jVWludDMyKG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50MzIgPSBtYWxsb2NVaW50MzJcblxuZnVuY3Rpb24gbWFsbG9jSW50OChuKSB7XG4gIHJldHVybiBuZXcgSW50OEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQ4ID0gbWFsbG9jSW50OFxuXG5mdW5jdGlvbiBtYWxsb2NJbnQxNihuKSB7XG4gIHJldHVybiBuZXcgSW50MTZBcnJheShtYWxsb2NBcnJheUJ1ZmZlcigyKm4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQxNiA9IG1hbGxvY0ludDE2XG5cbmZ1bmN0aW9uIG1hbGxvY0ludDMyKG4pIHtcbiAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDQqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0ludDMyID0gbWFsbG9jSW50MzJcblxuZnVuY3Rpb24gbWFsbG9jRmxvYXQobikge1xuICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NGbG9hdDMyID0gZXhwb3J0cy5tYWxsb2NGbG9hdCA9IG1hbGxvY0Zsb2F0XG5cbmZ1bmN0aW9uIG1hbGxvY0RvdWJsZShuKSB7XG4gIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDgqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0Zsb2F0NjQgPSBleHBvcnRzLm1hbGxvY0RvdWJsZSA9IG1hbGxvY0RvdWJsZVxuXG5mdW5jdGlvbiBtYWxsb2NVaW50OENsYW1wZWQobikge1xuICBpZihoYXNVaW50OEMpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYWxsb2NVaW50OChuKVxuICB9XG59XG5leHBvcnRzLm1hbGxvY1VpbnQ4Q2xhbXBlZCA9IG1hbGxvY1VpbnQ4Q2xhbXBlZFxuXG5mdW5jdGlvbiBtYWxsb2NEYXRhVmlldyhuKSB7XG4gIHJldHVybiBuZXcgRGF0YVZpZXcobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0RhdGFWaWV3ID0gbWFsbG9jRGF0YVZpZXdcblxuZnVuY3Rpb24gbWFsbG9jQnVmZmVyKG4pIHtcbiAgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBjYWNoZSA9IEJVRkZFUltsb2dfbl1cbiAgaWYoY2FjaGUubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBjYWNoZS5wb3AoKVxuICB9XG4gIHJldHVybiBuZXcgQnVmZmVyKG4pXG59XG5leHBvcnRzLm1hbGxvY0J1ZmZlciA9IG1hbGxvY0J1ZmZlclxuXG5leHBvcnRzLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICBmb3IodmFyIGk9MDsgaTwzMjsgKytpKSB7XG4gICAgUE9PTC5VSU5UOFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5VSU5UMTZbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDMyW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDhbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UMTZbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UMzJbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuRkxPQVRbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuRE9VQkxFW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLlVJTlQ4Q1tpXS5sZW5ndGggPSAwXG4gICAgREFUQVtpXS5sZW5ndGggPSAwXG4gICAgQlVGRkVSW2ldLmxlbmd0aCA9IDBcbiAgfVxufSJdfQ==
},{"bit-twiddle":11,"buffer":15,"dup":12}],14:[function(require,module,exports){

},{}],15:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length, 2)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length, unitSize) {
  if (unitSize) length -= length % unitSize;
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":16,"ieee754":17,"is-array":18}],16:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],17:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],18:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],19:[function(require,module,exports){
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
  "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
  "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
  "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
  "beige": [245,245,220,1], "bisque": [255,228,196,1],
  "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
  "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
  "brown": [165,42,42,1], "burlywood": [222,184,135,1],
  "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
  "chocolate": [210,105,30,1], "coral": [255,127,80,1],
  "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
  "crimson": [220,20,60,1], "cyan": [0,255,255,1],
  "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
  "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
  "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
  "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
  "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
  "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
  "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
  "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
  "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
  "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
  "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
  "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
  "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
  "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
  "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
  "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
  "gray": [128,128,128,1], "green": [0,128,0,1],
  "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
  "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
  "indianred": [205,92,92,1], "indigo": [75,0,130,1],
  "ivory": [255,255,240,1], "khaki": [240,230,140,1],
  "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
  "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
  "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
  "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
  "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
  "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
  "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
  "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
  "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
  "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
  "limegreen": [50,205,50,1], "linen": [250,240,230,1],
  "magenta": [255,0,255,1], "maroon": [128,0,0,1],
  "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
  "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
  "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
  "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
  "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
  "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
  "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
  "navy": [0,0,128,1], "oldlace": [253,245,230,1],
  "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
  "orange": [255,165,0,1], "orangered": [255,69,0,1],
  "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
  "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
  "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
  "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
  "pink": [255,192,203,1], "plum": [221,160,221,1],
  "powderblue": [176,224,230,1], "purple": [128,0,128,1],
  "red": [255,0,0,1], "rosybrown": [188,143,143,1],
  "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
  "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
  "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
  "sienna": [160,82,45,1], "silver": [192,192,192,1],
  "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
  "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
  "snow": [255,250,250,1], "springgreen": [0,255,127,1],
  "steelblue": [70,130,180,1], "tan": [210,180,140,1],
  "teal": [0,128,128,1], "thistle": [216,191,216,1],
  "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
  "violet": [238,130,238,1], "wheat": [245,222,179,1],
  "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
  "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]}

function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parse_css_int(str) {  // int or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_byte(parseFloat(str) / 100 * 255);
  return clamp_css_byte(parseInt(str));
}

function parse_css_float(str) {  // float or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_float(parseFloat(str) / 100);
  return clamp_css_float(parseFloat(str));
}

function css_hue_to_rgb(m1, m2, h) {
  if (h < 0) h += 1;
  else if (h > 1) h -= 1;

  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
  if (h * 2 < 1) return m2;
  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
  return m1;
}

function parseCSSColor(css_str) {
  // Remove all whitespace, not compliant, but should just be more accepting.
  var str = css_str.replace(/ /g, '').toLowerCase();

  // Color keywords (and transparent) lookup.
  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

  // #abc and #abc123 syntax.
  if (str[0] === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
              (iv & 0xf0) | ((iv & 0xf0) >> 4),
              (iv & 0xf) | ((iv & 0xf) << 4),
              1];
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
      return [(iv & 0xff0000) >> 16,
              (iv & 0xff00) >> 8,
              iv & 0xff,
              1];
    }

    return null;
  }

  var op = str.indexOf('('), ep = str.indexOf(')');
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op+1, ep-(op+1)).split(',');
    var alpha = 1;  // To allow case fallthrough.
    switch (fname) {
      case 'rgba':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'rgb':
        if (params.length !== 3) return null;
        return [parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha];
      case 'hsla':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'hsl':
        if (params.length !== 3) return null;
        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
        // NOTE(deanm): According to the CSS spec s/l should only be
        // percentages, but we don't bother and let float or percentage.
        var s = parse_css_float(params[1]);
        var l = parse_css_float(params[2]);
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var m1 = l * 2 - m2;
        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                alpha];
      default:
        return null;
    }
  }

  return null;
}

try { exports.parseCSSColor = parseCSSColor } catch(e) { }

},{}],20:[function(require,module,exports){
'use strict';

module.exports = earcut;

function earcut(points) {

    var outerNode = linkedList(points[0], true),
        node, minX, minY, maxX, maxY, x, y, size,
        len = 0,
        threshold = 80;

    for (var i = 0; len < threshold && i < points.length; i++) len += points[i].length;

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (len >= threshold) {
        node = outerNode.next;
        minX = maxX = node.p[0];
        minY = maxY = node.p[1];
        do {
            x = node.p[0];
            y = node.p[1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            node = node.next;
        } while (node !== outerNode);

        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }

    if (points.length > 1) outerNode = eliminateHoles(points, outerNode);

    var triangles = [];
    if (outerNode) earcutLinked(outerNode, triangles, minX, minY, size);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(points, clockwise) {
    var sum = 0,
        len = points.length,
        i, j, last;

    // calculate original winding order of a polygon ring
    for (i = 0, j = len - 1; i < len; j = i++) {
        var p1 = points[i],
            p2 = points[j];
        sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);
    }

    // link points into circular doubly-linked list in the specified winding order
    if (clockwise === (sum > 0)) {
        for (i = 0; i < len; i++) last = insertNode(points[i], last);
    } else {
        for (i = len - 1; i >= 0; i--) last = insertNode(points[i], last);
    }

    return last;
}

function filterPoints(start) {
    // eliminate colinear or duplicate points
    var node = start,
        again;
    do {
        again = false;

        if (equals(node.p, node.next.p) || orient(node.prev.p, node.p, node.next.p) === 0) {

            node.prev.next = node.next;
            node.next.prev = node.prev;

            if (node.prevZ) node.prevZ.nextZ = node.nextZ;
            if (node.nextZ) node.nextZ.prevZ = node.prevZ;

            node = start = node.prev;

            if (node === node.next) return null;
            again = true;

        } else {
            node = node.next;
        }
    } while (again || node !== start);

    return start;
}

function earcutLinked(ear, triangles, minX, minY, size, secondPass) {
    ear = filterPoints(ear);
    if (!ear) return;

    if (!secondPass && minX !== undefined) indexCurve(ear, minX, minY, size);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (isEar(ear, minX, minY, size)) {
            triangles.push(prev.p, ear.p, next.p);

            next.prev = prev;
            prev.next = next;

            if (ear.prevZ) ear.prevZ.nextZ = ear.nextZ;
            if (ear.nextZ) ear.nextZ.prevZ = ear.prevZ;

            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        if (ear === stop) {
            // if we can't find any more ears, try filtering points and cutting again
            if (!secondPass) earcutLinked(ear, triangles, minX, minY, size, true);
            // if this didn't work, try splitting the remaining polygon into two
            else splitEarcut(ear, triangles, minX, minY, size);
            break;
        }
    }
}

function isEar(ear, minX, minY, size) {

    var a = ear.prev.p,
        b = ear.p,
        c = ear.next.p,

        ax = a[0], bx = b[0], cx = c[0],
        ay = a[1], by = b[1], cy = c[1],

        abd = ax * by - ay * bx,
        acd = ax * cy - ay * cx,
        cbd = cx * by - cy * bx,
        A = abd - acd - cbd;

    if (A <= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear

    var cay = cy - ay,
        acx = ax - cx,
        aby = ay - by,
        bax = bx - ax,
        p, px, py, s, t, k, node;

    // if we use z-order curve hashing, iterate through the curve
    if (minX !== undefined) {

        // triangle bbox; min & max are calculated like this for speed
        var minTX = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
            minTY = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
            maxTX = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
            maxTY = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy),

            // z-order range for the current triangle bbox;
            minZ = zOrder(minTX, minTY, minX, minY, size),
            maxZ = zOrder(maxTX, maxTY, minX, minY, size);

        // first look for points inside the triangle in increasing z-order
        node = ear.nextZ;

        while (node && node.z <= maxZ) {
            p = node.p;
            node = node.nextZ;
            if (p === a || p === c) continue;

            px = p[0];
            py = p[1];

            s = cay * px + acx * py - acd;
            if (s >= 0) {
                t = aby * px + bax * py + abd;
                if (t >= 0) {
                    k = A - s - t;
                    if ((k >= 0) && ((s && t) || (s && k) || (t && k))) return false;
                }
            }
        }

        // then look for points in decreasing z-order
        node = ear.prevZ;

        while (node && node.z >= minZ) {
            p = node.p;
            node = node.prevZ;
            if (p === a || p === c) continue;

            px = p[0];
            py = p[1];

            s = cay * px + acx * py - acd;
            if (s >= 0) {
                t = aby * px + bax * py + abd;
                if (t >= 0) {
                    k = A - s - t;
                    if ((k >= 0) && ((s && t) || (s && k) || (t && k))) return false;
                }
            }
        }

    // if we don't use z-order curve hash, simply iterate through all other points
    } else {
        node = ear.next.next;

        while (node !== ear.prev) {
            p = node.p;
            node = node.next;

            px = p[0];
            py = p[1];

            s = cay * px + acx * py - acd;
            if (s >= 0) {
                t = aby * px + bax * py + abd;
                if (t >= 0) {
                    k = A - s - t;
                    if ((k >= 0) && ((s && t) || (s && k) || (t && k))) return false;
                }
            }
        }
    }

    return true;
}

function splitEarcut(start, triangles, minX, minY, size) {
    // find a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // run earcut on each half
                earcutLinked(a, triangles, minX, minY, size);
                earcutLinked(c, triangles, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

function eliminateHoles(points, outerNode) {
    var len = points.length;

    var queue = [];
    for (var i = 1; i < len; i++) {
        var list = filterPoints(linkedList(points[i], false));
        if (list) queue.push(getLeftmost(list));
    }
    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode);
    }

    return outerNode;
}

function eliminateHole(holeNode, outerNode) {
    outerNode = findHoleBridge(holeNode, outerNode);
    if (outerNode) splitPolygon(holeNode, outerNode);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(holeNode, outerNode) {
    var node = outerNode,
        p = holeNode.p,
        px = p[0],
        py = p[1],
        qMax = -Infinity,
        mNode, a, b;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        a = node.p;
        b = node.next.p;

        if (py <= a[1] && py >= b[1]) {
            var qx = a[0] + (py - a[1]) * (b[0] - a[0]) / (b[1] - a[1]);
            if (qx <= px && qx > qMax) {
                qMax = qx;
                mNode = a[0] < b[0] ? node : node.next;
            }
        }
        node = node.next;
    } while (node !== outerNode);

    if (!mNode) return null;

    // look for points strictly inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var bx = mNode.p[0],
        by = mNode.p[1],
        pbd = px * by - py * bx,
        pcd = px * py - py * qMax,
        cpy = py - py,
        pcx = px - qMax,
        pby = py - by,
        bpx = bx - px,
        A = pbd - pcd - (qMax * by - py * bx),
        sign = A <= 0 ? -1 : 1,
        stop = mNode,
        tanMin = Infinity,
        mx, my, amx, s, t, tan;

    node = mNode.next;

    while (node !== stop) {

        mx = node.p[0];
        my = node.p[1];
        amx = px - mx;

        if (amx >= 0 && mx >= bx) {
            s = (cpy * mx + pcx * my - pcd) * sign;
            if (s >= 0) {
                t = (pby * mx + bpx * my + pbd) * sign;

                if (t >= 0 && A * sign - s - t >= 0) {
                    tan = Math.abs(py - my) / amx; // tangential
                    if (tan < tanMin && locallyInside(node, holeNode)) {
                        mNode = node;
                        tanMin = tan;
                    }
                }
            }
        }

        node = node.next;
    }

    return mNode;
}

function indexCurve(start, minX, minY, size) {
    var node = start;

    do {
        node.z = node.z || zOrder(node.p[0], node.p[1], minX, minY, size);
        node.prevZ = node.prev;
        node.nextZ = node.next;
        node = node.next;
    } while (node !== start);

    node.prevZ.nextZ = null;
    node.prevZ = null;

    sortLinked(node);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    while (true) {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }

            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize === 0) {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                } else if (qSize === 0 || !q) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else if (p.z <= q.z) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;

        if (numMerges <= 1) return list;

        inSize *= 2;
    }
}

// z-order of a point given coords and bbox
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into (0..1000) integer range
    x = 1000 * (x - minX) / size;
    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = 1000 * (y - minY) / size;
    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

function getLeftmost(start) {
    var node = start,
        leftmost = start;
    do {
        if (node.p[0] < leftmost.p[0]) leftmost = node;
        node = node.next;
    } while (node !== start);

    return leftmost;
}

function isValidDiagonal(a, b) {
    return !intersectsPolygon(a, a.p, b.p) &&
           locallyInside(a, b) && locallyInside(b, a) &&
           middleInside(a, a.p, b.p);
}

// winding order of triangle formed by 3 given points
function orient(p, q, r) {
    var o = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
    return o > 0 ? 1 :
           o < 0 ? -1 : 0;
}

function equals(p1, p2) {
    return p1[0] === p2[0] && p1[1] === p2[1];
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    return orient(p1, q1, p2) !== orient(p1, q1, q2) &&
           orient(p2, q2, p1) !== orient(p2, q2, q1);
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(start, a, b) {
    var node = start;
    do {
        var p1 = node.p,
            p2 = node.next.p;

        if (p1 !== a && p2 !== a && p1 !== b && p2 !== b && intersects(p1, p2, a, b)) return true;

        node = node.next;
    } while (node !== start);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return orient(a.prev.p, a.p, a.next.p) === -1 ?
        orient(a.p, b.p, a.next.p) !== -1 && orient(a.p, a.prev.p, b.p) !== -1 :
        orient(a.p, b.p, a.prev.p) === -1 || orient(a.p, a.next.p, b.p) === -1;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(start, a, b) {
    var node = start,
        inside = false,
        px = (a[0] + b[0]) / 2,
        py = (a[1] + b[1]) / 2;
    do {
        var p1 = node.p,
            p2 = node.next.p;

        if (((p1[1] > py) !== (p2[1] > py)) &&
            (px < (p2[0] - p1[0]) * (py - p1[1]) / (p2[1] - p1[1]) + p1[0])) inside = !inside;

        node = node.next;
    } while (node !== start);

    return inside;
}

function compareX(a, b) {
    return a.p[0] - b.p[0];
}

// split the polygon vertices circular doubly-linked linked list into two
function splitPolygon(a, b) {
    var a2 = new Node(a.p),
        b2 = new Node(b.p),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return a2;
}

function insertNode(point, last) {
    var node = new Node(point);

    if (!last) {
        node.prev = node;
        node.next = node;

    } else {
        node.next = last.next;
        node.prev = last;
        last.next.prev = node;
        last.next = node;
    }
    return node;
}

function Node(p) {
    this.p = p;
    this.prev = null;
    this.next = null;

    this.z = null;
    this.prevZ = null;
    this.nextZ = null;
}

},{}],21:[function(require,module,exports){
'use strict';

module.exports = clip;

/* clip features between two axis-parallel lines:
 *     |        |
 *  ___|___     |     /
 * /   |   \____|____/
 *     |        |
 */

function clip(features, scale, k1, k2, axis, intersect, minAll, maxAll) {

    k1 /= scale;
    k2 /= scale;

    if (minAll >= k1 && maxAll <= k2) return features; // trivial accept
    else if (minAll > k2 || maxAll < k1) return null; // trivial reject

    var clipped = [];

    for (var i = 0; i < features.length; i++) {

        var feature = features[i],
            geometry = feature.geometry,
            type = feature.type,
            min, max;

        min = feature.min[axis];
        max = feature.max[axis];

        if (min >= k1 && max <= k2) { // trivial accept
            clipped.push(feature);
            continue;
        } else if (min > k2 || max < k1) continue; // trivial reject

        var slices = type === 1 ?
                clipPoints(geometry, k1, k2, axis) :
                clipGeometry(geometry, k1, k2, axis, intersect, type === 3);

        if (slices.length) {
            // if a feature got clipped, it will likely get clipped on the next zoom level as well,
            // so there's no need to recalculate bboxes
            clipped.push({
                geometry: slices,
                type: type,
                tags: features[i].tags || null,
                min: feature.min,
                max: feature.max
            });
        }
    }

    return clipped.length ? clipped : null;
}

function clipPoints(geometry, k1, k2, axis) {
    var slice = [];

    for (var i = 0; i < geometry.length; i++) {
        var a = geometry[i],
            ak = a[axis];

        if (ak >= k1 && ak <= k2) slice.push(a);
    }
    return slice;
}

function clipGeometry(geometry, k1, k2, axis, intersect, closed) {

    var slices = [];

    for (var i = 0; i < geometry.length; i++) {

        var ak = 0,
            bk = 0,
            b = null,
            points = geometry[i],
            area = points.area,
            dist = points.dist,
            len = points.length,
            a, j, last;

        var slice = [];

        for (j = 0; j < len - 1; j++) {
            a = b || points[j];
            b = points[j + 1];
            ak = bk || a[axis];
            bk = b[axis];

            if (ak < k1) {

                if ((bk > k2)) { // ---|-----|-->
                    slice.push(intersect(a, b, k1), intersect(a, b, k2));
                    if (!closed) slice = newSlice(slices, slice, area, dist);

                } else if (bk >= k1) slice.push(intersect(a, b, k1)); // ---|-->  |

            } else if (ak > k2) {

                if ((bk < k1)) { // <--|-----|---
                    slice.push(intersect(a, b, k2), intersect(a, b, k1));
                    if (!closed) slice = newSlice(slices, slice, area, dist);

                } else if (bk <= k2) slice.push(intersect(a, b, k2)); // |  <--|---

            } else {

                slice.push(a);

                if (bk < k1) { // <--|---  |
                    slice.push(intersect(a, b, k1));
                    if (!closed) slice = newSlice(slices, slice, area, dist);

                } else if (bk > k2) { // |  ---|-->
                    slice.push(intersect(a, b, k2));
                    if (!closed) slice = newSlice(slices, slice, area, dist);
                }
                // | --> |
            }
        }

        // add the last point
        a = points[len - 1];
        ak = a[axis];
        if (ak >= k1 && ak <= k2) slice.push(a);

        // close the polygon if its endpoints are not the same after clipping

        last = slice[slice.length - 1];
        if (closed && last && (slice[0][0] !== last[0] || slice[0][1] !== last[1])) slice.push(slice[0]);

        // add the final slice
        newSlice(slices, slice, area, dist);
    }

    return slices;
}

function newSlice(slices, slice, area, dist) {
    if (slice.length) {
        // we don't recalculate the area/length of the unclipped geometry because the case where it goes
        // below the visibility threshold as a result of clipping is rare, so we avoid doing unnecessary work
        slice.area = area;
        slice.dist = dist;

        slices.push(slice);
    }
    return [];
}

},{}],22:[function(require,module,exports){
'use strict';

module.exports = convert;

var simplify = require('./simplify');

// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data

function convert(data, tolerance) {
    var features = [];

    if (data.type === 'FeatureCollection') {
        for (var i = 0; i < data.features.length; i++) {
            convertFeature(features, data.features[i], tolerance);
        }
    } else if (data.type === 'Feature') {
        convertFeature(features, data, tolerance);

    } else {
        // single geometry or a geometry collection
        convertFeature(features, {geometry: data}, tolerance);
    }
    return features;
}

function convertFeature(features, feature, tolerance) {
    var geom = feature.geometry,
        type = geom.type,
        coords = geom.coordinates,
        tags = feature.properties,
        i, j, rings;

    if (type === 'Point') {
        features.push(create(tags, 1, [projectPoint(coords)]));

    } else if (type === 'MultiPoint') {
        features.push(create(tags, 1, project(coords)));

    } else if (type === 'LineString') {
        features.push(create(tags, 2, [project(coords, tolerance)]));

    } else if (type === 'MultiLineString' || type === 'Polygon') {
        rings = [];
        for (i = 0; i < coords.length; i++) {
            rings.push(project(coords[i], tolerance));
        }
        features.push(create(tags, type === 'Polygon' ? 3 : 2, rings));

    } else if (type === 'MultiPolygon') {
        rings = [];
        for (i = 0; i < coords.length; i++) {
            for (j = 0; j < coords[i].length; j++) {
                rings.push(project(coords[i][j], tolerance));
            }
        }
        features.push(create(tags, 3, rings));

    } else if (type === 'GeometryCollection') {
        for (i = 0; i < geom.geometries.length; i++) {
            convertFeature(features, {
                geometry: geom.geometries[i],
                properties: tags
            }, tolerance);
        }

    } else {
        throw new Error('Input data is not a valid GeoJSON object.');
    }
}

function create(tags, type, geometry) {
    var feature = {
        geometry: geometry,
        type: type,
        tags: tags || null,
        min: [2, 1], // initial bbox values;
        max: [-1, 0]  // note that coords are usually in [0..1] range
    };
    calcBBox(feature);
    return feature;
}

function project(lonlats, tolerance) {
    var projected = [];
    for (var i = 0; i < lonlats.length; i++) {
        projected.push(projectPoint(lonlats[i]));
    }
    if (tolerance) {
        simplify(projected, tolerance);
        calcSize(projected);
    }
    return projected;
}

function projectPoint(p) {
    var sin = Math.sin(p[1] * Math.PI / 180),
        x = (p[0] / 360 + 0.5),
        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);

    y = y < -1 ? -1 :
        y > 1 ? 1 : y;

    return [x, y, 0];
}

// calculate area and length of the poly
function calcSize(points) {
    var area = 0,
        dist = 0;

    for (var i = 0, a, b; i < points.length - 1; i++) {
        a = b || points[i];
        b = points[i + 1];

        area += a[0] * b[1] - b[0] * a[1];

        // use Manhattan distance instead of Euclidian one to avoid expensive square root computation
        dist += Math.abs(b[0] - a[0]) + Math.abs(b[1] - a[1]);
    }
    points.area = Math.abs(area / 2);
    points.dist = dist;
}

// calculate the feature bounding box for faster clipping later
function calcBBox(feature) {
    var geometry = feature.geometry,
        min = feature.min,
        max = feature.max;

    if (feature.type === 1) calcRingBBox(min, max, geometry);
    else for (var i = 0; i < geometry.length; i++) calcRingBBox(min, max, geometry[i]);

    return feature;
}

function calcRingBBox(min, max, points) {
    for (var i = 0, p; i < points.length; i++) {
        p = points[i];
        min[0] = Math.min(p[0], min[0]);
        max[0] = Math.max(p[0], max[0]);
        min[1] = Math.min(p[1], min[1]);
        max[1] = Math.max(p[1], max[1]);
    }
}

},{"./simplify":24}],23:[function(require,module,exports){
'use strict';

module.exports = geojsonvt;

var convert = require('./convert'), // GeoJSON conversion and preprocessing
    clip = require('./clip'),       // stripe clipping algorithm
    wrap = require('./wrap'),       // date line processing
    createTile = require('./tile'); // final simplified tile generation


function geojsonvt(data, options) {
    return new GeoJSONVT(data, options);
}

function GeoJSONVT(data, options) {
    options = this.options = extend(Object.create(this.options), options);

    var debug = options.debug;

    if (debug) console.time('preprocess data');

    var z2 = 1 << options.maxZoom, // 2^z
        features = convert(data, options.tolerance / (z2 * options.extent));

    this.tiles = {};

    if (debug) {
        console.timeEnd('preprocess data');
        console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);
        console.time('generate tiles');
        this.stats = {};
        this.total = 0;
    }

    features = wrap(features, options.buffer / options.extent, intersectX);

    // start slicing from the top tile down
    this.splitTile(features, 0, 0, 0);

    if (debug) {
        console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints);
        console.timeEnd('generate tiles');
        console.log('tiles generated:', this.total, JSON.stringify(this.stats));
    }
}

GeoJSONVT.prototype.options = {
    maxZoom: 14,            // max zoom to preserve detail on
    indexMaxZoom: 5,        // max zoom in the tile index
    indexMaxPoints: 100000, // max number of points per tile in the tile index
    tolerance: 3,           // simplification tolerance (higher means simpler)
    extent: 4096,           // tile extent
    buffer: 64,             // tile buffer on each side
    debug: 0                // logging level (0, 1 or 2)
};

GeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {

    var stack = [features, z, x, y],
        options = this.options,
        debug = options.debug,
        extent = options.extent,
        buffer = options.buffer;

    // avoid recursion by using a processing queue
    while (stack.length) {
        features = stack.shift();
        z = stack.shift();
        x = stack.shift();
        y = stack.shift();

        var z2 = 1 << z,
            id = toID(z, x, y),
            tile = this.tiles[id],
            tileTolerance = z === options.maxZoom ? 0 : options.tolerance / (z2 * extent);

        if (!tile) {
            if (debug > 1) console.time('creation');

            tile = this.tiles[id] = createTile(features, z2, x, y, tileTolerance, z === options.maxZoom);

            if (debug) {
                if (debug > 1) {
                    console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',
                        z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);
                    console.timeEnd('creation');
                }
                var key = 'z' + z;
                this.stats[key] = (this.stats[key] || 0) + 1;
                this.total++;
            }
        }

        // save reference to original geometry in tile so that we can drill down later if we stop now
        tile.source = features;

        // stop tiling if the tile is degenerate
        if (isClippedSquare(tile.features, extent, buffer)) continue;

        // if it's the first-pass tiling
        if (!cz) {
            // stop tiling if we reached max zoom, or if the tile is too simple
            if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) continue;

        // if a drilldown to a specific tile
        } else {
            // stop tiling if we reached base zoom or our target tile zoom
            if (z === options.maxZoom || z === cz) continue;

            // stop tiling if it's not an ancestor of the target tile
            var m = 1 << (cz - z);
            if (x !== Math.floor(cx / m) && y !== Math.floor(cy / m)) continue;
        }

        // if we slice further down, no need to keep source geometry
        tile.source = null;

        if (debug > 1) console.time('clipping');

        // values we'll use for clipping
        var k1 = 0.5 * buffer / extent,
            k2 = 0.5 - k1,
            k3 = 0.5 + k1,
            k4 = 1 + k1,
            tl, bl, tr, br, left, right;

        tl = bl = tr = br = null;

        left  = clip(features, z2, x - k1, x + k3, 0, intersectX, tile.min[0], tile.max[0]);
        right = clip(features, z2, x + k2, x + k4, 0, intersectX, tile.min[0], tile.max[0]);

        if (left) {
            tl = clip(left, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
            bl = clip(left, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
        }

        if (right) {
            tr = clip(right, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
            br = clip(right, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
        }

        if (debug > 1) console.timeEnd('clipping');

        if (tl) stack.push(tl, z + 1, x * 2,     y * 2);
        if (bl) stack.push(bl, z + 1, x * 2,     y * 2 + 1);
        if (tr) stack.push(tr, z + 1, x * 2 + 1, y * 2);
        if (br) stack.push(br, z + 1, x * 2 + 1, y * 2 + 1);
    }
};

GeoJSONVT.prototype.getTile = function (z, x, y) {
    var options = this.options,
        extent = options.extent,
        debug = options.debug;

    var z2 = 1 << z;
    x = ((x % z2) + z2) % z2; // wrap tile x coordinate

    var id = toID(z, x, y);
    if (this.tiles[id]) return transformTile(this.tiles[id], extent);

    if (debug > 1) console.log('drilling down to z%d-%d-%d', z, x, y);

    var z0 = z,
        x0 = x,
        y0 = y,
        parent;

    while (!parent && z0 > 0) {
        z0--;
        x0 = Math.floor(x0 / 2);
        y0 = Math.floor(y0 / 2);
        parent = this.tiles[toID(z0, x0, y0)];
    }

    if (debug > 1) console.log('found parent tile z%d-%d-%d', z0, x0, y0);

    // if we found a parent tile containing the original geometry, we can drill down from it
    if (parent.source) {
        if (isClippedSquare(parent.features, options.extent, options.buffer)) return transformTile(parent, extent);

        if (debug > 1) console.time('drilling down');
        this.splitTile(parent.source, z0, x0, y0, z, x, y);
        if (debug > 1) console.timeEnd('drilling down');
    }

    return transformTile(this.tiles[id], extent);
};

function transformTile(tile, extent) {
    if (!tile || tile.transformed) return tile;

    var z2 = tile.z2,
        tx = tile.x,
        ty = tile.y,
        i, j, k;

    for (i = 0; i < tile.features.length; i++) {
        var feature = tile.features[i],
            geom = feature.geometry,
            type = feature.type;

        if (type === 1) {
            for (j = 0; j < geom.length; j++) geom[j] = transformPoint(geom[j], extent, z2, tx, ty);

        } else {
            for (j = 0; j < geom.length; j++) {
                var ring = geom[j];
                for (k = 0; k < ring.length; k++) ring[k] = transformPoint(ring[k], extent, z2, tx, ty);
            }
        }
    }

    tile.transformed = true;

    return tile;
}

function transformPoint(p, extent, z2, tx, ty) {
    var x = Math.round(extent * (p[0] * z2 - tx)),
        y = Math.round(extent * (p[1] * z2 - ty));
    return [x, y];
}

// checks whether a tile is a whole-area fill after clipping; if it is, there's no sense slicing it further
function isClippedSquare(features, extent, buffer) {
    if (features.length !== 1) return false;

    var feature = features[0];
    if (feature.type !== 3 || feature.geometry.length > 1) return false;

    for (var i = 0; i < feature.geometry[0].length; i++) {
        var p = feature.geometry[0][i];
        if ((p[0] !== -buffer && p[0] !== extent + buffer) ||
            (p[1] !== -buffer && p[1] !== extent + buffer)) return false;
    }
    return true;
}

function toID(z, x, y) {
    return (((1 << z) * y + x) * 32) + z;
}

function intersectX(a, b, x) {
    return [x, (x - a[0]) * (b[1] - a[1]) / (b[0] - a[0]) + a[1], 1];
}
function intersectY(a, b, y) {
    return [(y - a[1]) * (b[0] - a[0]) / (b[1] - a[1]) + a[0], y, 1];
}

function extend(dest, src) {
    for (var i in src) dest[i] = src[i];
    return dest;
}

},{"./clip":21,"./convert":22,"./tile":25,"./wrap":26}],24:[function(require,module,exports){
'use strict';

module.exports = simplify;

// calculate simplification data using optimized Douglas-Peucker algorithm

function simplify(points, tolerance) {

    var sqTolerance = tolerance * tolerance,
        len = points.length,
        first = 0,
        last = len - 1,
        stack = [],
        i, maxSqDist, sqDist, index;

    // always retain the endpoints (1 is the max value)
    points[first][2] = 1;
    points[last][2] = 1;

    // avoid recursion by using a stack
    while (last) {

        maxSqDist = 0;

        for (i = first + 1; i < last; i++) {
            sqDist = getSqSegDist(points[i], points[first], points[last]);

            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }

        if (maxSqDist > sqTolerance) {
            points[index][2] = maxSqDist; // save the point importance in squared pixels as a z coordinate
            stack.push(first);
            stack.push(index);
            first = index;

        } else {
            last = stack.pop();
            first = stack.pop();
        }
    }
}

// square distance from a point to a segment
function getSqSegDist(p, a, b) {

    var x = a[0], y = a[1],
        bx = b[0], by = b[1],
        px = p[0], py = p[1],
        dx = bx - x,
        dy = by - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = bx;
            y = by;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = px - x;
    dy = py - y;

    return dx * dx + dy * dy;
}

},{}],25:[function(require,module,exports){
'use strict';

module.exports = createTile;

function createTile(features, z2, tx, ty, tolerance, noSimplify) {
    var tile = {
        features: [],
        numPoints: 0,
        numSimplified: 0,
        numFeatures: 0,
        source: null,
        x: tx,
        y: ty,
        z2: z2,
        transformed: false,
        min: [2, 1],
        max: [-1, 0]
    };
    for (var i = 0; i < features.length; i++) {
        tile.numFeatures++;
        addFeature(tile, features[i], tolerance, noSimplify);

        var min = features[i].min,
            max = features[i].max;

        if (min[0] < tile.min[0]) tile.min[0] = min[0];
        if (min[1] < tile.min[1]) tile.min[1] = min[1];
        if (max[0] > tile.max[0]) tile.max[0] = max[0];
        if (max[1] > tile.max[1]) tile.max[1] = max[1];
    }
    return tile;
}

function addFeature(tile, feature, tolerance, noSimplify) {

    var geom = feature.geometry,
        type = feature.type,
        simplified = [],
        sqTolerance = tolerance * tolerance,
        i, j, ring, p;

    if (type === 1) {
        for (i = 0; i < geom.length; i++) {
            simplified.push(geom[i]);
            tile.numPoints++;
            tile.numSimplified++;
        }

    } else {

        // simplify and transform projected coordinates for tile geometry
        for (i = 0; i < geom.length; i++) {
            ring = geom[i];

            // filter out tiny polylines & polygons
            if (!noSimplify && ((type === 2 && ring.dist < tolerance) ||
                                (type === 3 && ring.area < sqTolerance))) {
                tile.numPoints += ring.length;
                continue;
            }

            var simplifiedRing = [];

            for (j = 0; j < ring.length; j++) {
                p = ring[j];
                // keep points with importance > tolerance
                if (noSimplify || p[2] > sqTolerance) {
                    simplifiedRing.push(p);
                    tile.numSimplified++;
                }
                tile.numPoints++;
            }

            simplified.push(simplifiedRing);
        }
    }

    if (simplified.length) {
        tile.features.push({
            geometry: simplified,
            type: type,
            tags: feature.tags || null
        });
    }
}

},{}],26:[function(require,module,exports){
'use strict';

var clip = require('./clip');

module.exports = wrap;

function wrap(features, buffer, intersectX) {
    var merged = features,
        left  = clip(features, 1, -1 - buffer, buffer,     0, intersectX, -1, 2), // left world copy
        right = clip(features, 1,  1 - buffer, 2 + buffer, 0, intersectX, -1, 2); // right world copy

    if (left || right) {
        merged = clip(features, 1, -buffer, 1 + buffer, 0, intersectX, -1, 2); // center world copy

        if (left) merged = shiftFeatureCoords(left, 1).concat(merged); // merge left into center
        if (right) merged = merged.concat(shiftFeatureCoords(right, -1)); // merge right into center
    }

    return merged;
}

function shiftFeatureCoords(features, offset) {
    var newFeatures = [];

    for (var i = 0; i < features.length; i++) {
        var feature = features[i],
            type = feature.type;

        var newGeometry;

        if (type === 1) {
            newGeometry = shiftCoords(feature.geometry, offset);
        } else {
            newGeometry = [];
            for (var j = 0; j < feature.geometry.length; j++) {
                newGeometry.push(shiftCoords(feature.geometry[j], offset));
            }
        }

        newFeatures.push({
            geometry: newGeometry,
            type: type,
            tags: feature.tags,
            min: [feature.min[0] + offset, feature.min[1]],
            max: [feature.max[0] + offset, feature.max[1]]
        });
    }

    return newFeatures;
}

function shiftCoords(points, offset) {
    var newPoints = [];
    newPoints.area = points.area;
    newPoints.dist = points.dist;

    for (var i = 0; i < points.length; i++) {
        newPoints.push([points[i][0] + offset, points[i][1], points[i][2]]);
    }
    return newPoints;
}

},{"./clip":21}],27:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.2.1
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


(function(_global) {
  "use strict";

  var shim = {};
  if (typeof(exports) === 'undefined') {
    if(typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
      shim.exports = {};
      define(function() {
        return shim.exports;
      });
    } else {
      // gl-matrix lives in a browser, define its namespaces in global
      shim.exports = typeof(window) !== 'undefined' ? window : _global;
    }
  }
  else {
    // gl-matrix lives in commonjs, define its namespaces in exports
    shim.exports = exports;
  }

  (function(exports) {
    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


if(!GLMAT_EPSILON) {
    var GLMAT_EPSILON = 0.000001;
}

if(!GLMAT_ARRAY_TYPE) {
    var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
}

if(!GLMAT_RANDOM) {
    var GLMAT_RANDOM = Math.random;
}

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

/**
 * Sets the type of array used when creating new vectors and matricies
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    GLMAT_ARRAY_TYPE = type;
}

if(typeof(exports) !== 'undefined') {
    exports.glMatrix = glMatrix;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */

var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec2 = vec2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */

var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    var z = (GLMAT_RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/*
* Rotate a 3D vector around the x-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/*
* Rotate a 3D vector around the y-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/*
* Rotate a 3D vector around the z-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec3 = vec3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */

var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
        out[3] = a[3] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = GLMAT_RANDOM();
    out[1] = GLMAT_RANDOM();
    out[2] = GLMAT_RANDOM();
    out[3] = GLMAT_RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec4 = vec4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x2 Matrix
 * @name mat2
 */

var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 

if(typeof(exports) !== 'undefined') {
    exports.mat2 = mat2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;


/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

if(typeof(exports) !== 'undefined') {
    exports.mat2d = mat2d;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3x3 Matrix
 * @name mat3
 */

var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};


if(typeof(exports) !== 'undefined') {
    exports.mat3 = mat3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4x4 Matrix
 * @name mat4
 */

var mat4 = {};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < GLMAT_EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < GLMAT_EPSILON &&
        Math.abs(eyey - centery) < GLMAT_EPSILON &&
        Math.abs(eyez - centerz) < GLMAT_EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};


if(typeof(exports) !== 'undefined') {
    exports.mat4 = mat4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class Quaternion
 * @name quat
 */

var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[7]-m[5])*fRoot;
        out[1] = (m[2]-m[6])*fRoot;
        out[2] = (m[3]-m[1])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[k*3+j] - m[j*3+k]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.quat = quat;
}
;













  })(shim.exports);
})(this);

},{}],28:[function(require,module,exports){
module.exports = parseErrors

function parseErrors(log) {
  log = String(log)

  var logs = []
  var result

  while (result = log.match(/ERROR\:([^\n]+)/)) {
    log = log.slice(result.index + 1)

    var line = result[1].trim()
    var seps = line.split(':')
    var emsg = seps.slice(2).join(':').trim()
    var file = parseInt(seps[0], 10)
    var line = parseInt(seps[1], 10)

    logs.push({
        message: emsg
      , file: file
      , line: line
    })
  }

  return logs
}

},{}],29:[function(require,module,exports){
'use strict';


var yaml = require('./lib/js-yaml.js');


module.exports = yaml;

},{"./lib/js-yaml.js":30}],30:[function(require,module,exports){
'use strict';


var loader = require('./js-yaml/loader');
var dumper = require('./js-yaml/dumper');


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type                = require('./js-yaml/type');
module.exports.Schema              = require('./js-yaml/schema');
module.exports.FAILSAFE_SCHEMA     = require('./js-yaml/schema/failsafe');
module.exports.JSON_SCHEMA         = require('./js-yaml/schema/json');
module.exports.CORE_SCHEMA         = require('./js-yaml/schema/core');
module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = require('./js-yaml/exception');

// Deprecared schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');
module.exports.SAFE_SCHEMA    = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');

},{"./js-yaml/dumper":32,"./js-yaml/exception":33,"./js-yaml/loader":34,"./js-yaml/schema":36,"./js-yaml/schema/core":37,"./js-yaml/schema/default_full":38,"./js-yaml/schema/default_safe":39,"./js-yaml/schema/failsafe":40,"./js-yaml/schema/json":41,"./js-yaml/type":42}],31:[function(require,module,exports){
'use strict';


function isNothing(subject) {
  return (typeof subject === 'undefined') || (null === subject);
}


function isObject(subject) {
  return (typeof subject === 'object') && (null !== subject);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) {
    return sequence;
  } else if (isNothing(sequence)) {
    return [];
  }
  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (0 === number) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;

},{}],32:[function(require,module,exports){
'use strict';

/*eslint-disable no-use-before-define*/

var common              = require('./common');
var YAMLException       = require('./exception');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (null === map) {
    return {};
  }

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if ('!!' === tag.slice(0, 2)) {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }

    type = schema.compiledTypeMap[tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

function State(options) {
  this.schema      = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent      = Math.max(1, (options['indent'] || 2));
  this.skipInvalid = options['skipInvalid'] || false;
  this.flowLevel   = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap    = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys    = options['sortKeys'] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== '\n') {
      result += ind;
    }
    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

function StringBuilder(source) {
  this.source = source;
  this.result = '';
  this.checkpoint = 0;
}

StringBuilder.prototype.takeUpTo = function (position) {
  var er;

  if (position < this.checkpoint) {
    er = new Error('position should be > checkpoint');
    er.position = position;
    er.checkpoint = this.checkpoint;
    throw er;
  }

  this.result += this.source.slice(this.checkpoint, position);
  this.checkpoint = position;
  return this;
};

StringBuilder.prototype.escapeChar = function () {
  var character, esc;

  character = this.source.charCodeAt(this.checkpoint);
  esc = ESCAPE_SEQUENCES[character] || encodeHex(character);
  this.result += esc;
  this.checkpoint += 1;

  return this;
};

StringBuilder.prototype.finish = function () {
  if (this.source.length > this.checkpoint) {
    this.takeUpTo(this.source.length);
  }
};

function writeScalar(state, object, level) {
  var simple, first, spaceWrap, folded, literal, single, double,
      sawLineFeed, linePosition, longestLine, indent, max, character,
      position, escapeSeq, hexEsc, previous, lineLength, modifier,
      trailingLineBreaks, result;

  if (0 === object.length) {
    state.dump = "''";
    return;
  }

  if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {
    state.dump = "'" + object + "'";
    return;
  }

  simple = true;
  first = object.length ? object.charCodeAt(0) : 0;
  spaceWrap = (CHAR_SPACE === first ||
               CHAR_SPACE === object.charCodeAt(object.length - 1));

  // Simplified check for restricted first characters
  // http://www.yaml.org/spec/1.2/spec.html#ns-plain-first%28c%29
  if (CHAR_MINUS         === first ||
      CHAR_QUESTION      === first ||
      CHAR_COMMERCIAL_AT === first ||
      CHAR_GRAVE_ACCENT  === first) {
    simple = false;
  }

  // can only use > and | if not wrapped in spaces.
  if (spaceWrap) {
    simple = false;
    folded = false;
    literal = false;
  } else {
    folded = true;
    literal = true;
  }

  single = true;
  double = new StringBuilder(object);

  sawLineFeed = false;
  linePosition = 0;
  longestLine = 0;

  indent = state.indent * level;
  max = 80;
  if (indent < 40) {
    max -= indent;
  } else {
    max = 40;
  }

  for (position = 0; position < object.length; position++) {
    character = object.charCodeAt(position);
    if (simple) {
      // Characters that can never appear in the simple scalar
      if (!simpleChar(character)) {
        simple = false;
      } else {
        // Still simple.  If we make it all the way through like
        // this, then we can just dump the string as-is.
        continue;
      }
    }

    if (single && character === CHAR_SINGLE_QUOTE) {
      single = false;
    }

    escapeSeq = ESCAPE_SEQUENCES[character];
    hexEsc = needsHexEscape(character);

    if (!escapeSeq && !hexEsc) {
      continue;
    }

    if (character !== CHAR_LINE_FEED &&
        character !== CHAR_DOUBLE_QUOTE &&
        character !== CHAR_SINGLE_QUOTE) {
      folded = false;
      literal = false;
    } else if (character === CHAR_LINE_FEED) {
      sawLineFeed = true;
      single = false;
      if (position > 0) {
        previous = object.charCodeAt(position - 1);
        if (previous === CHAR_SPACE) {
          literal = false;
          folded = false;
        }
      }
      if (folded) {
        lineLength = position - linePosition;
        linePosition = position;
        if (lineLength > longestLine) {
          longestLine = lineLength;
        }
      }
    }

    if (character !== CHAR_DOUBLE_QUOTE) {
      single = false;
    }

    double.takeUpTo(position);
    double.escapeChar();
  }

  if (simple && testImplicitResolving(state, object)) {
    simple = false;
  }

  modifier = '';
  if (folded || literal) {
    trailingLineBreaks = 0;
    if (object.charCodeAt(object.length - 1) === CHAR_LINE_FEED) {
      trailingLineBreaks += 1;
      if (object.charCodeAt(object.length - 2) === CHAR_LINE_FEED) {
        trailingLineBreaks += 1;
      }
    }

    if (trailingLineBreaks === 0) {
      modifier = '-';
    } else if (trailingLineBreaks === 2) {
      modifier = '+';
    }
  }

  if (literal && longestLine < max) {
    folded = false;
  }

  // If it's literally one line, then don't bother with the literal.
  // We may still want to do a fold, though, if it's a super long line.
  if (!sawLineFeed) {
    literal = false;
  }

  if (simple) {
    state.dump = object;
  } else if (single) {
    state.dump = '\'' + object + '\'';
  } else if (folded) {
    result = fold(object, max);
    state.dump = '>' + modifier + '\n' + indentString(result, indent);
  } else if (literal) {
    if (!modifier) {
      object = object.replace(/\n$/, '');
    }
    state.dump = '|' + modifier + '\n' + indentString(object, indent);
  } else if (double) {
    double.finish();
    state.dump = '"' + double.result + '"';
  } else {
    throw new Error('Failed to dump scalar value');
  }

  return;
}

// The `trailing` var is a regexp match of any trailing `\n` characters.
//
// There are three cases we care about:
//
// 1. One trailing `\n` on the string.  Just use `|` or `>`.
//    This is the assumed default. (trailing = null)
// 2. No trailing `\n` on the string.  Use `|-` or `>-` to "chomp" the end.
// 3. More than one trailing `\n` on the string.  Use `|+` or `>+`.
//
// In the case of `>+`, these line breaks are *not* doubled (like the line
// breaks within the string), so it's important to only end with the exact
// same number as we started.
function fold(object, max) {
  var result = '',
      position = 0,
      length = object.length,
      trailing = /\n+$/.exec(object),
      newLine;

  if (trailing) {
    length = trailing.index + 1;
  }

  while (position < length) {
    newLine = object.indexOf('\n', position);
    if (newLine > length || newLine === -1) {
      if (result) {
        result += '\n\n';
      }
      result += foldLine(object.slice(position, length), max);
      position = length;
    } else {
      if (result) {
        result += '\n\n';
      }
      result += foldLine(object.slice(position, newLine), max);
      position = newLine + 1;
    }
  }
  if (trailing && trailing[0] !== '\n') {
    result += trailing[0];
  }

  return result;
}

function foldLine(line, max) {
  if (line === '') {
    return line;
  }

  var foldRe = /[^\s] [^\s]/g,
      result = '',
      prevMatch = 0,
      foldStart = 0,
      match = foldRe.exec(line),
      index,
      foldEnd,
      folded;

  while (match) {
    index = match.index;

    // when we cross the max len, if the previous match would've
    // been ok, use that one, and carry on.  If there was no previous
    // match on this fold section, then just have a long line.
    if (index - foldStart > max) {
      if (prevMatch !== foldStart) {
        foldEnd = prevMatch;
      } else {
        foldEnd = index;
      }

      if (result) {
        result += '\n';
      }
      folded = line.slice(foldStart, foldEnd);
      result += folded;
      foldStart = foldEnd + 1;
    }
    prevMatch = index + 1;
    match = foldRe.exec(line);
  }

  if (result) {
    result += '\n';
  }

  // if we end up with one last word at the end, then the last bit might
  // be slightly bigger than we wanted, because we exited out of the loop.
  if (foldStart !== prevMatch && line.length - foldStart > max) {
    result += line.slice(foldStart, prevMatch) + '\n' +
              line.slice(prevMatch + 1);
  } else {
    result += line.slice(foldStart);
  }

  return result;
}

// Returns true if character can be found in a simple scalar
function simpleChar(character) {
  return CHAR_TAB                  !== character &&
         CHAR_LINE_FEED            !== character &&
         CHAR_CARRIAGE_RETURN      !== character &&
         CHAR_COMMA                !== character &&
         CHAR_LEFT_SQUARE_BRACKET  !== character &&
         CHAR_RIGHT_SQUARE_BRACKET !== character &&
         CHAR_LEFT_CURLY_BRACKET   !== character &&
         CHAR_RIGHT_CURLY_BRACKET  !== character &&
         CHAR_SHARP                !== character &&
         CHAR_AMPERSAND            !== character &&
         CHAR_ASTERISK             !== character &&
         CHAR_EXCLAMATION          !== character &&
         CHAR_VERTICAL_LINE        !== character &&
         CHAR_GREATER_THAN         !== character &&
         CHAR_SINGLE_QUOTE         !== character &&
         CHAR_DOUBLE_QUOTE         !== character &&
         CHAR_PERCENT              !== character &&
         CHAR_COLON                !== character &&
         !ESCAPE_SEQUENCES[character]            &&
         !needsHexEscape(character);
}

// Returns true if the character code needs to be escaped.
function needsHexEscape(character) {
  return !((0x00020 <= character && character <= 0x00007E) ||
           (0x00085 === character)                         ||
           (0x000A0 <= character && character <= 0x00D7FF) ||
           (0x0E000 <= character && character <= 0x00FFFD) ||
           (0x10000 <= character && character <= 0x10FFFF));
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (0 !== index) {
        _result += ', ';
      }
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || 0 !== index) {
        _result += generateNextLine(state, level);
      }
      _result += '- ' + state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (0 !== index) {
      pairBuffer += ', ';
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) {
      pairBuffer += '? ';
    }

    pairBuffer += state.dump + ': ';

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || 0 !== index) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (null !== state.tag && '?' !== state.tag) ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || (('object' === typeof object) && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if ('[object Function]' === _toString.call(type.represent)) {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (0 > state.flowLevel || state.flowLevel > level);
  }

  if ((null !== state.tag && '?' !== state.tag) || (2 !== state.indent && level > 0)) {
    compact = false;
  }

  var objectOrArray = '[object Object]' === type || '[object Array]' === type,
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if ('[object Object]' === type) {
      if (block && (0 !== Object.keys(state.dump).length)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if ('[object Array]' === type) {
      if (block && (0 !== state.dump.length)) {
        writeBlockSequence(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if ('[object String]' === type) {
      if ('?' !== state.tag) {
        writeScalar(state, state.dump, level);
      }
    } else {
      if (state.skipInvalid) {
        return false;
      }
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (null !== state.tag && '?' !== state.tag) {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var type = _toString.call(object),
      objectKeyList,
      index,
      length;

  if (null !== object && 'object' === typeof object) {
    index = objects.indexOf(object);
    if (-1 !== index) {
      if (-1 === duplicatesIndexes.indexOf(index)) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) {
    return state.dump + '\n';
  }
  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump     = dump;
module.exports.safeDump = safeDump;

},{"./common":31,"./exception":33,"./schema/default_full":38,"./schema/default_safe":39}],33:[function(require,module,exports){
'use strict';


function YAMLException(reason, mark) {
  this.name    = 'YAMLException';
  this.reason  = reason;
  this.mark    = mark;
  this.message = this.toString(false);
}


YAMLException.prototype.toString = function toString(compact) {
  var result;

  result = 'JS-YAML: ' + (this.reason || '(unknown reason)');

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;

},{}],34:[function(require,module,exports){
'use strict';

/*eslint-disable max-len,no-use-before-define*/

var common              = require('./common');
var YAMLException       = require('./exception');
var Mark                = require('./mark');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return 0x2C/* , */ === c ||
         0x5B/* [ */ === c ||
         0x5D/* ] */ === c ||
         0x7B/* { */ === c ||
         0x7D/* } */ === c;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(((c - 0x010000) >> 10) + 0xD800,
                             ((c - 0x010000) & 0x03FF) + 0xDC00);
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  var error = generateError(state, message);

  if (state.onWarning) {
    state.onWarning.call(null, error);
  } else {
    throw error;
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

      var match, major, minor;

      if (null !== state.version) {
        throwError(state, 'duplication of %YAML directive');
      }

      if (1 !== args.length) {
        throwError(state, 'YAML directive accepts exactly one argument');
      }

      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

      if (null === match) {
        throwError(state, 'ill-formed argument of the YAML directive');
      }

      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);

      if (1 !== major) {
        throwError(state, 'unacceptable YAML version of the document');
      }

      state.version = args[0];
      state.checkLineBreaks = (minor < 2);

      if (1 !== minor && 2 !== minor) {
        throwWarning(state, 'unsupported YAML version of the document');
      }
    },

  TAG: function handleTagDirective(state, name, args) {

      var handle, prefix;

      if (2 !== args.length) {
        throwError(state, 'TAG directive accepts exactly two arguments');
      }

      handle = args[0];
      prefix = args[1];

      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
      }

      if (_hasOwnProperty.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }

      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
      }

      state.tagMap[handle] = prefix;
    }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length;
           _position < _length;
           _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(0x09 === _character ||
              0x20 <= _character && _character <= 0x10FFFF)) {
          throwError(state, 'expected valid JSON character');
        }
      }
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
    }
  }
}

function storeMappingPair(state, _result, keyTag, keyNode, valueNode) {
  var index, quantity;

  keyNode = String(keyNode);

  if (null === _result) {
    _result = {};
  }

  if ('tag:yaml.org,2002:merge' === keyTag) {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index]);
      }
    } else {
      mergeMappings(state, _result, valueNode);
    }
  } else {
    _result[keyNode] = valueNode;
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (0x0A/* LF */ === ch) {
    state.position++;
  } else if (0x0D/* CR */ === ch) {
    state.position++;
    if (0x0A/* LF */ === state.input.charCodeAt(state.position)) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && 0x23/* # */ === ch) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && 0 !== ch);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (0x20/* Space */ === ch) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (-1 !== checkIndent && 0 !== lineBreaks && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((0x2D/* - */ === ch || 0x2E/* . */ === ch) &&
      state.input.charCodeAt(_position + 1) === ch &&
      state.input.charCodeAt(_position + 2) === ch) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (1 === count) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)             ||
      is_FLOW_INDICATOR(ch)        ||
      0x23/* # */           === ch ||
      0x26/* & */           === ch ||
      0x2A/* * */           === ch ||
      0x21/* ! */           === ch ||
      0x7C/* | */           === ch ||
      0x3E/* > */           === ch ||
      0x27/* ' */           === ch ||
      0x22/* " */           === ch ||
      0x25/* % */           === ch ||
      0x40/* @ */           === ch ||
      0x60/* ` */           === ch) {
    return false;
  }

  if (0x3F/* ? */ === ch || 0x2D/* - */ === ch) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (0 !== ch) {
    if (0x3A/* : */ === ch) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (0x23/* # */ === ch) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (0x27/* ' */ !== ch) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    if (0x27/* ' */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (0x27/* ' */ === ch) {
        captureStart = captureEnd = state.position;
        state.position++;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp, tmpEsc,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x22/* " */ !== ch) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    if (0x22/* " */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (0x5C/* \ */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (0 !== ch) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (0x3F/* ? */ === ch) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && 0x3A/* : */ === ch) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (0x2C/* , */ === ch) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (0 !== ch) {
    ch = state.input.charCodeAt(++state.position);

    if (0x2B/* + */ === ch || 0x2D/* - */ === ch) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (0x2B/* + */ === ch) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (0x23/* # */ === ch) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (0 !== ch));
    }
  }

  while (0 !== ch) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (0x20/* Space */ === ch)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (detectedIndent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat('\n', emptyLines + 1);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (0 === emptyLines) {
        if (detectedIndent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else if (detectedIndent) {
      // If current line isn't the first one - count line break from the last content line.
      state.result += common.repeat('\n', emptyLines + 1);
    } else {
      // In case of the first content line - count only empty lines.
    }

    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (0 !== ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {

    if (0x2D/* - */ !== ch) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (0 !== ch)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((0x3F/* ? */ === ch || 0x3A/* : */  === ch) && is_WS_OR_EOL(following)) {

      if (0x3F/* ? */ === ch) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (0x3A/* : */ === ch) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, keyTag, keyNode, valueNode);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (0 !== ch)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x21/* ! */ !== ch) {
    return false;
  }

  if (null !== state.tag) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (0x3C/* < */ === ch) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (0x21/* ! */ === ch) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (0 !== ch && 0x3E/* > */ !== ch);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (0 !== ch && !is_WS_OR_EOL(ch)) {

      if (0x21/* ! */ === ch) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if ('!' === tagHandle) {
    state.tag = '!' + tagName;

  } else if ('!!' === tagHandle) {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x26/* & */ !== ch) {
    return false;
  }

  if (null !== state.anchor) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      len = state.length,
      input = state.input,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x2A/* * */ !== ch) {
    return false;
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent,
      _result;

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (1 === indentStatus) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (1 === indentStatus || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (1 === indentStatus) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (null !== state.tag || null !== state.anchor) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (null === state.tag) {
            state.tag = '?';
          }
        }

        if (null !== state.anchor) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (0 === indentStatus) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (null !== state.tag && '!' !== state.tag) {
    if ('?' === state.tag) {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length;
           typeIndex < typeQuantity;
           typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only assigned to plain scalars. So, it isn't
        // needed to check for 'kind' conformity.

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (null !== state.anchor) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
      type = state.typeMap[state.tag];

      if (null !== state.result && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (null !== state.anchor) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwWarning(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  return null !== state.tag || null !== state.anchor || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || 0x25/* % */ !== ch) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (0 !== ch && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (0 !== ch) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (0x23/* # */ === ch) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (0 !== ch && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) {
        break;
      }

      _position = state.position;

      while (0 !== ch && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (0 !== ch) {
      readLineBreak(state);
    }

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (0 === state.lineIndent &&
      0x2D/* - */ === state.input.charCodeAt(state.position) &&
      0x2D/* - */ === state.input.charCodeAt(state.position + 1) &&
      0x2D/* - */ === state.input.charCodeAt(state.position + 2)) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (0x2E/* . */ === state.input.charCodeAt(state.position)) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (0x0A/* LF */ !== input.charCodeAt(input.length - 1) &&
        0x0D/* CR */ !== input.charCodeAt(input.length - 1)) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  if (PATTERN_NON_PRINTABLE.test(state.input)) {
    throwError(state, 'the stream contains non-printable characters');
  }

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (0x20/* Space */ === state.input.charCodeAt(state.position)) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options), index, length;

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options), index, length;

  if (0 === documents.length) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (1 === documents.length) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}


function safeLoadAll(input, output, options) {
  loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;

},{"./common":31,"./exception":33,"./mark":35,"./schema/default_full":38,"./schema/default_safe":39}],35:[function(require,module,exports){
'use strict';


var common = require('./common');


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) {
    return null;
  }

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1))) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end))) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;

},{"./common":31}],36:[function(require,module,exports){
'use strict';

/*eslint-disable max-len*/

var common        = require('./common');
var YAMLException = require('./exception');
var Type          = require('./type');


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return -1 === exclude.indexOf(index);
  });
}


function compileMap(/* lists... */) {
  var result = {}, index, length;

  function collectType(type) {
    result[type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }

  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && 'scalar' !== type.loadKind) {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
  case 1:
    schemas = Schema.DEFAULT;
    types = arguments[0];
    break;

  case 2:
    schemas = arguments[0];
    types = arguments[1];
    break;

  default:
    throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;

},{"./common":31,"./exception":33,"./type":42}],37:[function(require,module,exports){
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./json')
  ]
});

},{"../schema":36,"./json":41}],38:[function(require,module,exports){
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.


'use strict';


var Schema = require('../schema');


module.exports = Schema.DEFAULT = new Schema({
  include: [
    require('./default_safe')
  ],
  explicit: [
    require('../type/js/undefined'),
    require('../type/js/regexp'),
    require('../type/js/function')
  ]
});

},{"../schema":36,"../type/js/function":47,"../type/js/regexp":48,"../type/js/undefined":49,"./default_safe":39}],39:[function(require,module,exports){
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./core')
  ],
  implicit: [
    require('../type/timestamp'),
    require('../type/merge')
  ],
  explicit: [
    require('../type/binary'),
    require('../type/omap'),
    require('../type/pairs'),
    require('../type/set')
  ]
});

},{"../schema":36,"../type/binary":43,"../type/merge":51,"../type/omap":53,"../type/pairs":54,"../type/set":56,"../type/timestamp":58,"./core":37}],40:[function(require,module,exports){
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  explicit: [
    require('../type/str'),
    require('../type/seq'),
    require('../type/map')
  ]
});

},{"../schema":36,"../type/map":50,"../type/seq":55,"../type/str":57}],41:[function(require,module,exports){
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./failsafe')
  ],
  implicit: [
    require('../type/null'),
    require('../type/bool'),
    require('../type/int'),
    require('../type/float')
  ]
});

},{"../schema":36,"../type/bool":44,"../type/float":45,"../type/int":46,"../type/null":52,"./failsafe":40}],42:[function(require,module,exports){
'use strict';

var YAMLException = require('./exception');

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (null !== map) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;

},{"./exception":33}],43:[function(require,module,exports){
'use strict';

/*eslint-disable no-bitwise*/

// A trick for browserified version.
// Since we make browserifier to ignore `buffer` module, NodeBuffer will be undefined
var NodeBuffer = require('buffer').Buffer;
var Type       = require('../type');


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (null === data) {
    return false;
  }

  var code, idx, bitlen = 0, len = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) { continue; }

    // Fail on illegal characters
    if (code < 0) { return false; }

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var code, idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    return new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

},{"../type":42,"buffer":14}],44:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlBoolean(data) {
  if (null === data) {
    return false;
  }

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return '[object Boolean]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":42}],45:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

var YAML_FLOAT_PATTERN = new RegExp(
  '^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?' +
  '|\\.[0-9_]+(?:[eE][-+][0-9]+)?' +
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  '|[-+]?\\.(?:inf|Inf|INF)' +
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (null === data) {
    return false;
  }

  var value, sign, base, digits;

  if (!YAML_FLOAT_PATTERN.test(data)) {
    return false;
  }
  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = '-' === value[0] ? -1 : 1;
  digits = [];

  if (0 <= '+-'.indexOf(value[0])) {
    value = value.slice(1);
  }

  if ('.inf' === value) {
    return (1 === sign) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if ('.nan' === value) {
    return NaN;

  } else if (0 <= value.indexOf(':')) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}

function representYamlFloat(object, style) {
  if (isNaN(object)) {
    switch (style) {
    case 'lowercase':
      return '.nan';
    case 'uppercase':
      return '.NAN';
    case 'camelcase':
      return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
    case 'lowercase':
      return '.inf';
    case 'uppercase':
      return '.INF';
    case 'camelcase':
      return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
    case 'lowercase':
      return '-.inf';
    case 'uppercase':
      return '-.INF';
    case 'camelcase':
      return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }
  return object.toString(10);
}

function isFloat(object) {
  return ('[object Number]' === Object.prototype.toString.call(object)) &&
         (0 !== object % 1 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

},{"../common":31,"../type":42}],46:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (null === data) {
    return false;
  }

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) { return false; }

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) { return true; }
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') { continue; }
        if (ch !== '0' && ch !== '1') {
          return false;
        }
        hasDigits = true;
      }
      return hasDigits;
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') { continue; }
        if (!isHexCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      return hasDigits;
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') { continue; }
      if (!isOctCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    return hasDigits;
  }

  // base 10 (except 0) or base 60

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') { continue; }
    if (ch === ':') { break; }
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  if (!hasDigits) { return false; }

  // if !base60 - done;
  if (ch !== ':') { return true; }

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') { sign = -1; }
    value = value.slice(1);
    ch = value[0];
  }

  if ('0' === value) {
    return 0;
  }

  if (ch === '0') {
    if (value[1] === 'b') {
      return sign * parseInt(value.slice(2), 2);
    }
    if (value[1] === 'x') {
      return sign * parseInt(value, 16);
    }
    return sign * parseInt(value, 8);

  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return ('[object Number]' === Object.prototype.toString.call(object)) &&
         (0 === object % 1 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (object) { return '0b' + object.toString(2); },
    octal:       function (object) { return '0'  + object.toString(8); },
    decimal:     function (object) { return        object.toString(10); },
    hexadecimal: function (object) { return '0x' + object.toString(16).toUpperCase(); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

},{"../common":31,"../type":42}],47:[function(require,module,exports){
'use strict';

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  esprima = require('esprima');
} catch (_) {
  /*global window */
  if (typeof window !== 'undefined') { esprima = window.esprima; }
}

var Type = require('../../type');

function resolveJavascriptFunction(data) {
  if (null === data) {
    return false;
  }

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true }),
        params = [],
        body;

    if ('Program'             !== ast.type         ||
        1                     !== ast.body.length  ||
        'ExpressionStatement' !== ast.body[0].type ||
        'FunctionExpression'  !== ast.body[0].expression.type) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if ('Program'             !== ast.type         ||
      1                     !== ast.body.length  ||
      'ExpressionStatement' !== ast.body[0].type ||
      'FunctionExpression'  !== ast.body[0].expression.type) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  /*eslint-disable no-new-func*/
  return new Function(params, source.slice(body[0] + 1, body[1] - 1));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return '[object Function]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

},{"../../type":42,"esprima":59}],48:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptRegExp(data) {
  if (null === data) {
    return false;
  }

  if (0 === data.length) {
    return false;
  }

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if ('/' === regexp[0]) {
    if (tail) {
      modifiers = tail[1];
    }

    if (modifiers.length > 3) { return false; }
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') { return false; }

    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  try {
    var dummy = new RegExp(regexp, modifiers);
    return true;
  } catch (error) {
    return false;
  }
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if ('/' === regexp[0]) {
    if (tail) {
      modifiers = tail[1];
    }
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) {
    result += 'g';
  }

  if (object.multiline) {
    result += 'm';
  }

  if (object.ignoreCase) {
    result += 'i';
  }

  return result;
}

function isRegExp(object) {
  return '[object RegExp]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

},{"../../type":42}],49:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return 'undefined' === typeof object;
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

},{"../../type":42}],50:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return null !== data ? data : {}; }
});

},{"../type":42}],51:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlMerge(data) {
  return '<<' === data || null === data;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

},{"../type":42}],52:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlNull(data) {
  if (null === data) {
    return true;
  }

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return null === object;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":42}],53:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (null === data) {
    return true;
  }

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if ('[object Object]' !== _toString.call(pair)) {
      return false;
    }

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) {
          pairHasKey = true;
        } else {
          return false;
        }
      }
    }

    if (!pairHasKey) {
      return false;
    }

    if (-1 === objectKeys.indexOf(pairKey)) {
      objectKeys.push(pairKey);
    } else {
      return false;
    }
  }

  return true;
}

function constructYamlOmap(data) {
  return null !== data ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

},{"../type":42}],54:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (null === data) {
    return true;
  }

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if ('[object Object]' !== _toString.call(pair)) {
      return false;
    }

    keys = Object.keys(pair);

    if (1 !== keys.length) {
      return false;
    }

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (null === data) {
    return [];
  }

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

},{"../type":42}],55:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return null !== data ? data : []; }
});

},{"../type":42}],56:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (null === data) {
    return true;
  }

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (null !== object[key]) {
        return false;
      }
    }
  }

  return true;
}

function constructYamlSet(data) {
  return null !== data ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

},{"../type":42}],57:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return null !== data ? data : ''; }
});

},{"../type":42}],58:[function(require,module,exports){
'use strict';

var Type = require('../type');

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:(?:[Tt]|[ \\t]+)'              + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?)?$');         // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (null === data) {
    return false;
  }

  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (null === match) {
    return false;
  }

  return true;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (null === match) {
    throw new Error('Date resolve error');
  }

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if ('-' === match[9]) {
      delta = -delta;
    }
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) {
    date.setTime(date.getTime() - delta);
  }

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

},{"../type":42}],59:[function(require,module,exports){
/*
  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.

    /* istanbul ignore next */
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.esprima = {}));
    }
}(this, function (exports) {
    'use strict';

    var Token,
        TokenName,
        FnExprTokens,
        Syntax,
        PlaceHolders,
        Messages,
        Regex,
        source,
        strict,
        sourceType,
        index,
        lineNumber,
        lineStart,
        hasLineTerminator,
        lastIndex,
        lastLineNumber,
        lastLineStart,
        startIndex,
        startLineNumber,
        startLineStart,
        scanning,
        length,
        lookahead,
        state,
        extra,
        isBindingElement,
        isAssignmentTarget,
        firstCoverInitializedNameError;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9,
        Template: 10
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';
    TokenName[Token.RegularExpression] = 'RegularExpression';
    TokenName[Token.Template] = 'Template';

    // A function following one of those tokens is an expression.
    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
                    'return', 'case', 'delete', 'throw', 'void',
                    // assignment operators
                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
                    '&=', '|=', '^=', ',',
                    // binary/unary operators
                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
                    '<=', '<', '>', '!=', '!=='];

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        Super: 'Super',
        SwitchCase: 'SwitchCase',
        SwitchStatement: 'SwitchStatement',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement'
    };

    PlaceHolders = {
        ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken: 'Unexpected token %0',
        UnexpectedNumber: 'Unexpected number',
        UnexpectedString: 'Unexpected string',
        UnexpectedIdentifier: 'Unexpected identifier',
        UnexpectedReserved: 'Unexpected reserved word',
        UnexpectedTemplate: 'Unexpected quasi %0',
        UnexpectedEOS: 'Unexpected end of input',
        NewlineAfterThrow: 'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp: 'Invalid regular expression: missing /',
        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally: 'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith: 'Strict mode code may not include a with statement',
        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord: 'Use of future reserved word in strict mode',
        TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
        ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
        DefaultRestParameter: 'Unexpected token =',
        ObjectPatternAsRestParameter: 'Unexpected token {',
        DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
        ConstructorSpecialMethod: 'Class constructor may not be an accessor',
        DuplicateConstructor: 'A class may only have one constructor',
        StaticPrototype: 'Classes may not have static property named prototype',
        MissingFromClause: 'Unexpected token',
        NoAsAfterImportNamespace: 'Unexpected token',
        InvalidModuleSpecifier: 'Unexpected token',
        IllegalImportDeclaration: 'Unexpected token',
        IllegalExportDeclaration: 'Unexpected token'
    };

    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        /* istanbul ignore if */
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function isDecimalDigit(ch) {
        return (ch >= 0x30 && ch <= 0x39);   // 0..9
    }

    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }

    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }

    function octalToDecimal(ch) {
        // \0 is not octal escape sequence
        var octal = (ch !== '0'), code = '01234567'.indexOf(ch);

        if (index < length && isOctalDigit(source[index])) {
            octal = true;
            code = code * 8 + '01234567'.indexOf(source[index++]);

            // 3 digits are only allowed when string starts
            // with 0, 1, 2, 3
            if ('0123'.indexOf(ch) >= 0 &&
                    index < length &&
                    isOctalDigit(source[index])) {
                code = code * 8 + '01234567'.indexOf(source[index++]);
            }
        }

        return {
            code: code,
            octal: octal
        };
    }

    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    // 7.6.1.2 Future Reserved Words

    function isFutureReservedWord(id) {
        switch (id) {
        case 'enum':
        case 'export':
        case 'import':
        case 'super':
            return true;
        default:
            return false;
        }
    }

    // 11.6.2.2 Future Reserved Words

    function isStrictModeReservedWord(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // 7.6.1.1 Keywords

    function isKeyword(id) {

        // 'const' is specialized as Keyword in V8.
        // 'yield' and 'let' are for compatibility with SpiderMonkey and ES.next.
        // Some others are from future reserved words.

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') ||
                (id === 'try') || (id === 'let');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    // 7.4 Comments

    function addComment(type, value, start, end, loc) {
        var comment;

        assert(typeof start === 'number', 'Comment must have valid position');

        state.lastCommentStart = start;

        comment = {
            type: type,
            value: value
        };
        if (extra.range) {
            comment.range = [start, end];
        }
        if (extra.loc) {
            comment.loc = loc;
        }
        extra.comments.push(comment);
        if (extra.attachComment) {
            extra.leadingComments.push(comment);
            extra.trailingComments.push(comment);
        }
    }

    function skipSingleLineComment(offset) {
        var start, loc, ch, comment;

        start = index - offset;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart - offset
            }
        };

        while (index < length) {
            ch = source.charCodeAt(index);
            ++index;
            if (isLineTerminator(ch)) {
                hasLineTerminator = true;
                if (extra.comments) {
                    comment = source.slice(start + offset, index - 1);
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    addComment('Line', comment, start, index - 1, loc);
                }
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                return;
            }
        }

        if (extra.comments) {
            comment = source.slice(start + offset, index);
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            addComment('Line', comment, start, index, loc);
        }
    }

    function skipMultiLineComment() {
        var start, loc, ch, comment;

        if (extra.comments) {
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (isLineTerminator(ch)) {
                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
                    ++index;
                }
                hasLineTerminator = true;
                ++lineNumber;
                ++index;
                lineStart = index;
            } else if (ch === 0x2A) {
                // Block comment ends with '*/'.
                if (source.charCodeAt(index + 1) === 0x2F) {
                    ++index;
                    ++index;
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 2);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment('Block', comment, start, index, loc);
                    }
                    return;
                }
                ++index;
            } else {
                ++index;
            }
        }

        // Ran off the end of the file - the whole thing is a comment
        if (extra.comments) {
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            comment = source.slice(start + 2, index);
            addComment('Block', comment, start, index, loc);
        }
        tolerateUnexpectedToken();
    }

    function skipComment() {
        var ch, start;
        hasLineTerminator = false;

        start = (index === 0);
        while (index < length) {
            ch = source.charCodeAt(index);

            if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                hasLineTerminator = true;
                ++index;
                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                start = true;
            } else if (ch === 0x2F) { // U+002F is '/'
                ch = source.charCodeAt(index + 1);
                if (ch === 0x2F) {
                    ++index;
                    ++index;
                    skipSingleLineComment(2);
                    start = true;
                } else if (ch === 0x2A) {  // U+002A is '*'
                    ++index;
                    ++index;
                    skipMultiLineComment();
                } else {
                    break;
                }
            } else if (start && ch === 0x2D) { // U+002D is '-'
                // U+003E is '>'
                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
                    // '-->' is a single-line comment
                    index += 3;
                    skipSingleLineComment(3);
                } else {
                    break;
                }
            } else if (ch === 0x3C) { // U+003C is '<'
                if (source.slice(index + 1, index + 4) === '!--') {
                    ++index; // `<`
                    ++index; // `!`
                    ++index; // `-`
                    ++index; // `-`
                    skipSingleLineComment(4);
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function scanUnicodeCodePointEscape() {
        var ch, code, cu1, cu2;

        ch = source[index];
        code = 0;

        // At least, one hex digit is required.
        if (ch === '}') {
            throwUnexpectedToken();
        }

        while (index < length) {
            ch = source[index++];
            if (!isHexDigit(ch)) {
                break;
            }
            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
        }

        if (code > 0x10FFFF || ch !== '}') {
            throwUnexpectedToken();
        }

        // UTF-16 Encoding
        if (code <= 0xFFFF) {
            return String.fromCharCode(code);
        }
        cu1 = ((code - 0x10000) >> 10) + 0xD800;
        cu2 = ((code - 0x10000) & 1023) + 0xDC00;
        return String.fromCharCode(cu1, cu2);
    }

    function getEscapedIdentifier() {
        var ch, id;

        ch = source.charCodeAt(index++);
        id = String.fromCharCode(ch);

        // '\u' (U+005C, U+0075) denotes an escaped character.
        if (ch === 0x5C) {
            if (source.charCodeAt(index) !== 0x75) {
                throwUnexpectedToken();
            }
            ++index;
            ch = scanHexEscape('u');
            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
                throwUnexpectedToken();
            }
            id = ch;
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (!isIdentifierPart(ch)) {
                break;
            }
            ++index;
            id += String.fromCharCode(ch);

            // '\u' (U+005C, U+0075) denotes an escaped character.
            if (ch === 0x5C) {
                id = id.substr(0, id.length - 1);
                if (source.charCodeAt(index) !== 0x75) {
                    throwUnexpectedToken();
                }
                ++index;
                ch = scanHexEscape('u');
                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
                    throwUnexpectedToken();
                }
                id += ch;
            }
        }

        return id;
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (ch === 0x5C) {
                // Blackslash (U+005C) marks Unicode escape sequence.
                index = start;
                return getEscapedIdentifier();
            }
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        // Backslash (U+005C) starts an escaped character.
        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }


    // 7.7 Punctuators

    function scanPunctuator() {
        var token, str;

        token = {
            type: Token.Punctuator,
            value: '',
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: index,
            end: index
        };

        // Check for most common single-character punctuators.
        str = source[index];
        switch (str) {

        case '(':
            if (extra.tokenize) {
                extra.openParenToken = extra.tokens.length;
            }
            ++index;
            break;

        case '{':
            if (extra.tokenize) {
                extra.openCurlyToken = extra.tokens.length;
            }
            state.curlyStack.push('{');
            ++index;
            break;

        case '.':
            ++index;
            if (source[index] === '.' && source[index + 1] === '.') {
                // Spread operator: ...
                index += 2;
                str = '...';
            }
            break;

        case '}':
            ++index;
            state.curlyStack.pop();
            break;
        case ')':
        case ';':
        case ',':
        case '[':
        case ']':
        case ':':
        case '?':
        case '~':
            ++index;
            break;

        default:
            // 4-character punctuator.
            str = source.substr(index, 4);
            if (str === '>>>=') {
                index += 4;
            } else {

                // 3-character punctuators.
                str = str.substr(0, 3);
                if (str === '===' || str === '!==' || str === '>>>' ||
                    str === '<<=' || str === '>>=') {
                    index += 3;
                } else {

                    // 2-character punctuators.
                    str = str.substr(0, 2);
                    if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
                        str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
                        str === '++' || str === '--' || str === '<<' || str === '>>' ||
                        str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
                        str === '<=' || str === '>=' || str === '=>') {
                        index += 2;
                    } else {

                        // 1-character punctuators.
                        str = source[index];
                        if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
                            ++index;
                        }
                    }
                }
            }
        }

        if (index === token.start) {
            throwUnexpectedToken();
        }

        token.end = index;
        token.value = str;
        return token;
    }

    // 7.8.3 Numeric Literals

    function scanHexLiteral(start) {
        var number = '';

        while (index < length) {
            if (!isHexDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            throwUnexpectedToken();
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt('0x' + number, 16),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanBinaryLiteral(start) {
        var ch, number;

        number = '';

        while (index < length) {
            ch = source[index];
            if (ch !== '0' && ch !== '1') {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            // only 0b or 0B
            throwUnexpectedToken();
        }

        if (index < length) {
            ch = source.charCodeAt(index);
            /* istanbul ignore else */
            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                throwUnexpectedToken();
            }
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 2),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanOctalLiteral(prefix, start) {
        var number, octal;

        if (isOctalDigit(prefix)) {
            octal = true;
            number = '0' + source[index++];
        } else {
            octal = false;
            ++index;
            number = '';
        }

        while (index < length) {
            if (!isOctalDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (!octal && number.length === 0) {
            // only 0o or 0O
            throwUnexpectedToken();
        }

        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function isImplicitOctalLiteral() {
        var i, ch;

        // Implicit octal, unless there is a non-octal digit.
        // (Annex B.1.1 on Numeric Literals)
        for (i = index + 1; i < length; ++i) {
            ch = source[i];
            if (ch === '8' || ch === '9') {
                return false;
            }
            if (!isOctalDigit(ch)) {
                return true;
            }
        }

        return true;
    }

    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            // Octal number in ES6 starts with '0o'.
            // Binary number in ES6 starts with '0b'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    ++index;
                    return scanHexLiteral(start);
                }
                if (ch === 'b' || ch === 'B') {
                    ++index;
                    return scanBinaryLiteral(start);
                }
                if (ch === 'o' || ch === 'O') {
                    return scanOctalLiteral(ch, start);
                }

                if (isOctalDigit(ch)) {
                    if (isImplicitOctalLiteral()) {
                        return scanOctalLiteral(ch, start);
                    }
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwUnexpectedToken();
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    // 7.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, unescaped, octToDec, octal = false;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            str += scanUnicodeCodePointEscape();
                        } else {
                            unescaped = scanHexEscape(ch);
                            if (!unescaped) {
                                throw throwUnexpectedToken();
                            }
                            str += unescaped;
                        }
                        break;
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\x0B';
                        break;
                    case '8':
                    case '9':
                        throw throwUnexpectedToken();

                    default:
                        if (isOctalDigit(ch)) {
                            octToDec = octalToDecimal(ch);

                            octal = octToDec.octal || octal;
                            str += String.fromCharCode(octToDec.code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwUnexpectedToken();
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            lineNumber: startLineNumber,
            lineStart: startLineStart,
            start: start,
            end: index
        };
    }

    function scanTemplate() {
        var cooked = '', ch, start, rawOffset, terminated, head, tail, restore, unescaped;

        terminated = false;
        tail = false;
        start = index;
        head = (source[index] === '`');
        rawOffset = 2;

        ++index;

        while (index < length) {
            ch = source[index++];
            if (ch === '`') {
                rawOffset = 1;
                tail = true;
                terminated = true;
                break;
            } else if (ch === '$') {
                if (source[index] === '{') {
                    state.curlyStack.push('${');
                    ++index;
                    terminated = true;
                    break;
                }
                cooked += ch;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'n':
                        cooked += '\n';
                        break;
                    case 'r':
                        cooked += '\r';
                        break;
                    case 't':
                        cooked += '\t';
                        break;
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            cooked += scanUnicodeCodePointEscape();
                        } else {
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) {
                                cooked += unescaped;
                            } else {
                                index = restore;
                                cooked += ch;
                            }
                        }
                        break;
                    case 'b':
                        cooked += '\b';
                        break;
                    case 'f':
                        cooked += '\f';
                        break;
                    case 'v':
                        cooked += '\v';
                        break;

                    default:
                        if (ch === '0') {
                            if (isDecimalDigit(source.charCodeAt(index))) {
                                // Illegal: \01 \02 and so on
                                throwError(Messages.TemplateOctalLiteral);
                            }
                            cooked += '\0';
                        } else if (isOctalDigit(ch)) {
                            // Illegal: \1 \2
                            throwError(Messages.TemplateOctalLiteral);
                        } else {
                            cooked += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                ++lineNumber;
                if (ch === '\r' && source[index] === '\n') {
                    ++index;
                }
                lineStart = index;
                cooked += '\n';
            } else {
                cooked += ch;
            }
        }

        if (!terminated) {
            throwUnexpectedToken();
        }

        if (!head) {
            state.curlyStack.pop();
        }

        return {
            type: Token.Template,
            value: {
                cooked: cooked,
                raw: source.slice(start + 1, index - rawOffset)
            },
            head: head,
            tail: tail,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function testRegExp(pattern, flags) {
        var tmp = pattern;

        if (flags.indexOf('u') >= 0) {
            // Replace each astral symbol and every Unicode escape sequence
            // that possibly represents an astral symbol or a paired surrogate
            // with a single ASCII symbol to avoid throwing on regular
            // expressions that are only valid in combination with the `/u`
            // flag.
            // Note: replacing with the ASCII symbol `x` might cause false
            // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
            // perfectly valid pattern that is equivalent to `[a-b]`, but it
            // would be replaced by `[x-b]` which throws an error.
            tmp = tmp
                .replace(/\\u\{([0-9a-fA-F]+)\}/g, function ($0, $1) {
                    if (parseInt($1, 16) <= 0x10FFFF) {
                        return 'x';
                    }
                    throwUnexpectedToken(null, Messages.InvalidRegExp);
                })
                .replace(
                    /\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                    'x'
                );
        }

        // First, detect invalid regular expressions.
        try {
            RegExp(tmp);
        } catch (e) {
            throwUnexpectedToken(null, Messages.InvalidRegExp);
        }

        // Return a regular expression object for this pattern-flag pair, or
        // `null` in case the current environment doesn't support the flags it
        // uses.
        try {
            return new RegExp(pattern, flags);
        } catch (exception) {
            return null;
        }
    }

    function scanRegExpBody() {
        var ch, str, classMarker, terminated, body;

        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];

        classMarker = false;
        terminated = false;
        while (index < length) {
            ch = source[index++];
            str += ch;
            if (ch === '\\') {
                ch = source[index++];
                // ECMA-262 7.8.5
                if (isLineTerminator(ch.charCodeAt(0))) {
                    throwUnexpectedToken(null, Messages.UnterminatedRegExp);
                }
                str += ch;
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                throwUnexpectedToken(null, Messages.UnterminatedRegExp);
            } else if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                }
            }
        }

        if (!terminated) {
            throwUnexpectedToken(null, Messages.UnterminatedRegExp);
        }

        // Exclude leading and trailing slash.
        body = str.substr(1, str.length - 2);
        return {
            value: body,
            literal: str
        };
    }

    function scanRegExpFlags() {
        var ch, str, flags, restore;

        str = '';
        flags = '';
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch.charCodeAt(0))) {
                break;
            }

            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        for (str += '\\u'; restore < index; ++restore) {
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                    tolerateUnexpectedToken();
                } else {
                    str += '\\';
                    tolerateUnexpectedToken();
                }
            } else {
                flags += ch;
                str += ch;
            }
        }

        return {
            value: flags,
            literal: str
        };
    }

    function scanRegExp() {
        scanning = true;
        var start, body, flags, value;

        lookahead = null;
        skipComment();
        start = index;

        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);
        scanning = false;
        if (extra.tokenize) {
            return {
                type: Token.RegularExpression,
                value: value,
                regex: {
                    pattern: body.value,
                    flags: flags.value
                },
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        return {
            literal: body.literal + flags.literal,
            value: value,
            regex: {
                pattern: body.value,
                flags: flags.value
            },
            start: start,
            end: index
        };
    }

    function collectRegex() {
        var pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        regex = scanRegExp();

        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        /* istanbul ignore next */
        if (!extra.tokenize) {
            // Pop the previous token, which is likely '/' or '/='
            if (extra.tokens.length > 0) {
                token = extra.tokens[extra.tokens.length - 1];
                if (token.range[0] === pos && token.type === 'Punctuator') {
                    if (token.value === '/' || token.value === '/=') {
                        extra.tokens.pop();
                    }
                }
            }

            extra.tokens.push({
                type: 'RegularExpression',
                value: regex.literal,
                regex: regex.regex,
                range: [pos, index],
                loc: loc
            });
        }

        return regex;
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advanceSlash() {
        var prevToken,
            checkToken;
        // Using the following algorithm:
        // https://github.com/mozilla/sweet.js/wiki/design
        prevToken = extra.tokens[extra.tokens.length - 1];
        if (!prevToken) {
            // Nothing before that: it cannot be a division.
            return collectRegex();
        }
        if (prevToken.type === 'Punctuator') {
            if (prevToken.value === ']') {
                return scanPunctuator();
            }
            if (prevToken.value === ')') {
                checkToken = extra.tokens[extra.openParenToken - 1];
                if (checkToken &&
                        checkToken.type === 'Keyword' &&
                        (checkToken.value === 'if' ||
                         checkToken.value === 'while' ||
                         checkToken.value === 'for' ||
                         checkToken.value === 'with')) {
                    return collectRegex();
                }
                return scanPunctuator();
            }
            if (prevToken.value === '}') {
                // Dividing a function by anything makes little sense,
                // but we have to check for that.
                if (extra.tokens[extra.openCurlyToken - 3] &&
                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                    // Anonymous function.
                    checkToken = extra.tokens[extra.openCurlyToken - 4];
                    if (!checkToken) {
                        return scanPunctuator();
                    }
                } else if (extra.tokens[extra.openCurlyToken - 4] &&
                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                    // Named function.
                    checkToken = extra.tokens[extra.openCurlyToken - 5];
                    if (!checkToken) {
                        return collectRegex();
                    }
                } else {
                    return scanPunctuator();
                }
                // checkToken determines whether the function is
                // a declaration or an expression.
                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
                    // It is an expression.
                    return scanPunctuator();
                }
                // It is a declaration.
                return collectRegex();
            }
            return collectRegex();
        }
        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
            return collectRegex();
        }
        return scanPunctuator();
    }

    function advance() {
        var ch, token;

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: index,
                end: index
            };
        }

        ch = source.charCodeAt(index);

        if (isIdentifierStart(ch)) {
            token = scanIdentifier();
            if (strict && isStrictModeReservedWord(token.value)) {
                token.type = Token.Keyword;
            }
            return token;
        }

        // Very common: ( and ) and ;
        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
            return scanPunctuator();
        }

        // String literal starts with single quote (U+0027) or double quote (U+0022).
        if (ch === 0x27 || ch === 0x22) {
            return scanStringLiteral();
        }

        // Dot (.) U+002E can also start a floating-point number, hence the need
        // to check the next character.
        if (ch === 0x2E) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }

        // Slash (/) U+002F can also start a regex.
        if (extra.tokenize && ch === 0x2F) {
            return advanceSlash();
        }

        // Template literals start with ` (U+0060) for template head
        // or } (U+007D) for template middle or template tail.
        if (ch === 0x60 || (ch === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${')) {
            return scanTemplate();
        }

        return scanPunctuator();
    }

    function collectToken() {
        var loc, token, value, entry;

        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        token = advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (token.type !== Token.EOF) {
            value = source.slice(token.start, token.end);
            entry = {
                type: TokenName[token.type],
                value: value,
                range: [token.start, token.end],
                loc: loc
            };
            if (token.regex) {
                entry.regex = {
                    pattern: token.regex.pattern,
                    flags: token.regex.flags
                };
            }
            extra.tokens.push(entry);
        }

        return token;
    }

    function lex() {
        var token;
        scanning = true;

        lastIndex = index;
        lastLineNumber = lineNumber;
        lastLineStart = lineStart;

        skipComment();

        token = lookahead;

        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        scanning = false;
        return token;
    }

    function peek() {
        scanning = true;

        skipComment();

        lastIndex = index;
        lastLineNumber = lineNumber;
        lastLineStart = lineStart;

        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        scanning = false;
    }

    function Position() {
        this.line = startLineNumber;
        this.column = startIndex - startLineStart;
    }

    function SourceLocation() {
        this.start = new Position();
        this.end = null;
    }

    function WrappingSourceLocation(startToken) {
        this.start = {
            line: startToken.lineNumber,
            column: startToken.start - startToken.lineStart
        };
        this.end = null;
    }

    function Node() {
        if (extra.range) {
            this.range = [startIndex, 0];
        }
        if (extra.loc) {
            this.loc = new SourceLocation();
        }
    }

    function WrappingNode(startToken) {
        if (extra.range) {
            this.range = [startToken.start, 0];
        }
        if (extra.loc) {
            this.loc = new WrappingSourceLocation(startToken);
        }
    }

    WrappingNode.prototype = Node.prototype = {

        processComment: function () {
            var lastChild,
                leadingComments,
                trailingComments,
                bottomRight = extra.bottomRightStack,
                i,
                comment,
                last = bottomRight[bottomRight.length - 1];

            if (this.type === Syntax.Program) {
                if (this.body.length > 0) {
                    return;
                }
            }

            if (extra.trailingComments.length > 0) {
                trailingComments = [];
                for (i = extra.trailingComments.length - 1; i >= 0; --i) {
                    comment = extra.trailingComments[i];
                    if (comment.range[0] >= this.range[1]) {
                        trailingComments.unshift(comment);
                        extra.trailingComments.splice(i, 1);
                    }
                }
                extra.trailingComments = [];
            } else {
                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {
                    trailingComments = last.trailingComments;
                    delete last.trailingComments;
                }
            }

            // Eating the stack.
            if (last) {
                while (last && last.range[0] >= this.range[0]) {
                    lastChild = last;
                    last = bottomRight.pop();
                }
            }

            if (lastChild) {
                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= this.range[0]) {
                    this.leadingComments = lastChild.leadingComments;
                    lastChild.leadingComments = undefined;
                }
            } else if (extra.leadingComments.length > 0) {
                leadingComments = [];
                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
                    comment = extra.leadingComments[i];
                    if (comment.range[1] <= this.range[0]) {
                        leadingComments.unshift(comment);
                        extra.leadingComments.splice(i, 1);
                    }
                }
            }


            if (leadingComments && leadingComments.length > 0) {
                this.leadingComments = leadingComments;
            }
            if (trailingComments && trailingComments.length > 0) {
                this.trailingComments = trailingComments;
            }

            bottomRight.push(this);
        },

        finish: function () {
            if (extra.range) {
                this.range[1] = lastIndex;
            }
            if (extra.loc) {
                this.loc.end = {
                    line: lastLineNumber,
                    column: lastIndex - lastLineStart
                };
                if (extra.source) {
                    this.loc.source = extra.source;
                }
            }

            if (extra.attachComment) {
                this.processComment();
            }
        },

        finishArrayExpression: function (elements) {
            this.type = Syntax.ArrayExpression;
            this.elements = elements;
            this.finish();
            return this;
        },

        finishArrayPattern: function (elements) {
            this.type = Syntax.ArrayPattern;
            this.elements = elements;
            this.finish();
            return this;
        },

        finishArrowFunctionExpression: function (params, defaults, body, expression) {
            this.type = Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = false;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishAssignmentExpression: function (operator, left, right) {
            this.type = Syntax.AssignmentExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishAssignmentPattern: function (left, right) {
            this.type = Syntax.AssignmentPattern;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBinaryExpression: function (operator, left, right) {
            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBlockStatement: function (body) {
            this.type = Syntax.BlockStatement;
            this.body = body;
            this.finish();
            return this;
        },

        finishBreakStatement: function (label) {
            this.type = Syntax.BreakStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishCallExpression: function (callee, args) {
            this.type = Syntax.CallExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishCatchClause: function (param, body) {
            this.type = Syntax.CatchClause;
            this.param = param;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassBody: function (body) {
            this.type = Syntax.ClassBody;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassDeclaration: function (id, superClass, body) {
            this.type = Syntax.ClassDeclaration;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
            this.finish();
            return this;
        },

        finishClassExpression: function (id, superClass, body) {
            this.type = Syntax.ClassExpression;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
            this.finish();
            return this;
        },

        finishConditionalExpression: function (test, consequent, alternate) {
            this.type = Syntax.ConditionalExpression;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishContinueStatement: function (label) {
            this.type = Syntax.ContinueStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishDebuggerStatement: function () {
            this.type = Syntax.DebuggerStatement;
            this.finish();
            return this;
        },

        finishDoWhileStatement: function (body, test) {
            this.type = Syntax.DoWhileStatement;
            this.body = body;
            this.test = test;
            this.finish();
            return this;
        },

        finishEmptyStatement: function () {
            this.type = Syntax.EmptyStatement;
            this.finish();
            return this;
        },

        finishExpressionStatement: function (expression) {
            this.type = Syntax.ExpressionStatement;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishForStatement: function (init, test, update, body) {
            this.type = Syntax.ForStatement;
            this.init = init;
            this.test = test;
            this.update = update;
            this.body = body;
            this.finish();
            return this;
        },

        finishForInStatement: function (left, right, body) {
            this.type = Syntax.ForInStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.each = false;
            this.finish();
            return this;
        },

        finishFunctionDeclaration: function (id, params, defaults, body) {
            this.type = Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = false;
            this.expression = false;
            this.finish();
            return this;
        },

        finishFunctionExpression: function (id, params, defaults, body) {
            this.type = Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.generator = false;
            this.expression = false;
            this.finish();
            return this;
        },

        finishIdentifier: function (name) {
            this.type = Syntax.Identifier;
            this.name = name;
            this.finish();
            return this;
        },

        finishIfStatement: function (test, consequent, alternate) {
            this.type = Syntax.IfStatement;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishLabeledStatement: function (label, body) {
            this.type = Syntax.LabeledStatement;
            this.label = label;
            this.body = body;
            this.finish();
            return this;
        },

        finishLiteral: function (token) {
            this.type = Syntax.Literal;
            this.value = token.value;
            this.raw = source.slice(token.start, token.end);
            if (token.regex) {
                this.regex = token.regex;
            }
            this.finish();
            return this;
        },

        finishMemberExpression: function (accessor, object, property) {
            this.type = Syntax.MemberExpression;
            this.computed = accessor === '[';
            this.object = object;
            this.property = property;
            this.finish();
            return this;
        },

        finishNewExpression: function (callee, args) {
            this.type = Syntax.NewExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishObjectExpression: function (properties) {
            this.type = Syntax.ObjectExpression;
            this.properties = properties;
            this.finish();
            return this;
        },

        finishObjectPattern: function (properties) {
            this.type = Syntax.ObjectPattern;
            this.properties = properties;
            this.finish();
            return this;
        },

        finishPostfixExpression: function (operator, argument) {
            this.type = Syntax.UpdateExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = false;
            this.finish();
            return this;
        },

        finishProgram: function (body) {
            this.type = Syntax.Program;
            this.body = body;
            if (sourceType === 'module') {
                // very restrictive for now
                this.sourceType = sourceType;
            }
            this.finish();
            return this;
        },

        finishProperty: function (kind, key, computed, value, method, shorthand) {
            this.type = Syntax.Property;
            this.key = key;
            this.computed = computed;
            this.value = value;
            this.kind = kind;
            this.method = method;
            this.shorthand = shorthand;
            this.finish();
            return this;
        },

        finishRestElement: function (argument) {
            this.type = Syntax.RestElement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishReturnStatement: function (argument) {
            this.type = Syntax.ReturnStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishSequenceExpression: function (expressions) {
            this.type = Syntax.SequenceExpression;
            this.expressions = expressions;
            this.finish();
            return this;
        },

        finishSpreadElement: function (argument) {
            this.type = Syntax.SpreadElement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishSwitchCase: function (test, consequent) {
            this.type = Syntax.SwitchCase;
            this.test = test;
            this.consequent = consequent;
            this.finish();
            return this;
        },

        finishSuper: function () {
            this.type = Syntax.Super;
            this.finish();
            return this;
        },

        finishSwitchStatement: function (discriminant, cases) {
            this.type = Syntax.SwitchStatement;
            this.discriminant = discriminant;
            this.cases = cases;
            this.finish();
            return this;
        },

        finishTaggedTemplateExpression: function (tag, quasi) {
            this.type = Syntax.TaggedTemplateExpression;
            this.tag = tag;
            this.quasi = quasi;
            this.finish();
            return this;
        },

        finishTemplateElement: function (value, tail) {
            this.type = Syntax.TemplateElement;
            this.value = value;
            this.tail = tail;
            this.finish();
            return this;
        },

        finishTemplateLiteral: function (quasis, expressions) {
            this.type = Syntax.TemplateLiteral;
            this.quasis = quasis;
            this.expressions = expressions;
            this.finish();
            return this;
        },

        finishThisExpression: function () {
            this.type = Syntax.ThisExpression;
            this.finish();
            return this;
        },

        finishThrowStatement: function (argument) {
            this.type = Syntax.ThrowStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishTryStatement: function (block, handler, finalizer) {
            this.type = Syntax.TryStatement;
            this.block = block;
            this.guardedHandlers = [];
            this.handlers = handler ? [ handler ] : [];
            this.handler = handler;
            this.finalizer = finalizer;
            this.finish();
            return this;
        },

        finishUnaryExpression: function (operator, argument) {
            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = true;
            this.finish();
            return this;
        },

        finishVariableDeclaration: function (declarations) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = 'var';
            this.finish();
            return this;
        },

        finishLexicalDeclaration: function (declarations, kind) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = kind;
            this.finish();
            return this;
        },

        finishVariableDeclarator: function (id, init) {
            this.type = Syntax.VariableDeclarator;
            this.id = id;
            this.init = init;
            this.finish();
            return this;
        },

        finishWhileStatement: function (test, body) {
            this.type = Syntax.WhileStatement;
            this.test = test;
            this.body = body;
            this.finish();
            return this;
        },

        finishWithStatement: function (object, body) {
            this.type = Syntax.WithStatement;
            this.object = object;
            this.body = body;
            this.finish();
            return this;
        },

        finishExportSpecifier: function (local, exported) {
            this.type = Syntax.ExportSpecifier;
            this.exported = exported || local;
            this.local = local;
            this.finish();
            return this;
        },

        finishImportDefaultSpecifier: function (local) {
            this.type = Syntax.ImportDefaultSpecifier;
            this.local = local;
            this.finish();
            return this;
        },

        finishImportNamespaceSpecifier: function (local) {
            this.type = Syntax.ImportNamespaceSpecifier;
            this.local = local;
            this.finish();
            return this;
        },

        finishExportNamedDeclaration: function (declaration, specifiers, src) {
            this.type = Syntax.ExportNamedDeclaration;
            this.declaration = declaration;
            this.specifiers = specifiers;
            this.source = src;
            this.finish();
            return this;
        },

        finishExportDefaultDeclaration: function (declaration) {
            this.type = Syntax.ExportDefaultDeclaration;
            this.declaration = declaration;
            this.finish();
            return this;
        },

        finishExportAllDeclaration: function (src) {
            this.type = Syntax.ExportAllDeclaration;
            this.source = src;
            this.finish();
            return this;
        },

        finishImportSpecifier: function (local, imported) {
            this.type = Syntax.ImportSpecifier;
            this.local = local || imported;
            this.imported = imported;
            this.finish();
            return this;
        },

        finishImportDeclaration: function (specifiers, src) {
            this.type = Syntax.ImportDeclaration;
            this.specifiers = specifiers;
            this.source = src;
            this.finish();
            return this;
        }
    };


    function recordError(error) {
        var e, existing;

        for (e = 0; e < extra.errors.length; e++) {
            existing = extra.errors[e];
            // Prevent duplicated error.
            /* istanbul ignore next */
            if (existing.index === error.index && existing.message === error.message) {
                return;
            }
        }

        extra.errors.push(error);
    }

    function createError(line, pos, description) {
        var error = new Error('Line ' + line + ': ' + description);
        error.index = pos;
        error.lineNumber = line;
        error.column = pos - (scanning ? lineStart : lastLineStart) + 1;
        error.description = description;
        return error;
    }

    // Throw an exception

    function throwError(messageFormat) {
        var args, msg;

        args = Array.prototype.slice.call(arguments, 1);
        msg = messageFormat.replace(/%(\d)/g,
            function (whole, idx) {
                assert(idx < args.length, 'Message reference must be in range');
                return args[idx];
            }
        );

        throw createError(lastLineNumber, lastIndex, msg);
    }

    function tolerateError(messageFormat) {
        var args, msg, error;

        args = Array.prototype.slice.call(arguments, 1);
        /* istanbul ignore next */
        msg = messageFormat.replace(/%(\d)/g,
            function (whole, idx) {
                assert(idx < args.length, 'Message reference must be in range');
                return args[idx];
            }
        );

        error = createError(lineNumber, lastIndex, msg);
        if (extra.errors) {
            recordError(error);
        } else {
            throw error;
        }
    }

    // Throw an exception because of the token.

    function unexpectedTokenError(token, message) {
        var value, msg = message || Messages.UnexpectedToken;

        if (token) {
            if (!message) {
                msg = (token.type === Token.EOF) ? Messages.UnexpectedEOS :
                    (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :
                    (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :
                    (token.type === Token.StringLiteral) ? Messages.UnexpectedString :
                    (token.type === Token.Template) ? Messages.UnexpectedTemplate :
                    Messages.UnexpectedToken;

                if (token.type === Token.Keyword) {
                    if (isFutureReservedWord(token.value)) {
                        msg = Messages.UnexpectedReserved;
                    } else if (strict && isStrictModeReservedWord(token.value)) {
                        msg = Messages.StrictReservedWord;
                    }
                }
            }

            value = (token.type === Token.Template) ? token.value.raw : token.value;
        } else {
            value = 'ILLEGAL';
        }

        msg = msg.replace('%0', value);

        return (token && typeof token.lineNumber === 'number') ?
            createError(token.lineNumber, token.start, msg) :
            createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);
    }

    function throwUnexpectedToken(token, message) {
        throw unexpectedTokenError(token, message);
    }

    function tolerateUnexpectedToken(token, message) {
        var error = unexpectedTokenError(token, message);
        if (extra.errors) {
            recordError(error);
        } else {
            throw error;
        }
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpectedToken(token);
        }
    }

    /**
     * @name expectCommaSeparator
     * @description Quietly expect a comma when in tolerant mode, otherwise delegates
     * to <code>expect(value)</code>
     * @since 2.0
     */
    function expectCommaSeparator() {
        var token;

        if (extra.errors) {
            token = lookahead;
            if (token.type === Token.Punctuator && token.value === ',') {
                lex();
            } else if (token.type === Token.Punctuator && token.value === ';') {
                lex();
                tolerateUnexpectedToken(token);
            } else {
                tolerateUnexpectedToken(token, Messages.UnexpectedToken);
            }
        } else {
            expect(',');
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpectedToken(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }

    // Return true if the next token matches the specified contextual keyword
    // (where an identifier is sometimes a keyword depending on the context)

    function matchContextualKeyword(keyword) {
        return lookahead.type === Token.Identifier && lookahead.value === keyword;
    }

    // Return true if the next token is an assignment operator

    function matchAssign() {
        var op;

        if (lookahead.type !== Token.Punctuator) {
            return false;
        }
        op = lookahead.value;
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    function consumeSemicolon() {
        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(startIndex) === 0x3B || match(';')) {
            lex();
            return;
        }

        if (hasLineTerminator) {
            return;
        }

        // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.
        lastIndex = startIndex;
        lastLineNumber = startLineNumber;
        lastLineStart = startLineStart;

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpectedToken(lookahead);
        }
    }

    // Cover grammar support.
    //
    // When an assignment expression position starts with an left parenthesis, the determination of the type
    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
    //
    // There are three productions that can be parsed in a parentheses pair that needs to be determined
    // after the outermost pair is closed. They are:
    //
    //   1. AssignmentExpression
    //   2. BindingElements
    //   3. AssignmentTargets
    //
    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
    // binding element or assignment target.
    //
    // The three productions have the relationship:
    //
    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
    //
    // with a single exception that CoverInitializedName when used directly in an Expression, generates
    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
    //
    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
    // the CoverInitializedName check is conducted.
    //
    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
    // pattern. The CoverInitializedName check is deferred.
    function isolateCoverGrammar(parser) {
        var oldIsBindingElement = isBindingElement,
            oldIsAssignmentTarget = isAssignmentTarget,
            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
            result;
        isBindingElement = true;
        isAssignmentTarget = true;
        firstCoverInitializedNameError = null;
        result = parser();
        if (firstCoverInitializedNameError !== null) {
            throwUnexpectedToken(firstCoverInitializedNameError);
        }
        isBindingElement = oldIsBindingElement;
        isAssignmentTarget = oldIsAssignmentTarget;
        firstCoverInitializedNameError = oldFirstCoverInitializedNameError;
        return result;
    }

    function inheritCoverGrammar(parser) {
        var oldIsBindingElement = isBindingElement,
            oldIsAssignmentTarget = isAssignmentTarget,
            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
            result;
        isBindingElement = true;
        isAssignmentTarget = true;
        firstCoverInitializedNameError = null;
        result = parser();
        isBindingElement = isBindingElement && oldIsBindingElement;
        isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;
        firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;
        return result;
    }

    function parseArrayPattern() {
        var node = new Node(), elements = [], rest, restNode;
        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                if (match('...')) {
                    restNode = new Node();
                    lex();
                    rest = parseVariableIdentifier();
                    elements.push(restNode.finishRestElement(rest));
                    break;
                } else {
                    elements.push(parsePatternWithDefault());
                }
                if (!match(']')) {
                    expect(',');
                }
            }

        }

        expect(']');

        return node.finishArrayPattern(elements);
    }

    function parsePropertyPattern() {
        var node = new Node(), key, computed = match('['), init;
        if (lookahead.type === Token.Identifier) {
            key = parseVariableIdentifier();
            if (match('=')) {
                lex();
                init = parseAssignmentExpression();
                return node.finishProperty(
                    'init', key, false,
                    new WrappingNode(key).finishAssignmentPattern(key, init), false, false);
            } else if (!match(':')) {
                return node.finishProperty('init', key, false, key, false, true);
            }
        } else {
            key = parseObjectPropertyKey();
        }
        expect(':');
        init = parsePatternWithDefault();
        return node.finishProperty('init', key, computed, init, false, false);
    }

    function parseObjectPattern() {
        var node = new Node(), properties = [];

        expect('{');

        while (!match('}')) {
            properties.push(parsePropertyPattern());
            if (!match('}')) {
                expect(',');
            }
        }

        lex();

        return node.finishObjectPattern(properties);
    }

    function parsePattern() {
        if (lookahead.type === Token.Identifier) {
            return parseVariableIdentifier();
        } else if (match('[')) {
            return parseArrayPattern();
        } else if (match('{')) {
            return parseObjectPattern();
        }
        throwUnexpectedToken(lookahead);
    }

    function parsePatternWithDefault() {
        var startToken = lookahead, pattern, right;
        pattern = parsePattern();
        if (match('=')) {
            lex();
            right = isolateCoverGrammar(parseAssignmentExpression);
            pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);
        }
        return pattern;
    }

    // 11.1.4 Array Initialiser

    function parseArrayInitialiser() {
        var elements = [], node = new Node(), restSpread;

        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else if (match('...')) {
                restSpread = new Node();
                lex();
                restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));

                if (!match(']')) {
                    isAssignmentTarget = isBindingElement = false;
                    expect(',');
                }
                elements.push(restSpread);
            } else {
                elements.push(inheritCoverGrammar(parseAssignmentExpression));

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        lex();

        return node.finishArrayExpression(elements);
    }

    // 11.1.5 Object Initialiser

    function parsePropertyFunction(node, paramInfo) {
        var previousStrict, body;

        isAssignmentTarget = isBindingElement = false;

        previousStrict = strict;
        body = isolateCoverGrammar(parseFunctionSourceElements);

        if (strict && paramInfo.firstRestricted) {
            tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);
        }
        if (strict && paramInfo.stricted) {
            tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);
        }

        strict = previousStrict;
        return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body);
    }

    function parsePropertyMethodFunction() {
        var params, method, node = new Node();

        params = parseParams();
        method = parsePropertyFunction(node, params);

        return method;
    }

    function parseObjectPropertyKey() {
        var token, node = new Node(), expr;

        token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        switch (token.type) {
        case Token.StringLiteral:
        case Token.NumericLiteral:
            if (strict && token.octal) {
                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
            }
            return node.finishLiteral(token);
        case Token.Identifier:
        case Token.BooleanLiteral:
        case Token.NullLiteral:
        case Token.Keyword:
            return node.finishIdentifier(token.value);
        case Token.Punctuator:
            if (token.value === '[') {
                expr = isolateCoverGrammar(parseAssignmentExpression);
                expect(']');
                return expr;
            }
            break;
        }
        throwUnexpectedToken(token);
    }

    function lookaheadPropertyName() {
        switch (lookahead.type) {
        case Token.Identifier:
        case Token.StringLiteral:
        case Token.BooleanLiteral:
        case Token.NullLiteral:
        case Token.NumericLiteral:
        case Token.Keyword:
            return true;
        case Token.Punctuator:
            return lookahead.value === '[';
        }
        return false;
    }

    // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,
    // it might be called at a position where there is in fact a short hand identifier pattern or a data property.
    // This can only be determined after we consumed up to the left parentheses.
    //
    // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller
    // is responsible to visit other options.
    function tryParseMethodDefinition(token, key, computed, node) {
        var value, options, methodNode;

        if (token.type === Token.Identifier) {
            // check for `get` and `set`;

            if (token.value === 'get' && lookaheadPropertyName()) {
                computed = match('[');
                key = parseObjectPropertyKey();
                methodNode = new Node();
                expect('(');
                expect(')');
                value = parsePropertyFunction(methodNode, {
                    params: [],
                    defaults: [],
                    stricted: null,
                    firstRestricted: null,
                    message: null
                });
                return node.finishProperty('get', key, computed, value, false, false);
            } else if (token.value === 'set' && lookaheadPropertyName()) {
                computed = match('[');
                key = parseObjectPropertyKey();
                methodNode = new Node();
                expect('(');

                options = {
                    params: [],
                    defaultCount: 0,
                    defaults: [],
                    firstRestricted: null,
                    paramSet: {}
                };
                if (match(')')) {
                    tolerateUnexpectedToken(lookahead);
                } else {
                    parseParam(options);
                    if (options.defaultCount === 0) {
                        options.defaults = [];
                    }
                }
                expect(')');

                value = parsePropertyFunction(methodNode, options);
                return node.finishProperty('set', key, computed, value, false, false);
            }
        }

        if (match('(')) {
            value = parsePropertyMethodFunction();
            return node.finishProperty('init', key, computed, value, true, false);
        }

        // Not a MethodDefinition.
        return null;
    }

    function checkProto(key, computed, hasProto) {
        if (computed === false && (key.type === Syntax.Identifier && key.name === '__proto__' ||
            key.type === Syntax.Literal && key.value === '__proto__')) {
            if (hasProto.value) {
                tolerateError(Messages.DuplicateProtoProperty);
            } else {
                hasProto.value = true;
            }
        }
    }

    function parseObjectProperty(hasProto) {
        var token = lookahead, node = new Node(), computed, key, maybeMethod, value;

        computed = match('[');
        key = parseObjectPropertyKey();
        maybeMethod = tryParseMethodDefinition(token, key, computed, node);

        if (maybeMethod) {
            checkProto(maybeMethod.key, maybeMethod.computed, hasProto);
            // finished
            return maybeMethod;
        }

        // init property or short hand property.
        checkProto(key, computed, hasProto);

        if (match(':')) {
            lex();
            value = inheritCoverGrammar(parseAssignmentExpression);
            return node.finishProperty('init', key, computed, value, false, false);
        }

        if (token.type === Token.Identifier) {
            if (match('=')) {
                firstCoverInitializedNameError = lookahead;
                lex();
                value = isolateCoverGrammar(parseAssignmentExpression);
                return node.finishProperty('init', key, computed,
                    new WrappingNode(token).finishAssignmentPattern(key, value), false, true);
            }
            return node.finishProperty('init', key, computed, key, false, true);
        }

        throwUnexpectedToken(lookahead);
    }

    function parseObjectInitialiser() {
        var properties = [], hasProto = {value: false}, node = new Node();

        expect('{');

        while (!match('}')) {
            properties.push(parseObjectProperty(hasProto));

            if (!match('}')) {
                expectCommaSeparator();
            }
        }

        expect('}');

        return node.finishObjectExpression(properties);
    }

    function reinterpretExpressionAsPattern(expr) {
        var i;
        switch (expr.type) {
        case Syntax.Identifier:
        case Syntax.MemberExpression:
        case Syntax.RestElement:
        case Syntax.AssignmentPattern:
            break;
        case Syntax.SpreadElement:
            expr.type = Syntax.RestElement;
            reinterpretExpressionAsPattern(expr.argument);
            break;
        case Syntax.ArrayExpression:
            expr.type = Syntax.ArrayPattern;
            for (i = 0; i < expr.elements.length; i++) {
                if (expr.elements[i] !== null) {
                    reinterpretExpressionAsPattern(expr.elements[i]);
                }
            }
            break;
        case Syntax.ObjectExpression:
            expr.type = Syntax.ObjectPattern;
            for (i = 0; i < expr.properties.length; i++) {
                reinterpretExpressionAsPattern(expr.properties[i].value);
            }
            break;
        case Syntax.AssignmentExpression:
            expr.type = Syntax.AssignmentPattern;
            reinterpretExpressionAsPattern(expr.left);
            break;
        default:
            // Allow other node type for tolerant parsing.
            break;
        }
    }

    function parseTemplateElement(option) {
        var node, token;

        if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {
            throwUnexpectedToken();
        }

        node = new Node();
        token = lex();

        return node.finishTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail);
    }

    function parseTemplateLiteral() {
        var quasi, quasis, expressions, node = new Node();

        quasi = parseTemplateElement({ head: true });
        quasis = [ quasi ];
        expressions = [];

        while (!quasi.tail) {
            expressions.push(parseExpression());
            quasi = parseTemplateElement({ head: false });
            quasis.push(quasi);
        }

        return node.finishTemplateLiteral(quasis, expressions);
    }

    // 11.1.6 The Grouping Operator

    function parseGroupExpression() {
        var expr, expressions, startToken, i;

        expect('(');

        if (match(')')) {
            lex();
            if (!match('=>')) {
                expect('=>');
            }
            return {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: []
            };
        }

        startToken = lookahead;
        if (match('...')) {
            expr = parseRestElement();
            expect(')');
            if (!match('=>')) {
                expect('=>');
            }
            return {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: [expr]
            };
        }

        isBindingElement = true;
        expr = inheritCoverGrammar(parseAssignmentExpression);

        if (match(',')) {
            isAssignmentTarget = false;
            expressions = [expr];

            while (startIndex < length) {
                if (!match(',')) {
                    break;
                }
                lex();

                if (match('...')) {
                    if (!isBindingElement) {
                        throwUnexpectedToken(lookahead);
                    }
                    expressions.push(parseRestElement());
                    expect(')');
                    if (!match('=>')) {
                        expect('=>');
                    }
                    isBindingElement = false;
                    for (i = 0; i < expressions.length; i++) {
                        reinterpretExpressionAsPattern(expressions[i]);
                    }
                    return {
                        type: PlaceHolders.ArrowParameterPlaceHolder,
                        params: expressions
                    };
                }

                expressions.push(inheritCoverGrammar(parseAssignmentExpression));
            }

            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
        }


        expect(')');

        if (match('=>')) {
            if (!isBindingElement) {
                throwUnexpectedToken(lookahead);
            }

            if (expr.type === Syntax.SequenceExpression) {
                for (i = 0; i < expr.expressions.length; i++) {
                    reinterpretExpressionAsPattern(expr.expressions[i]);
                }
            } else {
                reinterpretExpressionAsPattern(expr);
            }

            expr = {
                type: PlaceHolders.ArrowParameterPlaceHolder,
                params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]
            };
        }
        isBindingElement = false;
        return expr;
    }


    // 11.1 Primary Expressions

    function parsePrimaryExpression() {
        var type, token, expr, node;

        if (match('(')) {
            isBindingElement = false;
            return inheritCoverGrammar(parseGroupExpression);
        }

        if (match('[')) {
            return inheritCoverGrammar(parseArrayInitialiser);
        }

        if (match('{')) {
            return inheritCoverGrammar(parseObjectInitialiser);
        }

        type = lookahead.type;
        node = new Node();

        if (type === Token.Identifier) {
            expr = node.finishIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            isAssignmentTarget = isBindingElement = false;
            if (strict && lookahead.octal) {
                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);
            }
            expr = node.finishLiteral(lex());
        } else if (type === Token.Keyword) {
            isAssignmentTarget = isBindingElement = false;
            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }
            if (matchKeyword('this')) {
                lex();
                return node.finishThisExpression();
            }
            if (matchKeyword('class')) {
                return parseClassExpression();
            }
            throwUnexpectedToken(lex());
        } else if (type === Token.BooleanLiteral) {
            isAssignmentTarget = isBindingElement = false;
            token = lex();
            token.value = (token.value === 'true');
            expr = node.finishLiteral(token);
        } else if (type === Token.NullLiteral) {
            isAssignmentTarget = isBindingElement = false;
            token = lex();
            token.value = null;
            expr = node.finishLiteral(token);
        } else if (match('/') || match('/=')) {
            isAssignmentTarget = isBindingElement = false;
            index = startIndex;

            if (typeof extra.tokens !== 'undefined') {
                token = collectRegex();
            } else {
                token = scanRegExp();
            }
            lex();
            expr = node.finishLiteral(token);
        } else if (type === Token.Template) {
            expr = parseTemplateLiteral();
        } else {
            throwUnexpectedToken(lex());
        }

        return expr;
    }

    // 11.2 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [];

        expect('(');

        if (!match(')')) {
            while (startIndex < length) {
                args.push(isolateCoverGrammar(parseAssignmentExpression));
                if (match(')')) {
                    break;
                }
                expectCommaSeparator();
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token, node = new Node();

        token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpectedToken(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = isolateCoverGrammar(parseExpression);

        expect(']');

        return expr;
    }

    function parseNewExpression() {
        var callee, args, node = new Node();

        expectKeyword('new');
        callee = isolateCoverGrammar(parseLeftHandSideExpression);
        args = match('(') ? parseArguments() : [];

        isAssignmentTarget = isBindingElement = false;

        return node.finishNewExpression(callee, args);
    }

    function parseLeftHandSideExpressionAllowCall() {
        var quasi, expr, args, property, startToken, previousAllowIn = state.allowIn;

        startToken = lookahead;
        state.allowIn = true;

        if (matchKeyword('super') && state.inFunctionBody) {
            expr = new Node();
            lex();
            expr = expr.finishSuper();
            if (!match('(') && !match('.') && !match('[')) {
                throwUnexpectedToken(lookahead);
            }
        } else {
            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
        }

        for (;;) {
            if (match('.')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else if (match('(')) {
                isBindingElement = false;
                isAssignmentTarget = false;
                args = parseArguments();
                expr = new WrappingNode(startToken).finishCallExpression(expr, args);
            } else if (match('[')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else if (lookahead.type === Token.Template && lookahead.head) {
                quasi = parseTemplateLiteral();
                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
            } else {
                break;
            }
        }
        state.allowIn = previousAllowIn;

        return expr;
    }

    function parseLeftHandSideExpression() {
        var quasi, expr, property, startToken;
        assert(state.allowIn, 'callee of new expression always allow in keyword.');

        startToken = lookahead;

        if (matchKeyword('super') && state.inFunctionBody) {
            expr = new Node();
            lex();
            expr = expr.finishSuper();
            if (!match('[') && !match('.')) {
                throwUnexpectedToken(lookahead);
            }
        } else {
            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
        }

        for (;;) {
            if (match('[')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else if (match('.')) {
                isBindingElement = false;
                isAssignmentTarget = true;
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else if (lookahead.type === Token.Template && lookahead.head) {
                quasi = parseTemplateLiteral();
                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
            } else {
                break;
            }
        }
        return expr;
    }

    // 11.3 Postfix Expressions

    function parsePostfixExpression() {
        var expr, token, startToken = lookahead;

        expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);

        if (!hasLineTerminator && lookahead.type === Token.Punctuator) {
            if (match('++') || match('--')) {
                // 11.3.1, 11.3.2
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    tolerateError(Messages.StrictLHSPostfix);
                }

                if (!isAssignmentTarget) {
                    tolerateError(Messages.InvalidLHSInAssignment);
                }

                isAssignmentTarget = isBindingElement = false;

                token = lex();
                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);
            }
        }

        return expr;
    }

    // 11.4 Unary Operators

    function parseUnaryExpression() {
        var token, expr, startToken;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        } else if (match('++') || match('--')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            // 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                tolerateError(Messages.StrictLHSPrefix);
            }

            if (!isAssignmentTarget) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            isAssignmentTarget = isBindingElement = false;
        } else if (match('+') || match('-') || match('~') || match('!')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            isAssignmentTarget = isBindingElement = false;
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            startToken = lookahead;
            token = lex();
            expr = inheritCoverGrammar(parseUnaryExpression);
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                tolerateError(Messages.StrictDelete);
            }
            isAssignmentTarget = isBindingElement = false;
        } else {
            expr = parsePostfixExpression();
        }

        return expr;
    }

    function binaryPrecedence(token, allowIn) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
        case '||':
            prec = 1;
            break;

        case '&&':
            prec = 2;
            break;

        case '|':
            prec = 3;
            break;

        case '^':
            prec = 4;
            break;

        case '&':
            prec = 5;
            break;

        case '==':
        case '!=':
        case '===':
        case '!==':
            prec = 6;
            break;

        case '<':
        case '>':
        case '<=':
        case '>=':
        case 'instanceof':
            prec = 7;
            break;

        case 'in':
            prec = allowIn ? 7 : 0;
            break;

        case '<<':
        case '>>':
        case '>>>':
            prec = 8;
            break;

        case '+':
        case '-':
            prec = 9;
            break;

        case '*':
        case '/':
        case '%':
            prec = 11;
            break;

        default:
            break;
        }

        return prec;
    }

    // 11.5 Multiplicative Operators
    // 11.6 Additive Operators
    // 11.7 Bitwise Shift Operators
    // 11.8 Relational Operators
    // 11.9 Equality Operators
    // 11.10 Binary Bitwise Operators
    // 11.11 Binary Logical Operators

    function parseBinaryExpression() {
        var marker, markers, expr, token, prec, stack, right, operator, left, i;

        marker = lookahead;
        left = inheritCoverGrammar(parseUnaryExpression);

        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        if (prec === 0) {
            return left;
        }
        isAssignmentTarget = isBindingElement = false;
        token.prec = prec;
        lex();

        markers = [marker, lookahead];
        right = isolateCoverGrammar(parseUnaryExpression);

        stack = [left, token, right];

        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                markers.pop();
                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
                stack.push(expr);
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            markers.push(lookahead);
            expr = isolateCoverGrammar(parseUnaryExpression);
            stack.push(expr);
        }

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while (i > 1) {
            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
        }

        return expr;
    }


    // 11.12 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate, startToken;

        startToken = lookahead;

        expr = inheritCoverGrammar(parseBinaryExpression);
        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = isolateCoverGrammar(parseAssignmentExpression);
            state.allowIn = previousAllowIn;
            expect(':');
            alternate = isolateCoverGrammar(parseAssignmentExpression);

            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
            isAssignmentTarget = isBindingElement = false;
        }

        return expr;
    }

    // [ES6] 14.2 Arrow Function

    function parseConciseBody() {
        if (match('{')) {
            return parseFunctionSourceElements();
        }
        return isolateCoverGrammar(parseAssignmentExpression);
    }

    function checkPatternParam(options, param) {
        var i;
        switch (param.type) {
        case Syntax.Identifier:
            validateParam(options, param, param.name);
            break;
        case Syntax.RestElement:
            checkPatternParam(options, param.argument);
            break;
        case Syntax.AssignmentPattern:
            checkPatternParam(options, param.left);
            break;
        case Syntax.ArrayPattern:
            for (i = 0; i < param.elements.length; i++) {
                if (param.elements[i] !== null) {
                    checkPatternParam(options, param.elements[i]);
                }
            }
            break;
        default:
            assert(param.type === Syntax.ObjectPattern, 'Invalid type');
            for (i = 0; i < param.properties.length; i++) {
                checkPatternParam(options, param.properties[i].value);
            }
            break;
        }
    }
    function reinterpretAsCoverFormalsList(expr) {
        var i, len, param, params, defaults, defaultCount, options, token;

        defaults = [];
        defaultCount = 0;
        params = [expr];

        switch (expr.type) {
        case Syntax.Identifier:
            break;
        case PlaceHolders.ArrowParameterPlaceHolder:
            params = expr.params;
            break;
        default:
            return null;
        }

        options = {
            paramSet: {}
        };

        for (i = 0, len = params.length; i < len; i += 1) {
            param = params[i];
            switch (param.type) {
            case Syntax.AssignmentPattern:
                params[i] = param.left;
                defaults.push(param.right);
                ++defaultCount;
                checkPatternParam(options, param.left);
                break;
            default:
                checkPatternParam(options, param);
                params[i] = param;
                defaults.push(null);
                break;
            }
        }

        if (options.message === Messages.StrictParamDupe) {
            token = strict ? options.stricted : options.firstRestricted;
            throwUnexpectedToken(token, options.message);
        }

        if (defaultCount === 0) {
            defaults = [];
        }

        return {
            params: params,
            defaults: defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseArrowFunctionExpression(options, node) {
        var previousStrict, body;

        if (hasLineTerminator) {
            tolerateUnexpectedToken(lookahead);
        }
        expect('=>');
        previousStrict = strict;

        body = parseConciseBody();

        if (strict && options.firstRestricted) {
            throwUnexpectedToken(options.firstRestricted, options.message);
        }
        if (strict && options.stricted) {
            tolerateUnexpectedToken(options.stricted, options.message);
        }

        strict = previousStrict;

        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
    }

    // 11.13 Assignment Operators

    function parseAssignmentExpression() {
        var token, expr, right, list, startToken;

        startToken = lookahead;
        token = lookahead;

        expr = parseConditionalExpression();

        if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {
            isAssignmentTarget = isBindingElement = false;
            list = reinterpretAsCoverFormalsList(expr);

            if (list) {
                firstCoverInitializedNameError = null;
                return parseArrowFunctionExpression(list, new WrappingNode(startToken));
            }

            return expr;
        }

        if (matchAssign()) {
            if (!isAssignmentTarget) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }

            // 11.13.1
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
            }

            if (!match('=')) {
                isAssignmentTarget = isBindingElement = false;
            } else {
                reinterpretExpressionAsPattern(expr);
            }

            token = lex();
            right = isolateCoverGrammar(parseAssignmentExpression);
            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
            firstCoverInitializedNameError = null;
        }

        return expr;
    }

    // 11.14 Comma Operator

    function parseExpression() {
        var expr, startToken = lookahead, expressions;

        expr = isolateCoverGrammar(parseAssignmentExpression);

        if (match(',')) {
            expressions = [expr];

            while (startIndex < length) {
                if (!match(',')) {
                    break;
                }
                lex();
                expressions.push(isolateCoverGrammar(parseAssignmentExpression));
            }

            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
        }

        return expr;
    }

    // 12.1 Block

    function parseStatementListItem() {
        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'export':
                if (sourceType !== 'module') {
                    tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);
                }
                return parseExportDeclaration();
            case 'import':
                if (sourceType !== 'module') {
                    tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);
                }
                return parseImportDeclaration();
            case 'const':
            case 'let':
                return parseLexicalDeclaration({inFor: false});
            case 'function':
                return parseFunctionDeclaration(new Node());
            case 'class':
                return parseClassDeclaration();
            }
        }

        return parseStatement();
    }

    function parseStatementList() {
        var list = [];
        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            list.push(parseStatementListItem());
        }

        return list;
    }

    function parseBlock() {
        var block, node = new Node();

        expect('{');

        block = parseStatementList();

        expect('}');

        return node.finishBlockStatement(block);
    }

    // 12.2 Variable Statement

    function parseVariableIdentifier() {
        var token, node = new Node();

        token = lex();

        if (token.type !== Token.Identifier) {
            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {
                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
            } else {
                throwUnexpectedToken(token);
            }
        }

        return node.finishIdentifier(token.value);
    }

    function parseVariableDeclaration() {
        var init = null, id, node = new Node();

        id = parsePattern();

        // 12.2.1
        if (strict && isRestrictedWord(id.name)) {
            tolerateError(Messages.StrictVarName);
        }

        if (match('=')) {
            lex();
            init = isolateCoverGrammar(parseAssignmentExpression);
        } else if (id.type !== Syntax.Identifier) {
            expect('=');
        }

        return node.finishVariableDeclarator(id, init);
    }

    function parseVariableDeclarationList() {
        var list = [];

        do {
            list.push(parseVariableDeclaration());
            if (!match(',')) {
                break;
            }
            lex();
        } while (startIndex < length);

        return list;
    }

    function parseVariableStatement(node) {
        var declarations;

        expectKeyword('var');

        declarations = parseVariableDeclarationList();

        consumeSemicolon();

        return node.finishVariableDeclaration(declarations);
    }

    function parseLexicalBinding(kind, options) {
        var init = null, id, node = new Node();

        id = parsePattern();

        // 12.2.1
        if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {
            tolerateError(Messages.StrictVarName);
        }

        if (kind === 'const') {
            if (!matchKeyword('in')) {
                expect('=');
                init = isolateCoverGrammar(parseAssignmentExpression);
            }
        } else if ((!options.inFor && id.type !== Syntax.Identifier) || match('=')) {
            expect('=');
            init = isolateCoverGrammar(parseAssignmentExpression);
        }

        return node.finishVariableDeclarator(id, init);
    }

    function parseBindingList(kind, options) {
        var list = [];

        do {
            list.push(parseLexicalBinding(kind, options));
            if (!match(',')) {
                break;
            }
            lex();
        } while (startIndex < length);

        return list;
    }

    function parseLexicalDeclaration(options) {
        var kind, declarations, node = new Node();

        kind = lex().value;
        assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');

        declarations = parseBindingList(kind, options);

        consumeSemicolon();

        return node.finishLexicalDeclaration(declarations, kind);
    }

    function parseRestElement() {
        var param, node = new Node();

        lex();

        if (match('{')) {
            throwError(Messages.ObjectPatternAsRestParameter);
        }

        param = parseVariableIdentifier();

        if (match('=')) {
            throwError(Messages.DefaultRestParameter);
        }

        if (!match(')')) {
            throwError(Messages.ParameterAfterRestParameter);
        }

        return node.finishRestElement(param);
    }

    // 12.3 Empty Statement

    function parseEmptyStatement(node) {
        expect(';');
        return node.finishEmptyStatement();
    }

    // 12.4 Expression Statement

    function parseExpressionStatement(node) {
        var expr = parseExpression();
        consumeSemicolon();
        return node.finishExpressionStatement(expr);
    }

    // 12.5 If statement

    function parseIfStatement(node) {
        var test, consequent, alternate;

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return node.finishIfStatement(test, consequent, alternate);
    }

    // 12.6 Iteration Statements

    function parseDoWhileStatement(node) {
        var body, test, oldInIteration;

        expectKeyword('do');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        if (match(';')) {
            lex();
        }

        return node.finishDoWhileStatement(body, test);
    }

    function parseWhileStatement(node) {
        var test, body, oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return node.finishWhileStatement(test, body);
    }

    function parseForStatement(node) {
        var init, initSeq, initStartToken, test, update, left, right, kind, declarations,
            body, oldInIteration, previousAllowIn = state.allowIn;

        init = test = update = null;

        expectKeyword('for');

        expect('(');

        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var')) {
                init = new Node();
                lex();

                state.allowIn = false;
                init = init.finishVariableDeclaration(parseVariableDeclarationList());
                state.allowIn = previousAllowIn;

                if (init.declarations.length === 1 && matchKeyword('in')) {
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                } else {
                    expect(';');
                }
            } else if (matchKeyword('const') || matchKeyword('let')) {
                init = new Node();
                kind = lex().value;

                state.allowIn = false;
                declarations = parseBindingList(kind, {inFor: true});
                state.allowIn = previousAllowIn;

                if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {
                    init = init.finishLexicalDeclaration(declarations, kind);
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                } else {
                    consumeSemicolon();
                    init = init.finishLexicalDeclaration(declarations, kind);
                }
            } else {
                initStartToken = lookahead;
                state.allowIn = false;
                init = inheritCoverGrammar(parseAssignmentExpression);
                state.allowIn = previousAllowIn;

                if (matchKeyword('in')) {
                    if (!isAssignmentTarget) {
                        tolerateError(Messages.InvalidLHSInForIn);
                    }

                    lex();
                    reinterpretExpressionAsPattern(init);
                    left = init;
                    right = parseExpression();
                    init = null;
                } else {
                    if (match(',')) {
                        initSeq = [init];
                        while (match(',')) {
                            lex();
                            initSeq.push(isolateCoverGrammar(parseAssignmentExpression));
                        }
                        init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);
                    }
                    expect(';');
                }
            }
        }

        if (typeof left === 'undefined') {

            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');

            if (!match(')')) {
                update = parseExpression();
            }
        }

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = isolateCoverGrammar(parseStatement);

        state.inIteration = oldInIteration;

        return (typeof left === 'undefined') ?
                node.finishForStatement(init, test, update, body) :
                node.finishForInStatement(left, right, body);
    }

    // 12.7 The continue statement

    function parseContinueStatement(node) {
        var label = null, key;

        expectKeyword('continue');

        // Optimize the most common form: 'continue;'.
        if (source.charCodeAt(startIndex) === 0x3B) {
            lex();

            if (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (hasLineTerminator) {
            if (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !state.inIteration) {
            throwError(Messages.IllegalContinue);
        }

        return node.finishContinueStatement(label);
    }

    // 12.8 The break statement

    function parseBreakStatement(node) {
        var label = null, key;

        expectKeyword('break');

        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(lastIndex) === 0x3B) {
            lex();

            if (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }

            return node.finishBreakStatement(null);
        }

        if (hasLineTerminator) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }

            return node.finishBreakStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError(Messages.IllegalBreak);
        }

        return node.finishBreakStatement(label);
    }

    // 12.9 The return statement

    function parseReturnStatement(node) {
        var argument = null;

        expectKeyword('return');

        if (!state.inFunctionBody) {
            tolerateError(Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source.charCodeAt(lastIndex) === 0x20) {
            if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return node.finishReturnStatement(argument);
            }
        }

        if (hasLineTerminator) {
            // HACK
            return node.finishReturnStatement(null);
        }

        if (!match(';')) {
            if (!match('}') && lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return node.finishReturnStatement(argument);
    }

    // 12.10 The with statement

    function parseWithStatement(node) {
        var object, body;

        if (strict) {
            tolerateError(Messages.StrictModeWith);
        }

        expectKeyword('with');

        expect('(');

        object = parseExpression();

        expect(')');

        body = parseStatement();

        return node.finishWithStatement(object, body);
    }

    // 12.10 The swith statement

    function parseSwitchCase() {
        var test, consequent = [], statement, node = new Node();

        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');

        while (startIndex < length) {
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            statement = parseStatementListItem();
            consequent.push(statement);
        }

        return node.finishSwitchCase(test, consequent);
    }

    function parseSwitchStatement(node) {
        var discriminant, cases, clause, oldInSwitch, defaultFound;

        expectKeyword('switch');

        expect('(');

        discriminant = parseExpression();

        expect(')');

        expect('{');

        cases = [];

        if (match('}')) {
            lex();
            return node.finishSwitchStatement(discriminant, cases);
        }

        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;

        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError(Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect('}');

        return node.finishSwitchStatement(discriminant, cases);
    }

    // 12.13 The throw statement

    function parseThrowStatement(node) {
        var argument;

        expectKeyword('throw');

        if (hasLineTerminator) {
            throwError(Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        return node.finishThrowStatement(argument);
    }

    // 12.14 The try statement

    function parseCatchClause() {
        var param, body, node = new Node();

        expectKeyword('catch');

        expect('(');
        if (match(')')) {
            throwUnexpectedToken(lookahead);
        }

        param = parsePattern();

        // 12.14.1
        if (strict && isRestrictedWord(param.name)) {
            tolerateError(Messages.StrictCatchVariable);
        }

        expect(')');
        body = parseBlock();
        return node.finishCatchClause(param, body);
    }

    function parseTryStatement(node) {
        var block, handler = null, finalizer = null;

        expectKeyword('try');

        block = parseBlock();

        if (matchKeyword('catch')) {
            handler = parseCatchClause();
        }

        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }

        if (!handler && !finalizer) {
            throwError(Messages.NoCatchOrFinally);
        }

        return node.finishTryStatement(block, handler, finalizer);
    }

    // 12.15 The debugger statement

    function parseDebuggerStatement(node) {
        expectKeyword('debugger');

        consumeSemicolon();

        return node.finishDebuggerStatement();
    }

    // 12 Statements

    function parseStatement() {
        var type = lookahead.type,
            expr,
            labeledBody,
            key,
            node;

        if (type === Token.EOF) {
            throwUnexpectedToken(lookahead);
        }

        if (type === Token.Punctuator && lookahead.value === '{') {
            return parseBlock();
        }
        isAssignmentTarget = isBindingElement = true;
        node = new Node();

        if (type === Token.Punctuator) {
            switch (lookahead.value) {
            case ';':
                return parseEmptyStatement(node);
            case '(':
                return parseExpressionStatement(node);
            default:
                break;
            }
        } else if (type === Token.Keyword) {
            switch (lookahead.value) {
            case 'break':
                return parseBreakStatement(node);
            case 'continue':
                return parseContinueStatement(node);
            case 'debugger':
                return parseDebuggerStatement(node);
            case 'do':
                return parseDoWhileStatement(node);
            case 'for':
                return parseForStatement(node);
            case 'function':
                return parseFunctionDeclaration(node);
            case 'if':
                return parseIfStatement(node);
            case 'return':
                return parseReturnStatement(node);
            case 'switch':
                return parseSwitchStatement(node);
            case 'throw':
                return parseThrowStatement(node);
            case 'try':
                return parseTryStatement(node);
            case 'var':
                return parseVariableStatement(node);
            case 'while':
                return parseWhileStatement(node);
            case 'with':
                return parseWithStatement(node);
            default:
                break;
            }
        }

        expr = parseExpression();

        // 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            key = '$' + expr.name;
            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet[key] = true;
            labeledBody = parseStatement();
            delete state.labelSet[key];
            return node.finishLabeledStatement(expr, labeledBody);
        }

        consumeSemicolon();

        return node.finishExpressionStatement(expr);
    }

    // 13 Function Definition

    function parseFunctionSourceElements() {
        var statement, body = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesisCount,
            node = new Node();

        expect('{');

        while (startIndex < length) {
            if (lookahead.type !== Token.StringLiteral) {
                break;
            }
            token = lookahead;

            statement = parseStatementListItem();
            body.push(statement);
            if (statement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;
        oldParenthesisCount = state.parenthesizedCount;

        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;
        state.parenthesizedCount = 0;

        while (startIndex < length) {
            if (match('}')) {
                break;
            }
            body.push(parseStatementListItem());
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;
        state.parenthesizedCount = oldParenthesisCount;

        return node.finishBlockStatement(body);
    }

    function validateParam(options, param, name) {
        var key = '$' + name;
        if (strict) {
            if (isRestrictedWord(name)) {
                options.stricted = param;
                options.message = Messages.StrictParamName;
            }
            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        } else if (!options.firstRestricted) {
            if (isRestrictedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamName;
            } else if (isStrictModeReservedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictReservedWord;
            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamDupe;
            }
        }
        options.paramSet[key] = true;
    }

    function parseParam(options) {
        var token, param, def;

        token = lookahead;
        if (token.value === '...') {
            param = parseRestElement();
            validateParam(options, param.argument, param.argument.name);
            options.params.push(param);
            options.defaults.push(null);
            return false;
        }

        param = parsePatternWithDefault();
        validateParam(options, token, token.value);

        if (param.type === Syntax.AssignmentPattern) {
            def = param.right;
            param = param.left;
            ++options.defaultCount;
        }

        options.params.push(param);
        options.defaults.push(def);

        return !match(')');
    }

    function parseParams(firstRestricted) {
        var options;

        options = {
            params: [],
            defaultCount: 0,
            defaults: [],
            firstRestricted: firstRestricted
        };

        expect('(');

        if (!match(')')) {
            options.paramSet = {};
            while (startIndex < length) {
                if (!parseParam(options)) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        if (options.defaultCount === 0) {
            options.defaults = [];
        }

        return {
            params: options.params,
            defaults: options.defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseFunctionDeclaration(node, identifierIsOptional) {
        var id = null, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict;

        expectKeyword('function');
        if (!identifierIsOptional || !match('(')) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        if (strict && stricted) {
            tolerateUnexpectedToken(stricted, message);
        }
        strict = previousStrict;

        return node.finishFunctionDeclaration(id, params, defaults, body);
    }

    function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, tmp,
            params = [], defaults = [], body, previousStrict, node = new Node();

        expectKeyword('function');

        if (!match('(')) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        if (strict && stricted) {
            tolerateUnexpectedToken(stricted, message);
        }
        strict = previousStrict;

        return node.finishFunctionExpression(id, params, defaults, body);
    }


    function parseClassBody() {
        var classBody, token, isStatic, hasConstructor = false, body, method, computed, key;

        classBody = new Node();

        expect('{');
        body = [];
        while (!match('}')) {
            if (match(';')) {
                lex();
            } else {
                method = new Node();
                token = lookahead;
                isStatic = false;
                computed = match('[');
                key = parseObjectPropertyKey();
                if (key.name === 'static' && lookaheadPropertyName()) {
                    token = lookahead;
                    isStatic = true;
                    computed = match('[');
                    key = parseObjectPropertyKey();
                }
                method = tryParseMethodDefinition(token, key, computed, method);
                if (method) {
                    method['static'] = isStatic;
                    if (method.kind === 'init') {
                        method.kind = 'method';
                    }
                    if (!isStatic) {
                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {
                            if (method.kind !== 'method' || !method.method || method.value.generator) {
                                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);
                            }
                            if (hasConstructor) {
                                throwUnexpectedToken(token, Messages.DuplicateConstructor);
                            } else {
                                hasConstructor = true;
                            }
                            method.kind = 'constructor';
                        }
                    } else {
                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {
                            throwUnexpectedToken(token, Messages.StaticPrototype);
                        }
                    }
                    method.type = Syntax.MethodDefinition;
                    delete method.method;
                    delete method.shorthand;
                    body.push(method);
                } else {
                    throwUnexpectedToken(lookahead);
                }
            }
        }
        lex();
        return classBody.finishClassBody(body);
    }

    function parseClassDeclaration(identifierIsOptional) {
        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
        strict = true;

        expectKeyword('class');

        if (!identifierIsOptional || lookahead.type === Token.Identifier) {
            id = parseVariableIdentifier();
        }

        if (matchKeyword('extends')) {
            lex();
            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
        }
        classBody = parseClassBody();
        strict = previousStrict;

        return classNode.finishClassDeclaration(id, superClass, classBody);
    }

    function parseClassExpression() {
        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
        strict = true;

        expectKeyword('class');

        if (lookahead.type === Token.Identifier) {
            id = parseVariableIdentifier();
        }

        if (matchKeyword('extends')) {
            lex();
            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
        }
        classBody = parseClassBody();
        strict = previousStrict;

        return classNode.finishClassExpression(id, superClass, classBody);
    }

    // Modules grammar from:
    // people.mozilla.org/~jorendorff/es6-draft.html

    function parseModuleSpecifier() {
        var node = new Node();

        if (lookahead.type !== Token.StringLiteral) {
            throwError(Messages.InvalidModuleSpecifier);
        }
        return node.finishLiteral(lex());
    }

    function parseExportSpecifier() {
        var exported, local, node = new Node(), def;
        if (matchKeyword('default')) {
            // export {default} from 'something';
            def = new Node();
            lex();
            local = def.finishIdentifier('default');
        } else {
            local = parseVariableIdentifier();
        }
        if (matchContextualKeyword('as')) {
            lex();
            exported = parseNonComputedProperty();
        }
        return node.finishExportSpecifier(local, exported);
    }

    function parseExportNamedDeclaration(node) {
        var declaration = null,
            isExportFromIdentifier,
            src = null, specifiers = [];

        // non-default export
        if (lookahead.type === Token.Keyword) {
            // covers:
            // export var f = 1;
            switch (lookahead.value) {
                case 'let':
                case 'const':
                case 'var':
                case 'class':
                case 'function':
                    declaration = parseStatementListItem();
                    return node.finishExportNamedDeclaration(declaration, specifiers, null);
            }
        }

        expect('{');
        if (!match('}')) {
            do {
                isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');
                specifiers.push(parseExportSpecifier());
            } while (match(',') && lex());
        }
        expect('}');

        if (matchContextualKeyword('from')) {
            // covering:
            // export {default} from 'foo';
            // export {foo} from 'foo';
            lex();
            src = parseModuleSpecifier();
            consumeSemicolon();
        } else if (isExportFromIdentifier) {
            // covering:
            // export {default}; // missing fromClause
            throwError(lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        } else {
            // cover
            // export {foo};
            consumeSemicolon();
        }
        return node.finishExportNamedDeclaration(declaration, specifiers, src);
    }

    function parseExportDefaultDeclaration(node) {
        var declaration = null,
            expression = null;

        // covers:
        // export default ...
        expectKeyword('default');

        if (matchKeyword('function')) {
            // covers:
            // export default function foo () {}
            // export default function () {}
            declaration = parseFunctionDeclaration(new Node(), true);
            return node.finishExportDefaultDeclaration(declaration);
        }
        if (matchKeyword('class')) {
            declaration = parseClassDeclaration(true);
            return node.finishExportDefaultDeclaration(declaration);
        }

        if (matchContextualKeyword('from')) {
            throwError(Messages.UnexpectedToken, lookahead.value);
        }

        // covers:
        // export default {};
        // export default [];
        // export default (1 + 2);
        if (match('{')) {
            expression = parseObjectInitialiser();
        } else if (match('[')) {
            expression = parseArrayInitialiser();
        } else {
            expression = parseAssignmentExpression();
        }
        consumeSemicolon();
        return node.finishExportDefaultDeclaration(expression);
    }

    function parseExportAllDeclaration(node) {
        var src;

        // covers:
        // export * from 'foo';
        expect('*');
        if (!matchContextualKeyword('from')) {
            throwError(lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        }
        lex();
        src = parseModuleSpecifier();
        consumeSemicolon();

        return node.finishExportAllDeclaration(src);
    }

    function parseExportDeclaration() {
        var node = new Node();
        if (state.inFunctionBody) {
            throwError(Messages.IllegalExportDeclaration);
        }

        expectKeyword('export');

        if (matchKeyword('default')) {
            return parseExportDefaultDeclaration(node);
        }
        if (match('*')) {
            return parseExportAllDeclaration(node);
        }
        return parseExportNamedDeclaration(node);
    }

    function parseImportSpecifier() {
        // import {<foo as bar>} ...;
        var local, imported, node = new Node();

        imported = parseNonComputedProperty();
        if (matchContextualKeyword('as')) {
            lex();
            local = parseVariableIdentifier();
        }

        return node.finishImportSpecifier(local, imported);
    }

    function parseNamedImports() {
        var specifiers = [];
        // {foo, bar as bas}
        expect('{');
        if (!match('}')) {
            do {
                specifiers.push(parseImportSpecifier());
            } while (match(',') && lex());
        }
        expect('}');
        return specifiers;
    }

    function parseImportDefaultSpecifier() {
        // import <foo> ...;
        var local, node = new Node();

        local = parseNonComputedProperty();

        return node.finishImportDefaultSpecifier(local);
    }

    function parseImportNamespaceSpecifier() {
        // import <* as foo> ...;
        var local, node = new Node();

        expect('*');
        if (!matchContextualKeyword('as')) {
            throwError(Messages.NoAsAfterImportNamespace);
        }
        lex();
        local = parseNonComputedProperty();

        return node.finishImportNamespaceSpecifier(local);
    }

    function parseImportDeclaration() {
        var specifiers, src, node = new Node();

        if (state.inFunctionBody) {
            throwError(Messages.IllegalImportDeclaration);
        }

        expectKeyword('import');
        specifiers = [];

        if (lookahead.type === Token.StringLiteral) {
            // covers:
            // import 'foo';
            src = parseModuleSpecifier();
            consumeSemicolon();
            return node.finishImportDeclaration(specifiers, src);
        }

        if (!matchKeyword('default') && isIdentifierName(lookahead)) {
            // covers:
            // import foo
            // import foo, ...
            specifiers.push(parseImportDefaultSpecifier());
            if (match(',')) {
                lex();
            }
        }
        if (match('*')) {
            // covers:
            // import foo, * as foo
            // import * as foo
            specifiers.push(parseImportNamespaceSpecifier());
        } else if (match('{')) {
            // covers:
            // import foo, {bar}
            // import {bar}
            specifiers = specifiers.concat(parseNamedImports());
        }

        if (!matchContextualKeyword('from')) {
            throwError(lookahead.value ?
                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
        }
        lex();
        src = parseModuleSpecifier();
        consumeSemicolon();

        return node.finishImportDeclaration(specifiers, src);
    }

    // 14 Program

    function parseScriptBody() {
        var statement, body = [], token, directive, firstRestricted;

        while (startIndex < length) {
            token = lookahead;
            if (token.type !== Token.StringLiteral) {
                break;
            }

            statement = parseStatementListItem();
            body.push(statement);
            if (statement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (startIndex < length) {
            statement = parseStatementListItem();
            /* istanbul ignore if */
            if (typeof statement === 'undefined') {
                break;
            }
            body.push(statement);
        }
        return body;
    }

    function parseProgram() {
        var body, node;

        peek();
        node = new Node();

        body = parseScriptBody();
        return node.finishProgram(body);
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];

        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (entry.regex) {
                token.regex = {
                    pattern: entry.regex.pattern,
                    flags: entry.regex.flags
                };
            }
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    function tokenize(code, options) {
        var toString,
            tokens;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1,
            curlyStack: []
        };

        extra = {};

        // Options matching.
        options = options || {};

        // Of course we collect tokens here.
        options.tokens = true;
        extra.tokens = [];
        extra.tokenize = true;
        // The following two fields are necessary to compute the Regex tokens.
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;

        extra.range = (typeof options.range === 'boolean') && options.range;
        extra.loc = (typeof options.loc === 'boolean') && options.loc;

        if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
        }
        if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
        }

        try {
            peek();
            if (lookahead.type === Token.EOF) {
                return extra.tokens;
            }

            lex();
            while (lookahead.type !== Token.EOF) {
                try {
                    lex();
                } catch (lexError) {
                    if (extra.errors) {
                        recordError(lexError);
                        // We have to break on the first error
                        // to avoid infinite loops.
                        break;
                    } else {
                        throw lexError;
                    }
                }
            }

            filterTokenLocation();
            tokens = extra.tokens;
            if (typeof extra.comments !== 'undefined') {
                tokens.comments = extra.comments;
            }
            if (typeof extra.errors !== 'undefined') {
                tokens.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }
        return tokens;
    }

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        startIndex = index;
        startLineNumber = lineNumber;
        startLineStart = lineStart;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1,
            curlyStack: []
        };
        sourceType = 'script';
        strict = false;

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

            if (extra.loc && options.source !== null && options.source !== undefined) {
                extra.source = toString(options.source);
            }

            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
            if (extra.attachComment) {
                extra.range = true;
                extra.comments = [];
                extra.bottomRightStack = [];
                extra.trailingComments = [];
                extra.leadingComments = [];
            }
            if (options.sourceType === 'module') {
                // very restrictive condition for now
                sourceType = options.sourceType;
                strict = true;
            }
        }

        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }

        return program;
    }

    // Sync with *.json manifests.
    exports.version = '2.2.0';

    exports.tokenize = tokenize;

    exports.parse = parse;

    // Deep copy.
    /* istanbul ignore next */
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],60:[function(require,module,exports){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    if (typeof module === 'object' && module.exports && typeof require === 'function') {
        module.exports = definition();
    } else if (typeof define === 'function' && typeof define.amd === 'object') {
        define(definition);
    } else {
        root.log = definition();
    }
}(this, function () {
    var self = {};
    var noop = function() {};
    var undefinedType = "undefined";

    function realMethod(methodName) {
        if (typeof console === undefinedType) {
            return false; // We can't build a real method without a console to log to
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    function enableLoggingWhenConsoleArrives(methodName, level) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods(level);
                self[methodName].apply(self, arguments);
            }
        };
    }

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    function replaceLoggingMethods(level) {
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            self[methodName] = (i < level) ? noop : self.methodFactory(methodName, level);
        }
    }

    function persistLevelIfPossible(levelNum) {
        var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

        // Use localStorage if available
        try {
            window.localStorage['loglevel'] = levelName;
            return;
        } catch (ignore) {}

        // Use session cookie as fallback
        try {
            window.document.cookie = "loglevel=" + levelName + ";";
        } catch (ignore) {}
    }

    function loadPersistedLevel() {
        var storedLevel;

        try {
            storedLevel = window.localStorage['loglevel'];
        } catch (ignore) {}

        if (typeof storedLevel === undefinedType) {
            try {
                storedLevel = /loglevel=([^;]+)/.exec(window.document.cookie)[1];
            } catch (ignore) {}
        }
        
        if (self.levels[storedLevel] === undefined) {
            storedLevel = "WARN";
        }

        self.setLevel(self.levels[storedLevel]);
    }

    /*
     *
     * Public API
     *
     */

    self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
        "ERROR": 4, "SILENT": 5};

    self.methodFactory = function (methodName, level) {
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives(methodName, level);
    };

    self.setLevel = function (level) {
        if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
            level = self.levels[level.toUpperCase()];
        }
        if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
            persistLevelIfPossible(level);
            replaceLoggingMethods(level);
            if (typeof console === undefinedType && level < self.levels.SILENT) {
                return "No console available for logging";
            }
        } else {
            throw "log.setLevel() called with invalid level: " + level;
        }
    };

    self.enableAll = function() {
        self.setLevel(self.levels.TRACE);
    };

    self.disableAll = function() {
        self.setLevel(self.levels.SILENT);
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    self.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === self) {
            window.log = _log;
        }

        return self;
    };

    loadPersistedLevel();
    return self;
}));

},{}],61:[function(require,module,exports){
'use strict';

var whiteList = ['not', 'any', 'all', 'none'];


function notNull(x)  { return x != null; }
function toString(x) { return x.toString(); }
function wrap(x)     { return '(' + x + ')';}

function maybeQuote(value) {
    if (typeof value === 'string') {
        return '"' + value + '"';
    }
    return value;
}

function lookUp(key) {
    if (key.lastIndexOf('$') === 0) {
        return 'context.' + key.substring(1);
    }
    return 'context.feature.properties.' + key;
}

function nullValue(key, value) {
    return {
        type: 'nullValue',
        key: key,
        toString: function () {
            return ' true ';
        }
    };
}

function propertyEqual(key, value) {
    return {
        type: 'propertyEqual',
        opt: '===' ,
        key: key,
        value: value,
        toString: function () {
            return wrap(maybeQuote(this.value) + ' ' + this.opt + ' ' + lookUp(key));
        }
    };
}

function propertyOr(key, values) {
    return {
        type: 'propertyOr',
        key: key,
        values: values.map(function (x) { return propertyEqual(key, x); }),
        toString: function () {
            return wrap(this.values.map(toString).join(' || '));
        }
    };
}

function not(key, value) {
    return {
        type: 'notProperty',
        key: key,
        value: parseFilter(value),
        toString: function () {
            return '!' + wrap(this.value.toString());
        }
    };
}

function none(key, values) {
    return {
        type: 'none',
        values: any(null, values),
        toString: function () {
            return '!' + wrap(this.values.toString());
        }
    };
}

function printNested(values, joiner) {
    return wrap(values.filter(notNull).map(function (x) {
        return wrap(x.join(' && '));
    }).join(' ' + joiner + ' '));
}

function any(_, values) {
    return {
        type: 'any',
        values: values.map(parseFilter),
        toString: function () {
            return printNested(this.values, '||');
        }
    };
}

function all(_, values) {
    return {
        type: 'all',
        values: values.filter(notNull).map(parseFilter),
        toString: function () {
            return printNested(this.values, '&&');
        }
    };
}

function propertyMatchesBoolean(key, value) {
    return {
        type: 'propertyMatchesBoolean',
        key: key,
        value: value,
        toString: function () {
            return wrap(lookUp(this.key) + (this.value ? ' != ' : ' == ')  + 'null');
        }
    };
}

function rangeMatch(key, values) {
    return {
        type: 'rangeMatch',
        key: key,
        values: values,
        toString: function () {
            var expressions = [];

            if (this.values.max) {
                expressions.push('' + lookUp(key) + ' < ' + this.values.max);
            }

            if (this.values.min) {
                expressions.push('' + lookUp(key) + ' >= ' + this.values.min);
            }

            return wrap(expressions.join(' && '));
        }
    };
}

function parseFilter(filter) {
    var filterAST = [];

    // Function filter
    if (typeof filter === 'function') {
        filterAST.push(wrap(filter.toString() + '(context)'));
        return filterAST;
    }

    // Object filter
    var keys = Object.keys(filter);
    keys.forEach(function (key, idx) {

        var value = filter[key],
            type  = typeof value;
        if (type === 'string' || type === 'number') {
            filterAST.push(propertyEqual(key, value));
        } else if (type === 'boolean') {
            filterAST.push(propertyMatchesBoolean(key, value));
        } else if (value == null) {
            filterAST.push(nullValue(key, value));
        } else if (whiteList.indexOf(key) >= 0) {
            switch (key) {
            case 'not':
                filterAST.push(not(key, value));
                break;
            case 'any':
                filterAST.push(any(key, value));
                break;
            case 'all':
                filterAST.push(all(key, value));
                break;
            case 'none':
                filterAST.push(none(key, value));
                break;
            default:
                throw new Error('Unhandled WhiteListed property: ' + key);
            }
        } else if (Array.isArray(value)) {
            filterAST.push(propertyOr(key, value));
        } else if (type === 'object' && value != null) {
            if (value.max || value.min) {
                filterAST.push(rangeMatch(key, value));
            }
        } else {
            throw new Error('Unknown Query sytnax: ' + value);
        }
    });

    return keys.length === 0 ? ['true'] : filterAST;
}

function filterToString(filterAST) {
    return wrap(filterAST.join(' && '));
}

function match(filter) {
    if (filter == null) { return function () { return true; }; }
    // jshint evil: true
    return new Function('context', 'return ' + filterToString(parseFilter(filter)) + ';');
}

module.exports = {
    match: match,
    filterToString: filterToString,
    parseFilter: parseFilter
};

},{}],62:[function(require,module,exports){
'use strict';

// lightweight Buffer shim for pbf browser build
// based on code from github.com/feross/buffer (MIT-licensed)

module.exports = Buffer;

var ieee754 = require('ieee754');

var BufferMethods;

function Buffer(length) {
    var arr;
    if (length && length.length) {
        arr = length;
        length = arr.length;
    }
    var buf = new Uint8Array(length || 0);
    if (arr) buf.set(arr);

    buf.readUInt32LE = BufferMethods.readUInt32LE;
    buf.writeUInt32LE = BufferMethods.writeUInt32LE;
    buf.readInt32LE = BufferMethods.readInt32LE;
    buf.writeInt32LE = BufferMethods.writeInt32LE;
    buf.readFloatLE = BufferMethods.readFloatLE;
    buf.writeFloatLE = BufferMethods.writeFloatLE;
    buf.readDoubleLE = BufferMethods.readDoubleLE;
    buf.writeDoubleLE = BufferMethods.writeDoubleLE;
    buf.toString = BufferMethods.toString;
    buf.write = BufferMethods.write;
    buf.slice = BufferMethods.slice;
    buf.copy = BufferMethods.copy;

    buf._isBuffer = true;
    return buf;
}

var lastStr, lastStrEncoded;

BufferMethods = {
    readUInt32LE: function(pos) {
        return ((this[pos]) |
            (this[pos + 1] << 8) |
            (this[pos + 2] << 16)) +
            (this[pos + 3] * 0x1000000);
    },

    writeUInt32LE: function(val, pos) {
        this[pos] = val;
        this[pos + 1] = (val >>> 8);
        this[pos + 2] = (val >>> 16);
        this[pos + 3] = (val >>> 24);
    },

    readInt32LE: function(pos) {
        return ((this[pos]) |
            (this[pos + 1] << 8) |
            (this[pos + 2] << 16)) +
            (this[pos + 3] << 24);
    },

    readFloatLE:  function(pos) { return ieee754.read(this, pos, true, 23, 4); },
    readDoubleLE: function(pos) { return ieee754.read(this, pos, true, 52, 8); },

    writeFloatLE:  function(val, pos) { return ieee754.write(this, val, pos, true, 23, 4); },
    writeDoubleLE: function(val, pos) { return ieee754.write(this, val, pos, true, 52, 8); },

    toString: function(encoding, start, end) {
        var str = '',
            tmp = '';

        start = start || 0;
        end = Math.min(this.length, end || this.length);

        for (var i = start; i < end; i++) {
            var ch = this[i];
            if (ch <= 0x7F) {
                str += decodeURIComponent(tmp) + String.fromCharCode(ch);
                tmp = '';
            } else {
                tmp += '%' + ch.toString(16);
            }
        }

        str += decodeURIComponent(tmp);

        return str;
    },

    write: function(str, pos) {
        var bytes = str === lastStr ? lastStrEncoded : encodeString(str);
        for (var i = 0; i < bytes.length; i++) {
            this[pos + i] = bytes[i];
        }
    },

    slice: function(start, end) {
        return this.subarray(start, end);
    },

    copy: function(buf, pos) {
        pos = pos || 0;
        for (var i = 0; i < this.length; i++) {
            buf[pos + i] = this[i];
        }
    }
};

BufferMethods.writeInt32LE = BufferMethods.writeUInt32LE;

Buffer.byteLength = function(str) {
    lastStr = str;
    lastStrEncoded = encodeString(str);
    return lastStrEncoded.length;
};

Buffer.isBuffer = function(buf) {
    return !!(buf && buf._isBuffer);
};

function encodeString(str) {
    var length = str.length,
        bytes = [];

    for (var i = 0, c, lead; i < length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {

            if (lead) {
                if (c < 0xDC00) {
                    bytes.push(0xEF, 0xBF, 0xBD);
                    lead = c;
                    continue;

                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }

            } else {
                if (c > 0xDBFF || (i + 1 === length)) bytes.push(0xEF, 0xBF, 0xBD);
                else lead = c;

                continue;
            }

        } else if (lead) {
            bytes.push(0xEF, 0xBF, 0xBD);
            lead = null;
        }

        if (c < 0x80) bytes.push(c);
        else if (c < 0x800) bytes.push(c >> 0x6 | 0xC0, c & 0x3F | 0x80);
        else if (c < 0x10000) bytes.push(c >> 0xC | 0xE0, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
        else bytes.push(c >> 0x12 | 0xF0, c >> 0xC & 0x3F | 0x80, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
    }
    return bytes;
}

},{"ieee754":64}],63:[function(require,module,exports){
(function (global){
'use strict';

module.exports = Pbf;

var Buffer = global.Buffer || require('./buffer');

function Pbf(buf) {
    this.buf = !Buffer.isBuffer(buf) ? new Buffer(buf || 0) : buf;
    this.pos = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32,
    POW_2_63 = Math.pow(2, 63);

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            var val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            readField(tag, result, this);

            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = this.buf.readUInt32LE(this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = this.buf.readInt32LE(this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = this.buf.readUInt32LE(this.pos) + this.buf.readUInt32LE(this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = this.buf.readUInt32LE(this.pos) + this.buf.readInt32LE(this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = this.buf.readFloatLE(this.pos);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = this.buf.readDoubleLE(this.pos);
        this.pos += 8;
        return val;
    },

    readVarint: function() {
        var buf = this.buf,
            val, b, b0, b1, b2, b3;

        b0 = buf[this.pos++]; if (b0 < 0x80) return b0;                 b0 = b0 & 0x7f;
        b1 = buf[this.pos++]; if (b1 < 0x80) return b0 | b1 << 7;       b1 = (b1 & 0x7f) << 7;
        b2 = buf[this.pos++]; if (b2 < 0x80) return b0 | b1 | b2 << 14; b2 = (b2 & 0x7f) << 14;
        b3 = buf[this.pos++]; if (b3 < 0x80) return b0 | b1 | b2 | b3 << 21;

        val = b0 | b1 | b2 | (b3 & 0x7f) << 21;

        b = buf[this.pos++]; val += (b & 0x7f) * 0x10000000;         if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x800000000;        if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x40000000000;      if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x2000000000000;    if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x100000000000000;  if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x8000000000000000; if (b < 0x80) return val;

        throw new Error('Expected varint not more than 10 bytes');
    },

    readVarint64: function() {
        var startPos = this.pos,
            val = this.readVarint();

        if (val < POW_2_63) return val;

        var pos = this.pos - 2;
        while (this.buf[pos] === 0xff) pos--;
        if (pos < startPos) pos = startPos;

        val = 0;
        for (var i = 0; i < pos - startPos + 1; i++) {
            var b = ~this.buf[startPos + i] & 0x7f;
            val += i < 4 ? b << i * 7 : b * Math.pow(2, i * 7);
        }

        return -val - 1;
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos,
            str = this.buf.toString('utf8', this.pos, end);
        this.pos = end;
        return str;
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.slice(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readVarint());
        return arr;
    },
    readPackedSVarint: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error('Unimplemented type: ' + type);
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) length *= 2;

        if (length !== this.length) {
            var buf = new Buffer(length);
            this.buf.copy(buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.slice(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        this.buf.writeUInt32LE(val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        this.buf.writeInt32LE(val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        this.buf.writeInt32LE(val & -1, this.pos);
        this.buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        this.buf.writeInt32LE(val & -1, this.pos);
        this.buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val;

        if (val <= 0x7f) {
            this.realloc(1);
            this.buf[this.pos++] = val;

        } else if (val <= 0x3fff) {
            this.realloc(2);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f);

        } else if (val <= 0x1fffff) {
            this.realloc(3);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 14) & 0x7f);

        } else if (val <= 0xfffffff) {
            this.realloc(4);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 14) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 21) & 0x7f);

        } else {
            var pos = this.pos;
            while (val >= 0x80) {
                this.realloc(1);
                this.buf[this.pos++] = (val & 0xff) | 0x80;
                val /= 0x80;
            }
            this.realloc(1);
            this.buf[this.pos++] = val | 0;
            if (this.pos - pos > 10) throw new Error('Given varint doesn\'t fit into 10 bytes');
        }
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        var bytes = Buffer.byteLength(str);
        this.writeVarint(bytes);
        this.realloc(bytes);
        this.buf.write(str, this.pos);
        this.pos += bytes;
    },

    writeFloat: function(val) {
        this.realloc(4);
        this.buf.writeFloatLE(val, this.pos);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        this.buf.writeDoubleLE(val, this.pos);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);

        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        var varintLen =
            len <= 0x7f ? 1 :
            len <= 0x3fff ? 2 :
            len <= 0x1fffff ? 3 :
            len <= 0xfffffff ? 4 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

        // if 1 byte isn't enough for encoding message length, shift the data to the right
        if (varintLen > 1) {
            this.realloc(varintLen - 1);
            for (var i = this.pos - 1; i >= startPos; i--) this.buf[i + varintLen - 1] = this.buf[i];
        }

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },
    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },
    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },
    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },
    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },
    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },
    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },
    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },
    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9wYmYvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGJmO1xuXG52YXIgQnVmZmVyID0gZ2xvYmFsLkJ1ZmZlciB8fCByZXF1aXJlKCcuL2J1ZmZlcicpO1xuXG5mdW5jdGlvbiBQYmYoYnVmKSB7XG4gICAgdGhpcy5idWYgPSAhQnVmZmVyLmlzQnVmZmVyKGJ1ZikgPyBuZXcgQnVmZmVyKGJ1ZiB8fCAwKSA6IGJ1ZjtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLmJ1Zi5sZW5ndGg7XG59XG5cblBiZi5WYXJpbnQgID0gMDsgLy8gdmFyaW50OiBpbnQzMiwgaW50NjQsIHVpbnQzMiwgdWludDY0LCBzaW50MzIsIHNpbnQ2NCwgYm9vbCwgZW51bVxuUGJmLkZpeGVkNjQgPSAxOyAvLyA2NC1iaXQ6IGRvdWJsZSwgZml4ZWQ2NCwgc2ZpeGVkNjRcblBiZi5CeXRlcyAgID0gMjsgLy8gbGVuZ3RoLWRlbGltaXRlZDogc3RyaW5nLCBieXRlcywgZW1iZWRkZWQgbWVzc2FnZXMsIHBhY2tlZCByZXBlYXRlZCBmaWVsZHNcblBiZi5GaXhlZDMyID0gNTsgLy8gMzItYml0OiBmbG9hdCwgZml4ZWQzMiwgc2ZpeGVkMzJcblxudmFyIFNISUZUX0xFRlRfMzIgPSAoMSA8PCAxNikgKiAoMSA8PCAxNiksXG4gICAgU0hJRlRfUklHSFRfMzIgPSAxIC8gU0hJRlRfTEVGVF8zMixcbiAgICBQT1dfMl82MyA9IE1hdGgucG93KDIsIDYzKTtcblxuUGJmLnByb3RvdHlwZSA9IHtcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJ1ZiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8vID09PSBSRUFESU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICByZWFkRmllbGRzOiBmdW5jdGlvbihyZWFkRmllbGQsIHJlc3VsdCwgZW5kKSB7XG4gICAgICAgIGVuZCA9IGVuZCB8fCB0aGlzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLnJlYWRWYXJpbnQoKSxcbiAgICAgICAgICAgICAgICB0YWcgPSB2YWwgPj4gMyxcbiAgICAgICAgICAgICAgICBzdGFydFBvcyA9IHRoaXMucG9zO1xuXG4gICAgICAgICAgICByZWFkRmllbGQodGFnLCByZXN1bHQsIHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0UG9zKSB0aGlzLnNraXAodmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICByZWFkTWVzc2FnZTogZnVuY3Rpb24ocmVhZEZpZWxkLCByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZpZWxkcyhyZWFkRmllbGQsIHJlc3VsdCwgdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcyk7XG4gICAgfSxcblxuICAgIHJlYWRGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRTRml4ZWQzMjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkSW50MzJMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIC8vIDY0LWJpdCBpbnQgaGFuZGxpbmcgaXMgYmFzZWQgb24gZ2l0aHViLmNvbS9kcHcvbm9kZS1idWZmZXItbW9yZS1pbnRzIChNSVQtbGljZW5zZWQpXG5cbiAgICByZWFkRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MpICsgdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zICsgNCkgKiBTSElGVF9MRUZUXzMyO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkU0ZpeGVkNjQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zKSArIHRoaXMuYnVmLnJlYWRJbnQzMkxFKHRoaXMucG9zICsgNCkgKiBTSElGVF9MRUZUXzMyO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkRmxvYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZEZsb2F0TEUodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkRG91YmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWREb3VibGVMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYnVmID0gdGhpcy5idWYsXG4gICAgICAgICAgICB2YWwsIGIsIGIwLCBiMSwgYjIsIGIzO1xuXG4gICAgICAgIGIwID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjAgPCAweDgwKSByZXR1cm4gYjA7ICAgICAgICAgICAgICAgICBiMCA9IGIwICYgMHg3ZjtcbiAgICAgICAgYjEgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMSA8IDB4ODApIHJldHVybiBiMCB8IGIxIDw8IDc7ICAgICAgIGIxID0gKGIxICYgMHg3ZikgPDwgNztcbiAgICAgICAgYjIgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMiA8IDB4ODApIHJldHVybiBiMCB8IGIxIHwgYjIgPDwgMTQ7IGIyID0gKGIyICYgMHg3ZikgPDwgMTQ7XG4gICAgICAgIGIzID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjMgPCAweDgwKSByZXR1cm4gYjAgfCBiMSB8IGIyIHwgYjMgPDwgMjE7XG5cbiAgICAgICAgdmFsID0gYjAgfCBiMSB8IGIyIHwgKGIzICYgMHg3ZikgPDwgMjE7XG5cbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDEwMDAwMDAwOyAgICAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDgwMDAwMDAwMDsgICAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDQwMDAwMDAwMDAwOyAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDIwMDAwMDAwMDAwMDA7ICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDEwMDAwMDAwMDAwMDAwMDsgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDgwMDAwMDAwMDAwMDAwMDA7IGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHZhcmludCBub3QgbW9yZSB0aGFuIDEwIGJ5dGVzJyk7XG4gICAgfSxcblxuICAgIHJlYWRWYXJpbnQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zLFxuICAgICAgICAgICAgdmFsID0gdGhpcy5yZWFkVmFyaW50KCk7XG5cbiAgICAgICAgaWYgKHZhbCA8IFBPV18yXzYzKSByZXR1cm4gdmFsO1xuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcyAtIDI7XG4gICAgICAgIHdoaWxlICh0aGlzLmJ1Zltwb3NdID09PSAweGZmKSBwb3MtLTtcbiAgICAgICAgaWYgKHBvcyA8IHN0YXJ0UG9zKSBwb3MgPSBzdGFydFBvcztcblxuICAgICAgICB2YWwgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvcyAtIHN0YXJ0UG9zICsgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYiA9IH50aGlzLmJ1ZltzdGFydFBvcyArIGldICYgMHg3ZjtcbiAgICAgICAgICAgIHZhbCArPSBpIDwgNCA/IGIgPDwgaSAqIDcgOiBiICogTWF0aC5wb3coMiwgaSAqIDcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC12YWwgLSAxO1xuICAgIH0sXG5cbiAgICByZWFkU1ZhcmludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBudW0gPSB0aGlzLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgcmV0dXJuIG51bSAlIDIgPT09IDEgPyAobnVtICsgMSkgLyAtMiA6IG51bSAvIDI7IC8vIHppZ3phZyBlbmNvZGluZ1xuICAgIH0sXG5cbiAgICByZWFkQm9vbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMucmVhZFZhcmludCgpKTtcbiAgICB9LFxuXG4gICAgcmVhZFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgc3RyID0gdGhpcy5idWYudG9TdHJpbmcoJ3V0ZjgnLCB0aGlzLnBvcywgZW5kKTtcbiAgICAgICAgdGhpcy5wb3MgPSBlbmQ7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuICAgIHJlYWRCeXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgYnVmZmVyID0gdGhpcy5idWYuc2xpY2UodGhpcy5wb3MsIGVuZCk7XG4gICAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH0sXG5cbiAgICAvLyB2ZXJib3NlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOyBkb2Vzbid0IGFmZmVjdCBnemlwcGVkIHNpemVcblxuICAgIHJlYWRQYWNrZWRWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkVmFyaW50KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU1ZhcmludCgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRCb29sZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEJvb2xlYW4oKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRmxvYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkRmxvYXQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRG91YmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZERvdWJsZSgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkU0ZpeGVkMzI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU0ZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZFNGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG5cbiAgICBza2lwOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB2YWwgJiAweDc7XG4gICAgICAgIGlmICh0eXBlID09PSBQYmYuVmFyaW50KSB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gPiAweDdmKSB7fVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBQYmYuQnl0ZXMpIHRoaXMucG9zID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcztcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gUGJmLkZpeGVkMzIpIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFBiZi5GaXhlZDY0KSB0aGlzLnBvcyArPSA4O1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCB0eXBlOiAnICsgdHlwZSk7XG4gICAgfSxcblxuICAgIC8vID09PSBXUklUSU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICB3cml0ZVRhZzogZnVuY3Rpb24odGFnLCB0eXBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoKHRhZyA8PCAzKSB8IHR5cGUpO1xuICAgIH0sXG5cbiAgICByZWFsbG9jOiBmdW5jdGlvbihtaW4pIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDE2O1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGggPCB0aGlzLnBvcyArIG1pbikgbGVuZ3RoICo9IDI7XG5cbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmJ1Zi5jb3B5KGJ1Zik7XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgd3JpdGVGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZVVJbnQzMkxFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZVNGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUodmFsLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgfSxcblxuICAgIHdyaXRlRml4ZWQ2NDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVJbnQzMkxFKHZhbCAmIC0xLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlVUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIHRoaXMucG9zICsgNCk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlU0ZpeGVkNjQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoOCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIHRoaXMucG9zICsgNCk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlVmFyaW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFsID0gK3ZhbDtcblxuICAgICAgICBpZiAodmFsIDw9IDB4N2YpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gdmFsO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4M2ZmZikge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDIpO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMCkgJiAweDdmKSB8IDB4ODA7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiA3KSAmIDB4N2YpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4MWZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMyk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAwKSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDcpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMTQpICYgMHg3Zik7XG5cbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPD0gMHhmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAwKSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDcpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMTQpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMjEpICYgMHg3Zik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHdoaWxlICh2YWwgPj0gMHg4MCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICh2YWwgJiAweGZmKSB8IDB4ODA7XG4gICAgICAgICAgICAgICAgdmFsIC89IDB4ODA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMSk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IHZhbCB8IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgLSBwb3MgPiAxMCkgdGhyb3cgbmV3IEVycm9yKCdHaXZlbiB2YXJpbnQgZG9lc25cXCd0IGZpdCBpbnRvIDEwIGJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd3JpdGVTVmFyaW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh2YWwgPCAwID8gLXZhbCAqIDIgLSAxIDogdmFsICogMik7XG4gICAgfSxcblxuICAgIHdyaXRlQm9vbGVhbjogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoQm9vbGVhbih2YWwpKTtcbiAgICB9LFxuXG4gICAgd3JpdGVTdHJpbmc6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgICAgdmFyIGJ5dGVzID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyKTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChieXRlcyk7XG4gICAgICAgIHRoaXMucmVhbGxvYyhieXRlcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlKHN0ciwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSBieXRlcztcbiAgICB9LFxuXG4gICAgd3JpdGVGbG9hdDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg0KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVGbG9hdExFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZURvdWJsZTogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVEb3VibGVMRSh2YWwsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICB9LFxuXG4gICAgd3JpdGVCeXRlczogZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgIHZhciBsZW4gPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7XG4gICAgICAgIHRoaXMucmVhbGxvYyhsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IGJ1ZmZlcltpXTtcbiAgICB9LFxuXG4gICAgd3JpdGVNZXNzYWdlOiBmdW5jdGlvbih0YWcsIGZuLCBvYmopIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5CeXRlcyk7XG5cbiAgICAgICAgdGhpcy5wb3MrKzsgLy8gcmVzZXJ2ZSAxIGJ5dGUgZm9yIHNob3J0IG1lc3NhZ2UgbGVuZ3RoXG5cbiAgICAgICAgLy8gd3JpdGUgdGhlIG1lc3NhZ2UgZGlyZWN0bHkgdG8gdGhlIGJ1ZmZlciBhbmQgc2VlIGhvdyBtdWNoIHdhcyB3cml0dGVuXG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zO1xuICAgICAgICBmbihvYmosIHRoaXMpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5wb3MgLSBzdGFydFBvcztcblxuICAgICAgICB2YXIgdmFyaW50TGVuID1cbiAgICAgICAgICAgIGxlbiA8PSAweDdmID8gMSA6XG4gICAgICAgICAgICBsZW4gPD0gMHgzZmZmID8gMiA6XG4gICAgICAgICAgICBsZW4gPD0gMHgxZmZmZmYgPyAzIDpcbiAgICAgICAgICAgIGxlbiA8PSAweGZmZmZmZmYgPyA0IDogTWF0aC5jZWlsKE1hdGgubG9nKGxlbikgLyAoTWF0aC5MTjIgKiA3KSk7XG5cbiAgICAgICAgLy8gaWYgMSBieXRlIGlzbid0IGVub3VnaCBmb3IgZW5jb2RpbmcgbWVzc2FnZSBsZW5ndGgsIHNoaWZ0IHRoZSBkYXRhIHRvIHRoZSByaWdodFxuICAgICAgICBpZiAodmFyaW50TGVuID4gMSkge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKHZhcmludExlbiAtIDEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucG9zIC0gMTsgaSA+PSBzdGFydFBvczsgaS0tKSB0aGlzLmJ1ZltpICsgdmFyaW50TGVuIC0gMV0gPSB0aGlzLmJ1ZltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmFsbHksIHdyaXRlIHRoZSBtZXNzYWdlIGxlbmd0aCBpbiB0aGUgcmVzZXJ2ZWQgcGxhY2UgYW5kIHJlc3RvcmUgdGhlIHBvc2l0aW9uXG4gICAgICAgIHRoaXMucG9zID0gc3RhcnRQb3MgLSAxO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbjtcbiAgICB9LFxuXG4gICAgd3JpdGVQYWNrZWRWYXJpbnQ6ICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFZhcmludCwgYXJyKTsgICB9LFxuICAgIHdyaXRlUGFja2VkU1ZhcmludDogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRTVmFyaW50LCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZEJvb2xlYW46ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkQm9vbGVhbiwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRGbG9hdDogICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEZsb2F0LCBhcnIpOyAgICB9LFxuICAgIHdyaXRlUGFja2VkRG91YmxlOiAgIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWREb3VibGUsIGFycik7ICAgfSxcbiAgICB3cml0ZVBhY2tlZEZpeGVkMzI6ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRml4ZWQzMiwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRTRml4ZWQzMjogZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFNGaXhlZDMyLCBhcnIpOyB9LFxuICAgIHdyaXRlUGFja2VkRml4ZWQ2NDogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRGaXhlZDY0LCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkU0ZpeGVkNjQsIGFycik7IH0sXG5cbiAgICB3cml0ZUJ5dGVzRmllbGQ6IGZ1bmN0aW9uKHRhZywgYnVmZmVyKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuICAgICAgICB0aGlzLndyaXRlQnl0ZXMoYnVmZmVyKTtcbiAgICB9LFxuICAgIHdyaXRlRml4ZWQzMkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlRml4ZWQzMih2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTRml4ZWQzMkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlU0ZpeGVkMzIodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuICAgICAgICB0aGlzLndyaXRlRml4ZWQ2NCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuICAgICAgICB0aGlzLndyaXRlU0ZpeGVkNjQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlVmFyaW50RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuVmFyaW50KTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTVmFyaW50RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuVmFyaW50KTtcbiAgICAgICAgdGhpcy53cml0ZVNWYXJpbnQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU3RyaW5nRmllbGQ6IGZ1bmN0aW9uKHRhZywgc3RyKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuICAgICAgICB0aGlzLndyaXRlU3RyaW5nKHN0cik7XG4gICAgfSxcbiAgICB3cml0ZUZsb2F0RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQzMik7XG4gICAgICAgIHRoaXMud3JpdGVGbG9hdCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVEb3VibGVGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDY0KTtcbiAgICAgICAgdGhpcy53cml0ZURvdWJsZSh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVCb29sZWFuRmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnRGaWVsZCh0YWcsIEJvb2xlYW4odmFsKSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVQYWNrZWRWYXJpbnQoYXJyLCBwYmYpICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlVmFyaW50KGFycltpXSk7ICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTVmFyaW50KGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU1ZhcmludChhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGbG9hdChhcnIsIHBiZikgICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRmxvYXQoYXJyW2ldKTsgICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWREb3VibGUoYXJyLCBwYmYpICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRG91YmxlKGFycltpXSk7ICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRCb29sZWFuKGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlQm9vbGVhbihhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDMyKGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRml4ZWQzMihhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTRml4ZWQzMihhcnIsIHBiZikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU0ZpeGVkMzIoYXJyW2ldKTsgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDY0KGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRml4ZWQ2NChhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTRml4ZWQ2NChhcnIsIHBiZikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU0ZpeGVkNjQoYXJyW2ldKTsgfVxuIl19
},{"./buffer":62}],64:[function(require,module,exports){
module.exports=require(17)
},{"/Users/bcamper/Documents/dev/vector-map/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js":17}],65:[function(require,module,exports){
/*!
 * strip-comments <https://github.com/jonschlinkert/strip-comments>
 *
 * Copyright (c) 2014 Jon Schlinkert, contributors.
 * Licensed under the MIT license.
 */

'use stric';

var reBlock = '\\/\\*';
var reBlockIgnore = '\\/\\*(?!\\*?\\!)';
var reBlockEnd = '(.|[\\r\\n]|\\n)*?\\*\\/\\n?\\n?';
var reLine = /(^|[^\S\n])(?:\/\/)([\s\S]+?)$/gm;
var reLineIgnore = /(^|[^\S\n])(?:\/\/[^!])([\s\S]+?)$/gm;


/**
 * Strip all comments
 *
 * {%= docs("strip") %}
 *
 * @param   {String} `str`  file contents or string to strip.
 * @param   {Object} `opts`  options are passed to `.block`, and `.line`
 * @return  {String} String without comments.
 * @api public
 */

var strip = module.exports = function(str, opts) {
  return str ? strip.block(strip.line(str, opts), opts) : '';
};


/**
 * Strip only block comments, optionally leaving protected comments
 * (e.g. `/*!`) intact.
 *
 * {%= docs("block") %}
 *
 * @param   {String} `str`  file content or string to strip to
 * @param   {Object} `opts`  if `safe:true`, strip only comments that do not start with `/*!` or `/**!`
 * @return  {String} String without block comments.
 * @api public
 */

strip.block = function(str, opts) {
  opts = opts || {};
  var re = new RegExp(reBlock + reBlockEnd, 'gm');
  if(opts.safe) {
    re = new RegExp(reBlockIgnore + reBlockEnd, 'gm');
  }
  return str ? str.replace(re, '') : '';
};


/**
 * Strip only line comments
 *
 * {%= docs("line") %}
 *
 * @param   {String} `str`  file content or string to strip to
 * @param   {Object} `opts`  if `safe:true`, strip all that not starts with `//!`
 * @return  {String} String without line comments.
 * @api public
 */

strip.line = function(str, opts) {
  opts = opts || {};
  var re = reLine;
  if(opts.safe) {
    re = reLineIgnore;
  }
  return str ? str.replace(re, '') : '';
};

},{}],66:[function(require,module,exports){
!function() {
  var topojson = {
    version: "1.6.19",
    mesh: function(topology) { return object(topology, meshArcs.apply(this, arguments)); },
    meshArcs: meshArcs,
    merge: function(topology) { return object(topology, mergeArcs.apply(this, arguments)); },
    mergeArcs: mergeArcs,
    feature: featureOrCollection,
    neighbors: neighbors,
    presimplify: presimplify
  };

  function stitchArcs(topology, arcs) {
    var stitchedArcs = {},
        fragmentByStart = {},
        fragmentByEnd = {},
        fragments = [],
        emptyIndex = -1;

    // Stitch empty arcs first, since they may be subsumed by other arcs.
    arcs.forEach(function(i, j) {
      var arc = topology.arcs[i < 0 ? ~i : i], t;
      if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
        t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
      }
    });

    arcs.forEach(function(i) {
      var e = ends(i),
          start = e[0],
          end = e[1],
          f, g;

      if (f = fragmentByEnd[start]) {
        delete fragmentByEnd[f.end];
        f.push(i);
        f.end = end;
        if (g = fragmentByStart[end]) {
          delete fragmentByStart[g.start];
          var fg = g === f ? f : f.concat(g);
          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else if (f = fragmentByStart[end]) {
        delete fragmentByStart[f.start];
        f.unshift(i);
        f.start = start;
        if (g = fragmentByEnd[start]) {
          delete fragmentByEnd[g.end];
          var gf = g === f ? f : g.concat(f);
          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else {
        f = [i];
        fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
      }
    });

    function ends(i) {
      var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
      if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
      else p1 = arc[arc.length - 1];
      return i < 0 ? [p1, p0] : [p0, p1];
    }

    function flush(fragmentByEnd, fragmentByStart) {
      for (var k in fragmentByEnd) {
        var f = fragmentByEnd[k];
        delete fragmentByStart[f.start];
        delete f.start;
        delete f.end;
        f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
        fragments.push(f);
      }
    }

    flush(fragmentByEnd, fragmentByStart);
    flush(fragmentByStart, fragmentByEnd);
    arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

    return fragments;
  }

  function meshArcs(topology, o, filter) {
    var arcs = [];

    if (arguments.length > 1) {
      var geomsByArc = [],
          geom;

      function arc(i) {
        var j = i < 0 ? ~i : i;
        (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
      }

      function line(arcs) {
        arcs.forEach(arc);
      }

      function polygon(arcs) {
        arcs.forEach(line);
      }

      function geometry(o) {
        if (o.type === "GeometryCollection") o.geometries.forEach(geometry);
        else if (o.type in geometryType) geom = o, geometryType[o.type](o.arcs);
      }

      var geometryType = {
        LineString: line,
        MultiLineString: polygon,
        Polygon: polygon,
        MultiPolygon: function(arcs) { arcs.forEach(polygon); }
      };

      geometry(o);

      geomsByArc.forEach(arguments.length < 3
          ? function(geoms) { arcs.push(geoms[0].i); }
          : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });
    } else {
      for (var i = 0, n = topology.arcs.length; i < n; ++i) arcs.push(i);
    }

    return {type: "MultiLineString", arcs: stitchArcs(topology, arcs)};
  }

  function mergeArcs(topology, objects) {
    var polygonsByArc = {},
        polygons = [],
        components = [];

    objects.forEach(function(o) {
      if (o.type === "Polygon") register(o.arcs);
      else if (o.type === "MultiPolygon") o.arcs.forEach(register);
    });

    function register(polygon) {
      polygon.forEach(function(ring) {
        ring.forEach(function(arc) {
          (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
        });
      });
      polygons.push(polygon);
    }

    function exterior(ring) {
      return cartesianRingArea(object(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]) > 0; // TODO allow spherical?
    }

    polygons.forEach(function(polygon) {
      if (!polygon._) {
        var component = [],
            neighbors = [polygon];
        polygon._ = 1;
        components.push(component);
        while (polygon = neighbors.pop()) {
          component.push(polygon);
          polygon.forEach(function(ring) {
            ring.forEach(function(arc) {
              polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
                if (!polygon._) {
                  polygon._ = 1;
                  neighbors.push(polygon);
                }
              });
            });
          });
        }
      }
    });

    polygons.forEach(function(polygon) {
      delete polygon._;
    });

    return {
      type: "MultiPolygon",
      arcs: components.map(function(polygons) {
        var arcs = [];

        // Extract the exterior (unique) arcs.
        polygons.forEach(function(polygon) {
          polygon.forEach(function(ring) {
            ring.forEach(function(arc) {
              if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                arcs.push(arc);
              }
            });
          });
        });

        // Stitch the arcs into one or more rings.
        arcs = stitchArcs(topology, arcs);

        // If more than one ring is returned,
        // at most one of these rings can be the exterior;
        // this exterior ring has the same winding order
        // as any exterior ring in the original polygons.
        if ((n = arcs.length) > 1) {
          var sgn = exterior(polygons[0][0]);
          for (var i = 0, t; i < n; ++i) {
            if (sgn === exterior(arcs[i])) {
              t = arcs[0], arcs[0] = arcs[i], arcs[i] = t;
              break;
            }
          }
        }

        return arcs;
      })
    };
  }

  function featureOrCollection(topology, o) {
    return o.type === "GeometryCollection" ? {
      type: "FeatureCollection",
      features: o.geometries.map(function(o) { return feature(topology, o); })
    } : feature(topology, o);
  }

  function feature(topology, o) {
    var f = {
      type: "Feature",
      id: o.id,
      properties: o.properties || {},
      geometry: object(topology, o)
    };
    if (o.id == null) delete f.id;
    return f;
  }

  function object(topology, o) {
    var absolute = transformAbsolute(topology.transform),
        arcs = topology.arcs;

    function arc(i, points) {
      if (points.length) points.pop();
      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length, p; k < n; ++k) {
        points.push(p = a[k].slice());
        absolute(p, k);
      }
      if (i < 0) reverse(points, n);
    }

    function point(p) {
      p = p.slice();
      absolute(p, 0);
      return p;
    }

    function line(arcs) {
      var points = [];
      for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
      if (points.length < 2) points.push(points[0].slice());
      return points;
    }

    function ring(arcs) {
      var points = line(arcs);
      while (points.length < 4) points.push(points[0].slice());
      return points;
    }

    function polygon(arcs) {
      return arcs.map(ring);
    }

    function geometry(o) {
      var t = o.type;
      return t === "GeometryCollection" ? {type: t, geometries: o.geometries.map(geometry)}
          : t in geometryType ? {type: t, coordinates: geometryType[t](o)}
          : null;
    }

    var geometryType = {
      Point: function(o) { return point(o.coordinates); },
      MultiPoint: function(o) { return o.coordinates.map(point); },
      LineString: function(o) { return line(o.arcs); },
      MultiLineString: function(o) { return o.arcs.map(line); },
      Polygon: function(o) { return polygon(o.arcs); },
      MultiPolygon: function(o) { return o.arcs.map(polygon); }
    };

    return geometry(o);
  }

  function reverse(array, n) {
    var t, j = array.length, i = j - n; while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
  }

  function bisect(a, x) {
    var lo = 0, hi = a.length;
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (a[mid] < x) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }

  function neighbors(objects) {
    var indexesByArc = {}, // arc index -> array of object indexes
        neighbors = objects.map(function() { return []; });

    function line(arcs, i) {
      arcs.forEach(function(a) {
        if (a < 0) a = ~a;
        var o = indexesByArc[a];
        if (o) o.push(i);
        else indexesByArc[a] = [i];
      });
    }

    function polygon(arcs, i) {
      arcs.forEach(function(arc) { line(arc, i); });
    }

    function geometry(o, i) {
      if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
      else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
    }

    var geometryType = {
      LineString: line,
      MultiLineString: polygon,
      Polygon: polygon,
      MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
    };

    objects.forEach(geometry);

    for (var i in indexesByArc) {
      for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
        for (var k = j + 1; k < m; ++k) {
          var ij = indexes[j], ik = indexes[k], n;
          if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
          if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
        }
      }
    }

    return neighbors;
  }

  function presimplify(topology, triangleArea) {
    var absolute = transformAbsolute(topology.transform),
        relative = transformRelative(topology.transform),
        heap = minAreaHeap();

    if (!triangleArea) triangleArea = cartesianTriangleArea;

    topology.arcs.forEach(function(arc) {
      var triangles = [],
          maxArea = 0,
          triangle;

      // To store each point’s effective area, we create a new array rather than
      // extending the passed-in point to workaround a Chrome/V8 bug (getting
      // stuck in smi mode). For midpoints, the initial effective area of
      // Infinity will be computed in the next step.
      for (var i = 0, n = arc.length, p; i < n; ++i) {
        p = arc[i];
        absolute(arc[i] = [p[0], p[1], Infinity], i);
      }

      for (var i = 1, n = arc.length - 1; i < n; ++i) {
        triangle = arc.slice(i - 1, i + 2);
        triangle[1][2] = triangleArea(triangle);
        triangles.push(triangle);
        heap.push(triangle);
      }

      for (var i = 0, n = triangles.length; i < n; ++i) {
        triangle = triangles[i];
        triangle.previous = triangles[i - 1];
        triangle.next = triangles[i + 1];
      }

      while (triangle = heap.pop()) {
        var previous = triangle.previous,
            next = triangle.next;

        // If the area of the current point is less than that of the previous point
        // to be eliminated, use the latter's area instead. This ensures that the
        // current point cannot be eliminated without eliminating previously-
        // eliminated points.
        if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;
        else maxArea = triangle[1][2];

        if (previous) {
          previous.next = next;
          previous[2] = triangle[2];
          update(previous);
        }

        if (next) {
          next.previous = previous;
          next[0] = triangle[0];
          update(next);
        }
      }

      arc.forEach(relative);
    });

    function update(triangle) {
      heap.remove(triangle);
      triangle[1][2] = triangleArea(triangle);
      heap.push(triangle);
    }

    return topology;
  };

  function cartesianRingArea(ring) {
    var i = -1,
        n = ring.length,
        a,
        b = ring[n - 1],
        area = 0;

    while (++i < n) {
      a = b;
      b = ring[i];
      area += a[0] * b[1] - a[1] * b[0];
    }

    return area * .5;
  }

  function cartesianTriangleArea(triangle) {
    var a = triangle[0], b = triangle[1], c = triangle[2];
    return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));
  }

  function compareArea(a, b) {
    return a[1][2] - b[1][2];
  }

  function minAreaHeap() {
    var heap = {},
        array = [],
        size = 0;

    heap.push = function(object) {
      up(array[object._ = size] = object, size++);
      return size;
    };

    heap.pop = function() {
      if (size <= 0) return;
      var removed = array[0], object;
      if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);
      return removed;
    };

    heap.remove = function(removed) {
      var i = removed._, object;
      if (array[i] !== removed) return; // invalid request
      if (i !== --size) object = array[size], (compareArea(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);
      return i;
    };

    function up(object, i) {
      while (i > 0) {
        var j = ((i + 1) >> 1) - 1,
            parent = array[j];
        if (compareArea(object, parent) >= 0) break;
        array[parent._ = i] = parent;
        array[object._ = i = j] = object;
      }
    }

    function down(object, i) {
      while (true) {
        var r = (i + 1) << 1,
            l = r - 1,
            j = i,
            child = array[j];
        if (l < size && compareArea(array[l], child) < 0) child = array[j = l];
        if (r < size && compareArea(array[r], child) < 0) child = array[j = r];
        if (j === i) break;
        array[child._ = i] = child;
        array[object._ = i = j] = object;
      }
    }

    return heap;
  }

  function transformAbsolute(transform) {
    if (!transform) return noop;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function(point, i) {
      if (!i) x0 = y0 = 0;
      point[0] = (x0 += point[0]) * kx + dx;
      point[1] = (y0 += point[1]) * ky + dy;
    };
  }

  function transformRelative(transform) {
    if (!transform) return noop;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function(point, i) {
      if (!i) x0 = y0 = 0;
      var x1 = (point[0] - dx) / kx | 0,
          y1 = (point[1] - dy) / ky | 0;
      point[0] = x1 - x0;
      point[1] = y1 - y0;
      x0 = x1;
      y0 = y1;
    };
  }

  function noop() {}

  if (typeof define === "function" && define.amd) define(topojson);
  else if (typeof module === "object" && module.exports) module.exports = topojson;
  else this.topojson = topojson;
}();

},{}],67:[function(require,module,exports){
module.exports.VectorTile = require('./lib/vectortile.js');
module.exports.VectorTileFeature = require('./lib/vectortilefeature.js');
module.exports.VectorTileLayer = require('./lib/vectortilelayer.js');

},{"./lib/vectortile.js":68,"./lib/vectortilefeature.js":69,"./lib/vectortilelayer.js":70}],68:[function(require,module,exports){
'use strict';

var VectorTileLayer = require('./vectortilelayer');

module.exports = VectorTile;

function VectorTile(pbf, end) {
    this.layers = pbf.readFields(readTile, {}, end);
}

function readTile(tag, layers, pbf) {
    if (tag === 3) {
        var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length) layers[layer.name] = layer;
    }
}


},{"./vectortilelayer":70}],69:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = VectorTileFeature;

function VectorTileFeature(pbf, end, extent, keys, values) {
    // Public
    this.properties = {};
    this.extent = extent;
    this.type = 0;

    // Private
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;

    pbf.readFields(readFeature, this, end);
}

function readFeature(tag, feature, pbf) {
    if (tag == 1) feature._id = pbf.readVarint();
    else if (tag == 2) readTag(pbf, feature);
    else if (tag == 3) feature.type = pbf.readVarint();
    else if (tag == 4) feature._geometry = pbf.pos;
}

function readTag(pbf, feature) {
    var end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var key = feature._keys[pbf.readVarint()],
            value = feature._values[pbf.readVarint()];
        feature.properties[key] = value;
    }
}

VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature.prototype.loadGeometry = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        lines = [],
        line;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();

            if (cmd === 1) { // moveTo
                if (line) lines.push(line);
                line = [];
            }

            line.push(new Point(x, y));

        } else if (cmd === 7) {
            line.push(line[0].clone()); // closePolygon

        } else {
            throw new Error('unknown command ' + cmd);
        }
    }

    if (line) lines.push(line);

    return lines;
};

VectorTileFeature.prototype.bbox = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();
            if (x < x1) x1 = x;
            if (x > x2) x2 = x;
            if (y < y1) y1 = y;
            if (y > y2) y2 = y;

        } else if (cmd !== 7) {
            throw new Error('unknown command ' + cmd);
        }
    }

    return [x1, y1, x2, y2];
};

VectorTileFeature.prototype.toGeoJSON = function(x, y, z) {
    var size = this.extent * Math.pow(2, z),
        x0 = this.extent * x,
        y0 = this.extent * y,
        coords = this.loadGeometry(),
        type = VectorTileFeature.types[this.type];

    for (var i = 0; i < coords.length; i++) {
        var line = coords[i];
        for (var j = 0; j < line.length; j++) {
            var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;
            line[j] = [
                (p.x + x0) * 360 / size - 180,
                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
            ];
        }
    }

    if (type === 'Point' && coords.length === 1) {
        coords = coords[0][0];
    } else if (type === 'Point') {
        coords = coords[0];
        type = 'MultiPoint';
    } else if (type === 'LineString' && coords.length === 1) {
        coords = coords[0];
    } else if (type === 'LineString') {
        type = 'MultiLineString';
    }

    return {
        type: "Feature",
        geometry: {
            type: type,
            coordinates: coords
        },
        properties: this.properties
    };
};

},{"point-geometry":71}],70:[function(require,module,exports){
'use strict';

var VectorTileFeature = require('./vectortilefeature.js');

module.exports = VectorTileLayer;

function VectorTileLayer(pbf, end) {
    // Public
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;

    // Private
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];

    pbf.readFields(readLayer, this, end);

    this.length = this._features.length;
}

function readLayer(tag, layer, pbf) {
    if (tag === 15) layer.version = pbf.readVarint();
    else if (tag === 1) layer.name = pbf.readString();
    else if (tag === 5) layer.extent = pbf.readVarint();
    else if (tag === 2) layer._features.push(pbf.pos);
    else if (tag === 3) layer._keys.push(pbf.readString());
    else if (tag === 4) layer._values.push(readValueMessage(pbf));
}

function readValueMessage(pbf) {
    var value = null,
        end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var tag = pbf.readVarint() >> 3;

        value = tag === 1 ? pbf.readString() :
            tag === 2 ? pbf.readFloat() :
            tag === 3 ? pbf.readDouble() :
            tag === 4 ? pbf.readVarint64() :
            tag === 5 ? pbf.readVarint() :
            tag === 6 ? pbf.readSVarint() :
            tag === 7 ? pbf.readBoolean() : null;
    }

    return value;
}

// return feature `i` from this layer as a `VectorTileFeature`
VectorTileLayer.prototype.feature = function(i) {
    if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');

    this._pbf.pos = this._features[i];

    var end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
};

},{"./vectortilefeature.js":69}],71:[function(require,module,exports){
'use strict';

module.exports = Point;

function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype = {
    clone: function() { return new Point(this.x, this.y); },

    add:     function(p) { return this.clone()._add(p);     },
    sub:     function(p) { return this.clone()._sub(p);     },
    mult:    function(k) { return this.clone()._mult(k);    },
    div:     function(k) { return this.clone()._div(k);     },
    rotate:  function(a) { return this.clone()._rotate(a);  },
    matMult: function(m) { return this.clone()._matMult(m); },
    unit:    function() { return this.clone()._unit(); },
    perp:    function() { return this.clone()._perp(); },
    round:   function() { return this.clone()._round(); },

    mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    equals: function(p) {
        return this.x === p.x &&
               this.y === p.y;
    },

    dist: function(p) {
        return Math.sqrt(this.distSqr(p));
    },

    distSqr: function(p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    angle: function() {
        return Math.atan2(this.y, this.x);
    },

    angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
    },

    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(θ) for θ.
    angleWithSep: function(x, y) {
        return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y);
    },

    _matMult: function(m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function(k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function(k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _unit: function() {
        this._div(this.mag());
        return this;
    },

    _perp: function() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

// constructs Point from an array if necessary
Point.convert = function (a) {
    if (a instanceof Point) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point(a[0], a[1]);
    }
    return a;
};

},{}],72:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Camera */

var Geo = _interopRequire(require("./geo"));

var Utils = _interopRequire(require("./utils/utils"));

var ShaderProgram = _interopRequire(require("./gl/shader_program"));

var glMatrix = _interopRequire(require("gl-matrix"));

var mat4 = glMatrix.mat4;
var vec3 = glMatrix.vec3;

// Abstract base class

var Camera = (function () {
    function Camera(name, scene) {
        var options = arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, Camera);

        this.scene = scene;
        this.position = options.position;
        this.zoom = options.zoom;
        // this.updateScene();
    }

    _createClass(Camera, {
        update: {

            // Update method called once per frame

            value: function update() {}
        },
        setupProgram: {

            // Called once per frame per program (e.g. for main render pass, then for each additional pass for feature selection, etc.)

            value: function setupProgram(program) {}
        },
        updateScene: {

            /**
                Sync camera position and/or zoom to scene
                position: [lat, lng] or [lat, lng, zoom]
                zoom: zoom
            */

            value: function updateScene() {
                if (this.position || this.zoom) {
                    var view = {};
                    if (this.position) {
                        view = { lng: this.position[0], lat: this.position[1], zoom: this.position[2] };
                    }
                    if (this.zoom) {
                        view.zoom = this.zoom;
                    }
                    this.scene.setView(view);
                }
            }
        }
    }, {
        create: {

            // Create a camera by type name, factory-style

            value: function create(name, scene, config) {
                switch (config.type) {
                    case "isometric":
                        return new IsometricCamera(name, scene, config);
                    case "flat":
                        return new FlatCamera(name, scene, config);
                    case "perspective":
                    /* falls through */
                    default:
                        return new PerspectiveCamera(name, scene, config);
                }
            }
        }
    });

    return Camera;
})();

module.exports = Camera;

/**
    Perspective matrix projection

    This is a specialized perspective camera that, given a desired camera focal length (which can also vary by zoom level),
    constrains the camera height above the ground plane such that the displayed ground area of the map matches that of
    a traditional web mercator map. This means you can set the camera location by [lat, lng, zoom] as you would a typical
    web mercator map, then adjust the focal length as needed.

    Vanishing point can also be adjusted to achieve different "viewing angles", e.g. instead of looking straight down into
    the center of the viewport, the camera appears to be tilted at an angle. For example:

    [0, 0] = looking towards center of viewport
    [-250, -250] = looking 250 pixels from the viewport center to the lower-left corner
    [400, 0] = looking 400 pixels to the right of the viewport center
*/

var PerspectiveCamera = (function (_Camera) {
    function PerspectiveCamera(name, scene) {
        var options = arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, PerspectiveCamera);

        _get(Object.getPrototypeOf(PerspectiveCamera.prototype), "constructor", this).call(this, name, scene, options);
        this.type = "perspective";

        // a single scalar, or pairs of stops mapping zoom levels, e.g. [zoom, focal length]
        this.focal_length = options.focal_length;
        this.fov = options.fov;
        if (!this.focal_length && !this.fov) {
            // Default focal length ranges by zoom
            this.focal_length = [[16, 2], [17, 2.5], [18, 3], [19, 4], [20, 6]];
        }

        this.vanishing_point = options.vanishing_point || [0, 0]; // [x, y]
        this.vanishing_point_skew = [];

        this.position_meters = null;
        this.viewMatrix = new Float64Array(16);
        this.projectionMatrix = new Float32Array(16);

        // 'camera' is the name of the shader block, e.g. determines where in the shader this code is injected
        ShaderProgram.replaceBlock("camera", "\n            uniform mat4 u_projection;\n            uniform vec3 u_eye;\n            uniform vec2 u_vanishing_point;\n\n            void cameraProjection (inout vec4 position) {\n                position = u_projection * position;\n            }");
    }

    _inherits(PerspectiveCamera, _Camera);

    _createClass(PerspectiveCamera, {
        constrainCamera: {

            // Constrains the camera so that the viewable area matches given the viewport height
            // (in world space, e.g. meters), given either a camera focal length or field-of-view
            // (focal length is used if both are passed).

            value: function constrainCamera(_ref) {
                var view_height = _ref.view_height;
                var height = _ref.height;
                var focal_length = _ref.focal_length;
                var fov = _ref.fov;

                // Solve for camera height
                if (!height) {
                    // We have focal length, calculate FOV
                    if (focal_length) {
                        fov = Math.atan(1 / focal_length) * 2;
                    }
                    // We have FOV, calculate focal length
                    else if (fov) {
                        fov = fov * Math.PI / 180; // convert FOV degrees to radians
                        focal_length = 1 / Math.tan(fov / 2);
                    }

                    // Distance that camera should be from ground such that it fits the field of view expected
                    // for a conventional web mercator map at the current zoom level and camera focal length
                    height = view_height / 2 * focal_length;
                }
                // Solve for camera focal length / field-of-view
                else {
                    focal_length = 2 * height / view_height;
                    fov = Math.atan(1 / focal_length) * 2;
                }

                return { view_height: view_height, height: height, focal_length: focal_length, fov: fov };
            }
        },
        updateMatrices: {
            value: function updateMatrices() {
                // TODO: only re-calculate these vars when necessary

                // Height of the viewport in meters at current zoom
                var viewport_height = this.scene.css_size.height * Geo.metersPerPixel(this.scene.zoom);

                // Compute camera properties to fit desired view

                var _constrainCamera = this.constrainCamera({
                    view_height: viewport_height,
                    focal_length: Utils.interpolate(this.scene.zoom, this.focal_length),
                    fov: Utils.interpolate(this.scene.zoom, this.fov)
                });

                var height = _constrainCamera.height;
                var fov = _constrainCamera.fov;

                // View matrix
                var position = [this.scene.center_meters.x, this.scene.center_meters.y, height];
                this.position_meters = position;

                // mat4.lookAt(this.viewMatrix,
                //     vec3.fromValues(...position),
                //     vec3.fromValues(position[0], position[1], height - 1),
                //     vec3.fromValues(0, 1, 0));
                // Exclude camera height from view matrix
                mat4.lookAt(this.viewMatrix, vec3.fromValues(position[0], position[1], 0), vec3.fromValues(position[0], position[1], -1), vec3.fromValues(0, 1, 0));

                // Projection matrix
                mat4.perspective(this.projectionMatrix, fov, this.scene.view_aspect, 1, height * 2);

                // Convert vanishing point from pixels to viewport space
                this.vanishing_point_skew[0] = this.vanishing_point[0] / this.scene.css_size.width;
                this.vanishing_point_skew[1] = this.vanishing_point[1] / this.scene.css_size.height;

                // Adjust projection matrix to include vanishing point skew
                this.projectionMatrix[8] = -this.vanishing_point_skew[0]; // z column of x row, e.g. amount z skews x
                this.projectionMatrix[9] = -this.vanishing_point_skew[1]; // z column of y row, e.g. amount z skews y

                // Translate geometry into the distance so that camera is appropriate height above ground
                // Additionally, adjust xy to compensate for any vanishing point skew, e.g. move geometry so that the displayed g
                // plane of the map matches that expected by a traditional web mercator map at this [lat, lng, zoom].
                mat4.translate(this.projectionMatrix, this.projectionMatrix, vec3.fromValues(viewport_height / 2 * this.scene.view_aspect * -this.vanishing_point_skew[0], viewport_height / 2 * -this.vanishing_point_skew[1], 0));

                // Include camera height in projection matrix
                mat4.translate(this.projectionMatrix, this.projectionMatrix, vec3.fromValues(0, 0, -height));
            }
        },
        update: {
            value: function update() {
                _get(Object.getPrototypeOf(PerspectiveCamera.prototype), "update", this).call(this);
                this.updateMatrices();
            }
        },
        setupProgram: {
            value: function setupProgram(program) {
                program.uniform("Matrix4fv", "u_projection", false, this.projectionMatrix);
                program.uniform("3f", "u_eye", 0, 0, this.position_meters[2]);
                program.uniform("2fv", "u_vanishing_point", this.vanishing_point_skew);
            }
        }
    });

    return PerspectiveCamera;
})(Camera);

// Isometric-style projection
// Note: this is actually an "axonometric" projection, but I'm using the colloquial term isometric because it is more recognizable.
// An isometric projection is a specific subset of axonometric projections.
// 'axis' determines the xy skew applied to a vertex based on its z coordinate, e.g. [0, 1] axis causes buildings to be drawn
// straight upwards on screen at their true height, [0, .5] would draw them up at half-height, [1, 0] would be sideways, etc.

var IsometricCamera = (function (_Camera2) {
    function IsometricCamera(name, scene) {
        var options = arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, IsometricCamera);

        _get(Object.getPrototypeOf(IsometricCamera.prototype), "constructor", this).call(this, name, scene, options);
        this.type = "isometric";
        this.axis = options.axis || { x: 0, y: 1 };
        if (this.axis.length === 2) {
            this.axis = { x: this.axis[0], y: this.axis[1] }; // allow axis to also be passed as 2-elem array
        }

        this.position_meters = null;
        this.viewport_height = null;

        this.viewMatrix = new Float64Array(16);
        this.projectionMatrix = new Float32Array(16);

        // 'camera' is the name of the shader block, e.g. determines where in the shader this code is injected
        ShaderProgram.replaceBlock("camera", "\n            uniform mat4 u_projection;\n            uniform vec3 u_eye;\n            uniform vec2 u_vanishing_point;\n\n            void cameraProjection (inout vec4 position) {\n                position = u_projection * position;\n                // position.xy += position.z * u_isometric_axis;\n\n                // Reverse z for depth buffer so up is negative,\n                // and scale down values so objects higher than one screen height will not get clipped\n                // pull forward slightly to avoid going past far clipping plane\n                position.z = -position.z / 100. + 1. - 0.001;\n            }");
    }

    _inherits(IsometricCamera, _Camera2);

    _createClass(IsometricCamera, {
        update: {
            value: function update() {
                _get(Object.getPrototypeOf(IsometricCamera.prototype), "update", this).call(this);

                this.viewport_height = this.scene.css_size.height * Geo.metersPerPixel(this.scene.zoom);
                var position = [this.scene.center_meters.x, this.scene.center_meters.y, this.viewport_height];
                this.position_meters = position;

                // View
                mat4.identity(this.viewMatrix);
                mat4.translate(this.viewMatrix, this.viewMatrix, vec3.fromValues(-position[0], -position[1], 0));

                // Projection
                mat4.identity(this.projectionMatrix);

                // apply isometric skew
                this.projectionMatrix[8] = this.axis.x / this.scene.view_aspect; // z column of x row, e.g. amount z skews x
                this.projectionMatrix[9] = this.axis.y; // z column of x row, e.g. amount z skews y

                // convert meters to viewport
                mat4.scale(this.projectionMatrix, this.projectionMatrix, vec3.fromValues(2 / this.scene.viewport_meters.x, 2 / this.scene.viewport_meters.y, 2 / this.scene.viewport_meters.y));
            }
        },
        setupProgram: {
            value: function setupProgram(program) {
                program.uniform("Matrix4fv", "u_projection", false, this.projectionMatrix);

                program.uniform("3f", "u_eye", 0, 0, this.viewport_height);
                // program.uniform('3f', 'u_eye', this.viewport_height * this.axis.x, this.viewport_height * this.axis.y, this.viewport_height);
                program.uniform("2f", "u_vanishing_point", 0, 0);
            }
        }
    });

    return IsometricCamera;
})(Camera);

// Flat projection (e.g. just top-down, no perspective) - a degenerate isometric camera

var FlatCamera = (function (_IsometricCamera) {
    function FlatCamera(name, scene) {
        var options = arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, FlatCamera);

        _get(Object.getPrototypeOf(FlatCamera.prototype), "constructor", this).call(this, name, scene, options);
        this.type = "flat";
    }

    _inherits(FlatCamera, _IsometricCamera);

    _createClass(FlatCamera, {
        update: {
            value: function update() {
                // Axis is fixed to (0, 0) for flat camera
                this.axis.x = 0;
                this.axis.y = 0;

                _get(Object.getPrototypeOf(FlatCamera.prototype), "update", this).call(this);
            }
        }
    });

    return FlatCamera;
})(IsometricCamera);

// this.updateScene();

},{"./geo":73,"./gl/shader_program":79,"./utils/utils":115,"gl-matrix":27}],73:[function(require,module,exports){
"use strict";

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

// Miscellaneous geo functions

var Geo;
module.exports = Geo = {};

// Projection constants
Geo.tile_size = 256;
Geo.half_circumference_meters = 20037508.342789244;
Geo.circumference_meters = Geo.half_circumference_meters * 2;
Geo.min_zoom_meters_per_pixel = Geo.circumference_meters / Geo.tile_size; // min zoom draws world as 2 tiles wide
Geo.meters_per_pixel = [];
Geo.meters_per_tile = [];
Geo.max_zoom = 18;
for (var z = 0; z <= Geo.max_zoom; z++) {
    Geo.meters_per_pixel[z] = Geo.min_zoom_meters_per_pixel / Math.pow(2, z);
    Geo.meters_per_tile[z] = Geo.circumference_meters / Math.pow(2, z);
}

Geo.metersPerPixel = function (zoom) {
    return Geo.min_zoom_meters_per_pixel / Math.pow(2, zoom);
};

// Conversion functions based on an defined tile scale
Geo.units_per_meter = [];
Geo.tile_scale = 4096; // coordinates are locally scaled to the range [0, tile_scale]
Geo.units_per_pixel = Geo.tile_scale / Geo.tile_size;

for (var _z = 0; _z <= Geo.max_zoom; _z++) {
    Geo.units_per_meter[_z] = Geo.tile_scale / (Geo.tile_size * Geo.meters_per_pixel[_z]);
}

// Convert tile location to mercator meters - multiply by pixels per tile, then by meters per pixel, adjust for map origin
Geo.metersForTile = function (tile) {
    return {
        x: tile.x * Geo.circumference_meters / Math.pow(2, tile.z) - Geo.half_circumference_meters,
        y: -(tile.y * Geo.circumference_meters / Math.pow(2, tile.z) - Geo.half_circumference_meters)
    };
};

/**
   Given a point in mercator meters and a zoom level, return the tile X/Y/Z that the point lies in
*/
Geo.tileForMeters = function (_ref, zoom) {
    var _ref2 = _slicedToArray(_ref, 2);

    var x = _ref2[0];
    var y = _ref2[1];

    return {
        x: Math.floor((x + Geo.half_circumference_meters) / (Geo.circumference_meters / Math.pow(2, zoom))),
        y: Math.floor((-y + Geo.half_circumference_meters) / (Geo.circumference_meters / Math.pow(2, zoom))),
        z: zoom
    };
};

// Wrap a tile to positive #s for zoom
// Optionally specify the axes to wrap
Geo.wrapTile = function (_ref) {
    var x = _ref.x;
    var y = _ref.y;
    var z = _ref.z;
    var mask = arguments[1] === undefined ? { x: true, y: false } : arguments[1];

    var m = (1 << z) - 1;
    if (mask.x) {
        x = x & m;
    }
    if (mask.y) {
        y = y & m;
    }
    return { x: x, y: y, z: z };
};

/**
   Convert mercator meters to lat-lng
*/
Geo.metersToLatLng = function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2);

    var x = _ref2[0];
    var y = _ref2[1];

    x /= Geo.half_circumference_meters;
    y /= Geo.half_circumference_meters;

    y = (2 * Math.atan(Math.exp(y * Math.PI)) - Math.PI / 2) / Math.PI;

    x *= 180;
    y *= 180;

    return [x, y];
};

/**
  Convert lat-lng to mercator meters
*/
Geo.latLngToMeters = function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2);

    var x = _ref2[0];
    var y = _ref2[1];

    // Latitude
    y = Math.log(Math.tan(y * Math.PI / 360 + Math.PI / 4)) / Math.PI;
    y *= Geo.half_circumference_meters;

    // Longitude
    x *= Geo.half_circumference_meters / 180;

    return [x, y];
};

Geo.wrapLng = function (x) {
    if (x > 180 || x < -180) {
        x = ((x + 180) % 360 + 360) % 360 - 180;
    }
    return x;
};

// Run an in-place transform function on each cooordinate in a GeoJSON geometry
Geo.transformGeometry = function (geometry, transform) {
    if (geometry.type === "Point") {
        transform(geometry.coordinates);
    } else if (geometry.type === "LineString" || geometry.type === "MultiPoint") {
        geometry.coordinates.forEach(transform);
    } else if (geometry.type === "Polygon" || geometry.type === "MultiLineString") {
        geometry.coordinates.forEach(function (coordinates) {
            return coordinates.forEach(transform);
        });
    } else if (geometry.type === "MultiPolygon") {
        geometry.coordinates.forEach(function (polygon) {
            polygon.forEach(function (coordinates) {
                return coordinates.forEach(transform);
            });
        });
    }
    // TODO: support GeometryCollection
};

Geo.boxIntersect = function (b1, b2) {
    return !(b2.sw.x > b1.ne.x || b2.ne.x < b1.sw.x || b2.sw.y > b1.ne.y || b2.ne.y < b1.sw.y);
};

// Finds the axis-aligned bounding box for a polygon
Geo.findBoundingBox = function (polygon) {
    var min_x = Infinity,
        max_x = -Infinity,
        min_y = Infinity,
        max_y = -Infinity;

    // Only need to examine outer ring (polygon[0])
    var num_coords = polygon[0].length;
    for (var c = 0; c < num_coords; c++) {
        var coord = polygon[0][c];

        if (coord[0] < min_x) {
            min_x = coord[0];
        }
        if (coord[1] < min_y) {
            min_y = coord[1];
        }
        if (coord[0] > max_x) {
            max_x = coord[0];
        }
        if (coord[1] > max_y) {
            max_y = coord[1];
        }
    }

    return [min_x, min_y, max_x, max_y];
};

// Convert geometry type to one of: 'point', 'line', 'polygon'
Geo.geometryType = function (type) {
    if (type === "Polygon" || type === "MultiPolygon") {
        return "polygon";
    } else if (type === "LineString" || type === "MultiLineString") {
        return "line";
    }
    if (type === "Point" || type === "MultiPoint") {
        return "point";
    }
};

Geo.centroid = function (polygon) {
    var n = polygon.length;
    var centroid = [0, 0];

    for (var p = 0; p < polygon.length; p++) {
        centroid[0] += polygon[p][0];
        centroid[1] += polygon[p][1];
    }

    centroid[0] /= n;
    centroid[1] /= n;

    return centroid;
};

Geo.multiCentroid = function (polygons) {
    var n = polygons.length;
    var centroid = [0, 0];

    for (var p = 0; p < polygons.length; p++) {
        var polygon = polygons[p][0];
        var c = Geo.centroid(polygon);
        centroid[0] += c[0];
        centroid[1] += c[1];
    }

    centroid[0] /= n;
    centroid[1] /= n;

    return centroid;
};

Geo.signedPolygonAreaSum = function (polygon) {
    var area = 0;
    var n = polygon.length;

    for (var i = 0; i < n - 1; i++) {
        var p0 = polygon[i];
        var p1 = polygon[i + 1];

        area += p0[0] * p1[1] - p1[0] * p0[1];
    }

    area += polygon[n - 1][0] * polygon[0][1] - polygon[0][0] * polygon[n - 1][1];
    return area;
};

// TODO: subtract inner ring areas
Geo.polygonArea = function (polygon) {
    return Math.abs(Geo.signedPolygonAreaSum(polygon)) / 2;
};

Geo.multiPolygonArea = function (polygons) {
    var area = 0;

    for (var p = 0; p < polygons.length; p++) {
        var polygon = polygons[p][0];
        area += Geo.polygonArea(polygon);
    }

    return area;
};

Geo.ringWinding = function (ring) {
    return Geo.signedPolygonAreaSum(ring) > 0 ? "CW" : "CCW";
};

// Enforce winding order on outer/inner rings
// winding: 'CW' or 'CCW'
Geo.enforceWinding = function (geom, winding) {
    var polys = undefined;
    if (geom.type === "Polygon") {
        polys = [geom.coordinates];
    } else if (geom.type === "MultiPolygon") {
        polys = geom.coordinates;
    } else {
        return geom;
    }

    for (var p = 0; p < polys.length; p++) {
        var poly = polys[p];

        // If first ring winding doesn't match, reverse all rings
        // NOTE: assumes ring winding orders already alternate as expected
        if (Geo.ringWinding(poly[0]) !== winding) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = poly[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var ring = _step.value;

                    ring.reverse();
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                        _iterator["return"]();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
    }
    return geom;
};

},{}],74:[function(require,module,exports){
// WebGL constants - need to import these separately to make them available in the web worker

"use strict";

var gl;
module.exports = gl = {};

/* DataType */
gl.BYTE = 5120;
gl.UNSIGNED_BYTE = 5121;
gl.SHORT = 5122;
gl.UNSIGNED_SHORT = 5123;
gl.INT = 5124;
gl.UNSIGNED_INT = 5125;
gl.FLOAT = 5126;

},{}],75:[function(require,module,exports){
// WebGL context wrapper

"use strict";

var Context;
module.exports = Context = {};

// Setup a WebGL context
// If no canvas element is provided, one is created and added to the document body
Context.getContext = function getContext(canvas, options) {
    var fullscreen = false;
    if (canvas == null) {
        canvas = document.createElement("canvas");
        canvas.style.position = "absolute";
        canvas.style.top = 0;
        canvas.style.left = 0;
        canvas.style.zIndex = -1;
        document.body.appendChild(canvas);
        fullscreen = true;
    }

    var gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
    if (!gl) {
        throw new Error("Couldn't create WebGL context.");
    }

    Context.resize(gl, window.innerWidth, window.innerHeight, options.device_pixel_ratio);
    if (fullscreen === true) {
        window.addEventListener("resize", function () {
            Context.resize(gl, window.innerWidth, window.innerHeight);
        });
    }

    return gl;
};

Context.resize = function (gl, width, height, device_pixel_ratio) {
    device_pixel_ratio = device_pixel_ratio || window.devicePixelRatio || 1;
    gl.canvas.style.width = width + "px";
    gl.canvas.style.height = height + "px";
    gl.canvas.width = Math.round(gl.canvas.style.width * device_pixel_ratio);
    gl.canvas.height = Math.round(gl.canvas.style.width * device_pixel_ratio);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
};

},{}],76:[function(require,module,exports){
// map of extensions by GL context

"use strict";

module.exports = getExtension;
// WebGL extension wrapper
// Stores extensions by name and GL context

var extensions = new Map();
function getExtension(gl, name) {
    var exts = extensions.get(gl);
    if (!exts) {
        extensions.set(gl, new Map());
        exts = extensions.get(gl);
    }

    if (!exts.get(name)) {
        exts.set(name, gl.getExtension(name));
    }
    return exts.get(name);
}

},{}],77:[function(require,module,exports){
"use strict";

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var GLSL = {};
module.exports = GLSL;

/**
    Parse uniforms from a JS object, infers types and returns an array of objects with the
    necessary information to set uniform values on a GL program. Each object in the returned
    array has the form:
    { type, method, name, value }

    type: the GL uniform type, such as 'vec3', 'float', etc.
    method: the GL uniform setter method to use, such as '1f', '3fv', etc.
    name: the fully qualified name of the GL uniform location, e.g. 'array[0].field', etc.
    value: the value to be passed to the GL uniform setter for that type, e.g. [1, 2, 3] for a vec3

    Textures have special behavior: uniforms with string values are treated as textures, and
    the string is used as a unique texture 'key' to be interpreted by the caller (which is responsible
    for actually setting the uniforms). For example, this could be used as a key into a dictionary of
    known texture names, or it could simply be used as a URL to dynamically load the texture from.
*/
GLSL.parseUniforms = function (uniforms) {
    var prefix = arguments[1] === undefined ? null : arguments[1];

    var parsed = [];

    for (var name in uniforms) {
        var uniform = uniforms[name];
        var u;

        if (prefix) {
            name = prefix + "." + name;
        }

        // Single float
        if (typeof uniform === "number") {
            parsed.push({
                type: "float",
                method: "1f",
                name: name, value: uniform
            });
        }
        // Array: vector, array of floats, array of textures, or array of structs
        else if (Array.isArray(uniform)) {
            // Numeric values
            if (typeof uniform[0] === "number") {
                // float vectors (vec2, vec3, vec4)
                if (uniform.length >= 2 && uniform.length <= 4) {
                    parsed.push({
                        type: "vec" + uniform.length,
                        method: uniform.length + "fv",
                        name: name,
                        value: uniform
                    });
                }
                // float array
                else if (uniform.length > 4) {
                    parsed.push({
                        type: "float[]",
                        method: "1fv",
                        name: name + "[0]",
                        value: uniform
                    });
                }
                // TODO: assume matrix for (typeof == Float32Array && length == 16)?
            }
            // Array of textures
            else if (typeof uniform[0] === "string") {
                for (u = 0; u < uniform.length; u++) {
                    parsed.push({
                        type: "sampler2D",
                        method: "1i",
                        name: name + "[" + u + "]",
                        value: uniform[u]
                    });
                }
            }
            // Array of arrays - but only arrays of vectors are allowed in this case
            else if (Array.isArray(uniform[0]) && typeof uniform[0][0] === "number") {
                // float vectors (vec2, vec3, vec4)
                if (uniform[0].length >= 2 && uniform[0].length <= 4) {
                    // Set each vector in the array
                    for (u = 0; u < uniform.length; u++) {
                        parsed.push({
                            type: "vec" + uniform[0].length,
                            method: uniform[u].length + "fv",
                            name: name + "[" + u + "]",
                            value: uniform[u]
                        });
                    }
                }
                // else error?
            }
            // Array of structures
            else if (typeof uniform[0] === "object") {
                for (u = 0; u < uniform.length; u++) {
                    // Set each struct in the array
                    parsed.push.apply(parsed, _toConsumableArray(GLSL.parseUniforms(uniform[u], name + "[" + u + "]")));
                }
            }
        }
        // Boolean
        else if (typeof uniform === "boolean") {
            parsed.push({
                type: "bool",
                method: "1i",
                name: name,
                value: uniform
            });
        }
        // Texture
        else if (typeof uniform === "string") {
            parsed.push({
                type: "sampler2D",
                method: "1i",
                name: name,
                value: uniform
            });
        }
        // Structure
        else if (typeof uniform === "object") {
            // Set each field in the struct
            parsed.push.apply(parsed, _toConsumableArray(GLSL.parseUniforms(uniform, name)));
        }

        // TODO: support other non-float types? (int, etc.)
    }

    return parsed;
};

/**
    Generate a GLSL variable definition from a JS object
*/
GLSL.defineVariable = function (name, value) {
    var prefix = arguments[2] === undefined ? null : arguments[2];

    var type, array;
    var structs = "";
    prefix = prefix ? prefix + "_" + name : name;

    // Single float
    if (typeof value === "number") {
        type = "float";
    }
    // Multiple floats - vector or array
    else if (Array.isArray(value)) {
        // Numeric values
        if (typeof value[0] === "number") {
            // float vectors (vec2, vec3, vec4)
            if (value.length >= 2 && value.length <= 4) {
                type = "vec" + value.length;
            }
            // float array
            else {
                //if (value.length > 4) {
                type = "float";
                array = value.length;
            }
            // TODO: assume matrix for (typeof == Float32Array && length == 16)?
        }
        // Array of textures
        else if (typeof value[0] === "string") {
            type = "sampler2D";
            array = value.length;
        }
        // Array of arrays - but only arrays of vectors are allowed in this case
        else if (Array.isArray(value[0]) && typeof value[0][0] === "number") {
            // float vectors (vec2, vec3, vec4)
            if (value[0].length >= 2 && value[0].length <= 4) {
                type = "vec" + value[0].length;
            }
            // else error?
            array = value[0].length;
        }
        // Array of structures
        else if (typeof value[0] === "object") {
            type = "_type_" + prefix; // custom struct name
            array = value.length;
            structs += GLSL.defineStruct(type, value[0], prefix) + "\n"; // build & add to list of dependent structs
        }
    }
    // Boolean
    else if (typeof value === "boolean") {
        type = "bool";
    }
    // Texture
    else if (typeof value === "string") {
        type = "sampler2D";
    }
    // Structure
    else if (typeof value === "object") {
        type = "_type_" + prefix; // custom struct name
        structs += GLSL.defineStruct(type, value, prefix) + "\n"; // build & add to list of dependent structs
    }

    // Construct variable definition
    var variable = "";
    variable += "" + type + " " + name;
    if (array) {
        variable += "[" + array + "]";
    }
    variable += ";\n";

    // Return the variable definition itself, and any dependent struct definitions
    return { variable: variable, structs: structs };
};

/**
    Generate a GLSL structure definition from a JS object
*/
GLSL.defineStruct = function (type, value) {
    var prefix = arguments[2] === undefined ? null : arguments[2];

    var struct = "struct " + type + " {\n";
    var dependents = "";
    for (var field in value) {
        var subvar = GLSL.defineVariable(field, value[field], prefix);
        struct += "    " + subvar.variable;
        dependents += subvar.structs;
    }
    struct += "};\n";
    struct = dependents + struct;
    return struct;
};

/**
    Generate a GLSL uniform definition from a JS object
*/
GLSL.defineUniform = function (name, value) {
    var def = GLSL.defineVariable(name, value);
    def = def.structs + "uniform " + def.variable;
    return def;
};

/**
    Check for a uniform definition of 'name' in the provided GLSL source
    Simple regex check for 'uniform' keyword and var name, does not attempt to parse/extract GLSL
    NOTE: assumes comments have been stripped from source
*/
GLSL.isUniformDefined = function (name, source) {
    // Match, in order:
    // - the keyword 'uniform'
    // - at least one character that is anything except a semicolon, ;
    // - optionally, anything enclosed in curly braces, { ... } (an inline structure definition can go here)
    // - optionally, any # of characters that is not a semicolon, ;
    // - the name of the uniform

    var re = new RegExp("uniform[^;]+(?:{[\\s\\S]*})?[^;]*\\b" + name + "\\b", "g");
    if (source.match(re)) {
        return true;
    }
    return false;
};

/**
    Check that a symbol is referenced in the GLSL source
    NOTE: assumes comments have been stripped from source
*/
GLSL.isSymbolReferenced = function (name, source) {
    var re = new RegExp("\\b" + name + "\\b", "g");
    if (source.search(re) >= 0) {
        return true;
    }
    return false;
};

/**
    Expand a single value or 2-element array into a 3-element array, with the last ( z )
    coordinate defaulting to 1 (with option to specify). Also runs parseFloat to try to maintain
    data integrity. Returns null if input couldn't be parsed.
*/
GLSL.expandVec3 = function (v) {
    var z = arguments[1] === undefined ? 1 : arguments[1];

    var x = undefined;
    if (Array.isArray(v) && v.length === 2) {
        x = [].concat(_toConsumableArray(v), [z]).map(parseFloat);
    } else {
        x = [v, v, v].map(parseFloat);
    }

    if (x && x.every(function (n) {
        return typeof n === "number" && !isNaN(n);
    })) {
        return x;
    }
};

/**
    Expand a single value or 3-element array into a 4-element array, with the last (e.g. w or a)
    coordinate defaulting to 1 (with option to specify). Also runs parseFloat to try to maintain
    data integrity. Returns null if input couldn't be parsed.
*/
GLSL.expandVec4 = function (v) {
    var w = arguments[1] === undefined ? 1 : arguments[1];

    var x = undefined;
    if (Array.isArray(v) && v.length === 3) {
        x = [].concat(_toConsumableArray(v), [w]).map(parseFloat);
    } else {
        x = [v, v, v, w].map(parseFloat);
    }

    if (x && x.every(function (n) {
        return typeof n === "number" && !isNaN(n);
    })) {
        return x;
    }
};

},{}],78:[function(require,module,exports){
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var RenderState = (function () {
    function RenderState(value, setup) {
        _classCallCheck(this, RenderState);

        setup(value);
        this.value = value;
        this.setup = setup;
    }

    _createClass(RenderState, {
        set: {
            value: function set(value) {
                // if the states are different, call the GL context for a state change
                if (JSON.stringify(this.value) !== JSON.stringify(value)) {
                    this.setup(value);
                    this.value = value;
                }
            }
        }
    }, {
        initialize: {
            value: function initialize(gl) {
                // Culling
                RenderState.culling = new RenderState({ cull: true, face: gl.BACK }, function (value) {
                    if (value.cull) {
                        gl.enable(gl.CULL_FACE);
                        gl.cullFace(value.face);
                    } else {
                        gl.disable(gl.CULL_FACE);
                    }
                });

                // Blending mode
                RenderState.blending = new RenderState({ blend: false, src: gl.SRC_ALPHA, dst: gl.ONE_MINUS_SRC_ALPHA }, function (value) {
                    if (value.blend) {
                        gl.enable(gl.BLEND);
                        gl.blendFunc(value.src, value.dst);
                    } else {
                        gl.disable(gl.BLEND);
                    }
                });

                // Depth write
                RenderState.depth_write = new RenderState({ depth_write: true }, function (value) {
                    gl.depthMask(value.depth_write);
                });

                // Depth test
                RenderState.depth_test = new RenderState({ depth_test: true, depth_func: gl.LEQUAL }, function (value) {
                    if (value.depth_test) {
                        gl.enable(gl.DEPTH_TEST);
                        gl.depthFunc(value.depth_func);
                    } else {
                        gl.disable(gl.DEPTH_TEST);
                    }
                });
            }
        }
    });

    return RenderState;
})();

module.exports = RenderState;

},{}],79:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/* global ShaderProgram */
// GL program wrapper to cache uniform locations/values, do compile-time pre-processing
// (injecting #defines and #pragma blocks into shaders), etc.

var GLSL = _interopRequire(require("./glsl"));

var Texture = _interopRequire(require("./texture"));

var getExtension = _interopRequire(require("./extensions"));

var log = _interopRequire(require("loglevel"));

var strip = _interopRequire(require("strip-comments"));

var parseShaderErrors = _interopRequire(require("gl-shader-errors"));

var ShaderProgram = (function () {
    function ShaderProgram(gl, vertex_source, fragment_source, options) {
        _classCallCheck(this, ShaderProgram);

        options = options || {};

        this.gl = gl;
        this.program = null;
        this.compiled = false;
        this.compiling = false;
        this.error = null;

        // key/values inserted as #defines into shaders at compile-time
        this.defines = Object.assign({}, options.defines || {});

        // key/values for blocks that can be injected into shaders at compile-time
        this.blocks = Object.assign({}, options.blocks || {});

        // list of extensions to activate
        this.extensions = options.extensions || [];

        // JS-object uniforms that are expected by this program
        // If they are not found in the existing shader source, their types will be inferred and definitions
        // for each will be injected.
        this.dependent_uniforms = options.uniforms;

        this.uniforms = {}; // program locations of uniforms, lazily added as each uniform is set
        this.attribs = {}; // program locations of vertex attributes, lazily added as each attribute is accessed

        this.vertex_source = vertex_source;
        this.fragment_source = fragment_source;

        this.id = ShaderProgram.id++;
        ShaderProgram.programs[this.id] = this;
        this.name = options.name; // can provide a program name (useful for debugging)
    }

    _createClass(ShaderProgram, {
        destroy: {
            value: function destroy() {
                this.gl.useProgram(null);
                this.gl.deleteProgram(this.program);
                this.program = null;
                this.uniforms = {};
                this.attribs = {};
                delete ShaderProgram.programs[this.id];
                this.compiled = false;
            }
        },
        use: {

            // Use program wrapper with simple state cache

            value: function use() {
                if (!this.compiled) {
                    return;
                }

                if (ShaderProgram.current !== this) {
                    this.gl.useProgram(this.program);
                }
                ShaderProgram.current = this;
            }
        },
        compile: {
            value: function compile() {
                if (this.compiling) {
                    throw new Error("ShaderProgram.compile(): skipping for " + this.id + " (" + this.name + ") because already compiling");
                }
                this.compiling = true;
                this.compiled = false;
                this.error = null;

                // Copy sources from pre-modified template
                this.computed_vertex_source = this.vertex_source;
                this.computed_fragment_source = this.fragment_source;

                // Check for extension availability
                var extensions = this.checkExtensions();

                // Make list of defines to be injected later
                var defines = this.buildDefineList();

                // Inject user-defined blocks (arbitrary code points matching named #pragmas)
                // Replace according to this pattern:
                // #pragma tangram: [key]
                // e.g. #pragma tangram: global

                // Gather all block code snippets
                var blocks = this.buildShaderBlockList();
                var regexp;

                for (var key in blocks) {
                    var block = blocks[key];
                    if (!block || Array.isArray(block) && block.length === 0) {
                        continue;
                    }

                    // First find code replace points in shaders
                    regexp = new RegExp("^\\s*#pragma\\s+tangram:\\s+" + key + "\\s*$", "m");
                    var inject_vertex = this.computed_vertex_source.match(regexp);
                    var inject_fragment = this.computed_fragment_source.match(regexp);

                    // Avoid network request if nothing to replace
                    if (inject_vertex == null && inject_fragment == null) {
                        continue;
                    }

                    // Each key can be a single string or array of strings
                    var source = "\n" + block + "\n";
                    if (Array.isArray(block)) {
                        // Combine all blocks into one string
                        source = block.reduce(function (prev, cur) {
                            return "\n" + prev + "\n" + cur + "\n";
                        });
                    }
                    source = "// tangram-block-start: " + key + "\n" + source; // mark start and end of block
                    source += "// tangram-block-end: " + key;

                    // Inject
                    if (inject_vertex != null) {
                        this.computed_vertex_source = this.computed_vertex_source.replace(regexp, source);
                    }
                    if (inject_fragment != null) {
                        this.computed_fragment_source = this.computed_fragment_source.replace(regexp, source);
                    }

                    // Add a #define for this injection point
                    defines["TANGRAM_BLOCK_" + key.replace(/[\s-]+/g, "_").toUpperCase()] = true;
                }

                // Clean-up any #pragmas that weren't replaced (to prevent compiler warnings)
                regexp = new RegExp("^\\s*#pragma.*$", "gm");
                this.computed_vertex_source = this.computed_vertex_source.replace(regexp, "");
                this.computed_fragment_source = this.computed_fragment_source.replace(regexp, "");

                // Detect uniform definitions, inject any missing ones
                this.ensureUniforms(this.dependent_uniforms);

                // Build & inject extensions & defines
                // This is done *after* code injection so that we can add defines for which code points were injected
                var info = this.name ? this.name + " / id " + this.id : "id " + this.id;
                var header = "// Program: " + info + "\n" + ShaderProgram.buildExtensionString(extensions);

                defines.TANGRAM_VERTEX_SHADER = true;
                defines.TANGRAM_FRAGMENT_SHADER = false;
                this.computed_vertex_source = header + ShaderProgram.buildDefineString(defines) + this.computed_vertex_source;

                defines.TANGRAM_VERTEX_SHADER = false;
                defines.TANGRAM_FRAGMENT_SHADER = true;
                this.computed_fragment_source = header + ShaderProgram.buildDefineString(defines) + this.computed_fragment_source;

                // Add precision qualifier
                this.computed_fragment_source = "#ifdef GL_ES\nprecision highp float;\n#endif\n\n" + this.computed_fragment_source;

                // Compile & set uniforms to cached values
                try {
                    this.program = ShaderProgram.updateProgram(this.gl, this.program, this.computed_vertex_source, this.computed_fragment_source);
                    this.compiled = true;
                    this.compiling = false;
                } catch (error) {
                    this.program = null;
                    this.compiled = false;
                    this.compiling = false;
                    this.error = error;

                    // shader error info
                    if (error.type === "vertex" || error.type === "fragment") {
                        this.shader_errors = error.errors;
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = this.shader_errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var e = _step.value;

                                e.type = error.type;
                                e.block = this.block(error.type, e.line);
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator["return"]) {
                                    _iterator["return"]();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    }

                    throw new Error("ShaderProgram.compile(): program " + this.id + " (" + this.name + ") error:", error);
                }

                this.use();
                this.refreshUniforms();
                this.refreshAttributes();
            }
        },
        buildDefineList: {

            // Make list of defines (global, then program-specific)

            value: function buildDefineList() {
                var d,
                    defines = {};
                for (d in ShaderProgram.defines) {
                    defines[d] = ShaderProgram.defines[d];
                }
                for (d in this.defines) {
                    defines[d] = this.defines[d];
                }
                return defines;
            }
        },
        buildShaderBlockList: {

            // Make list of shader blocks (global, then program-specific)

            value: function buildShaderBlockList() {
                var d,
                    blocks = {};
                for (d in ShaderProgram.blocks) {
                    blocks[d] = [];

                    if (Array.isArray(ShaderProgram.blocks[d])) {
                        var _blocks$d;

                        (_blocks$d = blocks[d]).push.apply(_blocks$d, _toConsumableArray(ShaderProgram.blocks[d]));
                    } else {
                        blocks[d] = [ShaderProgram.blocks[d]];
                    }
                }
                for (d in this.blocks) {
                    blocks[d] = blocks[d] || [];

                    if (Array.isArray(this.blocks[d])) {
                        var _blocks$d2;

                        (_blocks$d2 = blocks[d]).push.apply(_blocks$d2, _toConsumableArray(this.blocks[d]));
                    } else {
                        blocks[d].push(this.blocks[d]);
                    }
                }
                return blocks;
            }
        },
        ensureUniforms: {

            // Detect uniform definitions, inject any missing ones

            value: function ensureUniforms(uniforms) {
                if (!uniforms) {
                    return;
                }

                var vs = strip(this.computed_vertex_source);
                var fs = strip(this.computed_fragment_source);
                var inject,
                    vs_injections = [],
                    fs_injections = [];

                // Check for missing uniform definitions
                for (var name in uniforms) {
                    inject = null;

                    // Check vertex shader
                    if (!GLSL.isUniformDefined(name, vs) && GLSL.isSymbolReferenced(name, vs)) {
                        if (!inject) {
                            inject = GLSL.defineUniform(name, uniforms[name]);
                        }
                        log.trace("Program " + this.name + ": " + name + " not defined in vertex shader, injecting: '" + inject + "'");
                        vs_injections.push(inject);
                    }
                    // Check fragment shader
                    if (!GLSL.isUniformDefined(name, fs) && GLSL.isSymbolReferenced(name, fs)) {
                        if (!inject) {
                            inject = GLSL.defineUniform(name, uniforms[name]);
                        }
                        log.trace("Program " + this.name + ": " + name + " not defined in fragment shader, injecting: '" + inject + "'");
                        fs_injections.push(inject);
                    }
                }

                // Inject missing uniforms
                // NOTE: these are injected at the very top of the shaders, even before any #defines or #pragmas are added
                // this could cause some issues with certain #pragmas, or other functions that might expect #defines
                if (vs_injections.length > 0) {
                    this.computed_vertex_source = vs_injections.join("\n") + this.computed_vertex_source;
                }

                if (fs_injections.length > 0) {
                    this.computed_fragment_source = fs_injections.join("\n") + this.computed_fragment_source;
                }
            }
        },
        setUniforms: {

            // Set uniforms from a JS object, with inferred types

            value: function setUniforms(uniforms) {
                var reset_texture_unit = arguments[1] === undefined ? true : arguments[1];

                if (!this.compiled) {
                    return;
                }

                // TODO: only update uniforms when changed

                // Texture units must be tracked and incremented each time a texture sampler uniform is set.
                // By default, the texture unit is reset to 0 each time setUniforms is called, but they can
                // also be preserved, for example in cases where multiple calls to setUniforms are expected
                // (e.g. program-specific uniforms followed by mesh-specific ones).
                if (reset_texture_unit) {
                    this.texture_unit = 0;
                }

                // Parse uniform types and values from the JS object
                var parsed = GLSL.parseUniforms(uniforms);

                // Set each uniform
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = parsed[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var uniform = _step.value;

                        if (uniform.type === "sampler2D") {
                            // For textures, we need to track texture units, so we have a special setter
                            this.setTextureUniform(uniform.name, uniform.value);
                        } else {
                            this.uniform(uniform.method, uniform.name, uniform.value);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        saveUniforms: {

            // Cache some or all uniform values so they can be restored

            value: function saveUniforms(subset) {
                var uniforms = subset || this.uniforms;
                for (var u in uniforms) {
                    var uniform = this.uniforms[u];
                    if (uniform) {
                        uniform.saved_value = uniform.value;
                    }
                }
                this.saved_texture_unit = this.texture_unit || 0;
            }
        },
        restoreUniforms: {

            // Restore some or all uniforms to saved values

            value: function restoreUniforms(subset) {
                var uniforms = subset || this.uniforms;
                for (var u in uniforms) {
                    var uniform = this.uniforms[u];
                    if (uniform && uniform.saved_value) {
                        uniform.value = uniform.saved_value;
                        this.updateUniform(u);
                    }
                }
                this.texture_unit = this.saved_texture_unit || 0;
            }
        },
        setTextureUniform: {

            // Set a texture uniform, finds texture by name or creates a new one

            value: function setTextureUniform(uniform_name, texture_name) {
                var texture = Texture.textures[texture_name];
                if (texture == null) {
                    texture = new Texture(this.gl, texture_name);
                    texture.load(texture_name);
                }

                texture.bind(this.texture_unit);
                this.uniform("1i", uniform_name, this.texture_unit);
                this.texture_unit++; // TODO: track max texture units and log/throw errors
            }
        },
        uniform: {

            // ex: program.uniform('3f', 'position', x, y, z);
            // TODO: only update uniforms when changed

            value: function uniform(method, name) {
                for (var _len = arguments.length, value = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                    value[_key - 2] = arguments[_key];
                }

                // 'value' is a method-appropriate arguments list
                if (!this.compiled) {
                    return;
                }

                this.uniforms[name] = this.uniforms[name] || {};
                var uniform = this.uniforms[name];
                uniform.name = name;
                if (uniform.location === undefined) {
                    uniform.location = this.gl.getUniformLocation(this.program, name);
                }
                uniform.method = "uniform" + method;
                uniform.value = value;
                this.updateUniform(name);
            }
        },
        updateUniform: {

            // Set a single uniform

            value: function updateUniform(name) {
                if (!this.compiled) {
                    return;
                }

                var uniform = this.uniforms[name];
                if (!uniform || uniform.location == null) {
                    return;
                }

                this.use();
                this.gl[uniform.method].apply(this.gl, [uniform.location].concat(uniform.value)); // call appropriate GL uniform method and pass through arguments
            }
        },
        refreshUniforms: {

            // Refresh uniform locations and set to last cached values

            value: function refreshUniforms() {
                if (!this.compiled) {
                    return;
                }

                for (var u in this.uniforms) {
                    this.uniforms[u].location = this.gl.getUniformLocation(this.program, u);
                    this.updateUniform(u);
                }
            }
        },
        refreshAttributes: {
            value: function refreshAttributes() {
                // var len = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES);
                // for (var i=0; i < len; i++) {
                //     var a = this.gl.getActiveAttrib(this.program, i);
                // }
                this.attribs = {};
            }
        },
        attribute: {

            // Get the location of a vertex attribute

            value: function attribute(name) {
                if (!this.compiled) {
                    return;
                }

                var attrib = this.attribs[name] = this.attribs[name] || {};
                if (attrib.location != null) {
                    return attrib;
                }

                attrib.name = name;
                attrib.location = this.gl.getAttribLocation(this.program, name);

                // var info = this.gl.getActiveAttrib(this.program, attrib.location);
                // attrib.type = info.type;
                // attrib.size = info.size;

                return attrib;
            }
        },
        source: {

            // Get shader source as string

            value: function source(type) {
                if (type === "vertex") {
                    return this.computed_vertex_source;
                } else if (type === "fragment") {
                    return this.computed_fragment_source;
                }
            }
        },
        lines: {

            // Get shader source as array of line strings

            value: function lines(type) {
                var source = this.source(type);
                if (source) {
                    return source.split("\n");
                }
                return [];
            }
        },
        line: {

            // Get a specific line from shader source

            value: function line(type, num) {
                var source = this.lines(type);
                if (source) {
                    return source[num];
                }
            }
        },
        block: {

            // Get info on which shader block (if any) a particular line number in a shader is in
            // Returns an object with the following info if a block is found: { name, line, source }
            //  name: shader block name (e.g. 'color', 'position', 'global')
            //  line: line number *within* the shader block (not the whole shader program), useful for error highlighting
            //  source: the code for the line
            // NOTE: this does a bruteforce loop over the shader source and looks for shader block start/end markers
            // We could track line ranges for shader blocks as they are inserted, but as this code is only used for
            // error handling on compilation failure, it was simpler to keep it separate than to burden the core
            // compilation path.

            value: function block(type, num) {
                var lines = this.lines(type);
                var block = undefined;
                for (var i = 0; i < num && i < lines.length; i++) {
                    var line = lines[i];
                    var match = line.match(/\/\/ tangram-block-start: (\w+)/);
                    if (match && match.length > 1) {
                        block = { name: match[1] }; // mark current block
                    } else {
                        match = line.match(/\/\/ tangram-block-end: (\w+)/);
                        if (match && match.length > 1) {
                            block = null; // clear current block
                        }
                    }

                    // update line # and content
                    if (block) {
                        // init to -1 so that line 0 is first actual line of block code, after comment marker
                        block.line = block.line == null ? -1 : block.line + 1;
                        block.source = line;
                    }
                }
                return block;
            }
        },
        checkExtensions: {

            // Returns list of available extensions from those requested
            // Sets internal #defines indicating availability of each requested extension

            value: function checkExtensions() {
                var exts = [];
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = this.extensions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var _name = _step.value;

                        var ext = getExtension(this.gl, _name);
                        var def = "TANGRAM_EXTENSION_" + _name;

                        this.defines[def] = ext != null;

                        if (ext) {
                            exts.push(_name);
                        } else {
                            log.debug("Could not enable extension '" + _name + "'");
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return exts;
            }
        }
    });

    return ShaderProgram;
})();

module.exports = ShaderProgram;

// Static methods and state

ShaderProgram.id = 0; // assign each program a unique id
ShaderProgram.programs = {}; // programs, by id
ShaderProgram.current = null; // currently bound program

// Global config applied to all programs (duplicate properties for a specific program will take precedence)
ShaderProgram.defines = {};
ShaderProgram.blocks = {};

// Turn an object of key/value pairs into single string of #define statements
ShaderProgram.buildDefineString = function (defines) {
    var define_str = "";
    for (var d in defines) {
        if (defines[d] === false) {
            continue;
        } else if (typeof defines[d] === "boolean" && defines[d] === true) {
            // booleans are simple defines with no value
            define_str += "#define " + d + "\n";
        } else if (typeof defines[d] === "number" && Math.floor(defines[d]) === defines[d]) {
            // int to float conversion to satisfy GLSL floats
            define_str += "#define " + d + " " + defines[d].toFixed(1) + "\n";
        } else {
            // any other float or string value
            define_str += "#define " + d + " " + defines[d] + "\n";
        }
    }
    return define_str;
};

// Turn a list of extension names into single string of #extension statements
ShaderProgram.buildExtensionString = function (extensions) {
    extensions = extensions || [];
    var str = "";
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = extensions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var ext = _step.value;

            str += "#extension GL_" + ext + " : enable\n";
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return str;
};

ShaderProgram.addBlock = function (key) {
    var _ShaderProgram$blocks$key;

    for (var _len = arguments.length, blocks = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        blocks[_key - 1] = arguments[_key];
    }

    ShaderProgram.blocks[key] = ShaderProgram.blocks[key] || [];
    (_ShaderProgram$blocks$key = ShaderProgram.blocks[key]).push.apply(_ShaderProgram$blocks$key, blocks);
};

// Remove all global shader blocks for a given key
ShaderProgram.removeBlock = function (key) {
    ShaderProgram.blocks[key] = [];
};

ShaderProgram.replaceBlock = function (key) {
    for (var _len = arguments.length, blocks = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        blocks[_key - 1] = arguments[_key];
    }

    ShaderProgram.removeBlock(key);
    ShaderProgram.addBlock.apply(ShaderProgram, [key].concat(blocks));
};

// Compile & link a WebGL program from provided vertex and fragment shader sources
// update a program if one is passed in. Create one if not. Alert and don't update anything if the shaders don't compile.
ShaderProgram.updateProgram = function (gl, program, vertex_shader_source, fragment_shader_source) {
    try {
        var vertex_shader = ShaderProgram.createShader(gl, vertex_shader_source, gl.VERTEX_SHADER);
        var fragment_shader = ShaderProgram.createShader(gl, fragment_shader_source, gl.FRAGMENT_SHADER);
    } catch (err) {
        log.error(err.message);
        throw err;
    }

    gl.useProgram(null);
    if (program != null) {
        var old_shaders = gl.getAttachedShaders(program);
        for (var i = 0; i < old_shaders.length; i++) {
            gl.detachShader(program, old_shaders[i]);
        }
    } else {
        program = gl.createProgram();
    }

    if (vertex_shader == null || fragment_shader == null) {
        return program;
    }

    gl.attachShader(program, vertex_shader);
    gl.attachShader(program, fragment_shader);

    gl.deleteShader(vertex_shader);
    gl.deleteShader(fragment_shader);

    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        var message = new Error("WebGL program error:\n            VALIDATE_STATUS: " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n            ERROR: " + gl.getError() + "\n            --- Vertex Shader ---\n            " + vertex_shader_source + "\n            --- Fragment Shader ---\n            " + fragment_shader_source);

        var error = { type: "program", message: message };
        log.error(error.message);
        throw error;
    }

    return program;
};

// Compile a vertex or fragment shader from provided source
ShaderProgram.createShader = function (gl, source, stype) {
    var shader = gl.createShader(stype);

    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        var type = stype === gl.VERTEX_SHADER ? "vertex" : "fragment";
        var message = gl.getShaderInfoLog(shader);
        var errors = parseShaderErrors(message);
        throw { type: type, message: message, errors: errors };
    }

    return shader;
};

},{"./extensions":76,"./glsl":77,"./texture":81,"gl-shader-errors":28,"loglevel":60,"strip-comments":65}],80:[function(require,module,exports){
// Generated from GLSL files, don't edit!
"use strict";

var shaderSources = {};

shaderSources["gl/shaders/ambientLight"] = "/*\n" + "\n" + "Expected globals:\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "struct AmbientLight {\n" + "    vec4 ambient;\n" + "};\n" + "\n" + "void calculateLight(in AmbientLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "    light_accumulator_ambient += _light.ambient;\n" + "}\n" + "";

shaderSources["gl/shaders/directionalLight"] = "/*\n" + "\n" + "Expected globals:\n" + "material\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "struct DirectionalLight {\n" + "    vec4 ambient;\n" + "    vec4 diffuse;\n" + "    vec4 specular;\n" + "    vec3 direction;\n" + "};\n" + "\n" + "void calculateLight(in DirectionalLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "\n" + "    light_accumulator_ambient += _light.ambient;\n" + "\n" + "    float nDotVP = clamp(dot(_normal, -normalize(_light.direction)), 0.0, 1.0);\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        light_accumulator_diffuse += _light.diffuse * nDotVP;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        float pf = 0.0;\n" + "        if (nDotVP > 0.0) {\n" + "            vec3 reflectVector = reflect(normalize(_light.direction), _normal);\n" + "            float eyeDotR = max(dot(normalize(_eyeToPoint), reflectVector), 0.0);\n" + "            pf = pow(eyeDotR, material.shininess);\n" + "        }\n" + "        light_accumulator_specular += _light.specular * pf;\n" + "    #endif\n" + "}\n" + "";

shaderSources["gl/shaders/layer_order"] = "// Apply layer ordering to avoid z-fighting\n" + "void applyLayerOrder (float layer, inout vec4 position) {\n" + "    position.z -= layer * TANGRAM_LAYER_DELTA * position.w;\n" + "}\n" + "";

shaderSources["gl/shaders/material"] = "/*\n" + "\n" + "Defines globals:\n" + "material\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "\n" + "// MATERIALS\n" + "//\n" + "struct Material {\n" + "    #ifdef TANGRAM_MATERIAL_EMISSION\n" + "        vec4 emission;\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE\n" + "            vec3 emissionScale;\n" + "        #endif\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_AMBIENT\n" + "        vec4 ambient;\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE\n" + "            vec3 ambientScale;\n" + "        #endif\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        vec4 diffuse;\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE\n" + "            vec3 diffuseScale;\n" + "        #endif\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        vec4 specular;\n" + "        float shininess;\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE\n" + "            vec3 specularScale;\n" + "        #endif\n" + "    #endif\n" + "\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE\n" + "        vec3 normalScale;\n" + "        float normalAmount;\n" + "    #endif\n" + "};\n" + "\n" + "// Note: uniform is copied to a global instance to allow modification\n" + "uniform Material u_material;\n" + "Material material = u_material;\n" + "\n" + "#ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE\n" + "uniform sampler2D u_material_emission_texture;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE\n" + "uniform sampler2D u_material_ambient_texture;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE\n" + "uniform sampler2D u_material_diffuse_texture;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE\n" + "uniform sampler2D u_material_specular_texture;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE\n" + "uniform sampler2D u_material_normal_texture;\n" + "#endif\n" + "\n" + "// Global light accumulators for each property\n" + "vec4 light_accumulator_ambient = vec4(0.0);\n" + "vec4 light_accumulator_diffuse = vec4(0.0);\n" + "#ifdef TANGRAM_MATERIAL_SPECULAR\n" + "    vec4 light_accumulator_specular = vec4(0.0);\n" + "#endif\n" + "\n" + "\n" + "#ifdef TANGRAM_MATERIAL_TEXTURE_SPHEREMAP\n" + "vec4 getSphereMap (in sampler2D _tex, in vec3 _eyeToPoint, in vec3 _normal, in vec2 _skew) {\n" + "    vec3 eye = normalize(_eyeToPoint);\n" + "    eye.xy -= _skew;\n" + "    eye = normalize(eye);\n" + "\n" + "    vec3 r = reflect(eye, _normal);\n" + "    r.z += 1.0;\n" + "    float m = 2. * length(r);\n" + "    vec2 uv = r.xy / m + .5;\n" + "    return texture2D(_tex, uv);\n" + "}\n" + "#endif\n" + "\n" + "\n" + "#ifdef TANGRAM_MATERIAL_TEXTURE_TRIPLANAR\n" + "vec3 getTriPlanarBlend (in vec3 _normal) {\n" + "    vec3 blending = abs(_normal);\n" + "    blending = normalize(max(blending, 0.00001));\n" + "    float b = (blending.x + blending.y + blending.z);\n" + "    return blending / b;\n" + "}\n" + "\n" + "vec4 getTriPlanar (in sampler2D _tex, in vec3 _pos, in vec3 _normal, in vec3 _scale) {\n" + "    vec3 blending = getTriPlanarBlend(_normal);\n" + "    vec4 xaxis = texture2D(_tex, fract(_pos.yz * _scale.x));\n" + "    vec4 yaxis = texture2D(_tex, fract(_pos.xz * _scale.y));\n" + "    vec4 zaxis = texture2D(_tex, fract(_pos.xy * _scale.z));\n" + "    return  xaxis * blending.x + yaxis * blending.y + zaxis * blending.z;\n" + "}\n" + "#endif\n" + "\n" + "\n" + "#ifdef TANGRAM_MATERIAL_TEXTURE_PLANAR\n" + "vec4 getPlanar (in sampler2D _tex, in vec3 _pos, in vec2 _scale) {\n" + "    return texture2D( _tex, fract(_pos.xy * _scale.x) );\n" + "}\n" + "#endif\n" + "\n" + "\n" + "#ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE\n" + "void calculateNormal (inout vec3 _normal) {\n" + "    // Get NORMALMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE_UV\n" + "    _normal += texture2D(u_material_normal_texture, fract(v_texcoord*material.normalScale.xy)).rgb*2.0-1.0;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE_PLANAR\n" + "    vec3 normalTex = getPlanar(u_material_normal_texture, v_world_position.xyz, material.normalScale.xy).rgb*2.0-1.0;\n" + "    _normal += normalTex;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE_TRIPLANAR\n" + "    vec3 normalTex = getTriPlanar(u_material_normal_texture, v_world_position.xyz, _normal, material.normalScale).rgb*2.0-1.0;\n" + "    _normal += normalTex;\n" + "    #endif\n" + "\n" + "    _normal = normalize(_normal);\n" + "}\n" + "#endif\n" + "\n" + "void calculateMaterial (in vec3 _eyeToPoint, inout vec3 _normal) {\n" + "    // get EMISSION TEXTUREMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE_UV\n" + "        material.emission *= texture2D(u_material_emission_texture,v_texcoord);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE_PLANAR\n" + "        material.emission *= getPlanar(u_material_emission_texture, v_world_position.xyz, material.emissionScale.xy);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE_TRIPLANAR\n" + "        material.emission *= getTriPlanar(u_material_emission_texture, v_world_position.xyz, _normal, material.emissionScale);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE_SPHEREMAP\n" + "        material.emission *= getSphereMap(u_material_emission_texture, _eyeToPoint, _normal, u_vanishing_point);\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // get AMBIENT TEXTUREMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE_UV\n" + "        material.ambient *= texture2D(u_material_ambient_texture,v_texcoord);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE_PLANAR\n" + "        material.ambient *= getPlanar(u_material_ambient_texture, v_world_position.xyz, material.ambientScale.xy);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE_TRIPLANAR\n" + "        material.ambient *= getTriPlanar(u_material_ambient_texture, v_world_position.xyz, _normal, material.ambientScale);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE_SPHEREMAP\n" + "        material.ambient *= getSphereMap(u_material_ambient_texture, _eyeToPoint, _normal, u_vanishing_point);\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // get DIFFUSE TEXTUREMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE_UV\n" + "        material.diffuse *= texture2D(u_material_diffuse_texture,v_texcoord);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE_PLANAR\n" + "        material.diffuse *= getPlanar(u_material_diffuse_texture, v_world_position.xyz, material.diffuseScale.xy);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE_TRIPLANAR\n" + "        material.diffuse *= getTriPlanar(u_material_diffuse_texture, v_world_position.xyz, _normal, material.diffuseScale);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE_SPHEREMAP\n" + "        material.diffuse *= getSphereMap(u_material_diffuse_texture, _eyeToPoint, _normal, u_vanishing_point);\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // get SPECULAR TEXTUREMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE_UV\n" + "        material.specular *= texture2D(u_material_specular_texture,v_texcoord);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE_PLANAR\n" + "        material.specular *= getPlanar(u_material_specular_texture, v_world_position.xyz, material.specularScale.xy);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE_TRIPLANAR\n" + "        material.specular *= getTriPlanar(u_material_specular_texture, v_world_position.xyz, _normal, material.specularScale);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE_SPHEREMAP\n" + "        material.specular *= getSphereMap(u_material_specular_texture, _eyeToPoint, _normal, u_vanishing_point);\n" + "        #endif\n" + "    #endif\n" + "}\n" + "";

shaderSources["gl/shaders/pointLight"] = "/*\n" + "\n" + "Expected globals:\n" + "material\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "struct PointLight {\n" + "    vec4 ambient;\n" + "    vec4 diffuse;\n" + "    vec4 specular;\n" + "    vec4 position;\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "    float attenuationExponent;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "    float innerRadius;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "    float outerRadius;\n" + "#endif\n" + "};\n" + "\n" + "void calculateLight(in PointLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "\n" + "    float dist = length(_light.position.xyz - _eyeToPoint);\n" + "\n" + "    // Compute vector from surface to light position\n" + "    vec3 VP = (_light.position.xyz - _eyeToPoint) / dist;\n" + "\n" + "    // Normalize the vector from surface to light position\n" + "    float nDotVP = clamp(dot(VP, _normal), 0.0, 1.0);\n" + "\n" + "    // Attenuation defaults\n" + "    float attenuation = 1.0;\n" + "    #ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "        float Rin = 1.0;\n" + "        float e = _light.attenuationExponent;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "            float Rdiff = _light.outerRadius-Rin;\n" + "            float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "            attenuation = 1.0-(pow(d,e));\n" + "        #else\n" + "            // If no outer is provide behaves like:\n" + "            // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "            float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "            attenuation = clamp(1.0/(pow(d,e)), 0.0, 1.0);\n" + "        #endif\n" + "    #else\n" + "        float Rin = 0.0;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float Rdiff = _light.outerRadius-Rin;\n" + "                float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                // If no outer is provide behaves like:\n" + "                // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "                float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "                attenuation = clamp(1.0/d, 0.0, 1.0);\n" + "            #endif\n" + "        #else\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float d = clamp(dist/_light.outerRadius, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                attenuation = 1.0;\n" + "            #endif\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // Computer accumulators\n" + "    light_accumulator_ambient += _light.ambient * attenuation;\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        light_accumulator_diffuse += _light.diffuse * nDotVP * attenuation;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        float pf = 0.0; // power factor for shiny speculars\n" + "        if (nDotVP > 0.0) {\n" + "            vec3 reflectVector = reflect(-VP, _normal);\n" + "            float eyeDotR = max(0.0, dot(-normalize(_eyeToPoint), reflectVector));\n" + "            pf = pow(eyeDotR, material.shininess);\n" + "        }\n" + "\n" + "        light_accumulator_specular += _light.specular * pf * attenuation;\n" + "    #endif\n" + "}\n" + "";

shaderSources["gl/shaders/selection_fragment"] = "// Fragment shader for feature selection passes\n" + "// Renders in silhouette according to selection (picking) color, or black if none defined\n" + "\n" + "#ifdef TANGRAM_FEATURE_SELECTION\n" + "    varying vec4 v_selection_color;\n" + "#endif\n" + "\n" + "void main (void) {\n" + "    #ifdef TANGRAM_FEATURE_SELECTION\n" + "        gl_FragColor = v_selection_color;\n" + "    #else\n" + "        gl_FragColor = vec4(0., 0., 0., 1.);\n" + "    #endif\n" + "}\n" + "";

shaderSources["gl/shaders/selection_globals"] = "// Vertex attribute + varying for feature selection\n" + "#if defined(TANGRAM_FEATURE_SELECTION) && defined(TANGRAM_VERTEX_SHADER)\n" + "    attribute vec4 a_selection_color;\n" + "    varying vec4 v_selection_color;\n" + "#endif\n" + "";

shaderSources["gl/shaders/selection_vertex"] = "// Selection pass-specific rendering\n" + "#if defined(TANGRAM_FEATURE_SELECTION) && defined(TANGRAM_VERTEX_SHADER)\n" + "    if (a_selection_color.rgb == vec3(0.)) {\n" + "        // Discard by forcing invalid triangle if we're in the feature\n" + "        // selection pass but have no selection info\n" + "        // TODO: in some cases we may actually want non-selectable features to occlude selectable ones?\n" + "        gl_Position = vec4(0., 0., 0., 1.);\n" + "        return;\n" + "    }\n" + "    v_selection_color = a_selection_color;\n" + "#endif\n" + "";

shaderSources["gl/shaders/spherical_environment_map"] = "// Spherical environment map\n" + "// Based on: http://www.clicktorelease.com/blog/creating-spherical-environment-mapping-shader\n" + "\n" + "// view: location of camera\n" + "// position: location of current point on surface\n" + "// normal: normal of current point on surface\n" + "// skew: skewing factor (used to compensate for altered vanishing point)\n" + "// envmap: spherical environment map texture\n" + "\n" + "vec4 sphericalEnvironmentMap(vec3 view, vec3 position, vec3 normal, vec2 skew, sampler2D envmap) {\n" + "    // Normalized vector from camera to surface\n" + "    vec3 eye = normalize(position.xyz - view.xyz);\n" + "\n" + "    // Skew\n" + "    eye.xy -= skew;\n" + "    eye = normalize(eye);\n" + "\n" + "    // Reflection of eye off of surface normal\n" + "    vec3 r = reflect(eye, normal);\n" + "\n" + "    // Map reflected vector onto the surface of a sphere\n" + "    r.z += 1.;\n" + "    float m = 2. * length(r);\n" + "\n" + "    // Adjust xy to account for spherical shape, and center in middle of texture\n" + "    vec2 uv = r.xy / m + .5;\n" + "\n" + "    // Sample the environment map\n" + "    return texture2D(envmap, uv);\n" + "}\n" + "";

shaderSources["gl/shaders/spotLight"] = "/*\n" + "\n" + "Expected globals:\n" + "material\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "struct SpotLight {\n" + "    vec4 ambient;\n" + "    vec4 diffuse;\n" + "    vec4 specular;\n" + "    vec4 position;\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "    float attenuationExponent;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "    float innerRadius;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "    float outerRadius;\n" + "#endif\n" + "\n" + "    vec3 direction;\n" + "    float spotCosCutoff;\n" + "    float spotExponent;\n" + "};\n" + "\n" + "void calculateLight(in SpotLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "\n" + "    float dist = length(_light.position.xyz - _eyeToPoint);\n" + "\n" + "    // Compute vector from surface to light position\n" + "    vec3 VP = (_light.position.xyz - _eyeToPoint) / dist;\n" + "\n" + "    // normal . light direction\n" + "    float nDotVP = clamp(dot(_normal, VP), 0.0, 1.0);\n" + "\n" + "    // Attenuation defaults\n" + "    float attenuation = 1.0;\n" + "    #ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "        float Rin = 1.0;\n" + "        float e = _light.attenuationExponent;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "            float Rdiff = _light.outerRadius-Rin;\n" + "            float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "            attenuation = 1.0-(pow(d,e));\n" + "        #else\n" + "            // If no outer is provide behaves like:\n" + "            // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "            float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "            attenuation = clamp(1.0/(pow(d,e)), 0.0, 1.0);\n" + "        #endif\n" + "    #else\n" + "        float Rin = 0.0;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float Rdiff = _light.outerRadius-Rin;\n" + "                float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                // If no outer is provide behaves like:\n" + "                // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "                float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "                attenuation = clamp(1.0/d, 0.0, 1.0);\n" + "            #endif\n" + "        #else\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float d = clamp(dist/_light.outerRadius, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                attenuation = 1.0;\n" + "            #endif\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // spotlight attenuation factor\n" + "    float spotAttenuation = 0.0;\n" + "\n" + "    // See if point on surface is inside cone of illumination\n" + "    float spotDot = clamp(dot(-VP, normalize(_light.direction)), 0.0, 1.0);\n" + "\n" + "    if (spotDot >= _light.spotCosCutoff) {\n" + "        spotAttenuation = pow(spotDot, _light.spotExponent);\n" + "    }\n" + "\n" + "    light_accumulator_ambient += _light.ambient * attenuation * spotAttenuation;\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        light_accumulator_diffuse += _light.diffuse * nDotVP * attenuation * spotAttenuation;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        // Power factor for shiny speculars\n" + "        float pf = 0.0;\n" + "        if (nDotVP > 0.0) {\n" + "            vec3 reflectVector = reflect(-VP, _normal);\n" + "            float eyeDotR = max(dot(-normalize(_eyeToPoint), reflectVector), 0.0);\n" + "            pf = pow(eyeDotR, material.shininess);\n" + "        }\n" + "        light_accumulator_specular += _light.specular * pf * attenuation * spotAttenuation;\n" + "    #endif\n" + "}\n" + "";

shaderSources["gl/shaders/world_position_wrap"] = "// Define a wrap value for world coordinates (allows more precision at higher zooms)\n" + "// e.g. at wrap 1000, the world space will wrap every 1000 meters\n" + "#if defined(TANGRAM_WORLD_POSITION_WRAP)\n" + "    vec2 world_position_anchor = vec2(floor(u_tile_origin / TANGRAM_WORLD_POSITION_WRAP) * TANGRAM_WORLD_POSITION_WRAP);\n" + "\n" + "    // Convert back to absolute world position if needed\n" + "    vec4 absoluteWorldPosition () {\n" + "        return vec4(v_world_position.xy + world_position_anchor, v_world_position.z, v_world_position.w);\n" + "    }\n" + "#else\n" + "    vec4 absoluteWorldPosition () {\n" + "        return v_world_position;\n" + "    }\n" + "#endif\n" + "";

shaderSources["styles/points/points_fragment"] = "uniform vec2 u_resolution;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_device_pixel_ratio;\n" + "uniform float u_time;\n" + "uniform vec3 u_map_position;\n" + "uniform vec3 u_tile_origin;\n" + "\n" + "uniform sampler2D u_texture;\n" + "\n" + "varying vec4 v_color;\n" + "varying vec2 v_texcoord;\n" + "varying vec4 v_world_position;\n" + "\n" + "// Alpha discard threshold (substitute for alpha blending)\n" + "#ifndef TANGRAM_ALPHA_DISCARD\n" + "#define TANGRAM_ALPHA_DISCARD 0.5\n" + "#endif\n" + "\n" + "// Alpha fade range for edges of points\n" + "#ifndef TANGRAM_FADE_RANGE\n" + "#define TANGRAM_FADE_RANGE .15\n" + "#endif\n" + "#define TANGRAM_FADE_START (1. - TANGRAM_FADE_RANGE)\n" + "\n" + "#pragma tangram: global\n" + "\n" + "void main (void) {\n" + "    vec4 color = v_color;\n" + "\n" + "    // Apply a texture\n" + "    #ifdef TANGRAM_POINT_TEXTURE\n" + "        color *= texture2D(u_texture, v_texcoord);\n" + "    // Draw a point\n" + "    #else\n" + "        // Fade alpha near circle edge\n" + "        vec2 uv = v_texcoord * 2. - 1.;\n" + "        float point_dist = length(uv);\n" + "        color.a = clamp(1. - (smoothstep(0., TANGRAM_FADE_RANGE, (point_dist - TANGRAM_FADE_START)) / TANGRAM_FADE_RANGE), 0., 1.);\n" + "    #endif\n" + "\n" + "    // If blending is off, use alpha discard as a lower-quality substitute\n" + "    #ifndef TANGRAM_BLEND_OVERLAY\n" + "        if (color.a < TANGRAM_ALPHA_DISCARD) {\n" + "            discard;\n" + "        }\n" + "    #endif\n" + "\n" + "    // Manually un-multiply alpha, for cases where texture has pre-multiplied alpha\n" + "    #ifdef TANGRAM_UNMULTIPLY_ALPHA\n" + "        color.rgb /= max(color.a, 0.001);\n" + "    #endif\n" + "\n" + "    #pragma tangram: color\n" + "    #pragma tangram: filter\n" + "\n" + "    gl_FragColor = color;\n" + "}\n" + "";

shaderSources["styles/points/points_vertex"] = "uniform vec2 u_resolution;\n" + "uniform float u_time;\n" + "uniform vec3 u_map_position;\n" + "uniform vec3 u_tile_origin;\n" + "uniform float u_meters_per_pixel;\n" + "\n" + "uniform mat4 u_model;\n" + "uniform mat4 u_modelView;\n" + "\n" + "attribute vec4 a_position;\n" + "attribute vec4 a_shape;\n" + "attribute vec4 a_color;\n" + "attribute vec2 a_texcoord;\n" + "\n" + "varying vec4 v_color;\n" + "varying vec2 v_texcoord;\n" + "varying vec4 v_world_position;\n" + "\n" + "#pragma tangram: camera\n" + "#pragma tangram: global\n" + "\n" + "vec2 rotate2D(vec2 _st, float _angle) {\n" + "    return mat2(cos(_angle),-sin(_angle),\n" + "                sin(_angle),cos(_angle)) * _st;\n" + "}\n" + "\n" + "void main() {\n" + "    // Adds vertex shader support for feature selection\n" + "    #pragma tangram: feature-selection-vertex\n" + "\n" + "    v_color = a_color;\n" + "    v_texcoord = a_texcoord;\n" + "\n" + "    // Apply scaling in screen space\n" + "    vec4 shape = a_shape;\n" + "    float zscale = fract(u_map_position.z) * (shape.w * 256. - 1.) + 1.;\n" + "    // float zscale = log(fract(u_map_position.z) + 1.) / log(2.) * (shape.w - 1.) + 1.;\n" + "    vec2 shape_offset = shape.xy * 256. * zscale;\n" + "\n" + "    // Position\n" + "    vec4 position = u_modelView * vec4(a_position.xyz * 32767., 1.);\n" + "\n" + "    // World coordinates for 3d procedural textures\n" + "    v_world_position = u_model * position;\n" + "    v_world_position.xy += shape_offset * u_meters_per_pixel;\n" + "    #if defined(TANGRAM_WORLD_POSITION_WRAP)\n" + "        v_world_position.xy -= world_position_anchor;\n" + "    #endif\n" + "\n" + "    // Modify position before camera projection\n" + "    #pragma tangram: position\n" + "\n" + "    cameraProjection(position);\n" + "\n" + "    #ifdef TANGRAM_LAYER_ORDER\n" + "        applyLayerOrder(a_position.w * 32767., position);\n" + "    #endif\n" + "\n" + "    position.xy += rotate2D(shape_offset, radians(shape.z * 360.)) * 2. * position.w / u_resolution;\n" + "\n" + "    gl_Position = position;\n" + "}\n" + "";

shaderSources["styles/polygons/polygons_fragment"] = "uniform vec2 u_resolution;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_device_pixel_ratio;\n" + "uniform float u_time;\n" + "uniform vec3 u_map_position;\n" + "uniform vec3 u_tile_origin;\n" + "\n" + "varying vec4 v_position;\n" + "varying vec3 v_normal;\n" + "varying vec4 v_color;\n" + "varying vec4 v_world_position;\n" + "\n" + "#ifdef TANGRAM_TEXTURE_COORDS\n" + "    varying vec2 v_texcoord;\n" + "#endif\n" + "\n" + "#if defined(TANGRAM_LIGHTING_VERTEX)\n" + "    varying vec4 v_lighting;\n" + "#endif\n" + "\n" + "#pragma tangram: camera\n" + "#pragma tangram: material\n" + "#pragma tangram: lighting\n" + "#pragma tangram: global\n" + "\n" + "void main (void) {\n" + "    vec4 color = v_color;\n" + "    vec3 normal = v_normal;\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE\n" + "        calculateNormal(normal);\n" + "    #endif\n" + "\n" + "    // Modify normal before lighting\n" + "    #pragma tangram: normal\n" + "\n" + "    // Modify color and material properties before lighting\n" + "    #if !defined(TANGRAM_LIGHTING_VERTEX)\n" + "    #pragma tangram: color\n" + "    #endif\n" + "\n" + "    #if defined(TANGRAM_LIGHTING_FRAGMENT)\n" + "        color = calculateLighting(v_position.xyz - u_eye, normal, color);\n" + "    #elif defined(TANGRAM_LIGHTING_VERTEX)\n" + "        color = v_lighting;\n" + "    #endif\n" + "\n" + "    // Modify color after lighting (filter-like effects that don't require a additional render passes)\n" + "    #pragma tangram: filter\n" + "\n" + "    gl_FragColor = color;\n" + "}\n" + "";

shaderSources["styles/polygons/polygons_vertex"] = "uniform vec2 u_resolution;\n" + "uniform float u_time;\n" + "uniform vec3 u_map_position;\n" + "uniform vec3 u_tile_origin;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_device_pixel_ratio;\n" + "\n" + "uniform mat4 u_model;\n" + "uniform mat4 u_modelView;\n" + "uniform mat3 u_normalMatrix;\n" + "\n" + "attribute vec4 a_position;\n" + "attribute vec4 a_color;\n" + "\n" + "// Optional normal attribute, otherwise default to up\n" + "#ifdef TANGRAM_NORMAL_ATTRIBUTE\n" + "    attribute vec3 a_normal;\n" + "    #define TANGRAM_NORMAL a_normal\n" + "#else\n" + "    #define TANGRAM_NORMAL vec3(0., 0., 1.)\n" + "#endif\n" + "\n" + "// Optional dynamic line extrusion\n" + "#ifdef TANGRAM_EXTRUDE_LINES\n" + "    // xy: extrusion direction in xy plane\n" + "    // z:  half-width of line (amount to extrude)\n" + "    // w:  scaling factor for interpolating width between zooms\n" + "    attribute vec4 a_extrude;\n" + "#endif\n" + "\n" + "varying vec4 v_position;\n" + "varying vec3 v_normal;\n" + "varying vec4 v_color;\n" + "varying vec4 v_world_position;\n" + "\n" + "// Optional texture UVs\n" + "#ifdef TANGRAM_TEXTURE_COORDS\n" + "    attribute vec2 a_texcoord;\n" + "    varying vec2 v_texcoord;\n" + "#endif\n" + "\n" + "#if defined(TANGRAM_LIGHTING_VERTEX)\n" + "    varying vec4 v_lighting;\n" + "#endif\n" + "\n" + "#pragma tangram: camera\n" + "#pragma tangram: material\n" + "#pragma tangram: lighting\n" + "#pragma tangram: global\n" + "\n" + "void main() {\n" + "    // Adds vertex shader support for feature selection\n" + "    #pragma tangram: feature-selection-vertex\n" + "\n" + "    // Texture UVs\n" + "    #ifdef TANGRAM_TEXTURE_COORDS\n" + "        v_texcoord = a_texcoord;\n" + "    #endif\n" + "\n" + "    // Position\n" + "    vec4 position = vec4(a_position.xyz * 32767., 1.);\n" + "\n" + "    #ifdef TANGRAM_EXTRUDE_LINES\n" + "        vec2 extrude = a_extrude.xy * 255.;\n" + "        float width = a_extrude.z * 32767.;\n" + "        float scale = a_extrude.w * 255.;\n" + "\n" + "        // Keep line width constant in screen-space\n" + "        float zscale = u_tile_origin.z - u_map_position.z;\n" + "        width *= pow(2., zscale);\n" + "\n" + "        // Smoothly interpolate line width between zooms\n" + "        width = mix(width, width * scale, -zscale);\n" + "\n" + "        // Modify line width before extrusion\n" + "        #pragma tangram: width\n" + "\n" + "        position.xy += extrude * width;\n" + "    #endif\n" + "\n" + "    // World coordinates for 3d procedural textures\n" + "    v_world_position = u_model * position;\n" + "    #if defined(TANGRAM_WORLD_POSITION_WRAP)\n" + "        v_world_position.xy -= world_position_anchor;\n" + "    #endif\n" + "\n" + "    // Adjust for tile and view position\n" + "    position = u_modelView * position;\n" + "\n" + "    // Modify position before camera projection\n" + "    #pragma tangram: position\n" + "\n" + "    // Setup varyings\n" + "    v_position = position;\n" + "    v_normal = normalize(u_normalMatrix * TANGRAM_NORMAL);\n" + "    v_color = a_color;\n" + "\n" + "    // Vertex lighting\n" + "    #if defined(TANGRAM_LIGHTING_VERTEX)\n" + "        vec4 color = a_color;\n" + "        vec3 normal = TANGRAM_NORMAL;\n" + "\n" + "        // Modify normal before lighting\n" + "        #pragma tangram: normal\n" + "\n" + "        // Modify color and material properties before lighting\n" + "        #pragma tangram: color\n" + "\n" + "        v_lighting = calculateLighting(position.xyz, normal, color);\n" + "        v_color = color;\n" + "    #endif\n" + "\n" + "    // Camera\n" + "    cameraProjection(position);\n" + "    applyLayerOrder(a_position.w * 32767., position);\n" + "\n" + "    gl_Position = position;\n" + "}\n" + "";

module.exports = shaderSources;

},{}],81:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Texture */
// Texture management

var Utils = _interopRequire(require("../utils/utils"));

var subscribeMixin = _interopRequire(require("../utils/subscribe"));

var WorkerBroker = _interopRequire(require("../utils/worker_broker"));

var Builders = _interopRequire(require("../styles/builders"));

var log = _interopRequire(require("loglevel"));

// GL texture wrapper object for keeping track of a global set of textures, keyed by a unique user-defined name

var Texture = (function () {
    function Texture(gl, name) {
        var options = arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, Texture);

        this.gl = gl;
        this.texture = gl.createTexture();
        if (this.texture) {
            this.valid = true;
        }
        this.bind();
        this.image = null; // an Image object/element that is the source for this texture
        this.canvas = null; // a Canvas object/element that is the source for this texture
        this.loading = null; // a Promise object to track the loading state of this texture

        // Default to a 1-pixel black texture so we can safely render while we wait for an image to load
        // See: http://stackoverflow.com/questions/19722247/webgl-wait-for-texture-to-load
        this.setData(1, 1, new Uint8Array([0, 0, 0, 255]), { filtering: "nearest" });

        // TODO: better support for non-URL sources: canvas/video elements, raw pixel buffers

        this.name = name;
        this.filtering = options.filtering;

        // Destroy previous texture if present
        if (Texture.textures[this.name]) {
            Texture.textures[this.name].destroy();
        }

        Texture.textures[this.name] = this;

        this.sprites = options.sprites;
        this.texcoords = {};
    }

    _createClass(Texture, {
        destroy: {

            // Destroy a single texture instance

            value: function destroy() {
                if (!this.valid) {
                    return;
                }
                this.gl.deleteTexture(this.texture);
                this.texture = null;
                delete this.data;
                this.data = null;
                delete Texture.textures[this.name];
                this.valid = false;
            }
        },
        bind: {
            value: function bind(unit) {
                if (!this.valid) {
                    return;
                }
                if (typeof unit === "number") {
                    if (Texture.activeUnit !== unit) {
                        this.gl.activeTexture(this.gl.TEXTURE0 + unit);
                        Texture.activeUnit = unit;
                    }
                }
                if (Texture.activeTexture !== this.texture) {
                    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
                    Texture.activeTexture = this.texture;
                }
            }
        },
        load: {

            // Loads a texture from a URL

            value: function load(url) {
                var _this = this;

                var options = arguments[1] === undefined ? {} : arguments[1];

                if (!this.valid) {
                    return;
                }

                if (Texture.base_url) {
                    url = Utils.addBaseURL(url, Texture.base_url);
                }

                this.loading = new Promise(function (resolve, reject) {
                    _this.image = new Image();
                    _this.image.onload = function () {
                        try {
                            _this.update(options);
                            _this.setTextureFiltering(options);
                            _this.calculateSprites();

                            _this.canvas = null; // mutually exclusive with other types
                            _this.data = null;
                        } catch (e) {
                            log.warn("Texture: failed to load url: '" + url + "'", e, options);
                            Texture.trigger("warning", { message: "Failed to load texture from " + url, error: e, texture: options });
                        }

                        resolve(_this);
                    };
                    _this.image.onerror = function (e) {
                        // Warn and resolve on error
                        log.warn("Texture: failed to load url: '" + url + "'", e, options);
                        Texture.trigger("warning", { message: "Failed to load texture from " + url, error: e, texture: options });
                        resolve(_this);
                    };
                    _this.image.crossOrigin = "anonymous";
                    _this.image.src = url;
                });
                return this.loading;
            }
        },
        setData: {

            // Sets texture to a raw image buffer

            value: function setData(width, height, data) {
                var options = arguments[3] === undefined ? {} : arguments[3];

                this.width = width;
                this.height = height;
                this.data = data;

                this.image = null; // mutually exclusive with other types
                this.canvas = null;

                this.update(options);
                this.setTextureFiltering(options);
            }
        },
        setCanvas: {

            // Sets the texture to track a canvas element

            value: function setCanvas(canvas, options) {
                this.canvas = canvas;
                this.update(options);
                this.setTextureFiltering(options);

                this.image = null; // mutually exclusive with other types
                this.data = null;
            }
        },
        update: {

            // Uploads current image or buffer to the GPU (can be used to update animated textures on the fly)

            value: function update() {
                var options = arguments[0] === undefined ? {} : arguments[0];

                if (!this.valid) {
                    return;
                }

                this.bind();
                this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, options.UNPACK_FLIP_Y_WEBGL === false ? false : true);
                this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.UNPACK_PREMULTIPLY_ALPHA_WEBGL || false);

                // Image element
                if (this.image && this.image.complete) {
                    this.width = this.image.width;
                    this.height = this.image.height;
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.image);
                }
                // Canvas element
                else if (this.canvas) {
                    this.width = this.canvas.width;
                    this.height = this.canvas.height;
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.canvas);
                }
                // Raw image buffer
                else if (this.width && this.height) {
                    // NOTE: this.data can be null, to zero out texture
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.width, this.height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.data);
                }

                Texture.trigger("update", this);
            }
        },
        setTextureFiltering: {

            // Determines appropriate filtering mode

            value: function setTextureFiltering() {
                var options = arguments[0] === undefined ? {} : arguments[0];

                if (!this.valid) {
                    return;
                }

                options.filtering = options.filtering || this.filtering || "linear";

                var gl = this.gl;
                this.bind();

                // For power-of-2 textures, the following presets are available:
                // mipmap: linear blend from nearest mip
                // linear: linear blend from original image (no mips)
                // nearest: nearest pixel from original image (no mips, 'blocky' look)
                if (Utils.isPowerOf2(this.width) && Utils.isPowerOf2(this.height)) {
                    this.power_of_2 = true;
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.TEXTURE_WRAP_S || options.repeat && gl.REPEAT || gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.TEXTURE_WRAP_T || options.repeat && gl.REPEAT || gl.CLAMP_TO_EDGE);

                    // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.TEXTURE_WRAP_S || gl.REPEAT);
                    // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.TEXTURE_WRAP_T || gl.REPEAT);

                    if (options.filtering === "mipmap") {
                        log.trace("power-of-2 MIPMAP");
                        this.filtering = "mipmap";
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR); // TODO: use trilinear filtering by defualt instead?
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } else if (options.filtering === "linear") {
                        log.trace("power-of-2 LINEAR");
                        this.filtering = "linear";
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    } else if (options.filtering === "nearest") {
                        log.trace("power-of-2 NEAREST");
                        this.filtering = "nearest";
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    }
                } else {
                    // WebGL has strict requirements on non-power-of-2 textures:
                    // No mipmaps and must clamp to edge
                    this.power_of_2 = false;
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                    if (options.filtering === "nearest") {
                        log.trace("power-of-2 NEAREST");
                        this.filtering = "nearest";
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    } else {
                        // default to linear for non-power-of-2 textures
                        log.trace("power-of-2 LINEAR");
                        this.filtering = "linear";
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    }
                }

                Texture.trigger("update", this);
            }
        },
        calculateSprites: {

            // Pre-calc sprite regions for a texture sprite in UV [0, 1] space

            value: function calculateSprites() {
                if (this.sprites) {
                    for (var s in this.sprites) {
                        var sprite = this.sprites[s];

                        // Map [0, 0] to [1, 1] coords to the appropriate sprite sub-area of the texture
                        this.texcoords[s] = Builders.getTexcoordsForSprite([sprite[0], sprite[1]], [sprite[2], sprite[3]], [this.width, this.height]);
                    }
                }
            }
        }
    });

    return Texture;
})();

module.exports = Texture;

// Static/class methods and state

// Destroy all texture instances for a given GL context
Texture.destroy = function (gl) {
    var textures = Object.keys(Texture.textures);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = textures[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var t = _step.value;

            var texture = Texture.textures[t];
            if (texture.gl === gl) {
                log.trace("destroying Texture " + texture.name);
                texture.destroy();
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
};

// Get sprite sub-area to use for texture coordinates (default is [0, 1])
Texture.getSpriteTexcoords = function (texname, sprite) {
    var texture = Texture.textures[texname];
    return texture && texture.texcoords[sprite];
};

// Create a set of textures keyed in an object
// Optionally load each if it has a URL specified
Texture.createFromObject = function (gl, textures) {
    var loading = [];
    if (textures) {
        for (var texname in textures) {
            var config = textures[texname];
            var texture = new Texture(gl, texname, config);
            if (config.url) {
                loading.push(texture.load(config.url, config));
            }
        }
    }
    return Promise.all(loading);
};

// Get metadata for a texture by name
// Returns via promise, in case texture is still loading
// Can be called on main thread from worker, to sync texture info to worker
Texture.getInfo = function (name) {
    // Get info for all textures by default
    if (!name) {
        name = Object.keys(Texture.textures);
    }

    // Get multiple textures
    if (Array.isArray(name)) {
        return Promise.all(name.map(function (n) {
            return Texture.getInfo(n);
        }));
    }

    // Get single texture
    var tex = Texture.textures[name];
    if (tex) {
        // Wait for this texture to finish loading, or return immediately
        var loading = tex.loading || Promise.resolve(tex);
        return loading.then(function () {
            // Return a subset of texture info
            // (compatible w/structured cloning, suitable for passing to a worker)
            return {
                name: tex.name,
                width: tex.width,
                height: tex.height,
                sprites: tex.sprites,
                texcoords: tex.texcoords,
                filtering: tex.filtering,
                power_of_2: tex.power_of_2,
                valid: tex.valid
            };
        });
    } else {
        // No texture found
        return Promise.resolve(null);
    }
};

// Sync texture info to worker
// Called from worker, gets info on one or more textures info from main thread via remote call, then stores it
// locally in worker. 'textures' can be an array of texture names to sync, or if null, all textures are synced.
Texture.syncTexturesToWorker = function (names) {
    return WorkerBroker.postMessage("Texture", "getInfo", names).then(function (textures) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = textures[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var tex = _step.value;

                Texture.textures[tex.name] = tex;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        return Texture.textures;
    });
};

// Global set of textures, by name
Texture.textures = {};
Texture.boundTexture = -1;
Texture.activeUnit = -1;

Texture.base_url = null; // optional base URL to add to textures

subscribeMixin(Texture);

},{"../styles/builders":97,"../utils/subscribe":114,"../utils/utils":115,"../utils/worker_broker":117,"loglevel":60}],82:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

// Creates a Vertex Array Object if the extension is available, or falls back on standard attribute calls

var log = _interopRequire(require("loglevel"));

var VertexArrayObject;
module.exports = VertexArrayObject = {};

VertexArrayObject.disabled = false; // set to true to disable VAOs even if extension is available
VertexArrayObject.bound_vao = null; // currently bound VAO

VertexArrayObject.init = function (gl) {
    if (VertexArrayObject.ext == null) {
        if (VertexArrayObject.disabled !== true) {
            VertexArrayObject.ext = gl.getExtension("OES_vertex_array_object");
        }

        if (VertexArrayObject.ext != null) {
            log.info("Vertex Array Object extension available");
        } else if (VertexArrayObject.disabled !== true) {
            log.warn("Vertex Array Object extension NOT available");
        } else {
            log.warn("Vertex Array Object extension force disabled");
        }
    }
};

VertexArrayObject.create = function (setup, teardown) {
    var vao = {};
    vao.setup = setup;
    vao.teardown = teardown;

    var ext = VertexArrayObject.ext;
    if (ext != null) {
        vao._vao = ext.createVertexArrayOES();
        ext.bindVertexArrayOES(vao._vao);
    }

    vao.setup(true);

    return vao;
};

VertexArrayObject.bind = function (vao) {
    var ext = VertexArrayObject.ext;
    if (vao != null) {
        if (ext != null && vao._vao != null) {
            ext.bindVertexArrayOES(vao._vao);
            VertexArrayObject.bound_vao = vao;
        } else {
            vao.setup(false);
        }
    } else {
        if (ext != null) {
            ext.bindVertexArrayOES(null);
        } else if (VertexArrayObject.bound_vao != null && typeof VertexArrayObject.bound_vao.teardown === "function") {
            VertexArrayObject.bound_vao.teardown();
        }
        VertexArrayObject.bound_vao = null;
    }
};

},{"loglevel":60}],83:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/* global VBOMesh */
// Manage rendering for primitives

var GLSL = _interopRequire(require("./glsl"));

var ShaderProgram = _interopRequire(require("./shader_program"));

var Texture = _interopRequire(require("./texture"));

var VertexArrayObject = _interopRequire(require("./vao"));

var log = _interopRequire(require("loglevel"));

// A single mesh/VBO, described by a vertex layout, that can be drawn with one or more programs

var VBOMesh = (function () {
    function VBOMesh(gl, vertex_data, vertex_layout, options) {
        _classCallCheck(this, VBOMesh);

        options = options || {};

        this.gl = gl;
        this.vertex_data = vertex_data; // typed array
        this.vertex_layout = vertex_layout;
        this.buffer = this.gl.createBuffer();
        this.draw_mode = options.draw_mode || this.gl.TRIANGLES;
        this.data_usage = options.data_usage || this.gl.STATIC_DRAW;
        this.vertices_per_geometry = 3; // TODO: support lines, strip, fan, etc.
        this.uniforms = options.uniforms;
        this.retain = options.retain || false; // whether to retain mesh data in CPU after uploading to GPU

        this.vertex_count = this.vertex_data.byteLength / this.vertex_layout.stride;
        this.geometry_count = this.vertex_count / this.vertices_per_geometry;
        this.vaos = new Map(); // map of VertexArrayObjects, keyed by program

        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vertex_data, this.data_usage);

        if (!this.retain) {
            delete this.vertex_data;
        }
        this.valid = true;
    }

    _createClass(VBOMesh, {
        render: {

            // Render, by default with currently bound program, or otherwise with optionally provided one

            value: function render() {
                var options = arguments[0] === undefined ? {} : arguments[0];

                if (!this.valid) {
                    return false;
                }

                if (typeof this._render_setup === "function") {
                    this._render_setup();
                }

                var program = options.program || ShaderProgram.current;
                program.use();

                if (this.uniforms) {
                    program.saveUniforms(this.uniforms);
                    program.setUniforms(this.uniforms, false); // don't reset texture unit
                }

                this.bind(program);

                // TODO: support element array mode
                this.gl.drawArrays(this.draw_mode, 0, this.vertex_count);
                VertexArrayObject.bind(null);

                if (this.uniforms) {
                    program.restoreUniforms(this.uniforms);
                }

                return true;
            }
        },
        bind: {

            // Bind buffers and vertex attributes to prepare for rendering

            value: function bind(program) {
                var _this = this;

                // Bind VAO for this progam, or create one
                var vao = this.vaos.get(program);
                if (vao) {
                    VertexArrayObject.bind(vao);
                } else {
                    this.vaos.set(program, VertexArrayObject.create(function (force) {
                        _this.gl.bindBuffer(_this.gl.ARRAY_BUFFER, _this.buffer);
                        _this.vertex_layout.enable(_this.gl, program, force);
                    }));
                }
            }
        },
        destroy: {
            value: function destroy() {
                if (!this.valid) {
                    return false;
                }
                this.valid = false;

                log.trace("VBOMesh.destroy: delete buffer" + (this.vertex_data ? " of size " + this.vertex_data.byteLength : ""));

                this.gl.deleteBuffer(this.buffer);
                this.buffer = null;
                delete this.vertex_data;

                // Free texture uniforms that are owned by this mesh
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = GLSL.parseUniforms(this.uniforms)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var _step$value = _step.value;
                        var type = _step$value.type;
                        var value = _step$value.value;

                        if (type === "sampler2D" && Texture.textures[value]) {
                            Texture.textures[value].destroy();
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return true;
            }
        }
    });

    return VBOMesh;
})();

module.exports = VBOMesh;

},{"./glsl":77,"./shader_program":79,"./texture":81,"./vao":82,"loglevel":60}],84:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var _defineProperty = function (obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/* global VertexData */

var gl = _interopRequire(require("./constants"));

// web workers don't have access to GL context, so import all GL constants

var log = require("../utils/utils").log;

// Maps GL types to JS array types
var array_types = (function () {
    var _array_types = {};

    _defineProperty(_array_types, gl.FLOAT, Float32Array);

    _defineProperty(_array_types, gl.BYTE, Int8Array);

    _defineProperty(_array_types, gl.UNSIGNED_BYTE, Uint8Array);

    _defineProperty(_array_types, gl.INT, Int32Array);

    _defineProperty(_array_types, gl.UNSIGNED_INT, Uint32Array);

    _defineProperty(_array_types, gl.SHORT, Int16Array);

    _defineProperty(_array_types, gl.UNSIGNED_SHORT, Uint16Array);

    return _array_types;
})();

// An intermediary object that holds vertex data in typed arrays, according to a given vertex layout
// Used to construct a mesh/VBO for rendering

var VertexData = (function () {
    function VertexData(vertex_layout) {
        var _ref = arguments[1] === undefined ? {} : arguments[1];

        var prealloc = _ref.prealloc;

        _classCallCheck(this, VertexData);

        this.vertex_layout = vertex_layout;

        if (VertexData.array_pool.length > 0) {
            this.buffer = VertexData.array_pool.pop();
            this.buffer_length = this.buffer.byteLength;
            this.buffer_size = Math.floor(this.buffer_length / this.vertex_layout.stride);
            log("trace", "VertexData: reused buffer of bytes " + this.buffer_length + ", " + this.buffer_size + " vertices");
        } else {
            this.buffer_size = prealloc || 500; // # of vertices to allocate
            this.buffer_length = this.vertex_layout.stride * this.buffer_size;
            this.buffer = new Uint8Array(this.buffer_length);
        }
        this.buffer_offset = 0; // byte offset into currently allocated buffer

        this.components = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = this.vertex_layout.components[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var component = _step.value;

                this.components.push([].concat(_toConsumableArray(component)));
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        this.vertex_count = 0;
        this.realloc_count = 0;
        this.setBufferViews();
    }

    _createClass(VertexData, {
        setBufferViews: {

            // (Re-)allocate typed views into the main buffer - only create the types we need for this layout

            value: function setBufferViews() {
                this.buffer_views = {};
                this.buffer_views[gl.UNSIGNED_BYTE] = this.buffer;
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = this.vertex_layout.attribs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var attrib = _step.value;

                        // Need view for this type?
                        if (this.buffer_views[attrib.type] == null) {
                            var array_type = array_types[attrib.type];
                            this.buffer_views[attrib.type] = new array_type(this.buffer.buffer);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                // Update component buffer pointers
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = this.components[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var component = _step2.value;

                        component[1] = this.buffer_views[component[0]];
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                            _iterator2["return"]();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
            }
        },
        checkBufferSize: {

            // Check allocated buffer size, expand/realloc buffer if needed

            value: function checkBufferSize() {
                if (this.buffer_offset + this.vertex_layout.stride > this.buffer_length) {
                    this.buffer_size = Math.floor(this.buffer_size * 1.5);
                    this.buffer_size -= this.buffer_size % 4;
                    this.buffer_length = this.vertex_layout.stride * this.buffer_size;
                    var new_view = new Uint8Array(this.buffer_length);
                    new_view.set(this.buffer); // copy existing data to new buffer
                    VertexData.array_pool.push(this.buffer); // save previous buffer for use by next tile
                    this.buffer = new_view;
                    this.setBufferViews();
                    this.realloc_count++;
                    // log.info(`VertexData: expanded vertex block to ${this.buffer_size} vertices`);
                }
            }
        },
        addVertex: {

            // Add a vertex, copied from a plain JS array of elements matching the order of the vertex layout.
            // Note: uses pre-calculated info about each attribute, including pointer to appropriate typed array
            // view and offset into it. This was the fastest method profiled so far for filling a mixed-type
            // vertex layout (though still slower than the previous method that only supported Float32Array attributes).

            value: function addVertex(vertex) {
                this.checkBufferSize();
                var i = 0;

                var clen = this.components.length;
                for (var c = 0; c < clen; c++) {
                    var component = this.components[c];
                    component[1][(this.buffer_offset >> component[2]) + component[3]] = vertex[i++];
                }

                this.buffer_offset += this.vertex_layout.stride;
                this.vertex_count++;
            }
        },
        end: {

            // Finalize vertex buffer for use in constructing a mesh

            value: function end() {
                // Clip the buffer to size used for this VBO
                this.buffer = this.buffer.subarray(0, this.buffer_offset);
                log("trace", "VertexData: " + this.buffer_size + " vertices total, realloc count " + this.realloc_count);
                return this;
            }
        }
    });

    return VertexData;
})();

module.exports = VertexData;

VertexData.array_pool = []; // pool of currently available (previously used) buffers (uint8)

},{"../utils/utils":115,"./constants":74}],85:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/* global VertexLayout */

var gl = _interopRequire(require("./constants"));

// web workers don't have access to GL context, so import all GL constants

var VertexData = _interopRequire(require("./vertex_data"));

// Describes a vertex layout that can be used with many different GL programs.

var VertexLayout = (function () {
    // Attribs are an array, in layout order, of: name, size, type, normalized
    // ex: { name: 'position', size: 3, type: gl.FLOAT, normalized: false }

    function VertexLayout(attribs) {
        _classCallCheck(this, VertexLayout);

        this.attribs = attribs; // dictionary of attributes, specified as standard GL attrib options
        this.components = []; // list of type and offset info about each attribute component
        this.index = {}; // linear buffer index of each attribute component, e.g. this.index.position.x

        // Calc vertex stride
        this.stride = 0;

        var count = 0;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = this.attribs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var attrib = _step.value;

                attrib.offset = this.stride;
                attrib.byte_size = attrib.size;
                var shift = 0;

                switch (attrib.type) {
                    case gl.FLOAT:
                    case gl.INT:
                    case gl.UNSIGNED_INT:
                        attrib.byte_size *= 4;
                        shift = 2;
                        break;
                    case gl.SHORT:
                    case gl.UNSIGNED_SHORT:
                        attrib.byte_size *= 2;
                        shift = 1;
                        break;
                }

                // Force 4-byte alignment on attributes
                this.stride += attrib.byte_size;
                if (this.stride & 3) {
                    // pad to multiple of 4 bytes
                    this.stride += 4 - (this.stride & 3);
                }

                // Add info to list of attribute components
                // Used to build the vertex data, provides pointers and offsets into each typed array view
                // Each component is an array of:
                // [GL attrib type, pointer to typed array view, bits to shift right to determine buffer offset, additional buffer offset for the component]
                var offset_typed = attrib.offset >> shift;
                if (attrib.size > 1) {
                    for (var a = 0; a < attrib.size; a++) {
                        this.components.push([attrib.type, null, shift, offset_typed++]);
                    }
                } else {
                    this.components.push([attrib.type, null, shift, offset_typed]);
                }

                // Provide an index into the vertex data buffer for each attribute component
                this.index[attrib.name] = count;
                count += attrib.size;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }

    _createClass(VertexLayout, {
        enable: {

            // Setup a vertex layout for a specific GL program
            // Assumes that the desired vertex buffer (VBO) is already bound
            // If a given program doesn't include all attributes, it can still use the vertex layout
            // to read those attribs that it does recognize, using the attrib offsets to skip others.

            value: function enable(gl, program, force) {
                var attrib, location;

                // Enable all attributes for this layout
                for (var a = 0; a < this.attribs.length; a++) {
                    attrib = this.attribs[a];
                    location = program.attribute(attrib.name).location;

                    if (location !== -1) {
                        if (!VertexLayout.enabled_attribs[location] || force) {
                            gl.enableVertexAttribArray(location);
                        }
                        gl.vertexAttribPointer(location, attrib.size, attrib.type, attrib.normalized, this.stride, attrib.offset);
                        VertexLayout.enabled_attribs[location] = program;
                    }
                }

                // Disable any previously bound attributes that aren't for this layout
                for (location in VertexLayout.enabled_attribs) {
                    this.disableUnusedAttribute(gl, location, program);
                }
            }
        },
        disableUnusedAttribute: {

            // Disable an attribute if it was not enabled for the specified program
            // NOTE: this was moved out of the inner loop in enable() to assist w/VM optimization

            value: function disableUnusedAttribute(gl, location, program) {
                if (VertexLayout.enabled_attribs[location] !== program) {
                    gl.disableVertexAttribArray(location);
                    delete VertexLayout.enabled_attribs[location];
                }
            }
        },
        createVertexData: {
            value: function createVertexData() {
                return new VertexData(this);
            }
        }
    });

    return VertexLayout;
})();

module.exports = VertexLayout;

// Track currently enabled attribs, by the program they are bound to
// Static class property to reflect global GL state
VertexLayout.enabled_attribs = {};

},{"./constants":74,"./vertex_data":84}],86:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

exports.leafletLayer = leafletLayer;
Object.defineProperty(exports, "__esModule", {
    value: true
});

var Utils = _interopRequire(require("./utils/utils"));

var Scene = _interopRequire(require("./scene"));

// Exports must appear outside a function, but will only be defined in main thread (below)
var LeafletLayer;
exports.LeafletLayer = LeafletLayer;

function leafletLayer(options) {
    return new LeafletLayer(options);
}

// Leaflet layer functionality is only defined in main thread
if (Utils.isMainThread) {
    (function () {

        // Determine if we are extending the leaflet 0.7.x TileLayer class, or the newer
        // leaflet 1.x GridLayer class.
        var layerBaseClass = L.GridLayer ? L.GridLayer : L.TileLayer;
        var leafletVersion = layerBaseClass === L.GridLayer ? "1.x" : "0.7.x";
        var layerClassConfig = {};

        // If extending leaflet 0.7.x TileLayer, make add/remove tile no ops
        if (layerBaseClass === L.TileLayer) {
            layerClassConfig._addTile = function () {};
            layerClassConfig._removeTile = function () {};
        }

        // Define custom layer methods
        Object.assign(layerClassConfig, {

            initialize: function initialize(options) {
                // Defaults
                options.showDebug = !options.showDebug ? false : true;

                L.setOptions(this, options);
                this.createScene();
                this.hooks = {};
                this._updating_tangram = false;

                // Force leaflet zoom animations off
                this._zoomAnimated = false;
            },

            createScene: function createScene() {
                this.scene = Scene.create(this.options.scene, {
                    numWorkers: this.options.numWorkers,
                    preUpdate: this.options.preUpdate,
                    postUpdate: this.options.postUpdate,
                    continuousZoom: LeafletLayer.leafletVersion === "1.x",
                    highDensityDisplay: this.options.highDensityDisplay,
                    logLevel: this.options.logLevel,
                    // advanced option, app will have to manually called scene.update() per frame
                    disableRenderLoop: this.options.disableRenderLoop,
                    // advanced option, will require library to be served as same host as page
                    allowCrossDomainWorkers: this.options.allowCrossDomainWorkers
                });
            },

            // Finish initializing scene and setup events when layer is added to map
            onAdd: function onAdd(map) {
                var _this = this;

                if (!this.scene) {
                    this.createScene();
                }

                layerBaseClass.prototype.onAdd.apply(this, arguments);

                this.hooks.resize = function () {
                    _this._updating_tangram = true;
                    var size = map.getSize();
                    _this.scene.resizeMap(size.x, size.y);
                    _this._updating_tangram = false;
                };
                map.on("resize", this.hooks.resize);

                this.hooks.move = function () {
                    if (_this._updating_tangram) {
                        return;
                    }

                    _this._updating_tangram = true;
                    var view = map.getCenter();
                    view.zoom = map.getZoom();

                    _this.scene.setView(view);
                    _this.scene.immediateRedraw();
                    _this._updating_tangram = false;
                };
                map.on("move", this.hooks.move);

                this.hooks.zoomstart = function () {
                    if (_this._updating_tangram) {
                        return;
                    }

                    _this._updating_tangram = true;
                    _this.scene.startZoom();
                    _this._updating_tangram = false;
                };
                map.on("zoomstart", this.hooks.zoomstart);

                this.hooks.dragstart = function () {
                    _this.scene.panning = true;
                };
                map.on("dragstart", this.hooks.dragstart);

                this.hooks.dragend = function () {
                    _this.scene.panning = false;
                };
                map.on("dragend", this.hooks.dragend);

                // Force leaflet zoom animations off
                map._zoomAnimated = false;

                // Modify default leaflet scroll wheel behavior
                this.modifyScrollWheelBehavior(map);

                // Canvas element will be inserted after map container (leaflet transforms shouldn't be applied to the GL canvas)
                // TODO: find a better way to deal with this? right now GL map only renders correctly as the bottom layer
                this.scene.container = map.getContainer();

                // Initial view
                var view = map.getCenter();
                view.zoom = map.getZoom();
                this.scene.setView(view);

                // Subscribe to tangram events
                this.scene.subscribe({
                    move: this.onTangramViewUpdate.bind(this)
                });

                // Use leaflet's existing event system as the callback mechanism
                this.scene.load().then(function () {
                    _this.fire("init");
                })["catch"](function (error) {
                    _this.fire("error", error);
                });
            },

            onRemove: function onRemove(map) {
                layerBaseClass.prototype.onRemove.apply(this, arguments);

                map.off("resize", this.hooks.resize);
                map.off("move", this.hooks.move);
                map.off("zoomstart", this.hooks.zoomstart);
                map.off("dragstart", this.hooks.dragstart);
                map.off("dragend", this.hooks.dragend);
                this.hooks = {};

                if (this.scene) {
                    this.scene.destroy();
                    this.scene = null;
                }
            },

            createTile: function createTile(coords) {
                var key = coords.x + "/" + coords.y + "/" + coords.z;
                var div = document.createElement("div");
                div.setAttribute("data-tile-key", key);
                div.style.width = "256px";
                div.style.height = "256px";

                if (this.options.showDebug) {
                    var debug_overlay = document.createElement("div");
                    debug_overlay.textContent = key;
                    debug_overlay.style.position = "absolute";
                    debug_overlay.style.left = 0;
                    debug_overlay.style.top = 0;
                    debug_overlay.style.color = "white";
                    debug_overlay.style.fontSize = "16px";
                    debug_overlay.style.textOutline = "1px #000000";
                    debug_overlay.style.padding = "8px";

                    div.appendChild(debug_overlay);
                    div.style.borderStyle = "solid";
                    div.style.borderColor = "white";
                    div.style.borderWidth = "1px";
                }

                return div;
            },

            // Modify leaflet's default scroll wheel behavior to have a much more sensitve/continuous zoom
            // Note: this should be deprecated once leaflet continuous zoom is more widely used and the
            // default behavior is presumably improved
            modifyScrollWheelBehavior: function modifyScrollWheelBehavior(map) {
                if (this.scene.continuous_zoom && map.scrollWheelZoom && this.options.modifyScrollWheel !== false) {
                    map.scrollWheelZoom._performZoom = function () {
                        var map = this._map,
                            delta = this._delta,
                            zoom = map.getZoom();

                        map.stop(); // stop panning and fly animations if any

                        // NOTE: this is the only real modification to default leaflet behavior
                        delta /= 40;

                        delta = Math.max(Math.min(delta, 4), -4);
                        delta = map._limitZoom(zoom + delta) - zoom;

                        this._delta = 0;
                        this._startTime = null;

                        if (!delta) {
                            return;
                        }

                        if (map.options.scrollWheelZoom === "center") {
                            map.setZoom(zoom + delta);
                        } else {
                            map.setZoomAround(this._lastMousePos, zoom + delta);
                        }
                        return false;
                    };
                }
            },

            onTangramViewUpdate: function onTangramViewUpdate() {
                if (!this._map || this._updating_tangram) {
                    return;
                }
                this._updating_tangram = true;
                this._map.setView([this.scene.center.lat, this.scene.center.lng], this.scene.zoom, { animate: false });
                this._updating_tangram = false;
            },

            render: function render() {
                if (!this.scene) {
                    return;
                }
                this.scene.update();
            }

        });

        // Create the layer class
        LeafletLayer = exports.LeafletLayer = layerBaseClass.extend(layerClassConfig);

        // Polyfill some 1.0 methods
        if (typeof LeafletLayer.remove !== "function") {
            LeafletLayer.prototype.remove = function () {
                if (this._map) {
                    this._map.removeLayer(this);
                }
                this.fire("remove");
            };
        }

        LeafletLayer.layerBaseClass = layerBaseClass;
        LeafletLayer.leafletVersion = leafletVersion;
    })();
}

},{"./scene":90,"./utils/utils":115}],87:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Light */

var ShaderProgram = _interopRequire(require("./gl/shader_program"));

var shaderSources = _interopRequire(require("./gl/shader_sources"));

// built-in shaders

var GLSL = _interopRequire(require("./gl/glsl"));

var Geo = _interopRequire(require("./geo"));

var StyleParser = require("./styles/style_parser").StyleParser;

// Abstract light

var Light = (function () {
    function Light(scene, config) {
        _classCallCheck(this, Light);

        this.name = config.name;
        this.scene = scene;

        if (config.ambient == null || typeof config.ambient === "number") {
            this.ambient = GLSL.expandVec4(config.ambient || 0);
        } else {
            this.ambient = StyleParser.parseColor(config.ambient);
        }

        if (config.diffuse == null || typeof config.diffuse === "number") {
            this.diffuse = GLSL.expandVec4(config.diffuse != null ? config.diffuse : 1);
        } else {
            this.diffuse = StyleParser.parseColor(config.diffuse);
        }

        if (config.specular == null || typeof config.specular === "number") {
            this.specular = GLSL.expandVec4(config.specular || 0);
        } else {
            this.specular = StyleParser.parseColor(config.specular);
        }
    }

    _createClass(Light, {
        inject: {

            // Common instance definition

            value: function inject() {
                var instance = "\n            uniform " + this.struct_name + " u_" + this.name + ";\n            " + this.struct_name + " " + this.name + " = u_" + this.name + ";\n";

                ShaderProgram.addBlock(Light.block, instance);
            }
        },
        update: {

            // Update method called once per frame

            value: function update() {}
        },
        setupProgram: {

            // Called once per frame per program (e.g. for main render pass, then for each additional
            // pass for feature selection, etc.)

            value: function setupProgram(_program) {
                //  Three common light properties
                _program.uniform("4fv", "u_" + this.name + ".ambient", this.ambient);
                _program.uniform("4fv", "u_" + this.name + ".diffuse", this.diffuse);
                _program.uniform("4fv", "u_" + this.name + ".specular", this.specular);
            }
        }
    }, {
        create: {

            // Create a light by type name, factory-style
            // 'config' must include 'name' and 'type', along with any other type-specific properties

            value: function create(scene, config) {
                if (Light.types[config.type]) {
                    return new Light.types[config.type](scene, config);
                }
            }
        },
        setMode: {

            // Set light for a style: fragment lighting, vertex lighting, or none

            value: function setMode(mode, style) {
                if (mode === true) {
                    mode = "fragment";
                }
                mode = Light.enabled && (mode != null ? mode : "fragment"); // default to fragment lighting
                style.defines.TANGRAM_LIGHTING_FRAGMENT = mode === "fragment";
                style.defines.TANGRAM_LIGHTING_VERTEX = mode === "vertex";
            }
        },
        inject: {

            // Inject all provided light definitions, and calculate cumulative light function

            value: function inject(lights) {
                // Clear previous injections
                ShaderProgram.removeBlock(Light.block);

                // If lighting is globally disabled, nothing is injected (mostly for debugging or live editing)
                if (!Light.enabled) {
                    return;
                }

                // Construct code to calculate each light instance
                var calculateLights = "";
                if (lights && Object.keys(lights).length > 0) {
                    // Collect uniques types of lights
                    var types = {};
                    for (var light_name in lights) {
                        types[lights[light_name].type] = true;
                    }

                    // Inject each type of light
                    for (var type in types) {
                        Light.types[type].inject();
                    }

                    // Inject per-instance blocks and construct the list of functions to calculate each light
                    for (var light_name in lights) {
                        // Define instance
                        lights[light_name].inject();

                        // Add the calculation function to the list
                        calculateLights += "calculateLight(" + light_name + ", _eyeToPoint, _normal);\n";
                    }
                } else {
                    // If no light is defined, use 100% omnidirectional diffuse light
                    calculateLights = "\n                #ifdef TANGRAM_MATERIAL_DIFFUSE\n                    light_accumulator_diffuse = vec4(1.);\n                #endif\n            ";
                }

                // Glue together the final lighting function that sums all the lights
                var calculateFunction = "\n            vec4 calculateLighting(in vec3 _eyeToPoint, in vec3 _normal, in vec4 _color) {\n\n                // Do initial material calculations over normal, emission, ambient, diffuse and specular values\n                calculateMaterial(_eyeToPoint,_normal);\n\n                // Un roll the loop of individual ligths to calculate\n                " + calculateLights + "\n\n                //  Final light intensity calculation\n                vec4 color = vec4(0.0);\n\n                #ifdef TANGRAM_MATERIAL_EMISSION\n                    color = material.emission;\n                #endif\n\n                #ifdef TANGRAM_MATERIAL_AMBIENT\n                    color += light_accumulator_ambient * _color * material.ambient;\n                #else\n                    #ifdef TANGRAM_MATERIAL_DIFFUSE\n                        color += light_accumulator_ambient * _color * material.diffuse;\n                    #endif\n                #endif\n\n                #ifdef TANGRAM_MATERIAL_DIFFUSE\n                    color += light_accumulator_diffuse * _color * material.diffuse;\n                #endif\n\n                #ifdef TANGRAM_MATERIAL_SPECULAR\n                    color += light_accumulator_specular * material.specular;\n                #endif\n\n                // Clamp final color\n                color = clamp(color, 0.0, 1.0);\n\n                return color;\n            }";

                ShaderProgram.addBlock(Light.block, calculateFunction);
            }
        }
    });

    return Light;
})();

module.exports = Light;

Light.types = {}; // references to subclasses by short name
Light.block = "lighting"; // shader block name
Light.enabled = true; // lighting can be globally enabled/disabled

// Light subclasses

var AmbientLight = (function (_Light) {
    function AmbientLight(scene, config) {
        _classCallCheck(this, AmbientLight);

        _get(Object.getPrototypeOf(AmbientLight.prototype), "constructor", this).call(this, scene, config);
        this.type = "ambient";
        this.struct_name = "AmbientLight";
    }

    _inherits(AmbientLight, _Light);

    _createClass(AmbientLight, {
        setupProgram: {
            value: function setupProgram(_program) {
                _program.uniform("4fv", "u_" + this.name + ".ambient", this.ambient);
            }
        }
    }, {
        inject: {

            // Inject struct and calculate function

            value: function inject() {
                ShaderProgram.addBlock(Light.block, shaderSources["gl/shaders/ambientLight"]);
            }
        }
    });

    return AmbientLight;
})(Light);

Light.types.ambient = AmbientLight;

var DirectionalLight = (function (_Light2) {
    function DirectionalLight(scene, config) {
        _classCallCheck(this, DirectionalLight);

        _get(Object.getPrototypeOf(DirectionalLight.prototype), "constructor", this).call(this, scene, config);
        this.type = "directional";
        this.struct_name = "DirectionalLight";

        this.direction = (config.direction || [0.2, 0.7, -0.5]).map(parseFloat); // [x, y, z]
    }

    _inherits(DirectionalLight, _Light2);

    _createClass(DirectionalLight, {
        setupProgram: {
            value: function setupProgram(_program) {
                _get(Object.getPrototypeOf(DirectionalLight.prototype), "setupProgram", this).call(this, _program);
                _program.uniform("3fv", "u_" + this.name + ".direction", this.direction);
            }
        }
    }, {
        inject: {

            // Inject struct and calculate function

            value: function inject() {
                ShaderProgram.addBlock(Light.block, shaderSources["gl/shaders/directionalLight"]);
            }
        }
    });

    return DirectionalLight;
})(Light);

Light.types.directional = DirectionalLight;

var PointLight = (function (_Light3) {
    function PointLight(scene, config) {
        _classCallCheck(this, PointLight);

        _get(Object.getPrototypeOf(PointLight.prototype), "constructor", this).call(this, scene, config);
        this.type = "point";
        this.struct_name = "PointLight";

        this.position = config.position || [0, 0, 0];
        this.position_eye = []; // position in eyespace
        this.origin = config.origin || "world";
        this.attenuation = !isNaN(parseFloat(config.attenuation)) ? parseFloat(config.attenuation) : 0;

        if (config.radius) {
            if (Array.isArray(config.radius) && config.radius.length === 2) {
                this.radius = config.radius;
            } else {
                this.radius = [null, config.radius];
            }
        } else {
            this.radius = null;
        }
    }

    _inherits(PointLight, _Light3);

    _createClass(PointLight, {
        inject: {

            // Inject isntance-specific settings

            value: function inject() {
                _get(Object.getPrototypeOf(PointLight.prototype), "inject", this).call(this);

                ShaderProgram.defines.TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT = this.attenuation !== 0;
                ShaderProgram.defines.TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS = this.radius != null && this.radius[0] != null;
                ShaderProgram.defines.TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS = this.radius != null;
            }
        },
        update: {
            value: function update() {
                this.updateEyePosition();
            }
        },
        updateEyePosition: {
            value: function updateEyePosition() {
                if (this.origin === "world") {
                    // For world origin, format is: [longitude, latitude, meters (default) or pixels w/px units]

                    // Move light's world position into camera space

                    var _Geo$latLngToMeters = Geo.latLngToMeters(this.position);

                    var _Geo$latLngToMeters2 = _slicedToArray(_Geo$latLngToMeters, 2);

                    var x = _Geo$latLngToMeters2[0];
                    var y = _Geo$latLngToMeters2[1];

                    this.position_eye[0] = x - this.scene.camera.position_meters[0];
                    this.position_eye[1] = y - this.scene.camera.position_meters[1];

                    this.position_eye[2] = StyleParser.convertUnits(this.position[2], { zoom: this.scene.zoom });
                    this.position_eye[2] = this.position_eye[2] - this.scene.camera.position_meters[2];
                }
                if (this.origin === "ground" || this.origin === "camera") {
                    // For camera or ground origin, format is: [x, y, z] in meters (default) or pixels w/px units

                    // Light is in camera space by default
                    this.position_eye = StyleParser.convertUnits(this.position, { zoom: this.scene.zoom });

                    if (this.origin === "ground") {
                        // Leave light's xy in camera space, but z needs to be moved relative to ground plane
                        this.position_eye[2] = this.position_eye[2] - this.scene.camera.position_meters[2];
                    }
                }
            }
        },
        setupProgram: {
            value: function setupProgram(_program) {
                _get(Object.getPrototypeOf(PointLight.prototype), "setupProgram", this).call(this, _program);

                _program.uniform("4f", "u_" + this.name + ".position", this.position_eye[0], this.position_eye[1], this.position_eye[2], 1);

                if (ShaderProgram.defines.TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT) {
                    _program.uniform("1f", "u_" + this.name + ".attenuationExponent", this.attenuation);
                }

                if (ShaderProgram.defines.TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS) {
                    _program.uniform("1f", "u_" + this.name + ".innerRadius", StyleParser.convertUnits(this.radius[0], { zoom: this.scene.zoom }));
                }

                if (ShaderProgram.defines.TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS) {
                    _program.uniform("1f", "u_" + this.name + ".outerRadius", StyleParser.convertUnits(this.radius[1], { zoom: this.scene.zoom }));
                }
            }
        }
    }, {
        inject: {

            // Inject struct and calculate function

            value: function inject() {
                ShaderProgram.addBlock(Light.block, shaderSources["gl/shaders/pointLight"]);
            }
        }
    });

    return PointLight;
})(Light);

Light.types.point = PointLight;

var SpotLight = (function (_PointLight) {
    function SpotLight(scene, config) {
        _classCallCheck(this, SpotLight);

        _get(Object.getPrototypeOf(SpotLight.prototype), "constructor", this).call(this, scene, config);
        this.type = "spotlight";
        this.struct_name = "SpotLight";

        this.direction = (config.direction || [0, 0, -1]).map(parseFloat); // [x, y, z]
        this.exponent = config.exponent ? parseFloat(config.exponent) : 0.2;
        this.angle = config.angle ? parseFloat(config.angle) : 20;
    }

    _inherits(SpotLight, _PointLight);

    _createClass(SpotLight, {
        setupProgram: {
            value: function setupProgram(_program) {
                _get(Object.getPrototypeOf(SpotLight.prototype), "setupProgram", this).call(this, _program);

                _program.uniform("3fv", "u_" + this.name + ".direction", this.direction);
                _program.uniform("1f", "u_" + this.name + ".spotCosCutoff", Math.cos(this.angle * 3.14159 / 180));
                _program.uniform("1f", "u_" + this.name + ".spotExponent", this.exponent);
            }
        }
    }, {
        inject: {

            // Inject struct and calculate function

            value: function inject() {
                ShaderProgram.addBlock(Light.block, shaderSources["gl/shaders/spotLight"]);
            }
        }
    });

    return SpotLight;
})(PointLight);

Light.types.spotlight = SpotLight;

},{"./geo":73,"./gl/glsl":77,"./gl/shader_program":79,"./gl/shader_sources":80,"./styles/style_parser":104}],88:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Material */

var shaderSources = _interopRequire(require("./gl/shader_sources"));

// built-in shaders

var GLSL = _interopRequire(require("./gl/glsl"));

var StyleParser = require("./styles/style_parser").StyleParser;

var Material = (function () {
    function Material(config) {
        _classCallCheck(this, Material);

        config = config || {};

        // These properties all have the same defaults, so they can be set in bulk
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = ["emission", "ambient", "diffuse", "specular"][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var prop = _step.value;

                if (config[prop] != null) {
                    if (config[prop].texture) {
                        this[prop] = {
                            texture: config[prop].texture,
                            mapping: config[prop].mapping || "spheremap",
                            scale: GLSL.expandVec3(config[prop].scale != null ? config[prop].scale : 1),
                            amount: GLSL.expandVec4(config[prop].amount != null ? config[prop].amount : 1)
                        };
                    } else if (typeof config[prop] === "number") {
                        this[prop] = { amount: GLSL.expandVec4(config[prop]) };
                    } else if (typeof config[prop] === "string") {
                        this[prop] = { amount: StyleParser.parseColor(config[prop]) };
                    } else {
                        this[prop] = config[prop];
                    }
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        // Extra specular props
        if (this.specular) {
            this.specular.shininess = config.shininess ? parseFloat(config.shininess) : 0.2;
        }

        // Normal mapping
        if (config.normal != null) {
            this.normal = {
                texture: config.normal.texture,
                mapping: config.normal.mapping || "triplanar",
                scale: GLSL.expandVec3(config.normal.scale != null ? config.normal.scale : 1),
                amount: config.normal.amount != null ? config.normal.amount : 1
            };
        }
    }

    _createClass(Material, {
        inject: {
            value: function inject(style) {
                // For each property, sets defines to configure texture mapping, with a pattern like:
                //   TANGRAM_MATERIAL_DIFFUSE, TANGRAM_MATERIAL_DIFFUSE_TEXTURE, TANGRAM_MATERIAL_DIFFUSE_TEXTURE_SPHEREMAP
                // Also sets flags to keep track of each unique mapping type being used, e.g.:
                //   TANGRAM_MATERIAL_TEXTURE_SPHEREMAP
                // Enables texture coordinates if needed and not already on
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = ["emission", "ambient", "diffuse", "specular"][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var prop = _step.value;

                        var def = "TANGRAM_MATERIAL_" + prop.toUpperCase();
                        var texdef = def + "_TEXTURE";
                        style.defines[def] = this[prop] != null;
                        if (this[prop] && this[prop].texture) {
                            style.defines[texdef] = true;
                            style.defines[texdef + "_" + this[prop].mapping.toUpperCase()] = true;
                            style.defines["TANGRAM_MATERIAL_TEXTURE_" + this[prop].mapping.toUpperCase()] = true;
                            style.texcoords = style.texcoords || this[prop].mapping === "uv";
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                // Normal mapping
                // As anove, sets flags to keep track of each unique mapping type being used, e.g.:
                //   TANGRAM_MATERIAL_TEXTURE_SPHEREMAP
                if (this.normal && this.normal.texture) {
                    style.defines.TANGRAM_MATERIAL_NORMAL_TEXTURE = true;
                    style.defines["TANGRAM_MATERIAL_NORMAL_TEXTURE_" + this.normal.mapping.toUpperCase()] = true;
                    style.defines["TANGRAM_MATERIAL_TEXTURE_" + this.normal.mapping.toUpperCase()] = true;
                    style.texcoords = style.texcoords || this.normal.mapping === "uv";
                }

                style.replaceShaderBlock(Material.block, shaderSources["gl/shaders/material"]);
            }
        },
        setupProgram: {
            value: function setupProgram(_program) {
                // For each property, sets uniforms in the pattern:
                // u_material.diffuse, u_material.diffuseScale u_material_diffuse_texture
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = ["emission", "ambient", "diffuse", "specular"][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var prop = _step.value;

                        if (this[prop]) {
                            if (this[prop].texture) {
                                _program.setTextureUniform("u_material_" + prop + "_texture", this[prop].texture);
                                _program.uniform("3fv", "u_material." + prop + "Scale", this[prop].scale);
                                _program.uniform("4fv", "u_material." + prop, this[prop].amount);
                            } else if (this[prop].amount) {
                                _program.uniform("4fv", "u_material." + prop, this[prop].amount);
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                // Extra specular props
                if (this.specular) {
                    _program.uniform("1f", "u_material.shininess", this.specular.shininess);
                }

                // Normal mapping
                if (this.normal && this.normal.texture) {
                    _program.setTextureUniform("u_material_normal_texture", this.normal.texture);
                    _program.uniform("3fv", "u_material.normalScale", this.normal.scale);
                    _program.uniform("1f", "u_material.normalAmount", this.normal.amount);
                }
            }
        }
    }, {
        isValid: {

            // Determine if a material config block has sufficient properties to create a material

            value: function isValid(config) {
                if (config == null) {
                    return false;
                }

                if (config.emission == null && config.ambient == null && config.diffuse == null && config.specular == null) {
                    return false;
                }

                return true;
            }
        }
    });

    return Material;
})();

module.exports = Material;

Material.block = "material";

},{"./gl/glsl":77,"./gl/shader_sources":80,"./styles/style_parser":104}],89:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

/*jshint worker: true*/

// Modules and dependencies to expose in the public Tangram module

var Utils = _interopRequire(require("./utils/utils"));

// The leaflet layer plugin is currently the primary public API

var _leaflet_layer = require("./leaflet_layer");

var LeafletLayer = _leaflet_layer.LeafletLayer;
var leafletLayer = _leaflet_layer.leafletLayer;

// The scene worker is only activated when a worker thread is instantiated, but must always be loaded

var SceneWorker = require("../src/scene_worker").SceneWorker;

// Additional modules are exposed for debugging

var version = _interopRequire(require("./utils/version"));

var log = _interopRequire(require("loglevel"));

var Geo = _interopRequire(require("./geo"));

var DataSource = _interopRequire(require("./sources/data_source"));

require("./sources/geojson");

require("./sources/topojson");

require("./sources/mvt");

var TileManager = _interopRequire(require("./tile_manager"));

var GLSL = _interopRequire(require("./gl/glsl"));

var ShaderProgram = _interopRequire(require("./gl/shader_program"));

var VertexData = _interopRequire(require("./gl/vertex_data"));

var Texture = _interopRequire(require("./gl/texture"));

var Material = _interopRequire(require("./material"));

var Light = _interopRequire(require("./light"));

var WorkerBroker = _interopRequire(require("./utils/worker_broker"));

var ruleCache = require("./styles/rule").ruleCache;

var StyleManager = require("./styles/style_manager").StyleManager;

var StyleParser = require("./styles/style_parser").StyleParser;

var FeatureSelection = _interopRequire(require("./selection"));

var glMatrix = _interopRequire(require("gl-matrix"));

// Default to 64-bit because we need the extra precision when multiplying matrices w/mercator projected values
glMatrix.glMatrix.setMatrixArrayType(Float64Array);

// Make some modules accessible for debugging
var debug = {
    log: log,
    Utils: Utils,
    Geo: Geo,
    DataSource: DataSource,
    TileManager: TileManager,
    GLSL: GLSL,
    ShaderProgram: ShaderProgram,
    VertexData: VertexData,
    Texture: Texture,
    Material: Material,
    Light: Light,
    SceneWorker: SceneWorker,
    WorkerBroker: WorkerBroker,
    ruleCache: ruleCache,
    StyleManager: StyleManager,
    StyleParser: StyleParser,
    FeatureSelection: FeatureSelection
};

// Window can only be set in main thread
if (Utils.isMainThread) {
    // Main thread objects that can be called from workers
    WorkerBroker.addTarget("Texture", Texture);

    window.Tangram = module.exports = {
        LeafletLayer: LeafletLayer,
        leafletLayer: leafletLayer,
        debug: debug,
        version: version.string
    };
}

if (Utils.isWorkerThread) {
    self.Tangram = {
        debug: debug,
        version: version.string
    };
}

if (Utils.isMainThread) {
    Utils.requestAnimationFramePolyfill();
}

// Setup logging to prefix with Tangram version
var originalFactory = log.methodFactory;
log.methodFactory = function (methodName, logLevel) {
    var rawMethod = originalFactory(methodName, logLevel);
    return function () {
        for (var _len = arguments.length, message = Array(_len), _key = 0; _key < _len; _key++) {
            message[_key] = arguments[_key];
        }

        rawMethod.apply(undefined, ["Tangram " + version.string + ":"].concat(message));
    };
};

},{"../src/scene_worker":91,"./geo":73,"./gl/glsl":77,"./gl/shader_program":79,"./gl/texture":81,"./gl/vertex_data":84,"./leaflet_layer":86,"./light":87,"./material":88,"./selection":92,"./sources/data_source":93,"./sources/geojson":94,"./sources/mvt":95,"./sources/topojson":96,"./styles/rule":101,"./styles/style_manager":103,"./styles/style_parser":104,"./tile_manager":111,"./utils/utils":115,"./utils/version":116,"./utils/worker_broker":117,"gl-matrix":27,"loglevel":60}],90:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Scene */

var Geo = _interopRequire(require("./geo"));

var Utils = _interopRequire(require("./utils/utils"));

var WorkerBroker = _interopRequire(require("./utils/worker_broker"));

var subscribeMixin = _interopRequire(require("./utils/subscribe"));

var Context = _interopRequire(require("./gl/context"));

var Texture = _interopRequire(require("./gl/texture"));

var VertexArrayObject = _interopRequire(require("./gl/vao"));

var StyleManager = require("./styles/style_manager").StyleManager;

var StyleParser = require("./styles/style_parser").StyleParser;

var Camera = _interopRequire(require("./camera"));

var Light = _interopRequire(require("./light"));

var TileManager = _interopRequire(require("./tile_manager"));

var DataSource = _interopRequire(require("./sources/data_source"));

var FeatureSelection = _interopRequire(require("./selection"));

var RenderState = _interopRequire(require("./gl/render_state"));

var Polygons = require("./styles/polygons/polygons").Polygons;

var Lines = require("./styles/lines/lines").Lines;

var Points = require("./styles/points/points").Points;

var TextStyle = require("./styles/text/text").TextStyle;

// Add built-in rendering styles
StyleManager.register(Polygons);
StyleManager.register(Lines);
StyleManager.register(Points);
StyleManager.register(TextStyle);

var log = _interopRequire(require("loglevel"));

var glMatrix = _interopRequire(require("gl-matrix"));

var mat4 = glMatrix.mat4;
var mat3 = glMatrix.mat3;
var vec3 = glMatrix.vec3;

// Load scene definition: pass an object directly, or a URL as string to load remotely

var Scene = (function () {
    function Scene(config_source, options) {
        _classCallCheck(this, Scene);

        options = options || {};
        subscribeMixin(this);

        this.initialized = false;
        this.initializing = false;
        this.sources = {};

        this.tile_manager = TileManager;
        this.tile_manager.init(this);
        this.num_workers = options.numWorkers || 2;
        this.continuous_zoom = typeof options.continuousZoom === "boolean" ? options.continuousZoom : true;
        this.tile_simplification_level = 0; // level-of-detail downsampling to apply to tile loading
        this.allow_cross_domain_workers = options.allowCrossDomainWorkers === false ? false : true;
        this.worker_url = options.workerUrl;
        if (options.disableVertexArrayObjects === true) {
            VertexArrayObject.disabled = true;
        }

        Utils.use_high_density_display = options.highDensityDisplay !== undefined ? options.highDensityDisplay : true;
        Utils.updateDevicePixelRatio();

        this.config = null;
        this.config_source = config_source;
        this.config_serialized = null;
        this.last_valid_config_source = null;

        this.styles = null;
        this.active_styles = {};

        this.building = null; // tracks current scene building state (tiles being built, etc.)
        this.dirty = true; // request a redraw
        this.animated = false; // request redraw every frame
        this.preUpdate = options.preUpdate; // optional pre-render loop hook
        this.postUpdate = options.postUpdate; // optional post-render loop hook
        this.render_loop = !options.disableRenderLoop; // disable render loop - app will have to manually call Scene.render() per frame
        this.render_loop_active = false;
        this.render_loop_stop = false;
        this.frame = 0;
        this.resetTime();

        this.zoom = null;
        this.center = null;

        this.zooming = false;
        this.preserve_tiles_within_zoom = 1;
        this.panning = false;
        this.container = options.container;

        this.camera = null;
        this.lights = null;
        this.background = null;

        // Model-view matrices
        // 64-bit versions are for CPU calcuations
        // 32-bit versions are downsampled and sent to GPU
        this.modelMatrix = new Float64Array(16);
        this.modelMatrix32 = new Float32Array(16);
        this.modelViewMatrix = new Float64Array(16);
        this.modelViewMatrix32 = new Float32Array(16);
        this.normalMatrix = new Float64Array(9);
        this.normalMatrix32 = new Float32Array(9);

        this.selection = null;
        this.texture_listener = null;

        // Debug config
        this.debug = {
            profile: {
                geometry_build: false
            }
        };

        this.updating = 0;
        this.generation = 0; // an id that is incremented each time the scene config is invalidated

        this.logLevel = options.logLevel || "warn";
        log.setLevel(this.logLevel);
    }

    _createClass(Scene, {
        load: {

            // Load (or reload) scene config
            // Optionally specify new scene file URL

            value: function load() {
                var _this = this;

                var config_source = arguments[0] === undefined ? null : arguments[0];

                if (this.initializing) {
                    return Promise.resolve();
                }

                this.updating++;
                this.initialized = false;
                this.initializing = true;

                // Load scene definition (sources, styles, etc.), then create styles & workers
                return this.loadScene(config_source).then(function () {
                    return _this.createWorkers();
                }).then(function () {
                    _this.createCanvas();
                    _this.resetFeatureSelection();

                    if (!_this.texture_listener) {
                        _this.texture_listener = {
                            update: function () {
                                return _this.dirty = true;
                            },
                            warning: function (data) {
                                return _this.trigger("warning", Object.assign({ type: "textures" }, data));
                            }
                        };
                        Texture.subscribe(_this.texture_listener);
                    }

                    // Remove tiles before rebuilding
                    _this.tile_manager.removeTiles(function (tile) {
                        return !tile.visible;
                    });
                    return _this.updateConfig({ rebuild: true });
                }).then(function () {
                    _this.updating--;
                    _this.initializing = false;
                    _this.initialized = true;
                    _this.last_valid_config_source = _this.config_source;

                    if (_this.render_loop !== false) {
                        _this.setupRenderLoop();
                    }
                })["catch"](function (error) {
                    _this.initializing = false;
                    _this.updating = 0;

                    // Report and revert to last valid config if available
                    var type = undefined,
                        message = undefined;
                    if (error.name === "YAMLException") {
                        type = "yaml";
                        message = "Error parsing scene YAML";
                    } else {
                        // TODO: more error types
                        message = "Error initializing scene";
                    }
                    _this.trigger("error", { type: type, message: message, error: error, url: _this.config_source });

                    message = "Scene.load() failed to load " + _this.config_source + ": " + error.message;
                    if (_this.last_valid_config_source) {
                        log.warn(message, error);
                        log.info("Scene.load() reverting to last valid configuration");
                        return _this.load(_this.last_valid_config_source);
                    }
                    log.error(message, error);
                    throw error;
                });
            }
        },
        reload: {

            // For API compatibility

            value: function reload() {
                var config_source = arguments[0] === undefined ? null : arguments[0];

                return this.load(config_source);
            }
        },
        destroy: {
            value: function destroy() {
                this.initialized = false;
                this.render_loop_stop = true; // schedule render loop to stop

                this.unsubscribeAll(); // clear all event listeners

                Texture.unsubscribe(this.texture_listener);
                this.texture_listener = null;

                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                    this.canvas = null;
                }
                this.container = null;

                if (this.selection) {
                    this.selection.destroy();
                }

                if (this.gl) {
                    Texture.destroy(this.gl);
                    StyleManager.destroy(this.gl);
                    this.styles = {};

                    this.gl = null;
                }

                this.sources = {};

                if (Array.isArray(this.workers)) {
                    this.workers.forEach(function (worker) {
                        worker.terminate();
                    });
                    this.workers = null;
                }

                this.tile_manager.destroy();
            }
        },
        createCanvas: {
            value: function createCanvas() {
                if (this.canvas) {
                    return;
                }

                this.container = this.container || document.body;
                this.canvas = document.createElement("canvas");
                this.canvas.style.position = "absolute";
                this.canvas.style.top = 0;
                this.canvas.style.left = 0;

                // Force tangram canvas underneath all leaflet layers, and set background to transparent
                this.canvas.style.zIndex = -1;
                this.container.style.cssText += "background: transparent;";
                this.container.appendChild(this.canvas);

                try {
                    this.gl = Context.getContext(this.canvas, {
                        alpha: false /*premultipliedAlpha: false*/,
                        device_pixel_ratio: Utils.device_pixel_ratio
                    });
                } catch (e) {
                    throw new Error("Couldn't create WebGL context. " + "Your browser may not support WebGL, or it's turned off? " + "Visit http://webglreport.com/ for more info.");
                }

                this.resizeMap(this.container.clientWidth, this.container.clientHeight);
                VertexArrayObject.init(this.gl);
                RenderState.initialize(this.gl);
            }
        },
        getWorkerUrl: {

            // Get the URL to load the web worker from

            value: function getWorkerUrl() {
                var worker_url = this.worker_url || Utils.findCurrentURL("tangram.debug.js", "tangram.min.js");

                if (!worker_url) {
                    throw new Error("Can't load worker because couldn't find base URL that library was loaded from");
                }

                if (this.allow_cross_domain_workers) {
                    var body = "importScripts('" + worker_url + "');";
                    return Utils.createObjectURL(new Blob([body], { type: "application/javascript" }));
                }
                return worker_url;
            }
        },
        createWorkers: {

            // Web workers handle heavy duty tile construction: networking, geometry processing, etc.

            value: function createWorkers() {
                if (!this.workers) {
                    return this.makeWorkers(this.getWorkerUrl());
                }
                return Promise.resolve();
            }
        },
        makeWorkers: {

            // Instantiate workers from URL, init event handlers

            value: function makeWorkers(url) {
                var _this = this;

                var queue = [];

                this.workers = [];
                for (var id = 0; id < this.num_workers; id++) {
                    var worker;

                    (function () {
                        worker = new Worker(url);

                        _this.workers[id] = worker;

                        worker.addEventListener("message", _this.workerLogMessage.bind(_this));
                        WorkerBroker.addWorker(worker);

                        log.debug("Scene.makeWorkers: initializing worker " + id);
                        var _id = id;
                        queue.push(WorkerBroker.postMessage(worker, "init", id, _this.num_workers, Utils.device_pixel_ratio).then(function (id) {
                            log.debug("Scene.makeWorkers: initialized worker " + id);
                            return id;
                        }, function (error) {
                            log.error("Scene.makeWorkers: failed to initialize worker " + _id + ":", error);
                            return Promise.reject(error);
                        }));
                    })();
                }

                this.next_worker = 0;
                return Promise.all(queue);
            }
        },
        nextWorker: {

            // Round robin selection of next worker

            value: function nextWorker() {
                var worker = this.workers[this.next_worker];
                this.next_worker = (this.next_worker + 1) % this.workers.length;
                return worker;
            }
        },
        setView: {

            /**
                Set the map view, can be passed an object with lat/lng and/or zoom
            */

            value: function setView() {
                var _ref = arguments[0] === undefined ? {} : arguments[0];

                var lng = _ref.lng;
                var lat = _ref.lat;
                var zoom = _ref.zoom;

                var changed = false;

                // Set center
                if (typeof lng === "number" && typeof lat === "number") {
                    if (!this.center || lng !== this.center.lng || lat !== this.center.lat) {
                        changed = true;
                        this.center = { lng: Geo.wrapLng(lng), lat: lat };
                    }
                }

                // Set zoom
                if (typeof zoom === "number" && zoom !== this.zoom) {
                    changed = true;
                    this.setZoom(zoom);
                }

                if (changed) {
                    this.updateBounds();
                }
                return changed;
            }
        },
        startZoom: {
            value: function startZoom() {
                this.last_zoom = this.zoom;
                this.zooming = true;
            }
        },
        baseZoom: {

            // Choose the base zoom level to use for a given fractional zoom

            value: function baseZoom(zoom) {
                return Math.floor(zoom);
            }
        },
        tileZoom: {

            // For a given view zoom, what tile zoom should be loaded?

            value: function tileZoom(view_zoom) {
                return this.baseZoom(view_zoom) - this.tile_simplification_level;
            }
        },
        styleZoom: {

            // For a given tile zoom, what style zoom should be used?

            value: function styleZoom(tile_zoom) {
                return this.baseZoom(tile_zoom) + this.tile_simplification_level;
            }
        },
        setZoom: {
            value: function setZoom(zoom) {
                var _this = this;

                this.zooming = false;
                var tile_zoom = this.tileZoom(zoom);

                if (!this.continuous_zoom) {
                    zoom = tile_zoom;
                }

                if (tile_zoom !== this.tileZoom(this.last_zoom)) {
                    // Remove tiles outside current zoom that are still loading
                    this.tile_manager.removeTiles(function (tile) {
                        if (tile.loading && _this.tileZoom(tile.coords.z) !== tile_zoom) {
                            log.trace("removed " + tile.key + " (was loading, but outside current zoom)");
                            return true;
                        }
                    });
                }

                this.last_zoom = this.zoom;
                this.zoom = zoom;
                this.tile_zoom = tile_zoom;

                this.updateBounds();

                this.dirty = true;
            }
        },
        viewReady: {
            value: function viewReady() {
                if (this.css_size == null || this.center == null || this.zoom == null || Object.keys(this.sources).length === 0) {
                    return false;
                }
                return true;
            }
        },
        updateBounds: {

            // Calculate viewport bounds based on current center and zoom

            value: function updateBounds() {
                // TODO: better concept of "readiness" state?
                if (!this.viewReady()) {
                    return;
                }

                this.meters_per_pixel = Geo.metersPerPixel(this.zoom);

                // Size of the half-viewport in meters at current zoom
                this.viewport_meters = {
                    x: this.css_size.width * this.meters_per_pixel,
                    y: this.css_size.height * this.meters_per_pixel
                };

                // Center of viewport in meters, and tile

                var _Geo$latLngToMeters = Geo.latLngToMeters([this.center.lng, this.center.lat]);

                var _Geo$latLngToMeters2 = _slicedToArray(_Geo$latLngToMeters, 2);

                var x = _Geo$latLngToMeters2[0];
                var y = _Geo$latLngToMeters2[1];

                this.center_meters = { x: x, y: y };

                var z = this.tileZoom(this.zoom);
                this.center_tile = Geo.tileForMeters([this.center_meters.x, this.center_meters.y], z);

                this.bounds_meters = {
                    sw: {
                        x: this.center_meters.x - this.viewport_meters.x / 2,
                        y: this.center_meters.y - this.viewport_meters.y / 2
                    },
                    ne: {
                        x: this.center_meters.x + this.viewport_meters.x / 2,
                        y: this.center_meters.y + this.viewport_meters.y / 2
                    }
                };

                this.tile_manager.updateTilesForView();

                this.trigger("move");
                this.dirty = true;
            }
        },
        findVisibleTileCoordinates: {
            value: function findVisibleTileCoordinates() {
                var _ref = arguments[0] === undefined ? {} : arguments[0];

                var buffer = _ref.buffer;

                if (!this.bounds_meters) {
                    return [];
                }

                var z = this.tileZoom(this.zoom);
                var sw = Geo.tileForMeters([this.bounds_meters.sw.x, this.bounds_meters.sw.y], z);
                var ne = Geo.tileForMeters([this.bounds_meters.ne.x, this.bounds_meters.ne.y], z);
                buffer = buffer || 0;

                var coords = [];
                for (var x = sw.x - buffer; x <= ne.x + buffer; x++) {
                    for (var y = ne.y - buffer; y <= sw.y + buffer; y++) {
                        coords.push({ x: x, y: y, z: z });
                    }
                }
                return coords;
            }
        },
        pruneTileCoordinatesForView: {

            // Remove tiles too far outside of view

            value: function pruneTileCoordinatesForView() {
                var _this = this;

                var border_buffer = arguments[0] === undefined ? 2 : arguments[0];

                if (!this.viewReady()) {
                    return;
                }

                // Remove tiles that are a specified # of tiles outside of the viewport border
                var border_tiles = [Math.ceil((Math.floor(this.css_size.width / Geo.tile_size) + 2) / 2), Math.ceil((Math.floor(this.css_size.height / Geo.tile_size) + 2) / 2)];
                var style_zoom = this.tileZoom(this.zoom);

                this.tile_manager.removeTiles(function (tile) {
                    // Ignore visible tiles
                    if (tile.visible) {
                        return false;
                    }

                    // Discard if too far from current zoom
                    var zdiff = tile.coords.z - style_zoom;
                    if (Math.abs(zdiff) > _this.preserve_tiles_within_zoom) {
                        return true;
                    }

                    // Handle tiles at different zooms
                    var ztrans = Math.pow(2, zdiff);
                    var coords = {
                        x: Math.floor(tile.coords.x / ztrans),
                        y: Math.floor(tile.coords.y / ztrans)
                    };

                    // Discard tiles outside an area surrounding the viewport
                    if (Math.abs(coords.x - _this.center_tile.x) - border_tiles[0] > border_buffer) {
                        log.trace("Scene: remove tile " + tile.key + " (as " + coords.x + "/" + coords.y + "/" + style_zoom + ") for being too far out of visible area ***");
                        return true;
                    } else if (Math.abs(coords.y - _this.center_tile.y) - border_tiles[1] > border_buffer) {
                        log.trace("Scene: remove tile " + tile.key + " (as " + coords.x + "/" + coords.y + "/" + style_zoom + ") for being too far out of visible area ***");
                        return true;
                    }
                    return false;
                });
            }
        },
        resizeMap: {
            value: function resizeMap(width, height) {
                this.dirty = true;

                this.css_size = { width: width, height: height };
                this.device_size = {
                    width: Math.round(this.css_size.width * Utils.device_pixel_ratio),
                    height: Math.round(this.css_size.height * Utils.device_pixel_ratio)
                };
                this.view_aspect = this.css_size.width / this.css_size.height;
                this.updateBounds();

                if (this.canvas) {
                    this.canvas.style.width = this.css_size.width + "px";
                    this.canvas.style.height = this.css_size.height + "px";
                    this.canvas.width = this.device_size.width;
                    this.canvas.height = this.device_size.height;

                    if (this.gl) {
                        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
                        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                    }
                }
            }
        },
        requestRedraw: {

            // Request scene be redrawn at next animation loop

            value: function requestRedraw() {
                this.dirty = true;
            }
        },
        immediateRedraw: {

            // Redraw scene immediately - don't wait for animation loop
            // Use sparingly, but for cases where you need the closest possible sync with other UI elements,
            // such as other, non-WebGL map layers (e.g. Leaflet raster layers, markers, etc.)

            value: function immediateRedraw() {
                this.dirty = true;
                this.update();
            }
        },
        renderLoop: {
            value: function renderLoop() {
                this.render_loop_active = true; // only let the render loop instantiate once

                if (this.initialized) {
                    // Render the scene
                    this.update();
                }

                // Request the next frame if not scheduled to stop
                if (!this.render_loop_stop) {
                    window.requestAnimationFrame(this.renderLoop.bind(this));
                } else {
                    this.render_loop_stop = false;
                    this.render_loop_active = false;
                }
            }
        },
        setupRenderLoop: {

            // Setup the render loop

            value: function setupRenderLoop() {
                var _this = this;

                if (!this.render_loop_active) {
                    setTimeout(function () {
                        _this.renderLoop();
                    }, 0); // delay start by one tick
                }
            }
        },
        update: {
            value: function update() {
                this.tile_manager.loadQueuedCoordinates();

                // Render on demand
                var will_render = !(this.dirty === false || this.initialized === false || this.updating > 0 || this.viewReady() === false);

                // Pre-render loop hook
                if (typeof this.preUpdate === "function") {
                    this.preUpdate(will_render);
                }

                // Bail if no need to render
                if (!will_render) {
                    return false;
                }
                this.dirty = false; // subclasses can set this back to true when animation is needed

                // Render the scene
                this.render();

                // Post-render loop hook
                if (typeof this.postUpdate === "function") {
                    this.postUpdate(will_render);
                }

                // Redraw every frame if animating
                if (this.animated === true) {
                    this.dirty = true;
                }

                this.frame++;
                log.trace("Scene.render()");
                return true;
            }
        },
        render: {
            value: function render() {
                var _this = this;

                var gl = this.gl;

                // Map transforms
                if (!this.center_meters) {
                    return;
                }

                // Update styles, camera, lights
                this.camera.update();
                Object.keys(this.active_styles).forEach(function (i) {
                    return _this.styles[i].update();
                });
                Object.keys(this.lights).forEach(function (i) {
                    return _this.lights[i].update();
                });

                // Renderable tile list
                this.renderable_tiles = this.tile_manager.getRenderableTiles();
                this.renderable_tiles_count = this.renderable_tiles.length;

                // Render main pass
                this.render_count = this.renderPass();

                // Render selection pass (if needed)
                if (this.selection.pendingRequests()) {
                    if (this.panning) {
                        return;
                    }

                    this.selection.bind(); // switch to FBO
                    this.renderPass("selection_program", // render w/alternate program
                    { allow_alpha_blend: false });
                    this.selection.read(); // read results from selection buffer

                    // Reset to screen buffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                }

                if (this.render_count !== this.last_render_count) {
                    this.getFeatureSelectionMapSize().then(function (size) {
                        log.info("Scene: rendered " + _this.render_count + " primitives (" + size + " features in selection map)");
                    }, function () {}); // no op when promise rejects (only print last response)
                }
                this.last_render_count = this.render_count;

                return true;
            }
        },
        renderPass: {

            // Render all active styles, grouped by blend/depth type (opaque, overlay, etc.) and by program (style)
            // Called both for main render pass, and for secondary passes like selection buffer

            value: function renderPass() {
                var _this = this;

                var program_key = arguments[0] === undefined ? "program" : arguments[0];

                var _ref = arguments[1] === undefined ? {} : arguments[1];

                var allow_alpha_blend = _ref.allow_alpha_blend;

                var styles = undefined;
                var count = 0; // how many primitives were rendered

                // optionally force alpha off (e.g. for selection pass)
                allow_alpha_blend = allow_alpha_blend == null ? true : allow_alpha_blend;

                this.clearFrame({ clear_color: true, clear_depth: true });

                // Opaque styles: depth test on, depth write on, blending off
                styles = Object.keys(this.active_styles).filter(function (s) {
                    return _this.styles[s].blend === "opaque";
                });
                if (styles.length > 0) {
                    this.setRenderState({ depth_test: true, depth_write: true, alpha_blend: false });
                    count += this.renderStyles(styles, program_key);
                }

                // Transparent styles: depth test off, depth write on, custom blending
                styles = Object.keys(this.active_styles).filter(function (s) {
                    return _this.styles[s].blend === "add";
                });
                if (styles.length > 0) {
                    this.setRenderState({ depth_test: true, depth_write: false, alpha_blend: allow_alpha_blend && "add" });
                    count += this.renderStyles(styles, program_key);
                }

                styles = Object.keys(this.active_styles).filter(function (s) {
                    return _this.styles[s].blend === "multiply";
                });
                if (styles.length > 0) {
                    this.setRenderState({ depth_test: true, depth_write: false, alpha_blend: allow_alpha_blend && "multiply" });
                    count += this.renderStyles(styles, program_key);
                }

                // Inlay styles: depth test on, depth write off, blending on
                styles = Object.keys(this.styles).filter(function (s) {
                    return _this.styles[s].blend === "inlay";
                });
                if (styles.length > 0) {
                    this.setRenderState({ depth_test: true, depth_write: false, alpha_blend: allow_alpha_blend });
                    count += this.renderStyles(styles, program_key);
                }

                // Overlay styles: depth test off, depth write off, blending on
                styles = Object.keys(this.styles).filter(function (s) {
                    return _this.styles[s].blend === "overlay";
                });
                if (styles.length > 0) {
                    this.setRenderState({ depth_test: false, depth_write: false, alpha_blend: allow_alpha_blend });
                    count += this.renderStyles(styles, program_key);
                }

                return count;
            }
        },
        renderStyles: {
            value: function renderStyles(styles, program_key) {
                var count = 0;
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = styles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var style = _step.value;

                        var program = this.styles[style][program_key];
                        if (!program || !program.compiled) {
                            continue;
                        }
                        count += this.renderStyle(style, program);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return count;
            }
        },
        renderStyle: {
            value: function renderStyle(style, program) {
                var first_for_style = true;
                var render_count = 0;

                // Render tile GL geometries
                for (var t in this.renderable_tiles) {
                    var tile = this.renderable_tiles[t];

                    if (tile.meshes[style] != null) {
                        // Setup style if encountering for first time this frame
                        // (lazy init, not all styles will be used in all screen views; some styles might be defined but never used)
                        if (first_for_style === true) {
                            first_for_style = false;

                            program.use();
                            this.styles[style].setup();

                            // TODO: don't set uniforms when they haven't changed
                            program.uniform("2f", "u_resolution", this.device_size.width, this.device_size.height);
                            program.uniform("1f", "u_time", (+new Date() - this.start_time) / 1000);
                            program.uniform("3f", "u_map_position", this.center_meters.x, this.center_meters.y, this.zoom);
                            // Math.floor(this.zoom) + (Math.log((this.zoom % 1) + 1) / Math.LN2 // scale fractional zoom by log
                            program.uniform("1f", "u_meters_per_pixel", this.meters_per_pixel);
                            program.uniform("1f", "u_device_pixel_ratio", Utils.device_pixel_ratio);

                            // Normal matrix - transforms surface normals into view space
                            // this matrix is constant since the view doesn't rotate for now
                            mat3.normalFromMat4(this.normalMatrix32, this.modelViewMatrix32);
                            program.uniform("Matrix3fv", "u_normalMatrix", false, this.normalMatrix32);

                            this.camera.setupProgram(program);
                            for (var i in this.lights) {
                                this.lights[i].setupProgram(program);
                            }
                        }

                        // TODO: calc these once per tile (currently being needlessly re-calculated per-tile-per-style)

                        // Tile origin
                        program.uniform("3f", "u_tile_origin", tile.min.x, tile.min.y, tile.style_zoom);

                        // Model matrix - transform tile space into world space (meters, absolute mercator position)
                        mat4.identity(this.modelMatrix);
                        mat4.translate(this.modelMatrix, this.modelMatrix, vec3.fromValues(tile.min.x, tile.min.y, 0));
                        mat4.scale(this.modelMatrix, this.modelMatrix, vec3.fromValues(tile.span.x / Geo.tile_scale, -1 * tile.span.y / Geo.tile_scale, 1)); // scale tile local coords to meters
                        mat4.copy(this.modelMatrix32, this.modelMatrix);
                        program.uniform("Matrix4fv", "u_model", false, this.modelMatrix32);

                        // Model view matrix - transform tile space into view space (meters, relative to camera)
                        mat4.multiply(this.modelViewMatrix32, this.camera.viewMatrix, this.modelMatrix);
                        program.uniform("Matrix4fv", "u_modelView", false, this.modelViewMatrix32);

                        // Render tile
                        tile.meshes[style].render();
                        render_count += tile.meshes[style].geometry_count;
                    }
                }

                return render_count;
            }
        },
        clearFrame: {
            value: function clearFrame() {
                var _ref = arguments[0] === undefined ? {} : arguments[0];

                var clear_color = _ref.clear_color;
                var clear_depth = _ref.clear_depth;

                if (!this.initialized) {
                    return;
                }

                // Defaults
                clear_color = clear_color === false ? false : true; // default true
                clear_depth = clear_depth === false ? false : true; // default true

                // Reset frame state
                var gl = this.gl;

                if (clear_color) {
                    gl.clearColor.apply(gl, _toConsumableArray(this.background.color));
                }

                if (clear_depth) {
                    gl.depthMask(true); // always clear depth if requested, even if depth write will be turned off
                }

                if (clear_color || clear_depth) {
                    var mask = (clear_color && gl.COLOR_BUFFER_BIT) | (clear_depth && gl.DEPTH_BUFFER_BIT);
                    gl.clear(mask);
                }
            }
        },
        setRenderState: {
            value: function setRenderState() {
                var _ref = arguments[0] === undefined ? {} : arguments[0];

                var depth_test = _ref.depth_test;
                var depth_write = _ref.depth_write;
                var cull_face = _ref.cull_face;
                var alpha_blend = _ref.alpha_blend;

                if (!this.initialized) {
                    return;
                }

                // Defaults
                // TODO: when we abstract out support for multiple render passes, these can be per-pass config options
                depth_test = depth_test === false ? false : true; // default true
                depth_write = depth_write === false ? false : true; // default true
                cull_face = cull_face === false ? false : true; // default true
                alpha_blend = alpha_blend != null ? alpha_blend : false; // default false

                // Reset frame state
                var gl = this.gl;

                RenderState.depth_test.set({ depth_test: depth_test, depth_func: gl.LEQUAL });
                RenderState.depth_write.set({ depth_write: depth_write });
                RenderState.culling.set({ cull: cull_face, face: gl.BACK });

                if (alpha_blend) {
                    // Traditional blending
                    if (alpha_blend === true) {
                        RenderState.blending.set({ blend: true, src: gl.SRC_ALPHA, dst: gl.ONE_MINUS_SRC_ALPHA });
                    }
                    // Additive blending
                    else if (alpha_blend === "add") {
                        RenderState.blending.set({ blend: true, src: gl.ONE, dst: gl.ONE });
                    }
                    // Multiplicative blending
                    else if (alpha_blend === "multiply") {
                        RenderState.blending.set({ blend: true, src: gl.ZERO, dst: gl.SRC_COLOR });
                    }
                } else {
                    RenderState.blending.set({ blend: false, src: null, dst: null });
                }
            }
        },
        getFeatureAt: {

            // Request feature selection at given pixel. Runs async and returns results via a promise.

            value: function getFeatureAt(pixel) {
                if (!this.initialized) {
                    log.debug("Scene.getFeatureAt() called before scene was initialized");
                    return Promise.resolve();
                }

                // Point scaled to [0..1] range
                var point = {
                    x: pixel.x * Utils.device_pixel_ratio / this.device_size.width,
                    y: pixel.y * Utils.device_pixel_ratio / this.device_size.height
                };

                this.dirty = true; // need to make sure the scene re-renders for these to be processed
                return this.selection.getFeatureAt(point);
            }
        },
        rebuild: {

            // Rebuild geometry, without re-parsing the config or re-compiling styles
            // TODO: detect which elements need to be refreshed/rebuilt (stylesheet changes, etc.)

            value: function rebuild() {
                return this.rebuildGeometry();
            }
        },
        rebuildGeometry: {

            // Rebuild all tiles

            value: function rebuildGeometry() {
                var _this = this;

                return new Promise(function (resolve, reject) {
                    // Skip rebuild if already in progress
                    if (_this.building) {
                        // Queue up to one rebuild call at a time, only save last request
                        if (_this.building.queued && _this.building.queued.reject) {
                            // notify previous request that it did not complete
                            log.debug("Scene.rebuildGeometry: request superceded by a newer call");
                            _this.building.queued.resolve(false); // false flag indicates rebuild request was superceded
                        }

                        // Save queued request
                        _this.building.queued = { resolve: resolve, reject: reject };
                        log.trace("Scene.rebuildGeometry(): queuing request");
                        return;
                    }

                    // Track tile build state
                    _this.building = { resolve: resolve, reject: reject };

                    // Profiling
                    if (_this.debug.profile.geometry_build) {
                        _this._profile("rebuildGeometry");
                    }

                    // Update config (in case JS objects were manipulated directly)
                    _this.syncConfigToWorker();
                    StyleManager.compile(_this.updateActiveStyles(), _this); // only recompile newly active styles
                    _this.resetFeatureSelection();
                    _this.resetTime();

                    // Rebuild visible tiles, sorted from center
                    var build = [];
                    _this.tile_manager.forEachTile(function (tile) {
                        if (tile.visible) {
                            build.push(tile);
                        } else {
                            _this.tile_manager.removeTile(tile.key);
                        }
                    });
                    _this.tile_manager.buildTiles(build);
                }).then(function () {
                    // Profiling
                    if (_this.debug.profile.geometry_build) {
                        _this._profileEnd("rebuildGeometry");
                    }
                });
            }
        },
        tileManagerBuildDone: {

            // Tile manager finished building tiles

            value: function tileManagerBuildDone() {
                if (this.building) {
                    log.info("Scene: build geometry finished");
                    if (this.building.resolve) {
                        this.building.resolve(true);
                    }

                    // Another rebuild queued?
                    var queued = this.building.queued;
                    this.building = null;
                    if (queued) {
                        log.debug("Scene: starting queued rebuildGeometry() request");
                        this.rebuildGeometry().then(queued.resolve, queued.reject);
                    }
                }
            }
        },
        loadScene: {

            /**
               Load (or reload) the scene config
               @return {Promise}
            */

            value: function loadScene() {
                var _this = this;

                var config_source = arguments[0] === undefined ? null : arguments[0];

                this.config_source = config_source || this.config_source;
                if (typeof this.config_source === "string") {
                    this.config_path = Utils.pathForURL(this.config_source);
                } else {
                    this.config_path = null;
                }
                Texture.base_url = this.config_path;

                return Utils.loadResource(this.config_source).then(function (config) {
                    _this.config = config;
                    return _this.preProcessConfig().then(function () {
                        _this.trigger("load", { config: _this.config });
                    });
                });
            }
        },
        loadDataSources: {
            value: function loadDataSources() {
                for (var name in this.config.sources) {
                    var source = this.config.sources[name];
                    source.url = Utils.addBaseURL(source.url);
                    this.sources[name] = DataSource.create(Object.assign({}, source, { name: name }));

                    if (!this.sources[name]) {
                        delete this.sources[name];
                        log.warn("Scene: could not create data source", source);
                        this.trigger("warning", { type: "sources", source: source, message: "Could not create data source" });
                    }
                }
            }
        },
        preProcessConfig: {

            // Normalize some settings that may not have been explicitly specified in the scene definition

            value: function preProcessConfig() {
                // Assign ids to data sources
                var source_id = 0;
                for (var source in this.config.sources) {
                    this.config.sources[source].id = source_id++;
                }

                // If only one camera specified, set it as default
                this.config.cameras = this.config.cameras || {};
                if (this.config.camera) {
                    this.config.cameras["default"] = this.config.camera;
                }
                var camera_names = Object.keys(this.config.cameras);
                if (camera_names.length === 0) {
                    this.config.cameras["default"] = { active: true };
                } else if (!this._active_camera) {
                    // If no camera set as active, use first one
                    this.config.cameras[camera_names[0]].active = true;
                }

                this.config.lights = this.config.lights || {}; // ensure lights object
                this.config.styles = this.config.styles || {}; // ensure styles object

                return StyleManager.preload(this.config.styles, this.config_path);
            }
        },
        loadTextures: {

            // Load all textures in the scene definition

            value: function loadTextures() {
                this.normalizeTextures();
                return Texture.createFromObject(this.gl, this.config.textures);
            }
        },
        normalizeTextures: {

            // Handle single or multi-texture syntax, for stylesheet convenience

            value: function normalizeTextures() {
                if (!this.config.styles) {
                    return;
                }

                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Utils.entries(this.config.styles)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var _step$value = _slicedToArray(_step.value, 2);

                        var style_name = _step$value[0];
                        var style = _step$value[1];

                        // If style has a single 'texture' object, move it to the global scene texture set
                        // and give it a default name
                        if (style.texture && typeof style.texture === "object") {
                            var texture_name = "__" + style_name;
                            this.config.textures = this.config.textures || {};
                            this.config.textures[texture_name] = style.texture;
                            style.texture = texture_name; // point stlye to location of texture
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        updateStyles: {

            // Called (currently manually) after styles are updated in stylesheet

            value: function updateStyles() {
                if (!this.initialized && !this.initializing) {
                    throw new Error("Scene.updateStyles() called before scene was initialized");
                }

                // (Re)build styles from config
                StyleManager.init();
                this.styles = StyleManager.build(this.config.styles, this);

                // Optionally set GL context (used when initializing or re-initializing GL resources)
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Utils.values(this.styles)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var style = _step.value;

                        style.setGL(this.gl);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                // Find & compile active styles
                this.updateActiveStyles();
                StyleManager.compile(Object.keys(this.active_styles), this);

                this.dirty = true;
            }
        },
        updateActiveStyles: {
            value: function updateActiveStyles() {
                var _this = this;

                // Make a set of currently active styles (used in a draw rule)
                // Note: doesn't actually check if any geometry matches the rule, just that the style is potentially renderable
                var prev_styles = Object.keys(this.active_styles || {});
                this.active_styles = {};
                var animated = false; // is any active style animated?
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Utils.recurseValues(this.config.layers)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var rule = _step.value;

                        if (rule.draw) {
                            var _iteratorNormalCompletion2 = true;
                            var _didIteratorError2 = false;
                            var _iteratorError2 = undefined;

                            try {
                                for (var _iterator2 = Utils.entries(rule.draw)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                    var _step2$value = _slicedToArray(_step2.value, 2);

                                    var _name = _step2$value[0];
                                    var group = _step2$value[1];

                                    // TODO: warn on non-object draw group
                                    if (typeof group === "object" && group.visible !== false) {
                                        (function () {
                                            var style_name = group.style || _name;
                                            var styles = [style_name];

                                            // optional additional outline style
                                            if (group.outline && group.outline.style) {
                                                styles.push(group.outline.style);
                                            }

                                            styles = styles.filter(function (x) {
                                                return _this.styles[x];
                                            }).forEach(function (style_name) {
                                                var style = _this.styles[style_name];
                                                if (style) {
                                                    _this.active_styles[style_name] = true;
                                                    if (style.animated) {
                                                        animated = true;
                                                    }
                                                }
                                            });
                                        })();
                                    }
                                }
                            } catch (err) {
                                _didIteratorError2 = true;
                                _iteratorError2 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                                        _iterator2["return"]();
                                    }
                                } finally {
                                    if (_didIteratorError2) {
                                        throw _iteratorError2;
                                    }
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                // Use explicitly set scene animation flag if defined, otherwise turn on animation
                // if there are any animated styles
                this.animated = this.config.scene.animated !== undefined ? this.config.scene.animated : animated;

                // Compile newly active styles
                return Object.keys(this.active_styles).filter(function (s) {
                    return prev_styles.indexOf(s) === -1;
                });
            }
        },
        createCamera: {

            // Create camera

            value: function createCamera() {
                var active_camera = this._active_camera;
                if (active_camera) {
                    this.camera = Camera.create(active_camera, this, this.config.cameras[this._active_camera]);

                    // TODO: replace this and move all position info to camera
                    this.camera.updateScene();
                }
            }
        },
        getActiveCamera: {

            // Get active camera - for public API

            value: function getActiveCamera() {
                return this._active_camera;
            }
        },
        setActiveCamera: {

            // Set active camera and recompile - for public API

            value: function setActiveCamera(name) {
                this._active_camera = name;
                this.updateConfig();
                return this._active_camera;
            }
        },
        _active_camera: {

            // Internal management of active camera

            get: function () {
                if (this.config && this.config.cameras) {
                    for (var name in this.config.cameras) {
                        if (this.config.cameras[name].active) {
                            return name;
                        }
                    }
                }
            },
            set: function (name) {
                var prev = this._active_camera;

                // Set new active camera
                if (this.config.cameras[name]) {
                    this.config.cameras[name].active = true;

                    // Clear previously active camera
                    if (prev && prev !== name && this.config.cameras[prev]) {
                        delete this.config.cameras[prev].active;
                    }
                }
            }
        },
        createLights: {

            // Create lighting

            value: function createLights() {
                this.lights = {};
                for (var i in this.config.lights) {
                    if (!this.config.lights[i] || typeof this.config.lights[i] !== "object") {
                        continue;
                    }
                    var light = this.config.lights[i];
                    light.name = i.replace("-", "_"); // light names are injected in shaders, can't have hyphens
                    light.visible = light.visible === false ? false : true;
                    if (light.visible) {
                        this.lights[light.name] = Light.create(this, light);
                    }
                }
                Light.inject(this.lights);
            }
        },
        setBackground: {

            // Set background color

            value: function setBackground() {
                var bg = this.config.scene.background;
                this.background = {};
                if (bg && bg.color) {
                    this.background.color = StyleParser.parseColor(bg.color);
                }
                if (!this.background.color) {
                    this.background.color = [0, 0, 0, 1]; // default background to black
                }
            }
        },
        updateConfig: {

            // Update scene config, and optionally rebuild geometry

            value: function updateConfig() {
                var _this = this;

                var _ref = arguments[0] === undefined ? {} : arguments[0];

                var rebuild = _ref.rebuild;

                this.generation++;
                this.updating++;
                this.config.scene = this.config.scene || {};
                this.createCamera();
                this.createLights();
                this.loadDataSources();
                this.loadTextures();
                this.setBackground();
                this.updateBounds();

                // TODO: detect changes to styles? already (currently) need to recompile anyway when camera or lights change
                this.updateStyles();
                this.syncConfigToWorker();
                if (rebuild) {
                    return this.rebuildGeometry().then(function () {
                        return _this.updating--;
                    });
                } else {
                    this.updating--;
                    return Promise.resolve();
                }
            }
        },
        syncConfigToWorker: {

            // Serialize config and send to worker

            value: function syncConfigToWorker() {
                var _this = this;

                // Tell workers we're about to rebuild (so they can update styles, etc.)
                this.config_serialized = Utils.serializeWithFunctions(this.config);
                this.workers.forEach(function (worker) {
                    WorkerBroker.postMessage(worker, "updateConfig", {
                        config: _this.config_serialized,
                        generation: _this.generation
                    });
                });
            }
        },
        resetFeatureSelection: {
            value: function resetFeatureSelection() {
                if (!this.selection) {
                    this.selection = new FeatureSelection(this.gl, this.workers);
                } else if (this.workers) {
                    this.workers.forEach(function (worker) {
                        return WorkerBroker.postMessage(worker, "resetFeatureSelection");
                    });
                }
            }
        },
        getFeatureSelectionMapSize: {

            // Gets the current feature selection map size across all workers. Returns a promise.

            value: function getFeatureSelectionMapSize() {
                var _this = this;

                if (this.fetching_selection_map) {
                    return Promise.reject();
                }
                this.fetching_selection_map = true;

                return Promise.all(this.workers.map(function (worker) {
                    return WorkerBroker.postMessage(worker, "getFeatureSelectionMapSize");
                })).then(function (sizes) {
                    _this.fetching_selection_map = false;
                    return sizes.reduce(function (a, b) {
                        return a + b;
                    });
                });
            }
        },
        resetTime: {

            // Reset internal clock, mostly useful for consistent experience when changing styles/debugging

            value: function resetTime() {
                this.start_time = +new Date();
            }
        },
        workerLogMessage: {

            // Stats/debug/profiling methods

            // Log messages pass through from web workers

            value: function workerLogMessage(event) {
                if (event.data.type !== "log") {
                    return;
                }

                var _event$data = event.data;
                var worker_id = _event$data.worker_id;
                var level = _event$data.level;
                var msg = _event$data.msg;

                if (log[level]) {
                    log[level].apply(log, ["worker " + worker_id + ":"].concat(_toConsumableArray(msg)));
                } else {
                    log.error("Scene.workerLogMessage: unrecognized log level " + level);
                }
            }
        },
        _profile: {

            // Profile helpers, issues a profile on main thread & all workers

            value: function _profile(name) {
                console.profile("main thread: " + name);
                this.workers.forEach(function (w) {
                    return WorkerBroker.postMessage(w, "profile", name);
                });
            }
        },
        _profileEnd: {
            value: function _profileEnd(name) {
                console.profileEnd("main thread: " + name);
                this.workers.forEach(function (w) {
                    return WorkerBroker.postMessage(w, "profileEnd", name);
                });
            }
        }
    });

    return Scene;
})();

module.exports = Scene;

// Static methods/state

Scene.create = function (config) {
    var options = arguments[1] === undefined ? {} : arguments[1];

    return new Scene(config, options);
};

},{"./camera":72,"./geo":73,"./gl/context":75,"./gl/render_state":78,"./gl/texture":81,"./gl/vao":82,"./light":87,"./selection":92,"./sources/data_source":93,"./styles/lines/lines":98,"./styles/points/points":99,"./styles/polygons/polygons":100,"./styles/style_manager":103,"./styles/style_parser":104,"./styles/text/text":109,"./tile_manager":111,"./utils/subscribe":114,"./utils/utils":115,"./utils/worker_broker":117,"gl-matrix":27,"loglevel":60}],91:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

Object.defineProperty(exports, "__esModule", {
    value: true
});
/*jshint worker: true*/

var Utils = _interopRequire(require("./utils/utils"));

var WorkerBroker = _interopRequire(require("./utils/worker_broker"));

// jshint ignore:line

var Tile = _interopRequire(require("./tile"));

var DataSource = _interopRequire(require("./sources/data_source"));

var FeatureSelection = _interopRequire(require("./selection"));

var StyleParser = require("./styles/style_parser").StyleParser;

var StyleManager = require("./styles/style_manager").StyleManager;

var parseRules = require("./styles/rule").parseRules;

var Texture = _interopRequire(require("./gl/texture"));

var SceneWorker = self;

exports.SceneWorker = SceneWorker;
// Worker functionality will only be defined in worker thread
Utils.isWorkerThread && Object.assign(self, {

    FeatureSelection: FeatureSelection,

    sources: {
        tiles: {},
        objects: {}
    },
    styles: {},
    rules: {},
    layers: {},
    tiles: {},
    objects: {},
    config: {},

    // Initialize worker
    init: function init(worker_id, num_workers, device_pixel_ratio) {
        self._worker_id = worker_id;
        self.num_workers = num_workers;
        Utils.device_pixel_ratio = device_pixel_ratio;
        FeatureSelection.setPrefix(self._worker_id);
        return worker_id;
    },

    // Starts a config refresh
    updateConfig: function updateConfig(_ref) {
        var config = _ref.config;
        var generation = _ref.generation;

        self.config = null;
        config = JSON.parse(config);

        self.generation = generation;
        self.styles = null;

        // Data block functions are not macro'ed and wrapped like the rest of the style functions are
        // TODO: probably want a cleaner way to exclude these
        for (var layer in config.layers) {
            config.layers[layer].data = Utils.stringsToFunctions(config.layers[layer].data);
        }

        // Create data sources
        config.sources = Utils.stringsToFunctions(StyleParser.expandMacros(config.sources));
        for (var name in config.sources) {
            var source = DataSource.create(Object.assign(config.sources[name], { name: name }));
            if (!source) {
                continue;
            }

            if (source.tiled) {
                self.sources.tiles[name] = source;
            } else {
                // Distribute object sources across workers
                if (source.id % self.num_workers === self._worker_id) {
                    // Load source if not cached
                    self.sources.objects[name] = source;
                    if (!self.objects[source.name]) {
                        self.objects[source.name] = {};
                        source.load(self.objects[source.name]);
                    }
                }
            }
        }

        // Expand styles
        self.config = Utils.stringsToFunctions(StyleParser.expandMacros(config), StyleParser.wrapFunction);
        self.styles = StyleManager.build(self.config.styles, { generation: self.generation });

        // Parse each top-level layer as a separate rule tree
        // TODO: find a more graceful way to incorporate this

        self.rules = parseRules(self.config.layers);

        // Sync tetxure info from main thread
        self.syncing_textures = self.syncTextures();

        // Return promise for when config refresh finishes
        self.configuring = self.syncing_textures.then(function () {
            Utils.log("debug", "updated config");
        });
    },

    // Returns a promise that fulfills when config refresh is finished
    awaitConfiguration: function awaitConfiguration() {
        return self.configuring;
    },

    // Build a tile: load from tile source if building for first time, otherwise rebuild with existing data
    buildTile: function buildTile(_ref) {
        var tile = _ref.tile;

        // Tile cached?
        if (self.tiles[tile.key] != null) {
            // Already loading?
            if (self.tiles[tile.key].loading === true) {
                return;
            }
        }

        // Update tile cache
        tile = self.tiles[tile.key] = Object.assign(self.tiles[tile.key] || {}, tile);

        // Update config (styles, etc.), then build tile
        return self.awaitConfiguration().then(function () {
            // First time building the tile
            if (tile.loaded !== true) {

                return new Promise(function (resolve, reject) {

                    tile.loading = true;
                    tile.loaded = false;
                    tile.error = null;

                    self.loadTileSourceData(tile).then(function () {
                        // Warn and continue on data source error
                        if (tile.source_data.error) {
                            Utils.log("warn", "tile load error(s) for " + tile.key + ": " + tile.source_data.error);
                        }

                        tile.loading = false;
                        tile.loaded = true;
                        Tile.buildGeometry(tile, self.config.layers, self.rules, self.styles).then(function (keys) {
                            resolve({ tile: Tile.slice(tile, keys) });
                        });
                    })["catch"](function (error) {
                        tile.loading = false;
                        tile.loaded = false;
                        tile.error = error.toString();
                        Utils.log("error", "tile load error for " + tile.key + ": " + error.stack);

                        resolve({ tile: Tile.slice(tile) });
                    });
                });
            }
            // Tile already loaded, just rebuild
            else {
                Utils.log("trace", "used worker cache for tile " + tile.key);

                // Build geometry
                return Tile.buildGeometry(tile, self.config.layers, self.rules, self.styles).then(function (keys) {
                    return { tile: Tile.slice(tile, keys) };
                });
            }
        });
    },

    // Load this tile's data source
    loadTileSourceData: function loadTileSourceData(tile) {
        return self.sources.tiles[tile.source].load(tile);
    },

    // Remove tile
    removeTile: function removeTile(key) {
        var tile = self.tiles[key];

        if (tile != null) {
            // Cancel if loading
            if (tile.loading === true) {
                Utils.log("trace", "cancel tile load for " + key);
                tile.loading = false;
            }

            Tile.cancel(tile);

            // Remove from cache
            FeatureSelection.clearTile(key);
            delete self.tiles[key];
            Utils.log("trace", "remove tile from cache for " + key);
        }
    },

    // Get a feature from the selection map
    getFeatureSelection: function getFeatureSelection() {
        var _ref = arguments[0] === undefined ? {} : arguments[0];

        var id = _ref.id;
        var key = _ref.key;

        var selection = FeatureSelection.map[key];

        return {
            id: id,
            feature: selection && selection.feature
        };
    },

    // Resets the feature selection state
    resetFeatureSelection: function resetFeatureSelection() {
        FeatureSelection.reset();
    },

    // Selection map size for this worker
    getFeatureSelectionMapSize: function getFeatureSelectionMapSize() {
        return FeatureSelection.getMapSize();
    },

    // Texture info needs to be synced from main thread
    syncTextures: function syncTextures() {
        // We're only syncing the textures that have sprites defined, since these are (currently) the only ones we
        // need info about for geometry construction (e.g. width/height, which we only know after the texture loads)
        var textures = [];
        if (self.config.textures) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = Utils.entries(self.config.textures)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var _step$value = _slicedToArray(_step.value, 2);

                    var texname = _step$value[0];
                    var texture = _step$value[1];

                    if (texture.sprites) {
                        textures.push(texname);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                        _iterator["return"]();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }

        Utils.log("trace", "sync textures to worker:", textures);
        if (textures.length > 0) {
            return Texture.syncTexturesToWorker(textures);
        }
        return Promise.resolve();
    },

    // Profiling helpers
    profile: function profile(name) {
        console.profile("worker " + self._worker_id + ": " + name);
    },

    profileEnd: function profileEnd(name) {
        console.profileEnd("worker " + self._worker_id + ": " + name);
    }

});

},{"./gl/texture":81,"./selection":92,"./sources/data_source":93,"./styles/rule":101,"./styles/style_manager":103,"./styles/style_parser":104,"./tile":110,"./utils/utils":115,"./utils/worker_broker":117}],92:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var Texture = _interopRequire(require("./gl/texture"));

var WorkerBroker = _interopRequire(require("./utils/worker_broker"));

var FeatureSelection = (function () {
    function FeatureSelection(gl, workers) {
        _classCallCheck(this, FeatureSelection);

        this.gl = gl;
        this.workers = workers; // pool of workers to request feature look-ups from, keyed by id
        this.init();
    }

    _createClass(FeatureSelection, {
        init: {
            value: function init() {
                // Selection state tracking
                this.requests = {}; // pending selection requests
                this.feature = null; // currently selected feature
                this.read_delay = 5; // delay time from selection render to framebuffer sample, to avoid CPU/GPU sync lock
                this.read_delay_timer = null; // current timer (setTimeout) for delayed selection reads

                this.pixel = new Uint8Array(4);
                this.pixel32 = new Float32Array(this.pixel.buffer);

                // Frame buffer for selection
                // TODO: initiate lazily in case we don't need to do any selection
                this.fbo = this.gl.createFramebuffer();
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo);
                this.fbo_size = { width: 256, height: 256 }; // TODO: make configurable / adaptive based on canvas size
                this.fbo_size.aspect = this.fbo_size.width / this.fbo_size.height;

                // Texture for the FBO color attachment
                var fbo_texture = new Texture(this.gl, "selection_fbo");
                fbo_texture.setData(this.fbo_size.width, this.fbo_size.height, null, { filtering: "nearest" });
                this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, fbo_texture.texture, 0);

                // Renderbuffer for the FBO depth attachment
                var fbo_depth_rb = this.gl.createRenderbuffer();
                this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, fbo_depth_rb);
                this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, this.fbo_size.width, this.fbo_size.height);
                this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, fbo_depth_rb);

                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
            }
        },
        destroy: {
            value: function destroy() {
                if (this.gl && this.fbo) {
                    this.gl.deleteFramebuffer(this.fbo);
                    this.fbo = null;
                    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
                }

                // TODO: free texture?
            }
        },
        bind: {
            value: function bind() {
                // Switch to FBO
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo);
                this.gl.viewport(0, 0, this.fbo_size.width, this.fbo_size.height);
            }
        },
        getFeatureAt: {

            // Request feature selection
            // Runs asynchronously, schedules selection buffer to be updated

            value: function getFeatureAt(point) {
                var _this = this;

                return new Promise(function (resolve, reject) {
                    // Queue requests for feature selection, and they will be picked up by the render loop
                    _this.selection_request_id = _this.selection_request_id + 1 || 0;
                    _this.requests[_this.selection_request_id] = {
                        type: "point",
                        id: _this.selection_request_id,
                        point: point,
                        resolve: resolve
                    };
                });
            }
        },
        pendingRequests: {

            // Any pending selection requests

            value: function pendingRequests() {
                return this.requests;
            }
        },
        read: {

            // Read pending results from the selection buffer. Called after rendering to selection buffer.

            value: function read() {
                var _this = this;

                // Delay reading the pixel result from the selection buffer to avoid CPU/GPU sync lock.
                // Calling readPixels synchronously caused a massive performance hit, presumably since it
                // forced this function to wait for the GPU to finish rendering and retrieve the texture contents.
                if (this.read_delay_timer != null) {
                    clearTimeout(this.read_delay_timer);
                }
                this.read_delay_timer = setTimeout(function () {
                    var gl = _this.gl;

                    gl.bindFramebuffer(gl.FRAMEBUFFER, _this.fbo);

                    for (var r in _this.requests) {
                        var request = _this.requests[r];

                        // This request was already sent to the worker, we're just awaiting its reply
                        if (request.sent) {
                            continue;
                        }

                        // TODO: support other selection types, such as features within a box
                        if (request.type !== "point") {
                            continue;
                        }

                        // Check selection map against FBO
                        gl.readPixels(Math.floor(request.point.x * _this.fbo_size.width), Math.floor((1 - request.point.y) * _this.fbo_size.height), 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, _this.pixel);
                        var feature_key = _this.pixel[0] + (_this.pixel[1] << 8) + (_this.pixel[2] << 16) + (_this.pixel[3] << 24) >>> 0;

                        // If feature found, ask appropriate web worker to lookup feature
                        var worker_id = _this.pixel[3];
                        if (worker_id !== 255) {
                            // 255 indicates an empty selection buffer pixel
                            if (_this.workers[worker_id] != null) {
                                WorkerBroker.postMessage(_this.workers[worker_id], "getFeatureSelection", { id: request.id, key: feature_key }).then(function (message) {
                                    _this.finishRead(message);
                                });
                            }
                        }
                        // No feature found, but still need to resolve promise
                        else {
                            _this.finishRead({ id: request.id, feature: null });
                        }

                        request.sent = true;
                    }

                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                }, this.read_delay);
            }
        },
        finishRead: {

            // Called on main thread when a web worker finds a feature in the selection buffer

            value: function finishRead(message) {
                var request = this.requests[message.id];
                if (!request) {
                    throw new Error("FeatureSelection.finishRead() called without any message");
                }

                var feature = message.feature;
                var changed = false;
                if (feature != null && this.feature == null || feature == null && this.feature != null || feature != null && this.feature != null && feature.id !== this.feature.id) {
                    changed = true;
                }

                this.feature = feature; // store the most recently selected feature

                // Resolve the request
                request.resolve({ feature: feature, changed: changed, request: request });
                delete this.requests[message.id]; // done processing this request
            }
        }
    }, {
        makeEntry: {

            // Selection map generation
            // Each worker will create its own independent, 'local' selection map

            // Create a unique 32-bit color to identify a feature
            // Workers independently create/modify selection colors in their own threads, but we also
            // need the main thread to know where each feature color originated. To accomplish this,
            // we partition the map by setting the 4th component (alpha channel) to the worker's id.

            value: function makeEntry(tile) {
                // 32-bit color key
                this.map_entry++;
                var ir = this.map_entry & 255;
                var ig = this.map_entry >> 8 & 255;
                var ib = this.map_entry >> 16 & 255;
                var ia = this.map_prefix;
                var r = ir / 255;
                var g = ig / 255;
                var b = ib / 255;
                var a = ia / 255;
                var key = ir + (ig << 8) + (ib << 16) + (ia << 24) >>> 0; // need unsigned right shift to convert to positive #

                this.map[key] = {
                    color: [r, g, b, a] };
                this.map_size++;

                this.tiles[tile.key] = this.tiles[tile.key] || [];
                this.tiles[tile.key].push(key);

                return this.map[key];
            }
        },
        makeColor: {
            value: function makeColor(feature, tile) {
                var selector = this.makeEntry(tile);
                selector.feature = {
                    id: feature.id,
                    properties: feature.properties,
                    tile: tile.key
                };

                return selector.color;
            }
        },
        reset: {
            value: function reset() {
                this.map = {};
                this.map_size = 0;
                this.map_entry = 0;
            }
        },
        clearTile: {
            value: function clearTile(key) {
                var _this = this;

                if (Array.isArray(this.tiles[key])) {
                    this.tiles[key].forEach(function (k) {
                        return delete _this.map[k];
                    });
                    this.map_size -= this.tiles[key].length;
                    delete this.tiles[key];
                }
            }
        },
        getMapSize: {
            value: function getMapSize() {
                return this.map_size;
            }
        },
        setPrefix: {
            value: function setPrefix(prefix) {
                this.map_prefix = prefix;
            }
        }
    });

    return FeatureSelection;
})();

module.exports = FeatureSelection;

// Static properties
FeatureSelection.map = {}; // this will be unique per module instance (so unique per worker)
FeatureSelection.tiles = {}; // selection keys, by tile
FeatureSelection.map_size = 0;
FeatureSelection.map_entry = 0;
FeatureSelection.map_prefix = 0; // set by worker to worker id #
FeatureSelection.defaultColor = [0, 0, 0, 1];

},{"./gl/texture":81,"./utils/worker_broker":117}],93:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

Object.defineProperty(exports, "__esModule", {
    value: true
});
/*jshint worker: true */

var Geo = _interopRequire(require("../geo"));

var MethodNotImplemented = require("../utils/errors").MethodNotImplemented;

var Utils = _interopRequire(require("../utils/utils"));

var DataSource = (function () {
    function DataSource(source) {
        _classCallCheck(this, DataSource);

        this.id = source.id;
        this.name = source.name;
        this.url = source.url;
        this.pad_scale = source.pad_scale || 0.0005; // scale tile up by small factor to cover seams
        this.enforce_winding = source.enforce_winding || false; // whether to enforce winding order

        // Optional function to transform source data
        this.transform = source.transform;
        if (typeof this.transform === "function") {
            this.transform.bind(this);
        }

        // Optional additional data to pass to the transform function
        this.extra_data = source.extra_data;

        // Optional additional scripts made available to the transform function
        if (typeof importScripts === "function" && source.scripts) {
            source.scripts.forEach(function (s, si) {
                try {
                    importScripts(s);
                    Utils.log("info", "DataSource: loaded library: " + s);
                } catch (e) {
                    Utils.log("error", "DataSource: failed to load library: " + s);
                    Utils.log("error", e);
                }
            });
        }

        // overzoom will apply for zooms higher than this
        this.max_zoom = Math.min(source.max_zoom || Geo.max_zoom, Geo.max_zoom);
    }

    _createClass(DataSource, {
        load: {
            value: function load(dest) {
                var _this = this;

                dest.source_data = {};
                dest.source_data.layers = {};
                dest.pad_scale = this.pad_scale;

                return this._load(dest).then(function (dest) {
                    // Post-processing
                    for (var layer in dest.source_data.layers) {
                        var data = dest.source_data.layers[layer];
                        if (data && data.features) {
                            data.features.forEach(function (feature) {
                                Geo.transformGeometry(feature.geometry, function (coord) {
                                    // Flip Y coords
                                    coord[1] = -coord[1];

                                    // Slightly scale up tile to cover seams
                                    if (_this.pad_scale) {
                                        coord[0] = Math.round(coord[0] * (1 + _this.pad_scale) - Geo.tile_scale * _this.pad_scale / 2);
                                        coord[1] = Math.round(coord[1] * (1 + _this.pad_scale) - Geo.tile_scale * _this.pad_scale / 2);
                                    }
                                });

                                // Optionally enforce winding order since not all data sources guarantee it
                                if (_this.enforce_winding) {
                                    Geo.enforceWinding(feature.geometry, "CCW");
                                }
                            });
                        }
                    }
                });
            }
        },
        _load: {

            // Sub-classes must implement

            value: function _load(dest) {
                throw new MethodNotImplemented("_load");
            }
        }
    }, {
        create: {

            // Create a tile source by type, factory-style

            value: function create(source) {
                if (DataSource.types[source.type]) {
                    return new DataSource.types[source.type](source);
                }
            }
        },
        projectData: {

            // Mercator projection

            value: function projectData(source) {
                var timer = +new Date();
                for (var t in source.layers) {
                    var num_features = source.layers[t].features.length;
                    for (var f = 0; f < num_features; f++) {
                        var feature = source.layers[t].features[f];
                        Geo.transformGeometry(feature.geometry, function (coord) {
                            var _Geo$latLngToMeters = Geo.latLngToMeters(coord);

                            var _Geo$latLngToMeters2 = _slicedToArray(_Geo$latLngToMeters, 2);

                            var x = _Geo$latLngToMeters2[0];
                            var y = _Geo$latLngToMeters2[1];

                            coord[0] = x;
                            coord[1] = y;
                        });
                    }
                }

                if (source.debug !== undefined) {
                    source.debug.projection = +new Date() - timer;
                }
            }
        },
        scaleData: {

            /**
             Re-scale geometries within each source to internal tile units
            */

            value: function scaleData(source, _ref) {
                var z = _ref.coords.z;
                var min = _ref.min;
                var max = _ref.max;

                for (var t in source.layers) {
                    var num_features = source.layers[t].features.length;
                    for (var f = 0; f < num_features; f++) {
                        var feature = source.layers[t].features[f];
                        Geo.transformGeometry(feature.geometry, function (coord) {
                            coord[0] = (coord[0] - min.x) * Geo.units_per_meter[z];
                            coord[1] = (coord[1] - min.y) * Geo.units_per_meter[z] * -1; // flip coords positive
                        });
                    }
                }
            }
        },
        register: {

            // Register a new data source type, under a type name

            value: function register(type_class, type_name) {
                if (!type_class || !type_name) {
                    return;
                }

                DataSource.types[type_name] = type_class;
            }
        }
    });

    return DataSource;
})();

exports["default"] = DataSource;

DataSource.types = {}; // set of supported data source classes, referenced by type name

/*** Generic network loading source - abstract class ***/

var NetworkSource = exports.NetworkSource = (function (_DataSource) {
    function NetworkSource(source) {
        _classCallCheck(this, NetworkSource);

        _get(Object.getPrototypeOf(NetworkSource.prototype), "constructor", this).call(this, source);
        this.response_type = ""; // use to set explicit XHR type
    }

    _inherits(NetworkSource, _DataSource);

    _createClass(NetworkSource, {
        _load: {
            value: function _load(dest) {
                var _this = this;

                // super.load(dest);

                var url = this.formatUrl(dest);

                var source_data = dest.source_data;
                source_data.url = url;
                dest.debug = dest.debug || {};
                dest.debug.network = +new Date();

                return new Promise(function (resolve, reject) {
                    source_data.error = null;
                    // For testing network errors
                    // var promise = Utils.io(url, 60 * 100, this.response_type);
                    // if (Math.random() < .7) {
                    //     promise = Promise.reject(Error('fake data source error'));
                    // }
                    // promise.then((body) => {
                    var promise = Utils.io(url, 60 * 1000, _this.response_type);
                    source_data.request = promise.request;

                    promise.then(function (body) {
                        dest.debug.response_size = body.length || body.byteLength;
                        dest.debug.network = +new Date() - dest.debug.network;
                        dest.debug.parsing = +new Date();
                        _this.parseSourceData(dest, source_data, body);
                        dest.debug.parsing = +new Date() - dest.debug.parsing;
                        resolve(dest);
                    })["catch"](function (error) {
                        source_data.error = error.toString();
                        resolve(dest); // resolve request but pass along error
                    });
                });
            }
        },
        formatUrl: {

            // Sub-classes must implement:

            value: function formatUrl(dest) {
                throw new MethodNotImplemented("formatUrl");
            }
        },
        parseSourceData: {
            value: function parseSourceData(dest, source, reponse) {
                throw new MethodNotImplemented("parseSourceData");
            }
        }
    });

    return NetworkSource;
})(DataSource);

/*** Generic network tile loading - abstract class ***/

var NetworkTileSource = exports.NetworkTileSource = (function (_NetworkSource) {
    function NetworkTileSource(source) {
        _classCallCheck(this, NetworkTileSource);

        _get(Object.getPrototypeOf(NetworkTileSource.prototype), "constructor", this).call(this, source);

        this.tiled = true;
        this.url_hosts = null;
        var host_match = this.url.match(/{s:\[([^}+]+)\]}/);
        if (host_match != null && host_match.length > 1) {
            this.url_hosts = host_match[1].split(",");
            this.next_host = 0;
        }
    }

    _inherits(NetworkTileSource, _NetworkSource);

    _createClass(NetworkTileSource, {
        formatUrl: {
            value: function formatUrl(tile) {
                var coords = Geo.wrapTile(tile.coords, { x: true });
                var url = this.url.replace("{x}", coords.x).replace("{y}", coords.y).replace("{z}", coords.z);

                if (this.url_hosts != null) {
                    url = url.replace(/{s:\[([^}+]+)\]}/, this.url_hosts[this.next_host]);
                    this.next_host = (this.next_host + 1) % this.url_hosts.length;
                }
                return url;
            }
        },
        urlHasTilePattern: {

            // Checks for the x/y/z tile pattern in URL template

            value: function urlHasTilePattern(url) {
                return url && url.search("{x}") > -1 && url.search("{y}") > -1 && url.search("{z}") > -1;
            }
        }
    });

    return NetworkTileSource;
})(NetworkSource);

},{"../geo":73,"../utils/errors":112,"../utils/utils":115}],94:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _data_source = require("./data_source");

var DataSource = _interopRequire(_data_source);

var NetworkSource = _data_source.NetworkSource;
var NetworkTileSource = _data_source.NetworkTileSource;

var Geo = _interopRequire(require("../geo"));

// For tiling GeoJSON client-side

var geojsonvt = _interopRequire(require("geojson-vt"));

/**
 Mapzen/OSM.US-style GeoJSON vector tiles
 @class GeoJSONTileSource
*/

var GeoJSONTileSource = exports.GeoJSONTileSource = (function (_NetworkTileSource) {
    function GeoJSONTileSource(source) {
        _classCallCheck(this, GeoJSONTileSource);

        _get(Object.getPrototypeOf(GeoJSONTileSource.prototype), "constructor", this).call(this, source);

        // Check for URL tile pattern, if not found, treat as standalone GeoJSON/TopoJSON object
        if (!this.urlHasTilePattern(this.url)) {
            // Check instance type from parent class
            if (this instanceof GeoJSONTileSource) {
                // Replace instance type
                return new GeoJSONSource(source);
            } else {
                // Pass back to parent class to instantiate
                return null;
            }
        }
        return this;
    }

    _inherits(GeoJSONTileSource, _NetworkTileSource);

    _createClass(GeoJSONTileSource, {
        parseSourceData: {
            value: function parseSourceData(tile, source, response) {
                var data = JSON.parse(response);
                this.prepareGeoJSON(data, tile, source);
            }
        },
        prepareGeoJSON: {
            value: function prepareGeoJSON(data, tile, source) {
                // Apply optional data transform
                if (typeof this.transform === "function") {
                    data = this.transform(data, source);
                }

                source.layers = GeoJSONSource.prototype.getLayers(data);

                // A "synthetic" tile that adjusts the tile min anchor to account for tile longitude wrapping
                var anchor = {
                    coords: tile.coords,
                    min: Geo.metersForTile(Geo.wrapTile(tile.coords, { x: true }))
                };

                DataSource.projectData(source); // mercator projection
                DataSource.scaleData(source, anchor); // re-scale from meters to local tile coords
            }
        }
    });

    return GeoJSONTileSource;
})(NetworkTileSource);

/**
 GeoJSON standalone (non-tiled) source
 Uses geojson-vt split into tiles client-side
*/

var GeoJSONSource = exports.GeoJSONSource = (function (_NetworkSource) {
    function GeoJSONSource(source) {
        _classCallCheck(this, GeoJSONSource);

        _get(Object.getPrototypeOf(GeoJSONSource.prototype), "constructor", this).call(this, source);
        this.tiled = true;
        this.load_data = null;
        this.tile_indexes = {}; // geojson-vt tile indices, by layer name
        this.max_zoom = Math.max(this.max_zoom || 0, 15); // TODO: max zoom < 15 causes artifacts/no-draw at 20, investigate
        this.pad_scale = 0; // we don't want padding on auto-tiled sources
        this.enforce_winding = source.enforce_winding === false ? false : true; // default on, can be forced off
    }

    _inherits(GeoJSONSource, _NetworkSource);

    _createClass(GeoJSONSource, {
        _load: {
            value: function _load(dest) {
                var _this = this;

                if (!this.load_data) {
                    this.load_data = _get(Object.getPrototypeOf(GeoJSONSource.prototype), "_load", this).call(this, { source_data: { layers: {} } }).then(function (data) {
                        var layers = data.source_data.layers;
                        for (var layer_name in layers) {
                            _this.tile_indexes[layer_name] = geojsonvt(layers[layer_name], {
                                maxZoom: _this.max_zoom, // max zoom to preserve detail on
                                tolerance: 3, // simplification tolerance (higher means simpler)
                                extent: Geo.tile_scale, // tile extent (both width and height)
                                buffer: 0 // tile buffer on each side
                            });
                        }

                        _this.loaded = true;
                        return data;
                    });
                }

                return this.load_data.then(function () {
                    for (var layer_name in _this.tile_indexes) {
                        dest.source_data.layers[layer_name] = _this.getTileFeatures(dest, layer_name);
                    }
                    return dest;
                });
            }
        },
        getTileFeatures: {
            value: function getTileFeatures(tile, layer_name) {
                var coords = Geo.wrapTile(tile.coords, { x: true });

                // request a particular tile
                var t = this.tile_indexes[layer_name].getTile(coords.z, coords.x, coords.y);

                // Convert from MVT-style JSON struct to GeoJSON
                var collection = undefined;
                if (t && t.features) {
                    collection = {
                        type: "FeatureCollection",
                        features: []
                    };

                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = t.features[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var feature = _step.value;

                            // Copy geometry (don't want to modify internal geojson-vt data)
                            var geom = feature.geometry.map(function (ring) {
                                return ring.map(function (coord) {
                                    return [coord[0], coord[1]];
                                });
                            });

                            var type = undefined;
                            if (feature.type === 1) {
                                type = "MultiPoint";
                            } else if (feature.type === 2) {
                                type = "MultiLineString";
                            } else if (feature.type === 3) {
                                type = "MultiPolygon";
                                geom = this.decodeMultiPolygon(geom); // un-flatten rings
                            } else {
                                continue;
                            }

                            var f = {
                                type: "Feature",
                                geometry: {
                                    type: type,
                                    coordinates: geom
                                },
                                properties: feature.tags
                            };

                            collection.features.push(f);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator["return"]) {
                                _iterator["return"]();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }

                return collection;
            }
        },
        decodeMultiPolygon: {

            // Decode multipolygons, which are encoded as a single set of rings
            // Outer rings are wound CCW, inner are CW
            // A CCW ring indicates the start of a new polygon

            value: function decodeMultiPolygon(geom) {
                var polys = [];
                var poly = [];
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = geom[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var ring = _step.value;

                        var winding = Geo.ringWinding(ring);
                        if (winding === "CCW" && poly.length > 0) {
                            polys.push(poly);
                            poly = [];
                        }
                        poly.push(ring);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                if (poly.length > 0) {
                    polys.push(poly);
                }
                return polys;
            }
        },
        formatUrl: {
            value: function formatUrl(dest) {
                return this.url;
            }
        },
        parseSourceData: {
            value: function parseSourceData(tile, source, response) {
                source.layers = this.getLayers(JSON.parse(response));
            }
        },
        getLayers: {

            // Detect single or multiple layers in returned data

            value: function getLayers(data) {
                if (data.type === "Feature" || data.type === "FeatureCollection") {
                    return { _default: data };
                } else {
                    return data;
                }
            }
        }
    });

    return GeoJSONSource;
})(NetworkSource);

DataSource.register(GeoJSONTileSource, "GeoJSON"); // prefered shorter name
DataSource.register(GeoJSONTileSource, "GeoJSONTiles"); // for backwards-compatibility

},{"../geo":73,"./data_source":93,"geojson-vt":23}],95:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _data_source = require("./data_source");

var DataSource = _interopRequire(_data_source);

var NetworkTileSource = _data_source.NetworkTileSource;

var Pbf = _interopRequire(require("pbf"));

var _vectorTile = require("vector-tile");

var VectorTile = _vectorTile.VectorTile;
var VectorTileFeature = _vectorTile.VectorTileFeature;

/**
 Mapbox Vector Tile format
 @class MVTSource
*/

var MVTSource = exports.MVTSource = (function (_NetworkTileSource) {
    function MVTSource(source) {
        _classCallCheck(this, MVTSource);

        _get(Object.getPrototypeOf(MVTSource.prototype), "constructor", this).call(this, source);
        this.response_type = "arraybuffer"; // binary data
    }

    _inherits(MVTSource, _NetworkTileSource);

    _createClass(MVTSource, {
        parseSourceData: {
            value: function parseSourceData(tile, source, response) {
                // Convert Mapbox vector tile to GeoJSON
                var data = new Uint8Array(response);
                var buffer = new Pbf(data);
                source.data = new VectorTile(buffer);
                source.layers = this.toGeoJSON(source.data);
                delete source.data; // comment out to save raw data for debugging
            }
        },
        toGeoJSON: {

            // Loop through layers/features using Mapbox lib API, convert to GeoJSON features
            // Returns an object with keys for each layer, e.g. { layer: geojson }

            value: function toGeoJSON(tile) {
                var layers = {};
                for (var l in tile.layers) {
                    var layer = tile.layers[l];
                    var layer_geojson = {
                        type: "FeatureCollection",
                        features: []
                    };

                    for (var f = 0; f < layer.length; f++) {
                        var feature = layer.feature(f);
                        var feature_geojson = {
                            type: "Feature",
                            geometry: {},
                            properties: feature.properties
                        };

                        var geometry = feature_geojson.geometry;
                        var coordinates = feature.loadGeometry();
                        for (var r = 0; r < coordinates.length; r++) {
                            var ring = coordinates[r];
                            for (var c = 0; c < ring.length; c++) {
                                ring[c] = [ring[c].x, ring[c].y];
                            }
                        }
                        geometry.coordinates = coordinates;

                        if (VectorTileFeature.types[feature.type] === "Point") {
                            geometry.type = "Point";
                            geometry.coordinates = geometry.coordinates[0][0];
                        } else if (VectorTileFeature.types[feature.type] === "LineString") {
                            if (coordinates.length === 1) {
                                geometry.type = "LineString";
                                geometry.coordinates = geometry.coordinates[0];
                            } else {
                                geometry.type = "MultiLineString";
                            }
                        } else if (VectorTileFeature.types[feature.type] === "Polygon") {
                            geometry.type = "Polygon";
                        }

                        layer_geojson.features.push(feature_geojson);
                    }
                    layers[l] = layer_geojson;
                }
                return layers;
            }
        }
    });

    return MVTSource;
})(NetworkTileSource);

DataSource.register(MVTSource, "MVT");

},{"./data_source":93,"pbf":63,"vector-tile":67}],96:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

Object.defineProperty(exports, "__esModule", {
    value: true
});

var DataSource = _interopRequire(require("./data_source"));

var _geojson = require("./geojson");

var GeoJSONSource = _geojson.GeoJSONSource;
var GeoJSONTileSource = _geojson.GeoJSONTileSource;

var topojson = _interopRequire(require("topojson"));

/**
 Mapzen/OSM.US-style TopoJSON vector tiles
 @class TopoJSONTileSource
*/

var TopoJSONTileSource = exports.TopoJSONTileSource = (function (_GeoJSONTileSource) {
    function TopoJSONTileSource(source) {
        _classCallCheck(this, TopoJSONTileSource);

        var _this = _get(Object.getPrototypeOf(TopoJSONTileSource.prototype), "constructor", this).call(this, source);

        // Replace with non-tiled source if tiled source failed to instantiate
        if (_this !== this) {
            return new TopoJSONSource(source);
        }
    }

    _inherits(TopoJSONTileSource, _GeoJSONTileSource);

    _createClass(TopoJSONTileSource, {
        parseSourceData: {
            value: function parseSourceData(tile, source, response) {
                var data = JSON.parse(response);
                data = TopoJSONSource.prototype.toGeoJSON(data);
                this.prepareGeoJSON(data, tile, source);
            }
        }
    });

    return TopoJSONTileSource;
})(GeoJSONTileSource);

/**
 TopoJSON standalone (non-tiled) source
 Uses geojson-vt split into tiles client-side
*/

var TopoJSONSource = exports.TopoJSONSource = (function (_GeoJSONSource) {
    function TopoJSONSource() {
        _classCallCheck(this, TopoJSONSource);

        if (_GeoJSONSource != null) {
            _GeoJSONSource.apply(this, arguments);
        }
    }

    _inherits(TopoJSONSource, _GeoJSONSource);

    _createClass(TopoJSONSource, {
        parseSourceData: {
            value: function parseSourceData(tile, source, response) {
                var data = JSON.parse(response);
                data = this.toGeoJSON(data);
                source.layers = this.getLayers(data);
            }
        },
        toGeoJSON: {
            value: function toGeoJSON(data) {
                // Single layer
                if (data.objects && Object.keys(data.objects).length === 1) {
                    var layer = Object.keys(data.objects)[0];
                    data = topojson.feature(data, data.objects[layer]);
                }
                // Multiple layers
                else {
                    var layers = {};
                    for (var key in data.objects) {
                        layers[key] = topojson.feature(data, data.objects[key]);
                    }
                    data = layers;
                }
                return data;
            }
        }
    });

    return TopoJSONSource;
})(GeoJSONSource);

DataSource.register(TopoJSONTileSource, "TopoJSON"); // prefered shorter name
DataSource.register(TopoJSONTileSource, "TopoJSONTiles"); // for backwards-compatibility

},{"./data_source":93,"./geojson":94,"topojson":66}],97:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

// Geometry building functions

var Vector = _interopRequire(require("../vector"));

var Geo = _interopRequire(require("../geo"));

var earcut = _interopRequire(require("earcut"));

var Builders;
module.exports = Builders = {};

Builders.debug = false;

Builders.tile_bounds = [{ x: 0, y: 0 }, { x: Geo.tile_scale, y: -Geo.tile_scale } // TODO: correct for flipped y-axis?
];

// Re-scale UVs from [0, 1] range to a smaller area within the image
Builders.scaleTexcoordsToSprite = function (uv, area_origin, area_size, tex_size) {
    var area_origin_y = tex_size[1] - area_origin[1] - area_size[1];
    var suv = [];
    suv[0] = (uv[0] * area_size[0] + area_origin[0]) / tex_size[0];
    suv[1] = (uv[1] * area_size[1] + area_origin_y) / tex_size[1];
    return suv;
};

Builders.getTexcoordsForSprite = function (area_origin, area_size, tex_size) {
    return [Builders.scaleTexcoordsToSprite([0, 0], area_origin, area_size, tex_size), Builders.scaleTexcoordsToSprite([1, 1], area_origin, area_size, tex_size)];
};

// Tesselate a flat 2D polygon
// x & y coordinates will be set as first two elements of provided vertex_template
Builders.buildPolygons = function (polygons, vertex_data, vertex_template, _ref) {
    var texcoord_index = _ref.texcoord_index;
    var texcoord_scale = _ref.texcoord_scale;
    var texcoord_normalize = _ref.texcoord_normalize;

    if (texcoord_index) {
        texcoord_normalize = texcoord_normalize || 1;

        var _ref2 = texcoord_scale || [[0, 0], [1, 1]];

        var _ref22 = _slicedToArray(_ref2, 2);

        var _ref22$0 = _slicedToArray(_ref22[0], 2);

        var min_u = _ref22$0[0];
        var min_v = _ref22$0[1];

        var _ref22$1 = _slicedToArray(_ref22[1], 2);

        var max_u = _ref22$1[0];
        var max_v = _ref22$1[1];
    }

    var num_polygons = polygons.length;
    for (var p = 0; p < num_polygons; p++) {
        var polygon = polygons[p];

        // Find polygon extents to calculate UVs, fit them to the axis-aligned bounding box
        if (texcoord_index) {
            var _Geo$findBoundingBox = Geo.findBoundingBox(polygon);

            var _Geo$findBoundingBox2 = _slicedToArray(_Geo$findBoundingBox, 4);

            var min_x = _Geo$findBoundingBox2[0];
            var min_y = _Geo$findBoundingBox2[1];
            var max_x = _Geo$findBoundingBox2[2];
            var max_y = _Geo$findBoundingBox2[3];

            var span_x = max_x - min_x;
            var span_y = max_y - min_y;
            var scale_u = (max_u - min_u) / span_x;
            var scale_v = (max_v - min_v) / span_y;
        }

        // Tessellate
        var vertices = Builders.triangulatePolygon(polygon);

        // Add vertex data
        var num_vertices = vertices.length;
        for (var v = 0; v < num_vertices; v++) {
            var vertex = vertices[v];
            vertex_template[0] = vertex[0];
            vertex_template[1] = vertex[1];

            // Add UVs
            if (texcoord_index) {
                vertex_template[texcoord_index + 0] = ((vertex[0] - min_x) * scale_u + min_u) * texcoord_normalize;
                vertex_template[texcoord_index + 1] = ((vertex[1] - min_y) * scale_v + min_v) * texcoord_normalize;
            }

            vertex_data.addVertex(vertex_template);
        }
    }
};

// Tesselate and extrude a flat 2D polygon into a simple 3D model with fixed height and add to GL vertex buffer
Builders.buildExtrudedPolygons = function (polygons, z, height, min_height, vertex_data, vertex_template, normal_index, normal_normalize, _ref) {
    var texcoord_index = _ref.texcoord_index;
    var texcoord_scale = _ref.texcoord_scale;
    var texcoord_normalize = _ref.texcoord_normalize;

    // Top
    var min_z = z + (min_height || 0);
    var max_z = z + height;
    vertex_template[2] = max_z;
    Builders.buildPolygons(polygons, vertex_data, vertex_template, { texcoord_index: texcoord_index, texcoord_scale: texcoord_scale, texcoord_normalize: texcoord_normalize });

    // Walls
    // Fit UVs to wall quad
    if (texcoord_index) {
        texcoord_normalize = texcoord_normalize || 1;

        var _ref2 = texcoord_scale || [[0, 0], [1, 1]];

        var _ref22 = _slicedToArray(_ref2, 2);

        var _ref22$0 = _slicedToArray(_ref22[0], 2);

        var min_u = _ref22$0[0];
        var min_v = _ref22$0[1];

        var _ref22$1 = _slicedToArray(_ref22[1], 2);

        var max_u = _ref22$1[0];
        var max_v = _ref22$1[1];

        var texcoords = [[min_u, max_v], [min_u, min_v], [max_u, min_v], [max_u, min_v], [max_u, max_v], [min_u, max_v]];
    }

    var num_polygons = polygons.length;
    for (var p = 0; p < num_polygons; p++) {
        var polygon = polygons[p];

        for (var q = 0; q < polygon.length; q++) {
            var contour = polygon[q];

            for (var w = 0; w < contour.length - 1; w++) {
                // Two triangles for the quad formed by each vertex pair, going from bottom to top height
                var wall_vertices = [
                // Triangle
                [contour[w + 1][0], contour[w + 1][1], max_z], [contour[w + 1][0], contour[w + 1][1], min_z], [contour[w][0], contour[w][1], min_z],
                // Triangle
                [contour[w][0], contour[w][1], min_z], [contour[w][0], contour[w][1], max_z], [contour[w + 1][0], contour[w + 1][1], max_z]];

                // Calc the normal of the wall from up vector and one segment of the wall triangles
                var normal = Vector.cross([0, 0, 1], Vector.normalize([contour[w + 1][0] - contour[w][0], contour[w + 1][1] - contour[w][1], 0]));

                // Update vertex template with current surface normal
                vertex_template[normal_index + 0] = normal[0] * normal_normalize;
                vertex_template[normal_index + 1] = normal[1] * normal_normalize;
                vertex_template[normal_index + 2] = normal[2] * normal_normalize;

                for (var wv = 0; wv < wall_vertices.length; wv++) {
                    vertex_template[0] = wall_vertices[wv][0];
                    vertex_template[1] = wall_vertices[wv][1];
                    vertex_template[2] = wall_vertices[wv][2];

                    if (texcoord_index) {
                        vertex_template[texcoord_index + 0] = texcoords[wv][0] * texcoord_normalize;
                        vertex_template[texcoord_index + 1] = texcoords[wv][1] * texcoord_normalize;
                    }

                    vertex_data.addVertex(vertex_template);
                }
            }
        }
    }
};

// Build tessellated triangles for a polyline
Builders.buildPolylines = function (lines, width, vertex_data, vertex_template, _ref) {
    var closed_polygon = _ref.closed_polygon;
    var remove_tile_edges = _ref.remove_tile_edges;
    var tile_edge_tolerance = _ref.tile_edge_tolerance;
    var texcoord_index = _ref.texcoord_index;
    var texcoord_scale = _ref.texcoord_scale;
    var texcoord_normalize = _ref.texcoord_normalize;
    var scaling_index = _ref.scaling_index;
    var scaling_normalize = _ref.scaling_normalize;
    var join = _ref.join;
    var cap = _ref.cap;

    var cornersOnCap = cap === "square" ? 2 : cap === "round" ? 3 : 0; // Butt is the implicit default
    var trianglesOnJoin = join === "bevel" ? 1 : join === "round" ? 3 : 0; // Miter is the implicit default

    // Build variables
    texcoord_normalize = texcoord_normalize || 1;

    var _ref2 = texcoord_scale || [[0, 0], [1, 1]];

    var _ref22 = _slicedToArray(_ref2, 2);

    var _ref22$0 = _slicedToArray(_ref22[0], 2);

    var min_u = _ref22$0[0];
    var min_v = _ref22$0[1];

    var _ref22$1 = _slicedToArray(_ref22[1], 2);

    var max_u = _ref22$1[0];
    var max_v = _ref22$1[1];

    // Values that are constant for each line and are passed to helper functions
    var constants = {
        vertex_data: vertex_data,
        vertex_template: vertex_template,
        halfWidth: width / 2,
        vertices: [],
        scaling_index: scaling_index,
        scaling_normalize: scaling_normalize,
        scalingVecs: scaling_index && [],
        texcoord_index: texcoord_index,
        texcoords: texcoord_index && [],
        texcoord_normalize: texcoord_normalize,
        min_u: min_u, min_v: min_v, max_u: max_u, max_v: max_v,
        nPairs: 0
    };

    for (var ln = 0; ln < lines.length; ln++) {
        var line = lines[ln];
        var lineSize = line.length;

        // Ignore non-lines
        if (lineSize < 2) {
            continue;
        }

        //  Initialize variables
        var coordPrev = [0, 0],
            // Previous point coordinates
        coordCurr = [0, 0],
            // Current point coordinates
        coordNext = [0, 0]; // Next point coordinates

        var normPrev = [0, 0],
            // Right normal to segment between previous and current m_points
        normCurr = [0, 0],
            // Right normal at current point, scaled for miter joint
        normNext = [0, 0]; // Right normal to segment between current and next m_points

        var isPrev = false,
            isNext = true;

        // Add vertices to buffer according to their index
        indexPairs(constants);

        // Do this with the rest (except the last one)
        for (var i = 0; i < lineSize; i++) {

            // There is a next one?
            isNext = i + 1 < lineSize;

            if (isPrev) {
                // If there is a previous one, copy the current (previous) values on *Prev
                coordPrev = coordCurr;
                normPrev = Vector.normalize(Vector.perp(coordPrev, line[i]));
            } else if (i === 0 && closed_polygon === true) {
                // If it's the first point and is a closed polygon

                var needToClose = true;
                if (remove_tile_edges) {
                    if (Builders.isOnTileEdge(line[i], line[lineSize - 2], { tolerance: tile_edge_tolerance })) {
                        needToClose = false;
                    }
                }

                if (needToClose) {
                    coordPrev = line[lineSize - 2];
                    normPrev = Vector.normalize(Vector.perp(coordPrev, line[i]));
                    isPrev = true;
                }
            }

            // Assign current coordinate
            coordCurr = line[i];

            if (isNext) {
                coordNext = line[i + 1];
            } else if (closed_polygon === true) {
                // If it's the last point in a closed polygon
                coordNext = line[1];
                isNext = true;
            }

            if (isNext) {
                // If it's not the last one get next coordinates and calculate the right normal

                normNext = Vector.normalize(Vector.perp(coordCurr, coordNext));
                if (remove_tile_edges) {
                    if (Builders.isOnTileEdge(coordCurr, coordNext, { tolerance: tile_edge_tolerance })) {
                        normCurr = Vector.normalize(Vector.perp(coordPrev, coordCurr));
                        if (isPrev) {
                            addVertexPair(coordCurr, normCurr, i / lineSize, constants);
                            constants.nPairs++;

                            // Add vertices to buffer acording their index
                            indexPairs(constants);
                        }
                        isPrev = false;
                        continue;
                    }
                }
            }

            //  Compute current normal
            if (isPrev) {
                //  If there is a PREVIOUS ...
                if (isNext) {
                    // ... and a NEXT ONE, compute previous and next normals (scaled by the angle with the last prev)
                    normCurr = Vector.normalize(Vector.add(normPrev, normNext));
                    var scale = 2 / (1 + Math.abs(Vector.dot(normPrev, normCurr)));
                    normCurr = Vector.mult(normCurr, scale * scale);
                } else {
                    // ... and there is NOT a NEXT ONE, copy the previous next one (which is the current one)
                    normCurr = Vector.normalize(Vector.perp(coordPrev, coordCurr));
                }
            } else {
                // If there is NO PREVIOUS ...
                if (isNext) {
                    // ... and a NEXT ONE,
                    normNext = Vector.normalize(Vector.perp(coordCurr, coordNext));
                    normCurr = normNext;
                } else {
                    // ... and NO NEXT ONE, nothing to do (without prev or next one this is just a point)
                    continue;
                }
            }

            if (isPrev || isNext) {
                // If it's the BEGINNING of a LINE
                if (i === 0 && !isPrev && !closed_polygon) {
                    addCap(coordCurr, normCurr, cornersOnCap, true, constants);
                }

                // If it's a JOIN
                if (trianglesOnJoin !== 0 && isPrev && isNext) {
                    addJoin([coordPrev, coordCurr, coordNext], [normPrev, normCurr, normNext], i / lineSize, trianglesOnJoin, constants);
                } else {
                    addVertexPair(coordCurr, normCurr, i / (lineSize - 1), constants);
                }

                if (isNext) {
                    constants.nPairs++;
                }

                isPrev = true;
            }
        }

        // Add vertices to buffer according to their index
        indexPairs(constants);

        // If it's the END of a LINE
        if (!closed_polygon) {
            addCap(coordCurr, normCurr, cornersOnCap, false, constants);
        }
    }
};

// Add to equidistant pairs of vertices (internal method for polyline builder)
function addVertex(coord, normal, uv, _ref) {
    var halfWidth = _ref.halfWidth;
    var vertices = _ref.vertices;
    var scalingVecs = _ref.scalingVecs;
    var texcoords = _ref.texcoords;

    if (scalingVecs) {
        //  a. If scaling is on add the vertex (the currCoord) and the scaling Vecs (normals pointing where to extrude the vertices)
        vertices.push(coord);
        scalingVecs.push(normal);
    } else {
        //  b. Add the extruded vertices
        vertices.push([coord[0] + normal[0] * halfWidth, coord[1] + normal[1] * halfWidth]);
    }

    // c) Add UVs if they are enabled
    if (texcoords) {
        texcoords.push(uv);
    }
}

//  Add to equidistant pairs of vertices (internal method for polyline builder)
function addVertexPair(coord, normal, v_pct, constants) {
    addVertex(coord, normal, [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v], constants);
    addVertex(coord, Vector.neg(normal), [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v], constants);
}

//  Tessalate a FAN geometry between points A       B
//  using their normals from a center        \ . . /
//  and interpolating their UVs               \ p /
//                                             \./
//                                              C
function addFan(coord, nA, nC, nB, uA, uC, uB, signed, numTriangles, constants) {

    if (numTriangles < 1) {
        return;
    }

    // Add previous vertices to buffer and clear the buffers and index pairs
    // because we are going to add more triangles.
    indexPairs(constants);

    var normCurr = Vector.set(nA);
    var normPrev = [0, 0];

    var angle_delta = Vector.dot(nA, nB);
    if (angle_delta < -1) {
        angle_delta = -1;
    }
    angle_delta = Math.acos(angle_delta) / numTriangles;

    if (!signed) {
        angle_delta *= -1;
    }

    var uvCurr = Vector.set(uA);
    var uv_delta = Vector.div(Vector.sub(uB, uA), numTriangles);

    //  Add the FIRST and CENTER vertex
    //  The triangles will be composed in a FAN style around it
    addVertex(coord, nC, uC, constants);

    //  Add first corner
    addVertex(coord, normCurr, uA, constants);

    // Iterate through the rest of the corners
    for (var t = 0; t < numTriangles; t++) {
        normPrev = Vector.normalize(normCurr);
        normCurr = Vector.rot(Vector.normalize(normCurr), angle_delta); //  Rotate the extrusion normal

        if (numTriangles === 4 && (t === 0 || t === numTriangles - 2)) {
            var scale = 2 / (1 + Math.abs(Vector.dot(normPrev, normCurr)));
            normCurr = Vector.mult(normCurr, scale * scale);
        }

        uvCurr = Vector.add(uvCurr, uv_delta);

        addVertex(coord, normCurr, uvCurr, constants); //  Add computed corner
    }

    for (var i = 0; i < numTriangles; i++) {
        if (signed) {
            addIndex(i + 2, constants);
            addIndex(0, constants);
            addIndex(i + 1, constants);
        } else {
            addIndex(i + 1, constants);
            addIndex(0, constants);
            addIndex(i + 2, constants);
        }
    }

    // Clear the buffer
    constants.vertices = [];
    if (constants.scalingVecs) {
        constants.scalingVecs = [];
    }
    if (constants.texcoords) {
        constants.texcoords = [];
    }
}

//  Add special joins (not miter) types that require FAN tessellations
//  Using http://www.codeproject.com/Articles/226569/Drawing-polylines-by-tessellation as reference
function addJoin(coords, normals, v_pct, nTriangles, constants) {

    var T = [Vector.set(normals[0]), Vector.set(normals[1]), Vector.set(normals[2])];
    var signed = Vector.signed_area(coords[0], coords[1], coords[2]) > 0;

    var nA = T[0],
        // normal to point A (aT)
    nC = Vector.neg(T[1]),
        // normal to center (-vP)
    nB = T[2]; // normal to point B (bT)

    var uA = [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v],
        uC = [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v],
        uB = [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];

    if (signed) {
        addVertex(coords[1], nA, uA, constants);
        addVertex(coords[1], nC, uC, constants);
    } else {
        nA = Vector.neg(T[0]);
        nC = T[1];
        nB = Vector.neg(T[2]);
        uA = [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];
        uC = [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];
        uB = [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];
        addVertex(coords[1], nC, uC, constants);
        addVertex(coords[1], nA, uA, constants);
    }

    addFan(coords[1], nA, nC, nB, uA, uC, uB, signed, nTriangles, constants);

    if (signed) {
        addVertex(coords[1], nB, uB, constants);
        addVertex(coords[1], nC, uC, constants);
    } else {
        addVertex(coords[1], nC, uC, constants);
        addVertex(coords[1], nB, uB, constants);
    }
}

//  Function to add the vertex need for line caps,
//  because re-use the buffers needs to be at the end
function addCap(coord, normal, numCorners, isBeginning, constants) {

    if (numCorners < 1) {
        return;
    }

    // UVs
    var uvA = [constants.min_u, constants.min_v],
        // Beginning angle UVs
    uvC = [constants.min_u + (constants.max_u - constants.min_u) / 2, constants.min_v],
        // center point UVs
    uvB = [constants.max_u, constants.min_v]; // Ending angle UVs

    if (!isBeginning) {
        uvA = [constants.min_u, constants.max_v], // Begining angle UVs
        uvC = [constants.min_u + (constants.max_u - constants.min_u) / 2, constants.max_v], // center point UVs
        uvB = [constants.max_u, constants.max_v];
    }

    addFan(coord, Vector.neg(normal), [0, 0], normal, uvA, uvC, uvB, isBeginning, numCorners * 2, constants);
}

// Add a vertex based on the index position into the VBO (internal method for polyline builder)
function addIndex(index, _ref) {
    var vertex_data = _ref.vertex_data;
    var vertex_template = _ref.vertex_template;
    var halfWidth = _ref.halfWidth;
    var vertices = _ref.vertices;
    var scaling_index = _ref.scaling_index;
    var scaling_normalize = _ref.scaling_normalize;
    var scalingVecs = _ref.scalingVecs;
    var texcoord_index = _ref.texcoord_index;
    var texcoords = _ref.texcoords;
    var texcoord_normalize = _ref.texcoord_normalize;

    // Prevent access to undefined vertices
    if (index >= vertices.length) {
        return;
    }

    // set vertex position
    vertex_template[0] = vertices[index][0];
    vertex_template[1] = vertices[index][1];

    // set UVs
    if (texcoord_index) {
        vertex_template[texcoord_index + 0] = texcoords[index][0] * texcoord_normalize;
        vertex_template[texcoord_index + 1] = texcoords[index][1] * texcoord_normalize;
    }

    // set Scaling vertex (X, Y normal direction + Z halfwidth as attribute)
    if (scaling_index) {
        vertex_template[scaling_index + 0] = scalingVecs[index][0] * scaling_normalize;
        vertex_template[scaling_index + 1] = scalingVecs[index][1] * scaling_normalize;
        vertex_template[scaling_index + 2] = halfWidth;
    }

    //  Add vertex to VBO
    vertex_data.addVertex(vertex_template);
}

// Add the index vertex to the VBO and clean the buffers
function indexPairs(constants) {
    // Add vertices to buffer acording their index
    for (var i = 0; i < constants.nPairs; i++) {
        addIndex(2 * i + 2, constants);
        addIndex(2 * i + 1, constants);
        addIndex(2 * i + 0, constants);

        addIndex(2 * i + 2, constants);
        addIndex(2 * i + 3, constants);
        addIndex(2 * i + 1, constants);
    }

    constants.nPairs = 0;

    // Clean the buffer
    constants.vertices = [];
    if (constants.scalingVecs) {
        constants.scalingVecs = [];
    }
    if (constants.texcoords) {
        constants.texcoords = [];
    }
}

// Build a billboard sprite quad centered on a point. Sprites are intended to be drawn in screenspace, and have
// properties for width, height, angle, and a scale factor that can be used to interpolate the screenspace size
// of a sprite between two zoom levels.
Builders.buildQuadsForPoints = function (points, width, height, angle, scale, vertex_data, vertex_template, scaling_index, _ref) {
    var texcoord_index = _ref.texcoord_index;
    var texcoord_scale = _ref.texcoord_scale;
    var texcoord_normalize = _ref.texcoord_normalize;

    var w2 = width / 2;
    var h2 = height / 2;
    var scaling = [[-w2, -h2], [w2, -h2], [w2, h2], [-w2, -h2], [w2, h2], [-w2, h2]];

    var texcoords = undefined;
    if (texcoord_index) {
        texcoord_normalize = texcoord_normalize || 1;

        var _ref2 = texcoord_scale || [[0, 0], [1, 1]];

        var _ref22 = _slicedToArray(_ref2, 2);

        var _ref22$0 = _slicedToArray(_ref22[0], 2);

        var min_u = _ref22$0[0];
        var min_v = _ref22$0[1];

        var _ref22$1 = _slicedToArray(_ref22[1], 2);

        var max_u = _ref22$1[0];
        var max_v = _ref22$1[1];

        texcoords = [[min_u, min_v], [max_u, min_v], [max_u, max_v], [min_u, min_v], [max_u, max_v], [min_u, max_v]];
    }

    var num_points = points.length;
    for (var p = 0; p < num_points; p++) {
        var point = points[p];

        for (var pos = 0; pos < 6; pos++) {
            // Add texcoords
            if (texcoord_index) {
                vertex_template[texcoord_index + 0] = texcoords[pos][0] * texcoord_normalize;
                vertex_template[texcoord_index + 1] = texcoords[pos][1] * texcoord_normalize;
            }

            vertex_template[0] = point[0];
            vertex_template[1] = point[1];

            vertex_template[scaling_index + 0] = scaling[pos][0];
            vertex_template[scaling_index + 1] = scaling[pos][1];
            vertex_template[scaling_index + 2] = angle;
            vertex_template[scaling_index + 3] = scale;

            vertex_data.addVertex(vertex_template);
        }
    }
};

/* Utility functions */

// Triangulation using earcut
// https://github.com/mapbox/earcut
Builders.triangulatePolygon = function (contours) {
    return earcut(contours);
};

// Tests if a line segment (from point A to B) is nearly coincident with the edge of a tile
Builders.isOnTileEdge = function (pa, pb, options) {
    options = options || {};

    var tolerance_function = options.tolerance_function || Builders.valuesWithinTolerance;
    var tolerance = options.tolerance || 1;
    var tile_min = Builders.tile_bounds[0];
    var tile_max = Builders.tile_bounds[1];
    var edge = null;

    if (tolerance_function(pa[0], tile_min.x, tolerance) && tolerance_function(pb[0], tile_min.x, tolerance)) {
        edge = "left";
    } else if (tolerance_function(pa[0], tile_max.x, tolerance) && tolerance_function(pb[0], tile_max.x, tolerance)) {
        edge = "right";
    } else if (tolerance_function(pa[1], tile_min.y, tolerance) && tolerance_function(pb[1], tile_min.y, tolerance)) {
        edge = "top";
    } else if (tolerance_function(pa[1], tile_max.y, tolerance) && tolerance_function(pb[1], tile_max.y, tolerance)) {
        edge = "bottom";
    }
    return edge;
};

Builders.valuesWithinTolerance = function (a, b, tolerance) {
    tolerance = tolerance || 1;
    return Math.abs(a - b) < tolerance;
};

},{"../geo":73,"../vector":118,"earcut":20}],98:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
// Line rendering style

var Style = require("../style").Style;

var StyleParser = require("../style_parser").StyleParser;

var StyleManager = require("../style_manager").StyleManager;

var gl = _interopRequire(require("../../gl/constants"));

// web workers don't have access to GL context, so import all GL constants

var VertexLayout = _interopRequire(require("../../gl/vertex_layout"));

var Builders = _interopRequire(require("../builders"));

var Geo = _interopRequire(require("../../geo"));

var Utils = _interopRequire(require("../../utils/utils"));

var Lines = Object.create(Style);

exports.Lines = Lines;
Object.assign(Lines, {
    name: "lines",
    built_in: true,
    vertex_shader_key: "styles/polygons/polygons_vertex", // re-use polygon shaders
    fragment_shader_key: "styles/polygons/polygons_fragment",
    selection: true, // turn feature selection on

    init: function init() {
        Style.init.apply(this, arguments);

        // Basic attributes, others can be added (see texture UVs below)
        var attribs = [{ name: "a_position", size: 4, type: gl.SHORT, normalized: true }, { name: "a_extrude", size: 4, type: gl.SHORT, normalized: true }, { name: "a_color", size: 4, type: gl.UNSIGNED_BYTE, normalized: true }];

        // Tell the shader we want a order in vertex attributes, and to extrude lines
        this.defines.TANGRAM_LAYER_ORDER = true;
        this.defines.TANGRAM_EXTRUDE_LINES = true;

        // Optional feature selection
        if (this.selection) {
            attribs.push({ name: "a_selection_color", size: 4, type: gl.UNSIGNED_BYTE, normalized: true });
        }

        // Optional texture UVs
        if (this.texcoords) {
            this.defines.TANGRAM_TEXTURE_COORDS = true;

            // Add vertex attribute for UVs only when needed
            attribs.push({ name: "a_texcoord", size: 2, type: gl.UNSIGNED_SHORT, normalized: true });
        }

        this.vertex_layout = new VertexLayout(attribs);
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        var style = this.feature_style;

        var inner_width = rule_style.width && StyleParser.cacheDistance(rule_style.width, context);
        if (!inner_width) {
            return;
        }
        style.width = inner_width * context.units_per_meter;

        // Smoothly interpolate line width between zooms: get scale factor to next zoom
        // Adjust by factor of 2 because tile units are zoom-dependent (a given value is twice as
        // big in world space at the next zoom than at the previous)
        context.zoom++;
        context.units_per_meter *= 2;
        var next_width = StyleParser.cacheDistance(rule_style.next_width, context);
        style.next_width = Utils.scaleInt16(next_width * context.units_per_meter / style.width, 256);
        context.zoom--;
        context.units_per_meter /= 2; // reset to original scale

        style.color = this.parseColor(rule_style.color, context);
        if (!style.color) {
            return null;
        }

        // height defaults to feature height, but extrude style can dynamically adjust height by returning a number or array (instead of a boolean)
        style.z = rule_style.z && StyleParser.cacheDistance(rule_style.z || 0, context) || StyleParser.defaults.z;
        style.height = feature.properties.height || StyleParser.defaults.height;
        style.extrude = rule_style.extrude;
        if (style.extrude) {
            if (typeof style.extrude === "function") {
                style.extrude = style.extrude(context);
            }

            if (typeof style.extrude === "number") {
                style.height = style.extrude;
            } else if (Array.isArray(style.extrude)) {
                style.height = style.extrude[1];
            }
        }

        // Raise line height if extruded
        if (style.extrude && style.height) {
            style.z += style.height;
        }

        style.cap = rule_style.cap;
        style.join = rule_style.join;
        style.tile_edges = rule_style.tile_edges;

        // Construct an outline style
        style.outline = style.outline || {};
        if (rule_style.outline && rule_style.outline.color && rule_style.outline.width) {
            var outline_width = StyleParser.cacheDistance(rule_style.outline.width, context) * 2;

            context.zoom++;
            context.units_per_meter *= 2;
            var outline_next_width = StyleParser.cacheDistance(rule_style.outline.next_width, context) * 2;
            context.zoom--;
            context.units_per_meter /= 2; // reset to original scale

            // Maintain consistent outline width around the inner line
            style.outline.width = { value: outline_width + inner_width };
            style.outline.next_width = { value: outline_next_width + next_width };

            style.outline.color = rule_style.outline.color;
            style.outline.cap = rule_style.outline.cap || rule_style.cap;
            style.outline.join = rule_style.outline.join || rule_style.join;
            style.outline.style = rule_style.outline.style || this.name;

            // Explicitly defined outline order, or inherited from inner line
            if (rule_style.outline.order) {
                style.outline.order = this.parseOrder(rule_style.outline.order, context);
            } else {
                style.outline.order = style.order;
            }

            // Don't let outline be above inner line
            if (style.outline.order > style.order) {
                style.outline.order = style.order;
            }

            // Outlines are always at half-layer intervals to avoid conflicting with inner lines
            style.outline.order -= 0.5;

            style.outline.preprocessed = true; // signal that we've already wrapped properties in cache objects
        } else {
            style.outline.color = null;
            style.outline.width = null;
        }

        return style;
    },

    preprocess: function preprocess(draw) {
        draw.color = draw.color && { value: draw.color };
        draw.width = draw.width && { value: draw.width };
        draw.next_width = draw.width && { value: draw.width.value };
        draw.z = draw.z && { value: draw.z };

        if (draw.outline) {
            draw.outline.color = draw.outline.color && { value: draw.outline.color };
            draw.outline.width = draw.outline.width && { value: draw.outline.width };
            draw.outline.next_width = draw.outline.width && { value: draw.outline.width.value };
        }
    },

    /**
     * A "template" that sets constant attibutes for each vertex, which is then modified per vertex or per feature.
     * A plain JS array matching the order of the vertex layout.
     */
    makeVertexTemplate: function makeVertexTemplate(style) {
        var i = 0;

        // position - x & y coords will be filled in per-vertex below
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = style.z || 0;

        // layer order - w coord of 'position' attribute (for packing efficiency)
        this.vertex_template[i++] = style.order;

        // extrusion vector
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 0;

        // scaling to previous and next zoom
        this.vertex_template[i++] = style.next_width;

        // color
        this.vertex_template[i++] = style.color[0] * 255;
        this.vertex_template[i++] = style.color[1] * 255;
        this.vertex_template[i++] = style.color[2] * 255;
        this.vertex_template[i++] = style.color[3] * 255;

        // selection color
        if (this.selection) {
            this.vertex_template[i++] = style.selection_color[0] * 255;
            this.vertex_template[i++] = style.selection_color[1] * 255;
            this.vertex_template[i++] = style.selection_color[2] * 255;
            this.vertex_template[i++] = style.selection_color[3] * 255;
        }

        // Add texture UVs to template only if needed
        if (this.texcoords) {
            this.vertex_template[i++] = 0;
            this.vertex_template[i++] = 0;
        }

        return this.vertex_template;
    },

    buildLines: function buildLines(lines, style, vertex_data, context, options) {
        var vertex_template = this.makeVertexTemplate(style);

        // Main line
        if (style.color && style.width) {
            Builders.buildPolylines(lines, style.width, vertex_data, vertex_template, {
                cap: style.cap,
                join: style.join,
                scaling_index: this.vertex_layout.index.a_extrude,
                scaling_normalize: Utils.scaleInt16(1, 256), // scale extrusion normals to signed shorts w/256 unit basis
                texcoord_index: this.vertex_layout.index.a_texcoord,
                texcoord_scale: this.texcoord_scale,
                texcoord_normalize: 65535, // scale UVs to unsigned shorts
                closed_polygon: options && options.closed_polygon,
                remove_tile_edges: !style.tile_edges && options && options.remove_tile_edges,
                tile_edge_tolerance: Geo.tile_scale * context.tile.pad_scale * 4
            });
        }

        // Outline
        if (style.outline && style.outline.color && style.outline.width) {
            var outline_style = StyleManager.styles[style.outline.style];
            if (outline_style) {
                outline_style.addFeature(context.feature, style.outline, context);
            }
        }
    },

    buildPolygons: function buildPolygons(polygons, style, vertex_data, context) {
        // Render polygons as individual lines
        for (var p = 0; p < polygons.length; p++) {
            this.buildLines(polygons[p], style, vertex_data, context, { closed_polygon: true, remove_tile_edges: true });
        }
    }

});

},{"../../geo":73,"../../gl/constants":74,"../../gl/vertex_layout":85,"../../utils/utils":115,"../builders":97,"../style":102,"../style_manager":103,"../style_parser":104}],99:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
// Point rendering style

var Style = require("../style").Style;

var StyleParser = require("../style_parser").StyleParser;

var gl = _interopRequire(require("../../gl/constants"));

// web workers don't have access to GL context, so import all GL constants

var VertexLayout = _interopRequire(require("../../gl/vertex_layout"));

var Builders = _interopRequire(require("../builders"));

var Texture = _interopRequire(require("../../gl/texture"));

var Geo = _interopRequire(require("../../geo"));

var Utils = _interopRequire(require("../../utils/utils"));

var log = _interopRequire(require("loglevel"));

var Points = Object.create(Style);

exports.Points = Points;
Object.assign(Points, {
    name: "points",
    built_in: true,
    selection: true, // turn feature selection on
    blend: "overlay", // overlays drawn on top of all other styles, with blending

    init: function init() {
        var options = arguments[0] === undefined ? {} : arguments[0];

        Style.init.apply(this, arguments);

        // Base shaders
        this.vertex_shader_key = "styles/points/points_vertex";
        this.fragment_shader_key = "styles/points/points_fragment";

        var attribs = [{ name: "a_position", size: 4, type: gl.SHORT, normalized: true }, { name: "a_shape", size: 4, type: gl.SHORT, normalized: true }, { name: "a_texcoord", size: 2, type: gl.UNSIGNED_SHORT, normalized: true }, { name: "a_color", size: 4, type: gl.UNSIGNED_BYTE, normalized: true }];

        // Optional feature selection
        if (this.selection) {
            attribs.push({ name: "a_selection_color", size: 4, type: gl.UNSIGNED_BYTE, normalized: true });
        }

        // If we're not rendering as overlay, we need a layer attribute
        if (this.blend !== "overlay") {
            this.defines.TANGRAM_LAYER_ORDER = true;
        }

        this.vertex_layout = new VertexLayout(attribs);

        if (this.texture) {
            this.defines.TANGRAM_POINT_TEXTURE = true;
            this.shaders.uniforms = this.shaders.uniforms || {};
            this.shaders.uniforms.u_texture = this.texture;
        }
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        var style = this.feature_style;
        var tile = context.tile.key;

        style.color = this.parseColor(rule_style.color, context);

        // require color or texture
        if (!style.color && !this.texture) {
            return null;
        }

        var sprite = style.sprite = rule_style.sprite;
        if (typeof sprite === "function") {
            sprite = sprite(context);
        }
        style.sprite_default = rule_style.sprite_default; // optional fallback if 'sprite' not found

        // if point has texture and sprites, require a valid sprite to draw
        if (this.texture && Texture.textures[this.texture] && Texture.textures[this.texture].sprites) {
            if (!sprite && !style.sprite_default) {
                return;
            } else if (!Texture.textures[this.texture].sprites[sprite]) {
                // If sprite not found, check for default sprite
                if (style.sprite_default) {
                    sprite = style.sprite_default;
                    if (!Texture.textures[this.texture].sprites[sprite]) {
                        log.warn("Style: in style '" + this.name + "', could not find default sprite '" + sprite + "' for texture '" + this.texture + "'");
                        return;
                    }
                } else {
                    log.warn("Style: in style '" + this.name + "', could not find sprite '" + sprite + "' for texture '" + this.texture + "'");
                    return;
                }
            }
        }

        // points can be placed off the ground
        style.z = rule_style.z && StyleParser.cacheDistance(rule_style.z, context) || StyleParser.defaults.z;

        // point style only supports sizes in pixel units, so unit conversion flag is off
        style.size = rule_style.size || { value: [32, 32] };
        style.size = StyleParser.cacheDistance(style.size, context, "pixels");

        // scale size to 16-bit signed int, with a max allowed width + height of 128 pixels
        style.size = [Math.min(style.size[0] || style.size, 256), Math.min(style.size[1] || style.size, 256)];

        style.size[0] *= Utils.device_pixel_ratio;
        style.size[1] *= Utils.device_pixel_ratio;

        style.angle = rule_style.angle || 0;
        if (typeof style.angle === "function") {
            style.angle = style.angle(context);
        }

        // factor by which point scales from current zoom level to next zoom level
        style.scale = rule_style.scale || 1;

        // to store bbox by tiles
        style.tile = tile;

        // polygons rendering as points will render each individual polygon point by default, but
        // rendering a single point at the polygon's centroid can be enabled
        style.centroid = rule_style.centroid;

        // Sets texcoord scale if needed (e.g. for sprite sub-area)
        if (this.texture && sprite) {
            this.texcoord_scale = Texture.getSpriteTexcoords(this.texture, sprite);
        } else {
            this.texcoord_scale = null;
        }

        return style;
    },

    preprocess: function preprocess(draw) {
        draw.color = draw.color && { value: draw.color };
        draw.z = draw.z && { value: draw.z };
        draw.size = draw.size && { value: draw.size };
    },

    /**
     * A "template" that sets constant attibutes for each vertex, which is then modified per vertex or per feature.
     * A plain JS array matching the order of the vertex layout.
     */
    makeVertexTemplate: function makeVertexTemplate(style) {
        var i = 0;
        var color = style.color || StyleParser.defaults.color;

        // position - x & y coords will be filled in per-vertex below
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = style.z || 0;

        // layer order - w coord of 'position' attribute (for packing efficiency)
        this.vertex_template[i++] = style.order || 0;

        // scaling vector - (x, y) components per pixel, z = angle, w = scaling factor
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 0;

        // texture coords
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 0;

        // color
        this.vertex_template[i++] = color[0] * 255;
        this.vertex_template[i++] = color[1] * 255;
        this.vertex_template[i++] = color[2] * 255;
        this.vertex_template[i++] = color[3] * 255;

        // selection color
        if (this.selection) {
            this.vertex_template[i++] = style.selection_color[0] * 255;
            this.vertex_template[i++] = style.selection_color[1] * 255;
            this.vertex_template[i++] = style.selection_color[2] * 255;
            this.vertex_template[i++] = style.selection_color[3] * 255;
        }

        return this.vertex_template;
    },

    buildPoints: function buildPoints(points, style, vertex_data) {
        if (!style.size) {
            return;
        }

        var vertex_template = this.makeVertexTemplate(style);

        var size = style.size;
        var angle = style.angle;

        Builders.buildQuadsForPoints(points, Utils.scaleInt16(size[0], 256), Utils.scaleInt16(size[1], 256), Utils.scaleInt16(Utils.radToDeg(angle), 360), Utils.scaleInt16(style.scale, 256), vertex_data, vertex_template, this.vertex_layout.index.a_shape, {
            texcoord_index: this.vertex_layout.index.a_texcoord,
            texcoord_scale: this.texcoord_scale,
            texcoord_normalize: 65535
        });
    },

    buildPolygons: function buildPolygons(polygons, style, vertex_data) {
        // Render polygons as individual points, or centroid
        if (!style.centroid) {
            for (var poly = 0; poly < polygons.length; poly++) {
                var polygon = polygons[poly];
                for (var r = 0; r < polygon.length; r++) {
                    this.buildPoints(polygon[r], style, vertex_data);
                }
            }
        } else {
            var centroid = Geo.multiCentroid(polygons);
            this.buildPoints([centroid], style, vertex_data);
        }
    },

    buildLines: function buildLines(lines, style, vertex_data) {
        // Render lines as individual points
        for (var ln = 0; ln < lines.length; ln++) {
            this.buildPoints(lines[ln], style, vertex_data);
        }
    }

});

},{"../../geo":73,"../../gl/constants":74,"../../gl/texture":81,"../../gl/vertex_layout":85,"../../utils/utils":115,"../builders":97,"../style":102,"../style_parser":104,"loglevel":60}],100:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
// Polygon rendering style

var Style = require("../style").Style;

var StyleParser = require("../style_parser").StyleParser;

var gl = _interopRequire(require("../../gl/constants"));

// web workers don't have access to GL context, so import all GL constants

var VertexLayout = _interopRequire(require("../../gl/vertex_layout"));

var Builders = _interopRequire(require("../builders"));

var Polygons = Object.create(Style);

exports.Polygons = Polygons;
Object.assign(Polygons, {
    name: "polygons",
    built_in: true,
    vertex_shader_key: "styles/polygons/polygons_vertex",
    fragment_shader_key: "styles/polygons/polygons_fragment",
    selection: true, // turn feature selection on

    init: function init() {
        Style.init.apply(this, arguments);

        // Basic attributes, others can be added (see texture UVs below)
        var attribs = [{ name: "a_position", size: 4, type: gl.SHORT, normalized: true }, { name: "a_normal", size: 3, type: gl.BYTE, normalized: true }, // gets padded to 4-bytes
        { name: "a_color", size: 4, type: gl.UNSIGNED_BYTE, normalized: true }];

        // Tell the shader we have a normal and order attributes
        this.defines.TANGRAM_NORMAL_ATTRIBUTE = true;
        this.defines.TANGRAM_LAYER_ORDER = true;

        // Optional feature selection
        if (this.selection) {
            attribs.push({ name: "a_selection_color", size: 4, type: gl.UNSIGNED_BYTE, normalized: true });
        }

        // Optional texture UVs
        if (this.texcoords) {
            this.defines.TANGRAM_TEXTURE_COORDS = true;

            // Add vertex attribute for UVs only when needed
            attribs.push({ name: "a_texcoord", size: 2, type: gl.UNSIGNED_SHORT, normalized: true });
        }

        this.vertex_layout = new VertexLayout(attribs);
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        var style = this.feature_style;

        style.color = this.parseColor(rule_style.color, context);
        if (!style.color) {
            return null;
        }

        // height defaults to feature height, but extrude style can dynamically adjust height by returning a number or array (instead of a boolean)
        style.z = rule_style.z && StyleParser.cacheDistance(rule_style.z, context) || StyleParser.defaults.z;
        style.height = feature.properties.height || StyleParser.defaults.height;
        style.min_height = feature.properties.min_height || StyleParser.defaults.min_height;
        style.extrude = rule_style.extrude;
        if (style.extrude) {
            if (typeof style.extrude === "function") {
                style.extrude = style.extrude(context);
            }

            if (typeof style.extrude === "number") {
                style.height = style.extrude;
            } else if (Array.isArray(style.extrude)) {
                style.min_height = style.extrude[0];
                style.height = style.extrude[1];
            }
        }

        // style.outline = style.outline || {};
        // if (rule_style.outline) {
        //     style.outline.color = StyleParser.parseColor(rule_style.outline.color, context);
        //     style.outline.width = StyleParser.parseDistance(rule_style.outline.width, context);
        //     style.outline.tile_edges = rule_style.outline.tile_edges;
        //     style.outline.cap = rule_style.outline.cap || rule_style.cap;
        //     style.outline.join = rule_style.outline.join || rule_style.join;
        // }
        // else {
        //     style.outline.color = null;
        //     style.outline.width = null;
        //     style.outline.tile_edges = false;
        // }

        return style;
    },

    preprocess: function preprocess(draw) {
        draw.color = draw.color && { value: draw.color };
        draw.z = draw.z && { value: draw.z };
    },

    /**
     * A "template" that sets constant attibutes for each vertex, which is then modified per vertex or per feature.
     * A plain JS array matching the order of the vertex layout.
     */
    makeVertexTemplate: function makeVertexTemplate(style) {
        var i = 0;

        // position - x & y coords will be filled in per-vertex below
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = style.z || 0;

        // layer order - w coord of 'position' attribute (for packing efficiency)
        this.vertex_template[i++] = style.order;

        // normal
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 0;
        this.vertex_template[i++] = 1 * 127;

        // color
        this.vertex_template[i++] = style.color[0] * 255;
        this.vertex_template[i++] = style.color[1] * 255;
        this.vertex_template[i++] = style.color[2] * 255;
        this.vertex_template[i++] = style.color[3] * 255;

        // selection color
        if (this.selection) {
            this.vertex_template[i++] = style.selection_color[0] * 255;
            this.vertex_template[i++] = style.selection_color[1] * 255;
            this.vertex_template[i++] = style.selection_color[2] * 255;
            this.vertex_template[i++] = style.selection_color[3] * 255;
        }

        // Add texture UVs to template only if needed
        if (this.texcoords) {
            this.vertex_template[i++] = 0;
            this.vertex_template[i++] = 0;
        }

        return this.vertex_template;
    },

    buildPolygons: function buildPolygons(polygons, style, vertex_data) {
        var vertex_template = this.makeVertexTemplate(style);
        var texcoords = {
            texcoord_index: this.vertex_layout.index.a_texcoord,
            texcoord_scale: this.texcoord_scale,
            texcoord_normalize: 65535 // scale UVs to unsigned shorts
        };

        // Extruded polygons (e.g. 3D buildings)
        if (style.extrude && style.height) {
            Builders.buildExtrudedPolygons(polygons, style.z, style.height, style.min_height, vertex_data, vertex_template, this.vertex_layout.index.a_normal, 127, // scale normals to signed bytes
            texcoords);
        }
        // Regular polygons
        else {
            Builders.buildPolygons(polygons, vertex_data, vertex_template, texcoords);
        }
    }

});

},{"../../gl/constants":74,"../../gl/vertex_layout":85,"../builders":97,"../style":102,"../style_parser":104}],101:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

exports.mergeTrees = mergeTrees;
exports.walkUp = walkUp;
exports.walkDown = walkDown;
exports.groupProps = groupProps;
exports.calculateDraw = calculateDraw;
exports.mergeObjects = mergeObjects;
exports.calculateOrder = calculateOrder;
exports.parseRuleTree = parseRuleTree;
exports.parseRules = parseRules;
exports.matchFeature = matchFeature;
Object.defineProperty(exports, "__esModule", {
    value: true
});

var match = require("match-feature").match;

var log = _interopRequire(require("loglevel"));

var whiteList = ["filter", "draw", "visible", "data", "properties"];

exports.whiteList = whiteList;
var ruleCache = {};

exports.ruleCache = ruleCache;
function cacheKey(rules) {
    var k = rules[0].id;
    for (var i = 1; i < rules.length; i++) {
        k += "/" + rules[i].id;
    }
    return k;
}

function mergeTrees(matchingTrees, key, context) {
    var draw = {},
        draws,

    // order = [],
    // order_draws = [],
    treeDepth = 0,
        x,
        t;

    // Visible by default
    draw.visible = true;

    // Find deepest tree
    for (t = 0; t < matchingTrees.length; t++) {
        if (matchingTrees[t].length > treeDepth) {
            treeDepth = matchingTrees[t].length;
        }
    }

    // No rules to parse
    if (treeDepth === 0) {
        return null;
    }

    // Iterate trees in parallel
    for (x = 0; x < treeDepth; x++) {
        draws = matchingTrees.map(function (tree) {
            return tree[x] && tree[x][key];
        });
        if (draws.length === 0) {
            continue;
        }

        // Property-specific logic
        // for (i=0; i < draws.length; i++) {
        //     if (!draws[i]) {
        //         continue;
        //     }

        //     // Collect unique orders (don't add the order multiple times for the smae draw rule)
        //     if (draws[i].order !== undefined) {
        //         if (order_draws.indexOf(draws[i]) === -1) {
        //             order.push(draws[i].order);
        //             order_draws.push(draws[i]);
        //         }
        //     }
        // }

        // Merge remaining draw objects
        mergeObjects.apply(undefined, [draw].concat(_toConsumableArray(draws)));
    }

    // Short-circuit if not visible
    if (draw.visible === false) {
        return null;
    }

    // Sum all orders
    // Note: temporarily commenting out, will revisit with new scene file syntax
    // if (order.length > 0) {
    //     // Order can be cached if it is all numeric
    //     if (order.length === 1 && typeof order[0] === 'number') {
    //         order = order[0];
    //     }
    //     else if (order.every(v => typeof v === 'number')) {
    //         order = calculateOrder(order, context); // TODO: use StyleParser.calculateOrder
    //     }
    //     draw.order = order;
    // }

    return draw;
}

var Rule = (function () {
    function Rule(_ref) {
        var name = _ref.name;
        var parent = _ref.parent;
        var draw = _ref.draw;
        var visible = _ref.visible;
        var filter = _ref.filter;
        var properties = _ref.properties;

        _classCallCheck(this, Rule);

        this.id = Rule.id++;
        this.parent = parent;
        this.name = name;
        this.draw = draw;
        this.filter = filter;
        this.visible = visible !== undefined ? visible : this.parent && this.parent.visible;
        this.properties = properties !== undefined ? properties : this.parent && this.parent.properties;

        // Denormalize properties to draw groups
        if (this.draw) {
            for (var group in this.draw) {
                if (this.properties !== undefined) {
                    this.draw[group].properties = this.properties;
                }
            }
        }

        this.buildFilter();
        this.buildDraw();
    }

    _createClass(Rule, {
        buildDraw: {
            value: function buildDraw() {
                this.calculatedDraw = calculateDraw(this);
            }
        },
        buildFilter: {
            value: function buildFilter() {
                var type = typeof this.filter;
                if (type === "object") {
                    this.filter = match(this.filter);
                }
            }
        },
        toJSON: {
            value: function toJSON() {
                return {
                    name: this.name,
                    draw: this.draw
                };
            }
        }
    });

    return Rule;
})();

Rule.id = 0;

var RuleLeaf = exports.RuleLeaf = (function (_Rule) {
    function RuleLeaf(_ref) {
        var name = _ref.name;
        var parent = _ref.parent;
        var draw = _ref.draw;
        var visible = _ref.visible;
        var filter = _ref.filter;
        var properties = _ref.properties;

        _classCallCheck(this, RuleLeaf);

        _get(Object.getPrototypeOf(RuleLeaf.prototype), "constructor", this).call(this, { name: name, parent: parent, draw: draw, visible: visible, filter: filter, properties: properties });
    }

    _inherits(RuleLeaf, _Rule);

    return RuleLeaf;
})(Rule);

var RuleTree = exports.RuleTree = (function (_Rule2) {
    function RuleTree(_ref) {
        var name = _ref.name;
        var parent = _ref.parent;
        var draw = _ref.draw;
        var visible = _ref.visible;
        var rules = _ref.rules;
        var filter = _ref.filter;
        var properties = _ref.properties;

        _classCallCheck(this, RuleTree);

        _get(Object.getPrototypeOf(RuleTree.prototype), "constructor", this).call(this, { name: name, parent: parent, draw: draw, visible: visible, filter: filter, properties: properties });
        this.rules = rules || [];
    }

    _inherits(RuleTree, _Rule2);

    _createClass(RuleTree, {
        addRule: {
            value: function addRule(rule) {
                this.rules.push(rule);
            }
        },
        buildDrawGroups: {
            value: function buildDrawGroups(context) {
                var rules = [];
                //TODO, should this function take a RuleTree
                matchFeature(context, [this], rules);

                if (rules.length > 0) {
                    var cache_key = cacheKey(rules);

                    // Only evaluate each rule combination once (undefined means not yet evaluated,
                    // null means evaluated with no draw object)
                    if (ruleCache[cache_key] === undefined) {
                        // Visible?
                        if (rules.some(function (x) {
                            return x.visible === false;
                        })) {
                            ruleCache[cache_key] = null;
                        } else {
                            // Find all the unique draw blocks for this rule tree
                            var draw_rules = rules.map(function (x) {
                                return x && x.calculatedDraw;
                            });
                            var draw_keys = {};

                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = undefined;

                            try {
                                for (var _iterator = draw_rules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                    var rule = _step.value;

                                    if (!rule) {
                                        continue;
                                    }
                                    var _iteratorNormalCompletion2 = true;
                                    var _didIteratorError2 = false;
                                    var _iteratorError2 = undefined;

                                    try {
                                        for (var _iterator2 = rule[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                            var group = _step2.value;

                                            for (var key in group) {
                                                draw_keys[key] = true;
                                            }
                                        }
                                    } catch (err) {
                                        _didIteratorError2 = true;
                                        _iteratorError2 = err;
                                    } finally {
                                        try {
                                            if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                                                _iterator2["return"]();
                                            }
                                        } finally {
                                            if (_didIteratorError2) {
                                                throw _iteratorError2;
                                            }
                                        }
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                                        _iterator["return"]();
                                    }
                                } finally {
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }

                            // Calculate each draw group
                            for (var draw_key in draw_keys) {
                                ruleCache[cache_key] = ruleCache[cache_key] || {};
                                ruleCache[cache_key][draw_key] = mergeTrees(draw_rules, draw_key, context);

                                // Only save the ones that weren't null
                                if (!ruleCache[cache_key][draw_key]) {
                                    delete ruleCache[cache_key][draw_key];
                                } else {
                                    ruleCache[cache_key][draw_key].key = cache_key + "/" + draw_key;
                                }
                            }

                            // No rules evaluated
                            if (ruleCache[cache_key] && Object.keys(ruleCache[cache_key]).length === 0) {
                                ruleCache[cache_key] = null;
                            }
                        }
                    }
                    return ruleCache[cache_key];
                }
            }
        }
    });

    return RuleTree;
})(Rule);

function isWhiteListed(key) {
    return whiteList.indexOf(key) > -1;
}

function isEmpty(obj) {
    return Object.keys(obj).length === 0;
}

function walkUp(rule, cb) {

    if (rule.parent) {
        walkUp(rule.parent, cb);
    }

    cb(rule);
}

function walkDown(rule, cb) {

    if (rule.rules) {
        rule.rules.forEach(function (r) {
            walkDown(r, cb);
        });
    }

    cb(rule);
}

function groupProps(obj) {
    var whiteListed = {},
        nonWhiteListed = {};

    for (var key in obj) {
        if (isWhiteListed(key)) {
            whiteListed[key] = obj[key];
        } else {
            nonWhiteListed[key] = obj[key];
        }
    }
    return [whiteListed, nonWhiteListed];
}

function calculateDraw(rule) {

    var draw = [];

    if (rule.parent) {
        var cs = rule.parent.calculatedDraw || [];
        draw.push.apply(draw, _toConsumableArray(cs));
    }

    draw.push(rule.draw);
    return draw;
}

function mergeObjects(newObj) {
    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        sources[_key - 1] = arguments[_key];
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {

        for (var _iterator = sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var source = _step.value;

            if (!source) {
                continue;
            }
            for (var key in source) {
                var value = source[key];
                if (typeof value === "object" && !Array.isArray(value)) {
                    newObj[key] = mergeObjects(newObj[key] || {}, value);
                } else {
                    newObj[key] = value;
                }
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return newObj;
}

function calculateOrder(orders) {
    var context = arguments[1] === undefined ? null : arguments[1];
    var defaultOrder = arguments[2] === undefined ? 0 : arguments[2];

    var sum = defaultOrder;

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = orders[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var order = _step.value;

            if (typeof order === "function") {
                order = order(context);
            } else {
                order = parseFloat(order);
            }

            if (!order || isNaN(order)) {
                continue;
            }
            sum += order;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return sum;
}

function parseRuleTree(name, rule, parent) {

    var properties = { name: name, parent: parent };

    var _groupProps = groupProps(rule);

    var _groupProps2 = _slicedToArray(_groupProps, 2);

    var whiteListed = _groupProps2[0];
    var nonWhiteListed = _groupProps2[1];

    var empty = isEmpty(nonWhiteListed);
    var Create = undefined;

    if (empty && parent != null) {
        Create = RuleLeaf;
    } else {
        Create = RuleTree;
    }

    var r = new Create(Object.assign(properties, whiteListed));

    if (parent) {
        parent.addRule(r);
    }

    if (!empty) {
        for (var key in nonWhiteListed) {
            var property = nonWhiteListed[key];
            if (typeof property === "object") {
                parseRuleTree(key, property, r);
            } else {
                log.warn("Rule property must be an object: ", name, rule, property);
            }
        }
    }

    return r;
}

function parseRules(rules) {
    var ruleTrees = {};

    for (var key in rules) {
        var rule = rules[key];
        ruleTrees[key] = parseRuleTree(key, rule);
    }

    return ruleTrees;
}

function doesMatch(filter, context) {
    return typeof filter === "function" && filter(context) || filter == null;
}

function matchFeature(context, rules, collectedRules) {
    var matched = false;
    var childMatched = false;

    if (rules.length === 0) {
        return;
    }

    for (var r = 0; r < rules.length; r++) {
        var current = rules[r];
        context.properties = current.properties;

        if (current instanceof RuleLeaf) {

            if (doesMatch(current.filter, context)) {
                matched = true;
                collectedRules.push(current);
            }
        } else if (current instanceof RuleTree) {
            if (doesMatch(current.filter, context)) {
                matched = true;

                childMatched = matchFeature(context, current.rules, collectedRules);

                if (!childMatched) {
                    collectedRules.push(current);
                }
            }
        }

        context.properties = null;
    }

    return matched;
}

},{"loglevel":60,"match-feature":61}],102:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
// Rendering styles

var StyleParser = require("./style_parser").StyleParser;

var FeatureSelection = _interopRequire(require("../selection"));

var ShaderProgram = _interopRequire(require("../gl/shader_program"));

var VBOMesh = _interopRequire(require("../gl/vbo_mesh"));

var Material = _interopRequire(require("../material"));

var Light = _interopRequire(require("../light"));

var MethodNotImplemented = require("../utils/errors").MethodNotImplemented;

var shaderSources = _interopRequire(require("../gl/shader_sources"));

// built-in shaders

var log = _interopRequire(require("loglevel"));

// Base class

var Style = {
    init: function init() {
        var _ref = arguments[0] === undefined ? {} : arguments[0];

        var generation = _ref.generation;

        if (!this.isBuiltIn()) {
            this.built_in = false; // explicitly set to false to avoid any confusion
        }

        this.generation = generation; // scene generation id this style was created for
        this.defines = this.hasOwnProperty("defines") && this.defines || {}; // #defines to be injected into the shaders
        this.shaders = this.hasOwnProperty("shaders") && this.shaders || {}; // shader customization (uniforms, defines, blocks, etc.)
        this.selection = this.selection || false; // flag indicating if this style supports feature selection
        this.compiling = false; // programs are currently compiling
        this.compiled = false; // programs are finished compiling
        this.program = null; // GL program reference (for main render pass)
        this.selection_program = null; // GL program reference for feature selection render pass
        this.feature_style = {}; // style for feature currently being parsed, shared to lessen GC/memory thrash
        this.vertex_template = []; // shared single-vertex template, filled out by each style
        this.tile_data = {};
        this.feature_options = {};

        // Default world coords to wrap every 100,000 meters, can turn off by setting this to 'false'
        this.defines.TANGRAM_WORLD_POSITION_WRAP = 100000;

        // Blending
        this.blend = this.blend || "opaque"; // default: opaque styles are drawn first, without blending
        this.defines["TANGRAM_BLEND_" + this.blend.toUpperCase()] = true;

        // If the style defines its own material, replace the inherited material instance
        if (!(this.material instanceof Material)) {
            if (!Material.isValid(this.material)) {
                this.material = StyleParser.defaults.material;
            }
            this.material = new Material(this.material);
        }
        this.material.inject(this);

        // Set lighting mode: fragment, vertex, or none (specified as 'false')
        Light.setMode(this.lighting, this);

        this.initialized = true;
    },

    destroy: function destroy() {
        if (this.program) {
            this.program.destroy();
            this.program = null;
        }

        if (this.selection_program) {
            this.selection_program.destroy();
            this.selection_program = null;
        }

        this.gl = null;
        this.initialized = false;
    },

    reset: function reset() {},

    isBuiltIn: function isBuiltIn() {
        return this.hasOwnProperty("built_in") && this.built_in;
    },

    /*** Style parsing and geometry construction ***/

    // Returns an object to hold feature data (for a tile or other object)
    startData: function startData(tile) {
        this.tile_data[tile] = {
            vertex_data: null,
            uniforms: null
        };
        return this.tile_data[tile];
    },

    // Finalizes an object holding feature data (for a tile or other object)
    endData: function endData(tile) {
        var tile_data = this.tile_data[tile];
        if (tile_data && tile_data.vertex_data) {
            // Only keep final byte buffer
            tile_data.vertex_data.end();
            tile_data.vertex_data = tile_data.vertex_data.buffer;
        }
        this.tile_data[tile] = null;
        return Promise.resolve(tile_data);
    },

    // Has mesh data for a given tile?
    hasDataForTile: function hasDataForTile(tile) {
        return this.tile_data[tile] != null;
    },

    addFeature: function addFeature(feature, rule, context) {
        var tile = context.tile;
        if (tile.generation !== this.generation) {
            return;
        }

        if (!this.tile_data[tile.key]) {
            this.startData(tile.key);
        }

        var style = this.parseFeature(feature, rule, context);

        // Skip feature?
        if (!style) {
            return;
        }

        // First feature in this render style?
        if (!this.tile_data[tile.key].vertex_data) {
            this.tile_data[tile.key].vertex_data = this.vertex_layout.createVertexData();
        }

        this.buildGeometry(feature.geometry, style, this.tile_data[tile.key].vertex_data, context);
    },

    buildGeometry: function buildGeometry(geometry, style, vertex_data, context) {
        if (geometry.type === "Polygon") {
            this.buildPolygons([geometry.coordinates], style, vertex_data, context);
        } else if (geometry.type === "MultiPolygon") {
            this.buildPolygons(geometry.coordinates, style, vertex_data, context);
        } else if (geometry.type === "LineString") {
            this.buildLines([geometry.coordinates], style, vertex_data, context);
        } else if (geometry.type === "MultiLineString") {
            this.buildLines(geometry.coordinates, style, vertex_data, context);
        } else if (geometry.type === "Point") {
            this.buildPoints([geometry.coordinates], style, vertex_data, context);
        } else if (geometry.type === "MultiPoint") {
            this.buildPoints(geometry.coordinates, style, vertex_data, context);
        }
    },

    parseFeature: function parseFeature(feature, rule_style, context) {
        try {
            var style = this.feature_style;

            // Preprocess first time
            if (!rule_style.preprocessed) {
                this.preprocess(rule_style);
                rule_style.preprocessed = true;
            }

            // Calculate order if it was not cached
            style.order = this.parseOrder(rule_style.order, context);

            // Feature selection (only if style supports it)
            var selectable = false;
            style.interactive = rule_style.interactive;
            if (this.selection) {
                if (typeof style.interactive === "function") {
                    selectable = style.interactive(context);
                } else {
                    selectable = style.interactive;
                }
            }

            // If feature is marked as selectable
            if (selectable) {
                style.selection_color = FeatureSelection.makeColor(feature, context.tile);
            } else {
                style.selection_color = FeatureSelection.defaultColor;
            }

            // Subclass implementation
            style = this._parseFeature(feature, rule_style, context);

            return style;
        } catch (error) {
            log.error("Style.parseFeature: style parsing error", feature, style, error);
        }
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        throw new MethodNotImplemented("_parseFeature");
    },

    preprocess: function preprocess() {},

    // Parse an order value
    parseOrder: function parseOrder(order, context) {
        // Calculate order if it was not cached
        if (typeof order !== "number") {
            return StyleParser.calculateOrder(order, context);
        }
        return order;
    },

    // Parse a color of choose a default if acceptable, return undefined if color missing
    parseColor: function parseColor(color, context) {
        // Need either a color, or a shader block for 'color' or 'filter'
        if (color) {
            return StyleParser.cacheColor(color, context);
        } else if (this.shaders.blocks.color || this.shaders.blocks.filter) {
            return StyleParser.defaults.color;
        }
    },

    // Build functions are no-ops until overriden
    buildPolygons: function buildPolygons() {},
    buildLines: function buildLines() {},
    buildPoints: function buildPoints() {},

    /*** GL state and rendering ***/

    setGL: function setGL(gl) {
        this.gl = gl;
    },

    makeMesh: function makeMesh(vertex_data) {
        var _ref = arguments[1] === undefined ? {} : arguments[1];

        var uniforms = _ref.uniforms;

        return new VBOMesh(this.gl, vertex_data, this.vertex_layout, { uniforms: uniforms });
    },

    compile: function compile() {
        if (!this.gl) {
            throw new Error("style.compile(): skipping for " + this.name + " because no GL context");
        }

        if (this.compiling) {
            throw new Error("style.compile(): skipping for " + this.name + " because style is already compiling");
        }
        this.compiling = true;
        this.compiled = false;

        // Build defines & for selection (need to create a new object since the first is stored as a reference by the program)
        var defines = this.buildDefineList();
        if (this.selection) {
            var selection_defines = Object.assign({}, defines);
            selection_defines.TANGRAM_FEATURE_SELECTION = true;
        }

        // Get any custom code blocks, uniform dependencies, etc.
        var blocks = this.shaders && this.shaders.blocks;
        var uniforms = this.shaders && this.shaders.uniforms;

        // accept a single extension, or an array of extensions
        var extensions = this.shaders && this.shaders.extensions;
        if (typeof extensions === "string") {
            extensions = [extensions];
        }

        // Create shaders
        try {
            this.program = new ShaderProgram(this.gl, shaderSources[this.vertex_shader_key], shaderSources[this.fragment_shader_key], {
                name: this.name,
                defines: defines,
                uniforms: uniforms,
                blocks: blocks,
                extensions: extensions
            });
            this.program.compile();

            if (this.selection) {
                this.selection_program = new ShaderProgram(this.gl, shaderSources[this.vertex_shader_key], shaderSources["gl/shaders/selection_fragment"], {
                    name: this.name + " (selection)",
                    defines: selection_defines,
                    uniforms: uniforms,
                    blocks: blocks,
                    extensions: extensions
                });
                this.selection_program.compile();
            } else {
                this.selection_program = null;
            }
        } catch (error) {
            this.compiling = false;
            this.compiled = false;
            throw new Error("style.compile(): style " + this.name + " error:", error);
        }

        this.compiling = false;
        this.compiled = true;
    },

    // Add a shader block
    addShaderBlock: function addShaderBlock(key) {
        var _shaders$blocks$key;

        for (var _len = arguments.length, blocks = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            blocks[_key - 1] = arguments[_key];
        }

        this.shaders.blocks = this.shaders.blocks || {};
        this.shaders.blocks[key] = this.shaders.blocks[key] || [];
        (_shaders$blocks$key = this.shaders.blocks[key]).push.apply(_shaders$blocks$key, blocks);
    },

    // Remove all shader blocks for key
    removeShaderBlock: function removeShaderBlock(key) {
        if (this.shaders.blocks) {
            this.shaders.blocks[key] = null;
        }
    },

    replaceShaderBlock: function replaceShaderBlock(key) {
        for (var _len = arguments.length, blocks = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            blocks[_key - 1] = arguments[_key];
        }

        this.removeShaderBlock(key);
        this.addShaderBlock.apply(this, [key].concat(blocks));
    },

    /** TODO: could probably combine and generalize this with similar method in ShaderProgram
     * (list of define objects that inherit from each other)
     */
    buildDefineList: function buildDefineList() {
        // Add any custom defines to built-in style defines
        var defines = {}; // create a new object to avoid mutating a prototype value that may be shared with other styles
        if (this.defines != null) {
            for (var d in this.defines) {
                defines[d] = this.defines[d];
            }
        }
        if (this.shaders != null && this.shaders.defines != null) {
            for (d in this.shaders.defines) {
                defines[d] = this.shaders.defines[d];
            }
        }
        return defines;
    },

    // Setup any GL state for rendering
    setup: function setup() {
        this.setUniforms();
        this.material.setupProgram(ShaderProgram.current);
    },

    // Set style uniforms on currently bound program
    setUniforms: function setUniforms() {
        var program = ShaderProgram.current;
        if (!program) {
            return;
        }

        program.setUniforms(this.shaders && this.shaders.uniforms, true); // reset texture unit to 0
    },

    update: function update() {}
};
exports.Style = Style;

// Style-specific animation
// if (typeof this.animation === 'function') {
//     this.animation();
// }

},{"../gl/shader_program":79,"../gl/shader_sources":80,"../gl/vbo_mesh":83,"../light":87,"../material":88,"../selection":92,"../utils/errors":112,"./style_parser":104,"loglevel":60}],103:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

Object.defineProperty(exports, "__esModule", {
    value: true
});
// Manage rendering styles

var Utils = _interopRequire(require("../utils/utils"));

var ShaderProgram = _interopRequire(require("../gl/shader_program"));

var shaderSources = _interopRequire(require("../gl/shader_sources"));

// built-in shaders

var Style = require("./style").Style;

var log = _interopRequire(require("loglevel"));

var StyleManager = {};
exports.StyleManager = StyleManager;
var Styles = {};
exports.Styles = Styles;
var BaseStyles = {};

exports.BaseStyles = BaseStyles;
StyleManager.styles = Styles;

// Set the base object used to instantiate styles
StyleManager.baseStyle = Style;

// Global configuration for all styles
StyleManager.init = function () {
    if (StyleManager.initialized) {
        return;
    }

    ShaderProgram.removeBlock("global");

    // Layer re-ordering function
    ShaderProgram.addBlock("global", shaderSources["gl/shaders/layer_order"]);

    // Feature selection global
    ShaderProgram.addBlock("global", shaderSources["gl/shaders/selection_globals"]);

    // World position wrapping
    ShaderProgram.addBlock("global", shaderSources["gl/shaders/world_position_wrap"]);

    // Feature selection vertex shader support
    ShaderProgram.replaceBlock("feature-selection-vertex", shaderSources["gl/shaders/selection_vertex"]);

    // assume min 16-bit depth buffer, in practice uses 14-bits, 1 extra bit to handle virtual half-layers
    // for outlines (inserted in between layers), another extra bit to prevent precision loss
    ShaderProgram.defines.TANGRAM_LAYER_DELTA = 1 / (1 << 14);

    StyleManager.initialized = true;
};

// Destroy all styles for a given GL context
StyleManager.destroy = function (gl) {
    Object.keys(Styles).forEach(function (_name) {
        var style = Styles[_name];
        if (style.gl === gl) {
            log.trace("StyleManager.destroy: destroying render style " + style.name);

            if (!style.isBuiltIn()) {
                StyleManager.remove(style.name);
            }
            style.destroy();
        }
    });
};

// Register a style
StyleManager.register = function (style) {
    Styles[style.name] = style;
    BaseStyles[style.name] = style;
};

// Remove a style
StyleManager.remove = function (name) {
    delete Styles[name];
};

// Preloads network resources in the stylesheet (shaders, textures, etc.)
StyleManager.preload = function (styles, base) {
    // First load remote styles, then load shader blocks from remote URLs
    return StyleManager.loadRemoteStyles(styles, base).then(function (styles) {
        return StyleManager.loadShaderBlocks(styles, base);
    });
};

// Load style definitions from external URLs
StyleManager.loadRemoteStyles = function (styles, base) {
    var _this = this;

    // Collect URLs and modes to import from them
    // This is done as a separate step becuase it is possible to import multiple modes from a single
    // URL, and we want to avoid duplicate calls for the same file.
    var urls = {};
    for (var name in styles) {
        var style = styles[name];
        if (style.url) {
            var url = style.url;
            if (base) {
                url = Utils.addBaseURL(url, base);
            }

            if (!urls[url]) {
                urls[url] = [];
            }

            // Make a list of the styles to import for this URL
            urls[url].push({
                target_name: name,
                source_name: style.name || name
            });
        }
    }

    // As each URL finishes loading, replace the target style(s)
    return Promise.all(Object.keys(urls).map(function (url) {
        return new Promise(function (resolve, reject) {
            Utils.loadResource(url).then(function (data) {
                // Mixin remote styles, within each remote file
                for (var source_style in data) {
                    StyleManager.mix(data[source_style], data);
                }

                // Add remote styles to local styles
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = urls[url][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var target = _step.value;

                        if (data && data[target.source_name]) {
                            styles[target.target_name] = data[target.source_name];
                        } else {
                            delete styles[target.target_name];
                            return reject(new Error("StyleManager.preload: error importing style " + target.target_name + ", could not find source style " + target.source_name + " in " + url));
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                resolve();

                _this.selection = false;
            })["catch"](function (error) {
                log.error("StyleManager.preload: error importing style(s) " + JSON.stringify(urls[url]) + " from " + url, error);
            });
        });
    })).then(function () {
        return Promise.resolve(styles);
    });
};

// Preload shader blocks from external URLs
StyleManager.loadShaderBlocks = function (styles, base) {
    var queue = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = Utils.values(styles)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var style = _step.value;

            if (style.shaders && style.shaders.blocks) {
                var _iteratorNormalCompletion2;

                var _didIteratorError2;

                var _iteratorError2;

                var _iterator2, _step2;

                var _step2$value;

                (function () {
                    var _blocks = style.shaders.blocks;

                    _iteratorNormalCompletion2 = true;
                    _didIteratorError2 = false;
                    _iteratorError2 = undefined;

                    try {
                        for (_iterator2 = Utils.entries(style.shaders.blocks)[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                            (function () {
                                _step2$value = _slicedToArray(_step2.value, 2);
                                var key = _step2$value[0];
                                var block = _step2$value[1];

                                var _key = key;

                                // Array of blocks
                                if (Array.isArray(block)) {
                                    for (var b = 0; b < block.length; b++) {
                                        if (typeof block[b] === "object" && block[b].url) {
                                            (function () {
                                                var _index = b;
                                                var url = block[b].url;
                                                if (base) {
                                                    url = Utils.addBaseURL(url, base);
                                                }

                                                queue.push(Utils.io(Utils.cacheBusterForUrl(url)).then(function (data) {
                                                    _blocks[_key][_index] = data;
                                                })["catch"](function (error) {
                                                    log.error("StyleManager.loadShaderBlocks: error loading shader block", _blocks, _key, _index, error);
                                                }));
                                            })();
                                        }
                                    }
                                }
                                // Single block
                                else if (typeof block === "object" && block.url) {
                                    var url = block.url;
                                    if (base) {
                                        url = Utils.addBaseURL(url, base);
                                    }

                                    queue.push(Utils.io(Utils.cacheBusterForUrl(url)).then(function (data) {
                                        _blocks[_key] = data;
                                    })["catch"](function (error) {
                                        log.error("StyleManager.loadShaderBlocks: error loading shader block", _blocks, _key, error);
                                    }));
                                }
                            })();
                        }
                    } catch (err) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                                _iterator2["return"]();
                            }
                        } finally {
                            if (_didIteratorError2) {
                                throw _iteratorError2;
                            }
                        }
                    }
                })();
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return Promise.all(queue).then(function () {
        return Promise.resolve(styles);
    }); // TODO: add error
};

StyleManager.mix = function (style, styles) {
    // Exit early if we have already applied mixins to this style
    if (style.mixed) {
        return style;
    }

    // Mixin sources, in order
    var sources = [];
    if (style.mix) {
        if (Array.isArray(style.mix)) {
            sources.push.apply(sources, _toConsumableArray(style.mix));
        } else {
            sources.push(style.mix);
        }
        sources = sources.map(function (x) {
            return styles[x];
        }).filter(function (x) {
            return x;
        });
    }
    sources.push(style);

    // Flags - OR'd, true if any style has it set
    style.animated = sources.some(function (x) {
        return x && x.animated;
    });
    style.texcoords = sources.some(function (x) {
        return x && x.texcoords;
    });

    // Overwrites - last definition wins
    style.base = sources.map(function (x) {
        return x.base;
    }).filter(function (x) {
        return x;
    }).pop();
    style.lighting = sources.map(function (x) {
        return x.lighting;
    }).filter(function (x) {
        return x != null;
    }).pop();
    style.texture = sources.map(function (x) {
        return x.texture;
    }).filter(function (x) {
        return x;
    }).pop();
    if (sources.some(function (x) {
        return x.blend;
    })) {
        // only mix blend if explicitly set, otherwise let base style choose blending mode
        style.blend = sources.map(function (x) {
            return x.blend;
        }).filter(function (x) {
            return x;
        }).pop();
    }

    // Merges - property-specific rules for merging values
    style.defines = Object.assign.apply(Object, [{}].concat(_toConsumableArray(sources.map(function (x) {
        return x.defines;
    }).filter(function (x) {
        return x;
    }))));
    style.material = Object.assign.apply(Object, [{}].concat(_toConsumableArray(sources.map(function (x) {
        return x.material;
    }).filter(function (x) {
        return x;
    }))));

    var merge = sources.map(function (x) {
        return x.shaders;
    }).filter(function (x) {
        return x;
    });
    var shaders = {};
    shaders.defines = Object.assign.apply(Object, [{}].concat(_toConsumableArray(merge.map(function (x) {
        return x.defines;
    }).filter(function (x) {
        return x;
    }))));
    shaders.uniforms = Object.assign.apply(Object, [{}].concat(_toConsumableArray(merge.map(function (x) {
        return x.uniforms;
    }).filter(function (x) {
        return x;
    }))));

    // Build a list of unique extensions
    shaders.extensions = Object.keys(merge.map(function (x) {
        return x.extensions;
    }).filter(function (x) {
        return x;
    }).reduce(function (prev, cur) {
        // single extension
        if (typeof cur === "string") {
            prev[cur] = true;
        }
        // array of extensions
        else {
            cur.forEach(function (x) {
                return prev[x] = true;
            });
        }
        return prev;
    }, {}) || {});

    merge.map(function (x) {
        return x.blocks;
    }).filter(function (x) {
        return x;
    }).forEach(function (blocks) {
        shaders.blocks = shaders.blocks || {};

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = Utils.entries(blocks)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _step$value = _slicedToArray(_step.value, 2);

                var t = _step$value[0];
                var block = _step$value[1];

                shaders.blocks[t] = shaders.blocks[t] || [];

                if (Array.isArray(block)) {
                    var _shaders$blocks$t;

                    (_shaders$blocks$t = shaders.blocks[t]).push.apply(_shaders$blocks$t, _toConsumableArray(block));
                } else {
                    shaders.blocks[t].push(block);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    });

    style.shaders = shaders;
    style.mixed = true; // track that we already applied mixins (avoid dupe work later)

    return style;
};

// Create a new style
// name: name of new style
// config: properties of new style
// styles: working set of styles being built (used for mixing in existing styles)
StyleManager.create = function (name, config) {
    var styles = arguments[2] === undefined ? {} : arguments[2];

    var style = Object.assign({}, config); // shallow copy
    style.name = name;

    // Style mixins
    StyleManager.mix(style, styles);

    // Has base style?
    // Only renderable (instantiated) styles should be included for run-time use
    // Others are intermediary/abstract, used during style composition but not execution
    if (style.base && BaseStyles[style.base]) {
        Styles[name] = style = Object.assign(Object.create(BaseStyles[style.base]), style);
    }

    return style;
};

// Called to create and initialize styles
StyleManager.build = function (styles) {
    var scene = arguments[1] === undefined ? {} : arguments[1];

    // Sort styles by dependency, then build them
    var style_deps = Object.keys(styles).sort(function (a, b) {
        return StyleManager.inheritanceDepth(a, styles) - StyleManager.inheritanceDepth(b, styles);
    });

    // Only keep built-in base styles
    for (var sname in Styles) {
        if (!BaseStyles[sname]) {
            delete Styles[sname];
        } else {
            Styles[sname].reset();
        }
    }

    // Working set of styles being built
    var ws = {};
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = style_deps[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var sname = _step.value;

            ws[sname] = StyleManager.create(sname, styles[sname], ws);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    StyleManager.initStyles(scene);
    return Styles;
};

// Initialize all styles
StyleManager.initStyles = function (scene) {
    // Initialize all
    for (var sname in Styles) {
        Styles[sname].init(scene);
    }
};

// Given a style key in a set of styles to add, count the length of the inheritance chain
// TODO: remove current (Styles) and future (styles) duplication, confusing
StyleManager.inheritanceDepth = function (key, styles) {
    var parents = 0;

    while (true) {
        var style = styles[key];
        if (!style) {
            // this is a scene def error, trying to extend a style that doesn't exist
            // TODO: warn/throw?
            break;
        }

        // Dependency chain ends when this style isn't mixing in any others
        if (!style.mix) {
            break;
        }

        // Traverse next parent style
        parents++;

        if (Array.isArray(style.mix)) {
            // If multiple mixins, find the deepest one
            parents += Math.max.apply(Math, _toConsumableArray(style.mix.map(function (s) {
                return StyleManager.inheritanceDepth(s, styles);
            })));
            break;
        } else {
            // If single mixin, continue loop up the tree
            key = style.mix;
        }
    }
    return parents;
};

// Compile all styles
StyleManager.compile = function (keys, scene) {
    keys = keys || Object.keys(Styles);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var key = _step.value;

            var style = Styles[key];
            try {
                style.compile();
                log.trace("StyleManager.compile(): compiled style " + key);
            } catch (error) {
                log.error("StyleManager.compile(): error compiling style " + key + ":", error);

                scene.trigger("warning", {
                    type: "styles",
                    message: "Error compiling style " + key,
                    style: style,
                    shader_errors: style.program && style.program.shader_errors
                });
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    log.debug("StyleManager.compile(): compiled all styles");
};

// Get all styles with mesh data for a given tile
StyleManager.stylesForTile = function (tile) {
    var styles = [];
    for (var s in Styles) {
        if (Styles[s].hasDataForTile(tile)) {
            styles.push(s);
        }
    }
    return styles;
};

},{"../gl/shader_program":79,"../gl/shader_sources":80,"../utils/utils":115,"./style":102,"loglevel":60}],104:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});

var Utils = _interopRequire(require("../utils/utils"));

var Geo = _interopRequire(require("../geo"));

var parseCSSColor = _interopRequire(require("csscolorparser"));

var log = _interopRequire(require("loglevel"));

var StyleParser = {};

exports.StyleParser = StyleParser;
// Style macros

StyleParser.expandMacros = function expandMacros(obj) {
    for (var p in obj) {
        var val = obj[p];

        // Loop through object properties
        if (typeof val === "object") {
            obj[p] = expandMacros(val);
        }
        // Convert strings back into functions
        else if (typeof val === "string") {
            for (var m in StyleParser.macros) {
                if (val.match(StyleParser.macros[m])) {
                    var f;
                    try {
                        /*jshint ignore:start */
                        eval("f = " + val);
                        /*jshint ignore:end */
                        obj[p] = f;
                        log.trace("expanded macro " + val + " to " + f);
                        break;
                    } catch (e) {
                        // fall-back to original value if parsing failed
                        obj[p] = val;
                        log.trace("failed to expand macro " + val);
                    }
                }
            }
        }
    }

    return obj;
};

// List of macros
StyleParser.macros = ["Style.color.pseudoRandomColor", "Style.color.randomColor"];

var Style = {};

Style.color = {
    // pseudo-random grayscale by geometry id
    pseudoRandomGrayscale: function pseudoRandomGrayscale() {
        var func = "function() {\n            var c = Math.max((parseInt(feature.id, 16) % 100) / 100, 0.4);\n            return [0.7 * c, 0.7 * c, 0.7 * c];\n        }";
        return func;
    },

    // pseudo-random color by geometry id
    pseudoRandomColor: function pseudoRandomColor() {
        var func = "function() {\n            return [\n                0.7 * (parseInt(feature.id, 16) / 100 % 1),\n                0.7 * (parseInt(feature.id, 16) / 10000 % 1),\n                0.7 * (parseInt(feature.id, 16) / 1000000 % 1)\n            ];\n        }";
        return func;
        // return `function() { return [0.7 * (parseInt(feature.id, 16) / 100 % 1), 0.7 * (parseInt(feature.id, 16) / 10000 % 1), 0.7 * (parseInt(feature.id, 16) / 1000000 % 1)]; }`;
    },

    // random color
    randomColor: function randomColor() {
        var func = "function() {\n            return [0.7 * Math.random(), 0.7 * Math.random(), 0.7 * Math.random()];\n        }";
        return func;
    }
};

// Wraps style functions and provides a scope of commonly accessible data:
// - feature: the 'properties' of the feature, e.g. accessed as 'feature.name'
// - $zoom: the current map zoom level
// - $geometry: the type of geometry, 'point', 'line', or 'polygon'
// - $meters_per_pixel: conversion for meters/pixels at current map zoom
// - properties: user-defined properties on the style-rule object in the stylesheet
StyleParser.wrapFunction = function (func) {
    var f = "function(context) {\n                var feature = context.feature.properties;\n                var $zoom = context.zoom;\n                var $geometry = context.geometry;\n                var $meters_per_pixel = context.meters_per_pixel;\n                var properties = context.properties;\n                return (" + func + "());\n            }";
    return f;
};

// Style parsing

// Style defaults
StyleParser.defaults = {
    color: [1, 1, 1, 1],
    width: 1,
    size: 1,
    extrude: false,
    height: 20,
    min_height: 0,
    order: 0,
    z: 0,
    material: {
        ambient: 1,
        diffuse: 1
    }
};

// A context object that is passed to style parsing functions to provide a scope of commonly used values
StyleParser.getFeatureParseContext = function (feature, tile) {
    return {
        feature: feature,
        tile: tile,
        zoom: tile.style_zoom,
        geometry: Geo.geometryType(feature.geometry.type),
        meters_per_pixel: Geo.metersPerPixel(tile.coords.z),
        units_per_meter: Geo.units_per_meter[tile.coords.z]
    };
};

StyleParser.convertUnits = function (val, context) {
    var convert = arguments[2] === undefined ? "meters" : arguments[2];

    if (typeof val === "string") {
        var units = val.match(/([0-9.-]+)([a-z]+)/);
        if (units && units.length === 3) {
            val = parseFloat(units[1]);
            units = units[2];
        }

        // Convert to meters
        if (convert === "meters") {
            // Convert from pixels
            if (units === "px") {
                val *= Geo.metersPerPixel(context.zoom);
            }
            // Convert from kilometers
            else if (units === "km") {
                val *= 1000;
            }
        }
    } else if (Array.isArray(val)) {
        // Array of arrays, e.g. zoom-interpolated stops
        if (Array.isArray(val[0])) {
            return val.map(function (v) {
                return [v[0], StyleParser.convertUnits(v[1], context, convert)];
            });
        }
        // Array of values
        else {
            return val.map(function (v) {
                return StyleParser.convertUnits(v, context, convert);
            });
        }
    }
    return val;
};

// Takes a distance cache object and returns a distance value for this zoom
// (caching the result for future use)
// { value: original, zoom: { z: meters }, dynamic: function(){...} }
StyleParser.cacheDistance = function (val, context) {
    var convert = arguments[2] === undefined ? "meters" : arguments[2];

    if (val.dynamic) {
        var v = val.dynamic(context);
        return v;
    } else if (val.zoom && val.zoom[convert] && val.zoom[convert][context.zoom]) {
        return val.zoom[convert][context.zoom];
    } else {
        // Dynamic function-based
        if (typeof val.value === "function") {
            val.dynamic = val.value;
            var v = val.dynamic(context);
            return v;
        }
        // Array of zoom-interpolated stops, e.g. [zoom, value] pairs
        else {
            // Calculate value for current zoom
            val.zoom = val.zoom || {};
            var zunits = val.zoom[convert] = val.zoom[convert] || {};

            zunits[context.zoom] = StyleParser.convertUnits(val.value, context, convert === "meters" && "meters"); // convert to meters
            zunits[context.zoom] = Utils.interpolate(context.zoom, zunits[context.zoom]);

            return zunits[context.zoom];
        }
    }
};

// Cache previously parsed color strings
StyleParser.string_colors = {};
StyleParser.colorForString = function (string) {
    // Cached
    if (StyleParser.string_colors[string]) {
        return StyleParser.string_colors[string];
    }

    // Calculate and cache
    var color = parseCSSColor.parseCSSColor(string);
    if (color && color.length === 4) {
        color[0] /= 255;
        color[1] /= 255;
        color[2] /= 255;
        color[3] = 1;
    } else {
        color = StyleParser.defaults.color;
    }
    StyleParser.string_colors[string] = color;
    return color;
};

// Takes a color cache object and returns a color value for this zoom
// (caching the result for future use)
// { value: original, static: [r,g,b,a], zoom: { z: [r,g,b,a] }, dynamic: function(){...} }
StyleParser.cacheColor = function (val) {
    var context = arguments[1] === undefined ? {} : arguments[1];

    if (val.dynamic) {
        var v = val.dynamic(context);
        v[3] = v[3] || 1; // default alpha
        return v;
    } else if (val["static"]) {
        return val["static"];
    } else if (val.zoom && val.zoom[context.zoom]) {
        return val.zoom[context.zoom];
    } else {
        // Dynamic function-based color
        if (typeof val.value === "function") {
            val.dynamic = val.value;
            var v = val.dynamic(context);
            v[3] = v[3] || 1; // default alpha
            return v;
        }
        // Single string color
        else if (typeof val.value === "string") {
            val["static"] = StyleParser.colorForString(val.value);
            return val["static"];
        }
        // Array of zoom-interpolated stops, e.g. [zoom, color] pairs
        else if (Array.isArray(val.value) && Array.isArray(val.value[0])) {
            if (!val.zoom) {
                val.zoom = {};
                // Parse any string colors inside stops
                for (var i = 0; i < val.value.length; i++) {
                    var v = val.value[i];
                    if (typeof v[1] === "string") {
                        v[1] = StyleParser.colorForString(v[1]);
                    }
                }
            }

            // Calculate color for current zoom
            val.zoom[context.zoom] = Utils.interpolate(context.zoom, val.value);
            val.zoom[context.zoom][3] = val.zoom[context.zoom][3] || 1; // default alpha
            return val.zoom[context.zoom];
        }
        // Single array color
        else {
            val["static"] = val.value;
            val["static"][3] = val["static"][3] || 1; // default alpha
            return val["static"];
        }
    }
};

StyleParser.parseColor = function (val) {
    var context = arguments[1] === undefined ? {} : arguments[1];

    if (typeof val === "function") {
        val = val(context);
    }

    // Parse CSS-style colors
    // TODO: change all colors to use 0-255 range internally to avoid dividing and then re-multiplying in geom builder
    if (typeof val === "string") {
        val = parseCSSColor.parseCSSColor(val);
        if (val && val.length === 4) {
            val[0] /= 255;
            val[1] /= 255;
            val[2] /= 255;
        } else {
            val = null;
        }
    } else if (Array.isArray(val) && Array.isArray(val[0])) {
        // Array of zoom-interpolated stops, e.g. [zoom, color] pairs
        for (var i = 0; i < val.length; i++) {
            var v = val[i];
            if (typeof v[1] === "string") {
                var vc = parseCSSColor.parseCSSColor(v[1]);
                if (vc && vc.length === 4) {
                    vc[0] /= 255;
                    vc[1] /= 255;
                    vc[2] /= 255;
                    v[1] = vc;
                }
            }
        }
    }

    if (context.zoom) {
        val = Utils.interpolate(context.zoom, val);
    }

    // Defaults
    if (val) {
        // alpha
        if (!val[3]) {
            val[3] = 1;
        }
    } else {
        val = [0, 0, 0, 1];
    }

    return val;
};

// Order is summed from top to bottom in the style hierarchy:
// each child order value is added to the parent order value
StyleParser.calculateOrder = function (order, context) {
    if (typeof order === "function") {
        order = order(context);
    } else if (Array.isArray(order)) {
        order = order.reduce(function (sum, order) {
            order = order || StyleParser.defaults.order;
            if (typeof order === "function") {
                order = order(context);
            } else if (typeof order === "string") {
                order = context.feature.properties[order];
            } else {
                order = parseFloat(order);
            }

            if (!order || isNaN(order)) {
                return sum;
            }
            return sum + order;
        }, 0);
    } else if (typeof order === "string") {
        if (context.feature.properties[order]) {
            order = context.feature.properties[order];
        } else {
            order = parseFloat(order);
        }
    }

    return order;
};

},{"../geo":73,"../utils/utils":115,"csscolorparser":19,"loglevel":60}],105:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Label */

var boxIntersect = _interopRequire(require("box-intersect"));

var Utils = _interopRequire(require("../../utils/utils"));

var Geo = _interopRequire(require("../../geo"));

var OBB = _interopRequire(require("../../utils/obb"));

var Vector = _interopRequire(require("../../vector"));

var Label = (function () {
    function Label(text, size, _ref) {
        var move_in_tile = _ref.move_in_tile;
        var keep_in_tile = _ref.keep_in_tile;

        _classCallCheck(this, Label);

        Object.assign(this, {
            text: text,
            size: size,
            position: [],
            aabb: [],
            move_in_tile: move_in_tile,
            keep_in_tile: keep_in_tile
        });

        this.id = Label.id++;
        this.buffer = this.buffer || 2; // TODO: make configurable
        this.buffer *= Geo.units_per_pixel;
        this.keep_min_distance = true;
    }

    _createClass(Label, {
        isComposite: {
            value: function isComposite() {
                return false;
            }
        },
        occluded: {
            value: function occluded(aabbs) {
                var _this = this;

                var intersect = false;

                // Broadphase
                if (aabbs.length > 0) {
                    boxIntersect([this.aabb], aabbs, function (i, j) {
                        // Narrow phase
                        if (OBB.intersect(_this.aabb.obb, aabbs[j].obb)) {
                            intersect = true;
                            return true;
                        }
                    });
                }

                // No collision on aabb
                if (!intersect) {
                    aabbs.push(this.aabb);
                }

                return intersect;
            }
        },
        checkMinDistance: {

            // keep a minimal distance between the labels

            value: function checkMinDistance(aabbs) {
                var obb1 = this.aabb.obb;
                var w1 = Math.abs(obb1.quad[1][0] - obb1.quad[0][0]);

                for (var i = 0; i < aabbs.length; ++i) {
                    var aabb = aabbs[i];
                    var obb0 = aabb.obb;

                    var dHalf = Vector.length(Vector.mult(Vector.sub(obb0.centroid, obb1.centroid), 0.5));
                    var w0 = Math.abs(obb0.quad[1][0] - obb0.quad[0][0]);

                    // skip obbs with half distance less than an obb width
                    if (dHalf > w0 + this.buffer && dHalf > w1 + this.buffer) {
                        continue;
                    }

                    for (var j = 0; j < obb0.quad.length; ++j) {
                        var v0 = obb0.quad[j];
                        for (var k = 0; k < obb1.quad.length; ++k) {
                            var v1 = obb1.quad[k];
                            var d = Vector.length(Vector.sub(v0, v1));

                            if (d < this.buffer) {
                                return true;
                            }
                        }
                    }
                }

                return false;
            }
        },
        inTileBounds: {

            // checks whether the label is within the tile boundaries

            value: function inTileBounds() {
                var min = [this.aabb[0], this.aabb[1]];
                var max = [this.aabb[2], this.aabb[3]];

                if (!Utils.pointInTile(min) || !Utils.pointInTile(max)) {
                    return false;
                }

                return true;
            }
        },
        discard: {

            // whether the label should be discarded
            // 1. try to keep the label in tile if the label (to avoid collision over tile for now)
            // 2. if 1. -> keep a minimal distance between the label
            // 3. if 2. -> perfom occlusion

            value: function discard(aabbs) {
                var discard = false;

                // perform specific styling rule, should we keep the label in tile bounds?
                if (this.keep_in_tile) {
                    var in_tile = this.inTileBounds();

                    if (!in_tile && this.move_in_tile) {
                        // can we move?
                        discard = this.moveInTile();
                    } else if (!in_tile) {
                        // we didn't want to move at all,
                        // just discard since we're out of tile bounds
                        return true;
                    }
                }

                if (this.keep_min_distance) {
                    discard |= this.checkMinDistance(aabbs);
                }

                // should we discard? if not, just make occlusion test
                return discard || this.occluded(aabbs);
            }
        }
    });

    return Label;
})();

module.exports = Label;

Label.id = 0;

},{"../../geo":73,"../../utils/obb":113,"../../utils/utils":115,"../../vector":118,"box-intersect":4}],106:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var LabelPoint = _interopRequire(require("./label_point"));

var LabelLine = _interopRequire(require("./label_line"));

var Geo = _interopRequire(require("../../geo"));

var LabelBuilder;
module.exports = LabelBuilder = {};

LabelBuilder.labelsFromGeometry = function (geometry, _ref, label_style) {
    var text = _ref.text;
    var size = _ref.size;

    var labels = [];

    if (geometry.type === "LineString") {
        var lines = geometry.coordinates;

        labels.push(new LabelLine(text, size, lines, label_style.lines, { move_in_tile: true, keep_in_tile: true }));
    } else if (geometry.type === "MultiLineString") {
        var lines = geometry.coordinates;

        for (var i = 0; i < lines.length; ++i) {
            var line = lines[i];

            labels.push(new LabelLine(text, size, line, label_style.lines, { move_in_tile: true, keep_in_tile: true }));
        }
    } else if (geometry.type === "Point") {
        var width = label_style.points.max_width;

        // if (width && size.text_size[0] > width) {
        //     let line_height = (size.px_logical_size / 100) * label_style.points.line_height;
        //     line_height = Utils.pixelToMercator(line_height);
        //     let label = LabelPoint.explode(text, geometry.coordinates, size, width, line_height, { move_in_tile: true, keep_in_tile: true });

        //     labels.push(label);
        // } else {
        if (!(width && size.text_size[0] > width)) {
            labels.push(new LabelPoint(text, geometry.coordinates, size, null, { move_in_tile: true, keep_in_tile: true }));
        }
    } else if (geometry.type === "MultiPoint") {
        var points = geometry.coordinates;

        for (var i = 0; i < points.length; ++i) {
            var point = points[i];
            labels.push(new LabelPoint(text, point, size, null, { move_in_tile: true, keep_in_tile: true }));
        }
    } else if (geometry.type === "Polygon") {
        var centroid = Geo.centroid(geometry.coordinates[0]);
        var area = Geo.polygonArea(geometry.coordinates[0]);

        labels.push(new LabelPoint(text, centroid, size, area, { move_in_tile: true, keep_in_tile: true }));
    } else if (geometry.type === "MultiPolygon") {
        var centroid = Geo.multiCentroid(geometry.coordinates);
        var area = Geo.multiPolygonArea(geometry.coordinates);

        labels.push(new LabelPoint(text, centroid, size, area, { move_in_tile: true, keep_in_tile: true }));
    }

    return labels;
};

},{"../../geo":73,"./label_line":107,"./label_point":108}],107:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var Vector = _interopRequire(require("../../vector"));

var Geo = _interopRequire(require("../../geo"));

var Label = _interopRequire(require("./label"));

var Utils = _interopRequire(require("../../utils/utils"));

var OBB = _interopRequire(require("../../utils/obb"));

var LabelLine = (function (_Label) {
    function LabelLine(text, size, lines, style, _ref) {
        var move_in_tile = _ref.move_in_tile;
        var keep_in_tile = _ref.keep_in_tile;

        _classCallCheck(this, LabelLine);

        _get(Object.getPrototypeOf(LabelLine.prototype), "constructor", this).call(this, text, size, { move_in_tile: move_in_tile, keep_in_tile: keep_in_tile });

        this.segment_index = 0;
        this.lines = lines;
        this.exceed_heuristic = style.exceed;
        this.offset = style.offset;
        this.update();
    }

    _inherits(LabelLine, _Label);

    _createClass(LabelLine, {
        middleSegment: {
            value: function middleSegment(segment) {
                return [(segment[0][0] + segment[1][0]) / 2, (segment[0][1] + segment[1][1]) / 2];
            }
        },
        update: {
            value: function update() {
                var segment = this.currentSegment();

                this.angle = this.computeAngle();

                var perp = Vector.normalize(Vector.perp(segment[0], segment[1]));
                var dot = Vector.dot(perp, [0, 1]);
                var offset = Vector.mult(perp, Utils.pixelToMercator(this.offset * Math.sign(dot)));

                this.position = Vector.add(this.middleSegment(segment), offset);
                this.aabb = this.computeAABB();
            }
        },
        moveNextSegment: {
            value: function moveNextSegment() {
                if (this.segment_index + 1 >= this.lines.length - 1) {
                    return false;
                }

                this.segment_index++;
                this.update();

                return true;
            }
        },
        computeAngle: {
            value: function computeAngle() {
                var segment = this.currentSegment();
                var p0p1 = Vector.sub(segment[0], segment[1]);

                p0p1 = Vector.normalize(p0p1);

                var PI_2 = Math.PI / 2;
                var theta = Math.atan2(p0p1[0], p0p1[1]) + PI_2;

                if (theta > PI_2 || theta < -PI_2) {
                    theta += Math.PI;
                }
                theta %= Math.PI * 2;

                return theta;
            }
        },
        fitToSegment: {
            value: function fitToSegment() {
                var should_fit = arguments[0] === undefined ? true : arguments[0];

                if (!should_fit) {
                    return true;
                }

                var segment = this.currentSegment();
                var p0p1 = Vector.sub(segment[0], segment[1]);
                var length = Vector.length(p0p1);

                var label_length = Utils.pixelToMercator(this.size.text_size[0]);

                if (label_length > length) {
                    // an exceed heurestic of 100% would let the label fit in any cases
                    var exceed = (1 - length / label_length) * 100;
                    return exceed < this.exceed_heuristic;
                }

                return label_length < length;
            }
        },
        currentSegment: {
            value: function currentSegment() {
                var p1 = this.lines[this.segment_index];
                var p2 = this.lines[this.segment_index + 1];

                return [p1, p2];
            }
        },
        computeAABB: {
            value: function computeAABB(size) {
                var upp = Geo.units_per_pixel;

                var merc_width = this.size.text_size[0] * upp;
                var merc_height = this.size.text_size[1] * upp;

                // the angle of the obb is negative since it's the tile system y axis is pointing down
                var obb = new OBB(this.position[0], this.position[1], -this.angle, merc_width, merc_height);
                var aabb = obb.getExtent();
                aabb.obb = obb;

                return aabb;
            }
        },
        moveInTile: {
            value: function moveInTile() {
                var in_tile = false;
                var fits_to_segment = this.fitToSegment();

                // move this label until we found a line we can fit in
                while (!in_tile && !fits_to_segment) {
                    if (!this.moveNextSegment()) {
                        // we can't move further in this line
                        break;
                    }

                    in_tile = this.inTileBounds();
                    fits_to_segment = this.fitToSegment();
                }

                return !in_tile || !fits_to_segment;
            }
        },
        discard: {
            value: function discard(aabbs) {
                if (this.lines && !this.fitToSegment()) {
                    while (!this.fitToSegment()) {
                        if (!this.moveNextSegment()) {
                            return true;
                        }
                    }
                }

                return _get(Object.getPrototypeOf(LabelLine.prototype), "discard", this).call(this, aabbs);
            }
        }
    });

    return LabelLine;
})(Label);

module.exports = LabelLine;

},{"../../geo":73,"../../utils/obb":113,"../../utils/utils":115,"../../vector":118,"./label":105}],108:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var Label = _interopRequire(require("./label"));

var Utils = _interopRequire(require("../../utils/utils"));

var Geo = _interopRequire(require("../../geo"));

var OBB = _interopRequire(require("../../utils/obb"));

var LabelPoint = (function (_Label) {
    function LabelPoint(text, position, size, area, _ref) {
        var move_in_tile = _ref.move_in_tile;
        var keep_in_tile = _ref.keep_in_tile;

        _classCallCheck(this, LabelPoint);

        _get(Object.getPrototypeOf(LabelPoint.prototype), "constructor", this).call(this, text, size, { move_in_tile: move_in_tile, keep_in_tile: keep_in_tile });

        this.area = area;
        this.position = position;
        this.aabb = this.computeAABB();
    }

    _inherits(LabelPoint, _Label);

    _createClass(LabelPoint, {
        computeAABB: {
            value: function computeAABB() {
                var merc_width = Utils.pixelToMercator(this.size.text_size[0]);
                var merc_height = Utils.pixelToMercator(this.size.text_size[1]);

                var obb = new OBB(this.position[0], this.position[1], 0, merc_width, merc_height);
                var aabb = obb.getExtent();
                aabb.obb = obb;

                return aabb;
            }
        },
        moveInTile: {
            value: function moveInTile(in_tile) {
                var width = this.aabb[2] - this.aabb[0];
                var height = -this.aabb[3] - -this.aabb[1];

                // Move point labels to tile edges
                if (this.position[0] - width / 2 < 0) {
                    this.position[0] = width / 2 + 1;
                } else if (this.position[0] + width / 2 > Geo.tile_scale) {
                    this.position[0] = Geo.tile_scale - (width / 2 + 1);
                }

                this.position[1] *= -1; // just doing this so Y coord is positive
                if (this.position[1] - height / 2 < 0) {
                    // && this.position[1] > 0) {
                    this.position[1] = height / 2 + 1;
                } else if (this.position[1] + height / 2 > Geo.tile_scale) {
                    this.position[1] = Geo.tile_scale - (height / 2 + 1);
                }
                this.position[1] *= -1;

                this.aabb = this.computeAABB();
                return !this.inTileBounds();
            }
        }
    }, {
        explode: {
            value: function explode(text, position, size, max_width, padding, move_in_tile, keep_in_tile) {
                var split_text = text.split(" ");

                if (split_text.length < 2) {
                    return new LabelPoint(text, position, size, null, move_in_tile, keep_in_tile);
                }

                var line = new TextLine(text, size.text_size[0], split_text, size.split_size);
                var lines = line.explode(max_width);
                var labels = [];

                if (lines.length === 1) {
                    return new LabelPoint(text, position, size, null, move_in_tile, keep_in_tile);
                }

                for (var i in lines) {
                    var l = lines[i];
                    var pos = [position[0], position[1] - Math.abs(padding) * i];
                    labels.push(new LabelPoint(l.text, pos, size, null, move_in_tile, keep_in_tile));
                }

                return new LabelComposite(text, position, size, labels, move_in_tile, keep_in_tile);
            }
        }
    });

    return LabelPoint;
})(Label);

module.exports = LabelPoint;

var LabelComposite = (function (_Label2) {
    function LabelComposite(text, position, size, labels, move_in_tile, keep_in_tile) {
        _classCallCheck(this, LabelComposite);

        _get(Object.getPrototypeOf(LabelComposite.prototype), "constructor", this).call(this, text, size, move_in_tile, keep_in_tile);

        this.position = position;
        this.labels = labels;
        this.aabb = this.computeAABB();
    }

    _inherits(LabelComposite, _Label2);

    _createClass(LabelComposite, {
        isComposite: {
            value: function isComposite() {
                return true;
            }
        },
        moveInTile: {
            value: function moveInTile(in_tile) {
                return false;
            }
        },
        computeAABB: {
            value: function computeAABB() {
                var aabb = [Infinity, Infinity, -Infinity, -Infinity];

                for (var i in this.labels) {
                    var b = this.labels[i].aabb;

                    aabb[0] = Math.min(b[0], aabb[0]);
                    aabb[1] = Math.min(b[1], aabb[1]);
                    aabb[2] = Math.max(b[2], aabb[2]);
                    aabb[3] = Math.max(b[3], aabb[3]);
                }

                return aabb;
            }
        }
    });

    return LabelComposite;
})(Label);

var TextLine = (function () {
    function TextLine(text, line_length, words, size_info) {
        _classCallCheck(this, TextLine);

        this.text = text;
        this.line_length = line_length;
        this.size_info = size_info;
        this.words = this.positions(words);
    }

    _createClass(TextLine, {
        positions: {
            value: function positions(words, size_info) {
                var word_infos = [];
                var offset = 0;
                var space_offset = this.size_info[" "];

                for (var i = 0; i < words.length; ++i) {
                    var word = words[i];
                    var word_length = this.size_info[word];

                    word_infos.push({
                        word: word,
                        start: offset,
                        end: offset + word_length
                    });
                    offset += word_length;

                    if (i !== words.length - 1) {
                        word_infos.push({
                            word: " ",
                            start: offset,
                            end: offset + space_offset
                        });
                        offset += space_offset;
                    }
                }

                return word_infos;
            }
        },
        explode: {
            value: function explode(max_width) {
                var exploded_lines = arguments[1] === undefined ? [] : arguments[1];

                if (max_width > this.line_length) {
                    exploded_lines.push(this);
                    return exploded_lines;
                }

                var index = this.wordInfoIndex(max_width);

                if (this.words[index].word === " ") {
                    index -= 1;
                }

                if (index < 1) {
                    exploded_lines.push(this);
                    return exploded_lines;
                }

                if (index < this.words.length) {
                    var next_line_length = 0,
                        previous_line_length = 0;
                    var next_line_words = "",
                        previous_line_words = "";

                    for (var i = index; i < this.words.length; ++i) {
                        next_line_words += this.words[i].word;
                        next_line_length += this.size_info[this.words[i].word];
                    }

                    for (var i = 0; i < index; i++) {
                        if (i !== index - 1 && this.words[i] !== " ") {
                            previous_line_words += this.words[i].word;
                            previous_line_length += this.size_info[this.words[i].word];
                        }
                    }

                    exploded_lines.push(new TextLine(previous_line_words, previous_line_length, previous_line_words.split(" "), this.size_info));

                    var next_line = new TextLine(next_line_words, next_line_length, next_line_words.split(" "), this.size_info);

                    return next_line.explode(max_width, exploded_lines);
                }

                exploded_lines.push(this);
                return exploded_lines;
            }
        },
        wordInfoIndex: {
            value: function wordInfoIndex(position) {
                if (position > this.line_length || this.words[this.words.length - 1].end < position) {
                    return this.words.length - 1;
                } else if (position < 0) {
                    return 0;
                }

                var d = this.words.length / 2;
                var i = Math.ceil(d);
                i = Math.min(Math.max(0, i), this.words.length - 1);
                var word_info = this.words[i];

                // dichotomic search
                while (word_info.start > position || word_info.end < position) {
                    d /= 2;
                    i += word_info.end < position ? Math.ceil(d) : -Math.ceil(d);
                    i = Math.min(Math.max(0, i), this.words.length - 1);
                    word_info = this.words[i];
                }

                return i;
            }
        }
    });

    return TextLine;
})();

},{"../../geo":73,"../../utils/obb":113,"../../utils/utils":115,"./label":105}],109:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

Object.defineProperty(exports, "__esModule", {
    value: true
});
// Text rendering style

var Builders = _interopRequire(require("../builders"));

var StyleParser = require("../style_parser").StyleParser;

var Texture = _interopRequire(require("../../gl/texture"));

var WorkerBroker = _interopRequire(require("../../utils/worker_broker"));

var Utils = _interopRequire(require("../../utils/utils"));

var Points = require("../points/points").Points;

var LabelBuilder = _interopRequire(require("./label_builder"));

var log = _interopRequire(require("loglevel"));

var TextStyle = Object.create(Points);

exports.TextStyle = TextStyle;
Object.assign(TextStyle, {
    name: "text",
    "super": Points,
    built_in: true,
    selection: false, // no feature selection for text by default

    init: function init() {

        this["super"].init.apply(this, arguments);

        // Provide a hook for this object to be called from worker threads
        this.main_thread_target = "TextStyle-" + this.name;
        if (Utils.isMainThread) {
            WorkerBroker.addTarget(this.main_thread_target, this);
        }

        // Point style (parent class) requires texturing to be turned on
        // (labels are always drawn with textures)
        this.defines.TANGRAM_POINT_TEXTURE = true;

        // Manually un-multiply alpha, because Canvas text rasterization is pre-multiplied
        // See https://github.com/tangrams/tangram/issues/179
        this.defines.TANGRAM_UNMULTIPLY_ALPHA = true;

        // default font style
        this.font_style = {
            typeface: "Helvetica 12px",
            fill: "white",
            capitalized: false
        };

        // default label style
        this.label_style = {
            lines: {
                exceed: 80,
                offset: 0
            },
            points: {
                max_width: 150,
                line_height: 100 // percentage
            }
        };

        this.reset();
    },

    reset: function reset() {
        this["super"].reset.call(this);
        this.texts = {}; // unique texts, keyed by tile
        this.textures = {};
        this.canvas = {};
        this.aabbs = {};
        this.features = {};
        this.feature_labels = {};
        this.feature_style_key = {};
    },

    // Called on main thread to release tile-specific resources
    freeTile: function freeTile(tile) {
        delete this.texts[tile];
        delete this.textures[tile];
        delete this.canvas[tile];
        delete this.aabbs[tile];
        delete this.features[tile];
        delete this.feature_labels[tile];
        delete this.feature_style_key[tile];
    },

    // Set font style params for canvas drawing
    setFont: function setFont(tile, _ref) {
        var font = _ref.font;
        var fill = _ref.fill;
        var stroke = _ref.stroke;
        var stroke_width = _ref.stroke_width;
        var px_size = _ref.px_size;
        var px_logical_size = _ref.px_logical_size;

        this.px_size = parseInt(px_size);
        this.px_logical_size = parseInt(px_logical_size);
        this.text_buffer = 6; // pixel padding around text
        var ctx = this.canvas[tile].context;

        ctx.font = font;
        if (stroke) {
            ctx.strokeStyle = stroke;
            ctx.lineWidth = stroke_width;
        } else {
            ctx.strokeStyle = null;
            ctx.lineWidth = 0;
        }
        ctx.fillStyle = fill;
        ctx.miterLimit = 2;
    },

    // Width and height of text based on current font style
    textSize: function textSize(text, tile, capitalized) {
        var str = capitalized ? text.toUpperCase() : text;
        var ctx = this.canvas[tile].context;
        var split = str.split(" ");
        var px_size = this.px_size;
        var px_logical_size = this.px_logical_size;
        var buffer = this.text_buffer * Utils.device_pixel_ratio;
        var split_size = {
            " ": this.canvas[tile].context.measureText(" ").width / Utils.device_pixel_ratio
        };

        for (var i in split) {
            var word = split[i];
            split_size[word] = ctx.measureText(word).width / Utils.device_pixel_ratio;
        }

        var str_width = ctx.measureText(str).width;
        var text_size = [str_width / Utils.device_pixel_ratio, this.px_size / Utils.device_pixel_ratio];

        var texture_text_size = [Math.ceil(str_width) + buffer * 2, this.px_size + buffer * 2];

        return { split_size: split_size, text_size: text_size, texture_text_size: texture_text_size, px_size: px_size, px_logical_size: px_logical_size };
    },

    // Draw text at specified location, adjusting for buffer and baseline
    drawText: function drawText(text, _ref, tile, stroke, capitalized) {
        var _ref2 = _slicedToArray(_ref, 2);

        var x = _ref2[0];
        var y = _ref2[1];

        var str = capitalized ? text.toUpperCase() : text;
        var buffer = this.text_buffer * Utils.device_pixel_ratio;
        if (stroke) {
            this.canvas[tile].context.strokeText(str, x + buffer, y + buffer + this.px_size);
        }
        this.canvas[tile].context.fillText(str, x + buffer, y + buffer + this.px_size);
    },

    setTextureTextPositions: function setTextureTextPositions(texts) {
        // Find widest label and sum of all label heights
        var widest = 0,
            height = 0;

        for (var style in texts) {
            var text_infos = texts[style];

            for (var text in text_infos) {
                var text_info = text_infos[text];
                var size = text_info.size.texture_text_size;

                text_info.position = [0, height];

                if (size[0] > widest) {
                    widest = size[0];
                }

                height += size[1];
            }
        }

        return [widest, height];
    },

    getTextSizes: function getTextSizes(tile, texts) {
        // create a canvas
        if (!this.canvas[tile]) {
            var canvas = document.createElement("canvas");
            this.canvas[tile] = {
                canvas: canvas,
                context: canvas.getContext("2d")
            };
        }

        for (var style in texts) {
            var text_infos = texts[style];

            for (var text in text_infos) {
                var text_style = text_infos[text].text_style;
                // update text sizes
                this.setFont(tile, text_style);
                text_infos[text].size = this.textSize(text, tile, text_style.capitalized);
            }
        }

        return Promise.resolve(texts);
    },

    rasterize: function rasterize(tile, texts, texture_size) {
        var pixel_scale = Utils.device_pixel_ratio;

        for (var style in texts) {
            var text_infos = texts[style];

            for (var text in text_infos) {
                var info = text_infos[text];

                this.setFont(tile, info.text_style);
                this.drawText(text, info.position, tile, info.text_style.stroke, info.text_style.capitalized);

                info.texcoords = Builders.getTexcoordsForSprite(info.position, info.size.texture_text_size, texture_size);

                if (!info.sub_texts) {
                    continue;
                }

                var width = this.text_buffer;
                var dists = [];
                var space_size = info.size.split_size[" "];

                for (var i = 0; i < info.sub_texts.length; ++i) {
                    var sub_text = info.sub_texts[i];
                    var split = sub_text.split(" ");

                    dists[i] = width * pixel_scale;

                    for (var j = 0; j < split.length; ++j) {
                        var word = split[j];
                        width += info.size.split_size[word];

                        if (j !== split.length - 1) {
                            width += space_size;
                        }
                    }

                    if (i !== info.sub_texts.length - 1) {
                        width += space_size / 2;
                    }
                }

                // sub-texts uv mapping
                for (var i = 0; i < info.sub_texts.length; ++i) {
                    var sub_text = info.sub_texts[i];

                    if (!info.subtexcoords) {
                        info.subtexcoords = {};
                    }

                    var offset = 0;

                    if (i < info.sub_texts.length - 1) {
                        offset = info.size.texture_text_size[0] - dists[i + 1];
                    }

                    var position = [info.position[0] + dists[i], info.position[1]];

                    var size = [info.size.texture_text_size[0] - offset - dists[i], info.size.texture_text_size[1]];

                    if (!info.subtext_size) {
                        info.subtext_size = {};
                    }
                    info.subtext_size[sub_text] = size;

                    info.subtexcoords[sub_text] = Builders.getTexcoordsForSprite(position, size, texture_size);
                }
            }
        }
    },

    // Called on main thread from worker, to create atlas of labels for a tile
    addTexts: function addTexts(tile, texts) {
        if (!this.canvas[tile]) {
            return Promise.resolve({});
        }

        var texture_size = this.setTextureTextPositions(texts);
        var context = this.canvas[tile].context;

        log.trace("text summary for tile " + tile + ": fits in " + texture_size[0] + "x" + texture_size[1] + "px");

        // update the canvas "context"
        this.canvas[tile].canvas.width = texture_size[0];
        this.canvas[tile].canvas.height = texture_size[1];
        context.clearRect(0, 0, texture_size[0], texture_size[1]);

        // create a texture
        var texture = "labels-" + tile + "-" + TextStyle.texture_id++;
        this.textures[tile] = new Texture(this.gl, texture, { filtering: "linear" });
        // this.textures[tile].owner = { tile };

        // ask for rasterization for the text set
        this.rasterize(tile, texts, texture_size);

        this.textures[tile].setCanvas(this.canvas[tile].canvas);

        // we don't need tile canvas/texture once it has been copied to to GPU
        delete this.textures[tile];
        delete this.canvas[tile];

        return Promise.resolve({ texts: texts, texture: texture });
    },

    // Override
    startData: function startData(tile) {
        var tile_data = this["super"].startData.apply(this, arguments);
        tile_data.queue = [];
        return tile_data;
    },

    subTextInfos: function subTextInfos(label_composite, text_info) {
        if (!text_info.sub_texts) {
            text_info.sub_texts = [];
        }

        for (var i in label_composite.labels) {
            var label = label_composite.labels[i];
            text_info.sub_texts.push(label.text);
        }
    },

    createLabels: function createLabels(tile, texts) {
        var labels_priorities = {};

        if (!this.features[tile]) {
            return;
        }

        for (var style in texts) {
            var text_infos = texts[style];

            if (!this.features[tile][style]) {
                return;
            }

            for (var text in text_infos) {
                var text_info = text_infos[text];
                text_info.ref = 0;

                if (!this.features[tile][style][text]) {
                    return;
                }

                for (var f = 0; f < this.features[tile][style][text].length; f++) {
                    var feature = this.features[tile][style][text][f];
                    var labels = LabelBuilder.labelsFromGeometry(feature.geometry, { text: text, size: text_info.size }, this.label_style);

                    for (var i = 0; i < labels.length; ++i) {
                        var label = labels[i];
                        var area = label.area;

                        labels_priorities[text_info.priority] = labels_priorities[text_info.priority] || [];
                        labels_priorities[text_info.priority].push({ style: style, feature: feature, label: label, area: area });

                        if (label.isComposite()) {
                            this.subTextInfos(label, text_info);
                        }
                    }
                }
            }
        }

        // sort by area size if defined
        for (var p = 0; p < labels_priorities.length; ++p) {
            if (!labels_priorities[p]) {
                continue;
            }

            labels_priorities[p].sort(function (e1, e2) {
                if (e1.area && e2.area) {
                    return e1.area < e2.area;
                } else {
                    return false;
                }
            });
        }

        return labels_priorities;
    },

    discardLabels: function discardLabels(tile, labels, texts) {
        this.aabbs[tile] = [];
        this.feature_labels[tile] = new Map();

        // Process labels by priority
        var priorities = Object.keys(labels).sort(function (a, b) {
            return a - b;
        });
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = priorities[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var priority = _step.value;

                if (!labels[priority]) {
                    continue;
                }

                for (var i = 0; i < labels[priority].length; i++) {
                    var _labels$priority$i = labels[priority][i];
                    var style = _labels$priority$i.style;
                    var feature = _labels$priority$i.feature;
                    var label = _labels$priority$i.label;

                    if (!label.discard(this.aabbs[tile])) {
                        if (!this.feature_labels[tile].has(feature)) {
                            this.feature_labels[tile].set(feature, []);
                        }
                        this.feature_labels[tile].get(feature).push(label);
                        texts[style][label.text].ref++;
                    }
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        for (var style in texts) {
            for (var text in texts[style]) {
                if (texts[style][text].ref < 1) {
                    delete texts[style][text];
                }
            }
        }

        for (var style in texts) {
            var text_infos = texts[style];
            // No labels for this style
            if (Object.keys(text_infos).length === 0) {
                delete texts[style];
            }
        }
    },

    // Override
    endData: function endData(tile) {
        var _this25 = this;

        var _arguments = arguments;

        // Count collected text
        var count = undefined;
        var tile_data = this.tile_data[tile];

        if (tile_data.queue.length > 0) {
            count = Object.keys(this.texts[tile] || {}).length;
            log.trace("# texts for tile " + tile + ": " + count);
        }
        if (!count) {
            return Promise.resolve();
        }

        // first call to main thread, ask for text pixel sizes
        return WorkerBroker.postMessage(this.main_thread_target, "getTextSizes", tile, this.texts[tile]).then(function (texts) {
            if (!texts) {
                _this25.freeTile(tile);
                return _this25["super"].endData.apply(_this25, _arguments);
            }

            var labels = _this25.createLabels(tile, texts);
            if (!labels) {
                _this25.freeTile(tile);
                return _this25["super"].endData.apply(_this25, _arguments);
            }

            _this25.discardLabels(tile, labels, texts);

            // No labels for this tile
            if (Object.keys(texts).length === 0) {
                _this25.freeTile(tile);
                WorkerBroker.postMessage(_this25.main_thread_target, "freeTile", tile);
                // early exit
                return;
            }

            // second call to main thread, for rasterizing the set of texts
            return WorkerBroker.postMessage(_this25.main_thread_target, "addTexts", tile, texts).then(function (_ref) {
                var texts = _ref.texts;
                var texture = _ref.texture;

                if (texts) {
                    _this25.texts[tile] = texts;

                    // Attach tile-specific label atlas to mesh as a texture uniform
                    tile_data.uniforms = { u_texture: texture };
                    tile_data.textures = [texture]; // assign texture ownership to tile - TODO: implement in VBOMesh

                    // Build queued features
                    tile_data.queue.forEach(function (q) {
                        return _this25["super"].addFeature.apply(_this25, q);
                    });
                    tile_data.queue = [];
                }

                _this25.freeTile(tile);
                return _this25["super"].endData.apply(_this25, _arguments);
            });
        });
    },

    // Override to queue features instead of processing immediately
    addFeature: function addFeature(feature, rule, context) {
        var tile = context.tile;
        if (tile.generation !== this.generation) {
            return;
        }

        // Collect text
        var text = undefined;
        var source = rule.text_source || "name";

        if (typeof source === "string") {
            text = feature.properties[source];
        } else if (typeof source === "function") {
            text = source(context);
        }

        if (text) {
            feature.text = text;

            if (!this.texts[tile.key]) {
                this.texts[tile.key] = {};
            }

            var style = this.constructFontStyle(rule, context);
            if (!style) {
                return;
            }

            var style_key = this.constructStyleKey(style);
            this.feature_style_key[tile.key] = this.feature_style_key[tile.key] || new Map();
            this.feature_style_key[tile.key].set(feature, style_key);

            if (!this.texts[tile.key][style_key]) {
                this.texts[tile.key][style_key] = {};
            }

            var priority = rule.priority !== undefined ? parseFloat(rule.priority) : -1 >>> 0;

            if (!this.texts[tile.key][style_key][text]) {
                this.texts[tile.key][style_key][text] = {
                    text_style: style,
                    priority: priority,
                    ref: 0
                };
            }

            this.features = this.features || {};
            this.features[tile.key] = this.features[tile.key] || {};
            this.features[tile.key][style_key] = this.features[tile.key][style_key] || {};
            this.features[tile.key][style_key][text] = this.features[tile.key][style_key][text] || [];
            this.features[tile.key][style_key][text].push(feature);

            if (!this.tile_data[tile.key]) {
                this.startData(tile.key);
            }
            this.tile_data[tile.key].queue.push([feature, rule, context]);
        }
    },

    constructFontStyle: function constructFontStyle(rule, context) {
        var style = undefined;

        if (rule.font) {
            style = {};

            // Use fill if specified, or default
            style.fill = rule.font.fill && Utils.toCanvasColor(StyleParser.parseColor(rule.font.fill, context)) || this.font_style.fill;

            // Use stroke if specified
            if (rule.font.stroke && rule.font.stroke.color) {
                style.stroke = Utils.toCanvasColor(StyleParser.parseColor(rule.font.stroke.color));
                style.stroke_width = rule.font.stroke.width || this.font_style.stroke.width;
            }

            // Use default typeface
            style.font = rule.font.typeface || this.font_style.typeface;
            style.capitalized = rule.font.capitalized || this.font_style.capitalized;

            var size_regex = /([0-9]*\.)?[0-9]+(px|pt|em|%)/g;
            var ft_size = style.font.match(size_regex)[0];
            var size_kind = ft_size.replace(/([0-9]*\.)?[0-9]+/g, "");

            style.px_logical_size = Utils.toPixelSize(ft_size.replace(/([a-z]|%)/g, ""), size_kind);
            style.px_size = style.px_logical_size * Utils.device_pixel_ratio;
            style.stroke_width *= Utils.device_pixel_ratio;
            style.font = style.font.replace(size_regex, style.px_size + "px");
        }

        return style;
    },

    constructStyleKey: function constructStyleKey(_ref) {
        var font = _ref.font;
        var fill = _ref.fill;
        var stroke = _ref.stroke;
        var stroke_width = _ref.stroke_width;

        return "" + font + "/" + fill + "/" + stroke + "/" + stroke_width;
    },

    buildLabel: function buildLabel(label, size, vertex_data, vertex_template, texcoord_scale) {
        var angle = label.angle || 0;
        Builders.buildQuadsForPoints([label.position], Utils.scaleInt16(size[0], 256), Utils.scaleInt16(size[1], 256), Utils.scaleInt16(Utils.radToDeg(angle), 360), Utils.scaleInt16(1, 256), vertex_data, vertex_template, this.vertex_layout.index.a_shape, {
            texcoord_index: this.vertex_layout.index.a_texcoord,
            texcoord_scale: texcoord_scale,
            texcoord_normalize: 65535
        });
    },

    build: function build(style, vertex_data) {
        var vertex_template = this.makeVertexTemplate(style);

        for (var i in style.labels) {
            var label = style.labels[i];

            if (label.isComposite()) {
                for (var j in label.labels) {
                    var l = label.labels[j];
                    var subtexcoord_scale = this.subtexcoord_scale[l.text];
                    var size = this.subtext_size[l.text];
                    this.buildLabel(l, size, vertex_data, vertex_template, subtexcoord_scale);
                }
            } else {
                this.buildLabel(label, label.size.texture_text_size, vertex_data, vertex_template, this.texcoord_scale);
            }
        }
    },

    buildLines: function buildLines(lines, style, vertex_data) {
        this.build(style, vertex_data);
    },

    buildPoints: function buildPoints(points, style, vertex_data) {
        this.build(style, vertex_data);
    },

    buildPolygons: function buildPolygons(points, style, vertex_data) {
        this.build(style, vertex_data);
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        var text = feature.text;

        var style = this.feature_style;
        var tile = context.tile.key;
        var style_key = this.feature_style_key[tile].get(feature);
        var text_info = this.texts[tile] && this.texts[tile][style_key] && this.texts[tile][style_key][text];

        if (!text_info || !this.feature_labels[tile].has(feature)) {
            return;
        }

        this.texcoord_scale = text_info.texcoords;
        this.subtexcoord_scale = text_info.subtexcoords;
        this.subtext_size = text_info.subtext_size;
        style.text = text;
        style.labels = this.feature_labels[tile].get(feature);

        // TODO: point style (parent class) requires a color, setting it to white for now,
        // but could be made conditional in the vertex layout to save space
        style.color = TextStyle.white;

        // tell the point style (base class) that we want to render polygon labels at the polygon's centroid
        style.centroid = true;

        // points can be placed off the ground
        style.z = rule_style.z && StyleParser.cacheDistance(rule_style.z, context) || StyleParser.defaults.z;

        return style;
    }

});

TextStyle.texture_id = 0;
TextStyle.white = [1, 1, 1, 1];

},{"../../gl/texture":81,"../../utils/utils":115,"../../utils/worker_broker":117,"../builders":97,"../points/points":99,"../style_parser":104,"./label_builder":106,"loglevel":60}],110:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Tile */

var Geo = _interopRequire(require("./geo"));

var StyleParser = require("./styles/style_parser").StyleParser;

var StyleManager = require("./styles/style_manager").StyleManager;

var WorkerBroker = _interopRequire(require("./utils/worker_broker"));

var Texture = _interopRequire(require("./gl/texture"));

var log = _interopRequire(require("loglevel"));

var Tile = (function () {

    /**
        Tile
        @constructor
        Required properties:
        coords: object with {x, y, z} properties identifying tile coordinate location
        worker: web worker to handle tile construction
    */

    function Tile(_ref) {
        var coords = _ref.coords;
        var source = _ref.source;
        var worker = _ref.worker;
        var style_zoom = _ref.style_zoom;

        _classCallCheck(this, Tile);

        Object.assign(this, {
            coords: {
                x: null,
                y: null,
                z: null
            },
            debug: {},
            loading: false,
            loaded: false,
            error: null,
            worker: null,
            generation: null,
            visible: false,
            center_dist: 0
        });

        this.worker = worker;
        this.source = source;
        this.style_zoom = style_zoom; // zoom level to be used for styling

        this.coords = coords;
        this.coords = Tile.overZoomedCoordinate(this.coords, this.source.max_zoom);
        this.coord_key = Tile.coordKey(this.coords);
        this.key = Tile.key(this.coords, this.source, this.style_zoom);
        this.min = Geo.metersForTile(this.coords);
        this.max = Geo.metersForTile({ x: this.coords.x + 1, y: this.coords.y + 1, z: this.coords.z }), this.span = { x: this.max.x - this.min.x, y: this.max.y - this.min.y };
        this.bounds = { sw: { x: this.min.x, y: this.max.y }, ne: { x: this.max.x, y: this.min.y } };

        this.meshes = {}; // renderable VBO meshes keyed by style
        this.textures = []; // textures that the tile owns (labels, etc.)
    }

    _createClass(Tile, {
        freeResources: {
            value: function freeResources() {
                if (this.meshes) {
                    for (var m in this.meshes) {
                        this.meshes[m].destroy();
                    }
                }

                if (this.textures) {
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = this.textures[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var t = _step.value;

                            var texture = Texture.textures[t];
                            if (texture) {
                                texture.destroy();
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator["return"]) {
                                _iterator["return"]();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }

                this.meshes = {};
                this.textures = [];
            }
        },
        destroy: {
            value: function destroy() {
                this.workerMessage("removeTile", this.key);
                this.freeResources();
                this.worker = null;
            }
        },
        buildAsMessage: {
            value: function buildAsMessage() {
                return {
                    key: this.key,
                    coord_key: this.coord_key,
                    source: this.source.name,
                    coords: this.coords,
                    min: this.min,
                    max: this.max,
                    style_zoom: this.style_zoom,
                    generation: this.generation,
                    debug: this.debug
                };
            }
        },
        workerMessage: {
            value: function workerMessage() {
                for (var _len = arguments.length, message = Array(_len), _key = 0; _key < _len; _key++) {
                    message[_key] = arguments[_key];
                }

                return WorkerBroker.postMessage.apply(WorkerBroker, [this.worker].concat(message));
            }
        },
        build: {
            value: function build(generation) {
                this.generation = generation;
                if (!this.loaded) {
                    this.loading = true;
                }
                return this.workerMessage("buildTile", { tile: this.buildAsMessage() })["catch"](function (e) {
                    throw e;
                });
            }
        },
        buildMeshes: {

            /**
               Called on main thread when a web worker completes processing
               for a single tile.
            */

            value: function buildMeshes(styles) {
                if (this.error) {
                    return;
                }

                // Cleanup existing VBOs
                this.freeResources();

                // Debug
                this.debug.geometries = 0;
                this.debug.buffer_size = 0;

                // Create VBOs
                var mesh_data = this.mesh_data;
                if (mesh_data) {
                    for (var s in mesh_data) {
                        if (mesh_data[s].vertex_data) {
                            this.debug.buffer_size += mesh_data[s].vertex_data.byteLength;
                            if (!styles[s]) {
                                log.warn("Could not create mesh because style '" + s + "' not found, for tile " + this.key + ", aborting tile");
                                this.meshes = {};
                                break;
                            }
                            this.meshes[s] = styles[s].makeMesh(mesh_data[s].vertex_data, mesh_data[s]);
                            this.debug.geometries += this.meshes[s].geometry_count;
                        }

                        // Assign ownership to textures if needed
                        if (mesh_data[s].textures) {
                            var _textures;

                            (_textures = this.textures).push.apply(_textures, _toConsumableArray(mesh_data[s].textures));
                        }
                    }
                }

                this.debug.geom_ratio = (this.debug.geometries / this.debug.features).toFixed(1);
                this.mesh_data = null; // TODO: might want to preserve this for rebuilding geometries when styles/etc. change?
                this.printDebug();
            }
        },
        printDebug: {
            value: function printDebug() {
                log.debug("Tile: debug for " + this.key + ": [  " + JSON.stringify(this.debug) + " ]");
            }
        },
        update: {
            value: function update(scene) {
                var coords = this.coords;
                if (coords.z !== scene.center_tile.z) {
                    coords = Tile.coordinateAtZoom(coords, scene.center_tile.z);
                }
                this.center_dist = Math.abs(scene.center_tile.x - coords.x) + Math.abs(scene.center_tile.y - coords.y);
            }
        },
        merge: {
            value: function merge(other) {
                for (var key in other) {
                    if (key !== "key") {
                        this[key] = other[key];
                    }
                }
                return this;
            }
        }
    }, {
        create: {
            value: function create(spec) {
                return new Tile(spec);
            }
        },
        coordKey: {
            value: function coordKey(_ref) {
                var x = _ref.x;
                var y = _ref.y;
                var z = _ref.z;

                return [x, y, z].join("/");
            }
        },
        key: {
            value: function key(coords, source, style_zoom) {
                coords = Tile.overZoomedCoordinate(coords, source.max_zoom);
                return [source.name, style_zoom, coords.x, coords.y, coords.z].join("/");
            }
        },
        coordinateAtZoom: {
            value: function coordinateAtZoom(_ref, zoom) {
                var x = _ref.x;
                var y = _ref.y;
                var z = _ref.z;

                if (z !== zoom) {
                    var zscale = Math.pow(2, z - zoom);
                    x = Math.floor(x / zscale);
                    y = Math.floor(y / zscale);
                }
                return { x: x, y: y, z: zoom };
            }
        },
        isChild: {
            value: function isChild(parent, child) {
                if (child.z > parent.z) {
                    var _Tile$coordinateAtZoom = Tile.coordinateAtZoom(child, parent.z);

                    var x = _Tile$coordinateAtZoom.x;
                    var y = _Tile$coordinateAtZoom.y;

                    return parent.x === x && parent.y === y;
                }
                return false;
            }
        },
        overZoomedCoordinate: {
            value: function overZoomedCoordinate(_ref, max_zoom) {
                var x = _ref.x;
                var y = _ref.y;
                var z = _ref.z;

                if (max_zoom !== undefined && z > max_zoom) {
                    return Tile.coordinateAtZoom({ x: x, y: y, z: z }, max_zoom);
                }
                return { x: x, y: y, z: z };
            }
        },
        sort: {

            // Sort a set of tile instances (which already have a distance from center tile computed)

            value: function sort(tiles) {
                return tiles.sort(function (a, b) {
                    var ad = a.center_dist;
                    var bd = b.center_dist;
                    return bd > ad ? -1 : bd === ad ? 0 : 1;
                });
            }
        },
        buildGeometry: {

            // Process geometry for tile - called by web worker
            // Returns a set of tile keys that should be sent to the main thread (so that we can minimize data exchange between worker and main thread)

            value: function buildGeometry(tile, layers, rules, styles) {
                tile.debug.rendering = +new Date();
                tile.debug.features = 0;

                var data = tile.source_data;

                // Treat top-level style rules as 'layers'
                for (var layer_name in layers) {
                    var layer = layers[layer_name];
                    // Skip layers with no data source defined
                    if (!layer.data) {
                        log.warn("Layer " + layer + " was defined without a geometry data source and will not be rendered.");
                        continue;
                    }

                    // Source names don't match
                    if (layer.data.source !== tile.source) {
                        continue;
                    }

                    var geom = Tile.getDataForSource(data, layer.data, layer_name);
                    if (!geom) {
                        continue;
                    }

                    // Render features in layer
                    var num_features = geom.features.length;
                    for (var f = num_features - 1; f >= 0; f--) {
                        var feature = geom.features[f];
                        var context = StyleParser.getFeatureParseContext(feature, tile);

                        // Get draw groups for this feature
                        var layer_rules = rules[layer_name];
                        var draw_groups = layer_rules.buildDrawGroups(context, true);
                        if (!draw_groups) {
                            continue;
                        }

                        // Render draw groups
                        for (var group_name in draw_groups) {
                            var group = draw_groups[group_name];
                            if (!group.visible) {
                                continue;
                            }

                            // Add to style
                            var style_name = group.style || group_name;
                            var style = styles[style_name];

                            if (!style) {
                                log.warn("Style '" + style_name + "' not found for rule in layer '" + layer_name + "':", group, feature);
                                continue;
                            }

                            context.properties = group.properties; // add rule-specific properties to context

                            style.addFeature(feature, group, context);

                            context.properties = null; // clear group-specific properties
                        }

                        tile.debug.features++;
                    }
                }
                tile.debug.rendering = +new Date() - tile.debug.rendering;

                // Finalize array buffer for each render style
                var tile_styles = StyleManager.stylesForTile(tile.key);
                tile.mesh_data = {};
                var queue = [];
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = tile_styles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        (function () {
                            var style_name = _step.value;

                            var style = styles[style_name];
                            queue.push(style.endData(tile.key).then(function (style_data) {
                                if (style_data) {
                                    tile.mesh_data[style_name] = {
                                        vertex_data: style_data.vertex_data,
                                        uniforms: style_data.uniforms,
                                        textures: style_data.textures
                                    };
                                }
                            }));
                        })();
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return Promise.all(queue).then(function () {
                    // Return keys to be transfered to main thread
                    return ["mesh_data"];
                });
            }
        },
        getDataForSource: {

            /**
                Retrieves geometry from a tile according to a data source definition
            */

            value: function getDataForSource(source_data, source_config) {
                var default_layer = arguments[2] === undefined ? null : arguments[2];

                var geom;

                if (source_config != null) {
                    // If no layer specified, and a default source layer exists
                    if (!source_config.layer && source_data.layers._default) {
                        geom = source_data.layers._default;
                    }
                    // If no layer specified, and a default requested layer exists
                    else if (!source_config.layer && default_layer) {
                        geom = source_data.layers[default_layer];
                    }
                    // If a layer is specified by name, use it
                    else if (typeof source_config.layer === "string") {
                        geom = source_data.layers[source_config.layer];
                    }
                    // If multiple layers are specified by name, combine them
                    else if (Array.isArray(source_config.layer)) {
                        geom = { type: "FeatureCollection", features: [] };
                        source_config.layer.forEach(function (layer) {
                            if (source_data.layers[layer] && source_data.layers[layer].features) {
                                var _geom$features;

                                (_geom$features = geom.features).push.apply(_geom$features, _toConsumableArray(source_data.layers[layer].features));
                            }
                        });
                    }
                    // Assemble a custom layer via a function, which is called with all source layers
                    else if (typeof source_config.layer === "function") {
                        geom = source_config.layer(source_data.layers);
                    }
                }

                return geom;
            }
        },
        abortBuild: {

            /**
                Called on main thread when web worker completes processing, but tile has since been discarded
                Frees resources that would have been transferred to the tile object.
                Static method because the tile object no longer exists (the tile data returned by the worker is passed instead).
            */

            value: function abortBuild(tile) {
                if (tile.mesh_data) {
                    for (var s in tile.mesh_data) {
                        var textures = tile.mesh_data[s].textures;
                        if (textures) {
                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = undefined;

                            try {
                                for (var _iterator = textures[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                    var t = _step.value;

                                    var texture = Texture.textures[t];
                                    if (texture) {
                                        log.trace("destroying texture " + t + " for tile " + tile.key);
                                        texture.destroy();
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                                        _iterator["return"]();
                                    }
                                } finally {
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        slice: {

            // Slice a subset of keys out of a tile
            // Includes a minimum set of pre-defined keys for load state, debug. etc.
            // We use this to send a subset of the tile back to the main thread, to minimize unnecessary data transfer
            // (e.g. very large items like feature geometry are not needed on the main thread)

            value: function slice(tile, keys) {
                var keep = ["key", "loading", "loaded", "generation", "error", "debug"];
                if (Array.isArray(keys)) {
                    keep.push.apply(keep, _toConsumableArray(keys));
                }

                // Build the tile subset
                var tile_subset = {};
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = keep[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var key = _step.value;

                        tile_subset[key] = tile[key];
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return tile_subset;
            }
        },
        cancel: {

            /**
                Called on worker to cancel loading
                Static method because the worker only has object representations of tile data, there is no
                tile instance created yet.
            */

            value: function cancel(tile) {
                if (tile) {
                    if (tile.source_data && tile.source_data.request) {
                        tile.source_data.request.abort();
                    }
                    Tile.abortBuild(tile);
                }
            }
        }
    });

    return Tile;
})();

module.exports = Tile;

},{"./geo":73,"./gl/texture":81,"./styles/style_manager":103,"./styles/style_parser":104,"./utils/worker_broker":117,"loglevel":60}],111:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var Tile = _interopRequire(require("./tile"));

var Utils = _interopRequire(require("./utils/utils"));

var log = _interopRequire(require("loglevel"));

var TileManager;

module.exports = TileManager = {

    init: function init(scene) {
        this.scene = scene;
        this.tiles = {};
        this.visible_coords = {};
        this.queued_coords = [];
        this.building_tiles = null;
    },

    destroy: function destroy() {
        this.forEachTile(function (tile) {
            return tile.destroy();
        });
        this.tiles = {};
        this.visible_coords = {};
        this.queued_coords = [];
        this.scene = null;
    },

    keepTile: function keepTile(tile) {
        this.tiles[tile.key] = tile;
    },

    hasTile: function hasTile(key) {
        return this.tiles[key] !== undefined;
    },

    forgetTile: function forgetTile(key) {
        delete this.tiles[key];
        this.tileBuildStop(key);
    },

    // Remove a single tile
    removeTile: function removeTile(key) {
        log.trace("tile unload for " + key);

        var tile = this.tiles[key];

        if (tile != null) {
            tile.destroy();
        }

        this.forgetTile(tile.key);
        this.scene.requestRedraw();
    },

    // Run a function on each tile
    forEachTile: function forEachTile(func) {
        for (var t in this.tiles) {
            func(this.tiles[t]);
        }
    },

    // Remove tiles that pass a filter condition
    removeTiles: function removeTiles(filter) {
        var remove_tiles = [];
        for (var t in this.tiles) {
            var tile = this.tiles[t];
            if (filter(tile)) {
                remove_tiles.push(t);
            }
        }
        for (var r = 0; r < remove_tiles.length; r++) {
            var key = remove_tiles[r];
            this.removeTile(key);
        }
    },

    updateTilesForView: function updateTilesForView() {
        var _this = this;

        // Find visible tiles and load new ones
        this.visible_coords = {};
        var tile_coords = this.scene.findVisibleTileCoordinates();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = tile_coords[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var coords = _step.value;

                this.queueCoordinate(coords);
                this.visible_coords[Tile.coordKey(coords)] = coords;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        // Remove tiles too far outside of view
        this.scene.pruneTileCoordinatesForView(); // TODO: return list to prune?

        this.forEachTile(function (tile) {
            _this.updateVisibility(tile);
            tile.update(_this.scene);
        });
    },

    updateVisibility: function updateVisibility(tile) {
        if (tile.style_zoom !== this.scene.tile_zoom) {
            tile.visible = false;
            return;
        }

        if (this.visible_coords[tile.coord_key]) {
            tile.visible = true;
        } else {
            // brute force
            for (var key in this.visible_coords) {
                if (Tile.isChild(tile.coords, this.visible_coords[key])) {
                    tile.visible = true;
                    return;
                }
            }

            tile.visible = false;
        }
    },

    getRenderableTiles: function getRenderableTiles() {
        var tiles = [];
        for (var t in this.tiles) {
            var tile = this.tiles[t];
            if (tile.visible && tile.loaded) {
                tiles.push(tile);
            }
        }
        return tiles;
    },

    // Queue a tile for load
    queueCoordinate: function queueCoordinate(coords) {
        this.queued_coords[this.queued_coords.length] = coords;
    },

    // Load all queued tiles
    loadQueuedCoordinates: function loadQueuedCoordinates() {
        var _this = this;

        if (this.queued_coords.length === 0) {
            return;
        }

        // Sort queued tiles from center tile
        this.queued_coords.sort(function (a, b) {
            var ad = Math.abs(_this.scene.center_tile.x - a.x) + Math.abs(_this.scene.center_tile.y - a.y);
            var bd = Math.abs(_this.scene.center_tile.x - b.x) + Math.abs(_this.scene.center_tile.y - b.y);
            return bd > ad ? -1 : bd === ad ? 0 : 1;
        });
        this.queued_coords.forEach(function (coords) {
            return _this.loadCoordinate(coords);
        });
        this.queued_coords = [];
    },

    // Load all tiles to cover a given logical tile coordinate
    loadCoordinate: function loadCoordinate(coords) {
        // Skip if not at current scene zoom
        if (coords.z !== this.scene.center_tile.z) {
            return;
        }

        // Determine necessary tiles for each source
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = Utils.values(this.scene.sources)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var source = _step.value;

                if (!source.tiled) {
                    continue;
                }

                var key = Tile.key(coords, source, this.scene.tile_zoom);
                if (!this.hasTile(key)) {
                    var tile = Tile.create({
                        source: source,
                        coords: coords,
                        // max_zoom: this.scene.findMaxZoom(), // TODO: replace with better max zoom handling
                        worker: this.scene.nextWorker(),
                        style_zoom: this.scene.styleZoom(coords.z) // TODO: replace?
                    });

                    this.keepTile(tile);
                    this.buildTile(tile);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    },

    // Sort and build a list of tiles
    buildTiles: function buildTiles(tiles) {
        var _this = this;

        Tile.sort(tiles).forEach(function (tile) {
            return _this.buildTile(tile);
        });
        this.checkBuildQueue();
    },

    buildTile: function buildTile(tile) {
        var _this = this;

        this.tileBuildStart(tile.key);
        this.updateVisibility(tile);
        tile.update(this.scene);
        tile.build(this.scene.generation).then(function (message) {
            return _this.buildTileCompleted(message);
        })["catch"](function () {
            _this.forgetTile(tile.key);
            Tile.abortBuild(tile);
        });
    },

    // Called on main thread when a web worker completes processing for a single tile (initial load, or rebuild)
    buildTileCompleted: function buildTileCompleted(_ref) {
        var tile = _ref.tile;

        // Removed this tile during load?
        if (this.tiles[tile.key] == null) {
            log.trace("discarded tile " + tile.key + " in TileManager.buildTileCompleted because previously removed");
            Tile.abortBuild(tile);
        }
        // Built with an outdated scene configuration?
        else if (tile.generation !== this.scene.generation) {
            log.debug("discarded tile " + tile.key + " in TileManager.buildTileCompleted because built with " + ("scene config gen " + tile.generation + ", current " + this.scene.generation));
            this.forgetTile(tile.key);
            Tile.abortBuild(tile);
        } else {
            // Update tile with properties from worker
            if (this.tiles[tile.key]) {
                tile = this.tiles[tile.key].merge(tile);
            }

            this.updateVisibility(tile);
            tile.update(this.scene);
            tile.buildMeshes(this.scene.styles);
            this.scene.requestRedraw();
        }

        this.tileBuildStop(tile.key);
    },

    // Track tile build state
    tileBuildStart: function tileBuildStart(key) {
        this.building_tiles = this.building_tiles || {};
        this.building_tiles[key] = true;
        log.trace("tileBuildStart for " + key + ": " + Object.keys(this.building_tiles).length);
    },

    tileBuildStop: function tileBuildStop(key) {
        // Done building?
        if (this.building_tiles) {
            log.trace("tileBuildStop for " + key + ": " + Object.keys(this.building_tiles).length);
            delete this.building_tiles[key];
            this.checkBuildQueue();
        }
    },

    // Check status of tile building queue and notify scene when we're done
    checkBuildQueue: function checkBuildQueue() {
        if (!this.building_tiles || Object.keys(this.building_tiles).length === 0) {
            this.building_tiles = null;
            this.scene.tileManagerBuildDone();
        }
    },

    // Sum of a debug property across tiles
    getDebugSum: function getDebugSum(prop, filter) {
        var sum = 0;
        for (var t in this.tiles) {
            if (this.tiles[t].debug[prop] != null && (typeof filter !== "function" || filter(this.tiles[t]) === true)) {
                sum += this.tiles[t].debug[prop];
            }
        }
        return sum;
    },

    // Average of a debug property across tiles
    getDebugAverage: function getDebugAverage(prop, filter) {
        return this.getDebugSum(prop, filter) / Object.keys(this.tiles).length;
    }

};

},{"./tile":110,"./utils/utils":115,"loglevel":60}],112:[function(require,module,exports){
"use strict";

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

Object.defineProperty(exports, "__esModule", {
    value: true
});

var MethodNotImplemented = exports.MethodNotImplemented = (function (_Error) {
    function MethodNotImplemented(methodName) {
        _classCallCheck(this, MethodNotImplemented);

        _get(Object.getPrototypeOf(MethodNotImplemented.prototype), "constructor", this).call(this);
        this.name = "MethodNotImplemented";
        this.message = "Method " + methodName + " must be implemented in subclass";
    }

    _inherits(MethodNotImplemented, _Error);

    return MethodNotImplemented;
})(Error);

},{}],113:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var Vector = _interopRequire(require("../vector"));

var OBB = (function () {
    function OBB(x, y, a, w, h) {
        _classCallCheck(this, OBB);

        this.dimension = [w, h];
        this.angle = a;
        this.centroid = [x, y];
        this.quad = [];
        this.axes = [];

        this.update();
    }

    _createClass(OBB, {
        move: {
            value: function move(px, py) {
                this.centroid = [px, py];

                this.update();
            }
        },
        getExtent: {
            value: function getExtent() {
                var inf = 1000000;
                var aabb = [inf, inf, -inf, -inf];

                for (var i = 0; i < 4; ++i) {
                    aabb[0] = Math.min(this.quad[i][0], aabb[0]);
                    aabb[1] = Math.min(this.quad[i][1], aabb[1]);
                    aabb[2] = Math.max(this.quad[i][0], aabb[2]);
                    aabb[3] = Math.max(this.quad[i][1], aabb[3]);
                }

                return aabb;
            }
        },
        perpAxes: {
            value: function perpAxes() {
                this.axes[0] = Vector.normalize(Vector.sub(this.quad[2], this.quad[3]));
                this.axes[1] = Vector.normalize(Vector.sub(this.quad[2], this.quad[1]));
            }
        },
        update: {
            value: function update() {
                var x = [Math.cos(this.angle), Math.sin(this.angle)];
                var y = [-Math.sin(this.angle), Math.cos(this.angle)];

                x = Vector.mult(x, this.dimension[0] / 2);
                y = Vector.mult(y, this.dimension[1] / 2);

                this.quad[0] = Vector.sub(Vector.sub(this.centroid, x), y); // lower-left
                this.quad[1] = Vector.sub(Vector.add(this.centroid, x), y); // lower-right
                this.quad[2] = Vector.add(Vector.add(this.centroid, x), y); // uper-right
                this.quad[3] = Vector.add(Vector.sub(this.centroid, x), y); // uper-left

                this.perpAxes();
            }
        }
    }, {
        projectToAxis: {
            value: function projectToAxis(obb, axis) {
                var inf = 1000000;
                var min = inf;
                var max = -inf;

                var quad = obb.quad;

                // for each axis, project obb quad to it and find min and max values
                for (var i = 0; i < 4; ++i) {
                    var d = Vector.dot(quad[i], axis);
                    min = Math.min(min, d);
                    max = Math.max(max, d);
                }

                return [min, max];
            }
        },
        axisCollide: {
            value: function axisCollide(obb_a, obb_b, axes) {
                for (var i = 0; i < 2; ++i) {
                    var a_proj = OBB.projectToAxis(obb_a, axes[i]);
                    var b_proj = OBB.projectToAxis(obb_b, axes[i]);

                    if (b_proj[0] > a_proj[1] || b_proj[1] < a_proj[0]) {
                        return false;
                    }
                }
                return true;
            }
        },
        intersect: {
            value: function intersect(obb_a, obb_b) {
                return OBB.axisCollide(obb_a, obb_b, obb_a.axes) && OBB.axisCollide(obb_a, obb_b, obb_b.axes);
            }
        }
    });

    return OBB;
})();

module.exports = OBB;

},{"../vector":118}],114:[function(require,module,exports){
"use strict";

module.exports = subscribeMixin;

function subscribeMixin(target) {

    var listeners = new Set();
    // var listeners = [];

    return Object.assign(target, {

        subscribe: function subscribe(listener) {
            listeners.add(listener);
            // listeners.push(listener);
        },

        unsubscribe: function unsubscribe(listener) {
            listeners["delete"](listener);
            // var index = listeners.indexOf(listener);
            // if (index > -1) {
            //     listeners.splice(index, 1);
            // }
        },

        unsubscribeAll: function unsubscribeAll() {
            listeners.clear();
            // listeners = [];
        },

        trigger: function trigger(event) {
            for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                data[_key - 1] = arguments[_key];
            }

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = listeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var listener = _step.value;

                    if (typeof listener[event] === "function") {
                        listener[event].apply(listener, data);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                        _iterator["return"]();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }

    });
}

},{}],115:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

// Miscellaneous utilities
/*jshint worker: true*/

var log = _interopRequire(require("loglevel"));

var yaml = _interopRequire(require("js-yaml"));

var Geo = _interopRequire(require("../geo"));

var Utils;
module.exports = Utils = {};

// Add a base URL for schemeless or protocol-less URLs
// Defaults to adding current window protocol and base, or adds a custom base if specified
// Maybe use https://github.com/medialize/URI.js if more robust functionality is needed
Utils.addBaseURL = function (url, base) {
    if (!url) {
        return;
    }

    // Schemeless, add protocol
    if (url.substr(0, 2) === "//") {
        url = window.location.protocol + url;
    }
    // No http(s) or data, add base
    else if (url.search(/^(http|https|data|blob):/) < 0) {
        var relative = url[0] !== "/";
        var base_info;
        if (base) {
            base_info = document.createElement("a"); // use a temporary element to parse URL
            base_info.href = base;
        } else {
            base_info = window.location;
        }

        if (relative) {
            var path = base_info.href.match(/([^\#]+)/); // strip hash
            path = path && path.length > 1 ? path[0] : "";
            url = path + url;
        } else {
            // Easy way
            if (base_info.origin) {
                url = base_info.origin + "/" + url;
            }
            // Hard way (IE11)
            else {
                var origin = url.match(/^((http|https|data|blob):\/\/[^\/]*\/)/);
                origin = origin && origin.length > 1 ? origin[0] : "";
                url = origin + url;
            }
        }
    }
    return url;
};

Utils.pathForURL = function (url) {
    if (url.search(/^(data|blob):/) === -1) {
        return url.substr(0, url.lastIndexOf("/") + 1);
    }
    return "";
};

Utils.cacheBusterForUrl = function (url) {
    if (url.search(/^(data|blob):/) > -1) {
        return url; // no cache-busting on object or data URLs
    }
    return url + "?" + +new Date();
};

// Polyfill (for Safari compatibility)
Utils._createObjectURL = undefined;
Utils.createObjectURL = function (url) {
    if (Utils._createObjectURL === undefined) {
        Utils._createObjectURL = window.URL && window.URL.createObjectURL || window.webkitURL && window.webkitURL.createObjectURL;

        if (typeof Utils._createObjectURL !== "function") {
            Utils._createObjectURL = null;
            log.warn("window.URL.createObjectURL (or vendor prefix) not found, unable to create local blob URLs");
        }
    }

    if (Utils._createObjectURL) {
        return Utils._createObjectURL(url);
    } else {
        return url;
    }
};

Utils.io = function (url) {
    var timeout = arguments[1] === undefined ? 60000 : arguments[1];
    var responseType = arguments[2] === undefined ? "text" : arguments[2];
    var method = arguments[3] === undefined ? "GET" : arguments[3];
    var headers = arguments[4] === undefined ? {} : arguments[4];

    var request = new XMLHttpRequest();
    var promise = new Promise(function (resolve, reject) {
        request.open(method, url, true);
        request.timeout = timeout;
        request.responseType = responseType;
        request.onload = function () {
            if (request.status === 200) {
                if (["text", "json"].indexOf(request.responseType) > -1) {
                    resolve(request.responseText);
                } else {
                    resolve(request.response);
                }
            } else {
                reject(Error("Request error with a status of " + request.statusText));
            }
        };
        request.onerror = function (evt) {
            reject(Error("There was a network error" + evt.toString()));
        };
        request.ontimeout = function (evt) {
            reject(Error("timeout " + evt.toString()));
        };
        request.send();
    });

    Object.defineProperty(promise, "request", {
        value: request
    });

    return promise;
};

Utils.parseResource = function (body) {
    var data;
    try {
        data = yaml.safeLoad(body);
    } catch (e) {
        throw e;
    }
    return data;
};

Utils.loadResource = function (source) {
    return new Promise(function (resolve, reject) {
        if (typeof source === "string") {
            Utils.io(Utils.cacheBusterForUrl(source)).then(function (body) {
                try {
                    var data = Utils.parseResource(body);
                    resolve(data);
                } catch (e) {
                    reject(e);
                }
            }, reject);
        } else {
            resolve(source);
        }
    });
};

// Needed for older browsers that still support WebGL (Safari 6 etc.)
Utils.requestAnimationFramePolyfill = function () {
    if (typeof window.requestAnimationFrame !== "function") {
        window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (cb) {
            setTimeout(cb, 1000 / 60);
        };
    }
};

// Stringify an object into JSON, but convert functions to strings
Utils.serializeWithFunctions = function (obj) {
    var serialized = JSON.stringify(obj, function (k, v) {
        // Convert functions to strings
        if (typeof v === "function") {
            return v.toString();
        }
        return v;
    });

    return serialized;
};

// Parse a JSON string, but convert function-like strings back into functions
Utils.deserializeWithFunctions = function (serialized, wrap) {
    var obj = JSON.parse(serialized);
    obj = Utils.stringsToFunctions(obj, wrap);
    return obj;
};

// Recursively parse an object, attempting to convert string properties that look like functions back into functions
Utils.stringsToFunctions = function (obj, wrap) {
    // Convert string
    if (typeof obj === "string") {
        obj = Utils.stringToFunction(obj, wrap);
    }
    // Loop through object properties
    else if (typeof obj === "object") {
        for (var p in obj) {
            obj[p] = Utils.stringsToFunctions(obj[p], wrap);
        }
    }
    return obj;
};

// Convert string back into a function
// TODO: make function matching tolerant of whitespace and multilines
Utils.stringToFunction = function (val, wrap) {
    // Convert strings back into functions
    if (val.match(/^\s*function\s*\w*\s*\([\s\S]*\)\s*\{[\s\S]*\}/m) != null) {
        var f;
        try {
            if (typeof wrap === "function") {
                eval("f = " + wrap(val)); // jshint ignore:line
            } else {
                eval("f = " + val); // jshint ignore:line
            }
            return f;
        } catch (e) {
            // fall-back to original value if parsing failed
            return val;
        }
    }
    return val;
};

// Log wrapper, sends message to main thread for display, and includes worker id #
Utils.log = function (level) {
    for (var _len = arguments.length, msg = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        msg[_key - 1] = arguments[_key];
    }

    level = level || "info";
    if (Utils.isWorkerThread) {
        self.postMessage({
            type: "log",
            level: level,
            worker_id: self._worker_id,
            msg: msg
        });
    } else if (typeof log[level] === "function") {
        log[level].apply(log, msg);
    }
};

// Default to allowing high pixel density
Utils.use_high_density_display = true;
Utils.updateDevicePixelRatio = function () {
    Utils.device_pixel_ratio = Utils.use_high_density_display && window.devicePixelRatio || 1;
};

// Mark thread as main or worker
(function () {
    try {
        if (window.document !== undefined) {
            Utils.isWorkerThread = false;
            Utils.isMainThread = true;
            Utils.updateDevicePixelRatio();
        }
    } catch (e) {
        if (self !== undefined) {
            Utils.isWorkerThread = true;
            Utils.isMainThread = false;
        }
    }
})();

// Get URL that the current script was loaded from
// If currentScript is not available, loops through <script> elements searching for a list of provided paths
// e.g. Utils.findCurrentURL('tangram.debug.js', 'tangram.min.js');
Utils.findCurrentURL = function () {
    for (var _len = arguments.length, paths = Array(_len), _key = 0; _key < _len; _key++) {
        paths[_key] = arguments[_key];
    }

    // Find currently executing script
    var script = document.currentScript;
    if (script) {
        return script.src;
    } else if (Array.isArray(paths)) {
        // Fallback on looping through <script> elements if document.currentScript is not supported
        var scripts = document.getElementsByTagName("script");
        for (var s = 0; s < scripts.length; s++) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = paths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var path = _step.value;

                    if (scripts[s].src.indexOf(path) > -1) {
                        return scripts[s].src;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                        _iterator["return"]();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
    }
};

// Used for differentiating between power-of-2 and non-power-of-2 textures
// Via: http://stackoverflow.com/questions/19722247/webgl-wait-for-texture-to-load
Utils.isPowerOf2 = function (value) {
    return (value & value - 1) === 0;
};

Utils.nextPowerOf2 = function (value) {
    return Math.pow(2, Math.ceil(Math.log2(value)));
};

// Interpolate 'x' along a series of control points
// 'points' is an array of control points in the form [x, y]
//
// Example:
//     Control points:
//         [0, 5]:  when x=0, y=5
//         [4, 10]: when x=4, y=10
//
//     Utils.interpolate(2, [[0, 5], [4, 10]]);
//     -> computes x=2, halfway between x=0 and x=4: (10 - 5) / 2 +5
//     -> returns 7.5
//
// TODO: add other interpolation methods besides linear
//
Utils.interpolate = function (x, points) {
    // If this doesn't resemble a list of control points, just return the original value
    if (!Array.isArray(points) || !Array.isArray(points[0])) {
        return points;
    } else if (points.length < 1) {
        return points;
    }

    var x1, x2, d, y;

    // Min bounds
    if (x <= points[0][0]) {
        y = points[0][1];
    }
    // Max bounds
    else if (x >= points[points.length - 1][0]) {
        y = points[points.length - 1][1];
    }
    // Find which control points x is between
    else {
        for (var i = 0; i < points.length - 1; i++) {
            if (x >= points[i][0] && x < points[i + 1][0]) {
                // Linear interpolation
                x1 = points[i][0];
                x2 = points[i + 1][0];

                // Multiple values
                if (Array.isArray(points[i][1])) {
                    y = [];
                    for (var c = 0; c < points[i][1].length; c++) {
                        d = points[i + 1][1][c] - points[i][1][c];
                        y[c] = d * (x - x1) / (x2 - x1) + points[i][1][c];
                    }
                }
                // Single value
                else {
                    d = points[i + 1][1] - points[i][1];
                    y = d * (x - x1) / (x2 - x1) + points[i][1];
                }
                break;
            }
        }
    }
    return y;
};

// Iterators (ES6 generators)

// Iterator for key/value pairs of an object
Utils.entries = regeneratorRuntime.mark(function callee$0$0(obj) {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, key;

    return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$1$0.prev = 3;
                _iterator = Object.keys(obj)[Symbol.iterator]();

            case 5:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                    context$1$0.next = 12;
                    break;
                }

                key = _step.value;
                context$1$0.next = 9;
                return [key, obj[key]];

            case 9:
                _iteratorNormalCompletion = true;
                context$1$0.next = 5;
                break;

            case 12:
                context$1$0.next = 18;
                break;

            case 14:
                context$1$0.prev = 14;
                context$1$0.t0 = context$1$0["catch"](3);
                _didIteratorError = true;
                _iteratorError = context$1$0.t0;

            case 18:
                context$1$0.prev = 18;
                context$1$0.prev = 19;

                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }

            case 21:
                context$1$0.prev = 21;

                if (!_didIteratorError) {
                    context$1$0.next = 24;
                    break;
                }

                throw _iteratorError;

            case 24:
                return context$1$0.finish(21);

            case 25:
                return context$1$0.finish(18);

            case 26:
            case "end":
                return context$1$0.stop();
        }
    }, callee$0$0, this, [[3, 14, 18, 26], [19,, 21, 25]]);
});

// Iterator for values of an object
Utils.values = regeneratorRuntime.mark(function callee$0$1(obj) {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, key;

    return regeneratorRuntime.wrap(function callee$0$1$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$1$0.prev = 3;
                _iterator = Object.keys(obj)[Symbol.iterator]();

            case 5:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                    context$1$0.next = 12;
                    break;
                }

                key = _step.value;
                context$1$0.next = 9;
                return obj[key];

            case 9:
                _iteratorNormalCompletion = true;
                context$1$0.next = 5;
                break;

            case 12:
                context$1$0.next = 18;
                break;

            case 14:
                context$1$0.prev = 14;
                context$1$0.t1 = context$1$0["catch"](3);
                _didIteratorError = true;
                _iteratorError = context$1$0.t1;

            case 18:
                context$1$0.prev = 18;
                context$1$0.prev = 19;

                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }

            case 21:
                context$1$0.prev = 21;

                if (!_didIteratorError) {
                    context$1$0.next = 24;
                    break;
                }

                throw _iteratorError;

            case 24:
                return context$1$0.finish(21);

            case 25:
                return context$1$0.finish(18);

            case 26:
            case "end":
                return context$1$0.stop();
        }
    }, callee$0$1, this, [[3, 14, 18, 26], [19,, 21, 25]]);
});

// Recursive iterators for all properties of an object, no matter how deeply nested
// TODO: fix for circular structures
Utils.recurseEntries = regeneratorRuntime.mark(function callee$0$2(obj) {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, key;

    return regeneratorRuntime.wrap(function callee$0$2$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                if (obj) {
                    context$1$0.next = 2;
                    break;
                }

                return context$1$0.abrupt("return");

            case 2:
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$1$0.prev = 5;
                _iterator = Object.keys(obj)[Symbol.iterator]();

            case 7:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                    context$1$0.next = 17;
                    break;
                }

                key = _step.value;

                if (!obj[key]) {
                    context$1$0.next = 14;
                    break;
                }

                context$1$0.next = 12;
                return [key, obj[key], obj];

            case 12:
                if (!(typeof obj[key] === "object")) {
                    context$1$0.next = 14;
                    break;
                }

                return context$1$0.delegateYield(Utils.recurseEntries(obj[key]), "t2", 14);

            case 14:
                _iteratorNormalCompletion = true;
                context$1$0.next = 7;
                break;

            case 17:
                context$1$0.next = 23;
                break;

            case 19:
                context$1$0.prev = 19;
                context$1$0.t3 = context$1$0["catch"](5);
                _didIteratorError = true;
                _iteratorError = context$1$0.t3;

            case 23:
                context$1$0.prev = 23;
                context$1$0.prev = 24;

                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }

            case 26:
                context$1$0.prev = 26;

                if (!_didIteratorError) {
                    context$1$0.next = 29;
                    break;
                }

                throw _iteratorError;

            case 29:
                return context$1$0.finish(26);

            case 30:
                return context$1$0.finish(23);

            case 31:
            case "end":
                return context$1$0.stop();
        }
    }, callee$0$2, this, [[5, 19, 23, 31], [24,, 26, 30]]);
});

Utils.recurseValues = regeneratorRuntime.mark(function callee$0$3(obj) {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, key;

    return regeneratorRuntime.wrap(function callee$0$3$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                if (obj) {
                    context$1$0.next = 2;
                    break;
                }

                return context$1$0.abrupt("return");

            case 2:
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$1$0.prev = 5;
                _iterator = Object.keys(obj)[Symbol.iterator]();

            case 7:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                    context$1$0.next = 17;
                    break;
                }

                key = _step.value;

                if (!obj[key]) {
                    context$1$0.next = 14;
                    break;
                }

                context$1$0.next = 12;
                return obj[key];

            case 12:
                if (!(typeof obj[key] === "object")) {
                    context$1$0.next = 14;
                    break;
                }

                return context$1$0.delegateYield(Utils.recurseValues(obj[key]), "t4", 14);

            case 14:
                _iteratorNormalCompletion = true;
                context$1$0.next = 7;
                break;

            case 17:
                context$1$0.next = 23;
                break;

            case 19:
                context$1$0.prev = 19;
                context$1$0.t5 = context$1$0["catch"](5);
                _didIteratorError = true;
                _iteratorError = context$1$0.t5;

            case 23:
                context$1$0.prev = 23;
                context$1$0.prev = 24;

                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }

            case 26:
                context$1$0.prev = 26;

                if (!_didIteratorError) {
                    context$1$0.next = 29;
                    break;
                }

                throw _iteratorError;

            case 29:
                return context$1$0.finish(26);

            case 30:
                return context$1$0.finish(23);

            case 31:
            case "end":
                return context$1$0.stop();
        }
    }, callee$0$3, this, [[5, 19, 23, 31], [24,, 26, 30]]);
});

// Scale a *signed* short for use in a GL VBO
// `unit` is an optional scaling factor to mimic fixed point, since these values will be
// normalized to 0-1, e.g. divide input by unit on the way in, multiply it back in the shader
Utils.scaleInt16 = function (val, unit) {
    return val / unit * 32767;
};

Utils.degToRad = function (degrees) {
    return degrees * Math.PI / 180;
};

Utils.radToDeg = function (radians) {
    return radians * 180 / Math.PI;
};

Utils.toCanvasColor = function (color) {
    return "rgb(" + Math.round(color[0] * 255) + "," + Math.round(color[1] * 255) + "," + Math.round(color[2] * 255) + ")";
};

Utils.toPixelSize = function (size, kind) {
    if (kind === "px") {
        return size;
    } else if (kind === "em") {
        return 16 * size;
    } else if (kind === "pt") {
        return size / 0.75;
    } else if (kind === "%") {
        return size / 6.25;
    }
};

Utils.pointInTile = function (point) {
    return point[0] > 0 && point[1] > -Geo.tile_scale && point[0] < Geo.tile_scale && point[1] < 0;
};

Utils.pixelToMercator = function (size) {
    return size * Geo.units_per_pixel;
};

},{"../geo":73,"js-yaml":29,"loglevel":60}],116:[function(require,module,exports){
"use strict";

var version;
module.exports = version = {
    string: "v0.2.1",
    major: 0,
    minor: 2,
    patch: 1,
    pre: false
};

},{}],117:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

/*jshint worker: true*/

// WorkerBroker routes messages between web workers and the main thread, allowing for simpler
// async code via promises. Example usage:
//
// In web worker, define a method:
//
//     self.square = function (x) {
//         return x * x;
//     };
//
// In main thread, invoke that method and receive the result (if any) as a promise:
//
//     worker = new Worker(...);
//     WorkerBroker.addWorker(worker);
//
//     WorkerBroker.postMessage(worker, 'square', 5).then(function(y) {
//         console.log(y);
//     });
//
//     -> prints 25
//
// Async code:
//
// For synchronous code that must pass a return value to the main thread, the function can simply
// return an immediate value (see example above). For cases where the worker method needs to run
// asynchronous code, the function can return a promise, and the resolved or rejected value will
// be sent back to the main thread when the promise is fulfilled.
//
// Error handling:
//
// If the worker method either throws an error, or returns a promise that is rejected, it will be
// sent back to the main thread as a promise rejection. These two examples are equivalent:
//
//     In worker, throwing an error:
//
//         self.broken = function () {
//             throw new Error('error in worker!');
//         };
//
//     In worker, returning a rejected promise:
//
//         self.broken = function () {
//             return Promise.reject(new Error('error in worker!'));
//         };
//
//     In main thread, both errors are received as a promise rejection:
//
//         WorkerBroker.postMessage(worker, 'broken').then(
//             // Promise resolved
//             function() {
//                 console.log('success!');
//             },
//             // Promise rejected
//             function(error) {
//                 console.log('error!', error);
//             });
//
//         -> prints 'error! error in worker'
//
// TODO: add documentation for invoking main thread methods from a worker (basically same API, but in reverse)

var Utils = _interopRequire(require("./utils"));

var WorkerBroker;
module.exports = WorkerBroker = {};

// Global list of all worker messages
// Uniquely tracks every call made between main thread and a worker
var message_id = 0;
var messages = {};

// Main thread:
// - Send messages to workers, and optionally receive an async response as a promise
// - Receive messages from workers, and optionally send an async response back as a promise
function setupMainThread() {

    // Send a message to a worker, and optionally get an async response
    // Arguments:
    //   - worker: the web worker instance
    //   - method: the method with this name will be invoked in the worker
    //   - message: will be passed to the method call in the worker
    // Returns:
    //   - a promise that will be fulfilled if the worker method returns a value (could be immediately, or async)
    //
    WorkerBroker.postMessage = function (worker, method) {
        for (var _len = arguments.length, message = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            message[_key - 2] = arguments[_key];
        }

        // Track state of this message
        var promise = new Promise(function (resolve, reject) {
            messages[message_id] = { method: method, message: message, resolve: resolve, reject: reject };
        });

        worker.postMessage({
            type: "main_send", // mark message as method invocation from main thread
            message_id: message_id, // unique id for this message, for life of program
            method: method, // will dispatch to a function of this name within the worker
            message: message // message payload
        });

        message_id++;
        return promise;
    };

    // Add a worker to communicate with - each worker must be registered from the main thread
    var worker_id = 0;
    var workers = {};

    WorkerBroker.addWorker = function (worker) {

        // Keep track of all registered workers
        // TODO: adding a property directly to the worker, would be better to track non-instrusively,
        // maybe with an ES6 Map
        worker._worker_broker_id = worker_id++;
        workers[worker._worker_broker_id] = worker;

        // Listen for messages coming back from the worker, and fulfill that message's promise
        worker.addEventListener("message", function (event) {
            if (event.data.type !== "worker_reply") {
                return;
            }

            // Pass the result to the promise
            var id = event.data.message_id;
            if (messages[id]) {
                if (event.data.error) {
                    messages[id].reject(event.data.error);
                } else {
                    messages[id].resolve(event.data.message);
                }
                delete messages[id];
            }
        });

        // Listen for messages initiating a call from the worker, dispatch them,
        // and send any return value back to the worker
        worker.addEventListener("message", function (event) {
            // Unique id for this message & return call to main thread
            var id = event.data.message_id;
            if (event.data.type !== "worker_send" || id == null) {
                return;
            }

            // Call the requested method and save the return value
            var target = targets[event.data.target];
            if (!target) {
                throw Error("Worker broker could not dispatch message type " + event.data.method + " on target " + event.data.target + " because no object with that name is registered on main thread");
            }

            var method = typeof target[event.data.method] === "function" && target[event.data.method];
            if (!method) {
                throw Error("Worker broker could not dispatch message type " + event.data.method + " on target " + event.data.target + " because object has no method with that name");
            }

            var result, error;
            try {
                result = method.apply(target, event.data.message);
            } catch (e) {
                // Thrown errors will be passed back (in string form) to worker
                error = e;
            }

            // Send return value to worker
            // Async result
            if (result instanceof Promise) {
                result.then(function (value) {
                    worker.postMessage({
                        type: "main_reply",
                        message_id: id,
                        message: value
                    });
                }, function (error) {
                    worker.postMessage({
                        type: "main_reply",
                        message_id: id,
                        error: error instanceof Error ? "" + error.message + ": " + error.stack : error
                    });
                });
            }
            // Immediate result
            else {
                worker.postMessage({
                    type: "main_reply",
                    message_id: id,
                    message: result,
                    error: error instanceof Error ? "" + error.message + ": " + error.stack : error
                });
            }
        });
    };

    // Register an object to receive calls from the worker
    var targets = {};
    WorkerBroker.addTarget = function (name, target) {
        targets[name] = target;
    };

    // Expose for debugging
    WorkerBroker.getMessages = function () {
        return messages;
    };

    WorkerBroker.getMessageId = function () {
        return message_id;
    };
}

// Worker threads:
// - Receive messages from main thread, and optionally send an async response back as a promise
// - Send messages to main thread, and optionally receive an async response as a promise
function setupWorkerThread() {

    // Send a message to the main thread, and optionally get an async response as a promise
    // Arguments:
    //   - target: the name of the object in the main thread to be called
    //   - method: the method with this name will be invoked on the main thread target object
    //   - message: will be passed to the method call in the main thread
    // Returns:
    //   - a promise that will be fulfilled if the main thread method returns a value (could be immediately, or async)
    //
    WorkerBroker.postMessage = function (target, method) {
        for (var _len = arguments.length, message = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            message[_key - 2] = arguments[_key];
        }

        // Track state of this message
        var promise = new Promise(function (resolve, reject) {
            messages[message_id] = { target: target, method: method, message: message, resolve: resolve, reject: reject };
        });

        self.postMessage({
            type: "worker_send", // mark message as method invocation from worker
            message_id: message_id, // unique id for this message, for life of program
            target: target, // name of the object to be called on main thread
            method: method, // will dispatch to a method of this name on the main thread
            message: message // message payload
        });

        message_id++;
        return promise;
    };

    // Listen for messages coming back from the main thread, and fulfill that message's promise
    self.addEventListener("message", function (event) {
        if (event.data.type !== "main_reply") {
            return;
        }

        // Pass the result to the promise
        var id = event.data.message_id;
        if (messages[id]) {
            if (event.data.error) {
                messages[id].reject(event.data.error);
            } else {
                messages[id].resolve(event.data.message);
            }
            delete messages[id];
        }
    });

    // Receive messages from main thread, dispatch them, and send back a reply
    self.addEventListener("message", function (event) {
        // Unique id for this message & return call to main thread
        var id = event.data.message_id;
        if (event.data.type !== "main_send" || id == null) {
            return;
        }

        // Call the requested worker method and save the return value
        var method_name = event.data.method;
        var method = typeof self[method_name] === "function" && self[method_name];
        if (!method) {
            throw Error("Worker broker could not dispatch message type " + method_name + " because worker has no method with that name");
        }

        var result, error;
        try {
            result = method.apply(self, event.data.message);
        } catch (e) {
            // Thrown errors will be passed back (in string form) to main thread
            error = e;
        }

        // Send return value to main thread
        var transferables = undefined;
        // Async result
        if (result instanceof Promise) {
            result.then(function (value) {
                transferables = findTransferables(value);

                self.postMessage({
                    type: "worker_reply",
                    message_id: id,
                    message: value
                }, transferables);

                if (transferables.length > 0) {
                    Utils.log("trace", "'" + method_name + "' transferred " + transferables.length + " objects to main thread");
                }
            }, function (error) {
                self.postMessage({
                    type: "worker_reply",
                    message_id: id,
                    error: error instanceof Error ? "" + error.message + ": " + error.stack : error
                });
            });
        }
        // Immediate result
        else {
            transferables = findTransferables(result);

            self.postMessage({
                type: "worker_reply",
                message_id: id,
                message: result,
                error: error instanceof Error ? "" + error.message + ": " + error.stack : error
            }, transferables);

            if (transferables.length > 0) {
                Utils.log("trace", "'" + method_name + "' transferred " + transferables.length + " objects to main thread");
            }
        }
    });
}

// Build a list of transferable objects from a source object
// TODO: add option in case you DON'T want to transfer objects
function findTransferables(source) {
    var list = arguments[1] === undefined ? [] : arguments[1];

    if (!source) {
        return list;
    }

    if (Array.isArray(source)) {
        // Check each array element
        source.forEach(function (x) {
            return findTransferables(x, list);
        });
    } else if (typeof source === "object") {
        // Is the object a transferable array buffer?
        if (source instanceof ArrayBuffer) {
            list.push(source);
        }
        // Or looks like a typed array (has an array buffer property)?
        else if (source.buffer instanceof ArrayBuffer) {
            list.push(source.buffer);
        }
        // Otherwise check each property
        else {
            for (var p in source) {
                findTransferables(source[p], list);
            }
        }
    }
    return list;
}

// Setup this thread as appropriate
if (Utils.isMainThread) {
    setupMainThread();
}

if (Utils.isWorkerThread) {
    setupWorkerThread();
}

},{"./utils":115}],118:[function(require,module,exports){
"use strict";

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

/*** Vector functions - vectors provided as [x, y, z] arrays ***/

var Vector;
module.exports = Vector = {};

Vector.set = function (v) {
    var V = [];
    var lim = v.length;
    for (var i = 0; i < lim; i++) {
        V[i] = v[i];
    }
    return V;
};

Vector.neg = function (v) {
    var V = [];
    var lim = v.length;
    for (var i = 0; i < lim; i++) {
        V[i] = v[i] * -1;
    }
    return V;
};

// Addition of two vectors
Vector.add = function (v1, v2) {
    var v = [];
    var lim = Math.min(v1.length, v2.length);
    for (var i = 0; i < lim; i++) {
        v[i] = v1[i] + v2[i];
    }
    return v;
};

// Substraction of two vectors
Vector.sub = function (v1, v2) {
    var v = [];
    var lim = Math.min(v1.length, v2.length);

    for (var i = 0; i < lim; i++) {
        v[i] = v1[i] - v2[i];
    }
    return v;
};

Vector.signed_area = function (v1, v2, v3) {
    return (v2[0] - v1[0]) * (v3[1] - v1[1]) - (v3[0] - v1[0]) * (v2[1] - v1[1]);
};

// Multiplication of two vectors
Vector.mult = function (v1, v2) {
    var v = [],
        len = v1.length,
        i;

    if (typeof v2 === "number") {
        // Mulitply by scalar
        for (i = 0; i < len; i++) {
            v[i] = v1[i] * v2;
        }
    } else {
        // Multiply two vectors
        len = Math.min(v1.length, v2.length);
        for (i = 0; i < len; i++) {
            v[i] = v1[i] * v2[i];
        }
    }
    return v;
};

// Division of two vectors
Vector.div = function (v1, v2) {
    var v = [],
        i;
    if (typeof v2 === "number") {
        // Divide by scalar
        for (i = 0; i < v1.length; i++) {
            v[i] = v1[i] / v2;
        }
    } else {
        // Divide to vectors
        var len = Math.min(v1.length, v2.length);
        for (i = 0; i < len; i++) {
            v[i] = v1[i] / v2[i];
        }
    }
    return v;
};

// Get 2D perpendicular
Vector.perp = function (v1, v2) {
    return [v2[1] - v1[1], v1[0] - v2[0]];
};

// Get 2D vector rotated
Vector.rot = function (v, a) {
    var vr = Vector.length(v);
    var va = Vector.angle(v);
    return [vr * Math.cos(va + a), vr * Math.sin(va + a)];
};

// Get 2D heading angle
Vector.angle = function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2);

    var x = _ref2[0];
    var y = _ref2[1];

    return Math.atan2(y, x);
};

// Compare two points
Vector.isEqual = function (v1, v2) {
    var len = v1.length;
    for (var i = 0; i < len; i++) {
        if (v1[i] !== v2[i]) {
            return false;
        }
    }
    return true;
};

// Vector length squared
Vector.lengthSq = function (v) {
    if (v.length === 2) {
        return v[0] * v[0] + v[1] * v[1];
    } else {
        return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
    }
};

// Vector length
Vector.length = function (v) {
    return Math.sqrt(Vector.lengthSq(v));
};

// Normalize a vector
Vector.normalize = function (v) {
    var d;
    if (v.length === 2) {
        d = v[0] * v[0] + v[1] * v[1];
        d = Math.sqrt(d);

        if (d !== 0) {
            return [v[0] / d, v[1] / d];
        }
        return [0, 0];
    } else {
        d = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
        d = Math.sqrt(d);

        if (d !== 0) {
            return [v[0] / d, v[1] / d, v[2] / d];
        }
        return [0, 0, 0];
    }
};

// Cross product of two vectors
Vector.cross = function (v1, v2) {
    return [v1[1] * v2[2] - v1[2] * v2[1], v1[2] * v2[0] - v1[0] * v2[2], v1[0] * v2[1] - v1[1] * v2[0]];
};

// Dot product of two vectors
Vector.dot = function (v1, v2) {
    var n = 0;
    var lim = Math.min(v1.length, v2.length);
    for (var i = 0; i < lim; i++) {
        n += v1[i] * v2[i];
    }
    return n;
};

// Find the intersection of two lines specified as segments from points (p1, p2) and (p3, p4)
// http://en.wikipedia.org/wiki/Line-line_intersection
// http://en.wikipedia.org/wiki/Cramer's_rule
Vector.lineIntersection = function (p1, p2, p3, p4, parallel_tolerance) {
    parallel_tolerance = parallel_tolerance || 0.01;

    // a1*x + b1*y = c1 for line (x1, y1) to (x2, y2)
    // a2*x + b2*y = c2 for line (x3, y3) to (x4, y4)
    var a1 = p1[1] - p2[1]; // y1 - y2
    var b1 = p1[0] - p2[0]; // x1 - x2
    var a2 = p3[1] - p4[1]; // y3 - y4
    var b2 = p3[0] - p4[0]; // x3 - x4
    var c1 = p1[0] * p2[1] - p1[1] * p2[0]; // x1*y2 - y1*x2
    var c2 = p3[0] * p4[1] - p3[1] * p4[0]; // x3*y4 - y3*x4
    var denom = b1 * a2 - a1 * b2;

    if (Math.abs(denom) > parallel_tolerance) {
        return [(c1 * b2 - b1 * c2) / denom, (c1 * a2 - a1 * c2) / denom];
    }
    return null; // return null if lines are (close to) parallel
};

},{}],119:[function(require,module,exports){
module.exports = require("./lib/babel/polyfill");

},{"./lib/babel/polyfill":1}]},{},[119,89])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbGliL2JhYmVsL3BvbHlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsL25vZGVfbW9kdWxlcy9jb3JlLWpzL3NoaW0uanMiLCJub2RlX21vZHVsZXMvYmFiZWwvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLWJhYmVsL3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2xpYi9icnV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2xpYi9pbnRlcnNlY3QuanMiLCJub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9saWIvbWVkaWFuLmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL3BhcnRpdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2xpYi9zb3J0LmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL3N3ZWVwLmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3Qvbm9kZV9tb2R1bGVzL2JpdC10d2lkZGxlL3R3aWRkbGUuanMiLCJub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9ub2RlX21vZHVsZXMvdHlwZWRhcnJheS1wb29sL25vZGVfbW9kdWxlcy9kdXAvZHVwLmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3Qvbm9kZV9tb2R1bGVzL3R5cGVkYXJyYXktcG9vbC9wb29sLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pcy1hcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jc3Njb2xvcnBhcnNlci9jc3Njb2xvcnBhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9lYXJjdXQvc3JjL2VhcmN1dC5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy9jbGlwLmpzIiwibm9kZV9tb2R1bGVzL2dlb2pzb24tdnQvc3JjL2NvbnZlcnQuanMiLCJub2RlX21vZHVsZXMvZ2VvanNvbi12dC9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2VvanNvbi12dC9zcmMvc2ltcGxpZnkuanMiLCJub2RlX21vZHVsZXMvZ2VvanNvbi12dC9zcmMvdGlsZS5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy93cmFwLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9kaXN0L2dsLW1hdHJpeC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1zaGFkZXItZXJyb3JzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL2R1bXBlci5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL2V4Y2VwdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL2xvYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL21hcmsuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X2Z1bGwuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZGVmYXVsdF9zYWZlLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hL2ZhaWxzYWZlLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hL2pzb24uanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9iaW5hcnkuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2Jvb2wuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2Zsb2F0LmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9pbnQuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2pzL2Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy9yZWdleHAuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2pzL3VuZGVmaW5lZC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvbWFwLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9tZXJnZS5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvbnVsbC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvb21hcC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvcGFpcnMuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL3NlcS5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvc2V0LmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zdHIuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL3RpbWVzdGFtcC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL25vZGVfbW9kdWxlcy9lc3ByaW1hL2VzcHJpbWEuanMiLCJub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIiwibm9kZV9tb2R1bGVzL21hdGNoLWZlYXR1cmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGJmL2J1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9wYmYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyaXAtY29tbWVudHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdG9wb2pzb24vdG9wb2pzb24uanMiLCJub2RlX21vZHVsZXMvdmVjdG9yLXRpbGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmVjdG9yLXRpbGUvbGliL3ZlY3RvcnRpbGUuanMiLCJub2RlX21vZHVsZXMvdmVjdG9yLXRpbGUvbGliL3ZlY3RvcnRpbGVmZWF0dXJlLmpzIiwibm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2xpYi92ZWN0b3J0aWxlbGF5ZXIuanMiLCJub2RlX21vZHVsZXMvdmVjdG9yLXRpbGUvbm9kZV9tb2R1bGVzL3BvaW50LWdlb21ldHJ5L2luZGV4LmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9jYW1lcmEuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2dlby5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvZ2wvY29uc3RhbnRzLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9nbC9jb250ZXh0LmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9nbC9leHRlbnNpb25zLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9nbC9nbHNsLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9nbC9yZW5kZXJfc3RhdGUuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2dsL3NoYWRlcl9wcm9ncmFtLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9nbC9zaGFkZXJfc291cmNlcy5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvZ2wvdGV4dHVyZS5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvZ2wvdmFvLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9nbC92Ym9fbWVzaC5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvZ2wvdmVydGV4X2RhdGEuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2dsL3ZlcnRleF9sYXlvdXQuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2xlYWZsZXRfbGF5ZXIuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL2xpZ2h0LmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9tYXRlcmlhbC5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvbW9kdWxlLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zY2VuZS5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc2NlbmVfd29ya2VyLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zZWxlY3Rpb24uanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3NvdXJjZXMvZGF0YV9zb3VyY2UuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3NvdXJjZXMvZ2VvanNvbi5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc291cmNlcy9tdnQuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3NvdXJjZXMvdG9wb2pzb24uanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy9idWlsZGVycy5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc3R5bGVzL2xpbmVzL2xpbmVzLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zdHlsZXMvcG9pbnRzL3BvaW50cy5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc3R5bGVzL3BvbHlnb25zL3BvbHlnb25zLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zdHlsZXMvcnVsZS5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc3R5bGVzL3N0eWxlLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zdHlsZXMvc3R5bGVfbWFuYWdlci5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc3R5bGVzL3N0eWxlX3BhcnNlci5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvc3R5bGVzL3RleHQvbGFiZWwuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy90ZXh0L2xhYmVsX2J1aWxkZXIuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy90ZXh0L2xhYmVsX2xpbmUuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3N0eWxlcy90ZXh0L2xhYmVsX3BvaW50LmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy9zdHlsZXMvdGV4dC90ZXh0LmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy90aWxlLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy90aWxlX21hbmFnZXIuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3V0aWxzL2Vycm9ycy5qcyIsIi9Vc2Vycy9iY2FtcGVyL0RvY3VtZW50cy9kZXYvdmVjdG9yLW1hcC9zcmMvdXRpbHMvb2JiLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy91dGlscy9zdWJzY3JpYmUuanMiLCIvVXNlcnMvYmNhbXBlci9Eb2N1bWVudHMvZGV2L3ZlY3Rvci1tYXAvc3JjL3V0aWxzL3V0aWxzLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy91dGlscy92ZXJzaW9uLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy91dGlscy93b3JrZXJfYnJva2VyLmpzIiwiL1VzZXJzL2JjYW1wZXIvRG9jdW1lbnRzL2Rldi92ZWN0b3ItbWFwL3NyYy92ZWN0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwvcG9seWZpbGwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6N0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2piQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hOQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWhDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGpEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RoQkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFD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RUFBRSxDQUFDLENBQUMsR0FBQyxLQUFLLENBQUEsR0FBRSxTQUFTLENBQUMsS0FBSyxHQUFHLEtBQUssR0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDO1FBQ3pFLEVBQUUsR0FBRyxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEdBQUMsS0FBSyxDQUFBLEdBQUUsU0FBUyxDQUFDLEtBQUssR0FBRyxLQUFLLEdBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQztRQUN6RSxFQUFFLEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFDLEtBQUssQ0FBQSxHQUFFLFNBQVMsQ0FBQyxLQUFLLEdBQUcsS0FBSyxHQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7QUFFOUUsUUFBSSxNQUFNLEVBQUU7QUFDUixpQkFBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ3hDLGlCQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsU0FBUyxDQUFDLENBQUM7S0FDM0MsTUFBTTtBQUNILFVBQUUsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3RCLFVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDVixVQUFFLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN0QixVQUFFLEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFDLEtBQUssQ0FBQSxHQUFFLFNBQVMsQ0FBQyxLQUFLLEdBQUcsS0FBSyxHQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMxRSxVQUFFLEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFDLEtBQUssQ0FBQSxHQUFFLFNBQVMsQ0FBQyxLQUFL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QUFJLENBQUMsZUFBZSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzlCLFlBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDOzs7QUFHcEMsWUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQ2pELFlBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUNqRCxZQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDakQsWUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDOzs7QUFHakQsWUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO0FBQ2hCLGdCQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDM0QsZ0JBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUMzRCxnQkFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQzNELGdCQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7U0FDOUQ7OztBQUdELFlBQUks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QUM7QUFDckIsWUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7QUFDckIsWUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7O0FBRTdCLFlBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0FBQ3JCLFlBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUMzRSxZQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQzVDLFlBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQy9ELFlBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDMUMsWUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsYUFBYSxDQUFDLEVBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQzdGLElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDLEVBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUcsQ0FBQyxFQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFHLENBQUM7QUFDM0UsWUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQzs7QUFFN0YsWUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFDakIsWUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7S0FDdEI7O2lCQXpDZ0IsSUFBSTtBQXlGckIscUJBQWE7bUJBQUEseUJBQUc7QUFDWixvQkFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO0FBQ2IseUJBQUssSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUN2Qiw0QkFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztxQkFDNUI7aUJBQ0o7O0FBRUQsb0JBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTs7Ozs7O0FBQ2YsNkNBQWMsSUFBSSxDQUFDLFFBQVE7Z0NBQWxCLENBQUM7O0FBQ04sZ0NBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbEMsZ0NBQUksT0FBTyxFQUFFO0FBQ1QsdUNBQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQzs2QkFDckI7eUJBQ0o7Ozs7Ozs7Ozs7Ozs7OztpQkFDSjs7QUFFRCxvQkFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFDakIsb0JBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO2FBQ3RCOztBQUVELGVBQU87bUJBQUEsbUJBQUc7QUFDTixvQkFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzNDLG9CQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7QUFDckIsb0JBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO2FBQ3RCOztBQUVELHNCQUFjO21CQUFBLDBCQUFHO0FBQ2IsdUJBQU87QUFDSCx1QkFBRyxFQUFFLElBQUksQ0FBQyxHQUFHO0FBQ2IsNkJBQVMsRUFBRSxJQUFJLENBQUMsU0FBUztBQUN6QiwwQkFBTSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSTtBQUN4QiwwQkFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO0FBQ25CLHVCQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUc7QUFDYix1QkFBRyxFQUFFLElBQUksQ0FBQyxHQUFHO0FBQ2IsOEJBQVUsRUFBRSxJQUFJLENBQUMsVUFBVTtBQUMzQiw4QkFBVSxFQUFFLElBQUksQ0FBQyxVQUFVO0FBQzNCLHlCQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7aUJBQ3BCLENBQUM7YUFDTDs7QUFFRCxxQkFBYTttQkFBQyx5QkFBYTtrREFBVCxPQUFPO0FBQVAsMkJBQU87OztBQUNyQix1QkFBTyxZQUFZLENBQUMsV0FBVyxNQUFBLENBQXhCLFlBQVksR0FBYSxJQUFJLENBQUMsTUFBTSxTQUFLLE9BQU8sRUFBQyxDQUFDO2FBQzVEOztBQUVELGFBQUs7bUJBQUEsZUFBQyxVQUFVLEVBQUU7QUFDZCxvQkFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7QUFDN0Isb0JBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO0FBQ2Qsd0JBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO2lCQUN2QjtBQUNELHVCQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxjQUFjLEVBQUUsRUFBRSxDQUFDLFNBQU0sQ0FBQyxVQUFBLENBQUMsRUFBSTtBQUFFLDBCQUFNLENBQUMsQ0FBQztpQkFBRSxDQUFDLENBQUM7YUFDcEc7O0FBc0lELG1CQUFXOzs7Ozs7O21CQUFBLHFCQUFDLE1BQU0sRUFBRTtBQUNoQixvQkFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO0FBQ1osMkJBQU87aUJBQ1Y7OztBQUdELG9CQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7OztBQUdyQixvQkFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDO0FBQzFCLG9CQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUM7OztBQUczQixvQkFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztBQUMvQixvQkFBSSxTQUFTLEVBQUU7QUFDWCx5QkFBSyxJQUFJLENBQUMsSUFBSSxTQUFTLEVBQUU7QUFDckIsNEJBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRTtBQUMxQixnQ0FBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUM7QUFDOUQsZ0NBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUU7QUFDWixtQ0FBRyxDQUFDLElBQUksMkNBQXlDLENBQUMsOEJBQXlCLElBQUksQ0FBQyxHQUFHLHFCQUFrQixDQUFDO0FBQ3RHLG9DQUFJLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQztBQUNqQixzQ0FBTTs2QkFDVDtBQUNELGdDQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM1RSxnQ0FBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUM7eUJBQzFEOzs7QUFHRCw0QkFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFOzs7QUFDdkIseUNBQUEsSUFBSSxDQUFDLFFBQVEsRUFBQyxJQUFJLE1BQUEsK0JBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBQyxDQUFDO3lCQUNoRDtxQkFDSjtpQkFDSjs7QUFFRCxvQkFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQSxDQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNqRixvQkFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7QUFDdEIsb0JBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQzthQUNyQjs7QUF3QkQsa0JBQVU7bUJBQUMsc0JBQUc7QUFDVixtQkFBRyxDQUFDLEtBQUssc0JBQW9CLElBQUksQ0FBQyxHQUFHLGFBQVEsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQUssQ0FBQzthQUNoRjs7QUFFRCxjQUFNO21CQUFBLGdCQUFDLEtBQUssRUFBRTtBQUNWLG9CQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO0FBQ3pCLG9CQUFJLE1BQU0sQ0FBQyxDQUFDLEtBQUssS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQUU7QUFDbEMsMEJBQU0sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQy9EO0FBQ0Qsb0JBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDMUc7O0FBMENELGFBQUs7bUJBQUEsZUFBQyxLQUFLLEVBQUU7QUFDVCxxQkFBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLEVBQUU7QUFDbkIsd0JBQUksR0FBRyxLQUFLLEtBQUssRUFBRTtBQUNmLDRCQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO3FCQUMxQjtpQkFDSjtBQUNELHVCQUFPLElBQUksQ0FBQzthQUNmOzs7QUE5Vk0sY0FBTTttQkFBQSxnQkFBQyxJQUFJLEVBQUU7QUFDaEIsdUJBQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDekI7O0FBRU0sZ0JBQVE7bUJBQUEsd0JBQVk7b0JBQVYsQ0FBQyxRQUFELENBQUM7b0JBQUUsQ0FBQyxRQUFELENBQUM7b0JBQUUsQ0FBQyxRQUFELENBQUM7O0FBQ3BCLHVCQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDOUI7O0FBRU0sV0FBRzttQkFBQyxhQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFO0FBQ3BDLHNCQUFNLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDNUQsdUJBQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUM1RTs7QUFFTSx3QkFBZ0I7bUJBQUEsZ0NBQVksSUFBSSxFQUFFO29CQUFoQixDQUFDLFFBQUQsQ0FBQztvQkFBRSxDQUFDLFFBQUQsQ0FBQztvQkFBRSxDQUFDLFFBQUQsQ0FBQzs7QUFDNUIsb0JBQUksQ0FBQyxLQUFLLElBQUksRUFBRTtBQUNaLHdCQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFDbkMscUJBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQztBQUMzQixxQkFBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDO2lCQUM5QjtBQUNELHVCQUFPLEVBQUMsQ0FBQyxFQUFELENBQUMsRUFBRSxDQUFDLEVBQUQsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUMsQ0FBQzthQUMxQjs7QUFFTSxlQUFPO21CQUFBLGlCQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUU7QUFDMUIsb0JBQUksS0FBSyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxFQUFFO2lEQUNQLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQzs7d0JBQTlDLENBQUMsMEJBQUQsQ0FBQzt3QkFBRSxDQUFDLDBCQUFELENBQUM7O0FBQ1QsMkJBQVEsTUFBTSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUU7aUJBQzdDO0FBQ0QsdUJBQU8sS0FBSyxDQUFDO2FBQ2hCOztBQUVNLDRCQUFvQjttQkFBQSxvQ0FBWSxRQUFRLEVBQUU7b0JBQXBCLENBQUMsUUFBRCxDQUFDO29CQUFFLENBQUMsUUFBRCxDQUFDO29CQUFFLENBQUMsUUFBRCxDQUFDOztBQUNoQyxvQkFBSSxRQUFRLEtBQUssU0FBUyxJQUFJLENBQUMsR0FBRyxRQUFRLEVBQUU7QUFDeEMsMkJBQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUMsQ0FBQyxFQUFELENBQUMsRUFBRSxDQUFDLEVBQUQsQ0FBQyxFQUFFLENBQUMsRUFBRCxDQUFDLEVBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztpQkFDckQ7QUFDRCx1QkFBTyxFQUFDLENBQUMsRUFBRCxDQUFDLEVBQUUsQ0FBQyxFQUFELENBQUMsRUFBRSxDQUFDLEVBQUQsQ0FBQyxFQUFDLENBQUM7YUFDcEI7O0FBR00sWUFBSTs7OzttQkFBQSxjQUFDLEtBQUssRUFBRTtBQUNmLHVCQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBQyxDQUFDLEVBQUUsQ0FBQyxFQUFLO0FBQ3hCLHdCQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsV0FBVyxDQUFDO0FBQ3ZCLHdCQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsV0FBVyxDQUFDO0FBQ3ZCLDJCQUFRLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFHO2lCQUMvQyxDQUFDLENBQUM7YUFDTjs7QUF3RE0scUJBQWE7Ozs7O21CQUFDLHVCQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRTtBQUMvQyxvQkFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDO0FBQ25DLG9CQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7O0FBRXhCLG9CQUFJLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDOzs7QUFHNUIscUJBQUssSUFBSSxVQUFVLElBQUksTUFBTSxFQUFFO0FBQzNCLHdCQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7O0FBRS9CLHdCQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRTtBQUNiLDJCQUFHLENBQUMsSUFBSSxZQUFVLEtBQUssMkVBQXdFLENBQUM7QUFDaEcsaUNBQVM7cUJBQ1o7OztBQUdELHdCQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxLQUFLLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFDbkMsaUNBQVM7cUJBQ1o7O0FBRUQsd0JBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQztBQUMvRCx3QkFBSSxDQUFDLElBQUksRUFBRTtBQUNQLGlDQUFTO3FCQUNaOzs7QUFHRCx3QkFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUM7QUFDeEMseUJBQUssSUFBSSxDQUFDLEdBQUcsWUFBWSxHQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3RDLDRCQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQy9CLDRCQUFJLE9BQU8sR0FBRyxXQUFXLENBQUMsc0JBQXNCLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDOzs7QUFHaEUsNEJBQUksV0FBVyxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNwQyw0QkFBSSxXQUFXLEdBQUcsV0FBVyxDQUFDLGVBQWUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDN0QsNEJBQUksQ0FBQyxXQUFXLEVBQUU7QUFDZCxxQ0FBUzt5QkFDWjs7O0FBR0QsNkJBQUssSUFBSSxVQUFVLElBQUksV0FBVyxFQUFFO0FBQ2hDLGdDQUFJLEtBQUssR0FBRyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDcEMsZ0NBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFO0FBQ2hCLHlDQUFTOzZCQUNaOzs7QUFHRCxnQ0FBSSxVQUFVLEdBQUcsS0FBSyxDQUFDLEtBQUssSUFBSSxVQUFVLENBQUM7QUFDM0MsZ0NBQUksS0FBSyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQzs7QUFFL0IsZ0NBQUksQ0FBQyxLQUFLLEVBQUU7QUFDUixtQ0FBRyxDQUFDLElBQUksYUFBVyxVQUFVLHVDQUFrQyxVQUFVLFNBQU0sS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQy9GLHlDQUFTOzZCQUNaOztBQUVELG1DQUFPLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUM7O0FBRXRDLGlDQUFLLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7O0FBRTFDLG1DQUFPLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQzt5QkFDN0I7O0FBRUQsNEJBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7cUJBQ3pCO2lCQUNKO0FBQ0Qsb0JBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLENBQUMsSUFBSSxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQzs7O0FBRzFELG9CQUFJLFdBQVcsR0FBRyxZQUFZLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN2RCxvQkFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7QUFDcEIsb0JBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQzs7Ozs7O0FBQ2YseUNBQXVCLFdBQVc7O2dDQUF6QixVQUFVOztBQUNmLGdDQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDL0IsaUNBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQUMsVUFBVSxFQUFLO0FBQ3BELG9DQUFJLFVBQVUsRUFBRTtBQUNaLHdDQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxHQUFHO0FBQ3pCLG1EQUFXLEVBQUUsVUFBVSxDQUFDLFdBQVc7QUFDbkMsZ0RBQVEsRUFBRSxVQUFVLENBQUMsUUFBUTtBQUM3QixnREFBUSxFQUFFLFVBQVUsQ0FBQyxRQUFRO3FDQUNoQyxDQUFDO2lDQUNMOzZCQUNKLENBQUMsQ0FBQyxDQUFDOztxQkFDUDs7Ozs7Ozs7Ozs7Ozs7OztBQUVELHVCQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQU07O0FBRWpDLDJCQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7aUJBQ3hCLENBQUMsQ0FBQzthQUNOOztBQUtNLHdCQUFnQjs7Ozs7O21CQUFDLDBCQUFDLFdBQVcsRUFBRSxhQUFhLEVBQXdCO29CQUF0QixhQUFhLGdDQUFHLElBQUk7O0FBQ3JFLG9CQUFJLElBQUksQ0FBQzs7QUFFVCxvQkFBSSxhQUFhLElBQUksSUFBSSxFQUFFOztBQUV2Qix3QkFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLElBQUksV0FBVyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUU7QUFDckQsNEJBQUksR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQztxQkFDdEM7O3lCQUVJLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxJQUFJLGFBQWEsRUFBRTtBQUM1Qyw0QkFBSSxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7cUJBQzVDOzt5QkFFSSxJQUFJLE9BQU8sYUFBYSxDQUFDLEtBQUssS0FBSyxRQUFRLEVBQUU7QUFDOUMsNEJBQUksR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztxQkFDbEQ7O3lCQUVJLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDekMsNEJBQUksR0FBRyxFQUFFLElBQUksRUFBRSxtQkFBbUIsRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFLENBQUM7QUFDbkQscUNBQWEsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFVBQUEsS0FBSyxFQUFJO0FBQ2pDLGdDQUFJLFdBQVcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksV0FBVyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUU7OztBQUNqRSxrREFBQSxJQUFJLENBQUMsUUFBUSxFQUFDLElBQUksTUFBQSxvQ0FBSSxXQUFXLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsRUFBQyxDQUFDOzZCQUM3RDt5QkFDSixDQUFDLENBQUM7cUJBQ047O3lCQUVJLElBQUksT0FBTyxhQUFhLENBQUMsS0FBSyxLQUFLLFVBQVUsRUFBRTtBQUNoRCw0QkFBSSxHQUFHLGFBQWEsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO3FCQUNsRDtpQkFDSjs7QUFFRCx1QkFBTyxJQUFJLENBQUM7YUFDZjs7QUFrRE0sa0JBQVU7Ozs7Ozs7O21CQUFDLG9CQUFDLElBQUksRUFBRTtBQUNyQixvQkFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO0FBQ2hCLHlCQUFLLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7QUFDMUIsNEJBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO0FBQzFDLDRCQUFJLFFBQVEsRUFBRTs7Ozs7O0FBQ1YscURBQWMsUUFBUTt3Q0FBYixDQUFDOztBQUNOLHdDQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2xDLHdDQUFJLE9BQU8sRUFBRTtBQUNULDJDQUFHLENBQUMsS0FBSyx5QkFBdUIsQ0FBQyxrQkFBYSxJQUFJLENBQUMsR0FBRyxDQUFHLENBQUM7QUFDMUQsK0NBQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztxQ0FDckI7aUNBQ0o7Ozs7Ozs7Ozs7Ozs7Ozt5QkFDSjtxQkFDSjtpQkFDSjthQUNKOztBQWtCTSxhQUFLOzs7Ozs7O21CQUFDLGVBQUMsSUFBSSxFQUFFLElBQUksRUFBRTtBQUN0QixvQkFBSSxJQUFJLEdBQUcsQ0FDUCxLQUFLLEVBQ0wsU0FBUyxFQUNULFFBQVEsRUFDUixZQUFZLEVBQ1osT0FBTyxFQUNQLE9BQU8sQ0FDVixDQUFDO0FBQ0Ysb0JBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUNyQix3QkFBSSxDQUFDLElBQUksTUFBQSxDQUFULElBQUkscUJBQVMsSUFBSSxFQUFDLENBQUM7aUJBQ3RCOzs7QUFHRCxvQkFBSSxXQUFXLEdBQUcsRUFBRSxDQUFDOzs7Ozs7QUFDckIseUNBQWdCLElBQUk7NEJBQVgsR0FBRzs7QUFDUixtQ0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztxQkFDaEM7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFRCx1QkFBTyxXQUFXLENBQUM7YUFDdEI7O0FBT00sY0FBTTs7Ozs7Ozs7bUJBQUEsZ0JBQUMsSUFBSSxFQUFFO0FBQ2hCLG9CQUFJLElBQUksRUFBRTtBQUNOLHdCQUFJLElBQUksQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUU7QUFDOUMsNEJBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO3FCQUNwQztBQUNELHdCQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUN6QjthQUNKOzs7O1dBaFlnQixJQUFJOzs7aUJBQUosSUFBSTs7Ozs7OztJQ1RsQixJQUFJLDJCQUFNLFFBQVE7O0lBQ2xCLEtBQUssMkJBQU0sZUFBZTs7SUFFMUIsR0FBRywyQkFBTSxVQUFVOztBQUUxQixJQUFJLFdBQVcsQ0FBQzs7aUJBRUQsV0FBVyxHQUFHOztBQUV6QixRQUFJLEVBQUEsY0FBQyxLQUFLLEVBQUU7QUFDUixZQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUNuQixZQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUNoQixZQUFJLENBQUMsY0FBYyxHQUFHLEVBQUUsQ0FBQztBQUN6QixZQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQztBQUN4QixZQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQztLQUM5Qjs7QUFFRCxXQUFPLEVBQUEsbUJBQUc7QUFDTixZQUFJLENBQUMsV0FBVyxDQUFDLFVBQUEsSUFBSTttQkFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1NBQUEsQ0FBQyxDQUFDO0FBQ3pDLFlBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO0FBQ2hCLFlBQUksQ0FBQyxjQUFjLEdBQUcsRUFBRSxDQUFDO0FBQ3pCLFlBQUksQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDO0FBQ3hCLFlBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0tBQ3JCOztBQUVELFlBQVEsRUFBQSxrQkFBQyxJQUFJLEVBQUU7QUFDWCxZQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUM7S0FDL0I7O0FBRUQsV0FBTyxFQUFBLGlCQUFDLEdBQUcsRUFBRTtBQUNULGVBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxTQUFTLENBQUM7S0FDeEM7O0FBRUQsY0FBVSxFQUFBLG9CQUFDLEdBQUcsRUFBRTtBQUNaLGVBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN2QixZQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQzNCOzs7QUFHRCxjQUFVLEVBQUEsb0JBQUMsR0FBRyxFQUFFO0FBQ1osV0FBRyxDQUFDLEtBQUssc0JBQW9CLEdBQUcsQ0FBRyxDQUFDOztBQUVwQyxZQUFJLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDOztBQUUzQixZQUFJLElBQUksSUFBSSxJQUFJLEVBQUU7QUFDZCxnQkFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1NBQ2xCOztBQUVELFlBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzFCLFlBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxFQUFFLENBQUM7S0FDOUI7OztBQUdELGVBQVcsRUFBQSxxQkFBQyxJQUFJLEVBQUU7QUFDZCxhQUFLLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7QUFDdEIsZ0JBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdkI7S0FDSjs7O0FBR0QsZUFBVyxFQUFBLHFCQUFDLE1BQU0sRUFBRTtBQUNoQixZQUFJLFlBQVksR0FBRyxFQUFFLENBQUM7QUFDdEIsYUFBSyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO0FBQ3RCLGdCQUFJLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLGdCQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUNkLDRCQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3hCO1NBQ0o7QUFDRCxhQUFLLElBQUksQ0FBQyxHQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN4QyxnQkFBSSxHQUFHLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzFCLGdCQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3hCO0tBQ0o7O0FBRUQsc0JBQWtCLEVBQUEsOEJBQUc7Ozs7QUFFakIsWUFBSSxDQUFDLGNBQWMsR0FBRyxFQUFFLENBQUM7QUFDekIsWUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQywwQkFBMEIsRUFBRSxDQUFDOzs7Ozs7QUFDMUQsaUNBQW1CLFdBQVc7b0JBQXJCLE1BQU07O0FBQ1gsb0JBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDN0Isb0JBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQzthQUN2RDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHRCxZQUFJLENBQUMsS0FBSyxDQUFDLDJCQUEyQixFQUFFLENBQUM7O0FBRXpDLFlBQUksQ0FBQyxXQUFXLENBQUMsVUFBQSxJQUFJLEVBQUk7QUFDckIsa0JBQUssZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDNUIsZ0JBQUksQ0FBQyxNQUFNLENBQUMsTUFBSyxLQUFLLENBQUMsQ0FBQztTQUMzQixDQUFDLENBQUM7S0FDTjs7QUFFRCxvQkFBZ0IsRUFBQSwwQkFBQyxJQUFJLEVBQUU7QUFDbkIsWUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFO0FBQzFDLGdCQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztBQUNyQixtQkFBTztTQUNWOztBQUVELFlBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUU7QUFDckMsZ0JBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1NBQ3ZCLE1BQ0k7O0FBRUQsaUJBQUssSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtBQUNqQyxvQkFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO0FBQ3JELHdCQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztBQUNwQiwyQkFBTztpQkFDVjthQUNKOztBQUVELGdCQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztTQUN4QjtLQUNKOztBQUVELHNCQUFrQixFQUFBLDhCQUFHO0FBQ2pCLFlBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUNmLGFBQUssSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtBQUN0QixnQkFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN6QixnQkFBSSxJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFDN0IscUJBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDcEI7U0FDSjtBQUNELGVBQU8sS0FBSyxDQUFDO0tBQ2hCOzs7QUFHRCxtQkFBZSxFQUFBLHlCQUFDLE1BQU0sRUFBRTtBQUNwQixZQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDO0tBQzFEOzs7QUFHRCx5QkFBcUIsRUFBQSxpQ0FBRzs7O0FBQ3BCLFlBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO0FBQ2pDLG1CQUFPO1NBQ1Y7OztBQUdELFlBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFVBQUMsQ0FBQyxFQUFFLENBQUMsRUFBSztBQUM5QixnQkFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFLLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQUssS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzdGLGdCQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQUssS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBSyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDN0YsbUJBQVEsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBSSxFQUFFLEtBQUssRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUc7U0FDL0MsQ0FBQyxDQUFDO0FBQ0gsWUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsVUFBQSxNQUFNO21CQUFJLE1BQUssY0FBYyxDQUFDLE1BQU0sQ0FBQztTQUFBLENBQUMsQ0FBQztBQUNsRSxZQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQztLQUMzQjs7O0FBR0Qsa0JBQWMsRUFBQSx3QkFBQyxNQUFNLEVBQUU7O0FBRW5CLFlBQUksTUFBTSxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQUU7QUFDdkMsbUJBQU87U0FDVjs7Ozs7Ozs7QUFHRCxpQ0FBbUIsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQztvQkFBMUMsTUFBTTs7QUFDWCxvQkFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUU7QUFDZiw2QkFBUztpQkFDWjs7QUFFRCxvQkFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDekQsb0JBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFO0FBQ3BCLHdCQUFJLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO0FBQ25CLDhCQUFNLEVBQU4sTUFBTTtBQUNOLDhCQUFNLEVBQU4sTUFBTTs7QUFFTiw4QkFBTSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFO0FBQy9CLGtDQUFVLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUFBLHFCQUM3QyxDQUFDLENBQUM7O0FBRUgsd0JBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDcEIsd0JBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ3hCO2FBQ0o7Ozs7Ozs7Ozs7Ozs7OztLQUNKOzs7QUFHRCxjQUFVLEVBQUEsb0JBQUMsS0FBSyxFQUFFOzs7QUFDZCxZQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFBLElBQUk7bUJBQUksTUFBSyxTQUFTLENBQUMsSUFBSSxDQUFDO1NBQUEsQ0FBQyxDQUFDO0FBQ3ZELFlBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztLQUMxQjs7QUFFRCxhQUFTLEVBQUEsbUJBQUMsSUFBSSxFQUFFOzs7QUFDWixZQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUM5QixZQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDNUIsWUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDeEIsWUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUM1QixJQUFJLENBQUMsVUFBQSxPQUFPO21CQUFJLE1BQUssa0JBQWtCLENBQUMsT0FBTyxDQUFDO1NBQUEsQ0FBQyxTQUM1QyxDQUFDLFlBQU07QUFDVCxrQkFBSyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzFCLGdCQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3pCLENBQUMsQ0FBQztLQUNWOzs7QUFHRCxzQkFBa0IsRUFBQSxrQ0FBVztZQUFSLElBQUksUUFBSixJQUFJOzs7QUFFckIsWUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJLEVBQUU7QUFDOUIsZUFBRyxDQUFDLEtBQUsscUJBQW1CLElBQUksQ0FBQyxHQUFHLG1FQUFnRSxDQUFDO0FBQ3JHLGdCQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3pCOzthQUVJLElBQUksSUFBSSxDQUFDLFVBQVUsS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRTtBQUNoRCxlQUFHLENBQUMsS0FBSyxDQUFDLG9CQUFrQixJQUFJLENBQUMsR0FBRyxxRkFDWixJQUFJLENBQUMsVUFBVSxrQkFBYSxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBRSxDQUFDLENBQUM7QUFDN0UsZ0JBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzFCLGdCQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3pCLE1BQ0k7O0FBRUQsZ0JBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDdEIsb0JBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDM0M7O0FBRUQsZ0JBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUM1QixnQkFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDeEIsZ0JBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNwQyxnQkFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLEVBQUUsQ0FBQztTQUM5Qjs7QUFFRCxZQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUNoQzs7O0FBR0Qsa0JBQWMsRUFBQSx3QkFBQyxHQUFHLEVBQUU7QUFDaEIsWUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsY0FBYyxJQUFJLEVBQUUsQ0FBQztBQUNoRCxZQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQztBQUNoQyxXQUFHLENBQUMsS0FBSyx5QkFBdUIsR0FBRyxVQUFLLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLE1BQU0sQ0FBRyxDQUFDO0tBQ3RGOztBQUVELGlCQUFhLEVBQUEsdUJBQUMsR0FBRyxFQUFFOztBQUVmLFlBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtBQUNyQixlQUFHLENBQUMsS0FBSyx3QkFBc0IsR0FBRyxVQUFLLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLE1BQU0sQ0FBRyxDQUFDO0FBQ2xGLG1CQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDaEMsZ0JBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztTQUMxQjtLQUNKOzs7QUFHRCxtQkFBZSxFQUFBLDJCQUFHO0FBQ2QsWUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtBQUN2RSxnQkFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7QUFDM0IsZ0JBQUksQ0FBQyxLQUFLLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztTQUNyQztLQUNKOzs7QUFHRCxlQUFXLEVBQUEscUJBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRTtBQUN0QixZQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7QUFDWixhQUFLLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7QUFDdEIsZ0JBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxLQUFLLE9BQU8sTUFBTSxLQUFLLFVBQVUsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQSxFQUFHO0FBQ3ZHLG1CQUFHLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDcEM7U0FDSjtBQUNELGVBQU8sR0FBRyxDQUFDO0tBQ2Q7OztBQUdELG1CQUFlLEVBQUEseUJBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRTtBQUMxQixlQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sQ0FBQztLQUMxRTs7Q0FFSjs7Ozs7Ozs7Ozs7Ozs7O0lDcFFZLG9CQUFvQixXQUFwQixvQkFBb0I7QUFDbEIsYUFERixvQkFBb0IsQ0FDakIsVUFBVSxFQUFFOzhCQURmLG9CQUFvQjs7QUFFekIsbUNBRkssb0JBQW9CLDZDQUVqQjtBQUNSLFlBQUksQ0FBQyxJQUFJLEdBQU0sc0JBQXNCLENBQUM7QUFDdEMsWUFBSSxDQUFDLE9BQU8sR0FBRyxTQUFTLEdBQUcsVUFBVSxHQUFHLGtDQUFrQyxDQUFDO0tBQzlFOztjQUxRLG9CQUFvQjs7V0FBcEIsb0JBQW9CO0dBQVMsS0FBSzs7Ozs7Ozs7Ozs7SUNGeEMsTUFBTSwyQkFBTSxXQUFXOztJQUVULEdBQUc7QUFFUixhQUZLLEdBQUcsQ0FFUCxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFOzhCQUZYLEdBQUc7O0FBR2hCLFlBQUksQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDeEIsWUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDZixZQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ3ZCLFlBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ2YsWUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7O0FBRWYsWUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0tBQ2pCOztpQkFWZ0IsR0FBRztBQVlwQixZQUFJO21CQUFDLGNBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUNiLG9CQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDOztBQUV6QixvQkFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO2FBQ2Q7O0FBRUQsaUJBQVM7bUJBQUMscUJBQUc7QUFDWixvQkFBSSxHQUFHLEdBQUcsT0FBRyxDQUFDO0FBQ2Qsb0JBQUksSUFBSSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDOztBQUVsQyxxQkFBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRTtBQUNyQix3QkFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM3Qyx3QkFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM3Qyx3QkFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM3Qyx3QkFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDbkQ7O0FBRUQsdUJBQU8sSUFBSSxDQUFDO2FBQ1o7O0FBRUQsZ0JBQVE7bUJBQUMsb0JBQUc7QUFDWCxvQkFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN4RSxvQkFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUN4RTs7QUFFRCxjQUFNO21CQUFDLGtCQUFHO0FBQ1Qsb0JBQUksQ0FBQyxHQUFHLENBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUN0RCxvQkFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7O0FBRXRELGlCQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFHLENBQUMsQ0FBQztBQUM1QyxpQkFBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBRyxDQUFDLENBQUM7O0FBRTVDLG9CQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQzNELG9CQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQzNELG9CQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQzNELG9CQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDOztBQUUzRCxvQkFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO2FBQ2hCOzs7QUFFTSxxQkFBYTttQkFBQyx1QkFBQyxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQ2hDLG9CQUFJLEdBQUcsR0FBRyxPQUFHLENBQUM7QUFDZCxvQkFBSSxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQ2Qsb0JBQUksR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDOztBQUVmLG9CQUFJLElBQUksR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDOzs7QUFHcEIscUJBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUU7QUFDckIsd0JBQUksQ0FBQyxHQUFJLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ25DLHVCQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDdkIsdUJBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztpQkFDN0I7O0FBRUQsdUJBQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7YUFDbEI7O0FBRU0sbUJBQVc7bUJBQUMscUJBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUU7QUFDdkMscUJBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUU7QUFDM0Isd0JBQUksTUFBTSxHQUFHLEdBQUcsQ0FBQyxhQUFhLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQy9DLHdCQUFJLE1BQU0sR0FBRyxHQUFHLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7QUFFL0Msd0JBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFO0FBQ25ELCtCQUFPLEtBQUssQ0FBQztxQkFDYjtpQkFDRDtBQUNELHVCQUFPLElBQUksQ0FBQzthQUNaOztBQUVNLGlCQUFTO21CQUFBLG1CQUFDLEtBQUssRUFBRSxLQUFLLEVBQUU7QUFDOUIsdUJBQU8sR0FBRyxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQzlGOzs7O1dBbkZnQixHQUFHOzs7aUJBQUgsR0FBRzs7Ozs7aUJDRkEsY0FBYzs7QUFBdkIsU0FBUyxjQUFjLENBQUUsTUFBTSxFQUFFOztBQUU1QyxRQUFJLFNBQVMsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDOzs7QUFHMUIsV0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRTs7QUFFekIsaUJBQVMsRUFBQSxtQkFBQyxRQUFRLEVBQUU7QUFDaEIscUJBQVMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7O1NBRTNCOztBQUVELG1CQUFXLEVBQUEscUJBQUMsUUFBUSxFQUFFO0FBQ2xCLHFCQUFTLFVBQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQzs7Ozs7U0FLOUI7O0FBRUQsc0JBQWMsRUFBQSwwQkFBRztBQUNiLHFCQUFTLENBQUMsS0FBSyxFQUFFLENBQUM7O1NBRXJCOztBQUVELGVBQU8sRUFBQSxpQkFBQyxLQUFLLEVBQVc7OENBQU4sSUFBSTtBQUFKLG9CQUFJOzs7Ozs7OztBQUNsQixxQ0FBcUIsU0FBUzt3QkFBckIsUUFBUTs7QUFDYix3QkFBSSxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxVQUFVLEVBQUU7QUFDdkMsZ0NBQVEsQ0FBQyxLQUFLLE9BQUMsQ0FBZixRQUFRLEVBQVcsSUFBSSxDQUFDLENBQUM7cUJBQzVCO2lCQUNKOzs7Ozs7Ozs7Ozs7Ozs7U0FDSjs7S0FFSixDQUFDLENBQUM7Q0FFTjs7Ozs7Ozs7OztJQ2hDTSxHQUFHLDJCQUFNLFVBQVU7O0lBQ25CLElBQUksMkJBQU0sU0FBUzs7SUFDbkIsR0FBRywyQkFBTSxRQUFROztBQUV4QixJQUFJLEtBQUssQ0FBQztpQkFDSyxLQUFLLEdBQUcsRUFBRTs7Ozs7QUFLekIsS0FBSyxDQUFDLFVBQVUsR0FBRyxVQUFVLEdBQUcsRUFBRSxJQUFJLEVBQUU7QUFDcEMsUUFBSSxDQUFDLEdBQUcsRUFBRTtBQUNOLGVBQU87S0FDVjs7O0FBR0QsUUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUU7QUFDM0IsV0FBRyxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsUUFBUSxHQUFHLEdBQUcsQ0FBQztLQUN4Qzs7U0FFSSxJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUMsMEJBQTBCLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDakQsWUFBSSxRQUFRLEdBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBRTtBQUNoQyxZQUFJLFNBQVMsQ0FBQztBQUNkLFlBQUksSUFBSSxFQUFFO0FBQ04scUJBQVMsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3hDLHFCQUFTLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztTQUN6QixNQUNJO0FBQ0QscUJBQVMsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDO1NBQy9COztBQUVELFlBQUksUUFBUSxFQUFFO0FBQ1YsZ0JBQUksSUFBSSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQzVDLGdCQUFJLEdBQUcsSUFBSyxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDaEQsZUFBRyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUM7U0FDcEIsTUFDSTs7QUFFRCxnQkFBSSxTQUFTLENBQUMsTUFBTSxFQUFFO0FBQ2xCLG1CQUFHLEdBQUcsU0FBUyxDQUFDLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDO2FBQ3RDOztpQkFFSTtBQUNELG9CQUFJLE1BQU0sR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLHdDQUF3QyxDQUFDLENBQUM7QUFDakUsc0JBQU0sR0FBRyxNQUFPLElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUN4RCxtQkFBRyxHQUFHLE1BQU0sR0FBRyxHQUFHLENBQUM7YUFDdEI7U0FDSjtLQUNKO0FBQ0QsV0FBTyxHQUFHLENBQUM7Q0FDZCxDQUFDOztBQUVGLEtBQUssQ0FBQyxVQUFVLEdBQUcsVUFBVSxHQUFHLEVBQUU7QUFDOUIsUUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO0FBQ3BDLGVBQU8sR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztLQUNsRDtBQUNELFdBQU8sRUFBRSxDQUFDO0NBQ2IsQ0FBQzs7QUFFRixLQUFLLENBQUMsaUJBQWlCLEdBQUcsVUFBVSxHQUFHLEVBQUU7QUFDckMsUUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO0FBQ2xDLGVBQU8sR0FBRyxDQUFDO0tBQ2Q7QUFDRCxXQUFPLEdBQUcsR0FBRyxHQUFHLEdBQUksQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFFO0NBQ3BDLENBQUM7OztBQUdGLEtBQUssQ0FBQyxnQkFBZ0IsR0FBRyxTQUFTLENBQUM7QUFDbkMsS0FBSyxDQUFDLGVBQWUsR0FBRyxVQUFVLEdBQUcsRUFBRTtBQUNuQyxRQUFJLEtBQUssQ0FBQyxnQkFBZ0IsS0FBSyxTQUFTLEVBQUU7QUFDdEMsYUFBSyxDQUFDLGdCQUFnQixHQUFHLE1BQU8sQ0FBQyxHQUFHLElBQUksTUFBTSxDQUFDLEdBQUcsQ0FBQyxlQUFlLElBQU0sTUFBTSxDQUFDLFNBQVMsSUFBSSxNQUFNLENBQUMsU0FBUyxDQUFDLGVBQWUsQ0FBRTs7QUFFOUgsWUFBSSxPQUFPLEtBQUssQ0FBQyxnQkFBZ0IsS0FBSyxVQUFVLEVBQUU7QUFDOUMsaUJBQUssQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7QUFDOUIsZUFBRyxDQUFDLElBQUksNkZBQTZGLENBQUM7U0FDekc7S0FDSjs7QUFFRCxRQUFJLEtBQUssQ0FBQyxnQkFBZ0IsRUFBRTtBQUN4QixlQUFPLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUN0QyxNQUNJO0FBQ0QsZUFBTyxHQUFHLENBQUM7S0FDZDtDQUNKLENBQUM7O0FBRUYsS0FBSyxDQUFDLEVBQUUsR0FBRyxVQUFVLEdBQUcsRUFBd0U7UUFBdEUsT0FBTyxnQ0FBRyxLQUFLO1FBQUUsWUFBWSxnQ0FBRyxNQUFNO1FBQUUsTUFBTSxnQ0FBRyxLQUFLO1FBQUUsT0FBTyxnQ0FBRyxFQUFFOztBQUMxRixRQUFJLE9BQU8sR0FBRyxJQUFJLGNBQWMsRUFBRSxDQUFDO0FBQ25DLFFBQUksT0FBTyxHQUFHLElBQUksT0FBTyxDQUFDLFVBQUMsT0FBTyxFQUFFLE1BQU0sRUFBSztBQUMzQyxlQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDaEMsZUFBTyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7QUFDMUIsZUFBTyxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7QUFDcEMsZUFBTyxDQUFDLE1BQU0sR0FBRyxZQUFNO0FBQ25CLGdCQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssR0FBRyxFQUFFO0FBQ3hCLG9CQUFJLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7QUFDckQsMkJBQU8sQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7aUJBQ2pDLE1BQ0k7QUFDRCwyQkFBTyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztpQkFDN0I7YUFDSixNQUFNO0FBQ0gsc0JBQU0sQ0FBQyxLQUFLLENBQUMsaUNBQWlDLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7YUFDekU7U0FDSixDQUFDO0FBQ0YsZUFBTyxDQUFDLE9BQU8sR0FBRyxVQUFDLEdBQUcsRUFBSztBQUN2QixrQkFBTSxDQUFDLEtBQUssQ0FBQywyQkFBMkIsR0FBRyxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQy9ELENBQUM7QUFDRixlQUFPLENBQUMsU0FBUyxHQUFHLFVBQUMsR0FBRyxFQUFLO0FBQ3pCLGtCQUFNLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRSxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQzdDLENBQUM7QUFDRixlQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7S0FDbEIsQ0FBQyxDQUFDOztBQUVILFVBQU0sQ0FBQyxjQUFjLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRTtBQUN0QyxhQUFLLEVBQUUsT0FBTztLQUNqQixDQUFDLENBQUM7O0FBRUgsV0FBTyxPQUFPLENBQUM7Q0FDbEIsQ0FBQzs7QUFFRixLQUFLLENBQUMsYUFBYSxHQUFHLFVBQVUsSUFBSSxFQUFFO0FBQ2xDLFFBQUksSUFBSSxDQUFDO0FBQ1QsUUFBSTtBQUNBLFlBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQzlCLENBQUMsT0FBTyxDQUFDLEVBQUU7QUFDUixjQUFNLENBQUMsQ0FBQztLQUNYO0FBQ0QsV0FBTyxJQUFJLENBQUM7Q0FDZixDQUFDOztBQUVGLEtBQUssQ0FBQyxZQUFZLEdBQUcsVUFBVSxNQUFNLEVBQUU7QUFDbkMsV0FBTyxJQUFJLE9BQU8sQ0FBQyxVQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUs7QUFDcEMsWUFBSSxPQUFPLE1BQU0sS0FBSyxRQUFRLEVBQUU7QUFDNUIsaUJBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQUMsSUFBSSxFQUFLO0FBQ3JELG9CQUFJO0FBQ0Esd0JBQUksSUFBSSxHQUFHLEtBQUssQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDckMsMkJBQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDakIsQ0FDRCxPQUFNLENBQUMsRUFBRTtBQUNMLDBCQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQ2I7YUFDSixFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ2QsTUFBTTtBQUNILG1CQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDbkI7S0FDSixDQUFDLENBQUM7Q0FDTixDQUFDOzs7QUFHRixLQUFLLENBQUMsNkJBQTZCLEdBQUcsWUFBWTtBQUM5QyxRQUFJLE9BQU8sTUFBTSxDQUFDLHFCQUFxQixLQUFLLFVBQVUsRUFBRTtBQUNwRCxjQUFNLENBQUMscUJBQXFCLEdBQ3hCLE1BQU0sQ0FBQywyQkFBMkIsSUFDbEMsTUFBTSxDQUFDLHdCQUF3QixJQUMvQixNQUFNLENBQUMsc0JBQXNCLElBQzdCLE1BQU0sQ0FBQyx1QkFBdUIsSUFDOUIsVUFBVSxFQUFFLEVBQUU7QUFDVixzQkFBVSxDQUFDLEVBQUUsRUFBRSxJQUFJLEdBQUUsRUFBRSxDQUFDLENBQUM7U0FDNUIsQ0FBQztLQUNUO0NBQ0osQ0FBQzs7O0FBR0YsS0FBSyxDQUFDLHNCQUFzQixHQUFHLFVBQVUsR0FBRyxFQUFFO0FBQzFDLFFBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLFVBQVMsQ0FBQyxFQUFFLENBQUMsRUFBRTs7QUFFaEQsWUFBSSxPQUFPLENBQUMsS0FBSyxVQUFVLEVBQUU7QUFDekIsbUJBQU8sQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO1NBQ3ZCO0FBQ0QsZUFBTyxDQUFDLENBQUM7S0FDWixDQUFDLENBQUM7O0FBRUgsV0FBTyxVQUFVLENBQUM7Q0FDckIsQ0FBQzs7O0FBR0YsS0FBSyxDQUFDLHdCQUF3QixHQUFHLFVBQVMsVUFBVSxFQUFFLElBQUksRUFBRTtBQUN4RCxRQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ2pDLE9BQUcsR0FBRyxLQUFLLENBQUMsa0JBQWtCLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQzFDLFdBQU8sR0FBRyxDQUFDO0NBQ2QsQ0FBQzs7O0FBR0YsS0FBSyxDQUFDLGtCQUFrQixHQUFHLFVBQVMsR0FBRyxFQUFFLElBQUksRUFBRTs7QUFFM0MsUUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7QUFDekIsV0FBRyxHQUFHLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDM0M7O1NBRUksSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7QUFDOUIsYUFBSyxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUU7QUFDZixlQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUNuRDtLQUNKO0FBQ0QsV0FBTyxHQUFHLENBQUM7Q0FDZCxDQUFDOzs7O0FBSUYsS0FBSyxDQUFDLGdCQUFnQixHQUFHLFVBQVMsR0FBRyxFQUFFLElBQUksRUFBRTs7QUFFekMsUUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLGlEQUFpRCxDQUFDLElBQUksSUFBSSxFQUFFO0FBQ3RFLFlBQUksQ0FBQyxDQUFDO0FBQ04sWUFBSTtBQUNBLGdCQUFJLE9BQU8sSUFBSSxLQUFLLFVBQVUsRUFBRTtBQUM1QixvQkFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzthQUM1QixNQUNJO0FBQ0Qsb0JBQUksQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUM7YUFDdEI7QUFDRCxtQkFBTyxDQUFDLENBQUM7U0FDWixDQUNELE9BQU8sQ0FBQyxFQUFFOztBQUVOLG1CQUFPLEdBQUcsQ0FBQztTQUNkO0tBQ0o7QUFDRCxXQUFPLEdBQUcsQ0FBQztDQUNkLENBQUM7OztBQUdGLEtBQUssQ0FBQyxHQUFHLEdBQUcsVUFBVSxLQUFLLEVBQVU7c0NBQUwsR0FBRztBQUFILFdBQUc7OztBQUMvQixTQUFLLEdBQUcsS0FBSyxJQUFJLE1BQU0sQ0FBQztBQUN4QixRQUFJLEtBQUssQ0FBQyxjQUFjLEVBQUU7QUFDdEIsWUFBSSxDQUFDLFdBQVcsQ0FBQztBQUNiLGdCQUFJLEVBQUUsS0FBSztBQUNYLGlCQUFLLEVBQUUsS0FBSztBQUNaLHFCQUFTLEVBQUUsSUFBSSxDQUFDLFVBQVU7QUFDMUIsZUFBRyxFQUFFLEdBQUc7U0FDWCxDQUFDLENBQUM7S0FDTixNQUNJLElBQUksT0FBTyxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssVUFBVSxFQUFFO0FBQ3ZDLFdBQUcsQ0FBQyxLQUFLLE9BQUMsQ0FBVixHQUFHLEVBQVcsR0FBRyxDQUFDLENBQUM7S0FDdEI7Q0FDSixDQUFDOzs7QUFHRixLQUFLLENBQUMsd0JBQXdCLEdBQUcsSUFBSSxDQUFDO0FBQ3RDLEtBQUssQ0FBQyxzQkFBc0IsR0FBRyxZQUFZO0FBQ3ZDLFNBQUssQ0FBQyxrQkFBa0IsR0FBRyxLQUFNLENBQUMsd0JBQXdCLElBQUksTUFBTSxDQUFDLGdCQUFnQixJQUFLLENBQUMsQ0FBQztDQUMvRixDQUFDOzs7QUFHRixDQUFDLFlBQVc7QUFDUixRQUFJO0FBQ0EsWUFBSSxNQUFNLENBQUMsUUFBUSxLQUFLLFNBQVMsRUFBRTtBQUMvQixpQkFBSyxDQUFDLGNBQWMsR0FBRyxLQUFLLENBQUM7QUFDN0IsaUJBQUssQ0FBQyxZQUFZLEdBQUssSUFBSSxDQUFDO0FBQzVCLGlCQUFLLENBQUMsc0JBQXNCLEVBQUUsQ0FBQztTQUNsQztLQUNKLENBQ0QsT0FBTyxDQUFDLEVBQUU7QUFDTixZQUFJLElBQUksS0FBSyxTQUFTLEVBQUU7QUFDcEIsaUJBQUssQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDO0FBQzVCLGlCQUFLLENBQUMsWUFBWSxHQUFLLEtBQUssQ0FBQztTQUNoQztLQUNKO0NBQ0osQ0FBQSxFQUFHLENBQUM7Ozs7O0FBS0wsS0FBSyxDQUFDLGNBQWMsR0FBRyxZQUFvQjtzQ0FBUCxLQUFLO0FBQUwsYUFBSzs7OztBQUVyQyxRQUFJLE1BQU0sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDO0FBQ3BDLFFBQUksTUFBTSxFQUFFO0FBQ1IsZUFBTyxNQUFNLENBQUMsR0FBRyxDQUFDO0tBQ3JCLE1BQ0ksSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFOztBQUUzQixZQUFJLE9BQU8sR0FBRyxRQUFRLENBQUMsb0JBQW9CLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDdEQsYUFBSyxJQUFJLENBQUMsR0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Ozs7OztBQUNuQyxxQ0FBaUIsS0FBSzt3QkFBYixJQUFJOztBQUNULHdCQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO0FBQ3BDLCtCQUFPLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7cUJBQ3hCO2lCQUNKOzs7Ozs7Ozs7Ozs7Ozs7U0FDSjtLQUNKO0NBQ0osQ0FBQzs7OztBQUlGLEtBQUssQ0FBQyxVQUFVLEdBQUcsVUFBUyxLQUFLLEVBQUU7QUFDL0IsV0FBTyxDQUFDLEtBQUssR0FBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEtBQU0sQ0FBQyxDQUFDO0NBQ3RDLENBQUM7O0FBRUYsS0FBSyxDQUFDLFlBQVksR0FBRyxVQUFTLEtBQUssRUFBRTtBQUNqQyxXQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDbkQsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztBQWdCRixLQUFLLENBQUMsV0FBVyxHQUFHLFVBQVMsQ0FBQyxFQUFFLE1BQU0sRUFBRTs7QUFFcEMsUUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO0FBQ3JELGVBQU8sTUFBTSxDQUFDO0tBQ2pCLE1BQ0ksSUFBSSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtBQUN4QixlQUFPLE1BQU0sQ0FBQztLQUNqQjs7QUFFRCxRQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQzs7O0FBR2pCLFFBQUksQ0FBQyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtBQUNuQixTQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3BCOztTQUVJLElBQUksQ0FBQyxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO0FBQ3RDLFNBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNsQzs7U0FFSTtBQUNELGFBQUssSUFBSSxDQUFDLEdBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN0QyxnQkFBSSxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFOztBQUV6QyxrQkFBRSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsQixrQkFBRSxHQUFHLE1BQU0sQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7OztBQUdwQixvQkFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO0FBQzdCLHFCQUFDLEdBQUcsRUFBRSxDQUFDO0FBQ1AseUJBQUssSUFBSSxDQUFDLEdBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3hDLHlCQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDeEMseUJBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQSxJQUFLLEVBQUUsR0FBRyxFQUFFLENBQUEsR0FBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7cUJBQ3JEO2lCQUNKOztxQkFFSTtBQUNELHFCQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbEMscUJBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQSxJQUFLLEVBQUUsR0FBRyxFQUFFLENBQUEsR0FBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQy9DO0FBQ0Qsc0JBQU07YUFDVDtTQUNKO0tBQ0o7QUFDRCxXQUFPLENBQUMsQ0FBQztDQUNaLENBQUM7Ozs7O0FBS0YsS0FBSyxDQUFDLE9BQU8sMkJBQUcsb0JBQVcsR0FBRzt3RkFDakIsR0FBRzs7Ozs7Ozs7OzRCQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDOzs7Ozs7OztBQUF2QixtQkFBRzs7dUJBQ0YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBRTVCLENBQUEsQ0FBQzs7O0FBR0YsS0FBSyxDQUFDLE1BQU0sMkJBQUcsb0JBQVcsR0FBRzt3RkFDaEIsR0FBRzs7Ozs7Ozs7OzRCQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDOzs7Ozs7OztBQUF2QixtQkFBRzs7dUJBQ0YsR0FBRyxDQUFDLEdBQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQUVyQixDQUFBLENBQUM7Ozs7QUFJRixLQUFLLENBQUMsY0FBYywyQkFBRyxvQkFBVyxHQUFHO3dGQUl4QixHQUFHOzs7OztvQkFIUCxHQUFHOzs7Ozs7Ozs7Ozs7NEJBR1EsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7Ozs7Ozs7O0FBQXZCLG1CQUFHOztxQkFDSixHQUFHLENBQUMsR0FBRyxDQUFDOzs7Ozs7dUJBQ0YsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQzs7O3NCQUN0QixPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxRQUFRLENBQUE7Ozs7O2lEQUNyQixLQUFLLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQUlwRCxDQUFBLENBQUM7O0FBRUYsS0FBSyxDQUFDLGFBQWEsMkJBQUcsb0JBQVcsR0FBRzt3RkFJdkIsR0FBRzs7Ozs7b0JBSFAsR0FBRzs7Ozs7Ozs7Ozs7OzRCQUdRLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDOzs7Ozs7OztBQUF2QixtQkFBRzs7cUJBQ0osR0FBRyxDQUFDLEdBQUcsQ0FBQzs7Ozs7O3VCQUNGLEdBQUcsQ0FBQyxHQUFHLENBQUM7OztzQkFDVixPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxRQUFRLENBQUE7Ozs7O2lEQUNyQixLQUFLLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQUluRCxDQUFBLENBQUM7Ozs7O0FBS0YsS0FBSyxDQUFDLFVBQVUsR0FBRyxVQUFVLEdBQUcsRUFBRSxJQUFJLEVBQUU7QUFDcEMsV0FBTyxHQUFJLEdBQUcsSUFBSSxHQUFJLEtBQUssQ0FBQztDQUMvQixDQUFDOztBQUVGLEtBQUssQ0FBQyxRQUFRLEdBQUcsVUFBVSxPQUFPLEVBQUU7QUFDaEMsV0FBTyxPQUFPLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUM7Q0FDbEMsQ0FBQzs7QUFFRixLQUFLLENBQUMsUUFBUSxHQUFHLFVBQVUsT0FBTyxFQUFFO0FBQ2hDLFdBQU8sT0FBTyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDO0NBQ2xDLENBQUM7O0FBRUYsS0FBSyxDQUFDLGFBQWEsR0FBRyxVQUFVLEtBQUssRUFBRTtBQUNuQyxXQUFPLE1BQU0sR0FBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUksR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztDQUM1SCxDQUFDOztBQUVGLEtBQUssQ0FBQyxXQUFXLEdBQUcsVUFBVSxJQUFJLEVBQUUsSUFBSSxFQUFFO0FBQ3RDLFFBQUksSUFBSSxLQUFLLElBQUksRUFBRTtBQUNmLGVBQU8sSUFBSSxDQUFDO0tBQ2YsTUFBTSxJQUFJLElBQUksS0FBSyxJQUFJLEVBQUU7QUFDdEIsZUFBTyxFQUFFLEdBQUcsSUFBSSxDQUFDO0tBQ3BCLE1BQU0sSUFBSSxJQUFJLEtBQUssSUFBSSxFQUFFO0FBQ3RCLGVBQU8sSUFBSSxHQUFHLElBQUksQ0FBQztLQUN0QixNQUFNLElBQUksSUFBSSxLQUFLLEdBQUcsRUFBRTtBQUNyQixlQUFPLElBQUksR0FBRyxJQUFJLENBQUM7S0FDdEI7Q0FDSixDQUFDOztBQUVGLEtBQUssQ0FBQyxXQUFXLEdBQUcsVUFBVSxLQUFLLEVBQUU7QUFDakMsV0FBTyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxVQUFVLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxVQUFVLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztDQUNsRyxDQUFDOztBQUVGLEtBQUssQ0FBQyxlQUFlLEdBQUcsVUFBVSxJQUFJLEVBQUU7QUFDcEMsV0FBTyxJQUFJLEdBQUcsR0FBRyxDQUFDLGVBQWUsQ0FBQztDQUNyQyxDQUFDOzs7OztBQ3RiRixJQUFJLE9BQU8sQ0FBQztpQkFDRyxPQUFPLEdBQUc7QUFDckIsVUFBTSxFQUFFLFFBQVE7QUFDaEIsU0FBSyxFQUFFLENBQUM7QUFDUixTQUFLLEVBQUUsQ0FBQztBQUNSLFNBQUssRUFBRSxDQUFDO0FBQ1IsT0FBRyxFQUFFLEtBQUs7Q0FDYjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDc0RNLEtBQUssMkJBQU0sU0FBUzs7QUFFM0IsSUFBSSxZQUFZLENBQUM7aUJBQ0YsWUFBWSxHQUFHLEVBQUU7Ozs7QUFJaEMsSUFBSSxVQUFVLEdBQUcsQ0FBQyxDQUFDO0FBQ25CLElBQUksUUFBUSxHQUFHLEVBQUUsQ0FBQzs7Ozs7QUFLbEIsU0FBUyxlQUFlLEdBQUk7Ozs7Ozs7Ozs7QUFVeEIsZ0JBQVksQ0FBQyxXQUFXLEdBQUcsVUFBVSxNQUFNLEVBQUUsTUFBTSxFQUFjOzBDQUFULE9BQU87QUFBUCxtQkFBTzs7OztBQUUzRCxZQUFJLE9BQU8sR0FBRyxJQUFJLE9BQU8sQ0FBQyxVQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUs7QUFDM0Msb0JBQVEsQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLE1BQU0sRUFBTixNQUFNLEVBQUUsT0FBTyxFQUFQLE9BQU8sRUFBRSxPQUFPLEVBQVAsT0FBTyxFQUFFLE1BQU0sRUFBTixNQUFNLEVBQUUsQ0FBQztTQUMvRCxDQUFDLENBQUM7O0FBRUgsY0FBTSxDQUFDLFdBQVcsQ0FBQztBQUNmLGdCQUFJLEVBQUUsV0FBVztBQUNqQixzQkFBVSxFQUFWLFVBQVU7QUFDVixrQkFBTSxFQUFOLE1BQU07QUFDTixtQkFBTyxFQUFQLE9BQU87QUFBQSxTQUNWLENBQUMsQ0FBQzs7QUFFSCxrQkFBVSxFQUFFLENBQUM7QUFDYixlQUFPLE9BQU8sQ0FBQztLQUNsQixDQUFDOzs7QUFHRixRQUFJLFNBQVMsR0FBRyxDQUFDLENBQUM7QUFDbEIsUUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDOztBQUVqQixnQkFBWSxDQUFDLFNBQVMsR0FBRyxVQUFVLE1BQU0sRUFBRTs7Ozs7QUFLdkMsY0FBTSxDQUFDLGlCQUFpQixHQUFHLFNBQVMsRUFBRSxDQUFDO0FBQ3ZDLGVBQU8sQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsR0FBRyxNQUFNLENBQUM7OztBQUczQyxjQUFNLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLFVBQUMsS0FBSyxFQUFLO0FBQzFDLGdCQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLGNBQWMsRUFBRTtBQUNwQyx1QkFBTzthQUNWOzs7QUFHRCxnQkFBSSxFQUFFLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7QUFDL0IsZ0JBQUksUUFBUSxDQUFDLEVBQUUsQ0FBQyxFQUFFO0FBQ2Qsb0JBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUU7QUFDbEIsNEJBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztpQkFDekMsTUFDSTtBQUNELDRCQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7aUJBQzVDO0FBQ0QsdUJBQU8sUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQ3ZCO1NBQ0osQ0FBQyxDQUFDOzs7O0FBSUgsY0FBTSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxVQUFDLEtBQUssRUFBSzs7QUFFMUMsZ0JBQUksRUFBRSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO0FBQy9CLGdCQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLGFBQWEsSUFBSSxFQUFFLElBQUksSUFBSSxFQUFFO0FBQ2pELHVCQUFPO2FBQ1Y7OztBQUdELGdCQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN4QyxnQkFBSSxDQUFDLE1BQU0sRUFBRTtBQUNULHNCQUFNLEtBQUssb0RBQWtELEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxtQkFBYyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sb0VBQWlFLENBQUM7YUFDbEw7O0FBRUQsZ0JBQUksTUFBTSxHQUFHLE9BQVEsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssVUFBVSxJQUFLLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQzVGLGdCQUFJLENBQUMsTUFBTSxFQUFFO0FBQ1Qsc0JBQU0sS0FBSyxvREFBa0QsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLG1CQUFjLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxrREFBK0MsQ0FBQzthQUNoSzs7QUFFRCxnQkFBSSxNQUFNLEVBQUUsS0FBSyxDQUFDO0FBQ2xCLGdCQUFJO0FBQ0Esc0JBQU0sR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2FBQ3JELENBQ0QsT0FBTSxDQUFDLEVBQUU7O0FBRUwscUJBQUssR0FBRyxDQUFDLENBQUM7YUFDYjs7OztBQUlELGdCQUFJLE1BQU0sWUFBWSxPQUFPLEVBQUU7QUFDM0Isc0JBQU0sQ0FBQyxJQUFJLENBQUMsVUFBQyxLQUFLLEVBQUs7QUFDbkIsMEJBQU0sQ0FBQyxXQUFXLENBQUM7QUFDZiw0QkFBSSxFQUFFLFlBQVk7QUFDbEIsa0NBQVUsRUFBRSxFQUFFO0FBQ2QsK0JBQU8sRUFBRSxLQUFLO3FCQUNqQixDQUFDLENBQUM7aUJBQ04sRUFBRSxVQUFDLEtBQUssRUFBSztBQUNWLDBCQUFNLENBQUMsV0FBVyxDQUFDO0FBQ2YsNEJBQUksRUFBRSxZQUFZO0FBQ2xCLGtDQUFVLEVBQUUsRUFBRTtBQUNkLDZCQUFLLEVBQUcsS0FBSyxZQUFZLEtBQUssUUFBTSxLQUFLLENBQUMsT0FBTyxVQUFLLEtBQUssQ0FBQyxLQUFLLEdBQUssS0FBSztxQkFDOUUsQ0FBQyxDQUFDO2lCQUNOLENBQUMsQ0FBQzthQUNOOztpQkFFSTtBQUNELHNCQUFNLENBQUMsV0FBVyxDQUFDO0FBQ2Ysd0JBQUksRUFBRSxZQUFZO0FBQ2xCLDhCQUFVLEVBQUUsRUFBRTtBQUNkLDJCQUFPLEVBQUUsTUFBTTtBQUNmLHlCQUFLLEVBQUcsS0FBSyxZQUFZLEtBQUssUUFBTSxLQUFLLENBQUMsT0FBTyxVQUFLLEtBQUssQ0FBQyxLQUFLLEdBQUssS0FBSztpQkFDOUUsQ0FBQyxDQUFDO2FBQ047U0FDSixDQUFDLENBQUM7S0FFTixDQUFDOzs7QUFHRixRQUFJLE9BQU8sR0FBRyxFQUFFLENBQUM7QUFDakIsZ0JBQVksQ0FBQyxTQUFTLEdBQUcsVUFBVSxJQUFJLEVBQUUsTUFBTSxFQUFFO0FBQzdDLGVBQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUM7S0FDMUIsQ0FBQzs7O0FBR0YsZ0JBQVksQ0FBQyxXQUFXLEdBQUcsWUFBWTtBQUNuQyxlQUFPLFFBQVEsQ0FBQztLQUNuQixDQUFDOztBQUVGLGdCQUFZLENBQUMsWUFBWSxHQUFHLFlBQVk7QUFDcEMsZUFBTyxVQUFVLENBQUM7S0FDckIsQ0FBQztDQUVMOzs7OztBQUtELFNBQVMsaUJBQWlCLEdBQUk7Ozs7Ozs7Ozs7QUFVMUIsZ0JBQVksQ0FBQyxXQUFXLEdBQUcsVUFBVSxNQUFNLEVBQUUsTUFBTSxFQUFjOzBDQUFULE9BQU87QUFBUCxtQkFBTzs7OztBQUUzRCxZQUFJLE9BQU8sR0FBRyxJQUFJLE9BQU8sQ0FBQyxVQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUs7QUFDM0Msb0JBQVEsQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLE1BQU0sRUFBTixNQUFNLEVBQUUsTUFBTSxFQUFOLE1BQU0sRUFBRSxPQUFPLEVBQVAsT0FBTyxFQUFFLE9BQU8sRUFBUCxPQUFPLEVBQUUsTUFBTSxFQUFOLE1BQU0sRUFBRSxDQUFDO1NBQ3ZFLENBQUMsQ0FBQzs7QUFFSCxZQUFJLENBQUMsV0FBVyxDQUFDO0FBQ2IsZ0JBQUksRUFBRSxhQUFhO0FBQ25CLHNCQUFVLEVBQVYsVUFBVTtBQUNWLGtCQUFNLEVBQU4sTUFBTTtBQUNOLGtCQUFNLEVBQU4sTUFBTTtBQUNOLG1CQUFPLEVBQVAsT0FBTztBQUFBLFNBQ1YsQ0FBQyxDQUFDOztBQUVILGtCQUFVLEVBQUUsQ0FBQztBQUNiLGVBQU8sT0FBTyxDQUFDO0tBQ2xCLENBQUM7OztBQUdGLFFBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsVUFBQyxLQUFLLEVBQUs7QUFDeEMsWUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxZQUFZLEVBQUU7QUFDbEMsbUJBQU87U0FDVjs7O0FBR0QsWUFBSSxFQUFFLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7QUFDL0IsWUFBSSxRQUFRLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDZCxnQkFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRTtBQUNsQix3QkFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ3pDLE1BQ0k7QUFDRCx3QkFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2FBQzVDO0FBQ0QsbUJBQU8sUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ3ZCO0tBQ0osQ0FBQyxDQUFDOzs7QUFHSCxRQUFJLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLFVBQUMsS0FBSyxFQUFLOztBQUV4QyxZQUFJLEVBQUUsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztBQUMvQixZQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLFdBQVcsSUFBSSxFQUFFLElBQUksSUFBSSxFQUFFO0FBQy9DLG1CQUFPO1NBQ1Y7OztBQUdELFlBQUksV0FBVyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO0FBQ3BDLFlBQUksTUFBTSxHQUFHLE9BQVEsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLFVBQVUsSUFBSyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDNUUsWUFBSSxDQUFDLE1BQU0sRUFBRTtBQUNULGtCQUFNLEtBQUssb0RBQWtELFdBQVcsa0RBQStDLENBQUM7U0FDM0g7O0FBRUQsWUFBSSxNQUFNLEVBQUUsS0FBSyxDQUFDO0FBQ2xCLFlBQUk7QUFDQSxrQkFBTSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDbkQsQ0FDRCxPQUFNLENBQUMsRUFBRTs7QUFFTCxpQkFBSyxHQUFHLENBQUMsQ0FBQztTQUNiOzs7QUFHRCxZQUFJLGFBQWEsWUFBQSxDQUFDOztBQUVsQixZQUFJLE1BQU0sWUFBWSxPQUFPLEVBQUU7QUFDM0Isa0JBQU0sQ0FBQyxJQUFJLENBQUMsVUFBQyxLQUFLLEVBQUs7QUFDbkIsNkJBQWEsR0FBRyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7QUFFekMsb0JBQUksQ0FBQyxXQUFXLENBQUM7QUFDYix3QkFBSSxFQUFFLGNBQWM7QUFDcEIsOEJBQVUsRUFBRSxFQUFFO0FBQ2QsMkJBQU8sRUFBRSxLQUFLO2lCQUNqQixFQUFFLGFBQWEsQ0FBQyxDQUFDOztBQUVsQixvQkFBSSxhQUFhLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtBQUMxQix5QkFBSyxDQUFDLEdBQUcsQ0FBQyxPQUFPLFFBQU0sV0FBVyxzQkFBaUIsYUFBYSxDQUFDLE1BQU0sNkJBQTBCLENBQUM7aUJBQ3JHO2FBQ0osRUFBRSxVQUFDLEtBQUssRUFBSztBQUNWLG9CQUFJLENBQUMsV0FBVyxDQUFDO0FBQ2Isd0JBQUksRUFBRSxjQUFjO0FBQ3BCLDhCQUFVLEVBQUUsRUFBRTtBQUNkLHlCQUFLLEVBQUcsS0FBSyxZQUFZLEtBQUssUUFBTSxLQUFLLENBQUMsT0FBTyxVQUFLLEtBQUssQ0FBQyxLQUFLLEdBQUssS0FBSztpQkFDOUUsQ0FBQyxDQUFDO2FBQ04sQ0FBQyxDQUFDO1NBQ047O2FBRUk7QUFDRCx5QkFBYSxHQUFHLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDOztBQUUxQyxnQkFBSSxDQUFDLFdBQVcsQ0FBQztBQUNiLG9CQUFJLEVBQUUsY0FBYztBQUNwQiwwQkFBVSxFQUFFLEVBQUU7QUFDZCx1QkFBTyxFQUFFLE1BQU07QUFDZixxQkFBSyxFQUFHLEtBQUssWUFBWSxLQUFLLFFBQU0sS0FBSyxDQUFDLE9BQU8sVUFBSyxLQUFLLENBQUMsS0FBSyxHQUFLLEtBQUs7YUFDOUUsRUFBRSxhQUFhLENBQUMsQ0FBQzs7QUFFbEIsZ0JBQUksYUFBYSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7QUFDMUIscUJBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxRQUFNLFdBQVcsc0JBQWlCLGFBQWEsQ0FBQyxNQUFNLDZCQUEwQixDQUFDO2FBQ3JHO1NBQ0o7S0FDSixDQUFDLENBQUM7Q0FFTjs7OztBQUlELFNBQVMsaUJBQWlCLENBQUMsTUFBTSxFQUFhO1FBQVgsSUFBSSxnQ0FBRyxFQUFFOztBQUN4QyxRQUFJLENBQUMsTUFBTSxFQUFFO0FBQ1IsZUFBTyxJQUFJLENBQUM7S0FDaEI7O0FBRUQsUUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFOztBQUV2QixjQUFNLENBQUMsT0FBTyxDQUFDLFVBQUEsQ0FBQzttQkFBSSxpQkFBaUIsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDO1NBQUEsQ0FBQyxDQUFDO0tBQ25ELE1BQ0ksSUFBSSxPQUFPLE1BQU0sS0FBSyxRQUFRLEVBQUU7O0FBRWpDLFlBQUksTUFBTSxZQUFZLFdBQVcsRUFBRTtBQUMvQixnQkFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNyQjs7YUFFSSxJQUFJLE1BQU0sQ0FBQyxNQUFNLFlBQVksV0FBVyxFQUFFO0FBQzNDLGdCQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUM1Qjs7YUFFSTtBQUNELGlCQUFLLElBQUksQ0FBQyxJQUFJLE1BQU0sRUFBRTtBQUNsQixpQ0FBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7YUFDdEM7U0FDSjtLQUNKO0FBQ0QsV0FBTyxJQUFJLENBQUM7Q0FDZjs7O0FBR0QsSUFBSSxLQUFLLENBQUMsWUFBWSxFQUFFO0FBQ3BCLG1CQUFlLEVBQUUsQ0FBQztDQUNyQjs7QUFFRCxJQUFJLEtBQUssQ0FBQyxjQUFjLEVBQUU7QUFDdEIscUJBQWlCLEVBQUUsQ0FBQztDQUN2Qjs7Ozs7Ozs7O0FDeFdELElBQUksTUFBTSxDQUFDO2lCQUNJLE1BQU0sR0FBRyxFQUFFOztBQUUxQixNQUFNLENBQUMsR0FBRyxHQUFHLFVBQVUsQ0FBQyxFQUFFO0FBQ3RCLFFBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNYLFFBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDbkIsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUMxQixTQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ2Y7QUFDRCxXQUFPLENBQUMsQ0FBQztDQUNaLENBQUM7O0FBRUYsTUFBTSxDQUFDLEdBQUcsR0FBRyxVQUFVLENBQUMsRUFBRTtBQUN0QixRQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDWCxRQUFJLEdBQUcsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQ25CLFNBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDMUIsU0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztLQUNwQjtBQUNELFdBQU8sQ0FBQyxDQUFDO0NBQ1osQ0FBQzs7O0FBR0YsTUFBTSxDQUFDLEdBQUcsR0FBRyxVQUFVLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDM0IsUUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0FBQ1gsUUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN4QyxTQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzFCLFNBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3hCO0FBQ0QsV0FBTyxDQUFDLENBQUM7Q0FDWixDQUFDOzs7QUFHRixNQUFNLENBQUMsR0FBRyxHQUFHLFVBQVUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUMzQixRQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDWCxRQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDOztBQUV4QyxTQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzFCLFNBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3hCO0FBQ0QsV0FBTyxDQUFDLENBQUM7Q0FDWixDQUFDOztBQUVGLE1BQU0sQ0FBQyxXQUFXLEdBQUcsVUFBVSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUN2QyxXQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQSxJQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUEsR0FBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUEsSUFBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFBLENBQUU7Q0FDcEUsQ0FBQzs7O0FBR0YsTUFBTSxDQUFDLElBQUksR0FBRyxVQUFVLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDNUIsUUFBSSxDQUFDLEdBQUcsRUFBRTtRQUNOLEdBQUcsR0FBRyxFQUFFLENBQUMsTUFBTTtRQUNmLENBQUMsQ0FBQzs7QUFFTixRQUFJLE9BQU8sRUFBRSxLQUFLLFFBQVEsRUFBRTs7QUFFeEIsYUFBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDdEIsYUFBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDckI7S0FDSixNQUNJOztBQUVELFdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3BDLGFBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3RCLGFBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3hCO0tBQ0o7QUFDRCxXQUFPLENBQUMsQ0FBQztDQUNaLENBQUM7OztBQUdGLE1BQU0sQ0FBQyxHQUFHLEdBQUcsVUFBVSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQzNCLFFBQUksQ0FBQyxHQUFHLEVBQUU7UUFDTixDQUFDLENBQUM7QUFDTixRQUFHLE9BQU8sRUFBRSxLQUFLLFFBQVEsRUFBQzs7QUFFdEIsYUFBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFDO0FBQzNCLGFBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1NBQ3JCO0tBQ0osTUFBTTs7QUFFSCxZQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3hDLGFBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3RCLGFBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3hCO0tBQ0o7QUFDRCxXQUFPLENBQUMsQ0FBQztDQUNaLENBQUM7OztBQUdGLE1BQU0sQ0FBQyxJQUFJLEdBQUcsVUFBVSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQzVCLFdBQU8sQ0FBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUNiLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUUsQ0FBQztDQUM1QixDQUFDOzs7QUFHRixNQUFNLENBQUMsR0FBRyxHQUFHLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUN6QixRQUFJLEVBQUUsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzFCLFFBQUksRUFBRSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDekIsV0FBTyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFDbkIsRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDaEMsQ0FBQzs7O0FBR0YsTUFBTSxDQUFDLEtBQUssR0FBRyxnQkFBa0I7OztRQUFQLENBQUM7UUFBRSxDQUFDOztBQUMxQixXQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDO0NBQzFCLENBQUM7OztBQUdGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsVUFBVSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQy9CLFFBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUM7QUFDcEIsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUMxQixZQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUM7QUFDaEIsbUJBQU8sS0FBSyxDQUFDO1NBQ2hCO0tBQ0o7QUFDRCxXQUFPLElBQUksQ0FBQztDQUNmLENBQUM7OztBQUdGLE1BQU0sQ0FBQyxRQUFRLEdBQUcsVUFBVSxDQUFDLEVBQzdCO0FBQ0ksUUFBSSxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtBQUNoQixlQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBRTtLQUNsQyxNQUNJO0FBQ0QsZUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBRTtLQUM5QztDQUNKLENBQUM7OztBQUdGLE1BQU0sQ0FBQyxNQUFNLEdBQUcsVUFBVSxDQUFDLEVBQzNCO0FBQ0ksV0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUN4QyxDQUFDOzs7QUFHRixNQUFNLENBQUMsU0FBUyxHQUFHLFVBQVUsQ0FBQyxFQUM5QjtBQUNJLFFBQUksQ0FBQyxDQUFDO0FBQ04sUUFBSSxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtBQUNoQixTQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzFCLFNBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDOztBQUVqQixZQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDVCxtQkFBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQy9CO0FBQ0QsZUFBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztLQUNqQixNQUFNO0FBQ0gsU0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FB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QixFQUFFO0FBQ3RDLGVBQU8sQ0FDSCxDQUFDLEVBQUcsR0FBRyxFQUFFLEdBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFJLEtBQUssRUFDL0IsQ0FBQyxFQUFHLEdBQUcsRUFBRSxHQUFLLEVBQUUsR0FBRyxFQUFFLENBQUMsR0FBSSxLQUFLLENBQ2xDLENBQUM7S0FDTDtBQUNELFdBQU8sSUFBSSxDQUFDO0NBQ2YsQ0FBQzs7O0FDek1GO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmIChnbG9iYWwuX2JhYmVsUG9seWZpbGwpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwib25seSBvbmUgaW5zdGFuY2Ugb2YgYmFiZWwvcG9seWZpbGwgaXMgYWxsb3dlZFwiKTtcbn1cbmdsb2JhbC5fYmFiZWxQb2x5ZmlsbCA9IHRydWU7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL3NoaW1cIik7XG5cbnJlcXVpcmUoXCJyZWdlbmVyYXRvci1iYWJlbC9ydW50aW1lXCIpO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5aVlXSmxiQzlzYVdJdlltRmlaV3d2Y0c5c2VXWnBiR3d1YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJJaXdpWm1sc1pTSTZJbWRsYm1WeVlYUmxaQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dWFXWWdLR2RzYjJKaGJDNWZZbUZpWld4UWIyeDVabWxzYkNrZ2UxeHVJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9YQ0p2Ym14NUlHOXVaU0JwYm5OMFlXNWpaU0J2WmlCaVlXSmxiQzl3YjJ4NVptbHNiQ0JwY3lCaGJHeHZkMlZrWENJcE8xeHVmVnh1WjJ4dlltRnNMbDlpWVdKbGJGQnZiSGxtYVd4c0lEMGdkSEoxWlR0Y2JseHVjbVZ4ZFdseVpTaGNJbU52Y21VdGFuTXZjMmhwYlZ3aUtUdGNibHh1Y21WeGRXbHlaU2hjSW5KbFoyVnVaWEpoZEc5eUxXSmhZbVZzTDNKMWJuUnBiV1ZjSWlrN0lsMTkiLCIvKipcbiAqIENvcmUuanMgMC42LjFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzXG4gKiBMaWNlbnNlOiBodHRwOi8vcm9jay5taXQtbGljZW5zZS5vcmdcbiAqIMKpIDIwMTUgRGVuaXMgUHVzaGthcmV2XG4gKi9cbiFmdW5jdGlvbihnbG9iYWwsIGZyYW1ld29yaywgdW5kZWZpbmVkKXtcbid1c2Ugc3RyaWN0JztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogY29tbW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvLyBTaG9ydGN1dHMgZm9yIFtbQ2xhc3NdXSAmIHByb3BlcnR5IG5hbWVzXHJcbnZhciBPQkpFQ1QgICAgICAgICAgPSAnT2JqZWN0J1xyXG4gICwgRlVOQ1RJT04gICAgICAgID0gJ0Z1bmN0aW9uJ1xyXG4gICwgQVJSQVkgICAgICAgICAgID0gJ0FycmF5J1xyXG4gICwgU1RSSU5HICAgICAgICAgID0gJ1N0cmluZydcclxuICAsIE5VTUJFUiAgICAgICAgICA9ICdOdW1iZXInXHJcbiAgLCBSRUdFWFAgICAgICAgICAgPSAnUmVnRXhwJ1xyXG4gICwgREFURSAgICAgICAgICAgID0gJ0RhdGUnXHJcbiAgLCBNQVAgICAgICAgICAgICAgPSAnTWFwJ1xyXG4gICwgU0VUICAgICAgICAgICAgID0gJ1NldCdcclxuICAsIFdFQUtNQVAgICAgICAgICA9ICdXZWFrTWFwJ1xyXG4gICwgV0VBS1NFVCAgICAgICAgID0gJ1dlYWtTZXQnXHJcbiAgLCBTWU1CT0wgICAgICAgICAgPSAnU3ltYm9sJ1xyXG4gICwgUFJPTUlTRSAgICAgICAgID0gJ1Byb21pc2UnXHJcbiAgLCBNQVRIICAgICAgICAgICAgPSAnTWF0aCdcclxuICAsIEFSR1VNRU5UUyAgICAgICA9ICdBcmd1bWVudHMnXHJcbiAgLCBQUk9UT1RZUEUgICAgICAgPSAncHJvdG90eXBlJ1xyXG4gICwgQ09OU1RSVUNUT1IgICAgID0gJ2NvbnN0cnVjdG9yJ1xyXG4gICwgVE9fU1RSSU5HICAgICAgID0gJ3RvU3RyaW5nJ1xyXG4gICwgVE9fU1RSSU5HX1RBRyAgID0gVE9fU1RSSU5HICsgJ1RhZydcclxuICAsIFRPX0xPQ0FMRSAgICAgICA9ICd0b0xvY2FsZVN0cmluZydcclxuICAsIEhBU19PV04gICAgICAgICA9ICdoYXNPd25Qcm9wZXJ0eSdcclxuICAsIEZPUl9FQUNIICAgICAgICA9ICdmb3JFYWNoJ1xyXG4gICwgSVRFUkFUT1IgICAgICAgID0gJ2l0ZXJhdG9yJ1xyXG4gICwgRkZfSVRFUkFUT1IgICAgID0gJ0BAJyArIElURVJBVE9SXHJcbiAgLCBQUk9DRVNTICAgICAgICAgPSAncHJvY2VzcydcclxuICAsIENSRUFURV9FTEVNRU5UICA9ICdjcmVhdGVFbGVtZW50J1xyXG4gIC8vIEFsaWFzZXMgZ2xvYmFsIG9iamVjdHMgYW5kIHByb3RvdHlwZXNcclxuICAsIEZ1bmN0aW9uICAgICAgICA9IGdsb2JhbFtGVU5DVElPTl1cclxuICAsIE9iamVjdCAgICAgICAgICA9IGdsb2JhbFtPQkpFQ1RdXHJcbiAgLCBBcnJheSAgICAgICAgICAgPSBnbG9iYWxbQVJSQVldXHJcbiAgLCBTdHJpbmcgICAgICAgICAgPSBnbG9iYWxbU1RSSU5HXVxyXG4gICwgTnVtYmVyICAgICAgICAgID0gZ2xvYmFsW05VTUJFUl1cclxuICAsIFJlZ0V4cCAgICAgICAgICA9IGdsb2JhbFtSRUdFWFBdXHJcbiAgLCBEYXRlICAgICAgICAgICAgPSBnbG9iYWxbREFURV1cclxuICAsIE1hcCAgICAgICAgICAgICA9IGdsb2JhbFtNQVBdXHJcbiAgLCBTZXQgICAgICAgICAgICAgPSBnbG9iYWxbU0VUXVxyXG4gICwgV2Vha01hcCAgICAgICAgID0gZ2xvYmFsW1dFQUtNQVBdXHJcbiAgLCBXZWFrU2V0ICAgICAgICAgPSBnbG9iYWxbV0VBS1NFVF1cclxuICAsIFN5bWJvbCAgICAgICAgICA9IGdsb2JhbFtTWU1CT0xdXHJcbiAgLCBNYXRoICAgICAgICAgICAgPSBnbG9iYWxbTUFUSF1cclxuICAsIFR5cGVFcnJvciAgICAgICA9IGdsb2JhbC5UeXBlRXJyb3JcclxuICAsIFJhbmdlRXJyb3IgICAgICA9IGdsb2JhbC5SYW5nZUVycm9yXHJcbiAgLCBzZXRUaW1lb3V0ICAgICAgPSBnbG9iYWwuc2V0VGltZW91dFxyXG4gICwgc2V0SW1tZWRpYXRlICAgID0gZ2xvYmFsLnNldEltbWVkaWF0ZVxyXG4gICwgY2xlYXJJbW1lZGlhdGUgID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlXHJcbiAgLCBwYXJzZUludCAgICAgICAgPSBnbG9iYWwucGFyc2VJbnRcclxuICAsIGlzRmluaXRlICAgICAgICA9IGdsb2JhbC5pc0Zpbml0ZVxyXG4gICwgcHJvY2VzcyAgICAgICAgID0gZ2xvYmFsW1BST0NFU1NdXHJcbiAgLCBuZXh0VGljayAgICAgICAgPSBwcm9jZXNzICYmIHByb2Nlc3MubmV4dFRpY2tcclxuICAsIGRvY3VtZW50ICAgICAgICA9IGdsb2JhbC5kb2N1bWVudFxyXG4gICwgaHRtbCAgICAgICAgICAgID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XHJcbiAgLCBuYXZpZ2F0b3IgICAgICAgPSBnbG9iYWwubmF2aWdhdG9yXHJcbiAgLCBkZWZpbmUgICAgICAgICAgPSBnbG9iYWwuZGVmaW5lXHJcbiAgLCBjb25zb2xlICAgICAgICAgPSBnbG9iYWwuY29uc29sZSB8fCB7fVxyXG4gICwgQXJyYXlQcm90byAgICAgID0gQXJyYXlbUFJPVE9UWVBFXVxyXG4gICwgT2JqZWN0UHJvdG8gICAgID0gT2JqZWN0W1BST1RPVFlQRV1cclxuICAsIEZ1bmN0aW9uUHJvdG8gICA9IEZ1bmN0aW9uW1BST1RPVFlQRV1cclxuICAsIEluZmluaXR5ICAgICAgICA9IDEgLyAwXHJcbiAgLCBET1QgICAgICAgICAgICAgPSAnLic7XHJcblxyXG4vLyBodHRwOi8vanNwZXJmLmNvbS9jb3JlLWpzLWlzb2JqZWN0XHJcbmZ1bmN0aW9uIGlzT2JqZWN0KGl0KXtcclxuICByZXR1cm4gaXQgIT09IG51bGwgJiYgKHR5cGVvZiBpdCA9PSAnb2JqZWN0JyB8fCB0eXBlb2YgaXQgPT0gJ2Z1bmN0aW9uJyk7XHJcbn1cclxuZnVuY3Rpb24gaXNGdW5jdGlvbihpdCl7XHJcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnZnVuY3Rpb24nO1xyXG59XHJcbi8vIE5hdGl2ZSBmdW5jdGlvbj9cclxudmFyIGlzTmF0aXZlID0gY3R4KC8uLy50ZXN0LCAvXFxbbmF0aXZlIGNvZGVcXF1cXHMqXFx9XFxzKiQvLCAxKTtcclxuXHJcbi8vIE9iamVjdCBpbnRlcm5hbCBbW0NsYXNzXV0gb3IgdG9TdHJpbmdUYWdcclxuLy8gaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xyXG52YXIgdG9TdHJpbmcgPSBPYmplY3RQcm90b1tUT19TVFJJTkddO1xyXG5mdW5jdGlvbiBzZXRUb1N0cmluZ1RhZyhpdCwgdGFnLCBzdGF0KXtcclxuICBpZihpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXRbUFJPVE9UWVBFXSwgU1lNQk9MX1RBRykpaGlkZGVuKGl0LCBTWU1CT0xfVEFHLCB0YWcpO1xyXG59XHJcbmZ1bmN0aW9uIGNvZihpdCl7XHJcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcclxufVxyXG5mdW5jdGlvbiBjbGFzc29mKGl0KXtcclxuICB2YXIgTywgVDtcclxuICByZXR1cm4gaXQgPT0gdW5kZWZpbmVkID8gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogJ051bGwnXHJcbiAgICA6IHR5cGVvZiAoVCA9IChPID0gT2JqZWN0KGl0KSlbU1lNQk9MX1RBR10pID09ICdzdHJpbmcnID8gVCA6IGNvZihPKTtcclxufVxyXG5cclxuLy8gRnVuY3Rpb25cclxudmFyIGNhbGwgID0gRnVuY3Rpb25Qcm90by5jYWxsXHJcbiAgLCBhcHBseSA9IEZ1bmN0aW9uUHJvdG8uYXBwbHlcclxuICAsIFJFRkVSRU5DRV9HRVQ7XHJcbi8vIFBhcnRpYWwgYXBwbHlcclxuZnVuY3Rpb24gcGFydCgvKiAuLi5hcmdzICovKXtcclxuICB2YXIgZm4gICAgID0gYXNzZXJ0RnVuY3Rpb24odGhpcylcclxuICAgICwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgLCBhcmdzICAgPSBBcnJheShsZW5ndGgpXHJcbiAgICAsIGkgICAgICA9IDBcclxuICAgICwgXyAgICAgID0gcGF0aC5fXHJcbiAgICAsIGhvbGRlciA9IGZhbHNlO1xyXG4gIHdoaWxlKGxlbmd0aCA+IGkpaWYoKGFyZ3NbaV0gPSBhcmd1bWVudHNbaSsrXSkgPT09IF8paG9sZGVyID0gdHJ1ZTtcclxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XHJcbiAgICB2YXIgdGhhdCAgICA9IHRoaXNcclxuICAgICAgLCBfbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgICAsIGkgPSAwLCBqID0gMCwgX2FyZ3M7XHJcbiAgICBpZighaG9sZGVyICYmICFfbGVuZ3RoKXJldHVybiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xyXG4gICAgX2FyZ3MgPSBhcmdzLnNsaWNlKCk7XHJcbiAgICBpZihob2xkZXIpZm9yKDtsZW5ndGggPiBpOyBpKyspaWYoX2FyZ3NbaV0gPT09IF8pX2FyZ3NbaV0gPSBhcmd1bWVudHNbaisrXTtcclxuICAgIHdoaWxlKF9sZW5ndGggPiBqKV9hcmdzLnB1c2goYXJndW1lbnRzW2orK10pO1xyXG4gICAgcmV0dXJuIGludm9rZShmbiwgX2FyZ3MsIHRoYXQpO1xyXG4gIH1cclxufVxyXG4vLyBPcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcclxuZnVuY3Rpb24gY3R4KGZuLCB0aGF0LCBsZW5ndGgpe1xyXG4gIGFzc2VydEZ1bmN0aW9uKGZuKTtcclxuICBpZih+bGVuZ3RoICYmIHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XHJcbiAgc3dpdGNoKGxlbmd0aCl7XHJcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcclxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XHJcbiAgICB9XHJcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcclxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XHJcbiAgICB9XHJcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcclxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XHJcbiAgICB9XHJcbiAgfSByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XHJcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xyXG4gIH1cclxufVxyXG4vLyBGYXN0IGFwcGx5XHJcbi8vIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxyXG5mdW5jdGlvbiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpe1xyXG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcclxuICBzd2l0Y2goYXJncy5sZW5ndGggfCAwKXtcclxuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxyXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xyXG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xyXG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xyXG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xyXG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xyXG4gICAgY2FzZSA1OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0pO1xyXG4gIH0gcmV0dXJuICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcclxufVxyXG5cclxuLy8gT2JqZWN0OlxyXG52YXIgY3JlYXRlICAgICAgICAgICA9IE9iamVjdC5jcmVhdGVcclxuICAsIGdldFByb3RvdHlwZU9mICAgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcclxuICAsIHNldFByb3RvdHlwZU9mICAgPSBPYmplY3Quc2V0UHJvdG90eXBlT2ZcclxuICAsIGRlZmluZVByb3BlcnR5ICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcclxuICAsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xyXG4gICwgZ2V0T3duRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcclxuICAsIGdldEtleXMgICAgICAgICAgPSBPYmplY3Qua2V5c1xyXG4gICwgZ2V0TmFtZXMgICAgICAgICA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXHJcbiAgLCBnZXRTeW1ib2xzICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc1xyXG4gICwgaXNGcm96ZW4gICAgICAgICA9IE9iamVjdC5pc0Zyb3plblxyXG4gICwgaGFzICAgICAgICAgICAgICA9IGN0eChjYWxsLCBPYmplY3RQcm90b1tIQVNfT1dOXSwgMilcclxuICAvLyBEdW1teSwgZml4IGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5nIGluIGVzNSBtb2R1bGVcclxuICAsIEVTNU9iamVjdCAgICAgICAgPSBPYmplY3RcclxuICAsIERpY3Q7XHJcbmZ1bmN0aW9uIHRvT2JqZWN0KGl0KXtcclxuICByZXR1cm4gRVM1T2JqZWN0KGFzc2VydERlZmluZWQoaXQpKTtcclxufVxyXG5mdW5jdGlvbiByZXR1cm5JdChpdCl7XHJcbiAgcmV0dXJuIGl0O1xyXG59XHJcbmZ1bmN0aW9uIHJldHVyblRoaXMoKXtcclxuICByZXR1cm4gdGhpcztcclxufVxyXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBrZXkpe1xyXG4gIGlmKGhhcyhvYmplY3QsIGtleSkpcmV0dXJuIG9iamVjdFtrZXldO1xyXG59XHJcbmZ1bmN0aW9uIG93bktleXMoaXQpe1xyXG4gIGFzc2VydE9iamVjdChpdCk7XHJcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBnZXROYW1lcyhpdCkuY29uY2F0KGdldFN5bWJvbHMoaXQpKSA6IGdldE5hbWVzKGl0KTtcclxufVxyXG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXHJcbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCwgc291cmNlKXtcclxuICB2YXIgVCA9IE9iamVjdChhc3NlcnREZWZpbmVkKHRhcmdldCkpXHJcbiAgICAsIGwgPSBhcmd1bWVudHMubGVuZ3RoXHJcbiAgICAsIGkgPSAxO1xyXG4gIHdoaWxlKGwgPiBpKXtcclxuICAgIHZhciBTICAgICAgPSBFUzVPYmplY3QoYXJndW1lbnRzW2krK10pXHJcbiAgICAgICwga2V5cyAgID0gZ2V0S2V5cyhTKVxyXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXHJcbiAgICAgICwgaiAgICAgID0gMFxyXG4gICAgICAsIGtleTtcclxuICAgIHdoaWxlKGxlbmd0aCA+IGopVFtrZXkgPSBrZXlzW2orK11dID0gU1trZXldO1xyXG4gIH1cclxuICByZXR1cm4gVDtcclxufVxyXG5mdW5jdGlvbiBrZXlPZihvYmplY3QsIGVsKXtcclxuICB2YXIgTyAgICAgID0gdG9PYmplY3Qob2JqZWN0KVxyXG4gICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXHJcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXHJcbiAgICAsIGluZGV4ICA9IDBcclxuICAgICwga2V5O1xyXG4gIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XHJcbn1cclxuXHJcbi8vIEFycmF5XHJcbi8vIGFycmF5KCdzdHIxLHN0cjIsc3RyMycpID0+IFsnc3RyMScsICdzdHIyJywgJ3N0cjMnXVxyXG5mdW5jdGlvbiBhcnJheShpdCl7XHJcbiAgcmV0dXJuIFN0cmluZyhpdCkuc3BsaXQoJywnKTtcclxufVxyXG52YXIgcHVzaCAgICA9IEFycmF5UHJvdG8ucHVzaFxyXG4gICwgdW5zaGlmdCA9IEFycmF5UHJvdG8udW5zaGlmdFxyXG4gICwgc2xpY2UgICA9IEFycmF5UHJvdG8uc2xpY2VcclxuICAsIHNwbGljZSAgPSBBcnJheVByb3RvLnNwbGljZVxyXG4gICwgaW5kZXhPZiA9IEFycmF5UHJvdG8uaW5kZXhPZlxyXG4gICwgZm9yRWFjaCA9IEFycmF5UHJvdG9bRk9SX0VBQ0hdO1xyXG4vKlxyXG4gKiAwIC0+IGZvckVhY2hcclxuICogMSAtPiBtYXBcclxuICogMiAtPiBmaWx0ZXJcclxuICogMyAtPiBzb21lXHJcbiAqIDQgLT4gZXZlcnlcclxuICogNSAtPiBmaW5kXHJcbiAqIDYgLT4gZmluZEluZGV4XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVBcnJheU1ldGhvZCh0eXBlKXtcclxuICB2YXIgaXNNYXAgICAgICAgPSB0eXBlID09IDFcclxuICAgICwgaXNGaWx0ZXIgICAgPSB0eXBlID09IDJcclxuICAgICwgaXNTb21lICAgICAgPSB0eXBlID09IDNcclxuICAgICwgaXNFdmVyeSAgICAgPSB0eXBlID09IDRcclxuICAgICwgaXNGaW5kSW5kZXggPSB0eXBlID09IDZcclxuICAgICwgbm9ob2xlcyAgICAgPSB0eXBlID09IDUgfHwgaXNGaW5kSW5kZXg7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XHJcbiAgICB2YXIgTyAgICAgID0gT2JqZWN0KGFzc2VydERlZmluZWQodGhpcykpXHJcbiAgICAgICwgdGhhdCAgID0gYXJndW1lbnRzWzFdXHJcbiAgICAgICwgc2VsZiAgID0gRVM1T2JqZWN0KE8pXHJcbiAgICAgICwgZiAgICAgID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpXHJcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpXHJcbiAgICAgICwgaW5kZXggID0gMFxyXG4gICAgICAsIHJlc3VsdCA9IGlzTWFwID8gQXJyYXkobGVuZ3RoKSA6IGlzRmlsdGVyID8gW10gOiB1bmRlZmluZWRcclxuICAgICAgLCB2YWwsIHJlcztcclxuICAgIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYobm9ob2xlcyB8fCBpbmRleCBpbiBzZWxmKXtcclxuICAgICAgdmFsID0gc2VsZltpbmRleF07XHJcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XHJcbiAgICAgIGlmKHR5cGUpe1xyXG4gICAgICAgIGlmKGlzTWFwKXJlc3VsdFtpbmRleF0gPSByZXM7ICAgICAgICAgICAgIC8vIG1hcFxyXG4gICAgICAgIGVsc2UgaWYocmVzKXN3aXRjaCh0eXBlKXtcclxuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAgICAgICAvLyBzb21lXHJcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAgICAgICAgLy8gZmluZFxyXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxyXG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgICAgICAgIC8vIGZpbHRlclxyXG4gICAgICAgIH0gZWxzZSBpZihpc0V2ZXJ5KXJldHVybiBmYWxzZTsgICAgICAgICAgIC8vIGV2ZXJ5XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBpc0ZpbmRJbmRleCA/IC0xIDogaXNTb21lIHx8IGlzRXZlcnkgPyBpc0V2ZXJ5IDogcmVzdWx0O1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVBcnJheUNvbnRhaW5zKGlzQ29udGFpbnMpe1xyXG4gIHJldHVybiBmdW5jdGlvbihlbCAvKiwgZnJvbUluZGV4ID0gMCAqLyl7XHJcbiAgICB2YXIgTyAgICAgID0gdG9PYmplY3QodGhpcylcclxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcclxuICAgICAgLCBpbmRleCAgPSB0b0luZGV4KGFyZ3VtZW50c1sxXSwgbGVuZ3RoKTtcclxuICAgIGlmKGlzQ29udGFpbnMgJiYgZWwgIT0gZWwpe1xyXG4gICAgICBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKHNhbWVOYU4oT1tpbmRleF0pKXJldHVybiBpc0NvbnRhaW5zIHx8IGluZGV4O1xyXG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoaXNDb250YWlucyB8fCBpbmRleCBpbiBPKXtcclxuICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBpc0NvbnRhaW5zIHx8IGluZGV4O1xyXG4gICAgfSByZXR1cm4gIWlzQ29udGFpbnMgJiYgLTE7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbmVyaWMoQSwgQil7XHJcbiAgLy8gc3RyYW5nZSBJRSBxdWlya3MgbW9kZSBidWcgLT4gdXNlIHR5cGVvZiB2cyBpc0Z1bmN0aW9uXHJcbiAgcmV0dXJuIHR5cGVvZiBBID09ICdmdW5jdGlvbicgPyBBIDogQjtcclxufVxyXG5cclxuLy8gTWF0aFxyXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmYgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxyXG4gICwgcG93ICAgID0gTWF0aC5wb3dcclxuICAsIGFicyAgICA9IE1hdGguYWJzXHJcbiAgLCBjZWlsICAgPSBNYXRoLmNlaWxcclxuICAsIGZsb29yICA9IE1hdGguZmxvb3JcclxuICAsIG1heCAgICA9IE1hdGgubWF4XHJcbiAgLCBtaW4gICAgPSBNYXRoLm1pblxyXG4gICwgcmFuZG9tID0gTWF0aC5yYW5kb21cclxuICAsIHRydW5jICA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24oaXQpe1xyXG4gICAgICByZXR1cm4gKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xyXG4gICAgfVxyXG4vLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxyXG5mdW5jdGlvbiBzYW1lTmFOKG51bWJlcil7XHJcbiAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XHJcbn1cclxuLy8gNy4xLjQgVG9JbnRlZ2VyXHJcbmZ1bmN0aW9uIHRvSW50ZWdlcihpdCl7XHJcbiAgcmV0dXJuIGlzTmFOKGl0KSA/IDAgOiB0cnVuYyhpdCk7XHJcbn1cclxuLy8gNy4xLjE1IFRvTGVuZ3RoXHJcbmZ1bmN0aW9uIHRvTGVuZ3RoKGl0KXtcclxuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIE1BWF9TQUZFX0lOVEVHRVIpIDogMDtcclxufVxyXG5mdW5jdGlvbiB0b0luZGV4KGluZGV4LCBsZW5ndGgpe1xyXG4gIHZhciBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XHJcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XHJcbn1cclxuZnVuY3Rpb24gbHoobnVtKXtcclxuICByZXR1cm4gbnVtID4gOSA/IG51bSA6ICcwJyArIG51bTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlUmVwbGFjZXIocmVnRXhwLCByZXBsYWNlLCBpc1N0YXRpYyl7XHJcbiAgdmFyIHJlcGxhY2VyID0gaXNPYmplY3QocmVwbGFjZSkgPyBmdW5jdGlvbihwYXJ0KXtcclxuICAgIHJldHVybiByZXBsYWNlW3BhcnRdO1xyXG4gIH0gOiByZXBsYWNlO1xyXG4gIHJldHVybiBmdW5jdGlvbihpdCl7XHJcbiAgICByZXR1cm4gU3RyaW5nKGlzU3RhdGljID8gaXQgOiB0aGlzKS5yZXBsYWNlKHJlZ0V4cCwgcmVwbGFjZXIpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVQb2ludEF0KHRvU3RyaW5nKXtcclxuICByZXR1cm4gZnVuY3Rpb24ocG9zKXtcclxuICAgIHZhciBzID0gU3RyaW5nKGFzc2VydERlZmluZWQodGhpcykpXHJcbiAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXHJcbiAgICAgICwgbCA9IHMubGVuZ3RoXHJcbiAgICAgICwgYSwgYjtcclxuICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gdG9TdHJpbmcgPyAnJyA6IHVuZGVmaW5lZDtcclxuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XHJcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxyXG4gICAgICA/IHRvU3RyaW5nID8gcy5jaGFyQXQoaSkgOiBhXHJcbiAgICAgIDogdG9TdHJpbmcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBBc3NlcnRpb24gJiBlcnJvcnNcclxudmFyIFJFRFVDRV9FUlJPUiA9ICdSZWR1Y2Ugb2YgZW1wdHkgb2JqZWN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZSc7XHJcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1zZzEsIG1zZzIpe1xyXG4gIGlmKCFjb25kaXRpb24pdGhyb3cgVHlwZUVycm9yKG1zZzIgPyBtc2cxICsgbXNnMiA6IG1zZzEpO1xyXG59XHJcbmZ1bmN0aW9uIGFzc2VydERlZmluZWQoaXQpe1xyXG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoJ0Z1bmN0aW9uIGNhbGxlZCBvbiBudWxsIG9yIHVuZGVmaW5lZCcpO1xyXG4gIHJldHVybiBpdDtcclxufVxyXG5mdW5jdGlvbiBhc3NlcnRGdW5jdGlvbihpdCl7XHJcbiAgYXNzZXJ0KGlzRnVuY3Rpb24oaXQpLCBpdCwgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcclxuICByZXR1cm4gaXQ7XHJcbn1cclxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0KGl0KXtcclxuICBhc3NlcnQoaXNPYmplY3QoaXQpLCBpdCwgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xyXG4gIHJldHVybiBpdDtcclxufVxyXG5mdW5jdGlvbiBhc3NlcnRJbnN0YW5jZShpdCwgQ29uc3RydWN0b3IsIG5hbWUpe1xyXG4gIGFzc2VydChpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yLCBuYW1lLCBcIjogdXNlIHRoZSAnbmV3JyBvcGVyYXRvciFcIik7XHJcbn1cclxuXHJcbi8vIFByb3BlcnR5IGRlc2NyaXB0b3JzICYgU3ltYm9sXHJcbmZ1bmN0aW9uIGRlc2NyaXB0b3IoYml0bWFwLCB2YWx1ZSl7XHJcbiAgcmV0dXJuIHtcclxuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcclxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcclxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcclxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gc2ltcGxlU2V0KG9iamVjdCwga2V5LCB2YWx1ZSl7XHJcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcclxuICByZXR1cm4gb2JqZWN0O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZURlZmluZXIoYml0bWFwKXtcclxuICByZXR1cm4gREVTQyA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XHJcbiAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIGRlc2NyaXB0b3IoYml0bWFwLCB2YWx1ZSkpO1xyXG4gIH0gOiBzaW1wbGVTZXQ7XHJcbn1cclxuZnVuY3Rpb24gdWlkKGtleSl7XHJcbiAgcmV0dXJuIFNZTUJPTCArICcoJyArIGtleSArICcpXycgKyAoKytzaWQgKyByYW5kb20oKSlbVE9fU1RSSU5HXSgzNik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0V2VsbEtub3duU3ltYm9sKG5hbWUsIHNldHRlcil7XHJcbiAgcmV0dXJuIChTeW1ib2wgJiYgU3ltYm9sW25hbWVdKSB8fCAoc2V0dGVyID8gU3ltYm9sIDogc2FmZVN5bWJvbCkoU1lNQk9MICsgRE9UICsgbmFtZSk7XHJcbn1cclxuLy8gVGhlIGVuZ2luZSB3b3JrcyBmaW5lIHdpdGggZGVzY3JpcHRvcnM/IFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHkuXHJcbnZhciBERVNDID0gISFmdW5jdGlvbigpe1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gMiB9fSkuYSA9PSAyO1xyXG4gICAgICB9IGNhdGNoKGUpe31cclxuICAgIH0oKVxyXG4gICwgc2lkICAgID0gMFxyXG4gICwgaGlkZGVuID0gY3JlYXRlRGVmaW5lcigxKVxyXG4gICwgc2V0ICAgID0gU3ltYm9sID8gc2ltcGxlU2V0IDogaGlkZGVuXHJcbiAgLCBzYWZlU3ltYm9sID0gU3ltYm9sIHx8IHVpZDtcclxuZnVuY3Rpb24gYXNzaWduSGlkZGVuKHRhcmdldCwgc3JjKXtcclxuICBmb3IodmFyIGtleSBpbiBzcmMpaGlkZGVuKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XHJcbiAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5cclxudmFyIFNZTUJPTF9VTlNDT1BBQkxFUyA9IGdldFdlbGxLbm93blN5bWJvbCgndW5zY29wYWJsZXMnKVxyXG4gICwgQXJyYXlVbnNjb3BhYmxlcyAgID0gQXJyYXlQcm90b1tTWU1CT0xfVU5TQ09QQUJMRVNdIHx8IHt9XHJcbiAgLCBTWU1CT0xfVEFHICAgICAgICAgPSBnZXRXZWxsS25vd25TeW1ib2woVE9fU1RSSU5HX1RBRylcclxuICAsIFNZTUJPTF9TUEVDSUVTICAgICA9IGdldFdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpXHJcbiAgLCBTWU1CT0xfSVRFUkFUT1I7XHJcbmZ1bmN0aW9uIHNldFNwZWNpZXMoQyl7XHJcbiAgaWYoREVTQyAmJiAoZnJhbWV3b3JrIHx8ICFpc05hdGl2ZShDKSkpZGVmaW5lUHJvcGVydHkoQywgU1lNQk9MX1NQRUNJRVMsIHtcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogcmV0dXJuVGhpc1xyXG4gIH0pO1xyXG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGNvbW1vbi5leHBvcnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBOT0RFID0gY29mKHByb2Nlc3MpID09IFBST0NFU1NcclxuICAsIGNvcmUgPSB7fVxyXG4gICwgcGF0aCA9IGZyYW1ld29yayA/IGdsb2JhbCA6IGNvcmVcclxuICAsIG9sZCAgPSBnbG9iYWwuY29yZVxyXG4gICwgZXhwb3J0R2xvYmFsXHJcbiAgLy8gdHlwZSBiaXRtYXBcclxuICAsIEZPUkNFRCA9IDFcclxuICAsIEdMT0JBTCA9IDJcclxuICAsIFNUQVRJQyA9IDRcclxuICAsIFBST1RPICA9IDhcclxuICAsIEJJTkQgICA9IDE2XHJcbiAgLCBXUkFQICAgPSAzMjtcclxuZnVuY3Rpb24gJGRlZmluZSh0eXBlLCBuYW1lLCBzb3VyY2Upe1xyXG4gIHZhciBrZXksIG93biwgb3V0LCBleHBcclxuICAgICwgaXNHbG9iYWwgPSB0eXBlICYgR0xPQkFMXHJcbiAgICAsIHRhcmdldCAgID0gaXNHbG9iYWwgPyBnbG9iYWwgOiAodHlwZSAmIFNUQVRJQylcclxuICAgICAgICA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwgT2JqZWN0UHJvdG8pW1BST1RPVFlQRV1cclxuICAgICwgZXhwb3J0cyAgPSBpc0dsb2JhbCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xyXG4gIGlmKGlzR2xvYmFsKXNvdXJjZSA9IG5hbWU7XHJcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xyXG4gICAgLy8gdGhlcmUgaXMgYSBzaW1pbGFyIG5hdGl2ZVxyXG4gICAgb3duID0gISh0eXBlICYgRk9SQ0VEKSAmJiB0YXJnZXQgJiYga2V5IGluIHRhcmdldFxyXG4gICAgICAmJiAoIWlzRnVuY3Rpb24odGFyZ2V0W2tleV0pIHx8IGlzTmF0aXZlKHRhcmdldFtrZXldKSk7XHJcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxyXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcclxuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xyXG4gICAgaWYoIWZyYW1ld29yayAmJiBpc0dsb2JhbCAmJiAhaXNGdW5jdGlvbih0YXJnZXRba2V5XSkpZXhwID0gc291cmNlW2tleV07XHJcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxyXG4gICAgZWxzZSBpZih0eXBlICYgQklORCAmJiBvd24pZXhwID0gY3R4KG91dCwgZ2xvYmFsKTtcclxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XHJcbiAgICBlbHNlIGlmKHR5cGUgJiBXUkFQICYmICFmcmFtZXdvcmsgJiYgdGFyZ2V0W2tleV0gPT0gb3V0KXtcclxuICAgICAgZXhwID0gZnVuY3Rpb24ocGFyYW0pe1xyXG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2Ygb3V0ID8gbmV3IG91dChwYXJhbSkgOiBvdXQocGFyYW0pO1xyXG4gICAgICB9XHJcbiAgICAgIGV4cFtQUk9UT1RZUEVdID0gb3V0W1BST1RPVFlQRV07XHJcbiAgICB9IGVsc2UgZXhwID0gdHlwZSAmIFBST1RPICYmIGlzRnVuY3Rpb24ob3V0KSA/IGN0eChjYWxsLCBvdXQpIDogb3V0O1xyXG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxyXG4gICAgaWYoZnJhbWV3b3JrICYmIHRhcmdldCAmJiAhb3duKXtcclxuICAgICAgaWYoaXNHbG9iYWwpdGFyZ2V0W2tleV0gPSBvdXQ7XHJcbiAgICAgIGVsc2UgZGVsZXRlIHRhcmdldFtrZXldICYmIGhpZGRlbih0YXJnZXQsIGtleSwgb3V0KTtcclxuICAgIH1cclxuICAgIC8vIGV4cG9ydFxyXG4gICAgaWYoZXhwb3J0c1trZXldICE9IG91dCloaWRkZW4oZXhwb3J0cywga2V5LCBleHApO1xyXG4gIH1cclxufVxyXG4vLyBDb21tb25KUyBleHBvcnRcclxuaWYodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyltb2R1bGUuZXhwb3J0cyA9IGNvcmU7XHJcbi8vIFJlcXVpcmVKUyBleHBvcnRcclxuZWxzZSBpZihpc0Z1bmN0aW9uKGRlZmluZSkgJiYgZGVmaW5lLmFtZClkZWZpbmUoZnVuY3Rpb24oKXtyZXR1cm4gY29yZX0pO1xyXG4vLyBFeHBvcnQgdG8gZ2xvYmFsIG9iamVjdFxyXG5lbHNlIGV4cG9ydEdsb2JhbCA9IHRydWU7XHJcbmlmKGV4cG9ydEdsb2JhbCB8fCBmcmFtZXdvcmspe1xyXG4gIGNvcmUubm9Db25mbGljdCA9IGZ1bmN0aW9uKCl7XHJcbiAgICBnbG9iYWwuY29yZSA9IG9sZDtcclxuICAgIHJldHVybiBjb3JlO1xyXG4gIH1cclxuICBnbG9iYWwuY29yZSA9IGNvcmU7XHJcbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogY29tbW9uLml0ZXJhdG9ycyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuU1lNQk9MX0lURVJBVE9SID0gZ2V0V2VsbEtub3duU3ltYm9sKElURVJBVE9SKTtcclxudmFyIElURVIgID0gc2FmZVN5bWJvbCgnaXRlcicpXHJcbiAgLCBLRVkgICA9IDFcclxuICAsIFZBTFVFID0gMlxyXG4gICwgSXRlcmF0b3JzID0ge31cclxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge31cclxuICAgIC8vIFNhZmFyaSBoYXMgYnlnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcclxuICAsIEJVR0dZX0lURVJBVE9SUyA9ICdrZXlzJyBpbiBBcnJheVByb3RvICYmICEoJ25leHQnIGluIFtdLmtleXMoKSk7XHJcbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXHJcbnNldEl0ZXJhdG9yKEl0ZXJhdG9yUHJvdG90eXBlLCByZXR1cm5UaGlzKTtcclxuZnVuY3Rpb24gc2V0SXRlcmF0b3IoTywgdmFsdWUpe1xyXG4gIGhpZGRlbihPLCBTWU1CT0xfSVRFUkFUT1IsIHZhbHVlKTtcclxuICAvLyBBZGQgaXRlcmF0b3IgZm9yIEZGIGl0ZXJhdG9yIHByb3RvY29sXHJcbiAgRkZfSVRFUkFUT1IgaW4gQXJyYXlQcm90byAmJiBoaWRkZW4oTywgRkZfSVRFUkFUT1IsIHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJdGVyYXRvcihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCwgcHJvdG8pe1xyXG4gIENvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBjcmVhdGUocHJvdG8gfHwgSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpfSk7XHJcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XHJcbn1cclxuZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3IoQ29uc3RydWN0b3IsIE5BTUUsIHZhbHVlLCBERUZBVUxUKXtcclxuICB2YXIgcHJvdG8gPSBDb25zdHJ1Y3RvcltQUk9UT1RZUEVdXHJcbiAgICAsIGl0ZXIgID0gZ2V0KHByb3RvLCBTWU1CT0xfSVRFUkFUT1IpIHx8IGdldChwcm90bywgRkZfSVRFUkFUT1IpIHx8IChERUZBVUxUICYmIGdldChwcm90bywgREVGQVVMVCkpIHx8IHZhbHVlO1xyXG4gIGlmKGZyYW1ld29yayl7XHJcbiAgICAvLyBEZWZpbmUgaXRlcmF0b3JcclxuICAgIHNldEl0ZXJhdG9yKHByb3RvLCBpdGVyKTtcclxuICAgIGlmKGl0ZXIgIT09IHZhbHVlKXtcclxuICAgICAgdmFyIGl0ZXJQcm90byA9IGdldFByb3RvdHlwZU9mKGl0ZXIuY2FsbChuZXcgQ29uc3RydWN0b3IpKTtcclxuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xyXG4gICAgICBzZXRUb1N0cmluZ1RhZyhpdGVyUHJvdG8sIE5BTUUgKyAnIEl0ZXJhdG9yJywgdHJ1ZSk7XHJcbiAgICAgIC8vIEZGIGZpeFxyXG4gICAgICBoYXMocHJvdG8sIEZGX0lURVJBVE9SKSAmJiBzZXRJdGVyYXRvcihpdGVyUHJvdG8sIHJldHVyblRoaXMpO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XHJcbiAgSXRlcmF0b3JzW05BTUVdID0gaXRlcjtcclxuICAvLyBGRiAmIHY4IGZpeFxyXG4gIEl0ZXJhdG9yc1tOQU1FICsgJyBJdGVyYXRvciddID0gcmV0dXJuVGhpcztcclxuICByZXR1cm4gaXRlcjtcclxufVxyXG5mdW5jdGlvbiBkZWZpbmVTdGRJdGVyYXRvcnMoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCl7XHJcbiAgZnVuY3Rpb24gY3JlYXRlSXRlcihraW5kKXtcclxuICAgIHJldHVybiBmdW5jdGlvbigpe1xyXG4gICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpO1xyXG4gICAgfVxyXG4gIH1cclxuICBjcmVhdGVJdGVyYXRvcihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XHJcbiAgdmFyIGVudHJpZXMgPSBjcmVhdGVJdGVyKEtFWStWQUxVRSlcclxuICAgICwgdmFsdWVzICA9IGNyZWF0ZUl0ZXIoVkFMVUUpO1xyXG4gIGlmKERFRkFVTFQgPT0gVkFMVUUpdmFsdWVzID0gZGVmaW5lSXRlcmF0b3IoQmFzZSwgTkFNRSwgdmFsdWVzLCAndmFsdWVzJyk7XHJcbiAgZWxzZSBlbnRyaWVzID0gZGVmaW5lSXRlcmF0b3IoQmFzZSwgTkFNRSwgZW50cmllcywgJ2VudHJpZXMnKTtcclxuICBpZihERUZBVUxUKXtcclxuICAgICRkZWZpbmUoUFJPVE8gKyBGT1JDRUQgKiBCVUdHWV9JVEVSQVRPUlMsIE5BTUUsIHtcclxuICAgICAgZW50cmllczogZW50cmllcyxcclxuICAgICAga2V5czogSVNfU0VUID8gdmFsdWVzIDogY3JlYXRlSXRlcihLRVkpLFxyXG4gICAgICB2YWx1ZXM6IHZhbHVlc1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGl0ZXJSZXN1bHQoZG9uZSwgdmFsdWUpe1xyXG4gIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xyXG59XHJcbmZ1bmN0aW9uIGlzSXRlcmFibGUoaXQpe1xyXG4gIHZhciBPICAgICAgPSBPYmplY3QoaXQpXHJcbiAgICAsIFN5bWJvbCA9IGdsb2JhbFtTWU1CT0xdXHJcbiAgICAsIGhhc0V4dCA9IChTeW1ib2wgJiYgU3ltYm9sW0lURVJBVE9SXSB8fCBGRl9JVEVSQVRPUikgaW4gTztcclxuICByZXR1cm4gaGFzRXh0IHx8IFNZTUJPTF9JVEVSQVRPUiBpbiBPIHx8IGhhcyhJdGVyYXRvcnMsIGNsYXNzb2YoTykpO1xyXG59XHJcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yKGl0KXtcclxuICB2YXIgU3ltYm9sICA9IGdsb2JhbFtTWU1CT0xdXHJcbiAgICAsIGV4dCAgICAgPSBpdFtTeW1ib2wgJiYgU3ltYm9sW0lURVJBVE9SXSB8fCBGRl9JVEVSQVRPUl1cclxuICAgICwgZ2V0SXRlciA9IGV4dCB8fCBpdFtTWU1CT0xfSVRFUkFUT1JdIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XHJcbiAgcmV0dXJuIGFzc2VydE9iamVjdChnZXRJdGVyLmNhbGwoaXQpKTtcclxufVxyXG5mdW5jdGlvbiBzdGVwQ2FsbChmbiwgdmFsdWUsIGVudHJpZXMpe1xyXG4gIHJldHVybiBlbnRyaWVzID8gaW52b2tlKGZuLCB2YWx1ZSkgOiBmbih2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tEYW5nZXJJdGVyQ2xvc2luZyhmbil7XHJcbiAgdmFyIGRhbmdlciA9IHRydWU7XHJcbiAgdmFyIE8gPSB7XHJcbiAgICBuZXh0OiBmdW5jdGlvbigpeyB0aHJvdyAxIH0sXHJcbiAgICAncmV0dXJuJzogZnVuY3Rpb24oKXsgZGFuZ2VyID0gZmFsc2UgfVxyXG4gIH07XHJcbiAgT1tTWU1CT0xfSVRFUkFUT1JdID0gcmV0dXJuVGhpcztcclxuICB0cnkge1xyXG4gICAgZm4oTyk7XHJcbiAgfSBjYXRjaChlKXt9XHJcbiAgcmV0dXJuIGRhbmdlcjtcclxufVxyXG5mdW5jdGlvbiBjbG9zZUl0ZXJhdG9yKGl0ZXJhdG9yKXtcclxuICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xyXG4gIGlmKHJldCAhPT0gdW5kZWZpbmVkKXJldC5jYWxsKGl0ZXJhdG9yKTtcclxufVxyXG5mdW5jdGlvbiBzYWZlSXRlckNsb3NlKGV4ZWMsIGl0ZXJhdG9yKXtcclxuICB0cnkge1xyXG4gICAgZXhlYyhpdGVyYXRvcik7XHJcbiAgfSBjYXRjaChlKXtcclxuICAgIGNsb3NlSXRlcmF0b3IoaXRlcmF0b3IpO1xyXG4gICAgdGhyb3cgZTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZm9yT2YoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0KXtcclxuICBzYWZlSXRlckNsb3NlKGZ1bmN0aW9uKGl0ZXJhdG9yKXtcclxuICAgIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXHJcbiAgICAgICwgc3RlcDtcclxuICAgIHdoaWxlKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSlpZihzdGVwQ2FsbChmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKSA9PT0gZmFsc2Upe1xyXG4gICAgICByZXR1cm4gY2xvc2VJdGVyYXRvcihpdGVyYXRvcik7XHJcbiAgICB9XHJcbiAgfSwgZ2V0SXRlcmF0b3IoaXRlcmFibGUpKTtcclxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYuc3ltYm9sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXHJcbiFmdW5jdGlvbihUQUcsIFN5bWJvbFJlZ2lzdHJ5LCBBbGxTeW1ib2xzLCBzZXR0ZXIpe1xyXG4gIC8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxyXG4gIGlmKCFpc05hdGl2ZShTeW1ib2wpKXtcclxuICAgIFN5bWJvbCA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKXtcclxuICAgICAgYXNzZXJ0KCEodGhpcyBpbnN0YW5jZW9mIFN5bWJvbCksIFNZTUJPTCArICcgaXMgbm90IGEgJyArIENPTlNUUlVDVE9SKTtcclxuICAgICAgdmFyIHRhZyA9IHVpZChkZXNjcmlwdGlvbilcclxuICAgICAgICAsIHN5bSA9IHNldChjcmVhdGUoU3ltYm9sW1BST1RPVFlQRV0pLCBUQUcsIHRhZyk7XHJcbiAgICAgIEFsbFN5bWJvbHNbdGFnXSA9IHN5bTtcclxuICAgICAgREVTQyAmJiBzZXR0ZXIgJiYgZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG8sIHRhZywge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcclxuICAgICAgICAgIGhpZGRlbih0aGlzLCB0YWcsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gc3ltO1xyXG4gICAgfVxyXG4gICAgaGlkZGVuKFN5bWJvbFtQUk9UT1RZUEVdLCBUT19TVFJJTkcsIGZ1bmN0aW9uKCl7XHJcbiAgICAgIHJldHVybiB0aGlzW1RBR107XHJcbiAgICB9KTtcclxuICB9XHJcbiAgJGRlZmluZShHTE9CQUwgKyBXUkFQLCB7U3ltYm9sOiBTeW1ib2x9KTtcclxuICBcclxuICB2YXIgc3ltYm9sU3RhdGljcyA9IHtcclxuICAgIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxyXG4gICAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcclxuICAgICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cclxuICAgICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSBTeW1ib2woa2V5KTtcclxuICAgIH0sXHJcbiAgICAvLyAxOS40LjIuNCBTeW1ib2wuaXRlcmF0b3JcclxuICAgIGl0ZXJhdG9yOiBTWU1CT0xfSVRFUkFUT1IgfHwgZ2V0V2VsbEtub3duU3ltYm9sKElURVJBVE9SKSxcclxuICAgIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxyXG4gICAga2V5Rm9yOiBwYXJ0LmNhbGwoa2V5T2YsIFN5bWJvbFJlZ2lzdHJ5KSxcclxuICAgIC8vIDE5LjQuMi4xMCBTeW1ib2wuc3BlY2llc1xyXG4gICAgc3BlY2llczogU1lNQk9MX1NQRUNJRVMsXHJcbiAgICAvLyAxOS40LjIuMTMgU3ltYm9sLnRvU3RyaW5nVGFnXHJcbiAgICB0b1N0cmluZ1RhZzogU1lNQk9MX1RBRyA9IGdldFdlbGxLbm93blN5bWJvbChUT19TVFJJTkdfVEFHLCB0cnVlKSxcclxuICAgIC8vIDE5LjQuMi4xNCBTeW1ib2wudW5zY29wYWJsZXNcclxuICAgIHVuc2NvcGFibGVzOiBTWU1CT0xfVU5TQ09QQUJMRVMsXHJcbiAgICBwdXJlOiBzYWZlU3ltYm9sLFxyXG4gICAgc2V0OiBzZXQsXHJcbiAgICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7c2V0dGVyID0gdHJ1ZX0sXHJcbiAgICB1c2VTaW1wbGU6IGZ1bmN0aW9uKCl7c2V0dGVyID0gZmFsc2V9XHJcbiAgfTtcclxuICAvLyAxOS40LjIuMiBTeW1ib2wuaGFzSW5zdGFuY2VcclxuICAvLyAxOS40LjIuMyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlXHJcbiAgLy8gMTkuNC4yLjYgU3ltYm9sLm1hdGNoXHJcbiAgLy8gMTkuNC4yLjggU3ltYm9sLnJlcGxhY2VcclxuICAvLyAxOS40LjIuOSBTeW1ib2wuc2VhcmNoXHJcbiAgLy8gMTkuNC4yLjExIFN5bWJvbC5zcGxpdFxyXG4gIC8vIDE5LjQuMi4xMiBTeW1ib2wudG9QcmltaXRpdmVcclxuICBmb3JFYWNoLmNhbGwoYXJyYXkoJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGxpdCx0b1ByaW1pdGl2ZScpLFxyXG4gICAgZnVuY3Rpb24oaXQpe1xyXG4gICAgICBzeW1ib2xTdGF0aWNzW2l0XSA9IGdldFdlbGxLbm93blN5bWJvbChpdCk7XHJcbiAgICB9XHJcbiAgKTtcclxuICAkZGVmaW5lKFNUQVRJQywgU1lNQk9MLCBzeW1ib2xTdGF0aWNzKTtcclxuICBcclxuICBzZXRUb1N0cmluZ1RhZyhTeW1ib2wsIFNZTUJPTCk7XHJcbiAgXHJcbiAgJGRlZmluZShTVEFUSUMgKyBGT1JDRUQgKiAhaXNOYXRpdmUoU3ltYm9sKSwgT0JKRUNULCB7XHJcbiAgICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxyXG4gICAgZ2V0T3duUHJvcGVydHlOYW1lczogZnVuY3Rpb24oaXQpe1xyXG4gICAgICB2YXIgbmFtZXMgPSBnZXROYW1lcyh0b09iamVjdChpdCkpLCByZXN1bHQgPSBbXSwga2V5LCBpID0gMDtcclxuICAgICAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSloYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcbiAgICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXHJcbiAgICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6IGZ1bmN0aW9uKGl0KXtcclxuICAgICAgdmFyIG5hbWVzID0gZ2V0TmFtZXModG9PYmplY3QoaXQpKSwgcmVzdWx0ID0gW10sIGtleSwgaSA9IDA7XHJcbiAgICAgIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgXHJcbiAgLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxyXG4gIHNldFRvU3RyaW5nVGFnKE1hdGgsIE1BVEgsIHRydWUpO1xyXG4gIC8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXHJcbiAgc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XHJcbn0oc2FmZVN5bWJvbCgndGFnJyksIHt9LCB7fSwgdHJ1ZSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5vYmplY3Quc3RhdGljcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbigpe1xyXG4gIHZhciBvYmplY3RTdGF0aWMgPSB7XHJcbiAgICAvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxyXG4gICAgYXNzaWduOiBhc3NpZ24sXHJcbiAgICAvLyAxOS4xLjMuMTAgT2JqZWN0LmlzKHZhbHVlMSwgdmFsdWUyKVxyXG4gICAgaXM6IGZ1bmN0aW9uKHgsIHkpe1xyXG4gICAgICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcclxuICAgIH1cclxuICB9O1xyXG4gIC8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXHJcbiAgLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmtzIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxyXG4gICdfX3Byb3RvX18nIGluIE9iamVjdFByb3RvICYmIGZ1bmN0aW9uKGJ1Z2d5LCBzZXQpe1xyXG4gICAgdHJ5IHtcclxuICAgICAgc2V0ID0gY3R4KGNhbGwsIGdldE93bkRlc2NyaXB0b3IoT2JqZWN0UHJvdG8sICdfX3Byb3RvX18nKS5zZXQsIDIpO1xyXG4gICAgICBzZXQoe30sIEFycmF5UHJvdG8pO1xyXG4gICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlIH1cclxuICAgIG9iamVjdFN0YXRpYy5zZXRQcm90b3R5cGVPZiA9IHNldFByb3RvdHlwZU9mID0gc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24oTywgcHJvdG8pe1xyXG4gICAgICBhc3NlcnRPYmplY3QoTyk7XHJcbiAgICAgIGFzc2VydChwcm90byA9PT0gbnVsbCB8fCBpc09iamVjdChwcm90byksIHByb3RvLCBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XHJcbiAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XHJcbiAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcclxuICAgICAgcmV0dXJuIE87XHJcbiAgICB9XHJcbiAgfSgpO1xyXG4gICRkZWZpbmUoU1RBVElDLCBPQkpFQ1QsIG9iamVjdFN0YXRpYyk7XHJcbn0oKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2Lm9iamVjdC5wcm90b3R5cGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKHRtcCl7XHJcbiAgLy8gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXHJcbiAgdG1wW1NZTUJPTF9UQUddID0gRE9UO1xyXG4gIGlmKGNvZih0bXApICE9IERPVCloaWRkZW4oT2JqZWN0UHJvdG8sIFRPX1NUUklORywgZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcclxuICB9KTtcclxufSh7fSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5vYmplY3Quc3RhdGljcy1hY2NlcHQtcHJpbWl0aXZlcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbigpe1xyXG4gIC8vIE9iamVjdCBzdGF0aWMgbWV0aG9kcyBhY2NlcHQgcHJpbWl0aXZlc1xyXG4gIGZ1bmN0aW9uIHdyYXBPYmplY3RNZXRob2Qoa2V5LCBNT0RFKXtcclxuICAgIHZhciBmbiAgPSBPYmplY3Rba2V5XVxyXG4gICAgICAsIGV4cCA9IGNvcmVbT0JKRUNUXVtrZXldXHJcbiAgICAgICwgZiAgID0gMFxyXG4gICAgICAsIG8gICA9IHt9O1xyXG4gICAgaWYoIWV4cCB8fCBpc05hdGl2ZShleHApKXtcclxuICAgICAgb1trZXldID0gTU9ERSA9PSAxID8gZnVuY3Rpb24oaXQpe1xyXG4gICAgICAgIHJldHVybiBpc09iamVjdChpdCkgPyBmbihpdCkgOiBpdDtcclxuICAgICAgfSA6IE1PREUgPT0gMiA/IGZ1bmN0aW9uKGl0KXtcclxuICAgICAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gZm4oaXQpIDogdHJ1ZTtcclxuICAgICAgfSA6IE1PREUgPT0gMyA/IGZ1bmN0aW9uKGl0KXtcclxuICAgICAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gZm4oaXQpIDogZmFsc2U7XHJcbiAgICAgIH0gOiBNT0RFID09IDQgPyBmdW5jdGlvbihpdCwga2V5KXtcclxuICAgICAgICByZXR1cm4gZm4odG9PYmplY3QoaXQpLCBrZXkpO1xyXG4gICAgICB9IDogZnVuY3Rpb24oaXQpe1xyXG4gICAgICAgIHJldHVybiBmbih0b09iamVjdChpdCkpO1xyXG4gICAgICB9O1xyXG4gICAgICB0cnkgeyBmbihET1QpIH1cclxuICAgICAgY2F0Y2goZSl7IGYgPSAxIH1cclxuICAgICAgJGRlZmluZShTVEFUSUMgKyBGT1JDRUQgKiBmLCBPQkpFQ1QsIG8pO1xyXG4gICAgfVxyXG4gIH1cclxuICB3cmFwT2JqZWN0TWV0aG9kKCdmcmVlemUnLCAxKTtcclxuICB3cmFwT2JqZWN0TWV0aG9kKCdzZWFsJywgMSk7XHJcbiAgd3JhcE9iamVjdE1ldGhvZCgncHJldmVudEV4dGVuc2lvbnMnLCAxKTtcclxuICB3cmFwT2JqZWN0TWV0aG9kKCdpc0Zyb3plbicsIDIpO1xyXG4gIHdyYXBPYmplY3RNZXRob2QoJ2lzU2VhbGVkJywgMik7XHJcbiAgd3JhcE9iamVjdE1ldGhvZCgnaXNFeHRlbnNpYmxlJywgMyk7XHJcbiAgd3JhcE9iamVjdE1ldGhvZCgnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJywgNCk7XHJcbiAgd3JhcE9iamVjdE1ldGhvZCgnZ2V0UHJvdG90eXBlT2YnKTtcclxuICB3cmFwT2JqZWN0TWV0aG9kKCdrZXlzJyk7XHJcbiAgd3JhcE9iamVjdE1ldGhvZCgnZ2V0T3duUHJvcGVydHlOYW1lcycpO1xyXG59KCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5mdW5jdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbihOQU1FKXtcclxuICAvLyAxOS4yLjQuMiBuYW1lXHJcbiAgTkFNRSBpbiBGdW5jdGlvblByb3RvIHx8IChERVNDICYmIGRlZmluZVByb3BlcnR5KEZ1bmN0aW9uUHJvdG8sIE5BTUUsIHtcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24oKXtcclxuICAgICAgdmFyIG1hdGNoID0gU3RyaW5nKHRoaXMpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopLylcclxuICAgICAgICAsIG5hbWUgID0gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnO1xyXG4gICAgICBoYXModGhpcywgTkFNRSkgfHwgZGVmaW5lUHJvcGVydHkodGhpcywgTkFNRSwgZGVzY3JpcHRvcig1LCBuYW1lKSk7XHJcbiAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgfSxcclxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgICBoYXModGhpcywgTkFNRSkgfHwgZGVmaW5lUHJvcGVydHkodGhpcywgTkFNRSwgZGVzY3JpcHRvcigwLCB2YWx1ZSkpO1xyXG4gICAgfVxyXG4gIH0pKTtcclxufSgnbmFtZScpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYubnVtYmVyLmNvbnN0cnVjdG9yICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5OdW1iZXIoJzBvMScpICYmIE51bWJlcignMGIxJykgfHwgZnVuY3Rpb24oX051bWJlciwgTnVtYmVyUHJvdG8pe1xyXG4gIGZ1bmN0aW9uIHRvTnVtYmVyKGl0KXtcclxuICAgIGlmKGlzT2JqZWN0KGl0KSlpdCA9IHRvUHJpbWl0aXZlKGl0KTtcclxuICAgIGlmKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyAmJiBpdC5sZW5ndGggPiAyICYmIGl0LmNoYXJDb2RlQXQoMCkgPT0gNDgpe1xyXG4gICAgICB2YXIgYmluYXJ5ID0gZmFsc2U7XHJcbiAgICAgIHN3aXRjaChpdC5jaGFyQ29kZUF0KDEpKXtcclxuICAgICAgICBjYXNlIDY2IDogY2FzZSA5OCAgOiBiaW5hcnkgPSB0cnVlO1xyXG4gICAgICAgIGNhc2UgNzkgOiBjYXNlIDExMSA6IHJldHVybiBwYXJzZUludChpdC5zbGljZSgyKSwgYmluYXJ5ID8gMiA6IDgpO1xyXG4gICAgICB9XHJcbiAgICB9IHJldHVybiAraXQ7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHRvUHJpbWl0aXZlKGl0KXtcclxuICAgIHZhciBmbiwgdmFsO1xyXG4gICAgaWYoaXNGdW5jdGlvbihmbiA9IGl0LnZhbHVlT2YpICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcclxuICAgIGlmKGlzRnVuY3Rpb24oZm4gPSBpdFtUT19TVFJJTkddKSAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XHJcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBudW1iZXJcIik7XHJcbiAgfVxyXG4gIE51bWJlciA9IGZ1bmN0aW9uIE51bWJlcihpdCl7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIE51bWJlciA/IG5ldyBfTnVtYmVyKHRvTnVtYmVyKGl0KSkgOiB0b051bWJlcihpdCk7XHJcbiAgfVxyXG4gIGZvckVhY2guY2FsbChERVNDID8gZ2V0TmFtZXMoX051bWJlcilcclxuICA6IGFycmF5KCdNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWScpLCBmdW5jdGlvbihrZXkpe1xyXG4gICAga2V5IGluIE51bWJlciB8fCBkZWZpbmVQcm9wZXJ0eShOdW1iZXIsIGtleSwgZ2V0T3duRGVzY3JpcHRvcihfTnVtYmVyLCBrZXkpKTtcclxuICB9KTtcclxuICBOdW1iZXJbUFJPVE9UWVBFXSA9IE51bWJlclByb3RvO1xyXG4gIE51bWJlclByb3RvW0NPTlNUUlVDVE9SXSA9IE51bWJlcjtcclxuICBoaWRkZW4oZ2xvYmFsLCBOVU1CRVIsIE51bWJlcik7XHJcbn0oTnVtYmVyLCBOdW1iZXJbUFJPVE9UWVBFXSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5udW1iZXIuc3RhdGljcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbihpc0ludGVnZXIpe1xyXG4gICRkZWZpbmUoU1RBVElDLCBOVU1CRVIsIHtcclxuICAgIC8vIDIwLjEuMi4xIE51bWJlci5FUFNJTE9OXHJcbiAgICBFUFNJTE9OOiBwb3coMiwgLTUyKSxcclxuICAgIC8vIDIwLjEuMi4yIE51bWJlci5pc0Zpbml0ZShudW1iZXIpXHJcbiAgICBpc0Zpbml0ZTogZnVuY3Rpb24oaXQpe1xyXG4gICAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIGlzRmluaXRlKGl0KTtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcclxuICAgIGlzSW50ZWdlcjogaXNJbnRlZ2VyLFxyXG4gICAgLy8gMjAuMS4yLjQgTnVtYmVyLmlzTmFOKG51bWJlcilcclxuICAgIGlzTmFOOiBzYW1lTmFOLFxyXG4gICAgLy8gMjAuMS4yLjUgTnVtYmVyLmlzU2FmZUludGVnZXIobnVtYmVyKVxyXG4gICAgaXNTYWZlSW50ZWdlcjogZnVuY3Rpb24obnVtYmVyKXtcclxuICAgICAgcmV0dXJuIGlzSW50ZWdlcihudW1iZXIpICYmIGFicyhudW1iZXIpIDw9IE1BWF9TQUZFX0lOVEVHRVI7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMS4yLjYgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcclxuICAgIE1BWF9TQUZFX0lOVEVHRVI6IE1BWF9TQUZFX0lOVEVHRVIsXHJcbiAgICAvLyAyMC4xLjIuMTAgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJcclxuICAgIE1JTl9TQUZFX0lOVEVHRVI6IC1NQVhfU0FGRV9JTlRFR0VSLFxyXG4gICAgLy8gMjAuMS4yLjEyIE51bWJlci5wYXJzZUZsb2F0KHN0cmluZylcclxuICAgIHBhcnNlRmxvYXQ6IHBhcnNlRmxvYXQsXHJcbiAgICAvLyAyMC4xLjIuMTMgTnVtYmVyLnBhcnNlSW50KHN0cmluZywgcmFkaXgpXHJcbiAgICBwYXJzZUludDogcGFyc2VJbnRcclxuICB9KTtcclxuLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXHJcbn0oTnVtYmVyLmlzSW50ZWdlciB8fCBmdW5jdGlvbihpdCl7XHJcbiAgcmV0dXJuICFpc09iamVjdChpdCkgJiYgaXNGaW5pdGUoaXQpICYmIGZsb29yKGl0KSA9PT0gaXQ7XHJcbn0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYubWF0aCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBFQ01BU2NyaXB0IDYgc2hpbVxyXG4hZnVuY3Rpb24oKXtcclxuICAvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXHJcbiAgdmFyIEUgICAgPSBNYXRoLkVcclxuICAgICwgZXhwICA9IE1hdGguZXhwXHJcbiAgICAsIGxvZyAgPSBNYXRoLmxvZ1xyXG4gICAgLCBzcXJ0ID0gTWF0aC5zcXJ0XHJcbiAgICAsIHNpZ24gPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24oeCl7XHJcbiAgICAgICAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xyXG4gICAgICB9O1xyXG4gIFxyXG4gIC8vIDIwLjIuMi41IE1hdGguYXNpbmgoeClcclxuICBmdW5jdGlvbiBhc2luaCh4KXtcclxuICAgIHJldHVybiAhaXNGaW5pdGUoeCA9ICt4KSB8fCB4ID09IDAgPyB4IDogeCA8IDAgPyAtYXNpbmgoLXgpIDogbG9nKHggKyBzcXJ0KHggKiB4ICsgMSkpO1xyXG4gIH1cclxuICAvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxyXG4gIGZ1bmN0aW9uIGV4cG0xKHgpe1xyXG4gICAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogeCA+IC0xZS02ICYmIHggPCAxZS02ID8geCArIHggKiB4IC8gMiA6IGV4cCh4KSAtIDE7XHJcbiAgfVxyXG4gICAgXHJcbiAgJGRlZmluZShTVEFUSUMsIE1BVEgsIHtcclxuICAgIC8vIDIwLjIuMi4zIE1hdGguYWNvc2goeClcclxuICAgIGFjb3NoOiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuICh4ID0gK3gpIDwgMSA/IE5hTiA6IGlzRmluaXRlKHgpID8gbG9nKHggLyBFICsgc3FydCh4ICsgMSkgKiBzcXJ0KHggLSAxKSAvIEUpICsgMSA6IHg7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjUgTWF0aC5hc2luaCh4KVxyXG4gICAgYXNpbmg6IGFzaW5oLFxyXG4gICAgLy8gMjAuMi4yLjcgTWF0aC5hdGFuaCh4KVxyXG4gICAgYXRhbmg6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiBsb2coKDEgKyB4KSAvICgxIC0geCkpIC8gMjtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuOSBNYXRoLmNicnQoeClcclxuICAgIGNicnQ6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICByZXR1cm4gc2lnbih4ID0gK3gpICogcG93KGFicyh4KSwgMSAvIDMpO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4xMSBNYXRoLmNsejMyKHgpXHJcbiAgICBjbHozMjogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHJldHVybiAoeCA+Pj49IDApID8gMzIgLSB4W1RPX1NUUklOR10oMikubGVuZ3RoIDogMzI7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjEyIE1hdGguY29zaCh4KVxyXG4gICAgY29zaDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHJldHVybiAoZXhwKHggPSAreCkgKyBleHAoLXgpKSAvIDI7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcclxuICAgIGV4cG0xOiBleHBtMSxcclxuICAgIC8vIDIwLjIuMi4xNiBNYXRoLmZyb3VuZCh4KVxyXG4gICAgLy8gVE9ETzogZmFsbGJhY2sgZm9yIElFOS1cclxuICAgIGZyb3VuZDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFt4XSlbMF07XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjE3IE1hdGguaHlwb3QoW3ZhbHVlMVssIHZhbHVlMlssIOKApiBdXV0pXHJcbiAgICBoeXBvdDogZnVuY3Rpb24odmFsdWUxLCB2YWx1ZTIpe1xyXG4gICAgICB2YXIgc3VtICA9IDBcclxuICAgICAgICAsIGxlbjEgPSBhcmd1bWVudHMubGVuZ3RoXHJcbiAgICAgICAgLCBsZW4yID0gbGVuMVxyXG4gICAgICAgICwgYXJncyA9IEFycmF5KGxlbjEpXHJcbiAgICAgICAgLCBsYXJnID0gLUluZmluaXR5XHJcbiAgICAgICAgLCBhcmc7XHJcbiAgICAgIHdoaWxlKGxlbjEtLSl7XHJcbiAgICAgICAgYXJnID0gYXJnc1tsZW4xXSA9ICthcmd1bWVudHNbbGVuMV07XHJcbiAgICAgICAgaWYoYXJnID09IEluZmluaXR5IHx8IGFyZyA9PSAtSW5maW5pdHkpcmV0dXJuIEluZmluaXR5O1xyXG4gICAgICAgIGlmKGFyZyA+IGxhcmcpbGFyZyA9IGFyZztcclxuICAgICAgfVxyXG4gICAgICBsYXJnID0gYXJnIHx8IDE7XHJcbiAgICAgIHdoaWxlKGxlbjItLSlzdW0gKz0gcG93KGFyZ3NbbGVuMl0gLyBsYXJnLCAyKTtcclxuICAgICAgcmV0dXJuIGxhcmcgKiBzcXJ0KHN1bSk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjE4IE1hdGguaW11bCh4LCB5KVxyXG4gICAgaW11bDogZnVuY3Rpb24oeCwgeSl7XHJcbiAgICAgIHZhciBVSW50MTYgPSAweGZmZmZcclxuICAgICAgICAsIHhuID0gK3hcclxuICAgICAgICAsIHluID0gK3lcclxuICAgICAgICAsIHhsID0gVUludDE2ICYgeG5cclxuICAgICAgICAsIHlsID0gVUludDE2ICYgeW47XHJcbiAgICAgIHJldHVybiAwIHwgeGwgKiB5bCArICgoVUludDE2ICYgeG4gPj4+IDE2KSAqIHlsICsgeGwgKiAoVUludDE2ICYgeW4gPj4+IDE2KSA8PCAxNiA+Pj4gMCk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcclxuICAgIGxvZzFwOiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuICh4ID0gK3gpID4gLTFlLTggJiYgeCA8IDFlLTggPyB4IC0geCAqIHggLyAyIDogbG9nKDEgKyB4KTtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMjEgTWF0aC5sb2cxMCh4KVxyXG4gICAgbG9nMTA6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICByZXR1cm4gbG9nKHgpIC8gTWF0aC5MTjEwO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4yMiBNYXRoLmxvZzIoeClcclxuICAgIGxvZzI6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICByZXR1cm4gbG9nKHgpIC8gTWF0aC5MTjI7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxyXG4gICAgc2lnbjogc2lnbixcclxuICAgIC8vIDIwLjIuMi4zMCBNYXRoLnNpbmgoeClcclxuICAgIHNpbmg6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICByZXR1cm4gKGFicyh4ID0gK3gpIDwgMSkgPyAoZXhwbTEoeCkgLSBleHBtMSgteCkpIC8gMiA6IChleHAoeCAtIDEpIC0gZXhwKC14IC0gMSkpICogKEUgLyAyKTtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMzMgTWF0aC50YW5oKHgpXHJcbiAgICB0YW5oOiBmdW5jdGlvbih4KXtcclxuICAgICAgdmFyIGEgPSBleHBtMSh4ID0gK3gpXHJcbiAgICAgICAgLCBiID0gZXhwbTEoLXgpO1xyXG4gICAgICByZXR1cm4gYSA9PSBJbmZpbml0eSA/IDEgOiBiID09IEluZmluaXR5ID8gLTEgOiAoYSAtIGIpIC8gKGV4cCh4KSArIGV4cCgteCkpO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4zNCBNYXRoLnRydW5jKHgpXHJcbiAgICB0cnVuYzogdHJ1bmNcclxuICB9KTtcclxufSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYuc3RyaW5nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oZnJvbUNoYXJDb2RlKXtcclxuICBmdW5jdGlvbiBhc3NlcnROb3RSZWdFeHAoaXQpe1xyXG4gICAgaWYoY29mKGl0KSA9PSBSRUdFWFApdGhyb3cgVHlwZUVycm9yKCk7XHJcbiAgfVxyXG4gIFxyXG4gICRkZWZpbmUoU1RBVElDLCBTVFJJTkcsIHtcclxuICAgIC8vIDIxLjEuMi4yIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNvZGVQb2ludHMpXHJcbiAgICBmcm9tQ29kZVBvaW50OiBmdW5jdGlvbih4KXtcclxuICAgICAgdmFyIHJlcyA9IFtdXHJcbiAgICAgICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXHJcbiAgICAgICAgLCBpICAgPSAwXHJcbiAgICAgICAgLCBjb2RlXHJcbiAgICAgIHdoaWxlKGxlbiA+IGkpe1xyXG4gICAgICAgIGNvZGUgPSArYXJndW1lbnRzW2krK107XHJcbiAgICAgICAgaWYodG9JbmRleChjb2RlLCAweDEwZmZmZikgIT09IGNvZGUpdGhyb3cgUmFuZ2VFcnJvcihjb2RlICsgJyBpcyBub3QgYSB2YWxpZCBjb2RlIHBvaW50Jyk7XHJcbiAgICAgICAgcmVzLnB1c2goY29kZSA8IDB4MTAwMDBcclxuICAgICAgICAgID8gZnJvbUNoYXJDb2RlKGNvZGUpXHJcbiAgICAgICAgICA6IGZyb21DaGFyQ29kZSgoKGNvZGUgLT0gMHgxMDAwMCkgPj4gMTApICsgMHhkODAwLCBjb2RlICUgMHg0MDAgKyAweGRjMDApXHJcbiAgICAgICAgKTtcclxuICAgICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xyXG4gICAgfSxcclxuICAgIC8vIDIxLjEuMi40IFN0cmluZy5yYXcoY2FsbFNpdGUsIC4uLnN1YnN0aXR1dGlvbnMpXHJcbiAgICByYXc6IGZ1bmN0aW9uKGNhbGxTaXRlKXtcclxuICAgICAgdmFyIHJhdyA9IHRvT2JqZWN0KGNhbGxTaXRlLnJhdylcclxuICAgICAgICAsIGxlbiA9IHRvTGVuZ3RoKHJhdy5sZW5ndGgpXHJcbiAgICAgICAgLCBzbG4gPSBhcmd1bWVudHMubGVuZ3RoXHJcbiAgICAgICAgLCByZXMgPSBbXVxyXG4gICAgICAgICwgaSAgID0gMDtcclxuICAgICAgd2hpbGUobGVuID4gaSl7XHJcbiAgICAgICAgcmVzLnB1c2goU3RyaW5nKHJhd1tpKytdKSk7XHJcbiAgICAgICAgaWYoaSA8IHNsbilyZXMucHVzaChTdHJpbmcoYXJndW1lbnRzW2ldKSk7XHJcbiAgICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcclxuICAgIH1cclxuICB9KTtcclxuICBcclxuICAkZGVmaW5lKFBST1RPLCBTVFJJTkcsIHtcclxuICAgIC8vIDIxLjEuMy4zIFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQocG9zKVxyXG4gICAgY29kZVBvaW50QXQ6IGNyZWF0ZVBvaW50QXQoZmFsc2UpLFxyXG4gICAgLy8gMjEuMS4zLjYgU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aChzZWFyY2hTdHJpbmcgWywgZW5kUG9zaXRpb25dKVxyXG4gICAgZW5kc1dpdGg6IGZ1bmN0aW9uKHNlYXJjaFN0cmluZyAvKiwgZW5kUG9zaXRpb24gPSBAbGVuZ3RoICovKXtcclxuICAgICAgYXNzZXJ0Tm90UmVnRXhwKHNlYXJjaFN0cmluZyk7XHJcbiAgICAgIHZhciB0aGF0ID0gU3RyaW5nKGFzc2VydERlZmluZWQodGhpcykpXHJcbiAgICAgICAgLCBlbmRQb3NpdGlvbiA9IGFyZ3VtZW50c1sxXVxyXG4gICAgICAgICwgbGVuID0gdG9MZW5ndGgodGhhdC5sZW5ndGgpXHJcbiAgICAgICAgLCBlbmQgPSBlbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gbGVuIDogbWluKHRvTGVuZ3RoKGVuZFBvc2l0aW9uKSwgbGVuKTtcclxuICAgICAgc2VhcmNoU3RyaW5nICs9ICcnO1xyXG4gICAgICByZXR1cm4gdGhhdC5zbGljZShlbmQgLSBzZWFyY2hTdHJpbmcubGVuZ3RoLCBlbmQpID09PSBzZWFyY2hTdHJpbmc7XHJcbiAgICB9LFxyXG4gICAgLy8gMjEuMS4zLjcgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyhzZWFyY2hTdHJpbmcsIHBvc2l0aW9uID0gMClcclxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbihzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XHJcbiAgICAgIGFzc2VydE5vdFJlZ0V4cChzZWFyY2hTdHJpbmcpO1xyXG4gICAgICByZXR1cm4gISF+U3RyaW5nKGFzc2VydERlZmluZWQodGhpcykpLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBhcmd1bWVudHNbMV0pO1xyXG4gICAgfSxcclxuICAgIC8vIDIxLjEuMy4xMyBTdHJpbmcucHJvdG90eXBlLnJlcGVhdChjb3VudClcclxuICAgIHJlcGVhdDogZnVuY3Rpb24oY291bnQpe1xyXG4gICAgICB2YXIgc3RyID0gU3RyaW5nKGFzc2VydERlZmluZWQodGhpcykpXHJcbiAgICAgICAgLCByZXMgPSAnJ1xyXG4gICAgICAgICwgbiAgID0gdG9JbnRlZ2VyKGNvdW50KTtcclxuICAgICAgaWYoMCA+IG4gfHwgbiA9PSBJbmZpbml0eSl0aHJvdyBSYW5nZUVycm9yKFwiQ291bnQgY2FuJ3QgYmUgbmVnYXRpdmVcIik7XHJcbiAgICAgIGZvcig7biA+IDA7IChuID4+Pj0gMSkgJiYgKHN0ciArPSBzdHIpKWlmKG4gJiAxKXJlcyArPSBzdHI7XHJcbiAgICAgIHJldHVybiByZXM7XHJcbiAgICB9LFxyXG4gICAgLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSlcclxuICAgIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uKHNlYXJjaFN0cmluZyAvKiwgcG9zaXRpb24gPSAwICovKXtcclxuICAgICAgYXNzZXJ0Tm90UmVnRXhwKHNlYXJjaFN0cmluZyk7XHJcbiAgICAgIHZhciB0aGF0ICA9IFN0cmluZyhhc3NlcnREZWZpbmVkKHRoaXMpKVxyXG4gICAgICAgICwgaW5kZXggPSB0b0xlbmd0aChtaW4oYXJndW1lbnRzWzFdLCB0aGF0Lmxlbmd0aCkpO1xyXG4gICAgICBzZWFyY2hTdHJpbmcgKz0gJyc7XHJcbiAgICAgIHJldHVybiB0aGF0LnNsaWNlKGluZGV4LCBpbmRleCArIHNlYXJjaFN0cmluZy5sZW5ndGgpID09PSBzZWFyY2hTdHJpbmc7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0oU3RyaW5nLmZyb21DaGFyQ29kZSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5hcnJheS5zdGF0aWNzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbigpe1xyXG4gICRkZWZpbmUoU1RBVElDICsgRk9SQ0VEICogY2hlY2tEYW5nZXJJdGVyQ2xvc2luZyhBcnJheS5mcm9tKSwgQVJSQVksIHtcclxuICAgIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcclxuICAgIGZyb206IGZ1bmN0aW9uKGFycmF5TGlrZS8qLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCovKXtcclxuICAgICAgdmFyIE8gICAgICAgPSBPYmplY3QoYXNzZXJ0RGVmaW5lZChhcnJheUxpa2UpKVxyXG4gICAgICAgICwgbWFwZm4gICA9IGFyZ3VtZW50c1sxXVxyXG4gICAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcclxuICAgICAgICAsIGYgICAgICAgPSBtYXBwaW5nID8gY3R4KG1hcGZuLCBhcmd1bWVudHNbMl0sIDIpIDogdW5kZWZpbmVkXHJcbiAgICAgICAgLCBpbmRleCAgID0gMFxyXG4gICAgICAgICwgbGVuZ3RoLCByZXN1bHQsIHN0ZXA7XHJcbiAgICAgIGlmKGlzSXRlcmFibGUoTykpe1xyXG4gICAgICAgIHJlc3VsdCA9IG5ldyAoZ2VuZXJpYyh0aGlzLCBBcnJheSkpO1xyXG4gICAgICAgIHNhZmVJdGVyQ2xvc2UoZnVuY3Rpb24oaXRlcmF0b3Ipe1xyXG4gICAgICAgICAgZm9yKDsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKXtcclxuICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IG1hcHBpbmcgPyBmKHN0ZXAudmFsdWUsIGluZGV4KSA6IHN0ZXAudmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZ2V0SXRlcmF0b3IoTykpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdCA9IG5ldyAoZ2VuZXJpYyh0aGlzLCBBcnJheSkpKGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKSk7XHJcbiAgICAgICAgZm9yKDsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xyXG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IG1hcHBpbmcgPyBmKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIFxyXG4gICRkZWZpbmUoU1RBVElDLCBBUlJBWSwge1xyXG4gICAgLy8gMjIuMS4yLjMgQXJyYXkub2YoIC4uLml0ZW1zKVxyXG4gICAgb2Y6IGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xyXG4gICAgICB2YXIgaW5kZXggID0gMFxyXG4gICAgICAgICwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgICAgICwgcmVzdWx0ID0gbmV3IChnZW5lcmljKHRoaXMsIEFycmF5KSkobGVuZ3RoKTtcclxuICAgICAgd2hpbGUobGVuZ3RoID4gaW5kZXgpcmVzdWx0W2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcclxuICAgICAgcmVzdWx0Lmxlbmd0aCA9IGxlbmd0aDtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICB9KTtcclxuICBcclxuICBzZXRTcGVjaWVzKEFycmF5KTtcclxufSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYuYXJyYXkucHJvdG90eXBlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oKXtcclxuICAkZGVmaW5lKFBST1RPLCBBUlJBWSwge1xyXG4gICAgLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXHJcbiAgICBjb3B5V2l0aGluOiBmdW5jdGlvbih0YXJnZXQgLyogPSAwICovLCBzdGFydCAvKiA9IDAsIGVuZCA9IEBsZW5ndGggKi8pe1xyXG4gICAgICB2YXIgTyAgICAgPSBPYmplY3QoYXNzZXJ0RGVmaW5lZCh0aGlzKSlcclxuICAgICAgICAsIGxlbiAgID0gdG9MZW5ndGgoTy5sZW5ndGgpXHJcbiAgICAgICAgLCB0byAgICA9IHRvSW5kZXgodGFyZ2V0LCBsZW4pXHJcbiAgICAgICAgLCBmcm9tICA9IHRvSW5kZXgoc3RhcnQsIGxlbilcclxuICAgICAgICAsIGVuZCAgID0gYXJndW1lbnRzWzJdXHJcbiAgICAgICAgLCBmaW4gICA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9JbmRleChlbmQsIGxlbilcclxuICAgICAgICAsIGNvdW50ID0gbWluKGZpbiAtIGZyb20sIGxlbiAtIHRvKVxyXG4gICAgICAgICwgaW5jICAgPSAxO1xyXG4gICAgICBpZihmcm9tIDwgdG8gJiYgdG8gPCBmcm9tICsgY291bnQpe1xyXG4gICAgICAgIGluYyAgPSAtMTtcclxuICAgICAgICBmcm9tID0gZnJvbSArIGNvdW50IC0gMTtcclxuICAgICAgICB0byAgID0gdG8gKyBjb3VudCAtIDE7XHJcbiAgICAgIH1cclxuICAgICAgd2hpbGUoY291bnQtLSA+IDApe1xyXG4gICAgICAgIGlmKGZyb20gaW4gTylPW3RvXSA9IE9bZnJvbV07XHJcbiAgICAgICAgZWxzZSBkZWxldGUgT1t0b107XHJcbiAgICAgICAgdG8gKz0gaW5jO1xyXG4gICAgICAgIGZyb20gKz0gaW5jO1xyXG4gICAgICB9IHJldHVybiBPO1xyXG4gICAgfSxcclxuICAgIC8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsKHZhbHVlLCBzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKVxyXG4gICAgZmlsbDogZnVuY3Rpb24odmFsdWUgLyosIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqLyl7XHJcbiAgICAgIHZhciBPICAgICAgPSBPYmplY3QoYXNzZXJ0RGVmaW5lZCh0aGlzKSlcclxuICAgICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxyXG4gICAgICAgICwgaW5kZXggID0gdG9JbmRleChhcmd1bWVudHNbMV0sIGxlbmd0aClcclxuICAgICAgICAsIGVuZCAgICA9IGFyZ3VtZW50c1syXVxyXG4gICAgICAgICwgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0luZGV4KGVuZCwgbGVuZ3RoKTtcclxuICAgICAgd2hpbGUoZW5kUG9zID4gaW5kZXgpT1tpbmRleCsrXSA9IHZhbHVlO1xyXG4gICAgICByZXR1cm4gTztcclxuICAgIH0sXHJcbiAgICAvLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXHJcbiAgICBmaW5kOiBjcmVhdGVBcnJheU1ldGhvZCg1KSxcclxuICAgIC8vIDIyLjEuMy45IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxyXG4gICAgZmluZEluZGV4OiBjcmVhdGVBcnJheU1ldGhvZCg2KVxyXG4gIH0pO1xyXG4gIFxyXG4gIGlmKGZyYW1ld29yayl7XHJcbiAgICAvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXHJcbiAgICBmb3JFYWNoLmNhbGwoYXJyYXkoJ2ZpbmQsZmluZEluZGV4LGZpbGwsY29weVdpdGhpbixlbnRyaWVzLGtleXMsdmFsdWVzJyksIGZ1bmN0aW9uKGl0KXtcclxuICAgICAgQXJyYXlVbnNjb3BhYmxlc1tpdF0gPSB0cnVlO1xyXG4gICAgfSk7XHJcbiAgICBTWU1CT0xfVU5TQ09QQUJMRVMgaW4gQXJyYXlQcm90byB8fCBoaWRkZW4oQXJyYXlQcm90bywgU1lNQk9MX1VOU0NPUEFCTEVTLCBBcnJheVVuc2NvcGFibGVzKTtcclxuICB9XHJcbn0oKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2Lml0ZXJhdG9ycyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKGF0KXtcclxuICAvLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXHJcbiAgLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcclxuICAvLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXHJcbiAgLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXHJcbiAgZGVmaW5lU3RkSXRlcmF0b3JzKEFycmF5LCBBUlJBWSwgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xyXG4gICAgc2V0KHRoaXMsIElURVIsIHtvOiB0b09iamVjdChpdGVyYXRlZCksIGk6IDAsIGs6IGtpbmR9KTtcclxuICAvLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcclxuICB9LCBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGl0ZXIgID0gdGhpc1tJVEVSXVxyXG4gICAgICAsIE8gICAgID0gaXRlci5vXHJcbiAgICAgICwga2luZCAgPSBpdGVyLmtcclxuICAgICAgLCBpbmRleCA9IGl0ZXIuaSsrO1xyXG4gICAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xyXG4gICAgICBpdGVyLm8gPSB1bmRlZmluZWQ7XHJcbiAgICAgIHJldHVybiBpdGVyUmVzdWx0KDEpO1xyXG4gICAgfVxyXG4gICAgaWYoa2luZCA9PSBLRVkpICByZXR1cm4gaXRlclJlc3VsdCgwLCBpbmRleCk7XHJcbiAgICBpZihraW5kID09IFZBTFVFKXJldHVybiBpdGVyUmVzdWx0KDAsIE9baW5kZXhdKTtcclxuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJSZXN1bHQoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xyXG4gIH0sIFZBTFVFKTtcclxuICBcclxuICAvLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXHJcbiAgSXRlcmF0b3JzW0FSR1VNRU5UU10gPSBJdGVyYXRvcnNbQVJSQVldO1xyXG4gIFxyXG4gIC8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcclxuICBkZWZpbmVTdGRJdGVyYXRvcnMoU3RyaW5nLCBTVFJJTkcsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcclxuICAgIHNldCh0aGlzLCBJVEVSLCB7bzogU3RyaW5nKGl0ZXJhdGVkKSwgaTogMH0pO1xyXG4gIC8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcclxuICB9LCBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGl0ZXIgID0gdGhpc1tJVEVSXVxyXG4gICAgICAsIE8gICAgID0gaXRlci5vXHJcbiAgICAgICwgaW5kZXggPSBpdGVyLmlcclxuICAgICAgLCBwb2ludDtcclxuICAgIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiBpdGVyUmVzdWx0KDEpO1xyXG4gICAgcG9pbnQgPSBhdC5jYWxsKE8sIGluZGV4KTtcclxuICAgIGl0ZXIuaSArPSBwb2ludC5sZW5ndGg7XHJcbiAgICByZXR1cm4gaXRlclJlc3VsdCgwLCBwb2ludCk7XHJcbiAgfSk7XHJcbn0oY3JlYXRlUG9pbnRBdCh0cnVlKSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5yZWdleHAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbkRFU0MgJiYgIWZ1bmN0aW9uKFJlZ0V4cFByb3RvLCBfUmVnRXhwKXsgIFxyXG4gIC8vIFJlZ0V4cCBhbGxvd3MgYSByZWdleCB3aXRoIGZsYWdzIGFzIHRoZSBwYXR0ZXJuXHJcbiAgaWYoIWZ1bmN0aW9uKCl7dHJ5e3JldHVybiBSZWdFeHAoL2EvZywgJ2knKSA9PSAnL2EvaSd9Y2F0Y2goZSl7fX0oKSl7XHJcbiAgICBSZWdFeHAgPSBmdW5jdGlvbiBSZWdFeHAocGF0dGVybiwgZmxhZ3Mpe1xyXG4gICAgICByZXR1cm4gbmV3IF9SZWdFeHAoY29mKHBhdHRlcm4pID09IFJFR0VYUCAmJiBmbGFncyAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgPyBwYXR0ZXJuLnNvdXJjZSA6IHBhdHRlcm4sIGZsYWdzKTtcclxuICAgIH1cclxuICAgIGZvckVhY2guY2FsbChnZXROYW1lcyhfUmVnRXhwKSwgZnVuY3Rpb24oa2V5KXtcclxuICAgICAga2V5IGluIFJlZ0V4cCB8fCBkZWZpbmVQcm9wZXJ0eShSZWdFeHAsIGtleSwge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBfUmVnRXhwW2tleV0gfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGl0KXsgX1JlZ0V4cFtrZXldID0gaXQgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgUmVnRXhwUHJvdG9bQ09OU1RSVUNUT1JdID0gUmVnRXhwO1xyXG4gICAgUmVnRXhwW1BST1RPVFlQRV0gPSBSZWdFeHBQcm90bztcclxuICAgIGhpZGRlbihnbG9iYWwsIFJFR0VYUCwgUmVnRXhwKTtcclxuICB9XHJcbiAgXHJcbiAgLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3MoKVxyXG4gIGlmKC8uL2cuZmxhZ3MgIT0gJ2cnKWRlZmluZVByb3BlcnR5KFJlZ0V4cFByb3RvLCAnZmxhZ3MnLCB7XHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGNyZWF0ZVJlcGxhY2VyKC9eLipcXC8oXFx3KikkLywgJyQxJylcclxuICB9KTtcclxuICBcclxuICBzZXRTcGVjaWVzKFJlZ0V4cCk7XHJcbn0oUmVnRXhwW1BST1RPVFlQRV0sIFJlZ0V4cCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IHdlYi5pbW1lZGlhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIHNldEltbWVkaWF0ZSBzaGltXHJcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIGVsc2U6XHJcbmlzRnVuY3Rpb24oc2V0SW1tZWRpYXRlKSAmJiBpc0Z1bmN0aW9uKGNsZWFySW1tZWRpYXRlKSB8fCBmdW5jdGlvbihPTlJFQURZU1RBVEVDSEFOR0Upe1xyXG4gIHZhciBwb3N0TWVzc2FnZSAgICAgID0gZ2xvYmFsLnBvc3RNZXNzYWdlXHJcbiAgICAsIGFkZEV2ZW50TGlzdGVuZXIgPSBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lclxyXG4gICAgLCBNZXNzYWdlQ2hhbm5lbCAgID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsXHJcbiAgICAsIGNvdW50ZXIgICAgICAgICAgPSAwXHJcbiAgICAsIHF1ZXVlICAgICAgICAgICAgPSB7fVxyXG4gICAgLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcclxuICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbihmbil7XHJcbiAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcclxuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XHJcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24oKXtcclxuICAgICAgaW52b2tlKGlzRnVuY3Rpb24oZm4pID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZGVmZXIoY291bnRlcik7XHJcbiAgICByZXR1cm4gY291bnRlcjtcclxuICB9XHJcbiAgY2xlYXJJbW1lZGlhdGUgPSBmdW5jdGlvbihpZCl7XHJcbiAgICBkZWxldGUgcXVldWVbaWRdO1xyXG4gIH1cclxuICBmdW5jdGlvbiBydW4oaWQpe1xyXG4gICAgaWYoaGFzKHF1ZXVlLCBpZCkpe1xyXG4gICAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XHJcbiAgICAgIGRlbGV0ZSBxdWV1ZVtpZF07XHJcbiAgICAgIGZuKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGxpc3RuZXIoZXZlbnQpe1xyXG4gICAgcnVuKGV2ZW50LmRhdGEpO1xyXG4gIH1cclxuICAvLyBOb2RlLmpzIDAuOC1cclxuICBpZihOT0RFKXtcclxuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xyXG4gICAgICBuZXh0VGljayhwYXJ0LmNhbGwocnVuLCBpZCkpO1xyXG4gICAgfVxyXG4gIC8vIE1vZGVybiBicm93c2Vycywgc2tpcCBpbXBsZW1lbnRhdGlvbiBmb3IgV2ViV29ya2Vyc1xyXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzIG9iamVjdFxyXG4gIH0gZWxzZSBpZihhZGRFdmVudExpc3RlbmVyICYmIGlzRnVuY3Rpb24ocG9zdE1lc3NhZ2UpICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyl7XHJcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcclxuICAgICAgcG9zdE1lc3NhZ2UoaWQsICcqJyk7XHJcbiAgICB9XHJcbiAgICBhZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdG5lciwgZmFsc2UpO1xyXG4gIC8vIFdlYldvcmtlcnNcclxuICB9IGVsc2UgaWYoaXNGdW5jdGlvbihNZXNzYWdlQ2hhbm5lbCkpe1xyXG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcclxuICAgIHBvcnQgICAgPSBjaGFubmVsLnBvcnQyO1xyXG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0bmVyO1xyXG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XHJcbiAgLy8gSUU4LVxyXG4gIH0gZWxzZSBpZihkb2N1bWVudCAmJiBPTlJFQURZU1RBVEVDSEFOR0UgaW4gZG9jdW1lbnRbQ1JFQVRFX0VMRU1FTlRdKCdzY3JpcHQnKSl7XHJcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcclxuICAgICAgaHRtbC5hcHBlbmRDaGlsZChkb2N1bWVudFtDUkVBVEVfRUxFTUVOVF0oJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcclxuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xyXG4gICAgICAgIHJ1bihpZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xyXG4gIH0gZWxzZSB7XHJcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcclxuICAgICAgc2V0VGltZW91dChydW4sIDAsIGlkKTtcclxuICAgIH1cclxuICB9XHJcbn0oJ29ucmVhZHlzdGF0ZWNoYW5nZScpO1xyXG4kZGVmaW5lKEdMT0JBTCArIEJJTkQsIHtcclxuICBzZXRJbW1lZGlhdGU6ICAgc2V0SW1tZWRpYXRlLFxyXG4gIGNsZWFySW1tZWRpYXRlOiBjbGVhckltbWVkaWF0ZVxyXG59KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2LnByb21pc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gRVM2IHByb21pc2VzIHNoaW1cclxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2dldGlmeS9uYXRpdmUtcHJvbWlzZS1vbmx5L1xyXG4hZnVuY3Rpb24oUHJvbWlzZSwgdGVzdCl7XHJcbiAgaXNGdW5jdGlvbihQcm9taXNlKSAmJiBpc0Z1bmN0aW9uKFByb21pc2UucmVzb2x2ZSlcclxuICAmJiBQcm9taXNlLnJlc29sdmUodGVzdCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKCl7fSkpID09IHRlc3RcclxuICB8fCBmdW5jdGlvbihhc2FwLCBSRUNPUkQpe1xyXG4gICAgZnVuY3Rpb24gaXNUaGVuYWJsZShpdCl7XHJcbiAgICAgIHZhciB0aGVuO1xyXG4gICAgICBpZihpc09iamVjdChpdCkpdGhlbiA9IGl0LnRoZW47XHJcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHRoZW4pID8gdGhlbiA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFuZGxlZFJlamVjdGlvbk9ySGFzT25SZWplY3RlZChwcm9taXNlKXtcclxuICAgICAgdmFyIHJlY29yZCA9IHByb21pc2VbUkVDT1JEXVxyXG4gICAgICAgICwgY2hhaW4gID0gcmVjb3JkLmNcclxuICAgICAgICAsIGkgICAgICA9IDBcclxuICAgICAgICAsIHJlYWN0O1xyXG4gICAgICBpZihyZWNvcmQuaClyZXR1cm4gdHJ1ZTtcclxuICAgICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSl7XHJcbiAgICAgICAgcmVhY3QgPSBjaGFpbltpKytdO1xyXG4gICAgICAgIGlmKHJlYWN0LmZhaWwgfHwgaGFuZGxlZFJlamVjdGlvbk9ySGFzT25SZWplY3RlZChyZWFjdC5QKSlyZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbm90aWZ5KHJlY29yZCwgcmVqZWN0KXtcclxuICAgICAgdmFyIGNoYWluID0gcmVjb3JkLmM7XHJcbiAgICAgIGlmKHJlamVjdCB8fCBjaGFpbi5sZW5ndGgpYXNhcChmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gcmVjb3JkLnBcclxuICAgICAgICAgICwgdmFsdWUgICA9IHJlY29yZC52XHJcbiAgICAgICAgICAsIG9rICAgICAgPSByZWNvcmQucyA9PSAxXHJcbiAgICAgICAgICAsIGkgICAgICAgPSAwO1xyXG4gICAgICAgIGlmKHJlamVjdCAmJiAhaGFuZGxlZFJlamVjdGlvbk9ySGFzT25SZWplY3RlZChwcm9taXNlKSl7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIGlmKCFoYW5kbGVkUmVqZWN0aW9uT3JIYXNPblJlamVjdGVkKHByb21pc2UpKXtcclxuICAgICAgICAgICAgICBpZihOT0RFKXtcclxuICAgICAgICAgICAgICAgIGlmKCFwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKSl7XHJcbiAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgbm9kZS5qcyBiZWhhdmlvclxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZihpc0Z1bmN0aW9uKGNvbnNvbGUuZXJyb3IpKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sIDFlMyk7XHJcbiAgICAgICAgfSBlbHNlIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpIWZ1bmN0aW9uKHJlYWN0KXtcclxuICAgICAgICAgIHZhciBjYiA9IG9rID8gcmVhY3Qub2sgOiByZWFjdC5mYWlsXHJcbiAgICAgICAgICAgICwgcmV0LCB0aGVuO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYoY2Ipe1xyXG4gICAgICAgICAgICAgIGlmKCFvaylyZWNvcmQuaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgcmV0ID0gY2IgPT09IHRydWUgPyB2YWx1ZSA6IGNiKHZhbHVlKTtcclxuICAgICAgICAgICAgICBpZihyZXQgPT09IHJlYWN0LlApe1xyXG4gICAgICAgICAgICAgICAgcmVhY3QucmVqKFR5cGVFcnJvcihQUk9NSVNFICsgJy1jaGFpbiBjeWNsZScpKTtcclxuICAgICAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmV0KSl7XHJcbiAgICAgICAgICAgICAgICB0aGVuLmNhbGwocmV0LCByZWFjdC5yZXMsIHJlYWN0LnJlaik7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHJlYWN0LnJlcyhyZXQpO1xyXG4gICAgICAgICAgICB9IGVsc2UgcmVhY3QucmVqKHZhbHVlKTtcclxuICAgICAgICAgIH0gY2F0Y2goZXJyKXtcclxuICAgICAgICAgICAgcmVhY3QucmVqKGVycik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfShjaGFpbltpKytdKTtcclxuICAgICAgICBjaGFpbi5sZW5ndGggPSAwO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlc29sdmUodmFsdWUpe1xyXG4gICAgICB2YXIgcmVjb3JkID0gdGhpc1xyXG4gICAgICAgICwgdGhlbiwgd3JhcHBlcjtcclxuICAgICAgaWYocmVjb3JkLmQpcmV0dXJuO1xyXG4gICAgICByZWNvcmQuZCA9IHRydWU7XHJcbiAgICAgIHJlY29yZCA9IHJlY29yZC5yIHx8IHJlY29yZDsgLy8gdW53cmFwXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKXtcclxuICAgICAgICAgIHdyYXBwZXIgPSB7cjogcmVjb3JkLCBkOiBmYWxzZX07IC8vIHdyYXBcclxuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgocmVqZWN0LCB3cmFwcGVyLCAxKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJlY29yZC52ID0gdmFsdWU7XHJcbiAgICAgICAgICByZWNvcmQucyA9IDE7XHJcbiAgICAgICAgICBub3RpZnkocmVjb3JkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2goZXJyKXtcclxuICAgICAgICByZWplY3QuY2FsbCh3cmFwcGVyIHx8IHtyOiByZWNvcmQsIGQ6IGZhbHNlfSwgZXJyKTsgLy8gd3JhcFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpe1xyXG4gICAgICB2YXIgcmVjb3JkID0gdGhpcztcclxuICAgICAgaWYocmVjb3JkLmQpcmV0dXJuO1xyXG4gICAgICByZWNvcmQuZCA9IHRydWU7XHJcbiAgICAgIHJlY29yZCA9IHJlY29yZC5yIHx8IHJlY29yZDsgLy8gdW53cmFwXHJcbiAgICAgIHJlY29yZC52ID0gdmFsdWU7XHJcbiAgICAgIHJlY29yZC5zID0gMjtcclxuICAgICAgbm90aWZ5KHJlY29yZCwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRDb25zdHJ1Y3RvcihDKXtcclxuICAgICAgdmFyIFMgPSBhc3NlcnRPYmplY3QoQylbU1lNQk9MX1NQRUNJRVNdO1xyXG4gICAgICByZXR1cm4gUyAhPSB1bmRlZmluZWQgPyBTIDogQztcclxuICAgIH1cclxuICAgIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXHJcbiAgICBQcm9taXNlID0gZnVuY3Rpb24oZXhlY3V0b3Ipe1xyXG4gICAgICBhc3NlcnRGdW5jdGlvbihleGVjdXRvcik7XHJcbiAgICAgIGFzc2VydEluc3RhbmNlKHRoaXMsIFByb21pc2UsIFBST01JU0UpO1xyXG4gICAgICB2YXIgcmVjb3JkID0ge1xyXG4gICAgICAgIHA6IHRoaXMsICAgICAgLy8gcHJvbWlzZVxyXG4gICAgICAgIGM6IFtdLCAgICAgICAgLy8gY2hhaW5cclxuICAgICAgICBzOiAwLCAgICAgICAgIC8vIHN0YXRlXHJcbiAgICAgICAgZDogZmFsc2UsICAgICAvLyBkb25lXHJcbiAgICAgICAgdjogdW5kZWZpbmVkLCAvLyB2YWx1ZVxyXG4gICAgICAgIGg6IGZhbHNlICAgICAgLy8gaGFuZGxlZCByZWplY3Rpb25cclxuICAgICAgfTtcclxuICAgICAgaGlkZGVuKHRoaXMsIFJFQ09SRCwgcmVjb3JkKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBleGVjdXRvcihjdHgocmVzb2x2ZSwgcmVjb3JkLCAxKSwgY3R4KHJlamVjdCwgcmVjb3JkLCAxKSk7XHJcbiAgICAgIH0gY2F0Y2goZXJyKXtcclxuICAgICAgICByZWplY3QuY2FsbChyZWNvcmQsIGVycik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGFzc2lnbkhpZGRlbihQcm9taXNlW1BST1RPVFlQRV0sIHtcclxuICAgICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcclxuICAgICAgdGhlbjogZnVuY3Rpb24ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpe1xyXG4gICAgICAgIHZhciBTID0gYXNzZXJ0T2JqZWN0KGFzc2VydE9iamVjdCh0aGlzKVtDT05TVFJVQ1RPUl0pW1NZTUJPTF9TUEVDSUVTXTtcclxuICAgICAgICB2YXIgcmVhY3QgPSB7XHJcbiAgICAgICAgICBvazogICBpc0Z1bmN0aW9uKG9uRnVsZmlsbGVkKSA/IG9uRnVsZmlsbGVkIDogdHJ1ZSxcclxuICAgICAgICAgIGZhaWw6IGlzRnVuY3Rpb24ob25SZWplY3RlZCkgID8gb25SZWplY3RlZCAgOiBmYWxzZVxyXG4gICAgICAgIH0gLCBQID0gcmVhY3QuUCA9IG5ldyAoUyAhPSB1bmRlZmluZWQgPyBTIDogUHJvbWlzZSkoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcclxuICAgICAgICAgIHJlYWN0LnJlcyA9IGFzc2VydEZ1bmN0aW9uKHJlc29sdmUpO1xyXG4gICAgICAgICAgcmVhY3QucmVqID0gYXNzZXJ0RnVuY3Rpb24ocmVqZWN0KTtcclxuICAgICAgICB9KSwgcmVjb3JkID0gdGhpc1tSRUNPUkRdO1xyXG4gICAgICAgIHJlY29yZC5jLnB1c2gocmVhY3QpO1xyXG4gICAgICAgIHJlY29yZC5zICYmIG5vdGlmeShyZWNvcmQpO1xyXG4gICAgICAgIHJldHVybiBQO1xyXG4gICAgICB9LFxyXG4gICAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxyXG4gICAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGVkKXtcclxuICAgICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgYXNzaWduSGlkZGVuKFByb21pc2UsIHtcclxuICAgICAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXHJcbiAgICAgIGFsbDogZnVuY3Rpb24oaXRlcmFibGUpe1xyXG4gICAgICAgIHZhciBQcm9taXNlID0gZ2V0Q29uc3RydWN0b3IodGhpcylcclxuICAgICAgICAgICwgdmFsdWVzICA9IFtdO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xyXG4gICAgICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBwdXNoLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgdmFyIHJlbWFpbmluZyA9IHZhbHVlcy5sZW5ndGhcclxuICAgICAgICAgICAgLCByZXN1bHRzICAgPSBBcnJheShyZW1haW5pbmcpO1xyXG4gICAgICAgICAgaWYocmVtYWluaW5nKWZvckVhY2guY2FsbCh2YWx1ZXMsIGZ1bmN0aW9uKHByb21pc2UsIGluZGV4KXtcclxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZShyZXN1bHRzKTtcclxuICAgICAgICAgICAgfSwgcmVqZWN0KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgZWxzZSByZXNvbHZlKHJlc3VsdHMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXHJcbiAgICAgIHJhY2U6IGZ1bmN0aW9uKGl0ZXJhYmxlKXtcclxuICAgICAgICB2YXIgUHJvbWlzZSA9IGdldENvbnN0cnVjdG9yKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xyXG4gICAgICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbihwcm9taXNlKXtcclxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHByb21pc2UpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxyXG4gICAgICByZWplY3Q6IGZ1bmN0aW9uKHIpe1xyXG4gICAgICAgIHJldHVybiBuZXcgKGdldENvbnN0cnVjdG9yKHRoaXMpKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xyXG4gICAgICAgICAgcmVqZWN0KHIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcclxuICAgICAgcmVzb2x2ZTogZnVuY3Rpb24oeCl7XHJcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIFJFQ09SRCBpbiB4ICYmIGdldFByb3RvdHlwZU9mKHgpID09PSB0aGlzW1BST1RPVFlQRV1cclxuICAgICAgICAgID8geCA6IG5ldyAoZ2V0Q29uc3RydWN0b3IodGhpcykpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XHJcbiAgICAgICAgICAgIHJlc29sdmUoeCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfShuZXh0VGljayB8fCBzZXRJbW1lZGlhdGUsIHNhZmVTeW1ib2woJ3JlY29yZCcpKTtcclxuICBzZXRUb1N0cmluZ1RhZyhQcm9taXNlLCBQUk9NSVNFKTtcclxuICBzZXRTcGVjaWVzKFByb21pc2UpO1xyXG4gICRkZWZpbmUoR0xPQkFMICsgRk9SQ0VEICogIWlzTmF0aXZlKFByb21pc2UpLCB7UHJvbWlzZTogUHJvbWlzZX0pO1xyXG59KGdsb2JhbFtQUk9NSVNFXSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5jb2xsZWN0aW9ucyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIEVDTUFTY3JpcHQgNiBjb2xsZWN0aW9ucyBzaGltXHJcbiFmdW5jdGlvbigpe1xyXG4gIHZhciBVSUQgICA9IHNhZmVTeW1ib2woJ3VpZCcpXHJcbiAgICAsIE8xICAgID0gc2FmZVN5bWJvbCgnTzEnKVxyXG4gICAgLCBXRUFLICA9IHNhZmVTeW1ib2woJ3dlYWsnKVxyXG4gICAgLCBMRUFLICA9IHNhZmVTeW1ib2woJ2xlYWsnKVxyXG4gICAgLCBMQVNUICA9IHNhZmVTeW1ib2woJ2xhc3QnKVxyXG4gICAgLCBGSVJTVCA9IHNhZmVTeW1ib2woJ2ZpcnN0JylcclxuICAgICwgU0laRSAgPSBERVNDID8gc2FmZVN5bWJvbCgnc2l6ZScpIDogJ3NpemUnXHJcbiAgICAsIHVpZCAgID0gMFxyXG4gICAgLCB0bXAgICA9IHt9O1xyXG4gIFxyXG4gIGZ1bmN0aW9uIGdldENvbGxlY3Rpb24oQywgTkFNRSwgbWV0aG9kcywgY29tbW9uTWV0aG9kcywgaXNNYXAsIGlzV2Vhayl7XHJcbiAgICB2YXIgQURERVIgPSBpc01hcCA/ICdzZXQnIDogJ2FkZCdcclxuICAgICAgLCBwcm90byA9IEMgJiYgQ1tQUk9UT1RZUEVdXHJcbiAgICAgICwgTyAgICAgPSB7fTtcclxuICAgIGZ1bmN0aW9uIGluaXRGcm9tSXRlcmFibGUodGhhdCwgaXRlcmFibGUpe1xyXG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIGlzTWFwLCB0aGF0W0FEREVSXSwgdGhhdCk7XHJcbiAgICAgIHJldHVybiB0aGF0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZml4U1ZaKGtleSwgY2hhaW4pe1xyXG4gICAgICB2YXIgbWV0aG9kID0gcHJvdG9ba2V5XTtcclxuICAgICAgaWYoZnJhbWV3b3JrKXByb3RvW2tleV0gPSBmdW5jdGlvbihhLCBiKXtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbWV0aG9kLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhLCBiKTtcclxuICAgICAgICByZXR1cm4gY2hhaW4gPyB0aGlzIDogcmVzdWx0O1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYoIWlzTmF0aXZlKEMpIHx8ICEoaXNXZWFrIHx8ICghQlVHR1lfSVRFUkFUT1JTICYmIGhhcyhwcm90bywgRk9SX0VBQ0gpICYmIGhhcyhwcm90bywgJ2VudHJpZXMnKSkpKXtcclxuICAgICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcclxuICAgICAgQyA9IGlzV2Vha1xyXG4gICAgICAgID8gZnVuY3Rpb24oaXRlcmFibGUpe1xyXG4gICAgICAgICAgICBhc3NlcnRJbnN0YW5jZSh0aGlzLCBDLCBOQU1FKTtcclxuICAgICAgICAgICAgc2V0KHRoaXMsIFVJRCwgdWlkKyspO1xyXG4gICAgICAgICAgICBpbml0RnJvbUl0ZXJhYmxlKHRoaXMsIGl0ZXJhYmxlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICA6IGZ1bmN0aW9uKGl0ZXJhYmxlKXtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICBhc3NlcnRJbnN0YW5jZSh0aGF0LCBDLCBOQU1FKTtcclxuICAgICAgICAgICAgc2V0KHRoYXQsIE8xLCBjcmVhdGUobnVsbCkpO1xyXG4gICAgICAgICAgICBzZXQodGhhdCwgU0laRSwgMCk7XHJcbiAgICAgICAgICAgIHNldCh0aGF0LCBMQVNULCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICBzZXQodGhhdCwgRklSU1QsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIGluaXRGcm9tSXRlcmFibGUodGhhdCwgaXRlcmFibGUpO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgYXNzaWduSGlkZGVuKGFzc2lnbkhpZGRlbihDW1BST1RPVFlQRV0sIG1ldGhvZHMpLCBjb21tb25NZXRob2RzKTtcclxuICAgICAgaXNXZWFrIHx8ICFERVNDIHx8IGRlZmluZVByb3BlcnR5KENbUFJPVE9UWVBFXSwgJ3NpemUnLCB7Z2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiBhc3NlcnREZWZpbmVkKHRoaXNbU0laRV0pO1xyXG4gICAgICB9fSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgTmF0aXZlID0gQ1xyXG4gICAgICAgICwgaW5zdCAgID0gbmV3IENcclxuICAgICAgICAsIGNoYWluICA9IGluc3RbQURERVJdKGlzV2VhayA/IHt9IDogLTAsIDEpXHJcbiAgICAgICAgLCBidWdneVplcm87XHJcbiAgICAgIC8vIHdyYXAgdG8gaW5pdCBjb2xsZWN0aW9ucyBmcm9tIGl0ZXJhYmxlXHJcbiAgICAgIGlmKGNoZWNrRGFuZ2VySXRlckNsb3NpbmcoZnVuY3Rpb24oTyl7IG5ldyBDKE8pIH0pKXtcclxuICAgICAgICBDID0gZnVuY3Rpb24oaXRlcmFibGUpe1xyXG4gICAgICAgICAgYXNzZXJ0SW5zdGFuY2UodGhpcywgQywgTkFNRSk7XHJcbiAgICAgICAgICByZXR1cm4gaW5pdEZyb21JdGVyYWJsZShuZXcgTmF0aXZlLCBpdGVyYWJsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIENbUFJPVE9UWVBFXSA9IHByb3RvO1xyXG4gICAgICAgIGlmKGZyYW1ld29yaylwcm90b1tDT05TVFJVQ1RPUl0gPSBDO1xyXG4gICAgICB9XHJcbiAgICAgIGlzV2VhayB8fCBpbnN0W0ZPUl9FQUNIXShmdW5jdGlvbih2YWwsIGtleSl7XHJcbiAgICAgICAgYnVnZ3laZXJvID0gMSAvIGtleSA9PT0gLUluZmluaXR5O1xyXG4gICAgICB9KTtcclxuICAgICAgLy8gZml4IGNvbnZlcnRpbmcgLTAga2V5IHRvICswXHJcbiAgICAgIGlmKGJ1Z2d5WmVybyl7XHJcbiAgICAgICAgZml4U1ZaKCdkZWxldGUnKTtcclxuICAgICAgICBmaXhTVlooJ2hhcycpO1xyXG4gICAgICAgIGlzTWFwICYmIGZpeFNWWignZ2V0Jyk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gKyBmaXggLmFkZCAmIC5zZXQgZm9yIGNoYWluaW5nXHJcbiAgICAgIGlmKGJ1Z2d5WmVybyB8fCBjaGFpbiAhPT0gaW5zdClmaXhTVlooQURERVIsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XHJcbiAgICBzZXRTcGVjaWVzKEMpO1xyXG4gICAgXHJcbiAgICBPW05BTUVdID0gQztcclxuICAgICRkZWZpbmUoR0xPQkFMICsgV1JBUCArIEZPUkNFRCAqICFpc05hdGl2ZShDKSwgTyk7XHJcbiAgICBcclxuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxyXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxyXG4gICAgaXNXZWFrIHx8IGRlZmluZVN0ZEl0ZXJhdG9ycyhDLCBOQU1FLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XHJcbiAgICAgIHNldCh0aGlzLCBJVEVSLCB7bzogaXRlcmF0ZWQsIGs6IGtpbmR9KTtcclxuICAgIH0sIGZ1bmN0aW9uKCl7XHJcbiAgICAgIHZhciBpdGVyICA9IHRoaXNbSVRFUl1cclxuICAgICAgICAsIGtpbmQgID0gaXRlci5rXHJcbiAgICAgICAgLCBlbnRyeSA9IGl0ZXIubDtcclxuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XHJcbiAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xyXG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxyXG4gICAgICBpZighaXRlci5vIHx8ICEoaXRlci5sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiBpdGVyLm9bRklSU1RdKSl7XHJcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cclxuICAgICAgICBpdGVyLm8gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmV0dXJuIGl0ZXJSZXN1bHQoMSk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxyXG4gICAgICBpZihraW5kID09IEtFWSkgIHJldHVybiBpdGVyUmVzdWx0KDAsIGVudHJ5LmspO1xyXG4gICAgICBpZihraW5kID09IFZBTFVFKXJldHVybiBpdGVyUmVzdWx0KDAsIGVudHJ5LnYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVyUmVzdWx0KDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7ICAgXHJcbiAgICB9LCBpc01hcCA/IEtFWStWQUxVRSA6IFZBTFVFLCAhaXNNYXApO1xyXG4gICAgXHJcbiAgICByZXR1cm4gQztcclxuICB9XHJcbiAgXHJcbiAgZnVuY3Rpb24gZmFzdEtleShpdCwgY3JlYXRlKXtcclxuICAgIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcclxuICAgIGlmKCFpc09iamVjdChpdCkpcmV0dXJuICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XHJcbiAgICAvLyBjYW4ndCBzZXQgaWQgdG8gZnJvemVuIG9iamVjdFxyXG4gICAgaWYoaXNGcm96ZW4oaXQpKXJldHVybiAnRic7XHJcbiAgICBpZighaGFzKGl0LCBVSUQpKXtcclxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgaWRcclxuICAgICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xyXG4gICAgICAvLyBhZGQgbWlzc2luZyBvYmplY3QgaWRcclxuICAgICAgaGlkZGVuKGl0LCBVSUQsICsrdWlkKTtcclxuICAgIC8vIHJldHVybiBvYmplY3QgaWQgd2l0aCBwcmVmaXhcclxuICAgIH0gcmV0dXJuICdPJyArIGl0W1VJRF07XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGdldEVudHJ5KHRoYXQsIGtleSl7XHJcbiAgICAvLyBmYXN0IGNhc2VcclxuICAgIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KSwgZW50cnk7XHJcbiAgICBpZihpbmRleCAhPSAnRicpcmV0dXJuIHRoYXRbTzFdW2luZGV4XTtcclxuICAgIC8vIGZyb3plbiBvYmplY3QgY2FzZVxyXG4gICAgZm9yKGVudHJ5ID0gdGhhdFtGSVJTVF07IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xyXG4gICAgICBpZihlbnRyeS5rID09IGtleSlyZXR1cm4gZW50cnk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGRlZih0aGF0LCBrZXksIHZhbHVlKXtcclxuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSlcclxuICAgICAgLCBwcmV2LCBpbmRleDtcclxuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxyXG4gICAgaWYoZW50cnkpZW50cnkudiA9IHZhbHVlO1xyXG4gICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHRoYXRbTEFTVF0gPSBlbnRyeSA9IHtcclxuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcclxuICAgICAgICBrOiBrZXksICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0ga2V5XHJcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXHJcbiAgICAgICAgcDogcHJldiA9IHRoYXRbTEFTVF0sICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XHJcbiAgICAgICAgbjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgIC8vIDwtIG5leHQgZW50cnlcclxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxyXG4gICAgICB9O1xyXG4gICAgICBpZighdGhhdFtGSVJTVF0pdGhhdFtGSVJTVF0gPSBlbnRyeTtcclxuICAgICAgaWYocHJldilwcmV2Lm4gPSBlbnRyeTtcclxuICAgICAgdGhhdFtTSVpFXSsrO1xyXG4gICAgICAvLyBhZGQgdG8gaW5kZXhcclxuICAgICAgaWYoaW5kZXggIT0gJ0YnKXRoYXRbTzFdW2luZGV4XSA9IGVudHJ5O1xyXG4gICAgfSByZXR1cm4gdGhhdDtcclxuICB9XHJcblxyXG4gIHZhciBjb2xsZWN0aW9uTWV0aG9kcyA9IHtcclxuICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxyXG4gICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXHJcbiAgICBjbGVhcjogZnVuY3Rpb24oKXtcclxuICAgICAgZm9yKHZhciB0aGF0ID0gdGhpcywgZGF0YSA9IHRoYXRbTzFdLCBlbnRyeSA9IHRoYXRbRklSU1RdOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcclxuICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcclxuICAgICAgICBpZihlbnRyeS5wKWVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XHJcbiAgICAgIH1cclxuICAgICAgdGhhdFtGSVJTVF0gPSB0aGF0W0xBU1RdID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGF0W1NJWkVdID0gMDtcclxuICAgIH0sXHJcbiAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXHJcbiAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcclxuICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xyXG4gICAgICB2YXIgdGhhdCAgPSB0aGlzXHJcbiAgICAgICAgLCBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XHJcbiAgICAgIGlmKGVudHJ5KXtcclxuICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5cclxuICAgICAgICAgICwgcHJldiA9IGVudHJ5LnA7XHJcbiAgICAgICAgZGVsZXRlIHRoYXRbTzFdW2VudHJ5LmldO1xyXG4gICAgICAgIGVudHJ5LnIgPSB0cnVlO1xyXG4gICAgICAgIGlmKHByZXYpcHJldi5uID0gbmV4dDtcclxuICAgICAgICBpZihuZXh0KW5leHQucCA9IHByZXY7XHJcbiAgICAgICAgaWYodGhhdFtGSVJTVF0gPT0gZW50cnkpdGhhdFtGSVJTVF0gPSBuZXh0O1xyXG4gICAgICAgIGlmKHRoYXRbTEFTVF0gPT0gZW50cnkpdGhhdFtMQVNUXSA9IHByZXY7XHJcbiAgICAgICAgdGhhdFtTSVpFXS0tO1xyXG4gICAgICB9IHJldHVybiAhIWVudHJ5O1xyXG4gICAgfSxcclxuICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxyXG4gICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXHJcbiAgICBmb3JFYWNoOiBmdW5jdGlvbihjYWxsYmFja2ZuIC8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcclxuICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdLCAzKVxyXG4gICAgICAgICwgZW50cnk7XHJcbiAgICAgIHdoaWxlKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpc1tGSVJTVF0pe1xyXG4gICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XHJcbiAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XHJcbiAgICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXHJcbiAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcclxuICAgIGhhczogZnVuY3Rpb24oa2V5KXtcclxuICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gMjMuMSBNYXAgT2JqZWN0c1xyXG4gIE1hcCA9IGdldENvbGxlY3Rpb24oTWFwLCBNQVAsIHtcclxuICAgIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcclxuICAgIGdldDogZnVuY3Rpb24oa2V5KXtcclxuICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhpcywga2V5KTtcclxuICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XHJcbiAgICB9LFxyXG4gICAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcclxuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XHJcbiAgICAgIHJldHVybiBkZWYodGhpcywga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH0sIGNvbGxlY3Rpb25NZXRob2RzLCB0cnVlKTtcclxuICBcclxuICAvLyAyMy4yIFNldCBPYmplY3RzXHJcbiAgU2V0ID0gZ2V0Q29sbGVjdGlvbihTZXQsIFNFVCwge1xyXG4gICAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXHJcbiAgICBhZGQ6IGZ1bmN0aW9uKHZhbHVlKXtcclxuICAgICAgcmV0dXJuIGRlZih0aGlzLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfSwgY29sbGVjdGlvbk1ldGhvZHMpO1xyXG4gIFxyXG4gIGZ1bmN0aW9uIGRlZldlYWsodGhhdCwga2V5LCB2YWx1ZSl7XHJcbiAgICBpZihpc0Zyb3plbihhc3NlcnRPYmplY3Qoa2V5KSkpbGVha1N0b3JlKHRoYXQpLnNldChrZXksIHZhbHVlKTtcclxuICAgIGVsc2Uge1xyXG4gICAgICBoYXMoa2V5LCBXRUFLKSB8fCBoaWRkZW4oa2V5LCBXRUFLLCB7fSk7XHJcbiAgICAgIGtleVtXRUFLXVt0aGF0W1VJRF1dID0gdmFsdWU7XHJcbiAgICB9IHJldHVybiB0aGF0O1xyXG4gIH1cclxuICBmdW5jdGlvbiBsZWFrU3RvcmUodGhhdCl7XHJcbiAgICByZXR1cm4gdGhhdFtMRUFLXSB8fCBoaWRkZW4odGhhdCwgTEVBSywgbmV3IE1hcClbTEVBS107XHJcbiAgfVxyXG4gIFxyXG4gIHZhciB3ZWFrTWV0aG9kcyA9IHtcclxuICAgIC8vIDIzLjMuMy4yIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXHJcbiAgICAvLyAyMy40LjMuMyBXZWFrU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXHJcbiAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcclxuICAgICAgaWYoIWlzT2JqZWN0KGtleSkpcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZihpc0Zyb3plbihrZXkpKXJldHVybiBsZWFrU3RvcmUodGhpcylbJ2RlbGV0ZSddKGtleSk7XHJcbiAgICAgIHJldHVybiBoYXMoa2V5LCBXRUFLKSAmJiBoYXMoa2V5W1dFQUtdLCB0aGlzW1VJRF0pICYmIGRlbGV0ZSBrZXlbV0VBS11bdGhpc1tVSURdXTtcclxuICAgIH0sXHJcbiAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxyXG4gICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxyXG4gICAgaGFzOiBmdW5jdGlvbihrZXkpe1xyXG4gICAgICBpZighaXNPYmplY3Qoa2V5KSlyZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmKGlzRnJvemVuKGtleSkpcmV0dXJuIGxlYWtTdG9yZSh0aGlzKS5oYXMoa2V5KTtcclxuICAgICAgcmV0dXJuIGhhcyhrZXksIFdFQUspICYmIGhhcyhrZXlbV0VBS10sIHRoaXNbVUlEXSk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBcclxuICAvLyAyMy4zIFdlYWtNYXAgT2JqZWN0c1xyXG4gIFdlYWtNYXAgPSBnZXRDb2xsZWN0aW9uKFdlYWtNYXAsIFdFQUtNQVAsIHtcclxuICAgIC8vIDIzLjMuMy4zIFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIGlmKGlzT2JqZWN0KGtleSkpe1xyXG4gICAgICAgIGlmKGlzRnJvemVuKGtleSkpcmV0dXJuIGxlYWtTdG9yZSh0aGlzKS5nZXQoa2V5KTtcclxuICAgICAgICBpZihoYXMoa2V5LCBXRUFLKSlyZXR1cm4ga2V5W1dFQUtdW3RoaXNbVUlEXV07XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvLyAyMy4zLjMuNSBXZWFrTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcclxuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XHJcbiAgICAgIHJldHVybiBkZWZXZWFrKHRoaXMsIGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH0sIHdlYWtNZXRob2RzLCB0cnVlLCB0cnVlKTtcclxuICBcclxuICAvLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XHJcbiAgaWYoZnJhbWV3b3JrICYmIG5ldyBXZWFrTWFwKCkuc2V0KE9iamVjdC5mcmVlemUodG1wKSwgNykuZ2V0KHRtcCkgIT0gNyl7XHJcbiAgICBmb3JFYWNoLmNhbGwoYXJyYXkoJ2RlbGV0ZSxoYXMsZ2V0LHNldCcpLCBmdW5jdGlvbihrZXkpe1xyXG4gICAgICB2YXIgbWV0aG9kID0gV2Vha01hcFtQUk9UT1RZUEVdW2tleV07XHJcbiAgICAgIFdlYWtNYXBbUFJPVE9UWVBFXVtrZXldID0gZnVuY3Rpb24oYSwgYil7XHJcbiAgICAgICAgLy8gc3RvcmUgZnJvemVuIG9iamVjdHMgb24gbGVha3kgbWFwXHJcbiAgICAgICAgaWYoaXNPYmplY3QoYSkgJiYgaXNGcm96ZW4oYSkpe1xyXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGxlYWtTdG9yZSh0aGlzKVtrZXldKGEsIGIpO1xyXG4gICAgICAgICAgcmV0dXJuIGtleSA9PSAnc2V0JyA/IHRoaXMgOiByZXN1bHQ7XHJcbiAgICAgICAgLy8gc3RvcmUgYWxsIHRoZSByZXN0IG9uIG5hdGl2ZSB3ZWFrbWFwXHJcbiAgICAgICAgfSByZXR1cm4gbWV0aG9kLmNhbGwodGhpcywgYSwgYik7XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICB9XHJcbiAgXHJcbiAgLy8gMjMuNCBXZWFrU2V0IE9iamVjdHNcclxuICBXZWFrU2V0ID0gZ2V0Q29sbGVjdGlvbihXZWFrU2V0LCBXRUFLU0VULCB7XHJcbiAgICAvLyAyMy40LjMuMSBXZWFrU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXHJcbiAgICBhZGQ6IGZ1bmN0aW9uKHZhbHVlKXtcclxuICAgICAgcmV0dXJuIGRlZldlYWsodGhpcywgdmFsdWUsIHRydWUpO1xyXG4gICAgfVxyXG4gIH0sIHdlYWtNZXRob2RzLCBmYWxzZSwgdHJ1ZSk7XHJcbn0oKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2LnJlZmxlY3QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKCl7XHJcbiAgZnVuY3Rpb24gRW51bWVyYXRlKGl0ZXJhdGVkKXtcclxuICAgIHZhciBrZXlzID0gW10sIGtleTtcclxuICAgIGZvcihrZXkgaW4gaXRlcmF0ZWQpa2V5cy5wdXNoKGtleSk7XHJcbiAgICBzZXQodGhpcywgSVRFUiwge286IGl0ZXJhdGVkLCBhOiBrZXlzLCBpOiAwfSk7XHJcbiAgfVxyXG4gIGNyZWF0ZUl0ZXJhdG9yKEVudW1lcmF0ZSwgT0JKRUNULCBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGl0ZXIgPSB0aGlzW0lURVJdXHJcbiAgICAgICwga2V5cyA9IGl0ZXIuYVxyXG4gICAgICAsIGtleTtcclxuICAgIGRvIHtcclxuICAgICAgaWYoaXRlci5pID49IGtleXMubGVuZ3RoKXJldHVybiBpdGVyUmVzdWx0KDEpO1xyXG4gICAgfSB3aGlsZSghKChrZXkgPSBrZXlzW2l0ZXIuaSsrXSkgaW4gaXRlci5vKSk7XHJcbiAgICByZXR1cm4gaXRlclJlc3VsdCgwLCBrZXkpO1xyXG4gIH0pO1xyXG4gIFxyXG4gIGZ1bmN0aW9uIHdyYXAoZm4pe1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGl0KXtcclxuICAgICAgYXNzZXJ0T2JqZWN0KGl0KTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpLCB0cnVlO1xyXG4gICAgICB9IGNhdGNoKGUpe1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICBmdW5jdGlvbiByZWZsZWN0R2V0KHRhcmdldCwgcHJvcGVydHlLZXkvKiwgcmVjZWl2ZXIqLyl7XHJcbiAgICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IGFyZ3VtZW50c1syXVxyXG4gICAgICAsIGRlc2MgPSBnZXRPd25EZXNjcmlwdG9yKGFzc2VydE9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSksIHByb3RvO1xyXG4gICAgaWYoZGVzYylyZXR1cm4gaGFzKGRlc2MsICd2YWx1ZScpXHJcbiAgICAgID8gZGVzYy52YWx1ZVxyXG4gICAgICA6IGRlc2MuZ2V0ID09PSB1bmRlZmluZWRcclxuICAgICAgICA/IHVuZGVmaW5lZFxyXG4gICAgICAgIDogZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XHJcbiAgICByZXR1cm4gaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKVxyXG4gICAgICA/IHJlZmxlY3RHZXQocHJvdG8sIHByb3BlcnR5S2V5LCByZWNlaXZlcilcclxuICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlZmxlY3RTZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgVi8qLCByZWNlaXZlciovKXtcclxuICAgIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCA0ID8gdGFyZ2V0IDogYXJndW1lbnRzWzNdXHJcbiAgICAgICwgb3duRGVzYyAgPSBnZXRPd25EZXNjcmlwdG9yKGFzc2VydE9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSlcclxuICAgICAgLCBleGlzdGluZ0Rlc2NyaXB0b3IsIHByb3RvO1xyXG4gICAgaWYoIW93bkRlc2Mpe1xyXG4gICAgICBpZihpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKXtcclxuICAgICAgICByZXR1cm4gcmVmbGVjdFNldChwcm90bywgcHJvcGVydHlLZXksIFYsIHJlY2VpdmVyKTtcclxuICAgICAgfVxyXG4gICAgICBvd25EZXNjID0gZGVzY3JpcHRvcigwKTtcclxuICAgIH1cclxuICAgIGlmKGhhcyhvd25EZXNjLCAndmFsdWUnKSl7XHJcbiAgICAgIGlmKG93bkRlc2Mud3JpdGFibGUgPT09IGZhbHNlIHx8ICFpc09iamVjdChyZWNlaXZlcikpcmV0dXJuIGZhbHNlO1xyXG4gICAgICBleGlzdGluZ0Rlc2NyaXB0b3IgPSBnZXRPd25EZXNjcmlwdG9yKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSkgfHwgZGVzY3JpcHRvcigwKTtcclxuICAgICAgZXhpc3RpbmdEZXNjcmlwdG9yLnZhbHVlID0gVjtcclxuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgZXhpc3RpbmdEZXNjcmlwdG9yKSwgdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBvd25EZXNjLnNldCA9PT0gdW5kZWZpbmVkXHJcbiAgICAgID8gZmFsc2VcclxuICAgICAgOiAob3duRGVzYy5zZXQuY2FsbChyZWNlaXZlciwgViksIHRydWUpO1xyXG4gIH1cclxuICB2YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCByZXR1cm5JdDtcclxuICBcclxuICB2YXIgcmVmbGVjdCA9IHtcclxuICAgIC8vIDI2LjEuMSBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KVxyXG4gICAgYXBwbHk6IGN0eChjYWxsLCBhcHBseSwgMyksXHJcbiAgICAvLyAyNi4xLjIgUmVmbGVjdC5jb25zdHJ1Y3QodGFyZ2V0LCBhcmd1bWVudHNMaXN0IFssIG5ld1RhcmdldF0pXHJcbiAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uKHRhcmdldCwgYXJndW1lbnRzTGlzdCAvKiwgbmV3VGFyZ2V0Ki8pe1xyXG4gICAgICB2YXIgcHJvdG8gICAgPSBhc3NlcnRGdW5jdGlvbihhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IGFyZ3VtZW50c1syXSlbUFJPVE9UWVBFXVxyXG4gICAgICAgICwgaW5zdGFuY2UgPSBjcmVhdGUoaXNPYmplY3QocHJvdG8pID8gcHJvdG8gOiBPYmplY3RQcm90bylcclxuICAgICAgICAsIHJlc3VsdCAgID0gYXBwbHkuY2FsbCh0YXJnZXQsIGluc3RhbmNlLCBhcmd1bWVudHNMaXN0KTtcclxuICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcclxuICAgIH0sXHJcbiAgICAvLyAyNi4xLjMgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKVxyXG4gICAgZGVmaW5lUHJvcGVydHk6IHdyYXAoZGVmaW5lUHJvcGVydHkpLFxyXG4gICAgLy8gMjYuMS40IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSlcclxuICAgIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbih0YXJnZXQsIHByb3BlcnR5S2V5KXtcclxuICAgICAgdmFyIGRlc2MgPSBnZXRPd25EZXNjcmlwdG9yKGFzc2VydE9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgIHJldHVybiBkZXNjICYmICFkZXNjLmNvbmZpZ3VyYWJsZSA/IGZhbHNlIDogZGVsZXRlIHRhcmdldFtwcm9wZXJ0eUtleV07XHJcbiAgICB9LFxyXG4gICAgLy8gMjYuMS41IFJlZmxlY3QuZW51bWVyYXRlKHRhcmdldClcclxuICAgIGVudW1lcmF0ZTogZnVuY3Rpb24odGFyZ2V0KXtcclxuICAgICAgcmV0dXJuIG5ldyBFbnVtZXJhdGUoYXNzZXJ0T2JqZWN0KHRhcmdldCkpO1xyXG4gICAgfSxcclxuICAgIC8vIDI2LjEuNiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5S2V5IFssIHJlY2VpdmVyXSlcclxuICAgIGdldDogcmVmbGVjdEdldCxcclxuICAgIC8vIDI2LjEuNyBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KVxyXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbih0YXJnZXQsIHByb3BlcnR5S2V5KXtcclxuICAgICAgcmV0dXJuIGdldE93bkRlc2NyaXB0b3IoYXNzZXJ0T2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcclxuICAgIH0sXHJcbiAgICAvLyAyNi4xLjggUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpXHJcbiAgICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24odGFyZ2V0KXtcclxuICAgICAgcmV0dXJuIGdldFByb3RvdHlwZU9mKGFzc2VydE9iamVjdCh0YXJnZXQpKTtcclxuICAgIH0sXHJcbiAgICAvLyAyNi4xLjkgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wZXJ0eUtleSlcclxuICAgIGhhczogZnVuY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eUtleSl7XHJcbiAgICAgIHJldHVybiBwcm9wZXJ0eUtleSBpbiB0YXJnZXQ7XHJcbiAgICB9LFxyXG4gICAgLy8gMjYuMS4xMCBSZWZsZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpXHJcbiAgICBpc0V4dGVuc2libGU6IGZ1bmN0aW9uKHRhcmdldCl7XHJcbiAgICAgIHJldHVybiAhIWlzRXh0ZW5zaWJsZShhc3NlcnRPYmplY3QodGFyZ2V0KSk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjYuMS4xMSBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxyXG4gICAgb3duS2V5czogb3duS2V5cyxcclxuICAgIC8vIDI2LjEuMTIgUmVmbGVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpXHJcbiAgICBwcmV2ZW50RXh0ZW5zaW9uczogd3JhcChPYmplY3QucHJldmVudEV4dGVuc2lvbnMgfHwgcmV0dXJuSXQpLFxyXG4gICAgLy8gMjYuMS4xMyBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIFssIHJlY2VpdmVyXSlcclxuICAgIHNldDogcmVmbGVjdFNldFxyXG4gIH1cclxuICAvLyAyNi4xLjE0IFJlZmxlY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcclxuICBpZihzZXRQcm90b3R5cGVPZilyZWZsZWN0LnNldFByb3RvdHlwZU9mID0gZnVuY3Rpb24odGFyZ2V0LCBwcm90byl7XHJcbiAgICByZXR1cm4gc2V0UHJvdG90eXBlT2YoYXNzZXJ0T2JqZWN0KHRhcmdldCksIHByb3RvKSwgdHJ1ZTtcclxuICB9O1xyXG4gIFxyXG4gICRkZWZpbmUoR0xPQkFMLCB7UmVmbGVjdDoge319KTtcclxuICAkZGVmaW5lKFNUQVRJQywgJ1JlZmxlY3QnLCByZWZsZWN0KTtcclxufSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczcucHJvcG9zYWxzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oKXtcclxuICAkZGVmaW5lKFBST1RPLCBBUlJBWSwge1xyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RvbWVuaWMvQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXHJcbiAgICBpbmNsdWRlczogY3JlYXRlQXJyYXlDb250YWlucyh0cnVlKVxyXG4gIH0pO1xyXG4gICRkZWZpbmUoUFJPVE8sIFNUUklORywge1xyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxyXG4gICAgYXQ6IGNyZWF0ZVBvaW50QXQodHJ1ZSlcclxuICB9KTtcclxuICBcclxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RUb0FycmF5KGlzRW50cmllcyl7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KXtcclxuICAgICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KG9iamVjdClcclxuICAgICAgICAsIGtleXMgICA9IGdldEtleXMob2JqZWN0KVxyXG4gICAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcclxuICAgICAgICAsIGkgICAgICA9IDBcclxuICAgICAgICAsIHJlc3VsdCA9IEFycmF5KGxlbmd0aClcclxuICAgICAgICAsIGtleTtcclxuICAgICAgaWYoaXNFbnRyaWVzKXdoaWxlKGxlbmd0aCA+IGkpcmVzdWx0W2ldID0gW2tleSA9IGtleXNbaSsrXSwgT1trZXldXTtcclxuICAgICAgZWxzZSB3aGlsZShsZW5ndGggPiBpKXJlc3VsdFtpXSA9IE9ba2V5c1tpKytdXTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICB9XHJcbiAgJGRlZmluZShTVEFUSUMsIE9CSkVDVCwge1xyXG4gICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi85MzUzNzgxXHJcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbihvYmplY3Qpe1xyXG4gICAgICB2YXIgTyAgICAgID0gdG9PYmplY3Qob2JqZWN0KVxyXG4gICAgICAgICwgcmVzdWx0ID0ge307XHJcbiAgICAgIGZvckVhY2guY2FsbChvd25LZXlzKE8pLCBmdW5jdGlvbihrZXkpe1xyXG4gICAgICAgIGRlZmluZVByb3BlcnR5KHJlc3VsdCwga2V5LCBkZXNjcmlwdG9yKDAsIGdldE93bkRlc2NyaXB0b3IoTywga2V5KSkpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcndhbGRyb24vdGMzOS1ub3Rlcy9ibG9iL21hc3Rlci9lczYvMjAxNC0wNC9hcHItOS5tZCM1MS1vYmplY3RlbnRyaWVzLW9iamVjdHZhbHVlc1xyXG4gICAgdmFsdWVzOiAgY3JlYXRlT2JqZWN0VG9BcnJheShmYWxzZSksXHJcbiAgICBlbnRyaWVzOiBjcmVhdGVPYmplY3RUb0FycmF5KHRydWUpXHJcbiAgfSk7XHJcbiAgJGRlZmluZShTVEFUSUMsIFJFR0VYUCwge1xyXG4gICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20va2FuZ2F4Lzk2OTgxMDBcclxuICAgIGVzY2FwZTogY3JlYXRlUmVwbGFjZXIoLyhbXFxcXFxcLVtcXF17fSgpKis/LixeJHxdKS9nLCAnXFxcXCQxJywgdHJ1ZSlcclxuICB9KTtcclxufSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczcuYWJzdHJhY3QtcmVmcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1hYnN0cmFjdC1yZWZzXHJcbiFmdW5jdGlvbihSRUZFUkVOQ0Upe1xyXG4gIFJFRkVSRU5DRV9HRVQgPSBnZXRXZWxsS25vd25TeW1ib2woUkVGRVJFTkNFKydHZXQnLCB0cnVlKTtcclxuICB2YXIgUkVGRVJFTkNFX1NFVCA9IGdldFdlbGxLbm93blN5bWJvbChSRUZFUkVOQ0UrU0VULCB0cnVlKVxyXG4gICAgLCBSRUZFUkVOQ0VfREVMRVRFID0gZ2V0V2VsbEtub3duU3ltYm9sKFJFRkVSRU5DRSsnRGVsZXRlJywgdHJ1ZSk7XHJcbiAgXHJcbiAgJGRlZmluZShTVEFUSUMsIFNZTUJPTCwge1xyXG4gICAgcmVmZXJlbmNlR2V0OiBSRUZFUkVOQ0VfR0VULFxyXG4gICAgcmVmZXJlbmNlU2V0OiBSRUZFUkVOQ0VfU0VULFxyXG4gICAgcmVmZXJlbmNlRGVsZXRlOiBSRUZFUkVOQ0VfREVMRVRFXHJcbiAgfSk7XHJcbiAgXHJcbiAgaGlkZGVuKEZ1bmN0aW9uUHJvdG8sIFJFRkVSRU5DRV9HRVQsIHJldHVyblRoaXMpO1xyXG4gIFxyXG4gIGZ1bmN0aW9uIHNldE1hcE1ldGhvZHMoQ29uc3RydWN0b3Ipe1xyXG4gICAgaWYoQ29uc3RydWN0b3Ipe1xyXG4gICAgICB2YXIgTWFwUHJvdG8gPSBDb25zdHJ1Y3RvcltQUk9UT1RZUEVdO1xyXG4gICAgICBoaWRkZW4oTWFwUHJvdG8sIFJFRkVSRU5DRV9HRVQsIE1hcFByb3RvLmdldCk7XHJcbiAgICAgIGhpZGRlbihNYXBQcm90bywgUkVGRVJFTkNFX1NFVCwgTWFwUHJvdG8uc2V0KTtcclxuICAgICAgaGlkZGVuKE1hcFByb3RvLCBSRUZFUkVOQ0VfREVMRVRFLCBNYXBQcm90b1snZGVsZXRlJ10pO1xyXG4gICAgfVxyXG4gIH1cclxuICBzZXRNYXBNZXRob2RzKE1hcCk7XHJcbiAgc2V0TWFwTWV0aG9kcyhXZWFrTWFwKTtcclxufSgncmVmZXJlbmNlJyk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGpzLmFycmF5LnN0YXRpY3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIEphdmFTY3JpcHQgMS42IC8gU3RyYXdtYW4gYXJyYXkgc3RhdGljcyBzaGltXHJcbiFmdW5jdGlvbihhcnJheVN0YXRpY3Mpe1xyXG4gIGZ1bmN0aW9uIHNldEFycmF5U3RhdGljcyhrZXlzLCBsZW5ndGgpe1xyXG4gICAgZm9yRWFjaC5jYWxsKGFycmF5KGtleXMpLCBmdW5jdGlvbihrZXkpe1xyXG4gICAgICBpZihrZXkgaW4gQXJyYXlQcm90bylhcnJheVN0YXRpY3Nba2V5XSA9IGN0eChjYWxsLCBBcnJheVByb3RvW2tleV0sIGxlbmd0aCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc2V0QXJyYXlTdGF0aWNzKCdwb3AscmV2ZXJzZSxzaGlmdCxrZXlzLHZhbHVlcyxlbnRyaWVzJywgMSk7XHJcbiAgc2V0QXJyYXlTdGF0aWNzKCdpbmRleE9mLGV2ZXJ5LHNvbWUsZm9yRWFjaCxtYXAsZmlsdGVyLGZpbmQsZmluZEluZGV4LGluY2x1ZGVzJywgMyk7XHJcbiAgc2V0QXJyYXlTdGF0aWNzKCdqb2luLHNsaWNlLGNvbmNhdCxwdXNoLHNwbGljZSx1bnNoaWZ0LHNvcnQsbGFzdEluZGV4T2YsJyArXHJcbiAgICAgICAgICAgICAgICAgICdyZWR1Y2UscmVkdWNlUmlnaHQsY29weVdpdGhpbixmaWxsLHR1cm4nKTtcclxuICAkZGVmaW5lKFNUQVRJQywgQVJSQVksIGFycmF5U3RhdGljcyk7XHJcbn0oe30pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiB3ZWIuZG9tLml0YXJhYmxlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oTm9kZUxpc3Qpe1xyXG4gIGlmKGZyYW1ld29yayAmJiBOb2RlTGlzdCAmJiAhKFNZTUJPTF9JVEVSQVRPUiBpbiBOb2RlTGlzdFtQUk9UT1RZUEVdKSl7XHJcbiAgICBoaWRkZW4oTm9kZUxpc3RbUFJPVE9UWVBFXSwgU1lNQk9MX0lURVJBVE9SLCBJdGVyYXRvcnNbQVJSQVldKTtcclxuICB9XHJcbiAgSXRlcmF0b3JzLk5vZGVMaXN0ID0gSXRlcmF0b3JzW0FSUkFZXTtcclxufShnbG9iYWwuTm9kZUxpc3QpO1xufSh0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKSwgdHJ1ZSk7IiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgaXRlcmF0b3JTeW1ib2wgPVxuICAgIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgcmV0dXJuIG5ldyBHZW5lcmF0b3IoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiB8fCBudWxsLCB0cnlMb2NzTGlzdCB8fCBbXSk7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW5lcmF0b3IgPSB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KTtcbiAgICAgIHZhciBjYWxsTmV4dCA9IHN0ZXAuYmluZChnZW5lcmF0b3IubmV4dCk7XG4gICAgICB2YXIgY2FsbFRocm93ID0gc3RlcC5iaW5kKGdlbmVyYXRvcltcInRocm93XCJdKTtcblxuICAgICAgZnVuY3Rpb24gc3RlcChhcmcpIHtcbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKHRoaXMsIG51bGwsIGFyZyk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgIHJlc29sdmUoaW5mby52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGluZm8udmFsdWUpLnRoZW4oY2FsbE5leHQsIGNhbGxUaHJvdyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2FsbE5leHQoKTtcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBHZW5lcmF0b3IoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgZ2VuZXJhdG9yID0gb3V0ZXJGbiA/IE9iamVjdC5jcmVhdGUob3V0ZXJGbi5wcm90b3R5cGUpIDogdGhpcztcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0KTtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdLFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3IsXG4gICAgICAgICAgICBhcmdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBMaWtlIHJldHVybmluZyBnZW5lcmF0b3IudGhyb3codW5jYXVnaHQpLCBidXQgd2l0aG91dCB0aGVcbiAgICAgICAgICAgIC8vIG92ZXJoZWFkIG9mIGFuIGV4dHJhIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWxlZ2F0ZSBnZW5lcmF0b3IgcmFuIGFuZCBoYW5kbGVkIGl0cyBvd24gZXhjZXB0aW9ucyBzb1xuICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUgbWV0aG9kIHdhcywgd2UgY29udGludWUgYXMgaWYgaXQgaXNcbiAgICAgICAgICAvLyBcIm5leHRcIiB3aXRoIGFuIHVuZGVmaW5lZCBhcmcuXG4gICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCAmJlxuICAgICAgICAgICAgICB0eXBlb2YgYXJnICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBcImF0dGVtcHQgdG8gc2VuZCBcIiArIEpTT04uc3RyaW5naWZ5KGFyZykgKyBcIiB0byBuZXdib3JuIGdlbmVyYXRvclwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCkge1xuICAgICAgICAgICAgY29udGV4dC5zZW50ID0gYXJnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgY29udGV4dC5zZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5kZWxlZ2F0ZSAmJiBtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcblxuICAgICAgICAgIGlmIChtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKHJlY29yZC5hcmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGdlbmVyYXRvci5uZXh0ID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcIm5leHRcIik7XG4gICAgZ2VuZXJhdG9yW1widGhyb3dcIl0gPSBpbnZva2UuYmluZChnZW5lcmF0b3IsIFwidGhyb3dcIik7XG4gICAgZ2VuZXJhdG9yW1wicmV0dXJuXCJdID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcInJldHVyblwiKTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cblxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgdGhpcy5zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIC8vIFByZS1pbml0aWFsaXplIGF0IGxlYXN0IDIwIHRlbXBvcmFyeSB2YXJpYWJsZXMgdG8gZW5hYmxlIGhpZGRlblxuICAgICAgLy8gY2xhc3Mgb3B0aW1pemF0aW9ucyBmb3Igc2ltcGxlIGdlbmVyYXRvcnMuXG4gICAgICBmb3IgKHZhciB0ZW1wSW5kZXggPSAwLCB0ZW1wTmFtZTtcbiAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgdGVtcE5hbWUgPSBcInRcIiArIHRlbXBJbmRleCkgfHwgdGVtcEluZGV4IDwgMjA7XG4gICAgICAgICAgICsrdGVtcEluZGV4KSB7XG4gICAgICAgIHRoaXNbdGVtcE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDwgZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBBbW9uZyB0aGUgdmFyaW91cyB0cmlja3MgZm9yIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsXG4gIC8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuICAvLyB1c2UgaW5kaXJlY3QgZXZhbCAod2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6IHRoaXNcbik7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWlZV0psYkM5dWIyUmxYMjF2WkhWc1pYTXZjbVZuWlc1bGNtRjBiM0l0WW1GaVpXd3ZjblZ1ZEdsdFpTNXFjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRWlMQ0ptYVd4bElqb2laMlZ1WlhKaGRHVmtMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWk4cUtseHVJQ29nUTI5d2VYSnBaMmgwSUNoaktTQXlNREUwTENCR1lXTmxZbTl2YXl3Z1NXNWpMbHh1SUNvZ1FXeHNJSEpwWjJoMGN5QnlaWE5sY25abFpDNWNiaUFxWEc0Z0tpQlVhR2x6SUhOdmRYSmpaU0JqYjJSbElHbHpJR3hwWTJWdWMyVmtJSFZ1WkdWeUlIUm9aU0JDVTBRdGMzUjViR1VnYkdsalpXNXpaU0JtYjNWdVpDQnBiaUIwYUdWY2JpQXFJR2gwZEhCek9pOHZjbUYzTG1kcGRHaDFZaTVqYjIwdlptRmpaV0p2YjJzdmNtVm5aVzVsY21GMGIzSXZiV0Z6ZEdWeUwweEpRMFZPVTBVZ1ptbHNaUzRnUVc1Y2JpQXFJR0ZrWkdsMGFXOXVZV3dnWjNKaGJuUWdiMllnY0dGMFpXNTBJSEpwWjJoMGN5QmpZVzRnWW1VZ1ptOTFibVFnYVc0Z2RHaGxJRkJCVkVWT1ZGTWdabWxzWlNCcGJseHVJQ29nZEdobElITmhiV1VnWkdseVpXTjBiM0o1TGx4dUlDb3ZYRzVjYmlFb1puVnVZM1JwYjI0b1oyeHZZbUZzS1NCN1hHNGdJRndpZFhObElITjBjbWxqZEZ3aU8xeHVYRzRnSUhaaGNpQm9ZWE5QZDI0Z1BTQlBZbXBsWTNRdWNISnZkRzkwZVhCbExtaGhjMDkzYmxCeWIzQmxjblI1TzF4dUlDQjJZWElnZFc1a1pXWnBibVZrT3lBdkx5Qk5iM0psSUdOdmJYQnlaWE56YVdKc1pTQjBhR0Z1SUhadmFXUWdNQzVjYmlBZ2RtRnlJR2wwWlhKaGRHOXlVM2x0WW05c0lEMWNiaUFnSUNCMGVYQmxiMllnVTNsdFltOXNJRDA5UFNCY0ltWjFibU4wYVc5dVhDSWdKaVlnVTNsdFltOXNMbWwwWlhKaGRHOXlJSHg4SUZ3aVFFQnBkR1Z5WVhSdmNsd2lPMXh1WEc0Z0lIWmhjaUJwYmsxdlpIVnNaU0E5SUhSNWNHVnZaaUJ0YjJSMWJHVWdQVDA5SUZ3aWIySnFaV04wWENJN1hHNGdJSFpoY2lCeWRXNTBhVzFsSUQwZ1oyeHZZbUZzTG5KbFoyVnVaWEpoZEc5eVVuVnVkR2x0WlR0Y2JpQWdhV1lnS0hKMWJuUnBiV1VwSUh0Y2JpQWdJQ0JwWmlBb2FXNU5iMlIxYkdVcElIdGNiaUFnSUNBZ0lDOHZJRWxtSUhKbFoyVnVaWEpoZEc5eVVuVnVkR2x0WlNCcGN5QmtaV1pwYm1Wa0lHZHNiMkpoYkd4NUlHRnVaQ0IzWlNkeVpTQnBiaUJoSUcxdlpIVnNaU3hjYmlBZ0lDQWdJQzh2SUcxaGEyVWdkR2hsSUdWNGNHOXlkSE1nYjJKcVpXTjBJR2xrWlc1MGFXTmhiQ0IwYnlCeVpXZGxibVZ5WVhSdmNsSjFiblJwYldVdVhHNGdJQ0FnSUNCdGIyUjFiR1V1Wlhod2IzSjBjeUE5SUhKMWJuUnBiV1U3WEc0Z0lDQWdmVnh1SUNBZ0lDOHZJRVJ2YmlkMElHSnZkR2hsY2lCbGRtRnNkV0YwYVc1bklIUm9aU0J5WlhOMElHOW1JSFJvYVhNZ1ptbHNaU0JwWmlCMGFHVWdjblZ1ZEdsdFpTQjNZWE5jYmlBZ0lDQXZMeUJoYkhKbFlXUjVJR1JsWm1sdVpXUWdaMnh2WW1Gc2JIa3VYRzRnSUNBZ2NtVjBkWEp1TzF4dUlDQjlYRzVjYmlBZ0x5OGdSR1ZtYVc1bElIUm9aU0J5ZFc1MGFXMWxJR2RzYjJKaGJHeDVJQ2hoY3lCbGVIQmxZM1JsWkNCaWVTQm5aVzVsY21GMFpXUWdZMjlrWlNrZ1lYTWdaV2wwYUdWeVhHNGdJQzh2SUcxdlpIVnNaUzVsZUhCdmNuUnpJQ2hwWmlCM1pTZHlaU0JwYmlCaElHMXZaSFZzWlNrZ2IzSWdZU0J1Wlhjc0lHVnRjSFI1SUc5aWFtVmpkQzVjYmlBZ2NuVnVkR2x0WlNBOUlHZHNiMkpoYkM1eVpXZGxibVZ5WVhSdmNsSjFiblJwYldVZ1BTQnBiazF2WkhWc1pTQS9JRzF2WkhWc1pTNWxlSEJ2Y25SeklEb2dlMzA3WEc1Y2JpQWdablZ1WTNScGIyNGdkM0poY0NocGJtNWxja1p1TENCdmRYUmxja1p1TENCelpXeG1MQ0IwY25sTWIyTnpUR2x6ZENrZ2UxeHVJQ0FnSUhKbGRIVnliaUJ1WlhjZ1IyVnVaWEpoZEc5eUtHbHVibVZ5Um00c0lHOTFkR1Z5Um00c0lITmxiR1lnZkh3Z2JuVnNiQ3dnZEhKNVRHOWpjMHhwYzNRZ2ZId2dXMTBwTzF4dUlDQjlYRzRnSUhKMWJuUnBiV1V1ZDNKaGNDQTlJSGR5WVhBN1hHNWNiaUFnTHk4Z1ZISjVMMk5oZEdOb0lHaGxiSEJsY2lCMGJ5QnRhVzVwYldsNlpTQmtaVzl3ZEdsdGFYcGhkR2x2Ym5NdUlGSmxkSFZ5Ym5NZ1lTQmpiMjF3YkdWMGFXOXVYRzRnSUM4dklISmxZMjl5WkNCc2FXdGxJR052Ym5SbGVIUXVkSEo1Ulc1MGNtbGxjMXRwWFM1amIyMXdiR1YwYVc5dUxpQlVhR2x6SUdsdWRHVnlabUZqWlNCamIzVnNaRnh1SUNBdkx5Qm9ZWFpsSUdKbFpXNGdLR0Z1WkNCM1lYTWdjSEpsZG1sdmRYTnNlU2tnWkdWemFXZHVaV1FnZEc4Z2RHRnJaU0JoSUdOc2IzTjFjbVVnZEc4Z1ltVmNiaUFnTHk4Z2FXNTJiMnRsWkNCM2FYUm9iM1YwSUdGeVozVnRaVzUwY3l3Z1luVjBJR2x1SUdGc2JDQjBhR1VnWTJGelpYTWdkMlVnWTJGeVpTQmhZbTkxZENCM1pWeHVJQ0F2THlCaGJISmxZV1I1SUdoaGRtVWdZVzRnWlhocGMzUnBibWNnYldWMGFHOWtJSGRsSUhkaGJuUWdkRzhnWTJGc2JDd2djMjhnZEdobGNtVW5jeUJ1YnlCdVpXVmtYRzRnSUM4dklIUnZJR055WldGMFpTQmhJRzVsZHlCbWRXNWpkR2x2YmlCdlltcGxZM1F1SUZkbElHTmhiaUJsZG1WdUlHZGxkQ0JoZDJGNUlIZHBkR2dnWVhOemRXMXBibWRjYmlBZ0x5OGdkR2hsSUcxbGRHaHZaQ0IwWVd0bGN5QmxlR0ZqZEd4NUlHOXVaU0JoY21kMWJXVnVkQ3dnYzJsdVkyVWdkR2hoZENCb1lYQndaVzV6SUhSdklHSmxJSFJ5ZFdWY2JpQWdMeThnYVc0Z1pYWmxjbmtnWTJGelpTd2djMjhnZDJVZ1pHOXVKM1FnYUdGMlpTQjBieUIwYjNWamFDQjBhR1VnWVhKbmRXMWxiblJ6SUc5aWFtVmpkQzRnVkdobFhHNGdJQzh2SUc5dWJIa2dZV1JrYVhScGIyNWhiQ0JoYkd4dlkyRjBhVzl1SUhKbGNYVnBjbVZrSUdseklIUm9aU0JqYjIxd2JHVjBhVzl1SUhKbFkyOXlaQ3dnZDJocFkyaGNiaUFnTHk4Z2FHRnpJR0VnYzNSaFlteGxJSE5vWVhCbElHRnVaQ0J6YnlCb2IzQmxablZzYkhrZ2MyaHZkV3hrSUdKbElHTm9aV0Z3SUhSdklHRnNiRzlqWVhSbExseHVJQ0JtZFc1amRHbHZiaUIwY25sRFlYUmphQ2htYml3Z2IySnFMQ0JoY21jcElIdGNiaUFnSUNCMGNua2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlIc2dkSGx3WlRvZ1hDSnViM0p0WVd4Y0lpd2dZWEpuT2lCbWJpNWpZV3hzS0c5aWFpd2dZWEpuS1NCOU8xeHVJQ0FnSUgwZ1kyRjBZMmdnS0dWeWNpa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlIc2dkSGx3WlRvZ1hDSjBhSEp2ZDF3aUxDQmhjbWM2SUdWeWNpQjlPMXh1SUNBZ0lIMWNiaUFnZlZ4dVhHNGdJSFpoY2lCSFpXNVRkR0YwWlZOMWMzQmxibVJsWkZOMFlYSjBJRDBnWENKemRYTndaVzVrWldSVGRHRnlkRndpTzF4dUlDQjJZWElnUjJWdVUzUmhkR1ZUZFhOd1pXNWtaV1JaYVdWc1pDQTlJRndpYzNWemNHVnVaR1ZrV1dsbGJHUmNJanRjYmlBZ2RtRnlJRWRsYmxOMFlYUmxSWGhsWTNWMGFXNW5JRDBnWENKbGVHVmpkWFJwYm1kY0lqdGNiaUFnZG1GeUlFZGxibE4wWVhSbFEyOXRjR3hsZEdWa0lEMGdYQ0pqYjIxd2JHVjBaV1JjSWp0Y2JseHVJQ0F2THlCU1pYUjFjbTVwYm1jZ2RHaHBjeUJ2WW1wbFkzUWdabkp2YlNCMGFHVWdhVzV1WlhKR2JpQm9ZWE1nZEdobElITmhiV1VnWldabVpXTjBJR0Z6WEc0Z0lDOHZJR0p5WldGcmFXNW5JRzkxZENCdlppQjBhR1VnWkdsemNHRjBZMmdnYzNkcGRHTm9JSE4wWVhSbGJXVnVkQzVjYmlBZ2RtRnlJRU52Ym5ScGJuVmxVMlZ1ZEdsdVpXd2dQU0I3ZlR0Y2JseHVJQ0F2THlCRWRXMXRlU0JqYjI1emRISjFZM1J2Y2lCbWRXNWpkR2x2Ym5NZ2RHaGhkQ0IzWlNCMWMyVWdZWE1nZEdobElDNWpiMjV6ZEhKMVkzUnZjaUJoYm1SY2JpQWdMeThnTG1OdmJuTjBjblZqZEc5eUxuQnliM1J2ZEhsd1pTQndjbTl3WlhKMGFXVnpJR1p2Y2lCbWRXNWpkR2x2Ym5NZ2RHaGhkQ0J5WlhSMWNtNGdSMlZ1WlhKaGRHOXlYRzRnSUM4dklHOWlhbVZqZEhNdUlFWnZjaUJtZFd4c0lITndaV01nWTI5dGNHeHBZVzVqWlN3Z2VXOTFJRzFoZVNCM2FYTm9JSFJ2SUdOdmJtWnBaM1Z5WlNCNWIzVnlYRzRnSUM4dklHMXBibWxtYVdWeUlHNXZkQ0IwYnlCdFlXNW5iR1VnZEdobElHNWhiV1Z6SUc5bUlIUm9aWE5sSUhSM2J5Qm1kVzVqZEdsdmJuTXVYRzRnSUdaMWJtTjBhVzl1SUVkbGJtVnlZWFJ2Y2taMWJtTjBhVzl1S0NrZ2UzMWNiaUFnWm5WdVkzUnBiMjRnUjJWdVpYSmhkRzl5Um5WdVkzUnBiMjVRY205MGIzUjVjR1VvS1NCN2ZWeHVYRzRnSUhaaGNpQkhjQ0E5SUVkbGJtVnlZWFJ2Y2taMWJtTjBhVzl1VUhKdmRHOTBlWEJsTG5CeWIzUnZkSGx3WlNBOUlFZGxibVZ5WVhSdmNpNXdjbTkwYjNSNWNHVTdYRzRnSUVkbGJtVnlZWFJ2Y2taMWJtTjBhVzl1TG5CeWIzUnZkSGx3WlNBOUlFZHdMbU52Ym5OMGNuVmpkRzl5SUQwZ1IyVnVaWEpoZEc5eVJuVnVZM1JwYjI1UWNtOTBiM1I1Y0dVN1hHNGdJRWRsYm1WeVlYUnZja1oxYm1OMGFXOXVVSEp2ZEc5MGVYQmxMbU52Ym5OMGNuVmpkRzl5SUQwZ1IyVnVaWEpoZEc5eVJuVnVZM1JwYjI0N1hHNGdJRWRsYm1WeVlYUnZja1oxYm1OMGFXOXVMbVJwYzNCc1lYbE9ZVzFsSUQwZ1hDSkhaVzVsY21GMGIzSkdkVzVqZEdsdmJsd2lPMXh1WEc0Z0lISjFiblJwYldVdWFYTkhaVzVsY21GMGIzSkdkVzVqZEdsdmJpQTlJR1oxYm1OMGFXOXVLR2RsYmtaMWJpa2dlMXh1SUNBZ0lIWmhjaUJqZEc5eUlEMGdkSGx3Wlc5bUlHZGxia1oxYmlBOVBUMGdYQ0ptZFc1amRHbHZibHdpSUNZbUlHZGxia1oxYmk1amIyNXpkSEoxWTNSdmNqdGNiaUFnSUNCeVpYUjFjbTRnWTNSdmNseHVJQ0FnSUNBZ1B5QmpkRzl5SUQwOVBTQkhaVzVsY21GMGIzSkdkVzVqZEdsdmJpQjhmRnh1SUNBZ0lDQWdJQ0F2THlCR2IzSWdkR2hsSUc1aGRHbDJaU0JIWlc1bGNtRjBiM0pHZFc1amRHbHZiaUJqYjI1emRISjFZM1J2Y2l3Z2RHaGxJR0psYzNRZ2QyVWdZMkZ1WEc0Z0lDQWdJQ0FnSUM4dklHUnZJR2x6SUhSdklHTm9aV05ySUdsMGN5QXVibUZ0WlNCd2NtOXdaWEowZVM1Y2JpQWdJQ0FnSUNBZ0tHTjBiM0l1WkdsemNHeGhlVTVoYldVZ2ZId2dZM1J2Y2k1dVlXMWxLU0E5UFQwZ1hDSkhaVzVsY21GMGIzSkdkVzVqZEdsdmJsd2lYRzRnSUNBZ0lDQTZJR1poYkhObE8xeHVJQ0I5TzF4dVhHNGdJSEoxYm5ScGJXVXViV0Z5YXlBOUlHWjFibU4wYVc5dUtHZGxia1oxYmlrZ2UxeHVJQ0FnSUdkbGJrWjFiaTVmWDNCeWIzUnZYMThnUFNCSFpXNWxjbUYwYjNKR2RXNWpkR2x2YmxCeWIzUnZkSGx3WlR0Y2JpQWdJQ0JuWlc1R2RXNHVjSEp2ZEc5MGVYQmxJRDBnVDJKcVpXTjBMbU55WldGMFpTaEhjQ2s3WEc0Z0lDQWdjbVYwZFhKdUlHZGxia1oxYmp0Y2JpQWdmVHRjYmx4dUlDQnlkVzUwYVcxbExtRnplVzVqSUQwZ1puVnVZM1JwYjI0b2FXNXVaWEpHYml3Z2IzVjBaWEpHYml3Z2MyVnNaaXdnZEhKNVRHOWpjMHhwYzNRcElIdGNiaUFnSUNCeVpYUjFjbTRnYm1WM0lGQnliMjFwYzJVb1puVnVZM1JwYjI0b2NtVnpiMngyWlN3Z2NtVnFaV04wS1NCN1hHNGdJQ0FnSUNCMllYSWdaMlZ1WlhKaGRHOXlJRDBnZDNKaGNDaHBibTVsY2tadUxDQnZkWFJsY2tadUxDQnpaV3htTENCMGNubE1iMk56VEdsemRDazdYRzRnSUNBZ0lDQjJZWElnWTJGc2JFNWxlSFFnUFNCemRHVndMbUpwYm1Rb1oyVnVaWEpoZEc5eUxtNWxlSFFwTzF4dUlDQWdJQ0FnZG1GeUlHTmhiR3hVYUhKdmR5QTlJSE4wWlhBdVltbHVaQ2huWlc1bGNtRjBiM0piWENKMGFISnZkMXdpWFNrN1hHNWNiaUFnSUNBZ0lHWjFibU4wYVc5dUlITjBaWEFvWVhKbktTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCeVpXTnZjbVFnUFNCMGNubERZWFJqYUNoMGFHbHpMQ0J1ZFd4c0xDQmhjbWNwTzF4dUlDQWdJQ0FnSUNCcFppQW9jbVZqYjNKa0xuUjVjR1VnUFQwOUlGd2lkR2h5YjNkY0lpa2dlMXh1SUNBZ0lDQWdJQ0FnSUhKbGFtVmpkQ2h5WldOdmNtUXVZWEpuS1R0Y2JpQWdJQ0FnSUNBZ0lDQnlaWFIxY200N1hHNGdJQ0FnSUNBZ0lIMWNibHh1SUNBZ0lDQWdJQ0IyWVhJZ2FXNW1ieUE5SUhKbFkyOXlaQzVoY21jN1hHNGdJQ0FnSUNBZ0lHbG1JQ2hwYm1adkxtUnZibVVwSUh0Y2JpQWdJQ0FnSUNBZ0lDQnlaWE52YkhabEtHbHVabTh1ZG1Gc2RXVXBPMXh1SUNBZ0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0FnSUZCeWIyMXBjMlV1Y21WemIyeDJaU2hwYm1adkxuWmhiSFZsS1M1MGFHVnVLR05oYkd4T1pYaDBMQ0JqWVd4c1ZHaHliM2NwTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lHTmhiR3hPWlhoMEtDazdYRzRnSUNBZ2ZTazdYRzRnSUgwN1hHNWNiaUFnWm5WdVkzUnBiMjRnUjJWdVpYSmhkRzl5S0dsdWJtVnlSbTRzSUc5MWRHVnlSbTRzSUhObGJHWXNJSFJ5ZVV4dlkzTk1hWE4wS1NCN1hHNGdJQ0FnZG1GeUlHZGxibVZ5WVhSdmNpQTlJRzkxZEdWeVJtNGdQeUJQWW1wbFkzUXVZM0psWVhSbEtHOTFkR1Z5Um00dWNISnZkRzkwZVhCbEtTQTZJSFJvYVhNN1hHNGdJQ0FnZG1GeUlHTnZiblJsZUhRZ1BTQnVaWGNnUTI5dWRHVjRkQ2gwY25sTWIyTnpUR2x6ZENrN1hHNGdJQ0FnZG1GeUlITjBZWFJsSUQwZ1IyVnVVM1JoZEdWVGRYTndaVzVrWldSVGRHRnlkRHRjYmx4dUlDQWdJR1oxYm1OMGFXOXVJR2x1ZG05clpTaHRaWFJvYjJRc0lHRnlaeWtnZTF4dUlDQWdJQ0FnYVdZZ0tITjBZWFJsSUQwOVBTQkhaVzVUZEdGMFpVVjRaV04xZEdsdVp5a2dlMXh1SUNBZ0lDQWdJQ0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9YQ0pIWlc1bGNtRjBiM0lnYVhNZ1lXeHlaV0ZrZVNCeWRXNXVhVzVuWENJcE8xeHVJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQnBaaUFvYzNSaGRHVWdQVDA5SUVkbGJsTjBZWFJsUTI5dGNHeGxkR1ZrS1NCN1hHNGdJQ0FnSUNBZ0lDOHZJRUpsSUdadmNtZHBkbWx1Wnl3Z2NHVnlJREkxTGpNdU15NHpMak1nYjJZZ2RHaGxJSE53WldNNlhHNGdJQ0FnSUNBZ0lDOHZJR2gwZEhCek9pOHZjR1Z2Y0d4bExtMXZlbWxzYkdFdWIzSm5MMzVxYjNKbGJtUnZjbVptTDJWek5pMWtjbUZtZEM1b2RHMXNJM05sWXkxblpXNWxjbUYwYjNKeVpYTjFiV1ZjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJR1J2Ym1WU1pYTjFiSFFvS1R0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2QyaHBiR1VnS0hSeWRXVXBJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlHUmxiR1ZuWVhSbElEMGdZMjl1ZEdWNGRDNWtaV3hsWjJGMFpUdGNiaUFnSUNBZ0lDQWdhV1lnS0dSbGJHVm5ZWFJsS1NCN1hHNGdJQ0FnSUNBZ0lDQWdkbUZ5SUhKbFkyOXlaQ0E5SUhSeWVVTmhkR05vS0Z4dUlDQWdJQ0FnSUNBZ0lDQWdaR1ZzWldkaGRHVXVhWFJsY21GMGIzSmJiV1YwYUc5a1hTeGNiaUFnSUNBZ0lDQWdJQ0FnSUdSbGJHVm5ZWFJsTG1sMFpYSmhkRzl5TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdZWEpuWEc0Z0lDQWdJQ0FnSUNBZ0tUdGNibHh1SUNBZ0lDQWdJQ0FnSUdsbUlDaHlaV052Y21RdWRIbHdaU0E5UFQwZ1hDSjBhSEp2ZDF3aUtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCamIyNTBaWGgwTG1SbGJHVm5ZWFJsSUQwZ2JuVnNiRHRjYmx4dUlDQWdJQ0FnSUNBZ0lDQWdMeThnVEdsclpTQnlaWFIxY201cGJtY2daMlZ1WlhKaGRHOXlMblJvY205M0tIVnVZMkYxWjJoMEtTd2dZblYwSUhkcGRHaHZkWFFnZEdobFhHNGdJQ0FnSUNBZ0lDQWdJQ0F2THlCdmRtVnlhR1ZoWkNCdlppQmhiaUJsZUhSeVlTQm1kVzVqZEdsdmJpQmpZV3hzTGx4dUlDQWdJQ0FnSUNBZ0lDQWdiV1YwYUc5a0lEMGdYQ0owYUhKdmQxd2lPMXh1SUNBZ0lDQWdJQ0FnSUNBZ1lYSm5JRDBnY21WamIzSmtMbUZ5Wnp0Y2JseHVJQ0FnSUNBZ0lDQWdJQ0FnWTI5dWRHbHVkV1U3WEc0Z0lDQWdJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQWdJQ0FnTHk4Z1JHVnNaV2RoZEdVZ1oyVnVaWEpoZEc5eUlISmhiaUJoYm1RZ2FHRnVaR3hsWkNCcGRITWdiM2R1SUdWNFkyVndkR2x2Ym5NZ2MyOWNiaUFnSUNBZ0lDQWdJQ0F2THlCeVpXZGhjbVJzWlhOeklHOW1JSGRvWVhRZ2RHaGxJRzFsZEdodlpDQjNZWE1zSUhkbElHTnZiblJwYm5WbElHRnpJR2xtSUdsMElHbHpYRzRnSUNBZ0lDQWdJQ0FnTHk4Z1hDSnVaWGgwWENJZ2QybDBhQ0JoYmlCMWJtUmxabWx1WldRZ1lYSm5MbHh1SUNBZ0lDQWdJQ0FnSUcxbGRHaHZaQ0E5SUZ3aWJtVjRkRndpTzF4dUlDQWdJQ0FnSUNBZ0lHRnlaeUE5SUhWdVpHVm1hVzVsWkR0Y2JseHVJQ0FnSUNBZ0lDQWdJSFpoY2lCcGJtWnZJRDBnY21WamIzSmtMbUZ5Wnp0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvYVc1bWJ5NWtiMjVsS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0JqYjI1MFpYaDBXMlJsYkdWbllYUmxMbkpsYzNWc2RFNWhiV1ZkSUQwZ2FXNW1ieTUyWVd4MVpUdGNiaUFnSUNBZ0lDQWdJQ0FnSUdOdmJuUmxlSFF1Ym1WNGRDQTlJR1JsYkdWbllYUmxMbTVsZUhSTWIyTTdYRzRnSUNBZ0lDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lITjBZWFJsSUQwZ1IyVnVVM1JoZEdWVGRYTndaVzVrWldSWmFXVnNaRHRjYmlBZ0lDQWdJQ0FnSUNBZ0lISmxkSFZ5YmlCcGJtWnZPMXh1SUNBZ0lDQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ0lDQWdJR052Ym5SbGVIUXVaR1ZzWldkaGRHVWdQU0J1ZFd4c08xeHVJQ0FnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQ0FnYVdZZ0tHMWxkR2h2WkNBOVBUMGdYQ0p1WlhoMFhDSXBJSHRjYmlBZ0lDQWdJQ0FnSUNCcFppQW9jM1JoZEdVZ1BUMDlJRWRsYmxOMFlYUmxVM1Z6Y0dWdVpHVmtVM1JoY25RZ0ppWmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2RIbHdaVzltSUdGeVp5QWhQVDBnWENKMWJtUmxabWx1WldSY0lpa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0x5OGdhSFIwY0hNNkx5OXdaVzl3YkdVdWJXOTZhV3hzWVM1dmNtY3ZmbXB2Y21WdVpHOXlabVl2WlhNMkxXUnlZV1owTG1oMGJXd2pjMlZqTFdkbGJtVnlZWFJ2Y25KbGMzVnRaVnh1SUNBZ0lDQWdJQ0FnSUNBZ2RHaHliM2NnYm1WM0lGUjVjR1ZGY25KdmNpaGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ1hDSmhkSFJsYlhCMElIUnZJSE5sYm1RZ1hDSWdLeUJLVTA5T0xuTjBjbWx1WjJsbWVTaGhjbWNwSUNzZ1hDSWdkRzhnYm1WM1ltOXliaUJuWlc1bGNtRjBiM0pjSWx4dUlDQWdJQ0FnSUNBZ0lDQWdLVHRjYmlBZ0lDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdJQ0JwWmlBb2MzUmhkR1VnUFQwOUlFZGxibE4wWVhSbFUzVnpjR1Z1WkdWa1dXbGxiR1FwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR052Ym5SbGVIUXVjMlZ1ZENBOUlHRnlaenRjYmlBZ0lDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdaR1ZzWlhSbElHTnZiblJsZUhRdWMyVnVkRHRjYmlBZ0lDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdmU0JsYkhObElHbG1JQ2h0WlhSb2IyUWdQVDA5SUZ3aWRHaHliM2RjSWlrZ2UxeHVJQ0FnSUNBZ0lDQWdJR2xtSUNoemRHRjBaU0E5UFQwZ1IyVnVVM1JoZEdWVGRYTndaVzVrWldSVGRHRnlkQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdjM1JoZEdVZ1BTQkhaVzVUZEdGMFpVTnZiWEJzWlhSbFpEdGNiaUFnSUNBZ0lDQWdJQ0FnSUhSb2NtOTNJR0Z5Wnp0Y2JpQWdJQ0FnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQ0FnSUNCcFppQW9ZMjl1ZEdWNGRDNWthWE53WVhSamFFVjRZMlZ3ZEdsdmJpaGhjbWNwS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0F2THlCSlppQjBhR1VnWkdsemNHRjBZMmhsWkNCbGVHTmxjSFJwYjI0Z2QyRnpJR05oZFdkb2RDQmllU0JoSUdOaGRHTm9JR0pzYjJOckxGeHVJQ0FnSUNBZ0lDQWdJQ0FnTHk4Z2RHaGxiaUJzWlhRZ2RHaGhkQ0JqWVhSamFDQmliRzlqYXlCb1lXNWtiR1VnZEdobElHVjRZMlZ3ZEdsdmJpQnViM0p0WVd4c2VTNWNiaUFnSUNBZ0lDQWdJQ0FnSUcxbGRHaHZaQ0E5SUZ3aWJtVjRkRndpTzF4dUlDQWdJQ0FnSUNBZ0lDQWdZWEpuSUQwZ2RXNWtaV1pwYm1Wa08xeHVJQ0FnSUNBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tHMWxkR2h2WkNBOVBUMGdYQ0p5WlhSMWNtNWNJaWtnZTF4dUlDQWdJQ0FnSUNBZ0lHTnZiblJsZUhRdVlXSnlkWEIwS0Z3aWNtVjBkWEp1WENJc0lHRnlaeWs3WEc0Z0lDQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ0lDQnpkR0YwWlNBOUlFZGxibE4wWVhSbFJYaGxZM1YwYVc1bk8xeHVYRzRnSUNBZ0lDQWdJSFpoY2lCeVpXTnZjbVFnUFNCMGNubERZWFJqYUNocGJtNWxja1p1TENCelpXeG1MQ0JqYjI1MFpYaDBLVHRjYmlBZ0lDQWdJQ0FnYVdZZ0tISmxZMjl5WkM1MGVYQmxJRDA5UFNCY0ltNXZjbTFoYkZ3aUtTQjdYRzRnSUNBZ0lDQWdJQ0FnTHk4Z1NXWWdZVzRnWlhoalpYQjBhVzl1SUdseklIUm9jbTkzYmlCbWNtOXRJR2x1Ym1WeVJtNHNJSGRsSUd4bFlYWmxJSE4wWVhSbElEMDlQVnh1SUNBZ0lDQWdJQ0FnSUM4dklFZGxibE4wWVhSbFJYaGxZM1YwYVc1bklHRnVaQ0JzYjI5d0lHSmhZMnNnWm05eUlHRnViM1JvWlhJZ2FXNTJiMk5oZEdsdmJpNWNiaUFnSUNBZ0lDQWdJQ0J6ZEdGMFpTQTlJR052Ym5SbGVIUXVaRzl1WlZ4dUlDQWdJQ0FnSUNBZ0lDQWdQeUJIWlc1VGRHRjBaVU52YlhCc1pYUmxaRnh1SUNBZ0lDQWdJQ0FnSUNBZ09pQkhaVzVUZEdGMFpWTjFjM0JsYm1SbFpGbHBaV3hrTzF4dVhHNGdJQ0FnSUNBZ0lDQWdkbUZ5SUdsdVptOGdQU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjJZV3gxWlRvZ2NtVmpiM0prTG1GeVp5eGNiaUFnSUNBZ0lDQWdJQ0FnSUdSdmJtVTZJR052Ym5SbGVIUXVaRzl1WlZ4dUlDQWdJQ0FnSUNBZ0lIMDdYRzVjYmlBZ0lDQWdJQ0FnSUNCcFppQW9jbVZqYjNKa0xtRnlaeUE5UFQwZ1EyOXVkR2x1ZFdWVFpXNTBhVzVsYkNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tHTnZiblJsZUhRdVpHVnNaV2RoZEdVZ0ppWWdiV1YwYUc5a0lEMDlQU0JjSW01bGVIUmNJaWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0F2THlCRVpXeHBZbVZ5WVhSbGJIa2dabTl5WjJWMElIUm9aU0JzWVhOMElITmxiblFnZG1Gc2RXVWdjMjhnZEdoaGRDQjNaU0JrYjI0bmRGeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBdkx5QmhZMk5wWkdWdWRHRnNiSGtnY0dGemN5QnBkQ0J2YmlCMGJ5QjBhR1VnWkdWc1pXZGhkR1V1WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJR0Z5WnlBOUlIVnVaR1ZtYVc1bFpEdGNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnY21WMGRYSnVJR2x1Wm04N1hHNGdJQ0FnSUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2NtVmpiM0prTG5SNWNHVWdQVDA5SUZ3aWRHaHliM2RjSWlrZ2UxeHVJQ0FnSUNBZ0lDQWdJSE4wWVhSbElEMGdSMlZ1VTNSaGRHVkRiMjF3YkdWMFpXUTdYRzVjYmlBZ0lDQWdJQ0FnSUNCcFppQW9iV1YwYUc5a0lEMDlQU0JjSW01bGVIUmNJaWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdZMjl1ZEdWNGRDNWthWE53WVhSamFFVjRZMlZ3ZEdsdmJpaHlaV052Y21RdVlYSm5LVHRjYmlBZ0lDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdZWEpuSUQwZ2NtVmpiM0prTG1GeVp6dGNiaUFnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JpQWdJQ0JuWlc1bGNtRjBiM0l1Ym1WNGRDQTlJR2x1ZG05clpTNWlhVzVrS0dkbGJtVnlZWFJ2Y2l3Z1hDSnVaWGgwWENJcE8xeHVJQ0FnSUdkbGJtVnlZWFJ2Y2x0Y0luUm9jbTkzWENKZElEMGdhVzUyYjJ0bExtSnBibVFvWjJWdVpYSmhkRzl5TENCY0luUm9jbTkzWENJcE8xeHVJQ0FnSUdkbGJtVnlZWFJ2Y2x0Y0luSmxkSFZ5Ymx3aVhTQTlJR2x1ZG05clpTNWlhVzVrS0dkbGJtVnlZWFJ2Y2l3Z1hDSnlaWFIxY201Y0lpazdYRzVjYmlBZ0lDQnlaWFIxY200Z1oyVnVaWEpoZEc5eU8xeHVJQ0I5WEc1Y2JpQWdSM0JiYVhSbGNtRjBiM0pUZVcxaWIyeGRJRDBnWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnY21WMGRYSnVJSFJvYVhNN1hHNGdJSDA3WEc1Y2JpQWdSM0F1ZEc5VGRISnBibWNnUFNCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNCeVpYUjFjbTRnWENKYmIySnFaV04wSUVkbGJtVnlZWFJ2Y2wxY0lqdGNiaUFnZlR0Y2JseHVJQ0JtZFc1amRHbHZiaUJ3ZFhOb1ZISjVSVzUwY25rb2JHOWpjeWtnZTF4dUlDQWdJSFpoY2lCbGJuUnllU0E5SUhzZ2RISjVURzlqT2lCc2IyTnpXekJkSUgwN1hHNWNiaUFnSUNCcFppQW9NU0JwYmlCc2IyTnpLU0I3WEc0Z0lDQWdJQ0JsYm5SeWVTNWpZWFJqYUV4dll5QTlJR3h2WTNOYk1WMDdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2FXWWdLRElnYVc0Z2JHOWpjeWtnZTF4dUlDQWdJQ0FnWlc1MGNua3VabWx1WVd4c2VVeHZZeUE5SUd4dlkzTmJNbDA3WEc0Z0lDQWdJQ0JsYm5SeWVTNWhablJsY2t4dll5QTlJR3h2WTNOYk0xMDdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2RHaHBjeTUwY25sRmJuUnlhV1Z6TG5CMWMyZ29aVzUwY25rcE8xeHVJQ0I5WEc1Y2JpQWdablZ1WTNScGIyNGdjbVZ6WlhSVWNubEZiblJ5ZVNobGJuUnllU2tnZTF4dUlDQWdJSFpoY2lCeVpXTnZjbVFnUFNCbGJuUnllUzVqYjIxd2JHVjBhVzl1SUh4OElIdDlPMXh1SUNBZ0lISmxZMjl5WkM1MGVYQmxJRDBnWENKdWIzSnRZV3hjSWp0Y2JpQWdJQ0JrWld4bGRHVWdjbVZqYjNKa0xtRnlaenRjYmlBZ0lDQmxiblJ5ZVM1amIyMXdiR1YwYVc5dUlEMGdjbVZqYjNKa08xeHVJQ0I5WEc1Y2JpQWdablZ1WTNScGIyNGdRMjl1ZEdWNGRDaDBjbmxNYjJOelRHbHpkQ2tnZTF4dUlDQWdJQzh2SUZSb1pTQnliMjkwSUdWdWRISjVJRzlpYW1WamRDQW9aV1ptWldOMGFYWmxiSGtnWVNCMGNua2djM1JoZEdWdFpXNTBJSGRwZEdodmRYUWdZU0JqWVhSamFGeHVJQ0FnSUM4dklHOXlJR0VnWm1sdVlXeHNlU0JpYkc5amF5a2daMmwyWlhNZ2RYTWdZU0J3YkdGalpTQjBieUJ6ZEc5eVpTQjJZV3gxWlhNZ2RHaHliM2R1SUdaeWIyMWNiaUFnSUNBdkx5QnNiMk5oZEdsdmJuTWdkMmhsY21VZ2RHaGxjbVVnYVhNZ2JtOGdaVzVqYkc5emFXNW5JSFJ5ZVNCemRHRjBaVzFsYm5RdVhHNGdJQ0FnZEdocGN5NTBjbmxGYm5SeWFXVnpJRDBnVzNzZ2RISjVURzlqT2lCY0luSnZiM1JjSWlCOVhUdGNiaUFnSUNCMGNubE1iMk56VEdsemRDNW1iM0pGWVdOb0tIQjFjMmhVY25sRmJuUnllU3dnZEdocGN5azdYRzRnSUNBZ2RHaHBjeTV5WlhObGRDZ3BPMXh1SUNCOVhHNWNiaUFnY25WdWRHbHRaUzVyWlhseklEMGdablZ1WTNScGIyNG9iMkpxWldOMEtTQjdYRzRnSUNBZ2RtRnlJR3RsZVhNZ1BTQmJYVHRjYmlBZ0lDQm1iM0lnS0haaGNpQnJaWGtnYVc0Z2IySnFaV04wS1NCN1hHNGdJQ0FnSUNCclpYbHpMbkIxYzJnb2EyVjVLVHRjYmlBZ0lDQjlYRzRnSUNBZ2EyVjVjeTV5WlhabGNuTmxLQ2s3WEc1Y2JpQWdJQ0F2THlCU1lYUm9aWElnZEdoaGJpQnlaWFIxY201cGJtY2dZVzRnYjJKcVpXTjBJSGRwZEdnZ1lTQnVaWGgwSUcxbGRHaHZaQ3dnZDJVZ2EyVmxjRnh1SUNBZ0lDOHZJSFJvYVc1bmN5QnphVzF3YkdVZ1lXNWtJSEpsZEhWeWJpQjBhR1VnYm1WNGRDQm1kVzVqZEdsdmJpQnBkSE5sYkdZdVhHNGdJQ0FnY21WMGRYSnVJR1oxYm1OMGFXOXVJRzVsZUhRb0tTQjdYRzRnSUNBZ0lDQjNhR2xzWlNBb2EyVjVjeTVzWlc1bmRHZ3BJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlHdGxlU0E5SUd0bGVYTXVjRzl3S0NrN1hHNGdJQ0FnSUNBZ0lHbG1JQ2hyWlhrZ2FXNGdiMkpxWldOMEtTQjdYRzRnSUNBZ0lDQWdJQ0FnYm1WNGRDNTJZV3gxWlNBOUlHdGxlVHRjYmlBZ0lDQWdJQ0FnSUNCdVpYaDBMbVJ2Ym1VZ1BTQm1ZV3h6WlR0Y2JpQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2JtVjRkRHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBdkx5QlVieUJoZG05cFpDQmpjbVZoZEdsdVp5QmhiaUJoWkdScGRHbHZibUZzSUc5aWFtVmpkQ3dnZDJVZ2FuVnpkQ0JvWVc1bklIUm9aU0F1ZG1Gc2RXVmNiaUFnSUNBZ0lDOHZJR0Z1WkNBdVpHOXVaU0J3Y205d1pYSjBhV1Z6SUc5bVppQjBhR1VnYm1WNGRDQm1kVzVqZEdsdmJpQnZZbXBsWTNRZ2FYUnpaV3htTGlCVWFHbHpYRzRnSUNBZ0lDQXZMeUJoYkhOdklHVnVjM1Z5WlhNZ2RHaGhkQ0IwYUdVZ2JXbHVhV1pwWlhJZ2QybHNiQ0J1YjNRZ1lXNXZibmx0YVhwbElIUm9aU0JtZFc1amRHbHZiaTVjYmlBZ0lDQWdJRzVsZUhRdVpHOXVaU0E5SUhSeWRXVTdYRzRnSUNBZ0lDQnlaWFIxY200Z2JtVjRkRHRjYmlBZ0lDQjlPMXh1SUNCOU8xeHVYRzRnSUdaMWJtTjBhVzl1SUhaaGJIVmxjeWhwZEdWeVlXSnNaU2tnZTF4dUlDQWdJR2xtSUNocGRHVnlZV0pzWlNrZ2UxeHVJQ0FnSUNBZ2RtRnlJR2wwWlhKaGRHOXlUV1YwYUc5a0lEMGdhWFJsY21GaWJHVmJhWFJsY21GMGIzSlRlVzFpYjJ4ZE8xeHVJQ0FnSUNBZ2FXWWdLR2wwWlhKaGRHOXlUV1YwYUc5a0tTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQnBkR1Z5WVhSdmNrMWxkR2h2WkM1allXeHNLR2wwWlhKaFlteGxLVHRjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnYVdZZ0tIUjVjR1Z2WmlCcGRHVnlZV0pzWlM1dVpYaDBJRDA5UFNCY0ltWjFibU4wYVc5dVhDSXBJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJR2wwWlhKaFlteGxPMXh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0JwWmlBb0lXbHpUbUZPS0dsMFpYSmhZbXhsTG14bGJtZDBhQ2twSUh0Y2JpQWdJQ0FnSUNBZ2RtRnlJR2tnUFNBdE1Td2dibVY0ZENBOUlHWjFibU4wYVc5dUlHNWxlSFFvS1NCN1hHNGdJQ0FnSUNBZ0lDQWdkMmhwYkdVZ0tDc3JhU0E4SUdsMFpYSmhZbXhsTG14bGJtZDBhQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdhV1lnS0doaGMwOTNiaTVqWVd4c0tHbDBaWEpoWW14bExDQnBLU2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0J1WlhoMExuWmhiSFZsSUQwZ2FYUmxjbUZpYkdWYmFWMDdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lHNWxlSFF1Wkc5dVpTQTlJR1poYkhObE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnYm1WNGREdGNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQ0FnSUNCdVpYaDBMblpoYkhWbElEMGdkVzVrWldacGJtVmtPMXh1SUNBZ0lDQWdJQ0FnSUc1bGVIUXVaRzl1WlNBOUlIUnlkV1U3WEc1Y2JpQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2JtVjRkRHRjYmlBZ0lDQWdJQ0FnZlR0Y2JseHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2JtVjRkQzV1WlhoMElEMGdibVY0ZER0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5WEc1Y2JpQWdJQ0F2THlCU1pYUjFjbTRnWVc0Z2FYUmxjbUYwYjNJZ2QybDBhQ0J1YnlCMllXeDFaWE11WEc0Z0lDQWdjbVYwZFhKdUlIc2dibVY0ZERvZ1pHOXVaVkpsYzNWc2RDQjlPMXh1SUNCOVhHNGdJSEoxYm5ScGJXVXVkbUZzZFdWeklEMGdkbUZzZFdWek8xeHVYRzRnSUdaMWJtTjBhVzl1SUdSdmJtVlNaWE4xYkhRb0tTQjdYRzRnSUNBZ2NtVjBkWEp1SUhzZ2RtRnNkV1U2SUhWdVpHVm1hVzVsWkN3Z1pHOXVaVG9nZEhKMVpTQjlPMXh1SUNCOVhHNWNiaUFnUTI5dWRHVjRkQzV3Y205MGIzUjVjR1VnUFNCN1hHNGdJQ0FnWTI5dWMzUnlkV04wYjNJNklFTnZiblJsZUhRc1hHNWNiaUFnSUNCeVpYTmxkRG9nWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNCMGFHbHpMbkJ5WlhZZ1BTQXdPMXh1SUNBZ0lDQWdkR2hwY3k1dVpYaDBJRDBnTUR0Y2JpQWdJQ0FnSUhSb2FYTXVjMlZ1ZENBOUlIVnVaR1ZtYVc1bFpEdGNiaUFnSUNBZ0lIUm9hWE11Wkc5dVpTQTlJR1poYkhObE8xeHVJQ0FnSUNBZ2RHaHBjeTVrWld4bFoyRjBaU0E5SUc1MWJHdzdYRzVjYmlBZ0lDQWdJSFJvYVhNdWRISjVSVzUwY21sbGN5NW1iM0pGWVdOb0tISmxjMlYwVkhKNVJXNTBjbmtwTzF4dVhHNGdJQ0FnSUNBdkx5QlFjbVV0YVc1cGRHbGhiR2w2WlNCaGRDQnNaV0Z6ZENBeU1DQjBaVzF3YjNKaGNua2dkbUZ5YVdGaWJHVnpJSFJ2SUdWdVlXSnNaU0JvYVdSa1pXNWNiaUFnSUNBZ0lDOHZJR05zWVhOeklHOXdkR2x0YVhwaGRHbHZibk1nWm05eUlITnBiWEJzWlNCblpXNWxjbUYwYjNKekxseHVJQ0FnSUNBZ1ptOXlJQ2gyWVhJZ2RHVnRjRWx1WkdWNElEMGdNQ3dnZEdWdGNFNWhiV1U3WEc0Z0lDQWdJQ0FnSUNBZ0lHaGhjMDkzYmk1allXeHNLSFJvYVhNc0lIUmxiWEJPWVcxbElEMGdYQ0owWENJZ0t5QjBaVzF3U1c1a1pYZ3BJSHg4SUhSbGJYQkpibVJsZUNBOElESXdPMXh1SUNBZ0lDQWdJQ0FnSUNBckszUmxiWEJKYm1SbGVDa2dlMXh1SUNBZ0lDQWdJQ0IwYUdselczUmxiWEJPWVcxbFhTQTlJRzUxYkd3N1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlN4Y2JseHVJQ0FnSUhOMGIzQTZJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQWdJQ0FnZEdocGN5NWtiMjVsSUQwZ2RISjFaVHRjYmx4dUlDQWdJQ0FnZG1GeUlISnZiM1JGYm5SeWVTQTlJSFJvYVhNdWRISjVSVzUwY21sbGMxc3dYVHRjYmlBZ0lDQWdJSFpoY2lCeWIyOTBVbVZqYjNKa0lEMGdjbTl2ZEVWdWRISjVMbU52YlhCc1pYUnBiMjQ3WEc0Z0lDQWdJQ0JwWmlBb2NtOXZkRkpsWTI5eVpDNTBlWEJsSUQwOVBTQmNJblJvY205M1hDSXBJSHRjYmlBZ0lDQWdJQ0FnZEdoeWIzY2djbTl2ZEZKbFkyOXlaQzVoY21jN1hHNGdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lISmxkSFZ5YmlCMGFHbHpMbkoyWVd3N1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUdScGMzQmhkR05vUlhoalpYQjBhVzl1T2lCbWRXNWpkR2x2YmlobGVHTmxjSFJwYjI0cElIdGNiaUFnSUNBZ0lHbG1JQ2gwYUdsekxtUnZibVVwSUh0Y2JpQWdJQ0FnSUNBZ2RHaHliM2NnWlhoalpYQjBhVzl1TzF4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNCMllYSWdZMjl1ZEdWNGRDQTlJSFJvYVhNN1hHNGdJQ0FnSUNCbWRXNWpkR2x2YmlCb1lXNWtiR1VvYkc5akxDQmpZWFZuYUhRcElIdGNiaUFnSUNBZ0lDQWdjbVZqYjNKa0xuUjVjR1VnUFNCY0luUm9jbTkzWENJN1hHNGdJQ0FnSUNBZ0lISmxZMjl5WkM1aGNtY2dQU0JsZUdObGNIUnBiMjQ3WEc0Z0lDQWdJQ0FnSUdOdmJuUmxlSFF1Ym1WNGRDQTlJR3h2WXp0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUNFaFkyRjFaMmgwTzF4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNCbWIzSWdLSFpoY2lCcElEMGdkR2hwY3k1MGNubEZiblJ5YVdWekxteGxibWQwYUNBdElERTdJR2tnUGowZ01Ec2dMUzFwS1NCN1hHNGdJQ0FnSUNBZ0lIWmhjaUJsYm5SeWVTQTlJSFJvYVhNdWRISjVSVzUwY21sbGMxdHBYVHRjYmlBZ0lDQWdJQ0FnZG1GeUlISmxZMjl5WkNBOUlHVnVkSEo1TG1OdmJYQnNaWFJwYjI0N1hHNWNiaUFnSUNBZ0lDQWdhV1lnS0dWdWRISjVMblJ5ZVV4dll5QTlQVDBnWENKeWIyOTBYQ0lwSUh0Y2JpQWdJQ0FnSUNBZ0lDQXZMeUJGZUdObGNIUnBiMjRnZEdoeWIzZHVJRzkxZEhOcFpHVWdiMllnWVc1NUlIUnllU0JpYkc5amF5QjBhR0YwSUdOdmRXeGtJR2hoYm1Sc1pWeHVJQ0FnSUNBZ0lDQWdJQzh2SUdsMExDQnpieUJ6WlhRZ2RHaGxJR052YlhCc1pYUnBiMjRnZG1Gc2RXVWdiMllnZEdobElHVnVkR2x5WlNCbWRXNWpkR2x2YmlCMGIxeHVJQ0FnSUNBZ0lDQWdJQzh2SUhSb2NtOTNJSFJvWlNCbGVHTmxjSFJwYjI0dVhHNGdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlHaGhibVJzWlNoY0ltVnVaRndpS1R0Y2JpQWdJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQWdJR2xtSUNobGJuUnllUzUwY25sTWIyTWdQRDBnZEdocGN5NXdjbVYyS1NCN1hHNGdJQ0FnSUNBZ0lDQWdkbUZ5SUdoaGMwTmhkR05vSUQwZ2FHRnpUM2R1TG1OaGJHd29aVzUwY25rc0lGd2lZMkYwWTJoTWIyTmNJaWs3WEc0Z0lDQWdJQ0FnSUNBZ2RtRnlJR2hoYzBacGJtRnNiSGtnUFNCb1lYTlBkMjR1WTJGc2JDaGxiblJ5ZVN3Z1hDSm1hVzVoYkd4NVRHOWpYQ0lwTzF4dVhHNGdJQ0FnSUNBZ0lDQWdhV1lnS0doaGMwTmhkR05vSUNZbUlHaGhjMFpwYm1Gc2JIa3BJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHbG1JQ2gwYUdsekxuQnlaWFlnUENCbGJuUnllUzVqWVhSamFFeHZZeWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdhR0Z1Wkd4bEtHVnVkSEo1TG1OaGRHTm9URzlqTENCMGNuVmxLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIMGdaV3h6WlNCcFppQW9kR2hwY3k1d2NtVjJJRHdnWlc1MGNua3VabWx1WVd4c2VVeHZZeWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdhR0Z1Wkd4bEtHVnVkSEo1TG1acGJtRnNiSGxNYjJNcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBZ0lDQWdmU0JsYkhObElHbG1JQ2hvWVhORFlYUmphQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdhV1lnS0hSb2FYTXVjSEpsZGlBOElHVnVkSEo1TG1OaGRHTm9URzlqS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUJvWVc1a2JHVW9aVzUwY25rdVkyRjBZMmhNYjJNc0lIUnlkV1VwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaG9ZWE5HYVc1aGJHeDVLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaUFvZEdocGN5NXdjbVYySUR3Z1pXNTBjbmt1Wm1sdVlXeHNlVXh2WXlrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnYUdGdVpHeGxLR1Z1ZEhKNUxtWnBibUZzYkhsTWIyTXBPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9jbTkzSUc1bGR5QkZjbkp2Y2loY0luUnllU0J6ZEdGMFpXMWxiblFnZDJsMGFHOTFkQ0JqWVhSamFDQnZjaUJtYVc1aGJHeDVYQ0lwTzF4dUlDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmVnh1SUNBZ0lIMHNYRzVjYmlBZ0lDQmhZbkoxY0hRNklHWjFibU4wYVc5dUtIUjVjR1VzSUdGeVp5a2dlMXh1SUNBZ0lDQWdabTl5SUNoMllYSWdhU0E5SUhSb2FYTXVkSEo1Ulc1MGNtbGxjeTVzWlc1bmRHZ2dMU0F4T3lCcElENDlJREE3SUMwdGFTa2dlMXh1SUNBZ0lDQWdJQ0IyWVhJZ1pXNTBjbmtnUFNCMGFHbHpMblJ5ZVVWdWRISnBaWE5iYVYwN1hHNGdJQ0FnSUNBZ0lHbG1JQ2hsYm5SeWVTNTBjbmxNYjJNZ1BEMGdkR2hwY3k1d2NtVjJJQ1ltWEc0Z0lDQWdJQ0FnSUNBZ0lDQm9ZWE5QZDI0dVkyRnNiQ2hsYm5SeWVTd2dYQ0ptYVc1aGJHeDVURzlqWENJcElDWW1YRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbkJ5WlhZZ1BDQmxiblJ5ZVM1bWFXNWhiR3g1VEc5aktTQjdYRzRnSUNBZ0lDQWdJQ0FnZG1GeUlHWnBibUZzYkhsRmJuUnllU0E5SUdWdWRISjVPMXh1SUNBZ0lDQWdJQ0FnSUdKeVpXRnJPMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUdsbUlDaG1hVzVoYkd4NVJXNTBjbmtnSmlaY2JpQWdJQ0FnSUNBZ0lDQW9kSGx3WlNBOVBUMGdYQ0ppY21WaGExd2lJSHg4WEc0Z0lDQWdJQ0FnSUNBZ0lIUjVjR1VnUFQwOUlGd2lZMjl1ZEdsdWRXVmNJaWtnSmlaY2JpQWdJQ0FnSUNBZ0lDQm1hVzVoYkd4NVJXNTBjbmt1ZEhKNVRHOWpJRHc5SUdGeVp5QW1KbHh1SUNBZ0lDQWdJQ0FnSUdGeVp5QThJR1pwYm1Gc2JIbEZiblJ5ZVM1bWFXNWhiR3g1VEc5aktTQjdYRzRnSUNBZ0lDQWdJQzh2SUVsbmJtOXlaU0IwYUdVZ1ptbHVZV3hzZVNCbGJuUnllU0JwWmlCamIyNTBjbTlzSUdseklHNXZkQ0JxZFcxd2FXNW5JSFJ2SUdGY2JpQWdJQ0FnSUNBZ0x5OGdiRzlqWVhScGIyNGdiM1YwYzJsa1pTQjBhR1VnZEhKNUwyTmhkR05vSUdKc2IyTnJMbHh1SUNBZ0lDQWdJQ0JtYVc1aGJHeDVSVzUwY25rZ1BTQnVkV3hzTzF4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNCMllYSWdjbVZqYjNKa0lEMGdabWx1WVd4c2VVVnVkSEo1SUQ4Z1ptbHVZV3hzZVVWdWRISjVMbU52YlhCc1pYUnBiMjRnT2lCN2ZUdGNiaUFnSUNBZ0lISmxZMjl5WkM1MGVYQmxJRDBnZEhsd1pUdGNiaUFnSUNBZ0lISmxZMjl5WkM1aGNtY2dQU0JoY21jN1hHNWNiaUFnSUNBZ0lHbG1JQ2htYVc1aGJHeDVSVzUwY25rcElIdGNiaUFnSUNBZ0lDQWdkR2hwY3k1dVpYaDBJRDBnWm1sdVlXeHNlVVZ1ZEhKNUxtWnBibUZzYkhsTWIyTTdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TG1OdmJYQnNaWFJsS0hKbFkyOXlaQ2s3WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUhKbGRIVnliaUJEYjI1MGFXNTFaVk5sYm5ScGJtVnNPMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQmpiMjF3YkdWMFpUb2dablZ1WTNScGIyNG9jbVZqYjNKa0xDQmhablJsY2t4dll5a2dlMXh1SUNBZ0lDQWdhV1lnS0hKbFkyOXlaQzUwZVhCbElEMDlQU0JjSW5Sb2NtOTNYQ0lwSUh0Y2JpQWdJQ0FnSUNBZ2RHaHliM2NnY21WamIzSmtMbUZ5Wnp0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ2FXWWdLSEpsWTI5eVpDNTBlWEJsSUQwOVBTQmNJbUp5WldGclhDSWdmSHhjYmlBZ0lDQWdJQ0FnSUNCeVpXTnZjbVF1ZEhsd1pTQTlQVDBnWENKamIyNTBhVzUxWlZ3aUtTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdWJtVjRkQ0E5SUhKbFkyOXlaQzVoY21jN1hHNGdJQ0FnSUNCOUlHVnNjMlVnYVdZZ0tISmxZMjl5WkM1MGVYQmxJRDA5UFNCY0luSmxkSFZ5Ymx3aUtTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdWNuWmhiQ0E5SUhKbFkyOXlaQzVoY21jN1hHNGdJQ0FnSUNBZ0lIUm9hWE11Ym1WNGRDQTlJRndpWlc1a1hDSTdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLSEpsWTI5eVpDNTBlWEJsSUQwOVBTQmNJbTV2Y20xaGJGd2lJQ1ltSUdGbWRHVnlURzlqS1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11Ym1WNGRDQTlJR0ZtZEdWeVRHOWpPMXh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0J5WlhSMWNtNGdRMjl1ZEdsdWRXVlRaVzUwYVc1bGJEdGNiaUFnSUNCOUxGeHVYRzRnSUNBZ1ptbHVhWE5vT2lCbWRXNWpkR2x2YmlobWFXNWhiR3g1VEc5aktTQjdYRzRnSUNBZ0lDQm1iM0lnS0haaGNpQnBJRDBnZEdocGN5NTBjbmxGYm5SeWFXVnpMbXhsYm1kMGFDQXRJREU3SUdrZ1BqMGdNRHNnTFMxcEtTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCbGJuUnllU0E5SUhSb2FYTXVkSEo1Ulc1MGNtbGxjMXRwWFR0Y2JpQWdJQ0FnSUNBZ2FXWWdLR1Z1ZEhKNUxtWnBibUZzYkhsTWIyTWdQVDA5SUdacGJtRnNiSGxNYjJNcElIdGNiaUFnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1amIyMXdiR1YwWlNobGJuUnllUzVqYjIxd2JHVjBhVzl1TENCbGJuUnllUzVoWm5SbGNreHZZeWs3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JpQWdJQ0I5TEZ4dVhHNGdJQ0FnWENKallYUmphRndpT2lCbWRXNWpkR2x2YmloMGNubE1iMk1wSUh0Y2JpQWdJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQjBhR2x6TG5SeWVVVnVkSEpwWlhNdWJHVnVaM1JvSUMwZ01Uc2dhU0ErUFNBd095QXRMV2twSUh0Y2JpQWdJQ0FnSUNBZ2RtRnlJR1Z1ZEhKNUlEMGdkR2hwY3k1MGNubEZiblJ5YVdWelcybGRPMXh1SUNBZ0lDQWdJQ0JwWmlBb1pXNTBjbmt1ZEhKNVRHOWpJRDA5UFNCMGNubE1iMk1wSUh0Y2JpQWdJQ0FnSUNBZ0lDQjJZWElnY21WamIzSmtJRDBnWlc1MGNua3VZMjl0Y0d4bGRHbHZianRjYmlBZ0lDQWdJQ0FnSUNCcFppQW9jbVZqYjNKa0xuUjVjR1VnUFQwOUlGd2lkR2h5YjNkY0lpa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2RtRnlJSFJvY205M2JpQTlJSEpsWTI5eVpDNWhjbWM3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnlaWE5sZEZSeWVVVnVkSEo1S0dWdWRISjVLVHRjYmlBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlIUm9jbTkzYmp0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQXZMeUJVYUdVZ1kyOXVkR1Y0ZEM1allYUmphQ0J0WlhSb2IyUWdiWFZ6ZENCdmJteDVJR0psSUdOaGJHeGxaQ0IzYVhSb0lHRWdiRzlqWVhScGIyNWNiaUFnSUNBZ0lDOHZJR0Z5WjNWdFpXNTBJSFJvWVhRZ1kyOXljbVZ6Y0c5dVpITWdkRzhnWVNCcmJtOTNiaUJqWVhSamFDQmliRzlqYXk1Y2JpQWdJQ0FnSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWhjSW1sc2JHVm5ZV3dnWTJGMFkyZ2dZWFIwWlcxd2RGd2lLVHRjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdaR1ZzWldkaGRHVlphV1ZzWkRvZ1puVnVZM1JwYjI0b2FYUmxjbUZpYkdVc0lISmxjM1ZzZEU1aGJXVXNJRzVsZUhSTWIyTXBJSHRjYmlBZ0lDQWdJSFJvYVhNdVpHVnNaV2RoZEdVZ1BTQjdYRzRnSUNBZ0lDQWdJR2wwWlhKaGRHOXlPaUIyWVd4MVpYTW9hWFJsY21GaWJHVXBMRnh1SUNBZ0lDQWdJQ0J5WlhOMWJIUk9ZVzFsT2lCeVpYTjFiSFJPWVcxbExGeHVJQ0FnSUNBZ0lDQnVaWGgwVEc5ak9pQnVaWGgwVEc5alhHNGdJQ0FnSUNCOU8xeHVYRzRnSUNBZ0lDQnlaWFIxY200Z1EyOXVkR2x1ZFdWVFpXNTBhVzVsYkR0Y2JpQWdJQ0I5WEc0Z0lIMDdYRzU5S1NoY2JpQWdMeThnUVcxdmJtY2dkR2hsSUhaaGNtbHZkWE1nZEhKcFkydHpJR1p2Y2lCdlluUmhhVzVwYm1jZ1lTQnlaV1psY21WdVkyVWdkRzhnZEdobElHZHNiMkpoYkZ4dUlDQXZMeUJ2WW1wbFkzUXNJSFJvYVhNZ2MyVmxiWE1nZEc4Z1ltVWdkR2hsSUcxdmMzUWdjbVZzYVdGaWJHVWdkR1ZqYUc1cGNYVmxJSFJvWVhRZ1pHOWxjeUJ1YjNSY2JpQWdMeThnZFhObElHbHVaR2x5WldOMElHVjJZV3dnS0hkb2FXTm9JSFpwYjJ4aGRHVnpJRU52Ym5SbGJuUWdVMlZqZFhKcGRIa2dVRzlzYVdONUtTNWNiaUFnZEhsd1pXOW1JR2RzYjJKaGJDQTlQVDBnWENKdlltcGxZM1JjSWlBL0lHZHNiMkpoYkNBNlhHNGdJSFI1Y0dWdlppQjNhVzVrYjNjZ1BUMDlJRndpYjJKcVpXTjBYQ0lnUHlCM2FXNWtiM2NnT2lCMGFHbHpYRzRwTzF4dUlsMTkiLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBib3hJbnRlcnNlY3RXcmFwcGVyXG5cbnZhciBwb29sID0gcmVxdWlyZSgndHlwZWRhcnJheS1wb29sJylcbnZhciBzd2VlcCA9IHJlcXVpcmUoJy4vbGliL3N3ZWVwJylcbnZhciBib3hJbnRlcnNlY3RJdGVyID0gcmVxdWlyZSgnLi9saWIvaW50ZXJzZWN0JylcblxuZnVuY3Rpb24gYm94RW1wdHkoZCwgYm94KSB7XG4gIGZvcih2YXIgaj0wOyBqPGQ7ICsraikge1xuICAgIGlmKCEoYm94W2pdIDw9IGJveFtqK2RdKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8vVW5wYWNrIGJveGVzIGludG8gYSBmbGF0IHR5cGVkIGFycmF5LCByZW1vdmUgZW1wdHkgYm94ZXNcbmZ1bmN0aW9uIGNvbnZlcnRCb3hlcyhib3hlcywgZCwgZGF0YSwgaWRzKSB7XG4gIHZhciBwdHIgPSAwXG4gIHZhciBjb3VudCA9IDBcbiAgZm9yKHZhciBpPTAsIG49Ym94ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHZhciBiID0gYm94ZXNbaV1cbiAgICBpZihib3hFbXB0eShkLCBiKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgZm9yKHZhciBqPTA7IGo8MipkOyArK2opIHtcbiAgICAgIGRhdGFbcHRyKytdID0gYltqXVxuICAgIH1cbiAgICBpZHNbY291bnQrK10gPSBpXG4gIH1cbiAgcmV0dXJuIGNvdW50XG59XG5cbi8vUGVyZm9ybSB0eXBlIGNvbnZlcnNpb25zLCBjaGVjayBib3VuZHNcbmZ1bmN0aW9uIGJveEludGVyc2VjdChyZWQsIGJsdWUsIHZpc2l0LCBmdWxsKSB7XG4gIHZhciBuID0gcmVkLmxlbmd0aFxuICB2YXIgbSA9IGJsdWUubGVuZ3RoXG5cbiAgLy9JZiBlaXRoZXIgYXJyYXkgaXMgZW1wdHksIHRoZW4gd2UgY2FuIHNraXAgdGhpcyB3aG9sZSB0aGluZ1xuICBpZihuIDw9IDAgfHwgbSA8PSAwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvL0NvbXB1dGUgZGltZW5zaW9uLCBpZiBpdCBpcyAwIHRoZW4gd2Ugc2tpcFxuICB2YXIgZCA9IChyZWRbMF0ubGVuZ3RoKT4+PjFcbiAgaWYoZCA8PSAwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgcmV0dmFsXG5cbiAgLy9Db252ZXJ0IHJlZCBib3hlc1xuICB2YXIgcmVkTGlzdCAgPSBwb29sLm1hbGxvY0RvdWJsZSgyKmQqbilcbiAgdmFyIHJlZElkcyAgID0gcG9vbC5tYWxsb2NJbnQzMihuKVxuICBuID0gY29udmVydEJveGVzKHJlZCwgZCwgcmVkTGlzdCwgcmVkSWRzKVxuXG4gIGlmKG4gPiAwKSB7XG4gICAgaWYoZCA9PT0gMSAmJiBmdWxsKSB7XG4gICAgICAvL1NwZWNpYWwgY2FzZTogMWQgY29tcGxldGVcbiAgICAgIHN3ZWVwLmluaXQobilcbiAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQ29tcGxldGUoXG4gICAgICAgIGQsIHZpc2l0LCBcbiAgICAgICAgMCwgbiwgcmVkTGlzdCwgcmVkSWRzLFxuICAgICAgICAwLCBuLCByZWRMaXN0LCByZWRJZHMpXG4gICAgfSBlbHNlIHtcblxuICAgICAgLy9Db252ZXJ0IGJsdWUgYm94ZXNcbiAgICAgIHZhciBibHVlTGlzdCA9IHBvb2wubWFsbG9jRG91YmxlKDIqZCptKVxuICAgICAgdmFyIGJsdWVJZHMgID0gcG9vbC5tYWxsb2NJbnQzMihtKVxuICAgICAgbSA9IGNvbnZlcnRCb3hlcyhibHVlLCBkLCBibHVlTGlzdCwgYmx1ZUlkcylcblxuICAgICAgaWYobSA+IDApIHtcbiAgICAgICAgc3dlZXAuaW5pdChuK20pXG5cbiAgICAgICAgaWYoZCA9PT0gMSkge1xuICAgICAgICAgIC8vU3BlY2lhbCBjYXNlOiAxZCBiaXBhcnRpdGVcbiAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcEJpcGFydGl0ZShcbiAgICAgICAgICAgIGQsIHZpc2l0LCBcbiAgICAgICAgICAgIDAsIG4sIHJlZExpc3QsICByZWRJZHMsXG4gICAgICAgICAgICAwLCBtLCBibHVlTGlzdCwgYmx1ZUlkcylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL0dlbmVyYWwgY2FzZTogIGQ+MVxuICAgICAgICAgIHJldHZhbCA9IGJveEludGVyc2VjdEl0ZXIoXG4gICAgICAgICAgICBkLCB2aXNpdCwgICAgZnVsbCxcbiAgICAgICAgICAgIG4sIHJlZExpc3QsICByZWRJZHMsXG4gICAgICAgICAgICBtLCBibHVlTGlzdCwgYmx1ZUlkcylcbiAgICAgICAgfVxuXG4gICAgICAgIHBvb2wuZnJlZShibHVlTGlzdClcbiAgICAgICAgcG9vbC5mcmVlKGJsdWVJZHMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcG9vbC5mcmVlKHJlZExpc3QpXG4gICAgcG9vbC5mcmVlKHJlZElkcylcbiAgfVxuXG4gIHJldHVybiByZXR2YWxcbn1cblxuXG52YXIgUkVTVUxUXG5cbmZ1bmN0aW9uIGFwcGVuZEl0ZW0oaSxqKSB7XG4gIFJFU1VMVC5wdXNoKFtpLGpdKVxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RGdWxsQXJyYXkoeCkge1xuICBSRVNVTFQgPSBbXVxuICBib3hJbnRlcnNlY3QoeCwgeCwgYXBwZW5kSXRlbSwgdHJ1ZSlcbiAgcmV0dXJuIFJFU1VMVFxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RCaXBhcnRpdGVBcnJheSh4LCB5KSB7XG4gIFJFU1VMVCA9IFtdXG4gIGJveEludGVyc2VjdCh4LCB5LCBhcHBlbmRJdGVtLCBmYWxzZSlcbiAgcmV0dXJuIFJFU1VMVFxufVxuXG4vL1VzZXItZnJpZW5kbHkgd3JhcHBlciwgaGFuZGxlIGZ1bGwgaW5wdXQgYW5kIG5vLXZpc2l0b3IgY2FzZXNcbmZ1bmN0aW9uIGJveEludGVyc2VjdFdyYXBwZXIoYXJnMCwgYXJnMSwgYXJnMikge1xuICB2YXIgcmVzdWx0XG4gIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGludGVyc2VjdEZ1bGxBcnJheShhcmcwKVxuICAgIGNhc2UgMjpcbiAgICAgIGlmKHR5cGVvZiBhcmcxID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBib3hJbnRlcnNlY3QoYXJnMCwgYXJnMCwgYXJnMSwgdHJ1ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbnRlcnNlY3RCaXBhcnRpdGVBcnJheShhcmcwLCBhcmcxKVxuICAgICAgfVxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBib3hJbnRlcnNlY3QoYXJnMCwgYXJnMSwgYXJnMiwgZmFsc2UpXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignYm94LWludGVyc2VjdDogSW52YWxpZCBhcmd1bWVudHMnKVxuICB9XG59IiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBESU1FTlNJT04gICA9ICdkJ1xudmFyIEFYSVMgICAgICAgID0gJ2F4J1xudmFyIFZJU0lUICAgICAgID0gJ3Z2J1xudmFyIEZMSVAgICAgICAgID0gJ2ZwJ1xuXG52YXIgRUxFTV9TSVpFICAgPSAnZXMnXG5cbnZhciBSRURfU1RBUlQgICA9ICdycydcbnZhciBSRURfRU5EICAgICA9ICdyZSdcbnZhciBSRURfQk9YRVMgICA9ICdyYidcbnZhciBSRURfSU5ERVggICA9ICdyaSdcbnZhciBSRURfUFRSICAgICA9ICdycCdcblxudmFyIEJMVUVfU1RBUlQgID0gJ2JzJ1xudmFyIEJMVUVfRU5EICAgID0gJ2JlJ1xudmFyIEJMVUVfQk9YRVMgID0gJ2JiJ1xudmFyIEJMVUVfSU5ERVggID0gJ2JpJ1xudmFyIEJMVUVfUFRSICAgID0gJ2JwJ1xuXG52YXIgUkVUVkFMICAgICAgPSAncnYnXG5cbnZhciBJTk5FUl9MQUJFTCA9ICdRJ1xuXG52YXIgQVJHUyA9IFtcbiAgRElNRU5TSU9OLFxuICBBWElTLFxuICBWSVNJVCxcbiAgUkVEX1NUQVJULFxuICBSRURfRU5ELFxuICBSRURfQk9YRVMsXG4gIFJFRF9JTkRFWCxcbiAgQkxVRV9TVEFSVCxcbiAgQkxVRV9FTkQsXG4gIEJMVUVfQk9YRVMsXG4gIEJMVUVfSU5ERVhcbl1cblxuZnVuY3Rpb24gZ2VuZXJhdGVCcnV0ZUZvcmNlKHJlZE1ham9yLCBmbGlwLCBmdWxsKSB7XG4gIHZhciBmdW5jTmFtZSA9ICdicnV0ZUZvcmNlJyArIFxuICAgIChyZWRNYWpvciA/ICdSZWQnIDogJ0JsdWUnKSArIFxuICAgIChmbGlwID8gJ0ZsaXAnIDogJycpICtcbiAgICAoZnVsbCA/ICdGdWxsJyA6ICcnKVxuXG4gIHZhciBjb2RlID0gWydmdW5jdGlvbiAnLCBmdW5jTmFtZSwgJygnLCBBUkdTLmpvaW4oKSwgJyl7JyxcbiAgICAndmFyICcsIEVMRU1fU0laRSwgJz0yKicsIERJTUVOU0lPTiwgJzsnXVxuXG4gIHZhciByZWRMb29wID0gXG4gICAgJ2Zvcih2YXIgaT0nICsgUkVEX1NUQVJUICsgJywnICsgUkVEX1BUUiArICc9JyArIEVMRU1fU0laRSArICcqJyArIFJFRF9TVEFSVCArICc7JyArXG4gICAgICAgICdpPCcgKyBSRURfRU5EICsnOycgK1xuICAgICAgICAnKytpLCcgKyBSRURfUFRSICsgJys9JyArIEVMRU1fU0laRSArICcpeycgK1xuICAgICAgICAndmFyIHgwPScgKyBSRURfQk9YRVMgKyAnWycgKyBBWElTICsgJysnICsgUkVEX1BUUiArICddLCcgK1xuICAgICAgICAgICAgJ3gxPScgKyBSRURfQk9YRVMgKyAnWycgKyBBWElTICsgJysnICsgUkVEX1BUUiArICcrJyArIERJTUVOU0lPTiArICddLCcgK1xuICAgICAgICAgICAgJ3hpPScgKyBSRURfSU5ERVggKyAnW2ldOydcblxuICB2YXIgYmx1ZUxvb3AgPSBcbiAgICAnZm9yKHZhciBqPScgKyBCTFVFX1NUQVJUICsgJywnICsgQkxVRV9QVFIgKyAnPScgKyBFTEVNX1NJWkUgKyAnKicgKyBCTFVFX1NUQVJUICsgJzsnICtcbiAgICAgICAgJ2o8JyArIEJMVUVfRU5EICsgJzsnICtcbiAgICAgICAgJysraiwnICsgQkxVRV9QVFIgKyAnKz0nICsgRUxFTV9TSVpFICsgJyl7JyArXG4gICAgICAgICd2YXIgeTA9JyArIEJMVUVfQk9YRVMgKyAnWycgKyBBWElTICsgJysnICsgQkxVRV9QVFIgKyAnXSwnICtcbiAgICAgICAgICAgIChmdWxsID8gJ3kxPScgKyBCTFVFX0JPWEVTICsgJ1snICsgQVhJUyArICcrJyArIEJMVUVfUFRSICsgJysnICsgRElNRU5TSU9OICsgJ10sJyA6ICcnKSArXG4gICAgICAgICAgICAneWk9JyArIEJMVUVfSU5ERVggKyAnW2pdOydcblxuICBpZihyZWRNYWpvcikge1xuICAgIGNvZGUucHVzaChyZWRMb29wLCBJTk5FUl9MQUJFTCwgJzonLCBibHVlTG9vcClcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goYmx1ZUxvb3AsIElOTkVSX0xBQkVMLCAnOicsIHJlZExvb3ApXG4gIH1cblxuICBpZihmdWxsKSB7XG4gICAgY29kZS5wdXNoKCdpZih5MTx4MHx8eDE8eTApY29udGludWU7JylcbiAgfSBlbHNlIGlmKGZsaXApIHtcbiAgICBjb2RlLnB1c2goJ2lmKHkwPD14MHx8eDE8eTApY29udGludWU7JylcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goJ2lmKHkwPHgwfHx4MTx5MCljb250aW51ZTsnKVxuICB9XG5cbiAgY29kZS5wdXNoKCdmb3IodmFyIGs9JytBWElTKycrMTtrPCcrRElNRU5TSU9OKyc7KytrKXsnK1xuICAgICd2YXIgcjA9JytSRURfQk9YRVMrJ1trKycrUkVEX1BUUisnXSwnK1xuICAgICAgICAncjE9JytSRURfQk9YRVMrJ1trKycrRElNRU5TSU9OKycrJytSRURfUFRSKyddLCcrXG4gICAgICAgICdiMD0nK0JMVUVfQk9YRVMrJ1trKycrQkxVRV9QVFIrJ10sJytcbiAgICAgICAgJ2IxPScrQkxVRV9CT1hFUysnW2srJytESU1FTlNJT04rJysnK0JMVUVfUFRSKyddOycrXG4gICAgICAnaWYocjE8YjB8fGIxPHIwKWNvbnRpbnVlICcgKyBJTk5FUl9MQUJFTCArICc7fScgK1xuICAgICAgJ3ZhciAnICsgUkVUVkFMICsgJz0nICsgVklTSVQgKyAnKCcpXG5cbiAgaWYoZmxpcCkge1xuICAgIGNvZGUucHVzaCgneWkseGknKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaCgneGkseWknKVxuICB9XG5cbiAgY29kZS5wdXNoKCcpO2lmKCcgKyBSRVRWQUwgKyAnIT09dm9pZCAwKXJldHVybiAnICsgUkVUVkFMICsgJzt9fX0nKVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogZnVuY05hbWUsIFxuICAgIGNvZGU6IGNvZGUuam9pbignJylcbiAgfVxufVxuXG5mdW5jdGlvbiBicnV0ZUZvcmNlUGxhbm5lcihmdWxsKSB7XG4gIHZhciBmdW5jTmFtZSA9ICdicnV0ZUZvcmNlJyArIChmdWxsID8gJ0Z1bGwnIDogJ1BhcnRpYWwnKVxuICB2YXIgcHJlZml4ID0gW11cbiAgdmFyIGZhcmdzID0gQVJHUy5zbGljZSgpXG4gIGlmKCFmdWxsKSB7XG4gICAgZmFyZ3Muc3BsaWNlKDMsIDAsIEZMSVApXG4gIH1cblxuICB2YXIgY29kZSA9IFsnZnVuY3Rpb24gJyArIGZ1bmNOYW1lICsgJygnICsgZmFyZ3Muam9pbigpICsgJyl7J11cblxuICBmdW5jdGlvbiBpbnZva2UocmVkTWFqb3IsIGZsaXApIHtcbiAgICB2YXIgcmVzID0gZ2VuZXJhdGVCcnV0ZUZvcmNlKHJlZE1ham9yLCBmbGlwLCBmdWxsKVxuICAgIHByZWZpeC5wdXNoKHJlcy5jb2RlKVxuICAgIGNvZGUucHVzaCgncmV0dXJuICcgKyByZXMubmFtZSArICcoJyArIEFSR1Muam9pbigpICsgJyk7JylcbiAgfVxuXG4gIGNvZGUucHVzaCgnaWYoJyArIFJFRF9FTkQgKyAnLScgKyBSRURfU1RBUlQgKyAnPicgK1xuICAgICAgICAgICAgICAgICAgICBCTFVFX0VORCArICctJyArIEJMVUVfU1RBUlQgKyAnKXsnKVxuXG4gIGlmKGZ1bGwpIHtcbiAgICBpbnZva2UodHJ1ZSwgZmFsc2UpXG4gICAgY29kZS5wdXNoKCd9ZWxzZXsnKVxuICAgIGludm9rZShmYWxzZSwgZmFsc2UpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKCdpZignICsgRkxJUCArICcpeycpXG4gICAgaW52b2tlKHRydWUsIHRydWUpXG4gICAgY29kZS5wdXNoKCd9ZWxzZXsnKVxuICAgIGludm9rZSh0cnVlLCBmYWxzZSlcbiAgICBjb2RlLnB1c2goJ319ZWxzZXtpZignICsgRkxJUCArICcpeycpXG4gICAgaW52b2tlKGZhbHNlLCB0cnVlKVxuICAgIGNvZGUucHVzaCgnfWVsc2V7JylcbiAgICBpbnZva2UoZmFsc2UsIGZhbHNlKVxuICAgIGNvZGUucHVzaCgnfScpXG4gIH1cbiAgY29kZS5wdXNoKCd9fXJldHVybiAnICsgZnVuY05hbWUpXG5cbiAgdmFyIGNvZGVTdHIgPSBwcmVmaXguam9pbignJykgKyBjb2RlLmpvaW4oJycpXG4gIHZhciBwcm9jID0gbmV3IEZ1bmN0aW9uKGNvZGVTdHIpXG4gIHJldHVybiBwcm9jKClcbn1cblxuXG5leHBvcnRzLnBhcnRpYWwgPSBicnV0ZUZvcmNlUGxhbm5lcihmYWxzZSlcbmV4cG9ydHMuZnVsbCAgICA9IGJydXRlRm9yY2VQbGFubmVyKHRydWUpIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gYm94SW50ZXJzZWN0SXRlclxuXG52YXIgcG9vbCA9IHJlcXVpcmUoJ3R5cGVkYXJyYXktcG9vbCcpXG52YXIgYml0cyA9IHJlcXVpcmUoJ2JpdC10d2lkZGxlJylcbnZhciBicnV0ZUZvcmNlID0gcmVxdWlyZSgnLi9icnV0ZScpXG52YXIgYnJ1dGVGb3JjZVBhcnRpYWwgPSBicnV0ZUZvcmNlLnBhcnRpYWxcbnZhciBicnV0ZUZvcmNlRnVsbCA9IGJydXRlRm9yY2UuZnVsbFxudmFyIHN3ZWVwID0gcmVxdWlyZSgnLi9zd2VlcCcpXG52YXIgZmluZE1lZGlhbiA9IHJlcXVpcmUoJy4vbWVkaWFuJylcbnZhciBnZW5QYXJ0aXRpb24gPSByZXF1aXJlKCcuL3BhcnRpdGlvbicpXG5cbi8vVHdpZGRsZSBwYXJhbWV0ZXJzXG52YXIgQlJVVEVfRk9SQ0VfQ1VUT0ZGICAgID0gMTI4ICAgICAgIC8vQ3V0IG9mZiBmb3IgYnJ1dGUgZm9yY2Ugc2VhcmNoXG52YXIgU0NBTl9DVVRPRkYgICAgICAgICAgID0gKDE8PDIyKSAgIC8vQ3V0IG9mZiBmb3IgdHdvIHdheSBzY2FuXG52YXIgU0NBTl9DT01QTEVURV9DVVRPRkYgID0gKDE8PDIyKSAgXG5cbi8vUGFydGl0aW9uIGZ1bmN0aW9uc1xudmFyIHBhcnRpdGlvbkludGVyaW9yQ29udGFpbnNJbnRlcnZhbCA9IGdlblBhcnRpdGlvbihcbiAgJyEobG8+PXAwKSYmIShwMT49aGkpJywgXG4gIFsncDAnLCAncDEnXSlcblxudmFyIHBhcnRpdGlvblN0YXJ0RXF1YWwgPSBnZW5QYXJ0aXRpb24oXG4gICdsbz09PXAwJyxcbiAgWydwMCddKVxuXG52YXIgcGFydGl0aW9uU3RhcnRMZXNzVGhhbiA9IGdlblBhcnRpdGlvbihcbiAgJ2xvPHAwJyxcbiAgWydwMCddKVxuXG52YXIgcGFydGl0aW9uRW5kTGVzc1RoYW5FcXVhbCA9IGdlblBhcnRpdGlvbihcbiAgJ2hpPD1wMCcsXG4gIFsncDAnXSlcblxudmFyIHBhcnRpdGlvbkNvbnRhaW5zUG9pbnQgPSBnZW5QYXJ0aXRpb24oXG4gICdsbzw9cDAmJnAwPD1oaScsXG4gIFsncDAnXSlcblxudmFyIHBhcnRpdGlvbkNvbnRhaW5zUG9pbnRQcm9wZXIgPSBnZW5QYXJ0aXRpb24oXG4gICdsbzxwMCYmcDA8PWhpJyxcbiAgWydwMCddKVxuXG4vL0ZyYW1lIHNpemUgZm9yIGl0ZXJhdGl2ZSBsb29wXG52YXIgSUZSQU1FX1NJWkUgPSA2XG52YXIgREZSQU1FX1NJWkUgPSAyXG5cbi8vRGF0YSBmb3IgYm94IHN0YXRja1xudmFyIElOSVRfQ0FQQUNJVFkgPSAxMDI0XG52YXIgQk9YX0lTVEFDSyAgPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgQk9YX0RTVEFDSyAgPSBwb29sLm1hbGxvY0RvdWJsZShJTklUX0NBUEFDSVRZKVxuXG4vL0luaXRpYWxpemUgaXRlcmF0aXZlIGxvb3AgcXVldWVcbmZ1bmN0aW9uIGl0ZXJJbml0KGQsIGNvdW50KSB7XG4gIHZhciBsZXZlbHMgPSAoOCAqIGJpdHMubG9nMihjb3VudCsxKSAqIChkKzEpKXwwXG4gIHZhciBtYXhJbnRzID0gYml0cy5uZXh0UG93MihJRlJBTUVfU0laRSpsZXZlbHMpXG4gIGlmKEJPWF9JU1RBQ0subGVuZ3RoIDwgbWF4SW50cykge1xuICAgIHBvb2wuZnJlZShCT1hfSVNUQUNLKVxuICAgIEJPWF9JU1RBQ0sgPSBwb29sLm1hbGxvY0ludDMyKG1heEludHMpXG4gIH1cbiAgdmFyIG1heERvdWJsZXMgPSBiaXRzLm5leHRQb3cyKERGUkFNRV9TSVpFKmxldmVscylcbiAgaWYoQk9YX0RTVEFDSyA8IG1heERvdWJsZXMpIHtcbiAgICBwb29sLmZyZWUoQk9YX0RTVEFDSylcbiAgICBCT1hfRFNUQUNLID0gcG9vbC5tYWxsb2NEb3VibGUobWF4RG91YmxlcylcbiAgfVxufVxuXG4vL0FwcGVuZCBpdGVtIHRvIHF1ZXVlXG5mdW5jdGlvbiBpdGVyUHVzaChwdHIsXG4gIGF4aXMsIFxuICByZWRTdGFydCwgcmVkRW5kLCBcbiAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBcbiAgc3RhdGUsIFxuICBsbywgaGkpIHtcblxuICB2YXIgaXB0ciA9IElGUkFNRV9TSVpFICogcHRyXG4gIEJPWF9JU1RBQ0tbaXB0cl0gICA9IGF4aXNcbiAgQk9YX0lTVEFDS1tpcHRyKzFdID0gcmVkU3RhcnRcbiAgQk9YX0lTVEFDS1tpcHRyKzJdID0gcmVkRW5kXG4gIEJPWF9JU1RBQ0tbaXB0ciszXSA9IGJsdWVTdGFydFxuICBCT1hfSVNUQUNLW2lwdHIrNF0gPSBibHVlRW5kXG4gIEJPWF9JU1RBQ0tbaXB0cis1XSA9IHN0YXRlXG5cbiAgdmFyIGRwdHIgPSBERlJBTUVfU0laRSAqIHB0clxuICBCT1hfRFNUQUNLW2RwdHJdICAgPSBsb1xuICBCT1hfRFNUQUNLW2RwdHIrMV0gPSBoaVxufVxuXG4vL1NwZWNpYWwgY2FzZTogIEludGVyc2VjdCBzaW5nbGUgcG9pbnQgd2l0aCBsaXN0IG9mIGludGVydmFsc1xuZnVuY3Rpb24gb25lUG9pbnRQYXJ0aWFsKFxuICBkLCBheGlzLCB2aXNpdCwgZmxpcCxcbiAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgYmx1ZU9mZnNldCwgYmx1ZSwgYmx1ZUlkKSB7XG5cbiAgdmFyIGVsZW1TaXplID0gMiAqIGRcbiAgdmFyIGJsdWVQdHIgID0gYmx1ZU9mZnNldCAqIGVsZW1TaXplXG4gIHZhciBibHVlWCAgICA9IGJsdWVbYmx1ZVB0ciArIGF4aXNdXG5cbnJlZF9sb29wOlxuICBmb3IodmFyIGk9cmVkU3RhcnQsIHJlZFB0cj1yZWRTdGFydCplbGVtU2l6ZTsgaTxyZWRFbmQ7ICsraSwgcmVkUHRyKz1lbGVtU2l6ZSkge1xuICAgIHZhciByMCA9IHJlZFtyZWRQdHIrYXhpc11cbiAgICB2YXIgcjEgPSByZWRbcmVkUHRyK2F4aXMrZF1cbiAgICBpZihibHVlWCA8IHIwIHx8IHIxIDwgYmx1ZVgpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmKGZsaXAgJiYgYmx1ZVggPT09IHIwKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICB2YXIgcmVkSWQgPSByZWRJbmRleFtpXVxuICAgIGZvcih2YXIgaj1heGlzKzE7IGo8ZDsgKytqKSB7XG4gICAgICB2YXIgcjAgPSByZWRbcmVkUHRyK2pdXG4gICAgICB2YXIgcjEgPSByZWRbcmVkUHRyK2orZF1cbiAgICAgIHZhciBiMCA9IGJsdWVbYmx1ZVB0citqXVxuICAgICAgdmFyIGIxID0gYmx1ZVtibHVlUHRyK2orZF1cbiAgICAgIGlmKHIxIDwgYjAgfHwgYjEgPCByMCkge1xuICAgICAgICBjb250aW51ZSByZWRfbG9vcFxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmV0dmFsXG4gICAgaWYoZmxpcCkge1xuICAgICAgcmV0dmFsID0gdmlzaXQoYmx1ZUlkLCByZWRJZClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dmFsID0gdmlzaXQocmVkSWQsIGJsdWVJZClcbiAgICB9XG4gICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiByZXR2YWxcbiAgICB9XG4gIH1cbn1cblxuLy9TcGVjaWFsIGNhc2U6ICBJbnRlcnNlY3Qgb25lIHBvaW50IHdpdGggbGlzdCBvZiBpbnRlcnZhbHNcbmZ1bmN0aW9uIG9uZVBvaW50RnVsbChcbiAgZCwgYXhpcywgdmlzaXQsXG4gIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gIGJsdWVPZmZzZXQsIGJsdWUsIGJsdWVJZCkge1xuXG4gIHZhciBlbGVtU2l6ZSA9IDIgKiBkXG4gIHZhciBibHVlUHRyICA9IGJsdWVPZmZzZXQgKiBlbGVtU2l6ZVxuICB2YXIgYmx1ZVggICAgPSBibHVlW2JsdWVQdHIgKyBheGlzXVxuXG5yZWRfbG9vcDpcbiAgZm9yKHZhciBpPXJlZFN0YXJ0LCByZWRQdHI9cmVkU3RhcnQqZWxlbVNpemU7IGk8cmVkRW5kOyArK2ksIHJlZFB0cis9ZWxlbVNpemUpIHtcbiAgICB2YXIgcmVkSWQgPSByZWRJbmRleFtpXVxuICAgIGlmKHJlZElkID09PSBibHVlSWQpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciByMCA9IHJlZFtyZWRQdHIrYXhpc11cbiAgICB2YXIgcjEgPSByZWRbcmVkUHRyK2F4aXMrZF1cbiAgICBpZihibHVlWCA8IHIwIHx8IHIxIDwgYmx1ZVgpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGZvcih2YXIgaj1heGlzKzE7IGo8ZDsgKytqKSB7XG4gICAgICB2YXIgcjAgPSByZWRbcmVkUHRyK2pdXG4gICAgICB2YXIgcjEgPSByZWRbcmVkUHRyK2orZF1cbiAgICAgIHZhciBiMCA9IGJsdWVbYmx1ZVB0citqXVxuICAgICAgdmFyIGIxID0gYmx1ZVtibHVlUHRyK2orZF1cbiAgICAgIGlmKHIxIDwgYjAgfHwgYjEgPCByMCkge1xuICAgICAgICBjb250aW51ZSByZWRfbG9vcFxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmV0dmFsID0gdmlzaXQocmVkSWQsIGJsdWVJZClcbiAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHJldHZhbFxuICAgIH1cbiAgfVxufVxuXG4vL1RoZSBtYWluIGJveCBpbnRlcnNlY3Rpb24gcm91dGluZVxuZnVuY3Rpb24gYm94SW50ZXJzZWN0SXRlcihcbiAgZCwgdmlzaXQsIGluaXRGdWxsLFxuICB4U2l6ZSwgeEJveGVzLCB4SW5kZXgsXG4gIHlTaXplLCB5Qm94ZXMsIHlJbmRleCkge1xuXG4gIC8vUmVzZXJ2ZSBtZW1vcnkgZm9yIHN0YWNrXG4gIGl0ZXJJbml0KGQsIHhTaXplICsgeVNpemUpXG5cbiAgdmFyIHRvcCAgPSAwXG4gIHZhciBlbGVtU2l6ZSA9IDIgKiBkXG4gIHZhciByZXR2YWxcblxuICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgIDAsXG4gICAgICAwLCB4U2l6ZSxcbiAgICAgIDAsIHlTaXplLFxuICAgICAgaW5pdEZ1bGwgPyAxNiA6IDAsIFxuICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgaWYoIWluaXRGdWxsKSB7XG4gICAgaXRlclB1c2godG9wKyssXG4gICAgICAwLFxuICAgICAgMCwgeVNpemUsXG4gICAgICAwLCB4U2l6ZSxcbiAgICAgIDEsIFxuICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgfVxuXG4gIHdoaWxlKHRvcCA+IDApIHtcbiAgICB0b3AgIC09IDFcblxuICAgIHZhciBpcHRyID0gdG9wICogSUZSQU1FX1NJWkVcbiAgICB2YXIgYXhpcyAgICAgID0gQk9YX0lTVEFDS1tpcHRyXVxuICAgIHZhciByZWRTdGFydCAgPSBCT1hfSVNUQUNLW2lwdHIrMV1cbiAgICB2YXIgcmVkRW5kICAgID0gQk9YX0lTVEFDS1tpcHRyKzJdXG4gICAgdmFyIGJsdWVTdGFydCA9IEJPWF9JU1RBQ0tbaXB0ciszXVxuICAgIHZhciBibHVlRW5kICAgPSBCT1hfSVNUQUNLW2lwdHIrNF1cbiAgICB2YXIgc3RhdGUgICAgID0gQk9YX0lTVEFDS1tpcHRyKzVdXG5cbiAgICB2YXIgZHB0ciA9IHRvcCAqIERGUkFNRV9TSVpFXG4gICAgdmFyIGxvICAgICAgICA9IEJPWF9EU1RBQ0tbZHB0cl1cbiAgICB2YXIgaGkgICAgICAgID0gQk9YX0RTVEFDS1tkcHRyKzFdXG5cbiAgICAvL1VucGFjayBzdGF0ZSBpbmZvXG4gICAgdmFyIGZsaXAgICAgICA9IChzdGF0ZSAmIDEpXG4gICAgdmFyIGZ1bGwgICAgICA9ICEhKHN0YXRlICYgMTYpXG5cbiAgICAvL1VucGFjayBpbmRpY2VzXG4gICAgdmFyIHJlZCAgICAgICA9IHhCb3hlc1xuICAgIHZhciByZWRJbmRleCAgPSB4SW5kZXhcbiAgICB2YXIgYmx1ZSAgICAgID0geUJveGVzXG4gICAgdmFyIGJsdWVJbmRleCA9IHlJbmRleFxuICAgIGlmKGZsaXApIHtcbiAgICAgIHJlZCAgICAgICAgID0geUJveGVzXG4gICAgICByZWRJbmRleCAgICA9IHlJbmRleFxuICAgICAgYmx1ZSAgICAgICAgPSB4Qm94ZXNcbiAgICAgIGJsdWVJbmRleCAgID0geEluZGV4XG4gICAgfVxuXG4gICAgaWYoc3RhdGUgJiAyKSB7XG4gICAgICByZWRFbmQgPSBwYXJ0aXRpb25TdGFydExlc3NUaGFuKFxuICAgICAgICBkLCBheGlzLFxuICAgICAgICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICBoaSlcbiAgICAgIGlmKHJlZFN0YXJ0ID49IHJlZEVuZCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZihzdGF0ZSAmIDQpIHtcbiAgICAgIHJlZFN0YXJ0ID0gcGFydGl0aW9uRW5kTGVzc1RoYW5FcXVhbChcbiAgICAgICAgZCwgYXhpcyxcbiAgICAgICAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgbG8pXG4gICAgICBpZihyZWRTdGFydCA+PSByZWRFbmQpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdmFyIHJlZENvdW50ICA9IHJlZEVuZCAgLSByZWRTdGFydFxuICAgIHZhciBibHVlQ291bnQgPSBibHVlRW5kIC0gYmx1ZVN0YXJ0XG5cbiAgICBpZihmdWxsKSB7XG4gICAgICBpZihkICogcmVkQ291bnQgKiAocmVkQ291bnQgKyBibHVlQ291bnQpIDwgU0NBTl9DT01QTEVURV9DVVRPRkYpIHtcbiAgICAgICAgcmV0dmFsID0gc3dlZXAuc2NhbkNvbXBsZXRlKFxuICAgICAgICAgIGQsIGF4aXMsIHZpc2l0LCBcbiAgICAgICAgICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZihkICogTWF0aC5taW4ocmVkQ291bnQsIGJsdWVDb3VudCkgPCBCUlVURV9GT1JDRV9DVVRPRkYpIHtcbiAgICAgICAgLy9JZiBpbnB1dCBzbWFsbCwgdGhlbiB1c2UgYnJ1dGUgZm9yY2VcbiAgICAgICAgcmV0dmFsID0gYnJ1dGVGb3JjZVBhcnRpYWwoXG4gICAgICAgICAgICBkLCBheGlzLCB2aXNpdCwgZmxpcCxcbiAgICAgICAgICAgIHJlZFN0YXJ0LCAgcmVkRW5kLCAgcmVkLCAgcmVkSW5kZXgsXG4gICAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSBpZihkICogcmVkQ291bnQgKiBibHVlQ291bnQgPCBTQ0FOX0NVVE9GRikge1xuICAgICAgICAvL0lmIGlucHV0IG1lZGl1bSBzaXplZCwgdGhlbiB1c2Ugc3dlZXAgYW5kIHBydW5lXG4gICAgICAgIHJldHZhbCA9IHN3ZWVwLnNjYW5CaXBhcnRpdGUoXG4gICAgICAgICAgZCwgYXhpcywgdmlzaXQsIGZsaXAsIFxuICAgICAgICAgIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vRmlyc3QsIGZpbmQgYWxsIHJlZCBpbnRlcnZhbHMgd2hvc2UgaW50ZXJpb3IgY29udGFpbnMgKGxvLGhpKVxuICAgIHZhciByZWQwID0gcGFydGl0aW9uSW50ZXJpb3JDb250YWluc0ludGVydmFsKFxuICAgICAgZCwgYXhpcywgXG4gICAgICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgbG8sIGhpKVxuXG4gICAgLy9Mb3dlciBkaW1lbnNpb25hbCBjYXNlXG4gICAgaWYocmVkU3RhcnQgPCByZWQwKSB7XG5cbiAgICAgIGlmKGQgKiAocmVkMCAtIHJlZFN0YXJ0KSA8IEJSVVRFX0ZPUkNFX0NVVE9GRikge1xuICAgICAgICAvL1NwZWNpYWwgY2FzZSBmb3Igc21hbGwgaW5wdXRzOiB1c2UgYnJ1dGUgZm9yY2VcbiAgICAgICAgcmV0dmFsID0gYnJ1dGVGb3JjZUZ1bGwoXG4gICAgICAgICAgZCwgYXhpcysxLCB2aXNpdCxcbiAgICAgICAgICByZWRTdGFydCwgcmVkMCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihheGlzID09PSBkLTIpIHtcbiAgICAgICAgaWYoZmxpcCkge1xuICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQmlwYXJ0aXRlKFxuICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleCxcbiAgICAgICAgICAgIHJlZFN0YXJ0LCByZWQwLCByZWQsIHJlZEluZGV4KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQmlwYXJ0aXRlKFxuICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICByZWRTdGFydCwgcmVkMCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICB9XG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgcmVkU3RhcnQsIHJlZDAsXG4gICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLFxuICAgICAgICAgIGZsaXAsXG4gICAgICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgYXhpcysxLFxuICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCxcbiAgICAgICAgICByZWRTdGFydCwgcmVkMCxcbiAgICAgICAgICBmbGlwXjEsXG4gICAgICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL0RpdmlkZSBhbmQgY29ucXVlciBwaGFzZVxuICAgIGlmKHJlZDAgPCByZWRFbmQpIHtcblxuICAgICAgLy9DdXQgYmx1ZSBpbnRvIDMgcGFydHM6XG4gICAgICAvL1xuICAgICAgLy8gIFBvaW50cyA8IG1pZCBwb2ludFxuICAgICAgLy8gIFBvaW50cyA9IG1pZCBwb2ludFxuICAgICAgLy8gIFBvaW50cyA+IG1pZCBwb2ludFxuICAgICAgLy9cbiAgICAgIHZhciBibHVlMCA9IGZpbmRNZWRpYW4oXG4gICAgICAgIGQsIGF4aXMsIFxuICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgIHZhciBtaWQgPSBibHVlW2VsZW1TaXplICogYmx1ZTAgKyBheGlzXVxuICAgICAgdmFyIGJsdWUxID0gcGFydGl0aW9uU3RhcnRFcXVhbChcbiAgICAgICAgZCwgYXhpcyxcbiAgICAgICAgYmx1ZTAsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleCxcbiAgICAgICAgbWlkKVxuXG4gICAgICAvL1JpZ2h0IGNhc2VcbiAgICAgIGlmKGJsdWUxIDwgYmx1ZUVuZCkge1xuICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICBheGlzLFxuICAgICAgICAgIHJlZDAsIHJlZEVuZCxcbiAgICAgICAgICBibHVlMSwgYmx1ZUVuZCxcbiAgICAgICAgICAoZmxpcHw0KSArIChmdWxsID8gMTYgOiAwKSxcbiAgICAgICAgICBtaWQsIGhpKVxuICAgICAgfVxuXG4gICAgICAvL0xlZnQgY2FzZVxuICAgICAgaWYoYmx1ZVN0YXJ0IDwgYmx1ZTApIHtcbiAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgYXhpcyxcbiAgICAgICAgICByZWQwLCByZWRFbmQsXG4gICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlMCxcbiAgICAgICAgICAoZmxpcHwyKSArIChmdWxsID8gMTYgOiAwKSxcbiAgICAgICAgICBsbywgbWlkKVxuICAgICAgfVxuXG4gICAgICAvL0NlbnRlciBjYXNlICh0aGUgaGFyZCBwYXJ0KVxuICAgICAgaWYoYmx1ZTAgKyAxID09PSBibHVlMSkge1xuICAgICAgICAvL09wdGltaXphdGlvbjogUmFuZ2Ugd2l0aCBleGFjdGx5IDEgcG9pbnQsIHVzZSBhIGJydXRlIGZvcmNlIHNjYW5cbiAgICAgICAgaWYoZnVsbCkge1xuICAgICAgICAgIHJldHZhbCA9IG9uZVBvaW50RnVsbChcbiAgICAgICAgICAgIGQsIGF4aXMsIHZpc2l0LFxuICAgICAgICAgICAgcmVkMCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgYmx1ZTAsIGJsdWUsIGJsdWVJbmRleFtibHVlMF0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dmFsID0gb25lUG9pbnRQYXJ0aWFsKFxuICAgICAgICAgICAgZCwgYXhpcywgdmlzaXQsIGZsaXAsXG4gICAgICAgICAgICByZWQwLCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICBibHVlMCwgYmx1ZSwgYmx1ZUluZGV4W2JsdWUwXSlcbiAgICAgICAgfVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKGJsdWUwIDwgYmx1ZTEpIHtcbiAgICAgICAgdmFyIHJlZDFcbiAgICAgICAgaWYoZnVsbCkge1xuICAgICAgICAgIC8vSWYgZnVsbCBpbnRlcnNlY3Rpb24sIG5lZWQgdG8gaGFuZGxlIHNwZWNpYWwgY2FzZVxuICAgICAgICAgIHJlZDEgPSBwYXJ0aXRpb25Db250YWluc1BvaW50KFxuICAgICAgICAgICAgZCwgYXhpcyxcbiAgICAgICAgICAgIHJlZDAsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgIG1pZClcbiAgICAgICAgICBpZihyZWQwIDwgcmVkMSkge1xuICAgICAgICAgICAgdmFyIHJlZFggPSBwYXJ0aXRpb25TdGFydEVxdWFsKFxuICAgICAgICAgICAgICBkLCBheGlzLFxuICAgICAgICAgICAgICByZWQwLCByZWQxLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICBtaWQpXG4gICAgICAgICAgICBpZihheGlzID09PSBkLTIpIHtcbiAgICAgICAgICAgICAgLy9EZWdlbmVyYXRlIHN3ZWVwIGludGVyc2VjdGlvbjpcbiAgICAgICAgICAgICAgLy8gIFtyZWQwLCByZWRYXSB3aXRoIFtibHVlMCwgYmx1ZTFdXG4gICAgICAgICAgICAgIGlmKHJlZDAgPCByZWRYKSB7XG4gICAgICAgICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBDb21wbGV0ZShcbiAgICAgICAgICAgICAgICAgIGQsIHZpc2l0LFxuICAgICAgICAgICAgICAgICAgcmVkMCwgcmVkWCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICAgICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy9Ob3JtYWwgc3dlZXAgaW50ZXJzZWN0aW9uOlxuICAgICAgICAgICAgICAvLyAgW3JlZFgsIHJlZDFdIHdpdGggW2JsdWUwLCBibHVlMV1cbiAgICAgICAgICAgICAgaWYocmVkWCA8IHJlZDEpIHtcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcEJpcGFydGl0ZShcbiAgICAgICAgICAgICAgICAgIGQsIHZpc2l0LFxuICAgICAgICAgICAgICAgICAgcmVkWCwgcmVkMSwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICAgICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZihyZWQwIDwgcmVkWCkge1xuICAgICAgICAgICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgICAgICAgICAgYXhpcysxLFxuICAgICAgICAgICAgICAgICAgcmVkMCwgcmVkWCxcbiAgICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSxcbiAgICAgICAgICAgICAgICAgIDE2LFxuICAgICAgICAgICAgICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZihyZWRYIDwgcmVkMSkge1xuICAgICAgICAgICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgICAgICAgICAgYXhpcysxLFxuICAgICAgICAgICAgICAgICAgcmVkWCwgcmVkMSxcbiAgICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSxcbiAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICAgICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgICAgICAgICAgYXhpcysxLFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLFxuICAgICAgICAgICAgICAgICAgcmVkWCwgcmVkMSxcbiAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKGZsaXApIHtcbiAgICAgICAgICAgIHJlZDEgPSBwYXJ0aXRpb25Db250YWluc1BvaW50UHJvcGVyKFxuICAgICAgICAgICAgICBkLCBheGlzLFxuICAgICAgICAgICAgICByZWQwLCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgIG1pZClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVkMSA9IHBhcnRpdGlvbkNvbnRhaW5zUG9pbnQoXG4gICAgICAgICAgICAgIGQsIGF4aXMsXG4gICAgICAgICAgICAgIHJlZDAsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgICAgbWlkKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZWQwIDwgcmVkMSkge1xuICAgICAgICAgICAgaWYoYXhpcyA9PT0gZC0yKSB7XG4gICAgICAgICAgICAgIGlmKGZsaXApIHtcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcEJpcGFydGl0ZShcbiAgICAgICAgICAgICAgICAgIGQsIHZpc2l0LFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLCBibHVlLCBibHVlSW5kZXgsXG4gICAgICAgICAgICAgICAgICByZWQwLCByZWQxLCByZWQsIHJlZEluZGV4KVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQmlwYXJ0aXRlKFxuICAgICAgICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICAgICAgICByZWQwLCByZWQxLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICAgICAgICByZWQwLCByZWQxLFxuICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSxcbiAgICAgICAgICAgICAgICBmbGlwLFxuICAgICAgICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsXG4gICAgICAgICAgICAgICAgcmVkMCwgcmVkMSxcbiAgICAgICAgICAgICAgICBmbGlwXjEsXG4gICAgICAgICAgICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kTWVkaWFuXG5cbnZhciBnZW5QYXJ0aXRpb24gPSByZXF1aXJlKCcuL3BhcnRpdGlvbicpXG5cbnZhciBwYXJ0aXRpb25TdGFydExlc3NUaGFuID0gZ2VuUGFydGl0aW9uKCdsbzxwMCcsIFsncDAnXSlcblxudmFyIFBBUlRJVElPTl9USFJFU0hPTEQgPSA4ICAgLy9DdXQgb2ZmIGZvciB1c2luZyBpbnNlcnRpb24gc29ydCBpbiBmaW5kTWVkaWFuXG5cbi8vQmFzZSBjYXNlIGZvciBtZWRpYW4gZmluZGluZzogIFVzZSBpbnNlcnRpb24gc29ydFxuZnVuY3Rpb24gaW5zZXJ0aW9uU29ydChkLCBheGlzLCBzdGFydCwgZW5kLCBib3hlcywgaWRzKSB7XG4gIHZhciBlbGVtU2l6ZSA9IDIgKiBkXG4gIHZhciBib3hQdHIgPSBlbGVtU2l6ZSAqIChzdGFydCsxKSArIGF4aXNcbiAgZm9yKHZhciBpPXN0YXJ0KzE7IGk8ZW5kOyArK2ksIGJveFB0cis9ZWxlbVNpemUpIHtcbiAgICB2YXIgeCA9IGJveGVzW2JveFB0cl1cbiAgICBmb3IodmFyIGo9aSwgcHRyPWVsZW1TaXplKihpLTEpOyBcbiAgICAgICAgaj5zdGFydCAmJiBib3hlc1twdHIrYXhpc10gPiB4OyBcbiAgICAgICAgLS1qLCBwdHItPWVsZW1TaXplKSB7XG4gICAgICAvL1N3YXBcbiAgICAgIHZhciBhUHRyID0gcHRyXG4gICAgICB2YXIgYlB0ciA9IHB0citlbGVtU2l6ZVxuICAgICAgZm9yKHZhciBrPTA7IGs8ZWxlbVNpemU7ICsraywgKythUHRyLCArK2JQdHIpIHtcbiAgICAgICAgdmFyIHkgPSBib3hlc1thUHRyXVxuICAgICAgICBib3hlc1thUHRyXSA9IGJveGVzW2JQdHJdXG4gICAgICAgIGJveGVzW2JQdHJdID0geVxuICAgICAgfVxuICAgICAgdmFyIHRtcCA9IGlkc1tqXVxuICAgICAgaWRzW2pdID0gaWRzW2otMV1cbiAgICAgIGlkc1tqLTFdID0gdG1wXG4gICAgfVxuICB9XG59XG5cbi8vRmluZCBtZWRpYW4gdXNpbmcgcXVpY2sgc2VsZWN0IGFsZ29yaXRobVxuLy8gIHRha2VzIE8obikgdGltZSB3aXRoIGhpZ2ggcHJvYmFiaWxpdHlcbmZ1bmN0aW9uIGZpbmRNZWRpYW4oZCwgYXhpcywgc3RhcnQsIGVuZCwgYm94ZXMsIGlkcykge1xuICBpZihlbmQgPD0gc3RhcnQrMSkge1xuICAgIHJldHVybiBzdGFydFxuICB9XG5cbiAgdmFyIGxvICAgICAgID0gc3RhcnRcbiAgdmFyIGhpICAgICAgID0gZW5kXG4gIHZhciBtaWQgICAgICA9ICgoZW5kICsgc3RhcnQpID4+PiAxKVxuICB2YXIgZWxlbVNpemUgPSAyKmRcbiAgdmFyIHBpdm90ICAgID0gbWlkXG4gIHZhciB2YWx1ZSAgICA9IGJveGVzW2VsZW1TaXplKm1pZCtheGlzXVxuICBcbiAgd2hpbGUobG8gPCBoaSkge1xuICAgIGlmKGhpIC0gbG8gPCBQQVJUSVRJT05fVEhSRVNIT0xEKSB7XG4gICAgICBpbnNlcnRpb25Tb3J0KGQsIGF4aXMsIGxvLCBoaSwgYm94ZXMsIGlkcylcbiAgICAgIHZhbHVlID0gYm94ZXNbZWxlbVNpemUqbWlkK2F4aXNdXG4gICAgICBicmVha1xuICAgIH1cbiAgICBcbiAgICAvL1NlbGVjdCBwaXZvdCB1c2luZyBtZWRpYW4tb2YtM1xuICAgIHZhciBjb3VudCAgPSBoaSAtIGxvXG4gICAgdmFyIHBpdm90MCA9IChNYXRoLnJhbmRvbSgpKmNvdW50K2xvKXwwXG4gICAgdmFyIHZhbHVlMCA9IGJveGVzW2VsZW1TaXplKnBpdm90MCArIGF4aXNdXG4gICAgdmFyIHBpdm90MSA9IChNYXRoLnJhbmRvbSgpKmNvdW50K2xvKXwwXG4gICAgdmFyIHZhbHVlMSA9IGJveGVzW2VsZW1TaXplKnBpdm90MSArIGF4aXNdXG4gICAgdmFyIHBpdm90MiA9IChNYXRoLnJhbmRvbSgpKmNvdW50K2xvKXwwXG4gICAgdmFyIHZhbHVlMiA9IGJveGVzW2VsZW1TaXplKnBpdm90MiArIGF4aXNdXG4gICAgaWYodmFsdWUwIDw9IHZhbHVlMSkge1xuICAgICAgaWYodmFsdWUyID49IHZhbHVlMSkge1xuICAgICAgICBwaXZvdCA9IHBpdm90MVxuICAgICAgICB2YWx1ZSA9IHZhbHVlMVxuICAgICAgfSBlbHNlIGlmKHZhbHVlMCA+PSB2YWx1ZTIpIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdDBcbiAgICAgICAgdmFsdWUgPSB2YWx1ZTBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3QyXG4gICAgICAgIHZhbHVlID0gdmFsdWUyXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKHZhbHVlMSA+PSB2YWx1ZTIpIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdDFcbiAgICAgICAgdmFsdWUgPSB2YWx1ZTFcbiAgICAgIH0gZWxzZSBpZih2YWx1ZTIgPj0gdmFsdWUwKSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3QwXG4gICAgICAgIHZhbHVlID0gdmFsdWUwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaXZvdCA9IHBpdm90MlxuICAgICAgICB2YWx1ZSA9IHZhbHVlMlxuICAgICAgfVxuICAgIH1cblxuICAgIC8vU3dhcCBwaXZvdCB0byBlbmQgb2YgYXJyYXlcbiAgICB2YXIgYVB0ciA9IGVsZW1TaXplICogKGhpLTEpXG4gICAgdmFyIGJQdHIgPSBlbGVtU2l6ZSAqIHBpdm90XG4gICAgZm9yKHZhciBpPTA7IGk8ZWxlbVNpemU7ICsraSwgKythUHRyLCArK2JQdHIpIHtcbiAgICAgIHZhciB4ID0gYm94ZXNbYVB0cl1cbiAgICAgIGJveGVzW2FQdHJdID0gYm94ZXNbYlB0cl1cbiAgICAgIGJveGVzW2JQdHJdID0geFxuICAgIH1cbiAgICB2YXIgeSA9IGlkc1toaS0xXVxuICAgIGlkc1toaS0xXSA9IGlkc1twaXZvdF1cbiAgICBpZHNbcGl2b3RdID0geVxuXG4gICAgLy9QYXJ0aXRpb24gdXNpbmcgcGl2b3RcbiAgICBwaXZvdCA9IHBhcnRpdGlvblN0YXJ0TGVzc1RoYW4oXG4gICAgICBkLCBheGlzLCBcbiAgICAgIGxvLCBoaS0xLCBib3hlcywgaWRzLFxuICAgICAgdmFsdWUpXG5cbiAgICAvL1N3YXAgcGl2b3QgYmFja1xuICAgIHZhciBhUHRyID0gZWxlbVNpemUgKiAoaGktMSlcbiAgICB2YXIgYlB0ciA9IGVsZW1TaXplICogcGl2b3RcbiAgICBmb3IodmFyIGk9MDsgaTxlbGVtU2l6ZTsgKytpLCArK2FQdHIsICsrYlB0cikge1xuICAgICAgdmFyIHggPSBib3hlc1thUHRyXVxuICAgICAgYm94ZXNbYVB0cl0gPSBib3hlc1tiUHRyXVxuICAgICAgYm94ZXNbYlB0cl0gPSB4XG4gICAgfVxuICAgIHZhciB5ID0gaWRzW2hpLTFdXG4gICAgaWRzW2hpLTFdID0gaWRzW3Bpdm90XVxuICAgIGlkc1twaXZvdF0gPSB5XG5cbiAgICAvL1N3YXAgcGl2b3QgdG8gbGFzdCBwaXZvdFxuICAgIGlmKG1pZCA8IHBpdm90KSB7XG4gICAgICBoaSA9IHBpdm90LTFcbiAgICAgIHdoaWxlKGxvIDwgaGkgJiYgXG4gICAgICAgIGJveGVzW2VsZW1TaXplKihoaS0xKStheGlzXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgaGkgLT0gMVxuICAgICAgfVxuICAgICAgaGkgKz0gMVxuICAgIH0gZWxzZSBpZihwaXZvdCA8IG1pZCkge1xuICAgICAgbG8gPSBwaXZvdCArIDFcbiAgICAgIHdoaWxlKGxvIDwgaGkgJiZcbiAgICAgICAgYm94ZXNbZWxlbVNpemUqbG8rYXhpc10gPT09IHZhbHVlKSB7XG4gICAgICAgIGxvICs9IDFcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvL01ha2Ugc3VyZSBwaXZvdCBpcyBhdCBzdGFydFxuICByZXR1cm4gcGFydGl0aW9uU3RhcnRMZXNzVGhhbihcbiAgICBkLCBheGlzLCBcbiAgICBzdGFydCwgbWlkLCBib3hlcywgaWRzLFxuICAgIGJveGVzW2VsZW1TaXplKm1pZCtheGlzXSlcbn0iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBnZW5QYXJ0aXRpb25cblxudmFyIGNvZGUgPSAnZm9yKHZhciBqPTIqYSxrPWoqYyxsPWssbT1jLG49YixvPWErYixwPWM7ZD5wOysrcCxrKz1qKXt2YXIgXztpZigkKWlmKG09PT1wKW0rPTEsbCs9ajtlbHNle2Zvcih2YXIgcz0wO2o+czsrK3Mpe3ZhciB0PWVbaytzXTtlW2src109ZVtsXSxlW2wrK109dH12YXIgdT1mW3BdO2ZbcF09ZlttXSxmW20rK109dX19cmV0dXJuIG0nXG5cbmZ1bmN0aW9uIGdlblBhcnRpdGlvbihwcmVkaWNhdGUsIGFyZ3MpIHtcbiAgdmFyIGZhcmdzID0nYWJjZGVmJy5zcGxpdCgnJykuY29uY2F0KGFyZ3MpXG4gIHZhciByZWFkcyA9IFtdXG4gIGlmKHByZWRpY2F0ZS5pbmRleE9mKCdsbycpID49IDApIHtcbiAgICByZWFkcy5wdXNoKCdsbz1lW2srbl0nKVxuICB9XG4gIGlmKHByZWRpY2F0ZS5pbmRleE9mKCdoaScpID49IDApIHtcbiAgICByZWFkcy5wdXNoKCdoaT1lW2srb10nKVxuICB9XG4gIGZhcmdzLnB1c2goXG4gICAgY29kZS5yZXBsYWNlKCdfJywgcmVhZHMuam9pbigpKVxuICAgICAgICAucmVwbGFjZSgnJCcsIHByZWRpY2F0ZSkpXG4gIHJldHVybiBGdW5jdGlvbi5hcHBseSh2b2lkIDAsIGZhcmdzKVxufSIsIid1c2Ugc3RyaWN0JztcblxuLy9UaGlzIGNvZGUgaXMgZXh0cmFjdGVkIGZyb20gbmRhcnJheS1zb3J0XG4vL0l0IGlzIGlubGluZWQgaGVyZSBhcyBhIHRlbXBvcmFyeSB3b3JrYXJvdW5kXG5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHBlcjtcblxudmFyIElOU0VSVF9TT1JUX0NVVE9GRiA9IDMyXG5cbmZ1bmN0aW9uIHdyYXBwZXIoZGF0YSwgbjApIHtcbiAgaWYgKG4wIDw9IDQqSU5TRVJUX1NPUlRfQ1VUT0ZGKSB7XG4gICAgaW5zZXJ0aW9uU29ydCgwLCBuMCAtIDEsIGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHF1aWNrU29ydCgwLCBuMCAtIDEsIGRhdGEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydGlvblNvcnQobGVmdCwgcmlnaHQsIGRhdGEpIHtcbiAgdmFyIHB0ciA9IDIqKGxlZnQrMSlcbiAgZm9yKHZhciBpPWxlZnQrMTsgaTw9cmlnaHQ7ICsraSkge1xuICAgIHZhciBhID0gZGF0YVtwdHIrK11cbiAgICB2YXIgYiA9IGRhdGFbcHRyKytdXG4gICAgdmFyIGogPSBpXG4gICAgdmFyIGpwdHIgPSBwdHItMlxuICAgIHdoaWxlKGotLSA+IGxlZnQpIHtcbiAgICAgIHZhciB4ID0gZGF0YVtqcHRyLTJdXG4gICAgICB2YXIgeSA9IGRhdGFbanB0ci0xXVxuICAgICAgaWYoeCA8IGEpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZih4ID09PSBhICYmIHkgPCBiKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBkYXRhW2pwdHJdICAgPSB4XG4gICAgICBkYXRhW2pwdHIrMV0gPSB5XG4gICAgICBqcHRyIC09IDJcbiAgICB9XG4gICAgZGF0YVtqcHRyXSAgID0gYVxuICAgIGRhdGFbanB0cisxXSA9IGJcbiAgfVxufVxuXG5mdW5jdGlvbiBzd2FwKGksIGosIGRhdGEpIHtcbiAgaSAqPSAyXG4gIGogKj0gMlxuICB2YXIgeCA9IGRhdGFbaV1cbiAgdmFyIHkgPSBkYXRhW2krMV1cbiAgZGF0YVtpXSA9IGRhdGFbal1cbiAgZGF0YVtpKzFdID0gZGF0YVtqKzFdXG4gIGRhdGFbal0gPSB4XG4gIGRhdGFbaisxXSA9IHlcbn1cblxuZnVuY3Rpb24gbW92ZShpLCBqLCBkYXRhKSB7XG4gIGkgKj0gMlxuICBqICo9IDJcbiAgZGF0YVtpXSA9IGRhdGFbal1cbiAgZGF0YVtpKzFdID0gZGF0YVtqKzFdXG59XG5cbmZ1bmN0aW9uIHJvdGF0ZShpLCBqLCBrLCBkYXRhKSB7XG4gIGkgKj0gMlxuICBqICo9IDJcbiAgayAqPSAyXG4gIHZhciB4ID0gZGF0YVtpXVxuICB2YXIgeSA9IGRhdGFbaSsxXVxuICBkYXRhW2ldID0gZGF0YVtqXVxuICBkYXRhW2krMV0gPSBkYXRhW2orMV1cbiAgZGF0YVtqXSA9IGRhdGFba11cbiAgZGF0YVtqKzFdID0gZGF0YVtrKzFdXG4gIGRhdGFba10gPSB4XG4gIGRhdGFbaysxXSA9IHlcbn1cblxuZnVuY3Rpb24gc2h1ZmZsZVBpdm90KGksIGosIHB4LCBweSwgZGF0YSkge1xuICBpICo9IDJcbiAgaiAqPSAyXG4gIGRhdGFbaV0gPSBkYXRhW2pdXG4gIGRhdGFbal0gPSBweFxuICBkYXRhW2krMV0gPSBkYXRhW2orMV1cbiAgZGF0YVtqKzFdID0gcHlcbn1cblxuZnVuY3Rpb24gY29tcGFyZShpLCBqLCBkYXRhKSB7XG4gIGkgKj0gMlxuICBqICo9IDJcbiAgdmFyIHggPSBkYXRhW2ldLFxuICAgICAgeSA9IGRhdGFbal1cbiAgaWYoeCA8IHkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmKHggPT09IHkpIHtcbiAgICByZXR1cm4gZGF0YVtpKzFdID4gZGF0YVtqKzFdXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gY29tcGFyZVBpdm90KGksIHksIGIsIGRhdGEpIHtcbiAgaSAqPSAyXG4gIHZhciB4ID0gZGF0YVtpXVxuICBpZih4IDwgeSkge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZih4ID09PSB5KSB7XG4gICAgcmV0dXJuIGRhdGFbaSsxXSA8IGJcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcXVpY2tTb3J0KGxlZnQsIHJpZ2h0LCBkYXRhKSB7XG4gIHZhciBzaXh0aCA9IChyaWdodCAtIGxlZnQgKyAxKSAvIDYgfCAwLCBcbiAgICAgIGluZGV4MSA9IGxlZnQgKyBzaXh0aCwgXG4gICAgICBpbmRleDUgPSByaWdodCAtIHNpeHRoLCBcbiAgICAgIGluZGV4MyA9IGxlZnQgKyByaWdodCA+PiAxLCBcbiAgICAgIGluZGV4MiA9IGluZGV4MyAtIHNpeHRoLCBcbiAgICAgIGluZGV4NCA9IGluZGV4MyArIHNpeHRoLCBcbiAgICAgIGVsMSA9IGluZGV4MSwgXG4gICAgICBlbDIgPSBpbmRleDIsIFxuICAgICAgZWwzID0gaW5kZXgzLCBcbiAgICAgIGVsNCA9IGluZGV4NCwgXG4gICAgICBlbDUgPSBpbmRleDUsIFxuICAgICAgbGVzcyA9IGxlZnQgKyAxLCBcbiAgICAgIGdyZWF0ID0gcmlnaHQgLSAxLCBcbiAgICAgIHRtcCA9IDBcbiAgaWYoY29tcGFyZShlbDEsIGVsMiwgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDFcbiAgICBlbDEgPSBlbDJcbiAgICBlbDIgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsNCwgZWw1LCBkYXRhKSkge1xuICAgIHRtcCA9IGVsNFxuICAgIGVsNCA9IGVsNVxuICAgIGVsNSA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWwxLCBlbDMsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwxXG4gICAgZWwxID0gZWwzXG4gICAgZWwzID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDIsIGVsMywgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDJcbiAgICBlbDIgPSBlbDNcbiAgICBlbDMgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsMSwgZWw0LCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMVxuICAgIGVsMSA9IGVsNFxuICAgIGVsNCA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWwzLCBlbDQsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwzXG4gICAgZWwzID0gZWw0XG4gICAgZWw0ID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDIsIGVsNSwgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDJcbiAgICBlbDIgPSBlbDVcbiAgICBlbDUgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsMiwgZWwzLCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMlxuICAgIGVsMiA9IGVsM1xuICAgIGVsMyA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWw0LCBlbDUsIGRhdGEpKSB7XG4gICAgdG1wID0gZWw0XG4gICAgZWw0ID0gZWw1XG4gICAgZWw1ID0gdG1wXG4gIH1cblxuICB2YXIgcGl2b3QxWCA9IGRhdGFbMiplbDJdXG4gIHZhciBwaXZvdDFZID0gZGF0YVsyKmVsMisxXVxuICB2YXIgcGl2b3QyWCA9IGRhdGFbMiplbDRdXG4gIHZhciBwaXZvdDJZID0gZGF0YVsyKmVsNCsxXVxuXG4gIHZhciBwdHIwID0gMiAqIGVsMTtcbiAgdmFyIHB0cjIgPSAyICogZWwzO1xuICB2YXIgcHRyNCA9IDIgKiBlbDU7XG4gIHZhciBwdHI1ID0gMiAqIGluZGV4MTtcbiAgdmFyIHB0cjYgPSAyICogaW5kZXgzO1xuICB2YXIgcHRyNyA9IDIgKiBpbmRleDU7XG4gIGZvciAodmFyIGkxID0gMDsgaTEgPCAyOyArK2kxKSB7XG4gICAgdmFyIHggPSBkYXRhW3B0cjAraTFdO1xuICAgIHZhciB5ID0gZGF0YVtwdHIyK2kxXTtcbiAgICB2YXIgeiA9IGRhdGFbcHRyNCtpMV07XG4gICAgZGF0YVtwdHI1K2kxXSA9IHg7XG4gICAgZGF0YVtwdHI2K2kxXSA9IHk7XG4gICAgZGF0YVtwdHI3K2kxXSA9IHo7XG4gIH1cblxuICBtb3ZlKGluZGV4MiwgbGVmdCwgZGF0YSlcbiAgbW92ZShpbmRleDQsIHJpZ2h0LCBkYXRhKVxuICBmb3IgKHZhciBrID0gbGVzczsgayA8PSBncmVhdDsgKytrKSB7XG4gICAgaWYgKGNvbXBhcmVQaXZvdChrLCBwaXZvdDFYLCBwaXZvdDFZLCBkYXRhKSkge1xuICAgICAgaWYgKGsgIT09IGxlc3MpIHtcbiAgICAgICAgc3dhcChrLCBsZXNzLCBkYXRhKVxuICAgICAgfVxuICAgICAgKytsZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNvbXBhcmVQaXZvdChrLCBwaXZvdDJYLCBwaXZvdDJZLCBkYXRhKSkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGlmICghY29tcGFyZVBpdm90KGdyZWF0LCBwaXZvdDJYLCBwaXZvdDJZLCBkYXRhKSkge1xuICAgICAgICAgICAgaWYgKC0tZ3JlYXQgPCBrKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb21wYXJlUGl2b3QoZ3JlYXQsIHBpdm90MVgsIHBpdm90MVksIGRhdGEpKSB7XG4gICAgICAgICAgICAgIHJvdGF0ZShrLCBsZXNzLCBncmVhdCwgZGF0YSlcbiAgICAgICAgICAgICAgKytsZXNzO1xuICAgICAgICAgICAgICAtLWdyZWF0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3dhcChrLCBncmVhdCwgZGF0YSlcbiAgICAgICAgICAgICAgLS1ncmVhdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzaHVmZmxlUGl2b3QobGVmdCwgbGVzcy0xLCBwaXZvdDFYLCBwaXZvdDFZLCBkYXRhKVxuICBzaHVmZmxlUGl2b3QocmlnaHQsIGdyZWF0KzEsIHBpdm90MlgsIHBpdm90MlksIGRhdGEpXG4gIGlmIChsZXNzIC0gMiAtIGxlZnQgPD0gSU5TRVJUX1NPUlRfQ1VUT0ZGKSB7XG4gICAgaW5zZXJ0aW9uU29ydChsZWZ0LCBsZXNzIC0gMiwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgcXVpY2tTb3J0KGxlZnQsIGxlc3MgLSAyLCBkYXRhKTtcbiAgfVxuICBpZiAocmlnaHQgLSAoZ3JlYXQgKyAyKSA8PSBJTlNFUlRfU09SVF9DVVRPRkYpIHtcbiAgICBpbnNlcnRpb25Tb3J0KGdyZWF0ICsgMiwgcmlnaHQsIGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHF1aWNrU29ydChncmVhdCArIDIsIHJpZ2h0LCBkYXRhKTtcbiAgfVxuICBpZiAoZ3JlYXQgLSBsZXNzIDw9IElOU0VSVF9TT1JUX0NVVE9GRikge1xuICAgIGluc2VydGlvblNvcnQobGVzcywgZ3JlYXQsIGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHF1aWNrU29ydChsZXNzLCBncmVhdCwgZGF0YSk7XG4gIH1cbn0iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluaXQ6ICAgICAgICAgICBzcUluaXQsXG4gIHN3ZWVwQmlwYXJ0aXRlOiBzd2VlcEJpcGFydGl0ZSxcbiAgc3dlZXBDb21wbGV0ZTogIHN3ZWVwQ29tcGxldGUsXG4gIHNjYW5CaXBhcnRpdGU6ICBzY2FuQmlwYXJ0aXRlLFxuICBzY2FuQ29tcGxldGU6ICAgc2NhbkNvbXBsZXRlXG59XG5cbnZhciBwb29sICA9IHJlcXVpcmUoJ3R5cGVkYXJyYXktcG9vbCcpXG52YXIgYml0cyAgPSByZXF1aXJlKCdiaXQtdHdpZGRsZScpXG52YXIgaXNvcnQgPSByZXF1aXJlKCcuL3NvcnQnKVxuXG4vL0ZsYWcgZm9yIGJsdWVcbnZhciBCTFVFX0ZMQUcgPSAoMTw8MjgpXG5cbi8vMUQgc3dlZXAgZXZlbnQgcXVldWUgc3R1ZmYgKHVzZSBwb29sIHRvIHNhdmUgc3BhY2UpXG52YXIgSU5JVF9DQVBBQ0lUWSAgICAgID0gMTAyNFxudmFyIFJFRF9TV0VFUF9RVUVVRSAgICA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBSRURfU1dFRVBfSU5ERVggICAgPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgQkxVRV9TV0VFUF9RVUVVRSAgID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIEJMVUVfU1dFRVBfSU5ERVggICA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBDT01NT05fU1dFRVBfUVVFVUUgPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgQ09NTU9OX1NXRUVQX0lOREVYID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIFNXRUVQX0VWRU5UUyAgICAgICA9IHBvb2wubWFsbG9jRG91YmxlKElOSVRfQ0FQQUNJVFkgKiA4KVxuXG4vL1Jlc2VydmVzIG1lbW9yeSBmb3IgdGhlIDFEIHN3ZWVwIGRhdGEgc3RydWN0dXJlc1xuZnVuY3Rpb24gc3FJbml0KGNvdW50KSB7XG4gIHZhciByY291bnQgPSBiaXRzLm5leHRQb3cyKGNvdW50KVxuICBpZihSRURfU1dFRVBfUVVFVUUubGVuZ3RoIDwgcmNvdW50KSB7XG4gICAgcG9vbC5mcmVlKFJFRF9TV0VFUF9RVUVVRSlcbiAgICBSRURfU1dFRVBfUVVFVUUgPSBwb29sLm1hbGxvY0ludDMyKHJjb3VudClcbiAgfVxuICBpZihSRURfU1dFRVBfSU5ERVgubGVuZ3RoIDwgcmNvdW50KSB7XG4gICAgcG9vbC5mcmVlKFJFRF9TV0VFUF9JTkRFWClcbiAgICBSRURfU1dFRVBfSU5ERVggPSBwb29sLm1hbGxvY0ludDMyKHJjb3VudClcbiAgfVxuICBpZihCTFVFX1NXRUVQX1FVRVVFLmxlbmd0aCA8IHJjb3VudCkge1xuICAgIHBvb2wuZnJlZShCTFVFX1NXRUVQX1FVRVVFKVxuICAgIEJMVUVfU1dFRVBfUVVFVUUgPSBwb29sLm1hbGxvY0ludDMyKHJjb3VudClcbiAgfVxuICBpZihCTFVFX1NXRUVQX0lOREVYLmxlbmd0aCA8IHJjb3VudCkge1xuICAgIHBvb2wuZnJlZShCTFVFX1NXRUVQX0lOREVYKVxuICAgIEJMVUVfU1dFRVBfSU5ERVggPSBwb29sLm1hbGxvY0ludDMyKHJjb3VudClcbiAgfVxuICBpZihDT01NT05fU1dFRVBfUVVFVUUubGVuZ3RoIDwgcmNvdW50KSB7XG4gICAgcG9vbC5mcmVlKENPTU1PTl9TV0VFUF9RVUVVRSlcbiAgICBDT01NT05fU1dFRVBfUVVFVUUgPSBwb29sLm1hbGxvY0ludDMyKHJjb3VudClcbiAgfVxuICBpZihDT01NT05fU1dFRVBfSU5ERVgubGVuZ3RoIDwgcmNvdW50KSB7XG4gICAgcG9vbC5mcmVlKENPTU1PTl9TV0VFUF9JTkRFWClcbiAgICBDT01NT05fU1dFRVBfSU5ERVggPSBwb29sLm1hbGxvY0ludDMyKHJjb3VudClcbiAgfVxuICB2YXIgZXZlbnRMZW5ndGggPSA4ICogcmNvdW50XG4gIGlmKFNXRUVQX0VWRU5UUy5sZW5ndGggPCBldmVudExlbmd0aCkge1xuICAgIHBvb2wuZnJlZShTV0VFUF9FVkVOVFMpXG4gICAgU1dFRVBfRVZFTlRTID0gcG9vbC5tYWxsb2NEb3VibGUoZXZlbnRMZW5ndGgpXG4gIH1cbn1cblxuLy9SZW1vdmUgYW4gaXRlbSBmcm9tIHRoZSBhY3RpdmUgcXVldWUgaW4gTygxKVxuZnVuY3Rpb24gc3FQb3AocXVldWUsIGluZGV4LCBjb3VudCwgaXRlbSkge1xuICB2YXIgaWR4ID0gaW5kZXhbaXRlbV1cbiAgdmFyIHRvcCA9IHF1ZXVlW2NvdW50LTFdXG4gIHF1ZXVlW2lkeF0gPSB0b3BcbiAgaW5kZXhbdG9wXSA9IGlkeFxufVxuXG4vL0luc2VydCBhbiBpdGVtIGludG8gdGhlIGFjdGl2ZSBxdWV1ZSBpbiBPKDEpXG5mdW5jdGlvbiBzcVB1c2gocXVldWUsIGluZGV4LCBjb3VudCwgaXRlbSkge1xuICBxdWV1ZVtjb3VudF0gPSBpdGVtXG4gIGluZGV4W2l0ZW1dICA9IGNvdW50XG59XG5cbi8vUmVjdXJzaW9uIGJhc2UgY2FzZTogdXNlIDFEIHN3ZWVwIGFsZ29yaXRobVxuZnVuY3Rpb24gc3dlZXBCaXBhcnRpdGUoXG4gICAgZCwgdmlzaXQsXG4gICAgcmVkU3RhcnQsICByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpIHtcblxuICAvL3N0b3JlIGV2ZW50cyBhcyBwYWlycyBbY29vcmRpbmF0ZSwgaWR4XVxuICAvL1xuICAvLyAgcmVkIGNyZWF0ZTogIC0oaWR4KzEpXG4gIC8vICByZWQgZGVzdHJveTogaWR4XG4gIC8vICBibHVlIGNyZWF0ZTogLShpZHgrQkxVRV9GTEFHKVxuICAvLyAgYmx1ZSBkZXN0cm95OiBpZHgrQkxVRV9GTEFHXG4gIC8vXG4gIHZhciBwdHIgICAgICA9IDBcbiAgdmFyIGVsZW1TaXplID0gMipkXG4gIHZhciBpc3RhcnQgICA9IGQtMVxuICB2YXIgaWVuZCAgICAgPSBlbGVtU2l6ZS0xXG5cbiAgZm9yKHZhciBpPXJlZFN0YXJ0OyBpPHJlZEVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IHJlZEluZGV4W2ldXG4gICAgdmFyIHJlZE9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC0oaWR4KzEpXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4XG4gIH1cblxuICBmb3IodmFyIGk9Ymx1ZVN0YXJ0OyBpPGJsdWVFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSBibHVlSW5kZXhbaV0rQkxVRV9GTEFHXG4gICAgdmFyIGJsdWVPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGJsdWVbYmx1ZU9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC1pZHhcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gYmx1ZVtibHVlT2Zmc2V0K2llbmRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGlkeFxuICB9XG5cbiAgLy9wcm9jZXNzIGV2ZW50cyBmcm9tIGxlZnQtPnJpZ2h0XG4gIHZhciBuID0gcHRyID4+PiAxXG4gIGlzb3J0KFNXRUVQX0VWRU5UUywgbilcbiAgXG4gIHZhciByZWRBY3RpdmUgID0gMFxuICB2YXIgYmx1ZUFjdGl2ZSA9IDBcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgdmFyIGUgPSBTV0VFUF9FVkVOVFNbMippKzFdfDBcbiAgICBpZihlID49IEJMVUVfRkxBRykge1xuICAgICAgLy9ibHVlIGRlc3Ryb3kgZXZlbnRcbiAgICAgIGUgPSAoZS1CTFVFX0ZMQUcpfDBcbiAgICAgIHNxUG9wKEJMVUVfU1dFRVBfUVVFVUUsIEJMVUVfU1dFRVBfSU5ERVgsIGJsdWVBY3RpdmUtLSwgZSlcbiAgICB9IGVsc2UgaWYoZSA+PSAwKSB7XG4gICAgICAvL3JlZCBkZXN0cm95IGV2ZW50XG4gICAgICBzcVBvcChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlLS0sIGUpXG4gICAgfSBlbHNlIGlmKGUgPD0gLUJMVUVfRkxBRykge1xuICAgICAgLy9ibHVlIGNyZWF0ZSBldmVudFxuICAgICAgZSA9ICgtZS1CTFVFX0ZMQUcpfDBcbiAgICAgIGZvcih2YXIgaj0wOyBqPHJlZEFjdGl2ZTsgKytqKSB7XG4gICAgICAgIHZhciByZXR2YWwgPSB2aXNpdChSRURfU1dFRVBfUVVFVUVbal0sIGUpXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzcVB1c2goQkxVRV9TV0VFUF9RVUVVRSwgQkxVRV9TV0VFUF9JTkRFWCwgYmx1ZUFjdGl2ZSsrLCBlKVxuICAgIH0gZWxzZSB7XG4gICAgICAvL3JlZCBjcmVhdGUgZXZlbnRcbiAgICAgIGUgPSAoLWUtMSl8MFxuICAgICAgZm9yKHZhciBqPTA7IGo8Ymx1ZUFjdGl2ZTsgKytqKSB7XG4gICAgICAgIHZhciByZXR2YWwgPSB2aXNpdChlLCBCTFVFX1NXRUVQX1FVRVVFW2pdKVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3FQdXNoKFJFRF9TV0VFUF9RVUVVRSwgUkVEX1NXRUVQX0lOREVYLCByZWRBY3RpdmUrKywgZSlcbiAgICB9XG4gIH1cbn1cblxuLy9Db21wbGV0ZSBzd2VlcFxuZnVuY3Rpb24gc3dlZXBDb21wbGV0ZShkLCB2aXNpdCwgXG4gIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KSB7XG5cbiAgdmFyIHB0ciAgICAgID0gMFxuICB2YXIgZWxlbVNpemUgPSAyKmRcbiAgdmFyIGlzdGFydCAgID0gZC0xXG4gIHZhciBpZW5kICAgICA9IGVsZW1TaXplLTFcblxuICBmb3IodmFyIGk9cmVkU3RhcnQ7IGk8cmVkRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gKHJlZEluZGV4W2ldKzEpPDwxXG4gICAgdmFyIHJlZE9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC1pZHhcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHhcbiAgfVxuXG4gIGZvcih2YXIgaT1ibHVlU3RhcnQ7IGk8Ymx1ZUVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IChibHVlSW5kZXhbaV0rMSk8PDFcbiAgICB2YXIgYmx1ZU9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gYmx1ZVtibHVlT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gKC1pZHgpfDFcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gYmx1ZVtibHVlT2Zmc2V0K2llbmRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGlkeHwxXG4gIH1cblxuICAvL3Byb2Nlc3MgZXZlbnRzIGZyb20gbGVmdC0+cmlnaHRcbiAgdmFyIG4gPSBwdHIgPj4+IDFcbiAgaXNvcnQoU1dFRVBfRVZFTlRTLCBuKVxuICBcbiAgdmFyIHJlZEFjdGl2ZSAgICA9IDBcbiAgdmFyIGJsdWVBY3RpdmUgICA9IDBcbiAgdmFyIGNvbW1vbkFjdGl2ZSA9IDBcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgdmFyIGUgICAgID0gU1dFRVBfRVZFTlRTWzIqaSsxXXwwXG4gICAgdmFyIGNvbG9yID0gZSYxXG4gICAgaWYoaSA8IG4tMSAmJiAoZT4+MSkgPT09IChTV0VFUF9FVkVOVFNbMippKzNdPj4xKSkge1xuICAgICAgY29sb3IgPSAyXG4gICAgICBpICs9IDFcbiAgICB9XG4gICAgXG4gICAgaWYoZSA8IDApIHtcbiAgICAgIC8vQ3JlYXRlIGV2ZW50XG4gICAgICB2YXIgaWQgPSAtKGU+PjEpIC0gMVxuXG4gICAgICAvL0ludGVyc2VjdCB3aXRoIGNvbW1vblxuICAgICAgZm9yKHZhciBqPTA7IGo8Y29tbW9uQWN0aXZlOyArK2opIHtcbiAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KENPTU1PTl9TV0VFUF9RVUVVRVtqXSwgaWQpXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKGNvbG9yICE9PSAwKSB7XG4gICAgICAgIC8vSW50ZXJzZWN0IHdpdGggcmVkXG4gICAgICAgIGZvcih2YXIgaj0wOyBqPHJlZEFjdGl2ZTsgKytqKSB7XG4gICAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KFJFRF9TV0VFUF9RVUVVRVtqXSwgaWQpXG4gICAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoY29sb3IgIT09IDEpIHtcbiAgICAgICAgLy9JbnRlcnNlY3Qgd2l0aCBibHVlXG4gICAgICAgIGZvcih2YXIgaj0wOyBqPGJsdWVBY3RpdmU7ICsraikge1xuICAgICAgICAgIHZhciByZXR2YWwgPSB2aXNpdChCTFVFX1NXRUVQX1FVRVVFW2pdLCBpZClcbiAgICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihjb2xvciA9PT0gMCkge1xuICAgICAgICAvL1JlZFxuICAgICAgICBzcVB1c2goUkVEX1NXRUVQX1FVRVVFLCBSRURfU1dFRVBfSU5ERVgsIHJlZEFjdGl2ZSsrLCBpZClcbiAgICAgIH0gZWxzZSBpZihjb2xvciA9PT0gMSkge1xuICAgICAgICAvL0JsdWVcbiAgICAgICAgc3FQdXNoKEJMVUVfU1dFRVBfUVVFVUUsIEJMVUVfU1dFRVBfSU5ERVgsIGJsdWVBY3RpdmUrKywgaWQpXG4gICAgICB9IGVsc2UgaWYoY29sb3IgPT09IDIpIHtcbiAgICAgICAgLy9Cb3RoXG4gICAgICAgIHNxUHVzaChDT01NT05fU1dFRVBfUVVFVUUsIENPTU1PTl9TV0VFUF9JTkRFWCwgY29tbW9uQWN0aXZlKyssIGlkKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvL0Rlc3Ryb3kgZXZlbnRcbiAgICAgIHZhciBpZCA9IChlPj4xKSAtIDFcbiAgICAgIGlmKGNvbG9yID09PSAwKSB7XG4gICAgICAgIC8vUmVkXG4gICAgICAgIHNxUG9wKFJFRF9TV0VFUF9RVUVVRSwgUkVEX1NXRUVQX0lOREVYLCByZWRBY3RpdmUtLSwgaWQpXG4gICAgICB9IGVsc2UgaWYoY29sb3IgPT09IDEpIHtcbiAgICAgICAgLy9CbHVlXG4gICAgICAgIHNxUG9wKEJMVUVfU1dFRVBfUVVFVUUsIEJMVUVfU1dFRVBfSU5ERVgsIGJsdWVBY3RpdmUtLSwgaWQpXG4gICAgICB9IGVsc2UgaWYoY29sb3IgPT09IDIpIHtcbiAgICAgICAgLy9Cb3RoXG4gICAgICAgIHNxUG9wKENPTU1PTl9TV0VFUF9RVUVVRSwgQ09NTU9OX1NXRUVQX0lOREVYLCBjb21tb25BY3RpdmUtLSwgaWQpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vU3dlZXAgYW5kIHBydW5lL3NjYW5saW5lIGFsZ29yaXRobTpcbi8vICBTY2FuIGFsb25nIGF4aXMsIGRldGVjdCBpbnRlcnNlY3Rpb25zXG4vLyAgQnJ1dGUgZm9yY2UgYWxsIGJveGVzIGFsb25nIGF4aXNcbmZ1bmN0aW9uIHNjYW5CaXBhcnRpdGUoXG4gIGQsIGF4aXMsIHZpc2l0LCBmbGlwLFxuICByZWRTdGFydCwgIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpIHtcbiAgXG4gIHZhciBwdHIgICAgICA9IDBcbiAgdmFyIGVsZW1TaXplID0gMipkXG4gIHZhciBpc3RhcnQgICA9IGF4aXNcbiAgdmFyIGllbmQgICAgID0gYXhpcytkXG5cbiAgdmFyIHJlZFNoaWZ0ICA9IDFcbiAgdmFyIGJsdWVTaGlmdCA9IDFcbiAgaWYoZmxpcCkge1xuICAgIGJsdWVTaGlmdCA9IEJMVUVfRkxBR1xuICB9IGVsc2Uge1xuICAgIHJlZFNoaWZ0ICA9IEJMVUVfRkxBR1xuICB9XG5cbiAgZm9yKHZhciBpPXJlZFN0YXJ0OyBpPHJlZEVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IGkgKyByZWRTaGlmdFxuICAgIHZhciByZWRPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtaWR4XG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4XG4gIH1cbiAgZm9yKHZhciBpPWJsdWVTdGFydDsgaTxibHVlRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gaSArIGJsdWVTaGlmdFxuICAgIHZhciBibHVlT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtaWR4XG4gIH1cblxuICAvL3Byb2Nlc3MgZXZlbnRzIGZyb20gbGVmdC0+cmlnaHRcbiAgdmFyIG4gPSBwdHIgPj4+IDFcbiAgaXNvcnQoU1dFRVBfRVZFTlRTLCBuKVxuICBcbiAgdmFyIHJlZEFjdGl2ZSAgICA9IDBcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgdmFyIGUgPSBTV0VFUF9FVkVOVFNbMippKzFdfDBcbiAgICBpZihlIDwgMCkge1xuICAgICAgdmFyIGlkeCAgID0gLWVcbiAgICAgIHZhciBpc1JlZCA9IGZhbHNlXG4gICAgICBpZihpZHggPj0gQkxVRV9GTEFHKSB7XG4gICAgICAgIGlzUmVkID0gIWZsaXBcbiAgICAgICAgaWR4IC09IEJMVUVfRkxBRyBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzUmVkID0gISFmbGlwXG4gICAgICAgIGlkeCAtPSAxXG4gICAgICB9XG4gICAgICBpZihpc1JlZCkge1xuICAgICAgICBzcVB1c2goUkVEX1NXRUVQX1FVRVVFLCBSRURfU1dFRVBfSU5ERVgsIHJlZEFjdGl2ZSsrLCBpZHgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYmx1ZUlkICA9IGJsdWVJbmRleFtpZHhdXG4gICAgICAgIHZhciBibHVlUHRyID0gZWxlbVNpemUgKiBpZHhcbiAgICAgICAgXG4gICAgICAgIHZhciBiMCA9IGJsdWVbYmx1ZVB0citheGlzKzFdXG4gICAgICAgIHZhciBiMSA9IGJsdWVbYmx1ZVB0citheGlzKzErZF1cblxucmVkX2xvb3A6XG4gICAgICAgIGZvcih2YXIgaj0wOyBqPHJlZEFjdGl2ZTsgKytqKSB7XG4gICAgICAgICAgdmFyIG9pZHggICA9IFJFRF9TV0VFUF9RVUVVRVtqXVxuICAgICAgICAgIHZhciByZWRQdHIgPSBlbGVtU2l6ZSAqIG9pZHhcblxuICAgICAgICAgIGlmKGIxIDwgcmVkW3JlZFB0citheGlzKzFdIHx8IFxuICAgICAgICAgICAgIHJlZFtyZWRQdHIrYXhpcysxK2RdIDwgYjApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yKHZhciBrPWF4aXMrMjsgazxkOyArK2spIHtcbiAgICAgICAgICAgIGlmKGJsdWVbYmx1ZVB0ciArIGsgKyBkXSA8IHJlZFtyZWRQdHIgKyBrXSB8fCBcbiAgICAgICAgICAgICAgIHJlZFtyZWRQdHIgKyBrICsgZF0gPCBibHVlW2JsdWVQdHIgKyBrXSkge1xuICAgICAgICAgICAgICBjb250aW51ZSByZWRfbG9vcFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWRJZCAgPSByZWRJbmRleFtvaWR4XVxuICAgICAgICAgIHZhciByZXR2YWxcbiAgICAgICAgICBpZihmbGlwKSB7XG4gICAgICAgICAgICByZXR2YWwgPSB2aXNpdChibHVlSWQsIHJlZElkKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR2YWwgPSB2aXNpdChyZWRJZCwgYmx1ZUlkKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHZhbCBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3FQb3AoUkVEX1NXRUVQX1FVRVVFLCBSRURfU1dFRVBfSU5ERVgsIHJlZEFjdGl2ZS0tLCBlIC0gcmVkU2hpZnQpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNjYW5Db21wbGV0ZShcbiAgZCwgYXhpcywgdmlzaXQsXG4gIHJlZFN0YXJ0LCAgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleCkge1xuXG4gIHZhciBwdHIgICAgICA9IDBcbiAgdmFyIGVsZW1TaXplID0gMipkXG4gIHZhciBpc3RhcnQgICA9IGF4aXNcbiAgdmFyIGllbmQgICAgID0gYXhpcytkXG5cbiAgZm9yKHZhciBpPXJlZFN0YXJ0OyBpPHJlZEVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IGkgKyBCTFVFX0ZMQUdcbiAgICB2YXIgcmVkT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2llbmRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGlkeFxuICB9XG4gIGZvcih2YXIgaT1ibHVlU3RhcnQ7IGk8Ymx1ZUVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IGkgKyAxXG4gICAgdmFyIGJsdWVPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGJsdWVbYmx1ZU9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC1pZHhcbiAgfVxuXG4gIC8vcHJvY2VzcyBldmVudHMgZnJvbSBsZWZ0LT5yaWdodFxuICB2YXIgbiA9IHB0ciA+Pj4gMVxuICBpc29ydChTV0VFUF9FVkVOVFMsIG4pXG4gIFxuICB2YXIgcmVkQWN0aXZlICAgID0gMFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgZSA9IFNXRUVQX0VWRU5UU1syKmkrMV18MFxuICAgIGlmKGUgPCAwKSB7XG4gICAgICB2YXIgaWR4ICAgPSAtZVxuICAgICAgaWYoaWR4ID49IEJMVUVfRkxBRykge1xuICAgICAgICBSRURfU1dFRVBfUVVFVUVbcmVkQWN0aXZlKytdID0gaWR4IC0gQkxVRV9GTEFHXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZHggLT0gMVxuICAgICAgICB2YXIgYmx1ZUlkICA9IGJsdWVJbmRleFtpZHhdXG4gICAgICAgIHZhciBibHVlUHRyID0gZWxlbVNpemUgKiBpZHhcblxuICAgICAgICB2YXIgYjAgPSBibHVlW2JsdWVQdHIrYXhpcysxXVxuICAgICAgICB2YXIgYjEgPSBibHVlW2JsdWVQdHIrYXhpcysxK2RdXG5cbnJlZF9sb29wOlxuICAgICAgICBmb3IodmFyIGo9MDsgajxyZWRBY3RpdmU7ICsraikge1xuICAgICAgICAgIHZhciBvaWR4ICAgPSBSRURfU1dFRVBfUVVFVUVbal1cbiAgICAgICAgICB2YXIgcmVkSWQgID0gcmVkSW5kZXhbb2lkeF1cblxuICAgICAgICAgIGlmKHJlZElkID09PSBibHVlSWQpIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlZFB0ciA9IGVsZW1TaXplICogb2lkeFxuICAgICAgICAgIGlmKGIxIDwgcmVkW3JlZFB0citheGlzKzFdIHx8IFxuICAgICAgICAgICAgcmVkW3JlZFB0citheGlzKzErZF0gPCBiMCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yKHZhciBrPWF4aXMrMjsgazxkOyArK2spIHtcbiAgICAgICAgICAgIGlmKGJsdWVbYmx1ZVB0ciArIGsgKyBkXSA8IHJlZFtyZWRQdHIgKyBrXSB8fCBcbiAgICAgICAgICAgICAgIHJlZFtyZWRQdHIgKyBrICsgZF0gICA8IGJsdWVbYmx1ZVB0ciArIGtdKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIHJlZF9sb29wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KHJlZElkLCBibHVlSWQpXG4gICAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXR2YWwgXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpZHggPSBlIC0gQkxVRV9GTEFHXG4gICAgICBmb3IodmFyIGo9cmVkQWN0aXZlLTE7IGo+PTA7IC0taikge1xuICAgICAgICBpZihSRURfU1dFRVBfUVVFVUVbal0gPT09IGlkeCkge1xuICAgICAgICAgIGZvcih2YXIgaz1qKzE7IGs8cmVkQWN0aXZlOyArK2spIHtcbiAgICAgICAgICAgIFJFRF9TV0VFUF9RVUVVRVtrLTFdID0gUkVEX1NXRUVQX1FVRVVFW2tdXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC0tcmVkQWN0aXZlXG4gICAgfVxuICB9XG59IiwiLyoqXG4gKiBCaXQgdHdpZGRsaW5nIGhhY2tzIGZvciBKYXZhU2NyaXB0LlxuICpcbiAqIEF1dGhvcjogTWlrb2xhIEx5c2Vua29cbiAqXG4gKiBQb3J0ZWQgZnJvbSBTdGFuZm9yZCBiaXQgdHdpZGRsaW5nIGhhY2sgbGlicmFyeTpcbiAqICAgIGh0dHA6Ly9ncmFwaGljcy5zdGFuZm9yZC5lZHUvfnNlYW5kZXIvYml0aGFja3MuaHRtbFxuICovXG5cblwidXNlIHN0cmljdFwiOyBcInVzZSByZXN0cmljdFwiO1xuXG4vL051bWJlciBvZiBiaXRzIGluIGFuIGludGVnZXJcbnZhciBJTlRfQklUUyA9IDMyO1xuXG4vL0NvbnN0YW50c1xuZXhwb3J0cy5JTlRfQklUUyAgPSBJTlRfQklUUztcbmV4cG9ydHMuSU5UX01BWCAgID0gIDB4N2ZmZmZmZmY7XG5leHBvcnRzLklOVF9NSU4gICA9IC0xPDwoSU5UX0JJVFMtMSk7XG5cbi8vUmV0dXJucyAtMSwgMCwgKzEgZGVwZW5kaW5nIG9uIHNpZ24gb2YgeFxuZXhwb3J0cy5zaWduID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gKHYgPiAwKSAtICh2IDwgMCk7XG59XG5cbi8vQ29tcHV0ZXMgYWJzb2x1dGUgdmFsdWUgb2YgaW50ZWdlclxuZXhwb3J0cy5hYnMgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBtYXNrID0gdiA+PiAoSU5UX0JJVFMtMSk7XG4gIHJldHVybiAodiBeIG1hc2spIC0gbWFzaztcbn1cblxuLy9Db21wdXRlcyBtaW5pbXVtIG9mIGludGVnZXJzIHggYW5kIHlcbmV4cG9ydHMubWluID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4geSBeICgoeCBeIHkpICYgLSh4IDwgeSkpO1xufVxuXG4vL0NvbXB1dGVzIG1heGltdW0gb2YgaW50ZWdlcnMgeCBhbmQgeVxuZXhwb3J0cy5tYXggPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiB4IF4gKCh4IF4geSkgJiAtKHggPCB5KSk7XG59XG5cbi8vQ2hlY2tzIGlmIGEgbnVtYmVyIGlzIGEgcG93ZXIgb2YgdHdvXG5leHBvcnRzLmlzUG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICEodiAmICh2LTEpKSAmJiAoISF2KTtcbn1cblxuLy9Db21wdXRlcyBsb2cgYmFzZSAyIG9mIHZcbmV4cG9ydHMubG9nMiA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHIsIHNoaWZ0O1xuICByID0gICAgICh2ID4gMHhGRkZGKSA8PCA0OyB2ID4+Pj0gcjtcbiAgc2hpZnQgPSAodiA+IDB4RkYgICkgPDwgMzsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICBzaGlmdCA9ICh2ID4gMHhGICAgKSA8PCAyOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHNoaWZ0ID0gKHYgPiAweDMgICApIDw8IDE7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgcmV0dXJuIHIgfCAodiA+PiAxKTtcbn1cblxuLy9Db21wdXRlcyBsb2cgYmFzZSAxMCBvZiB2XG5leHBvcnRzLmxvZzEwID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gICh2ID49IDEwMDAwMDAwMDApID8gOSA6ICh2ID49IDEwMDAwMDAwMCkgPyA4IDogKHYgPj0gMTAwMDAwMDApID8gNyA6XG4gICAgICAgICAgKHYgPj0gMTAwMDAwMCkgPyA2IDogKHYgPj0gMTAwMDAwKSA/IDUgOiAodiA+PSAxMDAwMCkgPyA0IDpcbiAgICAgICAgICAodiA+PSAxMDAwKSA/IDMgOiAodiA+PSAxMDApID8gMiA6ICh2ID49IDEwKSA/IDEgOiAwO1xufVxuXG4vL0NvdW50cyBudW1iZXIgb2YgYml0c1xuZXhwb3J0cy5wb3BDb3VudCA9IGZ1bmN0aW9uKHYpIHtcbiAgdiA9IHYgLSAoKHYgPj4+IDEpICYgMHg1NTU1NTU1NSk7XG4gIHYgPSAodiAmIDB4MzMzMzMzMzMpICsgKCh2ID4+PiAyKSAmIDB4MzMzMzMzMzMpO1xuICByZXR1cm4gKCh2ICsgKHYgPj4+IDQpICYgMHhGMEYwRjBGKSAqIDB4MTAxMDEwMSkgPj4+IDI0O1xufVxuXG4vL0NvdW50cyBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3NcbmZ1bmN0aW9uIGNvdW50VHJhaWxpbmdaZXJvcyh2KSB7XG4gIHZhciBjID0gMzI7XG4gIHYgJj0gLXY7XG4gIGlmICh2KSBjLS07XG4gIGlmICh2ICYgMHgwMDAwRkZGRikgYyAtPSAxNjtcbiAgaWYgKHYgJiAweDAwRkYwMEZGKSBjIC09IDg7XG4gIGlmICh2ICYgMHgwRjBGMEYwRikgYyAtPSA0O1xuICBpZiAodiAmIDB4MzMzMzMzMzMpIGMgLT0gMjtcbiAgaWYgKHYgJiAweDU1NTU1NTU1KSBjIC09IDE7XG4gIHJldHVybiBjO1xufVxuZXhwb3J0cy5jb3VudFRyYWlsaW5nWmVyb3MgPSBjb3VudFRyYWlsaW5nWmVyb3M7XG5cbi8vUm91bmRzIHRvIG5leHQgcG93ZXIgb2YgMlxuZXhwb3J0cy5uZXh0UG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgdiArPSB2ID09PSAwO1xuICAtLXY7XG4gIHYgfD0gdiA+Pj4gMTtcbiAgdiB8PSB2ID4+PiAyO1xuICB2IHw9IHYgPj4+IDQ7XG4gIHYgfD0gdiA+Pj4gODtcbiAgdiB8PSB2ID4+PiAxNjtcbiAgcmV0dXJuIHYgKyAxO1xufVxuXG4vL1JvdW5kcyBkb3duIHRvIHByZXZpb3VzIHBvd2VyIG9mIDJcbmV4cG9ydHMucHJldlBvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHYgfD0gdiA+Pj4gMTtcbiAgdiB8PSB2ID4+PiAyO1xuICB2IHw9IHYgPj4+IDQ7XG4gIHYgfD0gdiA+Pj4gODtcbiAgdiB8PSB2ID4+PiAxNjtcbiAgcmV0dXJuIHYgLSAodj4+PjEpO1xufVxuXG4vL0NvbXB1dGVzIHBhcml0eSBvZiB3b3JkXG5leHBvcnRzLnBhcml0eSA9IGZ1bmN0aW9uKHYpIHtcbiAgdiBePSB2ID4+PiAxNjtcbiAgdiBePSB2ID4+PiA4O1xuICB2IF49IHYgPj4+IDQ7XG4gIHYgJj0gMHhmO1xuICByZXR1cm4gKDB4Njk5NiA+Pj4gdikgJiAxO1xufVxuXG52YXIgUkVWRVJTRV9UQUJMRSA9IG5ldyBBcnJheSgyNTYpO1xuXG4oZnVuY3Rpb24odGFiKSB7XG4gIGZvcih2YXIgaT0wOyBpPDI1NjsgKytpKSB7XG4gICAgdmFyIHYgPSBpLCByID0gaSwgcyA9IDc7XG4gICAgZm9yICh2ID4+Pj0gMTsgdjsgdiA+Pj49IDEpIHtcbiAgICAgIHIgPDw9IDE7XG4gICAgICByIHw9IHYgJiAxO1xuICAgICAgLS1zO1xuICAgIH1cbiAgICB0YWJbaV0gPSAociA8PCBzKSAmIDB4ZmY7XG4gIH1cbn0pKFJFVkVSU0VfVEFCTEUpO1xuXG4vL1JldmVyc2UgYml0cyBpbiBhIDMyIGJpdCB3b3JkXG5leHBvcnRzLnJldmVyc2UgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAgKFJFVkVSU0VfVEFCTEVbIHYgICAgICAgICAmIDB4ZmZdIDw8IDI0KSB8XG4gICAgICAgICAgKFJFVkVSU0VfVEFCTEVbKHYgPj4+IDgpICAmIDB4ZmZdIDw8IDE2KSB8XG4gICAgICAgICAgKFJFVkVSU0VfVEFCTEVbKHYgPj4+IDE2KSAmIDB4ZmZdIDw8IDgpICB8XG4gICAgICAgICAgIFJFVkVSU0VfVEFCTEVbKHYgPj4+IDI0KSAmIDB4ZmZdO1xufVxuXG4vL0ludGVybGVhdmUgYml0cyBvZiAyIGNvb3JkaW5hdGVzIHdpdGggMTYgYml0cy4gIFVzZWZ1bCBmb3IgZmFzdCBxdWFkdHJlZSBjb2Rlc1xuZXhwb3J0cy5pbnRlcmxlYXZlMiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgeCAmPSAweEZGRkY7XG4gIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gIHggPSAoeCB8ICh4IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgeSAmPSAweEZGRkY7XG4gIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gIHkgPSAoeSB8ICh5IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuLy9FeHRyYWN0cyB0aGUgbnRoIGludGVybGVhdmVkIGNvbXBvbmVudFxuZXhwb3J0cy5kZWludGVybGVhdmUyID0gZnVuY3Rpb24odiwgbikge1xuICB2ID0gKHYgPj4+IG4pICYgMHg1NTU1NTU1NTtcbiAgdiA9ICh2IHwgKHYgPj4+IDEpKSAgJiAweDMzMzMzMzMzO1xuICB2ID0gKHYgfCAodiA+Pj4gMikpICAmIDB4MEYwRjBGMEY7XG4gIHYgPSAodiB8ICh2ID4+PiA0KSkgICYgMHgwMEZGMDBGRjtcbiAgdiA9ICh2IHwgKHYgPj4+IDE2KSkgJiAweDAwMEZGRkY7XG4gIHJldHVybiAodiA8PCAxNikgPj4gMTY7XG59XG5cblxuLy9JbnRlcmxlYXZlIGJpdHMgb2YgMyBjb29yZGluYXRlcywgZWFjaCB3aXRoIDEwIGJpdHMuICBVc2VmdWwgZm9yIGZhc3Qgb2N0cmVlIGNvZGVzXG5leHBvcnRzLmludGVybGVhdmUzID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICB4ICY9IDB4M0ZGO1xuICB4ICA9ICh4IHwgKHg8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB4ICA9ICh4IHwgKHg8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHggID0gKHggfCAoeDw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHggID0gKHggfCAoeDw8MikpICAmIDEyMjcxMzM1MTM7XG5cbiAgeSAmPSAweDNGRjtcbiAgeSAgPSAoeSB8ICh5PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeSAgPSAoeSB8ICh5PDw4KSkgICYgMjUxNzE5Njk1O1xuICB5ICA9ICh5IHwgKHk8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB5ICA9ICh5IHwgKHk8PDIpKSAgJiAxMjI3MTMzNTEzO1xuICB4IHw9ICh5IDw8IDEpO1xuICBcbiAgeiAmPSAweDNGRjtcbiAgeiAgPSAoeiB8ICh6PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeiAgPSAoeiB8ICh6PDw4KSkgICYgMjUxNzE5Njk1O1xuICB6ICA9ICh6IHwgKHo8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB6ICA9ICh6IHwgKHo8PDIpKSAgJiAxMjI3MTMzNTEzO1xuICBcbiAgcmV0dXJuIHggfCAoeiA8PCAyKTtcbn1cblxuLy9FeHRyYWN0cyBudGggaW50ZXJsZWF2ZWQgY29tcG9uZW50IG9mIGEgMy10dXBsZVxuZXhwb3J0cy5kZWludGVybGVhdmUzID0gZnVuY3Rpb24odiwgbikge1xuICB2ID0gKHYgPj4+IG4pICAgICAgICYgMTIyNzEzMzUxMztcbiAgdiA9ICh2IHwgKHY+Pj4yKSkgICAmIDMyNzIzNTYwMzU7XG4gIHYgPSAodiB8ICh2Pj4+NCkpICAgJiAyNTE3MTk2OTU7XG4gIHYgPSAodiB8ICh2Pj4+OCkpICAgJiA0Mjc4MTkwMzM1O1xuICB2ID0gKHYgfCAodj4+PjE2KSkgICYgMHgzRkY7XG4gIHJldHVybiAodjw8MjIpPj4yMjtcbn1cblxuLy9Db21wdXRlcyBuZXh0IGNvbWJpbmF0aW9uIGluIGNvbGV4aWNvZ3JhcGhpYyBvcmRlciAodGhpcyBpcyBtaXN0YWtlbmx5IGNhbGxlZCBuZXh0UGVybXV0YXRpb24gb24gdGhlIGJpdCB0d2lkZGxpbmcgaGFja3MgcGFnZSlcbmV4cG9ydHMubmV4dENvbWJpbmF0aW9uID0gZnVuY3Rpb24odikge1xuICB2YXIgdCA9IHYgfCAodiAtIDEpO1xuICByZXR1cm4gKHQgKyAxKSB8ICgoKH50ICYgLX50KSAtIDEpID4+PiAoY291bnRUcmFpbGluZ1plcm9zKHYpICsgMSkpO1xufVxuXG4iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBkdXBlX2FycmF5KGNvdW50LCB2YWx1ZSwgaSkge1xuICB2YXIgYyA9IGNvdW50W2ldfDBcbiAgaWYoYyA8PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShjKSwgalxuICBpZihpID09PSBjb3VudC5sZW5ndGgtMSkge1xuICAgIGZvcihqPTA7IGo8YzsgKytqKSB7XG4gICAgICByZXN1bHRbal0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3Ioaj0wOyBqPGM7ICsraikge1xuICAgICAgcmVzdWx0W2pdID0gZHVwZV9hcnJheShjb3VudCwgdmFsdWUsIGkrMSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBkdXBlX251bWJlcihjb3VudCwgdmFsdWUpIHtcbiAgdmFyIHJlc3VsdCwgaVxuICByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpXG4gIGZvcihpPTA7IGk8Y291bnQ7ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IHZhbHVlXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBkdXBlKGNvdW50LCB2YWx1ZSkge1xuICBpZih0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YWx1ZSA9IDBcbiAgfVxuICBzd2l0Y2godHlwZW9mIGNvdW50KSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgaWYoY291bnQgPiAwKSB7XG4gICAgICAgIHJldHVybiBkdXBlX251bWJlcihjb3VudHwwLCB2YWx1ZSlcbiAgICAgIH1cbiAgICBicmVha1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmKHR5cGVvZiAoY291bnQubGVuZ3RoKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gZHVwZV9hcnJheShjb3VudCwgdmFsdWUsIDApXG4gICAgICB9XG4gICAgYnJlYWtcbiAgfVxuICByZXR1cm4gW11cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkdXBlIiwiKGZ1bmN0aW9uIChnbG9iYWwsQnVmZmVyKXtcbid1c2Ugc3RyaWN0J1xuXG52YXIgYml0cyA9IHJlcXVpcmUoJ2JpdC10d2lkZGxlJylcbnZhciBkdXAgPSByZXF1aXJlKCdkdXAnKVxuXG4vL0xlZ2FjeSBwb29sIHN1cHBvcnRcbmlmKCFnbG9iYWwuX19UWVBFREFSUkFZX1BPT0wpIHtcbiAgZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MID0ge1xuICAgICAgVUlOVDggICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDE2ICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDMyICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UOCAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UMTYgICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UMzIgICA6IGR1cChbMzIsIDBdKVxuICAgICwgRkxPQVQgICA6IGR1cChbMzIsIDBdKVxuICAgICwgRE9VQkxFICA6IGR1cChbMzIsIDBdKVxuICAgICwgREFUQSAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDhDICA6IGR1cChbMzIsIDBdKVxuICAgICwgQlVGRkVSICA6IGR1cChbMzIsIDBdKVxuICB9XG59XG5cbnZhciBoYXNVaW50OEMgPSAodHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSAhPT0gJ3VuZGVmaW5lZCdcbnZhciBQT09MID0gZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MXG5cbi8vVXBncmFkZSBwb29sXG5pZighUE9PTC5VSU5UOEMpIHtcbiAgUE9PTC5VSU5UOEMgPSBkdXAoWzMyLCAwXSlcbn1cbmlmKCFQT09MLkJVRkZFUikge1xuICBQT09MLkJVRkZFUiA9IGR1cChbMzIsIDBdKVxufVxuXG4vL05ldyB0ZWNobmlxdWU6IE9ubHkgYWxsb2NhdGUgZnJvbSBBcnJheUJ1ZmZlclZpZXcgYW5kIEJ1ZmZlclxudmFyIERBVEEgICAgPSBQT09MLkRBVEFcbiAgLCBCVUZGRVIgID0gUE9PTC5CVUZGRVJcblxuZXhwb3J0cy5mcmVlID0gZnVuY3Rpb24gZnJlZShhcnJheSkge1xuICBpZihCdWZmZXIuaXNCdWZmZXIoYXJyYXkpKSB7XG4gICAgQlVGRkVSW2JpdHMubG9nMihhcnJheS5sZW5ndGgpXS5wdXNoKGFycmF5KVxuICB9IGVsc2Uge1xuICAgIGlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnJheSkgIT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIGFycmF5ID0gYXJyYXkuYnVmZmVyXG4gICAgfVxuICAgIGlmKCFhcnJheSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBuID0gYXJyYXkubGVuZ3RoIHx8IGFycmF5LmJ5dGVMZW5ndGhcbiAgICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobil8MFxuICAgIERBVEFbbG9nX25dLnB1c2goYXJyYXkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZnJlZUFycmF5QnVmZmVyKGJ1ZmZlcikge1xuICBpZighYnVmZmVyKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG4gPSBidWZmZXIubGVuZ3RoIHx8IGJ1ZmZlci5ieXRlTGVuZ3RoXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICBEQVRBW2xvZ19uXS5wdXNoKGJ1ZmZlcilcbn1cblxuZnVuY3Rpb24gZnJlZVR5cGVkQXJyYXkoYXJyYXkpIHtcbiAgZnJlZUFycmF5QnVmZmVyKGFycmF5LmJ1ZmZlcilcbn1cblxuZXhwb3J0cy5mcmVlVWludDggPVxuZXhwb3J0cy5mcmVlVWludDE2ID1cbmV4cG9ydHMuZnJlZVVpbnQzMiA9XG5leHBvcnRzLmZyZWVJbnQ4ID1cbmV4cG9ydHMuZnJlZUludDE2ID1cbmV4cG9ydHMuZnJlZUludDMyID1cbmV4cG9ydHMuZnJlZUZsb2F0MzIgPSBcbmV4cG9ydHMuZnJlZUZsb2F0ID1cbmV4cG9ydHMuZnJlZUZsb2F0NjQgPSBcbmV4cG9ydHMuZnJlZURvdWJsZSA9IFxuZXhwb3J0cy5mcmVlVWludDhDbGFtcGVkID0gXG5leHBvcnRzLmZyZWVEYXRhVmlldyA9IGZyZWVUeXBlZEFycmF5XG5cbmV4cG9ydHMuZnJlZUFycmF5QnVmZmVyID0gZnJlZUFycmF5QnVmZmVyXG5cbmV4cG9ydHMuZnJlZUJ1ZmZlciA9IGZ1bmN0aW9uIGZyZWVCdWZmZXIoYXJyYXkpIHtcbiAgQlVGRkVSW2JpdHMubG9nMihhcnJheS5sZW5ndGgpXS5wdXNoKGFycmF5KVxufVxuXG5leHBvcnRzLm1hbGxvYyA9IGZ1bmN0aW9uIG1hbGxvYyhuLCBkdHlwZSkge1xuICBpZihkdHlwZSA9PT0gdW5kZWZpbmVkIHx8IGR0eXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgcmV0dXJuIG1hbGxvY0FycmF5QnVmZmVyKG4pXG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoKGR0eXBlKSB7XG4gICAgICBjYXNlICd1aW50OCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50OChuKVxuICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQxNihuKVxuICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQzMihuKVxuICAgICAgY2FzZSAnaW50OCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQ4KG4pXG4gICAgICBjYXNlICdpbnQxNic6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQxNihuKVxuICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jSW50MzIobilcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jRmxvYXQobilcbiAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0RvdWJsZShuKVxuICAgICAgY2FzZSAndWludDhfY2xhbXBlZCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50OENsYW1wZWQobilcbiAgICAgIGNhc2UgJ2J1ZmZlcic6XG4gICAgICAgIHJldHVybiBtYWxsb2NCdWZmZXIobilcbiAgICAgIGNhc2UgJ2RhdGEnOlxuICAgICAgY2FzZSAnZGF0YXZpZXcnOlxuICAgICAgICByZXR1cm4gbWFsbG9jRGF0YVZpZXcobilcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gbWFsbG9jQXJyYXlCdWZmZXIobikge1xuICB2YXIgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBkID0gREFUQVtsb2dfbl1cbiAgaWYoZC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGQucG9wKClcbiAgfVxuICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKG4pXG59XG5leHBvcnRzLm1hbGxvY0FycmF5QnVmZmVyID0gbWFsbG9jQXJyYXlCdWZmZXJcblxuZnVuY3Rpb24gbWFsbG9jVWludDgobikge1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY1VpbnQ4ID0gbWFsbG9jVWludDhcblxuZnVuY3Rpb24gbWFsbG9jVWludDE2KG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShtYWxsb2NBcnJheUJ1ZmZlcigyKm4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50MTYgPSBtYWxsb2NVaW50MTZcblxuZnVuY3Rpb24gbWFsbG9jVWludDMyKG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50MzIgPSBtYWxsb2NVaW50MzJcblxuZnVuY3Rpb24gbWFsbG9jSW50OChuKSB7XG4gIHJldHVybiBuZXcgSW50OEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQ4ID0gbWFsbG9jSW50OFxuXG5mdW5jdGlvbiBtYWxsb2NJbnQxNihuKSB7XG4gIHJldHVybiBuZXcgSW50MTZBcnJheShtYWxsb2NBcnJheUJ1ZmZlcigyKm4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQxNiA9IG1hbGxvY0ludDE2XG5cbmZ1bmN0aW9uIG1hbGxvY0ludDMyKG4pIHtcbiAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDQqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0ludDMyID0gbWFsbG9jSW50MzJcblxuZnVuY3Rpb24gbWFsbG9jRmxvYXQobikge1xuICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NGbG9hdDMyID0gZXhwb3J0cy5tYWxsb2NGbG9hdCA9IG1hbGxvY0Zsb2F0XG5cbmZ1bmN0aW9uIG1hbGxvY0RvdWJsZShuKSB7XG4gIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDgqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0Zsb2F0NjQgPSBleHBvcnRzLm1hbGxvY0RvdWJsZSA9IG1hbGxvY0RvdWJsZVxuXG5mdW5jdGlvbiBtYWxsb2NVaW50OENsYW1wZWQobikge1xuICBpZihoYXNVaW50OEMpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYWxsb2NVaW50OChuKVxuICB9XG59XG5leHBvcnRzLm1hbGxvY1VpbnQ4Q2xhbXBlZCA9IG1hbGxvY1VpbnQ4Q2xhbXBlZFxuXG5mdW5jdGlvbiBtYWxsb2NEYXRhVmlldyhuKSB7XG4gIHJldHVybiBuZXcgRGF0YVZpZXcobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0RhdGFWaWV3ID0gbWFsbG9jRGF0YVZpZXdcblxuZnVuY3Rpb24gbWFsbG9jQnVmZmVyKG4pIHtcbiAgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBjYWNoZSA9IEJVRkZFUltsb2dfbl1cbiAgaWYoY2FjaGUubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBjYWNoZS5wb3AoKVxuICB9XG4gIHJldHVybiBuZXcgQnVmZmVyKG4pXG59XG5leHBvcnRzLm1hbGxvY0J1ZmZlciA9IG1hbGxvY0J1ZmZlclxuXG5leHBvcnRzLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICBmb3IodmFyIGk9MDsgaTwzMjsgKytpKSB7XG4gICAgUE9PTC5VSU5UOFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5VSU5UMTZbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDMyW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDhbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UMTZbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UMzJbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuRkxPQVRbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuRE9VQkxFW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLlVJTlQ4Q1tpXS5sZW5ndGggPSAwXG4gICAgREFUQVtpXS5sZW5ndGggPSAwXG4gICAgQlVGRkVSW2ldLmxlbmd0aCA9IDBcbiAgfVxufVxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5aWIzZ3RhVzUwWlhKelpXTjBMMjV2WkdWZmJXOWtkV3hsY3k5MGVYQmxaR0Z5Y21GNUxYQnZiMnd2Y0c5dmJDNXFjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRWlMQ0ptYVd4bElqb2laMlZ1WlhKaGRHVmtMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWlkMWMyVWdjM1J5YVdOMEoxeHVYRzUyWVhJZ1ltbDBjeUE5SUhKbGNYVnBjbVVvSjJKcGRDMTBkMmxrWkd4bEp5bGNiblpoY2lCa2RYQWdQU0J5WlhGMWFYSmxLQ2RrZFhBbktWeHVYRzR2TDB4bFoyRmplU0J3YjI5c0lITjFjSEJ2Y25SY2JtbG1LQ0ZuYkc5aVlXd3VYMTlVV1ZCRlJFRlNVa0ZaWDFCUFQwd3BJSHRjYmlBZ1oyeHZZbUZzTGw5ZlZGbFFSVVJCVWxKQldWOVFUMDlNSUQwZ2UxeHVJQ0FnSUNBZ1ZVbE9WRGdnSUNBNklHUjFjQ2hiTXpJc0lEQmRLVnh1SUNBZ0lDd2dWVWxPVkRFMklDQTZJR1IxY0NoYk16SXNJREJkS1Z4dUlDQWdJQ3dnVlVsT1ZETXlJQ0E2SUdSMWNDaGJNeklzSURCZEtWeHVJQ0FnSUN3Z1NVNVVPQ0FnSUNBNklHUjFjQ2hiTXpJc0lEQmRLVnh1SUNBZ0lDd2dTVTVVTVRZZ0lDQTZJR1IxY0NoYk16SXNJREJkS1Z4dUlDQWdJQ3dnU1U1VU16SWdJQ0E2SUdSMWNDaGJNeklzSURCZEtWeHVJQ0FnSUN3Z1JreFBRVlFnSUNBNklHUjFjQ2hiTXpJc0lEQmRLVnh1SUNBZ0lDd2dSRTlWUWt4RklDQTZJR1IxY0NoYk16SXNJREJkS1Z4dUlDQWdJQ3dnUkVGVVFTQWdJQ0E2SUdSMWNDaGJNeklzSURCZEtWeHVJQ0FnSUN3Z1ZVbE9WRGhESUNBNklHUjFjQ2hiTXpJc0lEQmRLVnh1SUNBZ0lDd2dRbFZHUmtWU0lDQTZJR1IxY0NoYk16SXNJREJkS1Z4dUlDQjlYRzU5WEc1Y2JuWmhjaUJvWVhOVmFXNTBPRU1nUFNBb2RIbHdaVzltSUZWcGJuUTRRMnhoYlhCbFpFRnljbUY1S1NBaFBUMGdKM1Z1WkdWbWFXNWxaQ2RjYm5aaGNpQlFUMDlNSUQwZ1oyeHZZbUZzTGw5ZlZGbFFSVVJCVWxKQldWOVFUMDlNWEc1Y2JpOHZWWEJuY21Ga1pTQndiMjlzWEc1cFppZ2hVRTlQVEM1VlNVNVVPRU1wSUh0Y2JpQWdVRTlQVEM1VlNVNVVPRU1nUFNCa2RYQW9Xek15TENBd1hTbGNibjFjYm1sbUtDRlFUMDlNTGtKVlJrWkZVaWtnZTF4dUlDQlFUMDlNTGtKVlJrWkZVaUE5SUdSMWNDaGJNeklzSURCZEtWeHVmVnh1WEc0dkwwNWxkeUIwWldOb2JtbHhkV1U2SUU5dWJIa2dZV3hzYjJOaGRHVWdabkp2YlNCQmNuSmhlVUoxWm1abGNsWnBaWGNnWVc1a0lFSjFabVpsY2x4dWRtRnlJRVJCVkVFZ0lDQWdQU0JRVDA5TUxrUkJWRUZjYmlBZ0xDQkNWVVpHUlZJZ0lEMGdVRTlQVEM1Q1ZVWkdSVkpjYmx4dVpYaHdiM0owY3k1bWNtVmxJRDBnWm5WdVkzUnBiMjRnWm5KbFpTaGhjbkpoZVNrZ2UxeHVJQ0JwWmloQ2RXWm1aWEl1YVhOQ2RXWm1aWElvWVhKeVlYa3BLU0I3WEc0Z0lDQWdRbFZHUmtWU1cySnBkSE11Ykc5bk1paGhjbkpoZVM1c1pXNW5kR2dwWFM1d2RYTm9LR0Z5Y21GNUtWeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lHbG1LRTlpYW1WamRDNXdjbTkwYjNSNWNHVXVkRzlUZEhKcGJtY3VZMkZzYkNoaGNuSmhlU2tnSVQwOUlDZGJiMkpxWldOMElFRnljbUY1UW5WbVptVnlYU2NwSUh0Y2JpQWdJQ0FnSUdGeWNtRjVJRDBnWVhKeVlYa3VZblZtWm1WeVhHNGdJQ0FnZlZ4dUlDQWdJR2xtS0NGaGNuSmhlU2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVYRzRnSUNBZ2ZWeHVJQ0FnSUhaaGNpQnVJRDBnWVhKeVlYa3ViR1Z1WjNSb0lIeDhJR0Z5Y21GNUxtSjVkR1ZNWlc1bmRHaGNiaUFnSUNCMllYSWdiRzluWDI0Z1BTQmlhWFJ6TG14dlp6SW9iaWw4TUZ4dUlDQWdJRVJCVkVGYmJHOW5YMjVkTG5CMWMyZ29ZWEp5WVhrcFhHNGdJSDFjYm4xY2JseHVablZ1WTNScGIyNGdabkpsWlVGeWNtRjVRblZtWm1WeUtHSjFabVpsY2lrZ2UxeHVJQ0JwWmlnaFluVm1abVZ5S1NCN1hHNGdJQ0FnY21WMGRYSnVYRzRnSUgxY2JpQWdkbUZ5SUc0Z1BTQmlkV1ptWlhJdWJHVnVaM1JvSUh4OElHSjFabVpsY2k1aWVYUmxUR1Z1WjNSb1hHNGdJSFpoY2lCc2IyZGZiaUE5SUdKcGRITXViRzluTWlodUtWeHVJQ0JFUVZSQlcyeHZaMTl1WFM1d2RYTm9LR0oxWm1abGNpbGNibjFjYmx4dVpuVnVZM1JwYjI0Z1puSmxaVlI1Y0dWa1FYSnlZWGtvWVhKeVlYa3BJSHRjYmlBZ1puSmxaVUZ5Y21GNVFuVm1abVZ5S0dGeWNtRjVMbUoxWm1abGNpbGNibjFjYmx4dVpYaHdiM0owY3k1bWNtVmxWV2x1ZERnZ1BWeHVaWGh3YjNKMGN5NW1jbVZsVldsdWRERTJJRDFjYm1WNGNHOXlkSE11Wm5KbFpWVnBiblF6TWlBOVhHNWxlSEJ2Y25SekxtWnlaV1ZKYm5RNElEMWNibVY0Y0c5eWRITXVabkpsWlVsdWRERTJJRDFjYm1WNGNHOXlkSE11Wm5KbFpVbHVkRE15SUQxY2JtVjRjRzl5ZEhNdVpuSmxaVVpzYjJGME16SWdQU0JjYm1WNGNHOXlkSE11Wm5KbFpVWnNiMkYwSUQxY2JtVjRjRzl5ZEhNdVpuSmxaVVpzYjJGME5qUWdQU0JjYm1WNGNHOXlkSE11Wm5KbFpVUnZkV0pzWlNBOUlGeHVaWGh3YjNKMGN5NW1jbVZsVldsdWREaERiR0Z0Y0dWa0lEMGdYRzVsZUhCdmNuUnpMbVp5WldWRVlYUmhWbWxsZHlBOUlHWnlaV1ZVZVhCbFpFRnljbUY1WEc1Y2JtVjRjRzl5ZEhNdVpuSmxaVUZ5Y21GNVFuVm1abVZ5SUQwZ1puSmxaVUZ5Y21GNVFuVm1abVZ5WEc1Y2JtVjRjRzl5ZEhNdVpuSmxaVUoxWm1abGNpQTlJR1oxYm1OMGFXOXVJR1p5WldWQ2RXWm1aWElvWVhKeVlYa3BJSHRjYmlBZ1FsVkdSa1ZTVzJKcGRITXViRzluTWloaGNuSmhlUzVzWlc1bmRHZ3BYUzV3ZFhOb0tHRnljbUY1S1Z4dWZWeHVYRzVsZUhCdmNuUnpMbTFoYkd4dll5QTlJR1oxYm1OMGFXOXVJRzFoYkd4dll5aHVMQ0JrZEhsd1pTa2dlMXh1SUNCcFppaGtkSGx3WlNBOVBUMGdkVzVrWldacGJtVmtJSHg4SUdSMGVYQmxJRDA5UFNBbllYSnlZWGxpZFdabVpYSW5LU0I3WEc0Z0lDQWdjbVYwZFhKdUlHMWhiR3h2WTBGeWNtRjVRblZtWm1WeUtHNHBYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdjM2RwZEdOb0tHUjBlWEJsS1NCN1hHNGdJQ0FnSUNCallYTmxJQ2QxYVc1ME9DYzZYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQnRZV3hzYjJOVmFXNTBPQ2h1S1Z4dUlDQWdJQ0FnWTJGelpTQW5kV2x1ZERFMkp6cGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHMWhiR3h2WTFWcGJuUXhOaWh1S1Z4dUlDQWdJQ0FnWTJGelpTQW5kV2x1ZERNeUp6cGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHMWhiR3h2WTFWcGJuUXpNaWh1S1Z4dUlDQWdJQ0FnWTJGelpTQW5hVzUwT0NjNlhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCdFlXeHNiMk5KYm5RNEtHNHBYRzRnSUNBZ0lDQmpZWE5sSUNkcGJuUXhOaWM2WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJ0WVd4c2IyTkpiblF4TmlodUtWeHVJQ0FnSUNBZ1kyRnpaU0FuYVc1ME16SW5PbHh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdiV0ZzYkc5alNXNTBNeklvYmlsY2JpQWdJQ0FnSUdOaGMyVWdKMlpzYjJGMEp6cGNiaUFnSUNBZ0lHTmhjMlVnSjJac2IyRjBNekluT2x4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnYldGc2JHOWpSbXh2WVhRb2JpbGNiaUFnSUNBZ0lHTmhjMlVnSjJSdmRXSnNaU2M2WEc0Z0lDQWdJQ0JqWVhObElDZG1iRzloZERZMEp6cGNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlHMWhiR3h2WTBSdmRXSnNaU2h1S1Z4dUlDQWdJQ0FnWTJGelpTQW5kV2x1ZERoZlkyeGhiWEJsWkNjNlhHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCdFlXeHNiMk5WYVc1ME9FTnNZVzF3WldRb2JpbGNiaUFnSUNBZ0lHTmhjMlVnSjJKMVptWmxjaWM2WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJ0WVd4c2IyTkNkV1ptWlhJb2JpbGNiaUFnSUNBZ0lHTmhjMlVnSjJSaGRHRW5PbHh1SUNBZ0lDQWdZMkZ6WlNBblpHRjBZWFpwWlhjbk9seHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2JXRnNiRzlqUkdGMFlWWnBaWGNvYmlsY2JseHVJQ0FnSUNBZ1pHVm1ZWFZzZERwY2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUc1MWJHeGNiaUFnSUNCOVhHNGdJSDFjYmlBZ2NtVjBkWEp1SUc1MWJHeGNibjFjYmx4dVpuVnVZM1JwYjI0Z2JXRnNiRzlqUVhKeVlYbENkV1ptWlhJb2Jpa2dlMXh1SUNCMllYSWdiaUE5SUdKcGRITXVibVY0ZEZCdmR6SW9iaWxjYmlBZ2RtRnlJR3h2WjE5dUlEMGdZbWwwY3k1c2IyY3lLRzRwWEc0Z0lIWmhjaUJrSUQwZ1JFRlVRVnRzYjJkZmJsMWNiaUFnYVdZb1pDNXNaVzVuZEdnZ1BpQXdLU0I3WEc0Z0lDQWdjbVYwZFhKdUlHUXVjRzl3S0NsY2JpQWdmVnh1SUNCeVpYUjFjbTRnYm1WM0lFRnljbUY1UW5WbVptVnlLRzRwWEc1OVhHNWxlSEJ2Y25SekxtMWhiR3h2WTBGeWNtRjVRblZtWm1WeUlEMGdiV0ZzYkc5alFYSnlZWGxDZFdabVpYSmNibHh1Wm5WdVkzUnBiMjRnYldGc2JHOWpWV2x1ZERnb2Jpa2dlMXh1SUNCeVpYUjFjbTRnYm1WM0lGVnBiblE0UVhKeVlYa29iV0ZzYkc5alFYSnlZWGxDZFdabVpYSW9iaWtzSURBc0lHNHBYRzU5WEc1bGVIQnZjblJ6TG0xaGJHeHZZMVZwYm5RNElEMGdiV0ZzYkc5alZXbHVkRGhjYmx4dVpuVnVZM1JwYjI0Z2JXRnNiRzlqVldsdWRERTJLRzRwSUh0Y2JpQWdjbVYwZFhKdUlHNWxkeUJWYVc1ME1UWkJjbkpoZVNodFlXeHNiMk5CY25KaGVVSjFabVpsY2lneUttNHBMQ0F3TENCdUtWeHVmVnh1Wlhod2IzSjBjeTV0WVd4c2IyTlZhVzUwTVRZZ1BTQnRZV3hzYjJOVmFXNTBNVFpjYmx4dVpuVnVZM1JwYjI0Z2JXRnNiRzlqVldsdWRETXlLRzRwSUh0Y2JpQWdjbVYwZFhKdUlHNWxkeUJWYVc1ME16SkJjbkpoZVNodFlXeHNiMk5CY25KaGVVSjFabVpsY2lnMEttNHBMQ0F3TENCdUtWeHVmVnh1Wlhod2IzSjBjeTV0WVd4c2IyTlZhVzUwTXpJZ1BTQnRZV3hzYjJOVmFXNTBNekpjYmx4dVpuVnVZM1JwYjI0Z2JXRnNiRzlqU1c1ME9DaHVLU0I3WEc0Z0lISmxkSFZ5YmlCdVpYY2dTVzUwT0VGeWNtRjVLRzFoYkd4dlkwRnljbUY1UW5WbVptVnlLRzRwTENBd0xDQnVLVnh1ZlZ4dVpYaHdiM0owY3k1dFlXeHNiMk5KYm5RNElEMGdiV0ZzYkc5alNXNTBPRnh1WEc1bWRXNWpkR2x2YmlCdFlXeHNiMk5KYm5ReE5paHVLU0I3WEc0Z0lISmxkSFZ5YmlCdVpYY2dTVzUwTVRaQmNuSmhlU2h0WVd4c2IyTkJjbkpoZVVKMVptWmxjaWd5S200cExDQXdMQ0J1S1Z4dWZWeHVaWGh3YjNKMGN5NXRZV3hzYjJOSmJuUXhOaUE5SUcxaGJHeHZZMGx1ZERFMlhHNWNibVoxYm1OMGFXOXVJRzFoYkd4dlkwbHVkRE15S0c0cElIdGNiaUFnY21WMGRYSnVJRzVsZHlCSmJuUXpNa0Z5Y21GNUtHMWhiR3h2WTBGeWNtRjVRblZtWm1WeUtEUXFiaWtzSURBc0lHNHBYRzU5WEc1bGVIQnZjblJ6TG0xaGJHeHZZMGx1ZERNeUlEMGdiV0ZzYkc5alNXNTBNekpjYmx4dVpuVnVZM1JwYjI0Z2JXRnNiRzlqUm14dllYUW9iaWtnZTF4dUlDQnlaWFIxY200Z2JtVjNJRVpzYjJGME16SkJjbkpoZVNodFlXeHNiMk5CY25KaGVVSjFabVpsY2lnMEttNHBMQ0F3TENCdUtWeHVmVnh1Wlhod2IzSjBjeTV0WVd4c2IyTkdiRzloZERNeUlEMGdaWGh3YjNKMGN5NXRZV3hzYjJOR2JHOWhkQ0E5SUcxaGJHeHZZMFpzYjJGMFhHNWNibVoxYm1OMGFXOXVJRzFoYkd4dlkwUnZkV0pzWlNodUtTQjdYRzRnSUhKbGRIVnliaUJ1WlhjZ1JteHZZWFEyTkVGeWNtRjVLRzFoYkd4dlkwRnljbUY1UW5WbVptVnlLRGdxYmlrc0lEQXNJRzRwWEc1OVhHNWxlSEJ2Y25SekxtMWhiR3h2WTBac2IyRjBOalFnUFNCbGVIQnZjblJ6TG0xaGJHeHZZMFJ2ZFdKc1pTQTlJRzFoYkd4dlkwUnZkV0pzWlZ4dVhHNW1kVzVqZEdsdmJpQnRZV3hzYjJOVmFXNTBPRU5zWVcxd1pXUW9iaWtnZTF4dUlDQnBaaWhvWVhOVmFXNTBPRU1wSUh0Y2JpQWdJQ0J5WlhSMWNtNGdibVYzSUZWcGJuUTRRMnhoYlhCbFpFRnljbUY1S0cxaGJHeHZZMEZ5Y21GNVFuVm1abVZ5S0c0cExDQXdMQ0J1S1Z4dUlDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUhKbGRIVnliaUJ0WVd4c2IyTlZhVzUwT0NodUtWeHVJQ0I5WEc1OVhHNWxlSEJ2Y25SekxtMWhiR3h2WTFWcGJuUTRRMnhoYlhCbFpDQTlJRzFoYkd4dlkxVnBiblE0UTJ4aGJYQmxaRnh1WEc1bWRXNWpkR2x2YmlCdFlXeHNiMk5FWVhSaFZtbGxkeWh1S1NCN1hHNGdJSEpsZEhWeWJpQnVaWGNnUkdGMFlWWnBaWGNvYldGc2JHOWpRWEp5WVhsQ2RXWm1aWElvYmlrc0lEQXNJRzRwWEc1OVhHNWxlSEJ2Y25SekxtMWhiR3h2WTBSaGRHRldhV1YzSUQwZ2JXRnNiRzlqUkdGMFlWWnBaWGRjYmx4dVpuVnVZM1JwYjI0Z2JXRnNiRzlqUW5WbVptVnlLRzRwSUh0Y2JpQWdiaUE5SUdKcGRITXVibVY0ZEZCdmR6SW9iaWxjYmlBZ2RtRnlJR3h2WjE5dUlEMGdZbWwwY3k1c2IyY3lLRzRwWEc0Z0lIWmhjaUJqWVdOb1pTQTlJRUpWUmtaRlVsdHNiMmRmYmwxY2JpQWdhV1lvWTJGamFHVXViR1Z1WjNSb0lENGdNQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQmpZV05vWlM1d2IzQW9LVnh1SUNCOVhHNGdJSEpsZEhWeWJpQnVaWGNnUW5WbVptVnlLRzRwWEc1OVhHNWxlSEJ2Y25SekxtMWhiR3h2WTBKMVptWmxjaUE5SUcxaGJHeHZZMEoxWm1abGNseHVYRzVsZUhCdmNuUnpMbU5zWldGeVEyRmphR1VnUFNCbWRXNWpkR2x2YmlCamJHVmhja05oWTJobEtDa2dlMXh1SUNCbWIzSW9kbUZ5SUdrOU1Ec2dhVHd6TWpzZ0t5dHBLU0I3WEc0Z0lDQWdVRTlQVEM1VlNVNVVPRnRwWFM1c1pXNW5kR2dnUFNBd1hHNGdJQ0FnVUU5UFRDNVZTVTVVTVRaYmFWMHViR1Z1WjNSb0lEMGdNRnh1SUNBZ0lGQlBUMHd1VlVsT1ZETXlXMmxkTG14bGJtZDBhQ0E5SURCY2JpQWdJQ0JRVDA5TUxrbE9WRGhiYVYwdWJHVnVaM1JvSUQwZ01GeHVJQ0FnSUZCUFQwd3VTVTVVTVRaYmFWMHViR1Z1WjNSb0lEMGdNRnh1SUNBZ0lGQlBUMHd1U1U1VU16SmJhVjB1YkdWdVozUm9JRDBnTUZ4dUlDQWdJRkJQVDB3dVJreFBRVlJiYVYwdWJHVnVaM1JvSUQwZ01GeHVJQ0FnSUZCUFQwd3VSRTlWUWt4RlcybGRMbXhsYm1kMGFDQTlJREJjYmlBZ0lDQlFUMDlNTGxWSlRsUTRRMXRwWFM1c1pXNW5kR2dnUFNBd1hHNGdJQ0FnUkVGVVFWdHBYUzVzWlc1bmRHZ2dQU0F3WEc0Z0lDQWdRbFZHUmtWU1cybGRMbXhsYm1kMGFDQTlJREJjYmlBZ2ZWeHVmU0pkZlE9PSIsbnVsbCwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzLWFycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIGtNYXhMZW5ndGggPSAweDNmZmZmZmZmXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIE5vdGU6XG4gKlxuICogLSBJbXBsZW1lbnRhdGlvbiBtdXN0IHN1cHBvcnQgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMuXG4gKiAgIEZpcmVmb3ggNC0yOSBsYWNrZWQgc3VwcG9ydCwgZml4ZWQgaW4gRmlyZWZveCAzMCsuXG4gKiAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG4gKlxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXkgd2lsbFxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgd2lsbCB3b3JrIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSAoZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoMSkuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpXG4gICAgbGVuZ3RoID0gc3ViamVjdCA+IDAgPyBzdWJqZWN0ID4+PiAwIDogMFxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpXG4gICAgICBzdWJqZWN0ID0gYmFzZTY0Y2xlYW4oc3ViamVjdClcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiBzdWJqZWN0ICE9PSBudWxsKSB7IC8vIGFzc3VtZSBvYmplY3QgaXMgYXJyYXktbGlrZVxuICAgIGlmIChzdWJqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkoc3ViamVjdC5kYXRhKSlcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0LmRhdGFcbiAgICBsZW5ndGggPSArc3ViamVjdC5sZW5ndGggPiAwID8gTWF0aC5mbG9vcigrc3ViamVjdC5sZW5ndGgpIDogMFxuICB9IGVsc2VcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHN0YXJ0IHdpdGggbnVtYmVyLCBidWZmZXIsIGFycmF5IG9yIHN0cmluZycpXG5cbiAgaWYgKHRoaXMubGVuZ3RoID4ga01heExlbmd0aClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuXG4gIHZhciBidWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgYnVmID0gdGhpc1xuICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGhcbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgYnVmW2ldID0gKChzdWJqZWN0W2ldICUgMjU2KSArIDI1NikgJSAyNTZcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuICYmIGFbaV0gPT09IGJbaV07IGkrKykge31cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdFssIGxlbmd0aF0pJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0b3RhbExlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICB2YXIgcmV0XG4gIHN0ciA9IHN0ciArICcnXG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoID4+PiAxXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbkJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG5cbi8vIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA9PT0gSW5maW5pdHkgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG4gIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChlbmQgPD0gc3RhcnQpIHJldHVybiAnJ1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGIpIHtcbiAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpXG4gICAgICBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbi8vIGBnZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihieXRlKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgMilcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSB1dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBhc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuO1xuICAgIGlmIChzdGFydCA8IDApXG4gICAgICBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMClcbiAgICAgIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydClcbiAgICBlbmQgPSBzdGFydFxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHJldHVybiBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQsIHRydWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZlxuICB9XG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpXG4gICAgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXNcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGlmICh0YXJnZXRfc3RhcnQgPCAwIHx8IHRhcmdldF9zdGFydCA+PSB0YXJnZXQubGVuZ3RoKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHNvdXJjZS5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBzb3VyY2UubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLXpdL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoYiA8PSAweDdGKSB7XG4gICAgICBieXRlQXJyYXkucHVzaChiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSBpXG4gICAgICBpZiAoYiA+PSAweEQ4MDAgJiYgYiA8PSAweERGRkYpIGkrK1xuICAgICAgdmFyIGggPSBlbmNvZGVVUklDb21wb25lbnQoc3RyLnNsaWNlKHN0YXJ0LCBpKzEpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoc3RyKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgsIHVuaXRTaXplKSB7XG4gIGlmICh1bml0U2l6ZSkgbGVuZ3RoIC09IGxlbmd0aCAlIHVuaXRTaXplO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIlxuLyoqXG4gKiBpc0FycmF5XG4gKi9cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIHRvU3RyaW5nXG4gKi9cblxudmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIGdpdmVuIGB2YWxgXG4gKiBpcyBhbiBhcnJheS5cbiAqXG4gKiBleGFtcGxlOlxuICpcbiAqICAgICAgICBpc0FycmF5KFtdKTtcbiAqICAgICAgICAvLyA+IHRydWVcbiAqICAgICAgICBpc0FycmF5KGFyZ3VtZW50cyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICogICAgICAgIGlzQXJyYXkoJycpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge21peGVkfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5IHx8IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuICEhIHZhbCAmJiAnW29iamVjdCBBcnJheV0nID09IHN0ci5jYWxsKHZhbCk7XG59O1xuIiwiLy8gKGMpIERlYW4gTWNOYW1lZSA8ZGVhbkBnbWFpbC5jb20+LCAyMDEyLlxuLy9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWFubS9jc3MtY29sb3ItcGFyc2VyLWpzXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1Ncbi8vIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci9cbnZhciBrQ1NTQ29sb3JUYWJsZSA9IHtcbiAgXCJ0cmFuc3BhcmVudFwiOiBbMCwwLDAsMF0sIFwiYWxpY2VibHVlXCI6IFsyNDAsMjQ4LDI1NSwxXSxcbiAgXCJhbnRpcXVld2hpdGVcIjogWzI1MCwyMzUsMjE1LDFdLCBcImFxdWFcIjogWzAsMjU1LDI1NSwxXSxcbiAgXCJhcXVhbWFyaW5lXCI6IFsxMjcsMjU1LDIxMiwxXSwgXCJhenVyZVwiOiBbMjQwLDI1NSwyNTUsMV0sXG4gIFwiYmVpZ2VcIjogWzI0NSwyNDUsMjIwLDFdLCBcImJpc3F1ZVwiOiBbMjU1LDIyOCwxOTYsMV0sXG4gIFwiYmxhY2tcIjogWzAsMCwwLDFdLCBcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsMjM1LDIwNSwxXSxcbiAgXCJibHVlXCI6IFswLDAsMjU1LDFdLCBcImJsdWV2aW9sZXRcIjogWzEzOCw0MywyMjYsMV0sXG4gIFwiYnJvd25cIjogWzE2NSw0Miw0MiwxXSwgXCJidXJseXdvb2RcIjogWzIyMiwxODQsMTM1LDFdLFxuICBcImNhZGV0Ymx1ZVwiOiBbOTUsMTU4LDE2MCwxXSwgXCJjaGFydHJldXNlXCI6IFsxMjcsMjU1LDAsMV0sXG4gIFwiY2hvY29sYXRlXCI6IFsyMTAsMTA1LDMwLDFdLCBcImNvcmFsXCI6IFsyNTUsMTI3LDgwLDFdLFxuICBcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsMTQ5LDIzNywxXSwgXCJjb3Juc2lsa1wiOiBbMjU1LDI0OCwyMjAsMV0sXG4gIFwiY3JpbXNvblwiOiBbMjIwLDIwLDYwLDFdLCBcImN5YW5cIjogWzAsMjU1LDI1NSwxXSxcbiAgXCJkYXJrYmx1ZVwiOiBbMCwwLDEzOSwxXSwgXCJkYXJrY3lhblwiOiBbMCwxMzksMTM5LDFdLFxuICBcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwxMzQsMTEsMV0sIFwiZGFya2dyYXlcIjogWzE2OSwxNjksMTY5LDFdLFxuICBcImRhcmtncmVlblwiOiBbMCwxMDAsMCwxXSwgXCJkYXJrZ3JleVwiOiBbMTY5LDE2OSwxNjksMV0sXG4gIFwiZGFya2toYWtpXCI6IFsxODksMTgzLDEwNywxXSwgXCJkYXJrbWFnZW50YVwiOiBbMTM5LDAsMTM5LDFdLFxuICBcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwxMDcsNDcsMV0sIFwiZGFya29yYW5nZVwiOiBbMjU1LDE0MCwwLDFdLFxuICBcImRhcmtvcmNoaWRcIjogWzE1Myw1MCwyMDQsMV0sIFwiZGFya3JlZFwiOiBbMTM5LDAsMCwxXSxcbiAgXCJkYXJrc2FsbW9uXCI6IFsyMzMsMTUwLDEyMiwxXSwgXCJkYXJrc2VhZ3JlZW5cIjogWzE0MywxODgsMTQzLDFdLFxuICBcImRhcmtzbGF0ZWJsdWVcIjogWzcyLDYxLDEzOSwxXSwgXCJkYXJrc2xhdGVncmF5XCI6IFs0Nyw3OSw3OSwxXSxcbiAgXCJkYXJrc2xhdGVncmV5XCI6IFs0Nyw3OSw3OSwxXSwgXCJkYXJrdHVycXVvaXNlXCI6IFswLDIwNiwyMDksMV0sXG4gIFwiZGFya3Zpb2xldFwiOiBbMTQ4LDAsMjExLDFdLCBcImRlZXBwaW5rXCI6IFsyNTUsMjAsMTQ3LDFdLFxuICBcImRlZXBza3libHVlXCI6IFswLDE5MSwyNTUsMV0sIFwiZGltZ3JheVwiOiBbMTA1LDEwNSwxMDUsMV0sXG4gIFwiZGltZ3JleVwiOiBbMTA1LDEwNSwxMDUsMV0sIFwiZG9kZ2VyYmx1ZVwiOiBbMzAsMTQ0LDI1NSwxXSxcbiAgXCJmaXJlYnJpY2tcIjogWzE3OCwzNCwzNCwxXSwgXCJmbG9yYWx3aGl0ZVwiOiBbMjU1LDI1MCwyNDAsMV0sXG4gIFwiZm9yZXN0Z3JlZW5cIjogWzM0LDEzOSwzNCwxXSwgXCJmdWNoc2lhXCI6IFsyNTUsMCwyNTUsMV0sXG4gIFwiZ2FpbnNib3JvXCI6IFsyMjAsMjIwLDIyMCwxXSwgXCJnaG9zdHdoaXRlXCI6IFsyNDgsMjQ4LDI1NSwxXSxcbiAgXCJnb2xkXCI6IFsyNTUsMjE1LDAsMV0sIFwiZ29sZGVucm9kXCI6IFsyMTgsMTY1LDMyLDFdLFxuICBcImdyYXlcIjogWzEyOCwxMjgsMTI4LDFdLCBcImdyZWVuXCI6IFswLDEyOCwwLDFdLFxuICBcImdyZWVueWVsbG93XCI6IFsxNzMsMjU1LDQ3LDFdLCBcImdyZXlcIjogWzEyOCwxMjgsMTI4LDFdLFxuICBcImhvbmV5ZGV3XCI6IFsyNDAsMjU1LDI0MCwxXSwgXCJob3RwaW5rXCI6IFsyNTUsMTA1LDE4MCwxXSxcbiAgXCJpbmRpYW5yZWRcIjogWzIwNSw5Miw5MiwxXSwgXCJpbmRpZ29cIjogWzc1LDAsMTMwLDFdLFxuICBcIml2b3J5XCI6IFsyNTUsMjU1LDI0MCwxXSwgXCJraGFraVwiOiBbMjQwLDIzMCwxNDAsMV0sXG4gIFwibGF2ZW5kZXJcIjogWzIzMCwyMzAsMjUwLDFdLCBcImxhdmVuZGVyYmx1c2hcIjogWzI1NSwyNDAsMjQ1LDFdLFxuICBcImxhd25ncmVlblwiOiBbMTI0LDI1MiwwLDFdLCBcImxlbW9uY2hpZmZvblwiOiBbMjU1LDI1MCwyMDUsMV0sXG4gIFwibGlnaHRibHVlXCI6IFsxNzMsMjE2LDIzMCwxXSwgXCJsaWdodGNvcmFsXCI6IFsyNDAsMTI4LDEyOCwxXSxcbiAgXCJsaWdodGN5YW5cIjogWzIyNCwyNTUsMjU1LDFdLCBcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6IFsyNTAsMjUwLDIxMCwxXSxcbiAgXCJsaWdodGdyYXlcIjogWzIxMSwyMTEsMjExLDFdLCBcImxpZ2h0Z3JlZW5cIjogWzE0NCwyMzgsMTQ0LDFdLFxuICBcImxpZ2h0Z3JleVwiOiBbMjExLDIxMSwyMTEsMV0sIFwibGlnaHRwaW5rXCI6IFsyNTUsMTgyLDE5MywxXSxcbiAgXCJsaWdodHNhbG1vblwiOiBbMjU1LDE2MCwxMjIsMV0sIFwibGlnaHRzZWFncmVlblwiOiBbMzIsMTc4LDE3MCwxXSxcbiAgXCJsaWdodHNreWJsdWVcIjogWzEzNSwyMDYsMjUwLDFdLCBcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksMTM2LDE1MywxXSxcbiAgXCJsaWdodHNsYXRlZ3JleVwiOiBbMTE5LDEzNiwxNTMsMV0sIFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwxOTYsMjIyLDFdLFxuICBcImxpZ2h0eWVsbG93XCI6IFsyNTUsMjU1LDIyNCwxXSwgXCJsaW1lXCI6IFswLDI1NSwwLDFdLFxuICBcImxpbWVncmVlblwiOiBbNTAsMjA1LDUwLDFdLCBcImxpbmVuXCI6IFsyNTAsMjQwLDIzMCwxXSxcbiAgXCJtYWdlbnRhXCI6IFsyNTUsMCwyNTUsMV0sIFwibWFyb29uXCI6IFsxMjgsMCwwLDFdLFxuICBcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwyMDUsMTcwLDFdLCBcIm1lZGl1bWJsdWVcIjogWzAsMCwyMDUsMV0sXG4gIFwibWVkaXVtb3JjaGlkXCI6IFsxODYsODUsMjExLDFdLCBcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LDExMiwyMTksMV0sXG4gIFwibWVkaXVtc2VhZ3JlZW5cIjogWzYwLDE3OSwxMTMsMV0sIFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsMTA0LDIzOCwxXSxcbiAgXCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwyNTAsMTU0LDFdLCBcIm1lZGl1bXR1cnF1b2lzZVwiOiBbNzIsMjA5LDIwNCwxXSxcbiAgXCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwyMSwxMzMsMV0sIFwibWlkbmlnaHRibHVlXCI6IFsyNSwyNSwxMTIsMV0sXG4gIFwibWludGNyZWFtXCI6IFsyNDUsMjU1LDI1MCwxXSwgXCJtaXN0eXJvc2VcIjogWzI1NSwyMjgsMjI1LDFdLFxuICBcIm1vY2Nhc2luXCI6IFsyNTUsMjI4LDE4MSwxXSwgXCJuYXZham93aGl0ZVwiOiBbMjU1LDIyMiwxNzMsMV0sXG4gIFwibmF2eVwiOiBbMCwwLDEyOCwxXSwgXCJvbGRsYWNlXCI6IFsyNTMsMjQ1LDIzMCwxXSxcbiAgXCJvbGl2ZVwiOiBbMTI4LDEyOCwwLDFdLCBcIm9saXZlZHJhYlwiOiBbMTA3LDE0MiwzNSwxXSxcbiAgXCJvcmFuZ2VcIjogWzI1NSwxNjUsMCwxXSwgXCJvcmFuZ2VyZWRcIjogWzI1NSw2OSwwLDFdLFxuICBcIm9yY2hpZFwiOiBbMjE4LDExMiwyMTQsMV0sIFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LDIzMiwxNzAsMV0sXG4gIFwicGFsZWdyZWVuXCI6IFsxNTIsMjUxLDE1MiwxXSwgXCJwYWxldHVycXVvaXNlXCI6IFsxNzUsMjM4LDIzOCwxXSxcbiAgXCJwYWxldmlvbGV0cmVkXCI6IFsyMTksMTEyLDE0NywxXSwgXCJwYXBheWF3aGlwXCI6IFsyNTUsMjM5LDIxMywxXSxcbiAgXCJwZWFjaHB1ZmZcIjogWzI1NSwyMTgsMTg1LDFdLCBcInBlcnVcIjogWzIwNSwxMzMsNjMsMV0sXG4gIFwicGlua1wiOiBbMjU1LDE5MiwyMDMsMV0sIFwicGx1bVwiOiBbMjIxLDE2MCwyMjEsMV0sXG4gIFwicG93ZGVyYmx1ZVwiOiBbMTc2LDIyNCwyMzAsMV0sIFwicHVycGxlXCI6IFsxMjgsMCwxMjgsMV0sXG4gIFwicmVkXCI6IFsyNTUsMCwwLDFdLCBcInJvc3licm93blwiOiBbMTg4LDE0MywxNDMsMV0sXG4gIFwicm95YWxibHVlXCI6IFs2NSwxMDUsMjI1LDFdLCBcInNhZGRsZWJyb3duXCI6IFsxMzksNjksMTksMV0sXG4gIFwic2FsbW9uXCI6IFsyNTAsMTI4LDExNCwxXSwgXCJzYW5keWJyb3duXCI6IFsyNDQsMTY0LDk2LDFdLFxuICBcInNlYWdyZWVuXCI6IFs0NiwxMzksODcsMV0sIFwic2Vhc2hlbGxcIjogWzI1NSwyNDUsMjM4LDFdLFxuICBcInNpZW5uYVwiOiBbMTYwLDgyLDQ1LDFdLCBcInNpbHZlclwiOiBbMTkyLDE5MiwxOTIsMV0sXG4gIFwic2t5Ymx1ZVwiOiBbMTM1LDIwNiwyMzUsMV0sIFwic2xhdGVibHVlXCI6IFsxMDYsOTAsMjA1LDFdLFxuICBcInNsYXRlZ3JheVwiOiBbMTEyLDEyOCwxNDQsMV0sIFwic2xhdGVncmV5XCI6IFsxMTIsMTI4LDE0NCwxXSxcbiAgXCJzbm93XCI6IFsyNTUsMjUwLDI1MCwxXSwgXCJzcHJpbmdncmVlblwiOiBbMCwyNTUsMTI3LDFdLFxuICBcInN0ZWVsYmx1ZVwiOiBbNzAsMTMwLDE4MCwxXSwgXCJ0YW5cIjogWzIxMCwxODAsMTQwLDFdLFxuICBcInRlYWxcIjogWzAsMTI4LDEyOCwxXSwgXCJ0aGlzdGxlXCI6IFsyMTYsMTkxLDIxNiwxXSxcbiAgXCJ0b21hdG9cIjogWzI1NSw5OSw3MSwxXSwgXCJ0dXJxdW9pc2VcIjogWzY0LDIyNCwyMDgsMV0sXG4gIFwidmlvbGV0XCI6IFsyMzgsMTMwLDIzOCwxXSwgXCJ3aGVhdFwiOiBbMjQ1LDIyMiwxNzksMV0sXG4gIFwid2hpdGVcIjogWzI1NSwyNTUsMjU1LDFdLCBcIndoaXRlc21va2VcIjogWzI0NSwyNDUsMjQ1LDFdLFxuICBcInllbGxvd1wiOiBbMjU1LDI1NSwwLDFdLCBcInllbGxvd2dyZWVuXCI6IFsxNTQsMjA1LDUwLDFdfVxuXG5mdW5jdGlvbiBjbGFtcF9jc3NfYnl0ZShpKSB7ICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMjU1LlxuICBpID0gTWF0aC5yb3VuZChpKTsgIC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDI1NSA/IDI1NSA6IGk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wX2Nzc19mbG9hdChmKSB7ICAvLyBDbGFtcCB0byBmbG9hdCAwLjAgLi4gMS4wLlxuICByZXR1cm4gZiA8IDAgPyAwIDogZiA+IDEgPyAxIDogZjtcbn1cblxuZnVuY3Rpb24gcGFyc2VfY3NzX2ludChzdHIpIHsgIC8vIGludCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJyUnKVxuICAgIHJldHVybiBjbGFtcF9jc3NfYnl0ZShwYXJzZUZsb2F0KHN0cikgLyAxMDAgKiAyNTUpO1xuICByZXR1cm4gY2xhbXBfY3NzX2J5dGUocGFyc2VJbnQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlX2Nzc19mbG9hdChzdHIpIHsgIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnJScpXG4gICAgcmV0dXJuIGNsYW1wX2Nzc19mbG9hdChwYXJzZUZsb2F0KHN0cikgLyAxMDApO1xuICByZXR1cm4gY2xhbXBfY3NzX2Zsb2F0KHBhcnNlRmxvYXQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCkge1xuICBpZiAoaCA8IDApIGggKz0gMTtcbiAgZWxzZSBpZiAoaCA+IDEpIGggLT0gMTtcblxuICBpZiAoaCAqIDYgPCAxKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoICogNjtcbiAgaWYgKGggKiAyIDwgMSkgcmV0dXJuIG0yO1xuICBpZiAoaCAqIDMgPCAyKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMi8zIC0gaCkgKiA2O1xuICByZXR1cm4gbTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ1NTQ29sb3IoY3NzX3N0cikge1xuICAvLyBSZW1vdmUgYWxsIHdoaXRlc3BhY2UsIG5vdCBjb21wbGlhbnQsIGJ1dCBzaG91bGQganVzdCBiZSBtb3JlIGFjY2VwdGluZy5cbiAgdmFyIHN0ciA9IGNzc19zdHIucmVwbGFjZSgvIC9nLCAnJykudG9Mb3dlckNhc2UoKTtcblxuICAvLyBDb2xvciBrZXl3b3JkcyAoYW5kIHRyYW5zcGFyZW50KSBsb29rdXAuXG4gIGlmIChzdHIgaW4ga0NTU0NvbG9yVGFibGUpIHJldHVybiBrQ1NTQ29sb3JUYWJsZVtzdHJdLnNsaWNlKCk7ICAvLyBkdXAuXG5cbiAgLy8gI2FiYyBhbmQgI2FiYzEyMyBzeW50YXguXG4gIGlmIChzdHJbMF0gPT09ICcjJykge1xuICAgIGlmIChzdHIubGVuZ3RoID09PSA0KSB7XG4gICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSByZXR1cm4gbnVsbDsgIC8vIENvdmVycyBOYU4uXG4gICAgICByZXR1cm4gWygoaXYgJiAweGYwMCkgPj4gNCkgfCAoKGl2ICYgMHhmMDApID4+IDgpLFxuICAgICAgICAgICAgICAoaXYgJiAweGYwKSB8ICgoaXYgJiAweGYwKSA+PiA0KSxcbiAgICAgICAgICAgICAgKGl2ICYgMHhmKSB8ICgoaXYgJiAweGYpIDw8IDQpLFxuICAgICAgICAgICAgICAxXTtcbiAgICB9IGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZmZmZikpIHJldHVybiBudWxsOyAgLy8gQ292ZXJzIE5hTi5cbiAgICAgIHJldHVybiBbKGl2ICYgMHhmZjAwMDApID4+IDE2LFxuICAgICAgICAgICAgICAoaXYgJiAweGZmMDApID4+IDgsXG4gICAgICAgICAgICAgIGl2ICYgMHhmZixcbiAgICAgICAgICAgICAgMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgb3AgPSBzdHIuaW5kZXhPZignKCcpLCBlcCA9IHN0ci5pbmRleE9mKCcpJyk7XG4gIGlmIChvcCAhPT0gLTEgJiYgZXAgKyAxID09PSBzdHIubGVuZ3RoKSB7XG4gICAgdmFyIGZuYW1lID0gc3RyLnN1YnN0cigwLCBvcCk7XG4gICAgdmFyIHBhcmFtcyA9IHN0ci5zdWJzdHIob3ArMSwgZXAtKG9wKzEpKS5zcGxpdCgnLCcpO1xuICAgIHZhciBhbHBoYSA9IDE7ICAvLyBUbyBhbGxvdyBjYXNlIGZhbGx0aHJvdWdoLlxuICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgIGNhc2UgJ3JnYmEnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGFscGhhID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtcy5wb3AoKSk7XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgIGNhc2UgJ3JnYic6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIFtwYXJzZV9jc3NfaW50KHBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgcGFyc2VfY3NzX2ludChwYXJhbXNbMV0pLFxuICAgICAgICAgICAgICAgIHBhcnNlX2Nzc19pbnQocGFyYW1zWzJdKSxcbiAgICAgICAgICAgICAgICBhbHBoYV07XG4gICAgICBjYXNlICdoc2xhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHJldHVybiBudWxsO1xuICAgICAgICBhbHBoYSA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICdoc2wnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBoID0gKCgocGFyc2VGbG9hdChwYXJhbXNbMF0pICUgMzYwKSArIDM2MCkgJSAzNjApIC8gMzYwOyAgLy8gMCAuLiAxXG4gICAgICAgIC8vIE5PVEUoZGVhbm0pOiBBY2NvcmRpbmcgdG8gdGhlIENTUyBzcGVjIHMvbCBzaG91bGQgb25seSBiZVxuICAgICAgICAvLyBwZXJjZW50YWdlcywgYnV0IHdlIGRvbid0IGJvdGhlciBhbmQgbGV0IGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIHZhciBzID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtc1sxXSk7XG4gICAgICAgIHZhciBsID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtc1syXSk7XG4gICAgICAgIHZhciBtMiA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICB2YXIgbTEgPSBsICogMiAtIG0yO1xuICAgICAgICByZXR1cm4gW2NsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCsxLzMpICogMjU1KSxcbiAgICAgICAgICAgICAgICBjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgpICogMjU1KSxcbiAgICAgICAgICAgICAgICBjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgtMS8zKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgYWxwaGFdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnRyeSB7IGV4cG9ydHMucGFyc2VDU1NDb2xvciA9IHBhcnNlQ1NTQ29sb3IgfSBjYXRjaChlKSB7IH1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBlYXJjdXQ7XG5cbmZ1bmN0aW9uIGVhcmN1dChwb2ludHMpIHtcblxuICAgIHZhciBvdXRlck5vZGUgPSBsaW5rZWRMaXN0KHBvaW50c1swXSwgdHJ1ZSksXG4gICAgICAgIG5vZGUsIG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIHNpemUsXG4gICAgICAgIGxlbiA9IDAsXG4gICAgICAgIHRocmVzaG9sZCA9IDgwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGxlbiA8IHRocmVzaG9sZCAmJiBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSBsZW4gKz0gcG9pbnRzW2ldLmxlbmd0aDtcblxuICAgIC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxuICAgIGlmIChsZW4gPj0gdGhyZXNob2xkKSB7XG4gICAgICAgIG5vZGUgPSBvdXRlck5vZGUubmV4dDtcbiAgICAgICAgbWluWCA9IG1heFggPSBub2RlLnBbMF07XG4gICAgICAgIG1pblkgPSBtYXhZID0gbm9kZS5wWzFdO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB4ID0gbm9kZS5wWzBdO1xuICAgICAgICAgICAgeSA9IG5vZGUucFsxXTtcbiAgICAgICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuICAgICAgICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcbiAgICAgICAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9IHdoaWxlIChub2RlICE9PSBvdXRlck5vZGUpO1xuXG4gICAgICAgIC8vIG1pblgsIG1pblkgYW5kIHNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXG4gICAgICAgIHNpemUgPSBNYXRoLm1heChtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgIH1cblxuICAgIGlmIChwb2ludHMubGVuZ3RoID4gMSkgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMocG9pbnRzLCBvdXRlck5vZGUpO1xuXG4gICAgdmFyIHRyaWFuZ2xlcyA9IFtdO1xuICAgIGlmIChvdXRlck5vZGUpIGVhcmN1dExpbmtlZChvdXRlck5vZGUsIHRyaWFuZ2xlcywgbWluWCwgbWluWSwgc2l6ZSk7XG5cbiAgICByZXR1cm4gdHJpYW5nbGVzO1xufVxuXG4vLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcbmZ1bmN0aW9uIGxpbmtlZExpc3QocG9pbnRzLCBjbG9ja3dpc2UpIHtcbiAgICB2YXIgc3VtID0gMCxcbiAgICAgICAgbGVuID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgaSwgaiwgbGFzdDtcblxuICAgIC8vIGNhbGN1bGF0ZSBvcmlnaW5hbCB3aW5kaW5nIG9yZGVyIG9mIGEgcG9seWdvbiByaW5nXG4gICAgZm9yIChpID0gMCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcbiAgICAgICAgdmFyIHAxID0gcG9pbnRzW2ldLFxuICAgICAgICAgICAgcDIgPSBwb2ludHNbal07XG4gICAgICAgIHN1bSArPSAocDJbMF0gLSBwMVswXSkgKiAocDFbMV0gKyBwMlsxXSk7XG4gICAgfVxuXG4gICAgLy8gbGluayBwb2ludHMgaW50byBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpc3QgaW4gdGhlIHNwZWNpZmllZCB3aW5kaW5nIG9yZGVyXG4gICAgaWYgKGNsb2Nrd2lzZSA9PT0gKHN1bSA+IDApKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykgbGFzdCA9IGluc2VydE5vZGUocG9pbnRzW2ldLCBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkgbGFzdCA9IGluc2VydE5vZGUocG9pbnRzW2ldLCBsYXN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGFzdDtcbn1cblxuZnVuY3Rpb24gZmlsdGVyUG9pbnRzKHN0YXJ0KSB7XG4gICAgLy8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcbiAgICB2YXIgbm9kZSA9IHN0YXJ0LFxuICAgICAgICBhZ2FpbjtcbiAgICBkbyB7XG4gICAgICAgIGFnYWluID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGVxdWFscyhub2RlLnAsIG5vZGUubmV4dC5wKSB8fCBvcmllbnQobm9kZS5wcmV2LnAsIG5vZGUucCwgbm9kZS5uZXh0LnApID09PSAwKSB7XG5cbiAgICAgICAgICAgIG5vZGUucHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XG5cbiAgICAgICAgICAgIGlmIChub2RlLnByZXZaKSBub2RlLnByZXZaLm5leHRaID0gbm9kZS5uZXh0WjtcbiAgICAgICAgICAgIGlmIChub2RlLm5leHRaKSBub2RlLm5leHRaLnByZXZaID0gbm9kZS5wcmV2WjtcblxuICAgICAgICAgICAgbm9kZSA9IHN0YXJ0ID0gbm9kZS5wcmV2O1xuXG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gbm9kZS5uZXh0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGFnYWluID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGFnYWluIHx8IG5vZGUgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBzdGFydDtcbn1cblxuZnVuY3Rpb24gZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBtaW5YLCBtaW5ZLCBzaXplLCBzZWNvbmRQYXNzKSB7XG4gICAgZWFyID0gZmlsdGVyUG9pbnRzKGVhcik7XG4gICAgaWYgKCFlYXIpIHJldHVybjtcblxuICAgIGlmICghc2Vjb25kUGFzcyAmJiBtaW5YICE9PSB1bmRlZmluZWQpIGluZGV4Q3VydmUoZWFyLCBtaW5YLCBtaW5ZLCBzaXplKTtcblxuICAgIHZhciBzdG9wID0gZWFyLFxuICAgICAgICBwcmV2LCBuZXh0O1xuXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXG4gICAgd2hpbGUgKGVhci5wcmV2ICE9PSBlYXIubmV4dCkge1xuICAgICAgICBwcmV2ID0gZWFyLnByZXY7XG4gICAgICAgIG5leHQgPSBlYXIubmV4dDtcblxuICAgICAgICBpZiAoaXNFYXIoZWFyLCBtaW5YLCBtaW5ZLCBzaXplKSkge1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocHJldi5wLCBlYXIucCwgbmV4dC5wKTtcblxuICAgICAgICAgICAgbmV4dC5wcmV2ID0gcHJldjtcbiAgICAgICAgICAgIHByZXYubmV4dCA9IG5leHQ7XG5cbiAgICAgICAgICAgIGlmIChlYXIucHJldlopIGVhci5wcmV2Wi5uZXh0WiA9IGVhci5uZXh0WjtcbiAgICAgICAgICAgIGlmIChlYXIubmV4dFopIGVhci5uZXh0Wi5wcmV2WiA9IGVhci5wcmV2WjtcblxuICAgICAgICAgICAgZWFyID0gbmV4dC5uZXh0O1xuICAgICAgICAgICAgc3RvcCA9IG5leHQubmV4dDtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBlYXIgPSBuZXh0O1xuXG4gICAgICAgIGlmIChlYXIgPT09IHN0b3ApIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGZpbmQgYW55IG1vcmUgZWFycywgdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIGN1dHRpbmcgYWdhaW5cbiAgICAgICAgICAgIGlmICghc2Vjb25kUGFzcykgZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBtaW5YLCBtaW5ZLCBzaXplLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlkbid0IHdvcmssIHRyeSBzcGxpdHRpbmcgdGhlIHJlbWFpbmluZyBwb2x5Z29uIGludG8gdHdvXG4gICAgICAgICAgICBlbHNlIHNwbGl0RWFyY3V0KGVhciwgdHJpYW5nbGVzLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0VhcihlYXIsIG1pblgsIG1pblksIHNpemUpIHtcblxuICAgIHZhciBhID0gZWFyLnByZXYucCxcbiAgICAgICAgYiA9IGVhci5wLFxuICAgICAgICBjID0gZWFyLm5leHQucCxcblxuICAgICAgICBheCA9IGFbMF0sIGJ4ID0gYlswXSwgY3ggPSBjWzBdLFxuICAgICAgICBheSA9IGFbMV0sIGJ5ID0gYlsxXSwgY3kgPSBjWzFdLFxuXG4gICAgICAgIGFiZCA9IGF4ICogYnkgLSBheSAqIGJ4LFxuICAgICAgICBhY2QgPSBheCAqIGN5IC0gYXkgKiBjeCxcbiAgICAgICAgY2JkID0gY3ggKiBieSAtIGN5ICogYngsXG4gICAgICAgIEEgPSBhYmQgLSBhY2QgLSBjYmQ7XG5cbiAgICBpZiAoQSA8PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICAvLyBub3cgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgb3RoZXIgcG9pbnRzIGluc2lkZSB0aGUgcG90ZW50aWFsIGVhclxuXG4gICAgdmFyIGNheSA9IGN5IC0gYXksXG4gICAgICAgIGFjeCA9IGF4IC0gY3gsXG4gICAgICAgIGFieSA9IGF5IC0gYnksXG4gICAgICAgIGJheCA9IGJ4IC0gYXgsXG4gICAgICAgIHAsIHB4LCBweSwgcywgdCwgaywgbm9kZTtcblxuICAgIC8vIGlmIHdlIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2hpbmcsIGl0ZXJhdGUgdGhyb3VnaCB0aGUgY3VydmVcbiAgICBpZiAobWluWCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICAgICAgdmFyIG1pblRYID0gYXggPCBieCA/IChheCA8IGN4ID8gYXggOiBjeCkgOiAoYnggPCBjeCA/IGJ4IDogY3gpLFxuICAgICAgICAgICAgbWluVFkgPSBheSA8IGJ5ID8gKGF5IDwgY3kgPyBheSA6IGN5KSA6IChieSA8IGN5ID8gYnkgOiBjeSksXG4gICAgICAgICAgICBtYXhUWCA9IGF4ID4gYnggPyAoYXggPiBjeCA/IGF4IDogY3gpIDogKGJ4ID4gY3ggPyBieCA6IGN4KSxcbiAgICAgICAgICAgIG1heFRZID0gYXkgPiBieSA/IChheSA+IGN5ID8gYXkgOiBjeSkgOiAoYnkgPiBjeSA/IGJ5IDogY3kpLFxuXG4gICAgICAgICAgICAvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuICAgICAgICAgICAgbWluWiA9IHpPcmRlcihtaW5UWCwgbWluVFksIG1pblgsIG1pblksIHNpemUpLFxuICAgICAgICAgICAgbWF4WiA9IHpPcmRlcihtYXhUWCwgbWF4VFksIG1pblgsIG1pblksIHNpemUpO1xuXG4gICAgICAgIC8vIGZpcnN0IGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGluY3JlYXNpbmcgei1vcmRlclxuICAgICAgICBub2RlID0gZWFyLm5leHRaO1xuXG4gICAgICAgIHdoaWxlIChub2RlICYmIG5vZGUueiA8PSBtYXhaKSB7XG4gICAgICAgICAgICBwID0gbm9kZS5wO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFo7XG4gICAgICAgICAgICBpZiAocCA9PT0gYSB8fCBwID09PSBjKSBjb250aW51ZTtcblxuICAgICAgICAgICAgcHggPSBwWzBdO1xuICAgICAgICAgICAgcHkgPSBwWzFdO1xuXG4gICAgICAgICAgICBzID0gY2F5ICogcHggKyBhY3ggKiBweSAtIGFjZDtcbiAgICAgICAgICAgIGlmIChzID49IDApIHtcbiAgICAgICAgICAgICAgICB0ID0gYWJ5ICogcHggKyBiYXggKiBweSArIGFiZDtcbiAgICAgICAgICAgICAgICBpZiAodCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSBBIC0gcyAtIHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoayA+PSAwKSAmJiAoKHMgJiYgdCkgfHwgKHMgJiYgaykgfHwgKHQgJiYgaykpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlbiBsb29rIGZvciBwb2ludHMgaW4gZGVjcmVhc2luZyB6LW9yZGVyXG4gICAgICAgIG5vZGUgPSBlYXIucHJldlo7XG5cbiAgICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZS56ID49IG1pblopIHtcbiAgICAgICAgICAgIHAgPSBub2RlLnA7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wcmV2WjtcbiAgICAgICAgICAgIGlmIChwID09PSBhIHx8IHAgPT09IGMpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBweCA9IHBbMF07XG4gICAgICAgICAgICBweSA9IHBbMV07XG5cbiAgICAgICAgICAgIHMgPSBjYXkgKiBweCArIGFjeCAqIHB5IC0gYWNkO1xuICAgICAgICAgICAgaWYgKHMgPj0gMCkge1xuICAgICAgICAgICAgICAgIHQgPSBhYnkgKiBweCArIGJheCAqIHB5ICsgYWJkO1xuICAgICAgICAgICAgICAgIGlmICh0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IEEgLSBzIC0gdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChrID49IDApICYmICgocyAmJiB0KSB8fCAocyAmJiBrKSB8fCAodCAmJiBrKSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIC8vIGlmIHdlIGRvbid0IHVzZSB6LW9yZGVyIGN1cnZlIGhhc2gsIHNpbXBseSBpdGVyYXRlIHRocm91Z2ggYWxsIG90aGVyIHBvaW50c1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBlYXIubmV4dC5uZXh0O1xuXG4gICAgICAgIHdoaWxlIChub2RlICE9PSBlYXIucHJldikge1xuICAgICAgICAgICAgcCA9IG5vZGUucDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG5cbiAgICAgICAgICAgIHB4ID0gcFswXTtcbiAgICAgICAgICAgIHB5ID0gcFsxXTtcblxuICAgICAgICAgICAgcyA9IGNheSAqIHB4ICsgYWN4ICogcHkgLSBhY2Q7XG4gICAgICAgICAgICBpZiAocyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdCA9IGFieSAqIHB4ICsgYmF4ICogcHkgKyBhYmQ7XG4gICAgICAgICAgICAgICAgaWYgKHQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBrID0gQSAtIHMgLSB0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGsgPj0gMCkgJiYgKChzICYmIHQpIHx8IChzICYmIGspIHx8ICh0ICYmIGspKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzcGxpdEVhcmN1dChzdGFydCwgdHJpYW5nbGVzLCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgLy8gZmluZCBhIHZhbGlkIGRpYWdvbmFsIHRoYXQgZGl2aWRlcyB0aGUgcG9seWdvbiBpbnRvIHR3b1xuICAgIHZhciBhID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYiA9IGEubmV4dC5uZXh0O1xuICAgICAgICB3aGlsZSAoYiAhPT0gYS5wcmV2KSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZERpYWdvbmFsKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BsaXQgdGhlIHBvbHlnb24gaW4gdHdvIGJ5IHRoZSBkaWFnb25hbFxuICAgICAgICAgICAgICAgIHZhciBjID0gc3BsaXRQb2x5Z29uKGEsIGIpO1xuXG4gICAgICAgICAgICAgICAgLy8gcnVuIGVhcmN1dCBvbiBlYWNoIGhhbGZcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYSwgdHJpYW5nbGVzLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYywgdHJpYW5nbGVzLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhLm5leHQ7XG4gICAgfSB3aGlsZSAoYSAhPT0gc3RhcnQpO1xufVxuXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlcyhwb2ludHMsIG91dGVyTm9kZSkge1xuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgdmFyIHF1ZXVlID0gW107XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgbGlzdCA9IGZpbHRlclBvaW50cyhsaW5rZWRMaXN0KHBvaW50c1tpXSwgZmFsc2UpKTtcbiAgICAgICAgaWYgKGxpc3QpIHF1ZXVlLnB1c2goZ2V0TGVmdG1vc3QobGlzdCkpO1xuICAgIH1cbiAgICBxdWV1ZS5zb3J0KGNvbXBhcmVYKTtcblxuICAgIC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XG4gICAgZm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsaW1pbmF0ZUhvbGUocXVldWVbaV0sIG91dGVyTm9kZSk7XG4gICAgICAgIG91dGVyTm9kZSA9IGZpbHRlclBvaW50cyhvdXRlck5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRlck5vZGU7XG59XG5cbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGUoaG9sZU5vZGUsIG91dGVyTm9kZSkge1xuICAgIG91dGVyTm9kZSA9IGZpbmRIb2xlQnJpZGdlKGhvbGVOb2RlLCBvdXRlck5vZGUpO1xuICAgIGlmIChvdXRlck5vZGUpIHNwbGl0UG9seWdvbihob2xlTm9kZSwgb3V0ZXJOb2RlKTtcbn1cblxuLy8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxuZnVuY3Rpb24gZmluZEhvbGVCcmlkZ2UoaG9sZU5vZGUsIG91dGVyTm9kZSkge1xuICAgIHZhciBub2RlID0gb3V0ZXJOb2RlLFxuICAgICAgICBwID0gaG9sZU5vZGUucCxcbiAgICAgICAgcHggPSBwWzBdLFxuICAgICAgICBweSA9IHBbMV0sXG4gICAgICAgIHFNYXggPSAtSW5maW5pdHksXG4gICAgICAgIG1Ob2RlLCBhLCBiO1xuXG4gICAgLy8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xuICAgIC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcbiAgICBkbyB7XG4gICAgICAgIGEgPSBub2RlLnA7XG4gICAgICAgIGIgPSBub2RlLm5leHQucDtcblxuICAgICAgICBpZiAocHkgPD0gYVsxXSAmJiBweSA+PSBiWzFdKSB7XG4gICAgICAgICAgICB2YXIgcXggPSBhWzBdICsgKHB5IC0gYVsxXSkgKiAoYlswXSAtIGFbMF0pIC8gKGJbMV0gLSBhWzFdKTtcbiAgICAgICAgICAgIGlmIChxeCA8PSBweCAmJiBxeCA+IHFNYXgpIHtcbiAgICAgICAgICAgICAgICBxTWF4ID0gcXg7XG4gICAgICAgICAgICAgICAgbU5vZGUgPSBhWzBdIDwgYlswXSA/IG5vZGUgOiBub2RlLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICB9IHdoaWxlIChub2RlICE9PSBvdXRlck5vZGUpO1xuXG4gICAgaWYgKCFtTm9kZSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgc3RyaWN0bHkgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XG4gICAgLy8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcblxuICAgIHZhciBieCA9IG1Ob2RlLnBbMF0sXG4gICAgICAgIGJ5ID0gbU5vZGUucFsxXSxcbiAgICAgICAgcGJkID0gcHggKiBieSAtIHB5ICogYngsXG4gICAgICAgIHBjZCA9IHB4ICogcHkgLSBweSAqIHFNYXgsXG4gICAgICAgIGNweSA9IHB5IC0gcHksXG4gICAgICAgIHBjeCA9IHB4IC0gcU1heCxcbiAgICAgICAgcGJ5ID0gcHkgLSBieSxcbiAgICAgICAgYnB4ID0gYnggLSBweCxcbiAgICAgICAgQSA9IHBiZCAtIHBjZCAtIChxTWF4ICogYnkgLSBweSAqIGJ4KSxcbiAgICAgICAgc2lnbiA9IEEgPD0gMCA/IC0xIDogMSxcbiAgICAgICAgc3RvcCA9IG1Ob2RlLFxuICAgICAgICB0YW5NaW4gPSBJbmZpbml0eSxcbiAgICAgICAgbXgsIG15LCBhbXgsIHMsIHQsIHRhbjtcblxuICAgIG5vZGUgPSBtTm9kZS5uZXh0O1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IHN0b3ApIHtcblxuICAgICAgICBteCA9IG5vZGUucFswXTtcbiAgICAgICAgbXkgPSBub2RlLnBbMV07XG4gICAgICAgIGFteCA9IHB4IC0gbXg7XG5cbiAgICAgICAgaWYgKGFteCA+PSAwICYmIG14ID49IGJ4KSB7XG4gICAgICAgICAgICBzID0gKGNweSAqIG14ICsgcGN4ICogbXkgLSBwY2QpICogc2lnbjtcbiAgICAgICAgICAgIGlmIChzID49IDApIHtcbiAgICAgICAgICAgICAgICB0ID0gKHBieSAqIG14ICsgYnB4ICogbXkgKyBwYmQpICogc2lnbjtcblxuICAgICAgICAgICAgICAgIGlmICh0ID49IDAgJiYgQSAqIHNpZ24gLSBzIC0gdCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhbiA9IE1hdGguYWJzKHB5IC0gbXkpIC8gYW14OyAvLyB0YW5nZW50aWFsXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YW4gPCB0YW5NaW4gJiYgbG9jYWxseUluc2lkZShub2RlLCBob2xlTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1Ob2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhbk1pbiA9IHRhbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1Ob2RlO1xufVxuXG5mdW5jdGlvbiBpbmRleEN1cnZlKHN0YXJ0LCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydDtcblxuICAgIGRvIHtcbiAgICAgICAgbm9kZS56ID0gbm9kZS56IHx8IHpPcmRlcihub2RlLnBbMF0sIG5vZGUucFsxXSwgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgIG5vZGUucHJldlogPSBub2RlLnByZXY7XG4gICAgICAgIG5vZGUubmV4dFogPSBub2RlLm5leHQ7XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfSB3aGlsZSAobm9kZSAhPT0gc3RhcnQpO1xuXG4gICAgbm9kZS5wcmV2Wi5uZXh0WiA9IG51bGw7XG4gICAgbm9kZS5wcmV2WiA9IG51bGw7XG5cbiAgICBzb3J0TGlua2VkKG5vZGUpO1xufVxuXG4vLyBTaW1vbiBUYXRoYW0ncyBsaW5rZWQgbGlzdCBtZXJnZSBzb3J0IGFsZ29yaXRobVxuLy8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcbmZ1bmN0aW9uIHNvcnRMaW5rZWQobGlzdCkge1xuICAgIHZhciBpLCBwLCBxLCBlLCB0YWlsLCBudW1NZXJnZXMsIHBTaXplLCBxU2l6ZSxcbiAgICAgICAgaW5TaXplID0gMTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHAgPSBsaXN0O1xuICAgICAgICBsaXN0ID0gbnVsbDtcbiAgICAgICAgdGFpbCA9IG51bGw7XG4gICAgICAgIG51bU1lcmdlcyA9IDA7XG5cbiAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgIG51bU1lcmdlcysrO1xuICAgICAgICAgICAgcSA9IHA7XG4gICAgICAgICAgICBwU2l6ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwU2l6ZSsrO1xuICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgIGlmICghcSkgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHFTaXplID0gaW5TaXplO1xuXG4gICAgICAgICAgICB3aGlsZSAocFNpemUgPiAwIHx8IChxU2l6ZSA+IDAgJiYgcSkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwU2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlID0gcTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHFTaXplLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxU2l6ZSA9PT0gMCB8fCAhcSkge1xuICAgICAgICAgICAgICAgICAgICBlID0gcDtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHBTaXplLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwLnogPD0gcS56KSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBwO1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcFNpemUtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlID0gcTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHFTaXplLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRhaWwpIHRhaWwubmV4dFogPSBlO1xuICAgICAgICAgICAgICAgIGVsc2UgbGlzdCA9IGU7XG5cbiAgICAgICAgICAgICAgICBlLnByZXZaID0gdGFpbDtcbiAgICAgICAgICAgICAgICB0YWlsID0gZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcCA9IHE7XG4gICAgICAgIH1cblxuICAgICAgICB0YWlsLm5leHRaID0gbnVsbDtcblxuICAgICAgICBpZiAobnVtTWVyZ2VzIDw9IDEpIHJldHVybiBsaXN0O1xuXG4gICAgICAgIGluU2l6ZSAqPSAyO1xuICAgIH1cbn1cblxuLy8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgYmJveFxuZnVuY3Rpb24gek9yZGVyKHgsIHksIG1pblgsIG1pblksIHNpemUpIHtcbiAgICAvLyBjb29yZHMgYXJlIHRyYW5zZm9ybWVkIGludG8gKDAuLjEwMDApIGludGVnZXIgcmFuZ2VcbiAgICB4ID0gMTAwMCAqICh4IC0gbWluWCkgLyBzaXplO1xuICAgIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICB5ID0gMTAwMCAqICh5IC0gbWluWSkgLyBzaXplO1xuICAgIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG5mdW5jdGlvbiBnZXRMZWZ0bW9zdChzdGFydCkge1xuICAgIHZhciBub2RlID0gc3RhcnQsXG4gICAgICAgIGxlZnRtb3N0ID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAobm9kZS5wWzBdIDwgbGVmdG1vc3QucFswXSkgbGVmdG1vc3QgPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH0gd2hpbGUgKG5vZGUgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBsZWZ0bW9zdDtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKGEsIGIpIHtcbiAgICByZXR1cm4gIWludGVyc2VjdHNQb2x5Z29uKGEsIGEucCwgYi5wKSAmJlxuICAgICAgICAgICBsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkgJiZcbiAgICAgICAgICAgbWlkZGxlSW5zaWRlKGEsIGEucCwgYi5wKTtcbn1cblxuLy8gd2luZGluZyBvcmRlciBvZiB0cmlhbmdsZSBmb3JtZWQgYnkgMyBnaXZlbiBwb2ludHNcbmZ1bmN0aW9uIG9yaWVudChwLCBxLCByKSB7XG4gICAgdmFyIG8gPSAocVsxXSAtIHBbMV0pICogKHJbMF0gLSBxWzBdKSAtIChxWzBdIC0gcFswXSkgKiAoclsxXSAtIHFbMV0pO1xuICAgIHJldHVybiBvID4gMCA/IDEgOlxuICAgICAgICAgICBvIDwgMCA/IC0xIDogMDtcbn1cblxuZnVuY3Rpb24gZXF1YWxzKHAxLCBwMikge1xuICAgIHJldHVybiBwMVswXSA9PT0gcDJbMF0gJiYgcDFbMV0gPT09IHAyWzFdO1xufVxuXG4vLyBjaGVjayBpZiB0d28gc2VnbWVudHMgaW50ZXJzZWN0XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHAxLCBxMSwgcDIsIHEyKSB7XG4gICAgcmV0dXJuIG9yaWVudChwMSwgcTEsIHAyKSAhPT0gb3JpZW50KHAxLCBxMSwgcTIpICYmXG4gICAgICAgICAgIG9yaWVudChwMiwgcTIsIHAxKSAhPT0gb3JpZW50KHAyLCBxMiwgcTEpO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xuZnVuY3Rpb24gaW50ZXJzZWN0c1BvbHlnb24oc3RhcnQsIGEsIGIpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIHAxID0gbm9kZS5wLFxuICAgICAgICAgICAgcDIgPSBub2RlLm5leHQucDtcblxuICAgICAgICBpZiAocDEgIT09IGEgJiYgcDIgIT09IGEgJiYgcDEgIT09IGIgJiYgcDIgIT09IGIgJiYgaW50ZXJzZWN0cyhwMSwgcDIsIGEsIGIpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH0gd2hpbGUgKG5vZGUgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGxvY2FsbHkgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBsb2NhbGx5SW5zaWRlKGEsIGIpIHtcbiAgICByZXR1cm4gb3JpZW50KGEucHJldi5wLCBhLnAsIGEubmV4dC5wKSA9PT0gLTEgP1xuICAgICAgICBvcmllbnQoYS5wLCBiLnAsIGEubmV4dC5wKSAhPT0gLTEgJiYgb3JpZW50KGEucCwgYS5wcmV2LnAsIGIucCkgIT09IC0xIDpcbiAgICAgICAgb3JpZW50KGEucCwgYi5wLCBhLnByZXYucCkgPT09IC0xIHx8IG9yaWVudChhLnAsIGEubmV4dC5wLCBiLnApID09PSAtMTtcbn1cblxuLy8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBtaWRkbGVJbnNpZGUoc3RhcnQsIGEsIGIpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0LFxuICAgICAgICBpbnNpZGUgPSBmYWxzZSxcbiAgICAgICAgcHggPSAoYVswXSArIGJbMF0pIC8gMixcbiAgICAgICAgcHkgPSAoYVsxXSArIGJbMV0pIC8gMjtcbiAgICBkbyB7XG4gICAgICAgIHZhciBwMSA9IG5vZGUucCxcbiAgICAgICAgICAgIHAyID0gbm9kZS5uZXh0LnA7XG5cbiAgICAgICAgaWYgKCgocDFbMV0gPiBweSkgIT09IChwMlsxXSA+IHB5KSkgJiZcbiAgICAgICAgICAgIChweCA8IChwMlswXSAtIHAxWzBdKSAqIChweSAtIHAxWzFdKSAvIChwMlsxXSAtIHAxWzFdKSArIHAxWzBdKSkgaW5zaWRlID0gIWluc2lkZTtcblxuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH0gd2hpbGUgKG5vZGUgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBpbnNpZGU7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVYKGEsIGIpIHtcbiAgICByZXR1cm4gYS5wWzBdIC0gYi5wWzBdO1xufVxuXG4vLyBzcGxpdCB0aGUgcG9seWdvbiB2ZXJ0aWNlcyBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpbmtlZCBsaXN0IGludG8gdHdvXG5mdW5jdGlvbiBzcGxpdFBvbHlnb24oYSwgYikge1xuICAgIHZhciBhMiA9IG5ldyBOb2RlKGEucCksXG4gICAgICAgIGIyID0gbmV3IE5vZGUoYi5wKSxcbiAgICAgICAgYW4gPSBhLm5leHQsXG4gICAgICAgIGJwID0gYi5wcmV2O1xuXG4gICAgYS5uZXh0ID0gYjtcbiAgICBiLnByZXYgPSBhO1xuXG4gICAgYTIubmV4dCA9IGFuO1xuICAgIGFuLnByZXYgPSBhMjtcblxuICAgIGIyLm5leHQgPSBhMjtcbiAgICBhMi5wcmV2ID0gYjI7XG5cbiAgICBicC5uZXh0ID0gYjI7XG4gICAgYjIucHJldiA9IGJwO1xuXG4gICAgcmV0dXJuIGEyO1xufVxuXG5mdW5jdGlvbiBpbnNlcnROb2RlKHBvaW50LCBsYXN0KSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgTm9kZShwb2ludCk7XG5cbiAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgbm9kZS5wcmV2ID0gbm9kZTtcbiAgICAgICAgbm9kZS5uZXh0ID0gbm9kZTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUubmV4dCA9IGxhc3QubmV4dDtcbiAgICAgICAgbm9kZS5wcmV2ID0gbGFzdDtcbiAgICAgICAgbGFzdC5uZXh0LnByZXYgPSBub2RlO1xuICAgICAgICBsYXN0Lm5leHQgPSBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gTm9kZShwKSB7XG4gICAgdGhpcy5wID0gcDtcbiAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG5cbiAgICB0aGlzLnogPSBudWxsO1xuICAgIHRoaXMucHJldlogPSBudWxsO1xuICAgIHRoaXMubmV4dFogPSBudWxsO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsaXA7XG5cbi8qIGNsaXAgZmVhdHVyZXMgYmV0d2VlbiB0d28gYXhpcy1wYXJhbGxlbCBsaW5lczpcbiAqICAgICB8ICAgICAgICB8XG4gKiAgX19ffF9fXyAgICAgfCAgICAgL1xuICogLyAgIHwgICBcXF9fX198X19fXy9cbiAqICAgICB8ICAgICAgICB8XG4gKi9cblxuZnVuY3Rpb24gY2xpcChmZWF0dXJlcywgc2NhbGUsIGsxLCBrMiwgYXhpcywgaW50ZXJzZWN0LCBtaW5BbGwsIG1heEFsbCkge1xuXG4gICAgazEgLz0gc2NhbGU7XG4gICAgazIgLz0gc2NhbGU7XG5cbiAgICBpZiAobWluQWxsID49IGsxICYmIG1heEFsbCA8PSBrMikgcmV0dXJuIGZlYXR1cmVzOyAvLyB0cml2aWFsIGFjY2VwdFxuICAgIGVsc2UgaWYgKG1pbkFsbCA+IGsyIHx8IG1heEFsbCA8IGsxKSByZXR1cm4gbnVsbDsgLy8gdHJpdmlhbCByZWplY3RcblxuICAgIHZhciBjbGlwcGVkID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlc1tpXSxcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gZmVhdHVyZS5nZW9tZXRyeSxcbiAgICAgICAgICAgIHR5cGUgPSBmZWF0dXJlLnR5cGUsXG4gICAgICAgICAgICBtaW4sIG1heDtcblxuICAgICAgICBtaW4gPSBmZWF0dXJlLm1pbltheGlzXTtcbiAgICAgICAgbWF4ID0gZmVhdHVyZS5tYXhbYXhpc107XG5cbiAgICAgICAgaWYgKG1pbiA+PSBrMSAmJiBtYXggPD0gazIpIHsgLy8gdHJpdmlhbCBhY2NlcHRcbiAgICAgICAgICAgIGNsaXBwZWQucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbiA+IGsyIHx8IG1heCA8IGsxKSBjb250aW51ZTsgLy8gdHJpdmlhbCByZWplY3RcblxuICAgICAgICB2YXIgc2xpY2VzID0gdHlwZSA9PT0gMSA/XG4gICAgICAgICAgICAgICAgY2xpcFBvaW50cyhnZW9tZXRyeSwgazEsIGsyLCBheGlzKSA6XG4gICAgICAgICAgICAgICAgY2xpcEdlb21ldHJ5KGdlb21ldHJ5LCBrMSwgazIsIGF4aXMsIGludGVyc2VjdCwgdHlwZSA9PT0gMyk7XG5cbiAgICAgICAgaWYgKHNsaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGlmIGEgZmVhdHVyZSBnb3QgY2xpcHBlZCwgaXQgd2lsbCBsaWtlbHkgZ2V0IGNsaXBwZWQgb24gdGhlIG5leHQgem9vbSBsZXZlbCBhcyB3ZWxsLFxuICAgICAgICAgICAgLy8gc28gdGhlcmUncyBubyBuZWVkIHRvIHJlY2FsY3VsYXRlIGJib3hlc1xuICAgICAgICAgICAgY2xpcHBlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogc2xpY2VzLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgdGFnczogZmVhdHVyZXNbaV0udGFncyB8fCBudWxsLFxuICAgICAgICAgICAgICAgIG1pbjogZmVhdHVyZS5taW4sXG4gICAgICAgICAgICAgICAgbWF4OiBmZWF0dXJlLm1heFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xpcHBlZC5sZW5ndGggPyBjbGlwcGVkIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gY2xpcFBvaW50cyhnZW9tZXRyeSwgazEsIGsyLCBheGlzKSB7XG4gICAgdmFyIHNsaWNlID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhID0gZ2VvbWV0cnlbaV0sXG4gICAgICAgICAgICBhayA9IGFbYXhpc107XG5cbiAgICAgICAgaWYgKGFrID49IGsxICYmIGFrIDw9IGsyKSBzbGljZS5wdXNoKGEpO1xuICAgIH1cbiAgICByZXR1cm4gc2xpY2U7XG59XG5cbmZ1bmN0aW9uIGNsaXBHZW9tZXRyeShnZW9tZXRyeSwgazEsIGsyLCBheGlzLCBpbnRlcnNlY3QsIGNsb3NlZCkge1xuXG4gICAgdmFyIHNsaWNlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyeS5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIHZhciBhayA9IDAsXG4gICAgICAgICAgICBiayA9IDAsXG4gICAgICAgICAgICBiID0gbnVsbCxcbiAgICAgICAgICAgIHBvaW50cyA9IGdlb21ldHJ5W2ldLFxuICAgICAgICAgICAgYXJlYSA9IHBvaW50cy5hcmVhLFxuICAgICAgICAgICAgZGlzdCA9IHBvaW50cy5kaXN0LFxuICAgICAgICAgICAgbGVuID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGEsIGosIGxhc3Q7XG5cbiAgICAgICAgdmFyIHNsaWNlID0gW107XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbiAtIDE7IGorKykge1xuICAgICAgICAgICAgYSA9IGIgfHwgcG9pbnRzW2pdO1xuICAgICAgICAgICAgYiA9IHBvaW50c1tqICsgMV07XG4gICAgICAgICAgICBhayA9IGJrIHx8IGFbYXhpc107XG4gICAgICAgICAgICBiayA9IGJbYXhpc107XG5cbiAgICAgICAgICAgIGlmIChhayA8IGsxKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoKGJrID4gazIpKSB7IC8vIC0tLXwtLS0tLXwtLT5cbiAgICAgICAgICAgICAgICAgICAgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazEpLCBpbnRlcnNlY3QoYSwgYiwgazIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHNsaWNlID0gbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJrID49IGsxKSBzbGljZS5wdXNoKGludGVyc2VjdChhLCBiLCBrMSkpOyAvLyAtLS18LS0+ICB8XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWsgPiBrMikge1xuXG4gICAgICAgICAgICAgICAgaWYgKChiayA8IGsxKSkgeyAvLyA8LS18LS0tLS18LS0tXG4gICAgICAgICAgICAgICAgICAgIHNsaWNlLnB1c2goaW50ZXJzZWN0KGEsIGIsIGsyKSwgaW50ZXJzZWN0KGEsIGIsIGsxKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKSBzbGljZSA9IG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiayA8PSBrMikgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazIpKTsgLy8gfCAgPC0tfC0tLVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgc2xpY2UucHVzaChhKTtcblxuICAgICAgICAgICAgICAgIGlmIChiayA8IGsxKSB7IC8vIDwtLXwtLS0gIHxcbiAgICAgICAgICAgICAgICAgICAgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazEpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHNsaWNlID0gbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJrID4gazIpIHsgLy8gfCAgLS0tfC0tPlxuICAgICAgICAgICAgICAgICAgICBzbGljZS5wdXNoKGludGVyc2VjdChhLCBiLCBrMikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNsb3NlZCkgc2xpY2UgPSBuZXdTbGljZShzbGljZXMsIHNsaWNlLCBhcmVhLCBkaXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gfCAtLT4gfFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRoZSBsYXN0IHBvaW50XG4gICAgICAgIGEgPSBwb2ludHNbbGVuIC0gMV07XG4gICAgICAgIGFrID0gYVtheGlzXTtcbiAgICAgICAgaWYgKGFrID49IGsxICYmIGFrIDw9IGsyKSBzbGljZS5wdXNoKGEpO1xuXG4gICAgICAgIC8vIGNsb3NlIHRoZSBwb2x5Z29uIGlmIGl0cyBlbmRwb2ludHMgYXJlIG5vdCB0aGUgc2FtZSBhZnRlciBjbGlwcGluZ1xuXG4gICAgICAgIGxhc3QgPSBzbGljZVtzbGljZS5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGNsb3NlZCAmJiBsYXN0ICYmIChzbGljZVswXVswXSAhPT0gbGFzdFswXSB8fCBzbGljZVswXVsxXSAhPT0gbGFzdFsxXSkpIHNsaWNlLnB1c2goc2xpY2VbMF0pO1xuXG4gICAgICAgIC8vIGFkZCB0aGUgZmluYWwgc2xpY2VcbiAgICAgICAgbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNsaWNlcztcbn1cblxuZnVuY3Rpb24gbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCkge1xuICAgIGlmIChzbGljZS5sZW5ndGgpIHtcbiAgICAgICAgLy8gd2UgZG9uJ3QgcmVjYWxjdWxhdGUgdGhlIGFyZWEvbGVuZ3RoIG9mIHRoZSB1bmNsaXBwZWQgZ2VvbWV0cnkgYmVjYXVzZSB0aGUgY2FzZSB3aGVyZSBpdCBnb2VzXG4gICAgICAgIC8vIGJlbG93IHRoZSB2aXNpYmlsaXR5IHRocmVzaG9sZCBhcyBhIHJlc3VsdCBvZiBjbGlwcGluZyBpcyByYXJlLCBzbyB3ZSBhdm9pZCBkb2luZyB1bm5lY2Vzc2FyeSB3b3JrXG4gICAgICAgIHNsaWNlLmFyZWEgPSBhcmVhO1xuICAgICAgICBzbGljZS5kaXN0ID0gZGlzdDtcblxuICAgICAgICBzbGljZXMucHVzaChzbGljZSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBjb252ZXJ0O1xuXG52YXIgc2ltcGxpZnkgPSByZXF1aXJlKCcuL3NpbXBsaWZ5Jyk7XG5cbi8vIGNvbnZlcnRzIEdlb0pTT04gZmVhdHVyZSBpbnRvIGFuIGludGVybWVkaWF0ZSBwcm9qZWN0ZWQgSlNPTiB2ZWN0b3IgZm9ybWF0IHdpdGggc2ltcGxpZmljYXRpb24gZGF0YVxuXG5mdW5jdGlvbiBjb252ZXJ0KGRhdGEsIHRvbGVyYW5jZSkge1xuICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuXG4gICAgaWYgKGRhdGEudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnZlcnRGZWF0dXJlKGZlYXR1cmVzLCBkYXRhLmZlYXR1cmVzW2ldLCB0b2xlcmFuY2UpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdGZWF0dXJlJykge1xuICAgICAgICBjb252ZXJ0RmVhdHVyZShmZWF0dXJlcywgZGF0YSwgdG9sZXJhbmNlKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNpbmdsZSBnZW9tZXRyeSBvciBhIGdlb21ldHJ5IGNvbGxlY3Rpb25cbiAgICAgICAgY29udmVydEZlYXR1cmUoZmVhdHVyZXMsIHtnZW9tZXRyeTogZGF0YX0sIHRvbGVyYW5jZSk7XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlcztcbn1cblxuZnVuY3Rpb24gY29udmVydEZlYXR1cmUoZmVhdHVyZXMsIGZlYXR1cmUsIHRvbGVyYW5jZSkge1xuICAgIHZhciBnZW9tID0gZmVhdHVyZS5nZW9tZXRyeSxcbiAgICAgICAgdHlwZSA9IGdlb20udHlwZSxcbiAgICAgICAgY29vcmRzID0gZ2VvbS5jb29yZGluYXRlcyxcbiAgICAgICAgdGFncyA9IGZlYXR1cmUucHJvcGVydGllcyxcbiAgICAgICAgaSwgaiwgcmluZ3M7XG5cbiAgICBpZiAodHlwZSA9PT0gJ1BvaW50Jykge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGNyZWF0ZSh0YWdzLCAxLCBbcHJvamVjdFBvaW50KGNvb3JkcyldKSk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGNyZWF0ZSh0YWdzLCAxLCBwcm9qZWN0KGNvb3JkcykpKTtcblxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goY3JlYXRlKHRhZ3MsIDIsIFtwcm9qZWN0KGNvb3JkcywgdG9sZXJhbmNlKV0pKTtcblxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ011bHRpTGluZVN0cmluZycgfHwgdHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIHJpbmdzID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJpbmdzLnB1c2gocHJvamVjdChjb29yZHNbaV0sIHRvbGVyYW5jZSkpO1xuICAgICAgICB9XG4gICAgICAgIGZlYXR1cmVzLnB1c2goY3JlYXRlKHRhZ3MsIHR5cGUgPT09ICdQb2x5Z29uJyA/IDMgOiAyLCByaW5ncykpO1xuXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICByaW5ncyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29vcmRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgcmluZ3MucHVzaChwcm9qZWN0KGNvb3Jkc1tpXVtqXSwgdG9sZXJhbmNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmVhdHVyZXMucHVzaChjcmVhdGUodGFncywgMywgcmluZ3MpKTtcblxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdlb20uZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29udmVydEZlYXR1cmUoZmVhdHVyZXMsIHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogZ2VvbS5nZW9tZXRyaWVzW2ldLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHRhZ3NcbiAgICAgICAgICAgIH0sIHRvbGVyYW5jZSk7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBpcyBub3QgYSB2YWxpZCBHZW9KU09OIG9iamVjdC4nKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZSh0YWdzLCB0eXBlLCBnZW9tZXRyeSkge1xuICAgIHZhciBmZWF0dXJlID0ge1xuICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHRhZ3M6IHRhZ3MgfHwgbnVsbCxcbiAgICAgICAgbWluOiBbMiwgMV0sIC8vIGluaXRpYWwgYmJveCB2YWx1ZXM7XG4gICAgICAgIG1heDogWy0xLCAwXSAgLy8gbm90ZSB0aGF0IGNvb3JkcyBhcmUgdXN1YWxseSBpbiBbMC4uMV0gcmFuZ2VcbiAgICB9O1xuICAgIGNhbGNCQm94KGZlYXR1cmUpO1xuICAgIHJldHVybiBmZWF0dXJlO1xufVxuXG5mdW5jdGlvbiBwcm9qZWN0KGxvbmxhdHMsIHRvbGVyYW5jZSkge1xuICAgIHZhciBwcm9qZWN0ZWQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvbmxhdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJvamVjdGVkLnB1c2gocHJvamVjdFBvaW50KGxvbmxhdHNbaV0pKTtcbiAgICB9XG4gICAgaWYgKHRvbGVyYW5jZSkge1xuICAgICAgICBzaW1wbGlmeShwcm9qZWN0ZWQsIHRvbGVyYW5jZSk7XG4gICAgICAgIGNhbGNTaXplKHByb2plY3RlZCk7XG4gICAgfVxuICAgIHJldHVybiBwcm9qZWN0ZWQ7XG59XG5cbmZ1bmN0aW9uIHByb2plY3RQb2ludChwKSB7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luKHBbMV0gKiBNYXRoLlBJIC8gMTgwKSxcbiAgICAgICAgeCA9IChwWzBdIC8gMzYwICsgMC41KSxcbiAgICAgICAgeSA9ICgwLjUgLSAwLjI1ICogTWF0aC5sb2coKDEgKyBzaW4pIC8gKDEgLSBzaW4pKSAvIE1hdGguUEkpO1xuXG4gICAgeSA9IHkgPCAtMSA/IC0xIDpcbiAgICAgICAgeSA+IDEgPyAxIDogeTtcblxuICAgIHJldHVybiBbeCwgeSwgMF07XG59XG5cbi8vIGNhbGN1bGF0ZSBhcmVhIGFuZCBsZW5ndGggb2YgdGhlIHBvbHlcbmZ1bmN0aW9uIGNhbGNTaXplKHBvaW50cykge1xuICAgIHZhciBhcmVhID0gMCxcbiAgICAgICAgZGlzdCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgYSwgYjsgaSA8IHBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgYSA9IGIgfHwgcG9pbnRzW2ldO1xuICAgICAgICBiID0gcG9pbnRzW2kgKyAxXTtcblxuICAgICAgICBhcmVhICs9IGFbMF0gKiBiWzFdIC0gYlswXSAqIGFbMV07XG5cbiAgICAgICAgLy8gdXNlIE1hbmhhdHRhbiBkaXN0YW5jZSBpbnN0ZWFkIG9mIEV1Y2xpZGlhbiBvbmUgdG8gYXZvaWQgZXhwZW5zaXZlIHNxdWFyZSByb290IGNvbXB1dGF0aW9uXG4gICAgICAgIGRpc3QgKz0gTWF0aC5hYnMoYlswXSAtIGFbMF0pICsgTWF0aC5hYnMoYlsxXSAtIGFbMV0pO1xuICAgIH1cbiAgICBwb2ludHMuYXJlYSA9IE1hdGguYWJzKGFyZWEgLyAyKTtcbiAgICBwb2ludHMuZGlzdCA9IGRpc3Q7XG59XG5cbi8vIGNhbGN1bGF0ZSB0aGUgZmVhdHVyZSBib3VuZGluZyBib3ggZm9yIGZhc3RlciBjbGlwcGluZyBsYXRlclxuZnVuY3Rpb24gY2FsY0JCb3goZmVhdHVyZSkge1xuICAgIHZhciBnZW9tZXRyeSA9IGZlYXR1cmUuZ2VvbWV0cnksXG4gICAgICAgIG1pbiA9IGZlYXR1cmUubWluLFxuICAgICAgICBtYXggPSBmZWF0dXJlLm1heDtcblxuICAgIGlmIChmZWF0dXJlLnR5cGUgPT09IDEpIGNhbGNSaW5nQkJveChtaW4sIG1heCwgZ2VvbWV0cnkpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyeS5sZW5ndGg7IGkrKykgY2FsY1JpbmdCQm94KG1pbiwgbWF4LCBnZW9tZXRyeVtpXSk7XG5cbiAgICByZXR1cm4gZmVhdHVyZTtcbn1cblxuZnVuY3Rpb24gY2FsY1JpbmdCQm94KG1pbiwgbWF4LCBwb2ludHMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwID0gcG9pbnRzW2ldO1xuICAgICAgICBtaW5bMF0gPSBNYXRoLm1pbihwWzBdLCBtaW5bMF0pO1xuICAgICAgICBtYXhbMF0gPSBNYXRoLm1heChwWzBdLCBtYXhbMF0pO1xuICAgICAgICBtaW5bMV0gPSBNYXRoLm1pbihwWzFdLCBtaW5bMV0pO1xuICAgICAgICBtYXhbMV0gPSBNYXRoLm1heChwWzFdLCBtYXhbMV0pO1xuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBnZW9qc29udnQ7XG5cbnZhciBjb252ZXJ0ID0gcmVxdWlyZSgnLi9jb252ZXJ0JyksIC8vIEdlb0pTT04gY29udmVyc2lvbiBhbmQgcHJlcHJvY2Vzc2luZ1xuICAgIGNsaXAgPSByZXF1aXJlKCcuL2NsaXAnKSwgICAgICAgLy8gc3RyaXBlIGNsaXBwaW5nIGFsZ29yaXRobVxuICAgIHdyYXAgPSByZXF1aXJlKCcuL3dyYXAnKSwgICAgICAgLy8gZGF0ZSBsaW5lIHByb2Nlc3NpbmdcbiAgICBjcmVhdGVUaWxlID0gcmVxdWlyZSgnLi90aWxlJyk7IC8vIGZpbmFsIHNpbXBsaWZpZWQgdGlsZSBnZW5lcmF0aW9uXG5cblxuZnVuY3Rpb24gZ2VvanNvbnZ0KGRhdGEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEdlb0pTT05WVChkYXRhLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gR2VvSlNPTlZUKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zID0gZXh0ZW5kKE9iamVjdC5jcmVhdGUodGhpcy5vcHRpb25zKSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuXG4gICAgaWYgKGRlYnVnKSBjb25zb2xlLnRpbWUoJ3ByZXByb2Nlc3MgZGF0YScpO1xuXG4gICAgdmFyIHoyID0gMSA8PCBvcHRpb25zLm1heFpvb20sIC8vIDJeelxuICAgICAgICBmZWF0dXJlcyA9IGNvbnZlcnQoZGF0YSwgb3B0aW9ucy50b2xlcmFuY2UgLyAoejIgKiBvcHRpb25zLmV4dGVudCkpO1xuXG4gICAgdGhpcy50aWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUudGltZUVuZCgncHJlcHJvY2VzcyBkYXRhJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdpbmRleDogbWF4Wm9vbTogJWQsIG1heFBvaW50czogJWQnLCBvcHRpb25zLmluZGV4TWF4Wm9vbSwgb3B0aW9ucy5pbmRleE1heFBvaW50cyk7XG4gICAgICAgIGNvbnNvbGUudGltZSgnZ2VuZXJhdGUgdGlsZXMnKTtcbiAgICAgICAgdGhpcy5zdGF0cyA9IHt9O1xuICAgICAgICB0aGlzLnRvdGFsID0gMDtcbiAgICB9XG5cbiAgICBmZWF0dXJlcyA9IHdyYXAoZmVhdHVyZXMsIG9wdGlvbnMuYnVmZmVyIC8gb3B0aW9ucy5leHRlbnQsIGludGVyc2VjdFgpO1xuXG4gICAgLy8gc3RhcnQgc2xpY2luZyBmcm9tIHRoZSB0b3AgdGlsZSBkb3duXG4gICAgdGhpcy5zcGxpdFRpbGUoZmVhdHVyZXMsIDAsIDAsIDApO1xuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdmZWF0dXJlczogJWQsIHBvaW50czogJWQnLCB0aGlzLnRpbGVzWzBdLm51bUZlYXR1cmVzLCB0aGlzLnRpbGVzWzBdLm51bVBvaW50cyk7XG4gICAgICAgIGNvbnNvbGUudGltZUVuZCgnZ2VuZXJhdGUgdGlsZXMnKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3RpbGVzIGdlbmVyYXRlZDonLCB0aGlzLnRvdGFsLCBKU09OLnN0cmluZ2lmeSh0aGlzLnN0YXRzKSk7XG4gICAgfVxufVxuXG5HZW9KU09OVlQucHJvdG90eXBlLm9wdGlvbnMgPSB7XG4gICAgbWF4Wm9vbTogMTQsICAgICAgICAgICAgLy8gbWF4IHpvb20gdG8gcHJlc2VydmUgZGV0YWlsIG9uXG4gICAgaW5kZXhNYXhab29tOiA1LCAgICAgICAgLy8gbWF4IHpvb20gaW4gdGhlIHRpbGUgaW5kZXhcbiAgICBpbmRleE1heFBvaW50czogMTAwMDAwLCAvLyBtYXggbnVtYmVyIG9mIHBvaW50cyBwZXIgdGlsZSBpbiB0aGUgdGlsZSBpbmRleFxuICAgIHRvbGVyYW5jZTogMywgICAgICAgICAgIC8vIHNpbXBsaWZpY2F0aW9uIHRvbGVyYW5jZSAoaGlnaGVyIG1lYW5zIHNpbXBsZXIpXG4gICAgZXh0ZW50OiA0MDk2LCAgICAgICAgICAgLy8gdGlsZSBleHRlbnRcbiAgICBidWZmZXI6IDY0LCAgICAgICAgICAgICAvLyB0aWxlIGJ1ZmZlciBvbiBlYWNoIHNpZGVcbiAgICBkZWJ1ZzogMCAgICAgICAgICAgICAgICAvLyBsb2dnaW5nIGxldmVsICgwLCAxIG9yIDIpXG59O1xuXG5HZW9KU09OVlQucHJvdG90eXBlLnNwbGl0VGlsZSA9IGZ1bmN0aW9uIChmZWF0dXJlcywgeiwgeCwgeSwgY3osIGN4LCBjeSkge1xuXG4gICAgdmFyIHN0YWNrID0gW2ZlYXR1cmVzLCB6LCB4LCB5XSxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZGVidWcgPSBvcHRpb25zLmRlYnVnLFxuICAgICAgICBleHRlbnQgPSBvcHRpb25zLmV4dGVudCxcbiAgICAgICAgYnVmZmVyID0gb3B0aW9ucy5idWZmZXI7XG5cbiAgICAvLyBhdm9pZCByZWN1cnNpb24gYnkgdXNpbmcgYSBwcm9jZXNzaW5nIHF1ZXVlXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICBmZWF0dXJlcyA9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgIHogPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICB4ID0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgeSA9IHN0YWNrLnNoaWZ0KCk7XG5cbiAgICAgICAgdmFyIHoyID0gMSA8PCB6LFxuICAgICAgICAgICAgaWQgPSB0b0lEKHosIHgsIHkpLFxuICAgICAgICAgICAgdGlsZSA9IHRoaXMudGlsZXNbaWRdLFxuICAgICAgICAgICAgdGlsZVRvbGVyYW5jZSA9IHogPT09IG9wdGlvbnMubWF4Wm9vbSA/IDAgOiBvcHRpb25zLnRvbGVyYW5jZSAvICh6MiAqIGV4dGVudCk7XG5cbiAgICAgICAgaWYgKCF0aWxlKSB7XG4gICAgICAgICAgICBpZiAoZGVidWcgPiAxKSBjb25zb2xlLnRpbWUoJ2NyZWF0aW9uJyk7XG5cbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLnRpbGVzW2lkXSA9IGNyZWF0ZVRpbGUoZmVhdHVyZXMsIHoyLCB4LCB5LCB0aWxlVG9sZXJhbmNlLCB6ID09PSBvcHRpb25zLm1heFpvb20pO1xuXG4gICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVidWcgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd0aWxlIHolZC0lZC0lZCAoZmVhdHVyZXM6ICVkLCBwb2ludHM6ICVkLCBzaW1wbGlmaWVkOiAlZCknLFxuICAgICAgICAgICAgICAgICAgICAgICAgeiwgeCwgeSwgdGlsZS5udW1GZWF0dXJlcywgdGlsZS5udW1Qb2ludHMsIHRpbGUubnVtU2ltcGxpZmllZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUudGltZUVuZCgnY3JlYXRpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9ICd6JyArIHo7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0c1trZXldID0gKHRoaXMuc3RhdHNba2V5XSB8fCAwKSArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy50b3RhbCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgZ2VvbWV0cnkgaW4gdGlsZSBzbyB0aGF0IHdlIGNhbiBkcmlsbCBkb3duIGxhdGVyIGlmIHdlIHN0b3Agbm93XG4gICAgICAgIHRpbGUuc291cmNlID0gZmVhdHVyZXM7XG5cbiAgICAgICAgLy8gc3RvcCB0aWxpbmcgaWYgdGhlIHRpbGUgaXMgZGVnZW5lcmF0ZVxuICAgICAgICBpZiAoaXNDbGlwcGVkU3F1YXJlKHRpbGUuZmVhdHVyZXMsIGV4dGVudCwgYnVmZmVyKSkgY29udGludWU7XG5cbiAgICAgICAgLy8gaWYgaXQncyB0aGUgZmlyc3QtcGFzcyB0aWxpbmdcbiAgICAgICAgaWYgKCFjeikge1xuICAgICAgICAgICAgLy8gc3RvcCB0aWxpbmcgaWYgd2UgcmVhY2hlZCBtYXggem9vbSwgb3IgaWYgdGhlIHRpbGUgaXMgdG9vIHNpbXBsZVxuICAgICAgICAgICAgaWYgKHogPT09IG9wdGlvbnMuaW5kZXhNYXhab29tIHx8IHRpbGUubnVtUG9pbnRzIDw9IG9wdGlvbnMuaW5kZXhNYXhQb2ludHMpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIGlmIGEgZHJpbGxkb3duIHRvIGEgc3BlY2lmaWMgdGlsZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc3RvcCB0aWxpbmcgaWYgd2UgcmVhY2hlZCBiYXNlIHpvb20gb3Igb3VyIHRhcmdldCB0aWxlIHpvb21cbiAgICAgICAgICAgIGlmICh6ID09PSBvcHRpb25zLm1heFpvb20gfHwgeiA9PT0gY3opIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBzdG9wIHRpbGluZyBpZiBpdCdzIG5vdCBhbiBhbmNlc3RvciBvZiB0aGUgdGFyZ2V0IHRpbGVcbiAgICAgICAgICAgIHZhciBtID0gMSA8PCAoY3ogLSB6KTtcbiAgICAgICAgICAgIGlmICh4ICE9PSBNYXRoLmZsb29yKGN4IC8gbSkgJiYgeSAhPT0gTWF0aC5mbG9vcihjeSAvIG0pKSBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIHNsaWNlIGZ1cnRoZXIgZG93biwgbm8gbmVlZCB0byBrZWVwIHNvdXJjZSBnZW9tZXRyeVxuICAgICAgICB0aWxlLnNvdXJjZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS50aW1lKCdjbGlwcGluZycpO1xuXG4gICAgICAgIC8vIHZhbHVlcyB3ZSdsbCB1c2UgZm9yIGNsaXBwaW5nXG4gICAgICAgIHZhciBrMSA9IDAuNSAqIGJ1ZmZlciAvIGV4dGVudCxcbiAgICAgICAgICAgIGsyID0gMC41IC0gazEsXG4gICAgICAgICAgICBrMyA9IDAuNSArIGsxLFxuICAgICAgICAgICAgazQgPSAxICsgazEsXG4gICAgICAgICAgICB0bCwgYmwsIHRyLCBiciwgbGVmdCwgcmlnaHQ7XG5cbiAgICAgICAgdGwgPSBibCA9IHRyID0gYnIgPSBudWxsO1xuXG4gICAgICAgIGxlZnQgID0gY2xpcChmZWF0dXJlcywgejIsIHggLSBrMSwgeCArIGszLCAwLCBpbnRlcnNlY3RYLCB0aWxlLm1pblswXSwgdGlsZS5tYXhbMF0pO1xuICAgICAgICByaWdodCA9IGNsaXAoZmVhdHVyZXMsIHoyLCB4ICsgazIsIHggKyBrNCwgMCwgaW50ZXJzZWN0WCwgdGlsZS5taW5bMF0sIHRpbGUubWF4WzBdKTtcblxuICAgICAgICBpZiAobGVmdCkge1xuICAgICAgICAgICAgdGwgPSBjbGlwKGxlZnQsIHoyLCB5IC0gazEsIHkgKyBrMywgMSwgaW50ZXJzZWN0WSwgdGlsZS5taW5bMV0sIHRpbGUubWF4WzFdKTtcbiAgICAgICAgICAgIGJsID0gY2xpcChsZWZ0LCB6MiwgeSArIGsyLCB5ICsgazQsIDEsIGludGVyc2VjdFksIHRpbGUubWluWzFdLCB0aWxlLm1heFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgICAgIHRyID0gY2xpcChyaWdodCwgejIsIHkgLSBrMSwgeSArIGszLCAxLCBpbnRlcnNlY3RZLCB0aWxlLm1pblsxXSwgdGlsZS5tYXhbMV0pO1xuICAgICAgICAgICAgYnIgPSBjbGlwKHJpZ2h0LCB6MiwgeSArIGsyLCB5ICsgazQsIDEsIGludGVyc2VjdFksIHRpbGUubWluWzFdLCB0aWxlLm1heFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVidWcgPiAxKSBjb25zb2xlLnRpbWVFbmQoJ2NsaXBwaW5nJyk7XG5cbiAgICAgICAgaWYgKHRsKSBzdGFjay5wdXNoKHRsLCB6ICsgMSwgeCAqIDIsICAgICB5ICogMik7XG4gICAgICAgIGlmIChibCkgc3RhY2sucHVzaChibCwgeiArIDEsIHggKiAyLCAgICAgeSAqIDIgKyAxKTtcbiAgICAgICAgaWYgKHRyKSBzdGFjay5wdXNoKHRyLCB6ICsgMSwgeCAqIDIgKyAxLCB5ICogMik7XG4gICAgICAgIGlmIChicikgc3RhY2sucHVzaChiciwgeiArIDEsIHggKiAyICsgMSwgeSAqIDIgKyAxKTtcbiAgICB9XG59O1xuXG5HZW9KU09OVlQucHJvdG90eXBlLmdldFRpbGUgPSBmdW5jdGlvbiAoeiwgeCwgeSkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBleHRlbnQgPSBvcHRpb25zLmV4dGVudCxcbiAgICAgICAgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuXG4gICAgdmFyIHoyID0gMSA8PCB6O1xuICAgIHggPSAoKHggJSB6MikgKyB6MikgJSB6MjsgLy8gd3JhcCB0aWxlIHggY29vcmRpbmF0ZVxuXG4gICAgdmFyIGlkID0gdG9JRCh6LCB4LCB5KTtcbiAgICBpZiAodGhpcy50aWxlc1tpZF0pIHJldHVybiB0cmFuc2Zvcm1UaWxlKHRoaXMudGlsZXNbaWRdLCBleHRlbnQpO1xuXG4gICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS5sb2coJ2RyaWxsaW5nIGRvd24gdG8geiVkLSVkLSVkJywgeiwgeCwgeSk7XG5cbiAgICB2YXIgejAgPSB6LFxuICAgICAgICB4MCA9IHgsXG4gICAgICAgIHkwID0geSxcbiAgICAgICAgcGFyZW50O1xuXG4gICAgd2hpbGUgKCFwYXJlbnQgJiYgejAgPiAwKSB7XG4gICAgICAgIHowLS07XG4gICAgICAgIHgwID0gTWF0aC5mbG9vcih4MCAvIDIpO1xuICAgICAgICB5MCA9IE1hdGguZmxvb3IoeTAgLyAyKTtcbiAgICAgICAgcGFyZW50ID0gdGhpcy50aWxlc1t0b0lEKHowLCB4MCwgeTApXTtcbiAgICB9XG5cbiAgICBpZiAoZGVidWcgPiAxKSBjb25zb2xlLmxvZygnZm91bmQgcGFyZW50IHRpbGUgeiVkLSVkLSVkJywgejAsIHgwLCB5MCk7XG5cbiAgICAvLyBpZiB3ZSBmb3VuZCBhIHBhcmVudCB0aWxlIGNvbnRhaW5pbmcgdGhlIG9yaWdpbmFsIGdlb21ldHJ5LCB3ZSBjYW4gZHJpbGwgZG93biBmcm9tIGl0XG4gICAgaWYgKHBhcmVudC5zb3VyY2UpIHtcbiAgICAgICAgaWYgKGlzQ2xpcHBlZFNxdWFyZShwYXJlbnQuZmVhdHVyZXMsIG9wdGlvbnMuZXh0ZW50LCBvcHRpb25zLmJ1ZmZlcikpIHJldHVybiB0cmFuc2Zvcm1UaWxlKHBhcmVudCwgZXh0ZW50KTtcblxuICAgICAgICBpZiAoZGVidWcgPiAxKSBjb25zb2xlLnRpbWUoJ2RyaWxsaW5nIGRvd24nKTtcbiAgICAgICAgdGhpcy5zcGxpdFRpbGUocGFyZW50LnNvdXJjZSwgejAsIHgwLCB5MCwgeiwgeCwgeSk7XG4gICAgICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUudGltZUVuZCgnZHJpbGxpbmcgZG93bicpO1xuICAgIH1cblxuICAgIHJldHVybiB0cmFuc2Zvcm1UaWxlKHRoaXMudGlsZXNbaWRdLCBleHRlbnQpO1xufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtVGlsZSh0aWxlLCBleHRlbnQpIHtcbiAgICBpZiAoIXRpbGUgfHwgdGlsZS50cmFuc2Zvcm1lZCkgcmV0dXJuIHRpbGU7XG5cbiAgICB2YXIgejIgPSB0aWxlLnoyLFxuICAgICAgICB0eCA9IHRpbGUueCxcbiAgICAgICAgdHkgPSB0aWxlLnksXG4gICAgICAgIGksIGosIGs7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGlsZS5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IHRpbGUuZmVhdHVyZXNbaV0sXG4gICAgICAgICAgICBnZW9tID0gZmVhdHVyZS5nZW9tZXRyeSxcbiAgICAgICAgICAgIHR5cGUgPSBmZWF0dXJlLnR5cGU7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnZW9tLmxlbmd0aDsgaisrKSBnZW9tW2pdID0gdHJhbnNmb3JtUG9pbnQoZ2VvbVtqXSwgZXh0ZW50LCB6MiwgdHgsIHR5KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdlb20ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmluZyA9IGdlb21bal07XG4gICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHJpbmcubGVuZ3RoOyBrKyspIHJpbmdba10gPSB0cmFuc2Zvcm1Qb2ludChyaW5nW2tdLCBleHRlbnQsIHoyLCB0eCwgdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGlsZS50cmFuc2Zvcm1lZCA9IHRydWU7XG5cbiAgICByZXR1cm4gdGlsZTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnQocCwgZXh0ZW50LCB6MiwgdHgsIHR5KSB7XG4gICAgdmFyIHggPSBNYXRoLnJvdW5kKGV4dGVudCAqIChwWzBdICogejIgLSB0eCkpLFxuICAgICAgICB5ID0gTWF0aC5yb3VuZChleHRlbnQgKiAocFsxXSAqIHoyIC0gdHkpKTtcbiAgICByZXR1cm4gW3gsIHldO1xufVxuXG4vLyBjaGVja3Mgd2hldGhlciBhIHRpbGUgaXMgYSB3aG9sZS1hcmVhIGZpbGwgYWZ0ZXIgY2xpcHBpbmc7IGlmIGl0IGlzLCB0aGVyZSdzIG5vIHNlbnNlIHNsaWNpbmcgaXQgZnVydGhlclxuZnVuY3Rpb24gaXNDbGlwcGVkU3F1YXJlKGZlYXR1cmVzLCBleHRlbnQsIGJ1ZmZlcikge1xuICAgIGlmIChmZWF0dXJlcy5sZW5ndGggIT09IDEpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbMF07XG4gICAgaWYgKGZlYXR1cmUudHlwZSAhPT0gMyB8fCBmZWF0dXJlLmdlb21ldHJ5Lmxlbmd0aCA+IDEpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZS5nZW9tZXRyeVswXS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcCA9IGZlYXR1cmUuZ2VvbWV0cnlbMF1baV07XG4gICAgICAgIGlmICgocFswXSAhPT0gLWJ1ZmZlciAmJiBwWzBdICE9PSBleHRlbnQgKyBidWZmZXIpIHx8XG4gICAgICAgICAgICAocFsxXSAhPT0gLWJ1ZmZlciAmJiBwWzFdICE9PSBleHRlbnQgKyBidWZmZXIpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB0b0lEKHosIHgsIHkpIHtcbiAgICByZXR1cm4gKCgoMSA8PCB6KSAqIHkgKyB4KSAqIDMyKSArIHo7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdFgoYSwgYiwgeCkge1xuICAgIHJldHVybiBbeCwgKHggLSBhWzBdKSAqIChiWzFdIC0gYVsxXSkgLyAoYlswXSAtIGFbMF0pICsgYVsxXSwgMV07XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RZKGEsIGIsIHkpIHtcbiAgICByZXR1cm4gWyh5IC0gYVsxXSkgKiAoYlswXSAtIGFbMF0pIC8gKGJbMV0gLSBhWzFdKSArIGFbMF0sIHksIDFdO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjKSB7XG4gICAgZm9yICh2YXIgaSBpbiBzcmMpIGRlc3RbaV0gPSBzcmNbaV07XG4gICAgcmV0dXJuIGRlc3Q7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gc2ltcGxpZnk7XG5cbi8vIGNhbGN1bGF0ZSBzaW1wbGlmaWNhdGlvbiBkYXRhIHVzaW5nIG9wdGltaXplZCBEb3VnbGFzLVBldWNrZXIgYWxnb3JpdGhtXG5cbmZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50cywgdG9sZXJhbmNlKSB7XG5cbiAgICB2YXIgc3FUb2xlcmFuY2UgPSB0b2xlcmFuY2UgKiB0b2xlcmFuY2UsXG4gICAgICAgIGxlbiA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIGZpcnN0ID0gMCxcbiAgICAgICAgbGFzdCA9IGxlbiAtIDEsXG4gICAgICAgIHN0YWNrID0gW10sXG4gICAgICAgIGksIG1heFNxRGlzdCwgc3FEaXN0LCBpbmRleDtcblxuICAgIC8vIGFsd2F5cyByZXRhaW4gdGhlIGVuZHBvaW50cyAoMSBpcyB0aGUgbWF4IHZhbHVlKVxuICAgIHBvaW50c1tmaXJzdF1bMl0gPSAxO1xuICAgIHBvaW50c1tsYXN0XVsyXSA9IDE7XG5cbiAgICAvLyBhdm9pZCByZWN1cnNpb24gYnkgdXNpbmcgYSBzdGFja1xuICAgIHdoaWxlIChsYXN0KSB7XG5cbiAgICAgICAgbWF4U3FEaXN0ID0gMDtcblxuICAgICAgICBmb3IgKGkgPSBmaXJzdCArIDE7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgICAgICAgIHNxRGlzdCA9IGdldFNxU2VnRGlzdChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSk7XG5cbiAgICAgICAgICAgIGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgbWF4U3FEaXN0ID0gc3FEaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICBwb2ludHNbaW5kZXhdWzJdID0gbWF4U3FEaXN0OyAvLyBzYXZlIHRoZSBwb2ludCBpbXBvcnRhbmNlIGluIHNxdWFyZWQgcGl4ZWxzIGFzIGEgeiBjb29yZGluYXRlXG4gICAgICAgICAgICBzdGFjay5wdXNoKGZpcnN0KTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgZmlyc3QgPSBpbmRleDtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgZmlyc3QgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gc3F1YXJlIGRpc3RhbmNlIGZyb20gYSBwb2ludCB0byBhIHNlZ21lbnRcbmZ1bmN0aW9uIGdldFNxU2VnRGlzdChwLCBhLCBiKSB7XG5cbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSxcbiAgICAgICAgcHggPSBwWzBdLCBweSA9IHBbMV0sXG4gICAgICAgIGR4ID0gYnggLSB4LFxuICAgICAgICBkeSA9IGJ5IC0geTtcblxuICAgIGlmIChkeCAhPT0gMCB8fCBkeSAhPT0gMCkge1xuXG4gICAgICAgIHZhciB0ID0gKChweCAtIHgpICogZHggKyAocHkgLSB5KSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgaWYgKHQgPiAxKSB7XG4gICAgICAgICAgICB4ID0gYng7XG4gICAgICAgICAgICB5ID0gYnk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0ID4gMCkge1xuICAgICAgICAgICAgeCArPSBkeCAqIHQ7XG4gICAgICAgICAgICB5ICs9IGR5ICogdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGR4ID0gcHggLSB4O1xuICAgIGR5ID0gcHkgLSB5O1xuXG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVRpbGU7XG5cbmZ1bmN0aW9uIGNyZWF0ZVRpbGUoZmVhdHVyZXMsIHoyLCB0eCwgdHksIHRvbGVyYW5jZSwgbm9TaW1wbGlmeSkge1xuICAgIHZhciB0aWxlID0ge1xuICAgICAgICBmZWF0dXJlczogW10sXG4gICAgICAgIG51bVBvaW50czogMCxcbiAgICAgICAgbnVtU2ltcGxpZmllZDogMCxcbiAgICAgICAgbnVtRmVhdHVyZXM6IDAsXG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgeDogdHgsXG4gICAgICAgIHk6IHR5LFxuICAgICAgICB6MjogejIsXG4gICAgICAgIHRyYW5zZm9ybWVkOiBmYWxzZSxcbiAgICAgICAgbWluOiBbMiwgMV0sXG4gICAgICAgIG1heDogWy0xLCAwXVxuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aWxlLm51bUZlYXR1cmVzKys7XG4gICAgICAgIGFkZEZlYXR1cmUodGlsZSwgZmVhdHVyZXNbaV0sIHRvbGVyYW5jZSwgbm9TaW1wbGlmeSk7XG5cbiAgICAgICAgdmFyIG1pbiA9IGZlYXR1cmVzW2ldLm1pbixcbiAgICAgICAgICAgIG1heCA9IGZlYXR1cmVzW2ldLm1heDtcblxuICAgICAgICBpZiAobWluWzBdIDwgdGlsZS5taW5bMF0pIHRpbGUubWluWzBdID0gbWluWzBdO1xuICAgICAgICBpZiAobWluWzFdIDwgdGlsZS5taW5bMV0pIHRpbGUubWluWzFdID0gbWluWzFdO1xuICAgICAgICBpZiAobWF4WzBdID4gdGlsZS5tYXhbMF0pIHRpbGUubWF4WzBdID0gbWF4WzBdO1xuICAgICAgICBpZiAobWF4WzFdID4gdGlsZS5tYXhbMV0pIHRpbGUubWF4WzFdID0gbWF4WzFdO1xuICAgIH1cbiAgICByZXR1cm4gdGlsZTtcbn1cblxuZnVuY3Rpb24gYWRkRmVhdHVyZSh0aWxlLCBmZWF0dXJlLCB0b2xlcmFuY2UsIG5vU2ltcGxpZnkpIHtcblxuICAgIHZhciBnZW9tID0gZmVhdHVyZS5nZW9tZXRyeSxcbiAgICAgICAgdHlwZSA9IGZlYXR1cmUudHlwZSxcbiAgICAgICAgc2ltcGxpZmllZCA9IFtdLFxuICAgICAgICBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZSxcbiAgICAgICAgaSwgaiwgcmluZywgcDtcblxuICAgIGlmICh0eXBlID09PSAxKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZW9tLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzaW1wbGlmaWVkLnB1c2goZ2VvbVtpXSk7XG4gICAgICAgICAgICB0aWxlLm51bVBvaW50cysrO1xuICAgICAgICAgICAgdGlsZS5udW1TaW1wbGlmaWVkKys7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gc2ltcGxpZnkgYW5kIHRyYW5zZm9ybSBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMgZm9yIHRpbGUgZ2VvbWV0cnlcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdlb20ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJpbmcgPSBnZW9tW2ldO1xuXG4gICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IHRpbnkgcG9seWxpbmVzICYgcG9seWdvbnNcbiAgICAgICAgICAgIGlmICghbm9TaW1wbGlmeSAmJiAoKHR5cGUgPT09IDIgJiYgcmluZy5kaXN0IDwgdG9sZXJhbmNlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZSA9PT0gMyAmJiByaW5nLmFyZWEgPCBzcVRvbGVyYW5jZSkpKSB7XG4gICAgICAgICAgICAgICAgdGlsZS5udW1Qb2ludHMgKz0gcmluZy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzaW1wbGlmaWVkUmluZyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcmluZy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHAgPSByaW5nW2pdO1xuICAgICAgICAgICAgICAgIC8vIGtlZXAgcG9pbnRzIHdpdGggaW1wb3J0YW5jZSA+IHRvbGVyYW5jZVxuICAgICAgICAgICAgICAgIGlmIChub1NpbXBsaWZ5IHx8IHBbMl0gPiBzcVRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBzaW1wbGlmaWVkUmluZy5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB0aWxlLm51bVNpbXBsaWZpZWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGlsZS5udW1Qb2ludHMrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2ltcGxpZmllZC5wdXNoKHNpbXBsaWZpZWRSaW5nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaW1wbGlmaWVkLmxlbmd0aCkge1xuICAgICAgICB0aWxlLmZlYXR1cmVzLnB1c2goe1xuICAgICAgICAgICAgZ2VvbWV0cnk6IHNpbXBsaWZpZWQsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgdGFnczogZmVhdHVyZS50YWdzIHx8IG51bGxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xpcCA9IHJlcXVpcmUoJy4vY2xpcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXA7XG5cbmZ1bmN0aW9uIHdyYXAoZmVhdHVyZXMsIGJ1ZmZlciwgaW50ZXJzZWN0WCkge1xuICAgIHZhciBtZXJnZWQgPSBmZWF0dXJlcyxcbiAgICAgICAgbGVmdCAgPSBjbGlwKGZlYXR1cmVzLCAxLCAtMSAtIGJ1ZmZlciwgYnVmZmVyLCAgICAgMCwgaW50ZXJzZWN0WCwgLTEsIDIpLCAvLyBsZWZ0IHdvcmxkIGNvcHlcbiAgICAgICAgcmlnaHQgPSBjbGlwKGZlYXR1cmVzLCAxLCAgMSAtIGJ1ZmZlciwgMiArIGJ1ZmZlciwgMCwgaW50ZXJzZWN0WCwgLTEsIDIpOyAvLyByaWdodCB3b3JsZCBjb3B5XG5cbiAgICBpZiAobGVmdCB8fCByaWdodCkge1xuICAgICAgICBtZXJnZWQgPSBjbGlwKGZlYXR1cmVzLCAxLCAtYnVmZmVyLCAxICsgYnVmZmVyLCAwLCBpbnRlcnNlY3RYLCAtMSwgMik7IC8vIGNlbnRlciB3b3JsZCBjb3B5XG5cbiAgICAgICAgaWYgKGxlZnQpIG1lcmdlZCA9IHNoaWZ0RmVhdHVyZUNvb3JkcyhsZWZ0LCAxKS5jb25jYXQobWVyZ2VkKTsgLy8gbWVyZ2UgbGVmdCBpbnRvIGNlbnRlclxuICAgICAgICBpZiAocmlnaHQpIG1lcmdlZCA9IG1lcmdlZC5jb25jYXQoc2hpZnRGZWF0dXJlQ29vcmRzKHJpZ2h0LCAtMSkpOyAvLyBtZXJnZSByaWdodCBpbnRvIGNlbnRlclxuICAgIH1cblxuICAgIHJldHVybiBtZXJnZWQ7XG59XG5cbmZ1bmN0aW9uIHNoaWZ0RmVhdHVyZUNvb3JkcyhmZWF0dXJlcywgb2Zmc2V0KSB7XG4gICAgdmFyIG5ld0ZlYXR1cmVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbaV0sXG4gICAgICAgICAgICB0eXBlID0gZmVhdHVyZS50eXBlO1xuXG4gICAgICAgIHZhciBuZXdHZW9tZXRyeTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgbmV3R2VvbWV0cnkgPSBzaGlmdENvb3JkcyhmZWF0dXJlLmdlb21ldHJ5LCBvZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3R2VvbWV0cnkgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmVhdHVyZS5nZW9tZXRyeS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIG5ld0dlb21ldHJ5LnB1c2goc2hpZnRDb29yZHMoZmVhdHVyZS5nZW9tZXRyeVtqXSwgb2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBuZXdGZWF0dXJlcy5wdXNoKHtcbiAgICAgICAgICAgIGdlb21ldHJ5OiBuZXdHZW9tZXRyeSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICB0YWdzOiBmZWF0dXJlLnRhZ3MsXG4gICAgICAgICAgICBtaW46IFtmZWF0dXJlLm1pblswXSArIG9mZnNldCwgZmVhdHVyZS5taW5bMV1dLFxuICAgICAgICAgICAgbWF4OiBbZmVhdHVyZS5tYXhbMF0gKyBvZmZzZXQsIGZlYXR1cmUubWF4WzFdXVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RmVhdHVyZXM7XG59XG5cbmZ1bmN0aW9uIHNoaWZ0Q29vcmRzKHBvaW50cywgb2Zmc2V0KSB7XG4gICAgdmFyIG5ld1BvaW50cyA9IFtdO1xuICAgIG5ld1BvaW50cy5hcmVhID0gcG9pbnRzLmFyZWE7XG4gICAgbmV3UG9pbnRzLmRpc3QgPSBwb2ludHMuZGlzdDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld1BvaW50cy5wdXNoKFtwb2ludHNbaV1bMF0gKyBvZmZzZXQsIHBvaW50c1tpXVsxXSwgcG9pbnRzW2ldWzJdXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdQb2ludHM7XG59XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgZ2wtbWF0cml4IC0gSGlnaCBwZXJmb3JtYW5jZSBtYXRyaXggYW5kIHZlY3RvciBvcGVyYXRpb25zXG4gKiBAYXV0aG9yIEJyYW5kb24gSm9uZXNcbiAqIEBhdXRob3IgQ29saW4gTWFjS2VuemllIElWXG4gKiBAdmVyc2lvbiAyLjIuMVxuICovXG5cbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG5cbihmdW5jdGlvbihfZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBzaGltID0ge307XG4gIGlmICh0eXBlb2YoZXhwb3J0cykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAgIHNoaW0uZXhwb3J0cyA9IHt9O1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2hpbS5leHBvcnRzO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdsLW1hdHJpeCBsaXZlcyBpbiBhIGJyb3dzZXIsIGRlZmluZSBpdHMgbmFtZXNwYWNlcyBpbiBnbG9iYWxcbiAgICAgIHNoaW0uZXhwb3J0cyA9IHR5cGVvZih3aW5kb3cpICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IF9nbG9iYWw7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGdsLW1hdHJpeCBsaXZlcyBpbiBjb21tb25qcywgZGVmaW5lIGl0cyBuYW1lc3BhY2VzIGluIGV4cG9ydHNcbiAgICBzaGltLmV4cG9ydHMgPSBleHBvcnRzO1xuICB9XG5cbiAgKGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgICAvKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG5cbmlmKCFHTE1BVF9FUFNJTE9OKSB7XG4gICAgdmFyIEdMTUFUX0VQU0lMT04gPSAwLjAwMDAwMTtcbn1cblxuaWYoIUdMTUFUX0FSUkFZX1RZUEUpIHtcbiAgICB2YXIgR0xNQVRfQVJSQVlfVFlQRSA9ICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJykgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbn1cblxuaWYoIUdMTUFUX1JBTkRPTSkge1xuICAgIHZhciBHTE1BVF9SQU5ET00gPSBNYXRoLnJhbmRvbTtcbn1cblxuLyoqXG4gKiBAY2xhc3MgQ29tbW9uIHV0aWxpdGllc1xuICogQG5hbWUgZ2xNYXRyaXhcbiAqL1xudmFyIGdsTWF0cml4ID0ge307XG5cbi8qKlxuICogU2V0cyB0aGUgdHlwZSBvZiBhcnJheSB1c2VkIHdoZW4gY3JlYXRpbmcgbmV3IHZlY3RvcnMgYW5kIG1hdHJpY2llc1xuICpcbiAqIEBwYXJhbSB7VHlwZX0gdHlwZSBBcnJheSB0eXBlLCBzdWNoIGFzIEZsb2F0MzJBcnJheSBvciBBcnJheVxuICovXG5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgR0xNQVRfQVJSQVlfVFlQRSA9IHR5cGU7XG59XG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLmdsTWF0cml4ID0gZ2xNYXRyaXg7XG59XG5cbnZhciBkZWdyZWUgPSBNYXRoLlBJIC8gMTgwO1xuXG4vKipcbiogQ29udmVydCBEZWdyZWUgVG8gUmFkaWFuXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSBBbmdsZSBpbiBEZWdyZWVzXG4qL1xuZ2xNYXRyaXgudG9SYWRpYW4gPSBmdW5jdGlvbihhKXtcbiAgICAgcmV0dXJuIGEgKiBkZWdyZWU7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyAyIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjMlxuICovXG5cbnZhciB2ZWMyID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxuICpcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHkpIHtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuc3ViID0gdmVjMi5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5tdWwgPSB2ZWMyLm11bHRpcGx5O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuZGl2ID0gdmVjMi5kaXZpZGU7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm1pbiA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5tYXggPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzIncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzIuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuZGlzdCA9IHZlYzIuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMyLnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLnNxckRpc3QgPSB2ZWMyLnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWMyLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5sZW4gPSB2ZWMyLmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWMyLnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zcXJMZW4gPSB2ZWMyLnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICB2YXIgbGVuID0geCp4ICsgeSp5O1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG52ZWMyLmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqIE5vdGUgdGhhdCB0aGUgY3Jvc3MgcHJvZHVjdCBtdXN0IGJ5IGRlZmluaXRpb24gcHJvZHVjZSBhIDNEIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMi5jcm9zcyA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIHZhciB6ID0gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcbiAgICBvdXRbMF0gPSBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV07XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5yYW5kb20gPSBmdW5jdGlvbiAob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICAgIHZhciByID0gR0xNQVRfUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogc2NhbGU7XG4gICAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiBzY2FsZTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDIgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHk7XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0MmR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0MmQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDNcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDMgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVszXSAqIHkgKyBtWzZdO1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs0XSAqIHkgKyBtWzddO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDRcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzAnXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCBcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bMTJdO1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzEzXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjMnMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMi4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzJzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLmZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlYyA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoY291bnQpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07XG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgICAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzIuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzIoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcpJztcbn07XG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLnZlYzIgPSB2ZWMyO1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgMyBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzNcbiAqL1xuXG52YXIgdmVjMyA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzNcbiAqXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbnZlYzMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMyk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgzKTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSwgeikge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnN1YiA9IHZlYzMuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMubXVsID0gdmVjMy5tdWx0aXBseTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmRpdiA9IHZlYzMuZGl2aWRlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5taW4gPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubWF4ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zY2FsZUFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMy5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmRpc3QgPSB2ZWMzLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMy5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl07XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqejtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnNxckRpc3QgPSB2ZWMzLnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWMzLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMubGVuID0gdmVjMy5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjMy5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLnNxckxlbiA9IHZlYzMuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICB2YXIgbGVuID0geCp4ICsgeSp5ICsgeip6O1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgICAgICAgb3V0WzJdID0gYVsyXSAqIGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG52ZWMzLmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5jcm9zcyA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdO1xuXG4gICAgb3V0WzBdID0gYXkgKiBieiAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYng7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV0sXG4gICAgICAgIGF6ID0gYVsyXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnJhbmRvbSA9IGZ1bmN0aW9uIChvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG5cbiAgICB2YXIgciA9IEdMTUFUX1JBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgICB2YXIgeiA9IChHTE1BVF9SQU5ET00oKSAqIDIuMCkgLSAxLjA7XG4gICAgdmFyIHpTY2FsZSA9IE1hdGguc3FydCgxLjAteip6KSAqIHNjYWxlO1xuXG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGU7XG4gICAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiB6U2NhbGU7XG4gICAgb3V0WzJdID0geiAqIHNjYWxlO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDQuXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy50cmFuc2Zvcm1NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM107XG4gICAgb3V0WzJdID0gbVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIHRoZSAzeDMgbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtTWF0MyA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuICAgIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XTtcbiAgICBvdXRbMV0gPSB4ICogbVsxXSArIHkgKiBtWzRdICsgeiAqIG1bN107XG4gICAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnRyYW5zZm9ybVF1YXQgPSBmdW5jdGlvbihvdXQsIGEsIHEpIHtcbiAgICAvLyBiZW5jaG1hcmtzOiBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9uc1xuXG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHF4ID0gcVswXSwgcXkgPSBxWzFdLCBxeiA9IHFbMl0sIHF3ID0gcVszXSxcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuICAgICAgICBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeSxcbiAgICAgICAgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXG4gICAgICAgIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4LFxuICAgICAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qXG4qIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xuKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4qIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiovXG52ZWMzLnJvdGF0ZVggPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICAgdmFyIHAgPSBbXSwgcj1bXTtcblx0ICAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cdCAgcFswXSA9IGFbMF0gLSBiWzBdO1xuXHQgIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgXHRwWzJdID0gYVsyXSAtIGJbMl07XG5cblx0ICAvL3BlcmZvcm0gcm90YXRpb25cblx0ICByWzBdID0gcFswXTtcblx0ICByWzFdID0gcFsxXSpNYXRoLmNvcyhjKSAtIHBbMl0qTWF0aC5zaW4oYyk7XG5cdCAgclsyXSA9IHBbMV0qTWF0aC5zaW4oYykgKyBwWzJdKk1hdGguY29zKGMpO1xuXG5cdCAgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXHQgIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuXHQgIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuXHQgIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuXG4gIFx0cmV0dXJuIG91dDtcbn07XG5cbi8qXG4qIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xuKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4qIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiovXG52ZWMzLnJvdGF0ZVkgPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICBcdHZhciBwID0gW10sIHI9W107XG4gIFx0Ly9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBcdHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgXHRwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuICBcbiAgXHQvL3BlcmZvcm0gcm90YXRpb25cbiAgXHRyWzBdID0gcFsyXSpNYXRoLnNpbihjKSArIHBbMF0qTWF0aC5jb3MoYyk7XG4gIFx0clsxXSA9IHBbMV07XG4gIFx0clsyXSA9IHBbMl0qTWF0aC5jb3MoYykgLSBwWzBdKk1hdGguc2luKGMpO1xuICBcbiAgXHQvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIFx0b3V0WzBdID0gclswXSArIGJbMF07XG4gIFx0b3V0WzFdID0gclsxXSArIGJbMV07XG4gIFx0b3V0WzJdID0gclsyXSArIGJbMl07XG4gIFxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKlxuKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcbiogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4qIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4qIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuKiBAcmV0dXJucyB7dmVjM30gb3V0XG4qL1xudmVjMy5yb3RhdGVaID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgXHR2YXIgcCA9IFtdLCByPVtdO1xuICBcdC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgXHRwWzBdID0gYVswXSAtIGJbMF07XG4gIFx0cFsxXSA9IGFbMV0gLSBiWzFdO1xuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcbiAgXG4gIFx0Ly9wZXJmb3JtIHJvdGF0aW9uXG4gIFx0clswXSA9IHBbMF0qTWF0aC5jb3MoYykgLSBwWzFdKk1hdGguc2luKGMpO1xuICBcdHJbMV0gPSBwWzBdKk1hdGguc2luKGMpICsgcFsxXSpNYXRoLmNvcyhjKTtcbiAgXHRyWzJdID0gcFsyXTtcbiAgXG4gIFx0Ly90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICBcdG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBcdG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBcdG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICBcbiAgXHRyZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjM3MuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMy4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlYyA9IHZlYzMuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSAzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoY291bnQpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07IHZlY1syXSA9IGFbaSsyXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdOyBhW2krMl0gPSB2ZWNbMl07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMzLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWMzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcpJztcbn07XG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLnZlYzMgPSB2ZWMzO1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgNCBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzRcbiAqL1xuXG52YXIgdmVjNCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzRcbiAqXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbnZlYzQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB6LCB3KSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHksIHosIHcpIHtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LnN1YiA9IHZlYzQuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAqIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQubXVsID0gdmVjNC5tdWx0aXBseTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAvIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LmRpdiA9IHZlYzQuZGl2aWRlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5taW4gPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLm1pbihhWzNdLCBiWzNdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubWF4ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gICAgb3V0WzNdID0gTWF0aC5tYXgoYVszXSwgYlszXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjNCBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICBvdXRbM10gPSBhWzNdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWM0J3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zY2FsZUFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzQuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl0sXG4gICAgICAgIHcgPSBiWzNdIC0gYVszXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeiArIHcqdyk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LmRpc3QgPSB2ZWM0LmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjNC5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl0sXG4gICAgICAgIHcgPSBiWzNdIC0gYVszXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuc3FyRGlzdCA9IHZlYzQuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzQubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXSxcbiAgICAgICAgdyA9IGFbM107XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnogKyB3KncpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQubGVuID0gdmVjNC5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjNC5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXSxcbiAgICAgICAgdyA9IGFbM107XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqeiArIHcqdztcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5zcXJMZW4gPSB2ZWM0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSAtYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBhWzNdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgICAgICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICAgICAgICBvdXRbM10gPSBhWzNdICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzQuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl0sXG4gICAgICAgIGF3ID0gYVszXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgICBvdXRbM10gPSBhdyArIHQgKiAoYlszXSAtIGF3KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnJhbmRvbSA9IGZ1bmN0aW9uIChvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG5cbiAgICAvL1RPRE86IFRoaXMgaXMgYSBwcmV0dHkgYXdmdWwgd2F5IG9mIGRvaW5nIHRoaXMuIEZpbmQgc29tZXRoaW5nIGJldHRlci5cbiAgICBvdXRbMF0gPSBHTE1BVF9SQU5ET00oKTtcbiAgICBvdXRbMV0gPSBHTE1BVF9SQU5ET00oKTtcbiAgICBvdXRbMl0gPSBHTE1BVF9SQU5ET00oKTtcbiAgICBvdXRbM10gPSBHTE1BVF9SQU5ET00oKTtcbiAgICB2ZWM0Lm5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgdmVjNC5zY2FsZShvdXQsIG91dCwgc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIG1hdDQuXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSwgdyA9IGFbM107XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0gKiB3O1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdICogdztcbiAgICBvdXRbMl0gPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0gKiB3O1xuICAgIG91dFszXSA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XSAqIHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQudHJhbnNmb3JtUXVhdCA9IGZ1bmN0aW9uKG91dCwgYSwgcSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICAgIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWM0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWM0LiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVjID0gdmVjNC5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTsgdmVjWzJdID0gYVtpKzJdOyB2ZWNbM10gPSBhW2krM107XG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgICAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTsgYVtpKzJdID0gdmVjWzJdOyBhW2krM10gPSB2ZWNbM107XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWM0LnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWM0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufTtcblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMudmVjNCA9IHZlYzQ7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyAyeDIgTWF0cml4XG4gKiBAbmFtZSBtYXQyXG4gKi9cblxudmFyIG1hdDIgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJcbiAqXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5tYXQyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbm1hdDIuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQyIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgIGlmIChvdXQgPT09IGEpIHtcbiAgICAgICAgdmFyIGExID0gYVsxXTtcbiAgICAgICAgb3V0WzFdID0gYVsyXTtcbiAgICAgICAgb3V0WzJdID0gYTE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVsyXTtcbiAgICAgICAgb3V0WzJdID0gYVsxXTtcbiAgICAgICAgb3V0WzNdID0gYVszXTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGEwICogYTMgLSBhMiAqIGExO1xuXG4gICAgaWYgKCFkZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcbiAgICBcbiAgICBvdXRbMF0gPSAgYTMgKiBkZXQ7XG4gICAgb3V0WzFdID0gLWExICogZGV0O1xuICAgIG91dFsyXSA9IC1hMiAqIGRldDtcbiAgICBvdXRbM10gPSAgYTAgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIENhY2hpbmcgdGhpcyB2YWx1ZSBpcyBuZXNzZWNhcnkgaWYgb3V0ID09IGFcbiAgICB2YXIgYTAgPSBhWzBdO1xuICAgIG91dFswXSA9ICBhWzNdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIG91dFszXSA9ICBhMDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5tYXQyLmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzJdICogYVsxXTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MidzXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTtcbiAgICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcbiAgICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMTtcbiAgICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0Mi5tdWwgPSBtYXQyLm11bHRpcGx5O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQyIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHM7XG4gICAgb3V0WzFdID0gYTEgKiAgYyArIGEzICogcztcbiAgICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xuICAgIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQyIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqKi9cbm1hdDIuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuICAgICAgICB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgICBvdXRbMF0gPSBhMCAqIHYwO1xuICAgIG91dFsxXSA9IGExICogdjA7XG4gICAgb3V0WzJdID0gYTIgKiB2MTtcbiAgICBvdXRbM10gPSBhMyAqIHYxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0Mi5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MignICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDIuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSkpXG59O1xuXG4vKipcbiAqIFJldHVybnMgTCwgRCBhbmQgVSBtYXRyaWNlcyAoTG93ZXIgdHJpYW5ndWxhciwgRGlhZ29uYWwgYW5kIFVwcGVyIHRyaWFuZ3VsYXIpIGJ5IGZhY3Rvcml6aW5nIHRoZSBpbnB1dCBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gTCB0aGUgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXggXG4gKiBAcGFyYW0ge21hdDJ9IEQgdGhlIGRpYWdvbmFsIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gVSB0aGUgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXggXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGlucHV0IG1hdHJpeCB0byBmYWN0b3JpemVcbiAqL1xuXG5tYXQyLkxEVSA9IGZ1bmN0aW9uIChMLCBELCBVLCBhKSB7IFxuICAgIExbMl0gPSBhWzJdL2FbMF07IFxuICAgIFVbMF0gPSBhWzBdOyBcbiAgICBVWzFdID0gYVsxXTsgXG4gICAgVVszXSA9IGFbM10gLSBMWzJdICogVVsxXTsgXG4gICAgcmV0dXJuIFtMLCBELCBVXTsgICAgICAgXG59OyBcblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMubWF0MiA9IG1hdDI7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyAyeDMgTWF0cml4XG4gKiBAbmFtZSBtYXQyZFxuICogXG4gKiBAZGVzY3JpcHRpb24gXG4gKiBBIG1hdDJkIGNvbnRhaW5zIHNpeCBlbGVtZW50cyBkZWZpbmVkIGFzOlxuICogPHByZT5cbiAqIFthLCBjLCB0eCxcbiAqICBiLCBkLCB0eV1cbiAqIDwvcHJlPlxuICogVGhpcyBpcyBhIHNob3J0IGZvcm0gZm9yIHRoZSAzeDMgbWF0cml4OlxuICogPHByZT5cbiAqIFthLCBjLCB0eCxcbiAqICBiLCBkLCB0eSxcbiAqICAwLCAwLCAxXVxuICogPC9wcmU+XG4gKiBUaGUgbGFzdCByb3cgaXMgaWdub3JlZCBzbyB0aGUgYXJyYXkgaXMgc2hvcnRlciBhbmQgb3BlcmF0aW9ucyBhcmUgZmFzdGVyLlxuICovXG5cbnZhciBtYXQyZCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MmRcbiAqXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xubWF0MmQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDYpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MmQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDJkfSBhIG5ldyAyeDMgbWF0cml4XG4gKi9cbm1hdDJkLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg2KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MmQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDJkIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYWEgPSBhWzBdLCBhYiA9IGFbMV0sIGFjID0gYVsyXSwgYWQgPSBhWzNdLFxuICAgICAgICBhdHggPSBhWzRdLCBhdHkgPSBhWzVdO1xuXG4gICAgdmFyIGRldCA9IGFhICogYWQgLSBhYiAqIGFjO1xuICAgIGlmKCFkZXQpe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gICAgb3V0WzFdID0gLWFiICogZGV0O1xuICAgIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgICBvdXRbM10gPSBhYSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDJkLmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzFdICogYVsyXTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MmQnc1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM10sIGI0ID0gYls0XSwgYjUgPSBiWzVdO1xuICAgIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICAgIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICAgIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICAgIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICAgIG91dFs0XSA9IGEwICogYjQgKyBhMiAqIGI1ICsgYTQ7XG4gICAgb3V0WzVdID0gYTEgKiBiNCArIGEzICogYjUgKyBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDJkLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDJkLm11bCA9IG1hdDJkLm11bHRpcGx5O1xuXG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDJkIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgb3V0WzBdID0gYTAgKiAgYyArIGEyICogcztcbiAgICBvdXRbMV0gPSBhMSAqICBjICsgYTMgKiBzO1xuICAgIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gICAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgICBvdXRbNF0gPSBhNDtcbiAgICBvdXRbNV0gPSBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqKi9cbm1hdDJkLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sXG4gICAgICAgIHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICAgIG91dFswXSA9IGEwICogdjA7XG4gICAgb3V0WzFdID0gYTEgKiB2MDtcbiAgICBvdXRbMl0gPSBhMiAqIHYxO1xuICAgIG91dFszXSA9IGEzICogdjE7XG4gICAgb3V0WzRdID0gYTQ7XG4gICAgb3V0WzVdID0gYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlcyB0aGUgbWF0MmQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byB0cmFuc2xhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqKi9cbm1hdDJkLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgICBvdXRbMF0gPSBhMDtcbiAgICBvdXRbMV0gPSBhMTtcbiAgICBvdXRbMl0gPSBhMjtcbiAgICBvdXRbM10gPSBhMztcbiAgICBvdXRbNF0gPSBhMCAqIHYwICsgYTIgKiB2MSArIGE0O1xuICAgIG91dFs1XSA9IGExICogdjAgKyBhMyAqIHYxICsgYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQyZC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MmQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzNdICsgJywgJyArIGFbNF0gKyAnLCAnICsgYVs1XSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0MmQuZnJvYiA9IGZ1bmN0aW9uIChhKSB7IFxuICAgIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgMSkpXG59OyBcblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMubWF0MmQgPSBtYXQyZDtcbn1cbjtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogQGNsYXNzIDN4MyBNYXRyaXhcbiAqIEBuYW1lIG1hdDNcbiAqL1xuXG52YXIgbWF0MyA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0M1xuICpcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XG4gKi9cbm1hdDMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDkpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMTtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcGllcyB0aGUgdXBwZXItbGVmdCAzeDMgdmFsdWVzIGludG8gdGhlIGdpdmVuIG1hdDMuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyAzeDMgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgICB0aGUgc291cmNlIDR4NCBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5mcm9tTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbNF07XG4gICAgb3V0WzRdID0gYVs1XTtcbiAgICBvdXRbNV0gPSBhWzZdO1xuICAgIG91dFs2XSA9IGFbOF07XG4gICAgb3V0WzddID0gYVs5XTtcbiAgICBvdXRbOF0gPSBhWzEwXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5tYXQzLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg5KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQzIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAxO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMTIgPSBhWzVdO1xuICAgICAgICBvdXRbMV0gPSBhWzNdO1xuICAgICAgICBvdXRbMl0gPSBhWzZdO1xuICAgICAgICBvdXRbM10gPSBhMDE7XG4gICAgICAgIG91dFs1XSA9IGFbN107XG4gICAgICAgIG91dFs2XSA9IGEwMjtcbiAgICAgICAgb3V0WzddID0gYTEyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbM107XG4gICAgICAgIG91dFsyXSA9IGFbNl07XG4gICAgICAgIG91dFszXSA9IGFbMV07XG4gICAgICAgIG91dFs0XSA9IGFbNF07XG4gICAgICAgIG91dFs1XSA9IGFbN107XG4gICAgICAgIG91dFs2XSA9IGFbMl07XG4gICAgICAgIG91dFs3XSA9IGFbNV07XG4gICAgICAgIG91dFs4XSA9IGFbOF07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuXG4gICAgICAgIGIwMSA9IGEyMiAqIGExMSAtIGExMiAqIGEyMSxcbiAgICAgICAgYjExID0gLWEyMiAqIGExMCArIGExMiAqIGEyMCxcbiAgICAgICAgYjIxID0gYTIxICogYTEwIC0gYTExICogYTIwLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYTAwICogYjAxICsgYTAxICogYjExICsgYTAyICogYjIxO1xuXG4gICAgaWYgKCFkZXQpIHsgXG4gICAgICAgIHJldHVybiBudWxsOyBcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gYjAxICogZGV0O1xuICAgIG91dFsxXSA9ICgtYTIyICogYTAxICsgYTAyICogYTIxKSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTEyICogYTAxIC0gYTAyICogYTExKSAqIGRldDtcbiAgICBvdXRbM10gPSBiMTEgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCkgKiBkZXQ7XG4gICAgb3V0WzVdID0gKC1hMTIgKiBhMDAgKyBhMDIgKiBhMTApICogZGV0O1xuICAgIG91dFs2XSA9IGIyMSAqIGRldDtcbiAgICBvdXRbN10gPSAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGExMSAqIGEwMCAtIGEwMSAqIGExMCkgKiBkZXQ7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XTtcblxuICAgIG91dFswXSA9IChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpO1xuICAgIG91dFsxXSA9IChhMDIgKiBhMjEgLSBhMDEgKiBhMjIpO1xuICAgIG91dFsyXSA9IChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpO1xuICAgIG91dFszXSA9IChhMTIgKiBhMjAgLSBhMTAgKiBhMjIpO1xuICAgIG91dFs0XSA9IChhMDAgKiBhMjIgLSBhMDIgKiBhMjApO1xuICAgIG91dFs1XSA9IChhMDIgKiBhMTAgLSBhMDAgKiBhMTIpO1xuICAgIG91dFs2XSA9IChhMTAgKiBhMjEgLSBhMTEgKiBhMjApO1xuICAgIG91dFs3XSA9IChhMDEgKiBhMjAgLSBhMDAgKiBhMjEpO1xuICAgIG91dFs4XSA9IChhMDAgKiBhMTEgLSBhMDEgKiBhMTApO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5tYXQzLmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XTtcblxuICAgIHJldHVybiBhMDAgKiAoYTIyICogYTExIC0gYTEyICogYTIxKSArIGEwMSAqICgtYTIyICogYTEwICsgYTEyICogYTIwKSArIGEwMiAqIChhMjEgKiBhMTAgLSBhMTEgKiBhMjApO1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQzJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICAgICAgYjAwID0gYlswXSwgYjAxID0gYlsxXSwgYjAyID0gYlsyXSxcbiAgICAgICAgYjEwID0gYlszXSwgYjExID0gYls0XSwgYjEyID0gYls1XSxcbiAgICAgICAgYjIwID0gYls2XSwgYjIxID0gYls3XSwgYjIyID0gYls4XTtcblxuICAgIG91dFswXSA9IGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMDtcbiAgICBvdXRbMV0gPSBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjE7XG4gICAgb3V0WzJdID0gYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyO1xuXG4gICAgb3V0WzNdID0gYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwO1xuICAgIG91dFs0XSA9IGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMTtcbiAgICBvdXRbNV0gPSBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjI7XG5cbiAgICBvdXRbNl0gPSBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjA7XG4gICAgb3V0WzddID0gYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxO1xuICAgIG91dFs4XSA9IGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDMubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0My5tdWwgPSBtYXQzLm11bHRpcGx5O1xuXG4vKipcbiAqIFRyYW5zbGF0ZSBhIG1hdDMgYnkgdGhlIGdpdmVuIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMudHJhbnNsYXRlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG4gICAgICAgIHggPSB2WzBdLCB5ID0gdlsxXTtcblxuICAgIG91dFswXSA9IGEwMDtcbiAgICBvdXRbMV0gPSBhMDE7XG4gICAgb3V0WzJdID0gYTAyO1xuXG4gICAgb3V0WzNdID0gYTEwO1xuICAgIG91dFs0XSA9IGExMTtcbiAgICBvdXRbNV0gPSBhMTI7XG5cbiAgICBvdXRbNl0gPSB4ICogYTAwICsgeSAqIGExMCArIGEyMDtcbiAgICBvdXRbN10gPSB4ICogYTAxICsgeSAqIGExMSArIGEyMTtcbiAgICBvdXRbOF0gPSB4ICogYTAyICsgeSAqIGExMiArIGEyMjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MyBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuXG4gICAgICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGMgKiBhMDAgKyBzICogYTEwO1xuICAgIG91dFsxXSA9IGMgKiBhMDEgKyBzICogYTExO1xuICAgIG91dFsyXSA9IGMgKiBhMDIgKyBzICogYTEyO1xuXG4gICAgb3V0WzNdID0gYyAqIGExMCAtIHMgKiBhMDA7XG4gICAgb3V0WzRdID0gYyAqIGExMSAtIHMgKiBhMDE7XG4gICAgb3V0WzVdID0gYyAqIGExMiAtIHMgKiBhMDI7XG5cbiAgICBvdXRbNl0gPSBhMjA7XG4gICAgb3V0WzddID0gYTIxO1xuICAgIG91dFs4XSA9IGEyMjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDMgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xubWF0My5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV07XG5cbiAgICBvdXRbMF0gPSB4ICogYVswXTtcbiAgICBvdXRbMV0gPSB4ICogYVsxXTtcbiAgICBvdXRbMl0gPSB4ICogYVsyXTtcblxuICAgIG91dFszXSA9IHkgKiBhWzNdO1xuICAgIG91dFs0XSA9IHkgKiBhWzRdO1xuICAgIG91dFs1XSA9IHkgKiBhWzVdO1xuXG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgZnJvbSBhIG1hdDJkIGludG8gYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBjb3B5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5tYXQzLmZyb21NYXQyZCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSAwO1xuXG4gICAgb3V0WzNdID0gYVsyXTtcbiAgICBvdXRbNF0gPSBhWzNdO1xuICAgIG91dFs1XSA9IDA7XG5cbiAgICBvdXRbNl0gPSBhWzRdO1xuICAgIG91dFs3XSA9IGFbNV07XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4qIENhbGN1bGF0ZXMgYSAzeDMgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cbipcbiogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuKiBAcGFyYW0ge3F1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cbipcbiogQHJldHVybnMge21hdDN9IG91dFxuKi9cbm1hdDMuZnJvbVF1YXQgPSBmdW5jdGlvbiAob3V0LCBxKSB7XG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB5eCA9IHkgKiB4MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHp4ID0geiAqIHgyLFxuICAgICAgICB6eSA9IHogKiB5MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgICBvdXRbM10gPSB5eCAtIHd6O1xuICAgIG91dFs2XSA9IHp4ICsgd3k7XG5cbiAgICBvdXRbMV0gPSB5eCArIHd6O1xuICAgIG91dFs0XSA9IDEgLSB4eCAtIHp6O1xuICAgIG91dFs3XSA9IHp5IC0gd3g7XG5cbiAgICBvdXRbMl0gPSB6eCAtIHd5O1xuICAgIG91dFs1XSA9IHp5ICsgd3g7XG4gICAgb3V0WzhdID0gMSAtIHh4IC0geXk7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4qIENhbGN1bGF0ZXMgYSAzeDMgbm9ybWFsIG1hdHJpeCAodHJhbnNwb3NlIGludmVyc2UpIGZyb20gdGhlIDR4NCBtYXRyaXhcbipcbiogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuKiBAcGFyYW0ge21hdDR9IGEgTWF0NCB0byBkZXJpdmUgdGhlIG5vcm1hbCBtYXRyaXggZnJvbVxuKlxuKiBAcmV0dXJucyB7bWF0M30gb3V0XG4qL1xubWF0My5ub3JtYWxGcm9tTWF0NCA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gICAgaWYgKCFkZXQpIHsgXG4gICAgICAgIHJldHVybiBudWxsOyBcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzFdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG5cbiAgICBvdXRbM10gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcblxuICAgIG91dFs2XSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIG91dFs3XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIG91dFs4XSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQzLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBcbiAgICAgICAgICAgICAgICAgICAgYVszXSArICcsICcgKyBhWzRdICsgJywgJyArIGFbNV0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgKyBhWzhdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0My5mcm9iID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIE1hdGgucG93KGFbNl0sIDIpICsgTWF0aC5wb3coYVs3XSwgMikgKyBNYXRoLnBvdyhhWzhdLCAyKSkpXG59O1xuXG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLm1hdDMgPSBtYXQzO1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgNHg0IE1hdHJpeFxuICogQG5hbWUgbWF0NFxuICovXG5cbnZhciBtYXQ0ID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQ0XG4gKlxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xubWF0NC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMTYpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xubWF0NC5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMTYpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIG91dFs5XSA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgIGlmIChvdXQgPT09IGEpIHtcbiAgICAgICAgdmFyIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgICAgICBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICAgICAgb3V0WzFdID0gYVs0XTtcbiAgICAgICAgb3V0WzJdID0gYVs4XTtcbiAgICAgICAgb3V0WzNdID0gYVsxMl07XG4gICAgICAgIG91dFs0XSA9IGEwMTtcbiAgICAgICAgb3V0WzZdID0gYVs5XTtcbiAgICAgICAgb3V0WzddID0gYVsxM107XG4gICAgICAgIG91dFs4XSA9IGEwMjtcbiAgICAgICAgb3V0WzldID0gYTEyO1xuICAgICAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgICAgIG91dFsxMl0gPSBhMDM7XG4gICAgICAgIG91dFsxM10gPSBhMTM7XG4gICAgICAgIG91dFsxNF0gPSBhMjM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVs0XTtcbiAgICAgICAgb3V0WzJdID0gYVs4XTtcbiAgICAgICAgb3V0WzNdID0gYVsxMl07XG4gICAgICAgIG91dFs0XSA9IGFbMV07XG4gICAgICAgIG91dFs1XSA9IGFbNV07XG4gICAgICAgIG91dFs2XSA9IGFbOV07XG4gICAgICAgIG91dFs3XSA9IGFbMTNdO1xuICAgICAgICBvdXRbOF0gPSBhWzJdO1xuICAgICAgICBvdXRbOV0gPSBhWzZdO1xuICAgICAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzEyXSA9IGFbM107XG4gICAgICAgIG91dFsxM10gPSBhWzddO1xuICAgICAgICBvdXRbMTRdID0gYVsxMV07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICAgIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICAgIG91dFs0XSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIG91dFs3XSA9IChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0O1xuICAgIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICAgIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICAgIG91dFsxMF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxM10gPSAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICAgIG91dFswXSAgPSAgKGExMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gICAgb3V0WzFdICA9IC0oYTAxICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgICBvdXRbMl0gID0gIChhMDEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFszXSAgPSAtKGEwMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTExICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzRdICA9IC0oYTEwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgICBvdXRbNV0gID0gIChhMDAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICAgIG91dFs2XSAgPSAtKGEwMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTEwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzddICA9ICAoYTAwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbOF0gID0gIChhMTAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkpO1xuICAgIG91dFs5XSAgPSAtKGEwMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSk7XG4gICAgb3V0WzEwXSA9ICAoYTAwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgICBvdXRbMTFdID0gLShhMDAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICAgIG91dFsxMl0gPSAtKGExMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSk7XG4gICAgb3V0WzEzXSA9ICAoYTAwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpKTtcbiAgICBvdXRbMTRdID0gLShhMDAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICAgIG91dFsxNV0gPSAgKGEwMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDQuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgcmV0dXJuIGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NCdzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gICAgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG4gICAgdmFyIGIwICA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107ICBcbiAgICBvdXRbMF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzFdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsyXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbM10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbNF07IGIxID0gYls1XTsgYjIgPSBiWzZdOyBiMyA9IGJbN107XG4gICAgb3V0WzRdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFs1XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbNl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzddID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzhdOyBiMSA9IGJbOV07IGIyID0gYlsxMF07IGIzID0gYlsxMV07XG4gICAgb3V0WzhdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFs5XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMTBdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFsxMV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbMTJdOyBiMSA9IGJbMTNdOyBiMiA9IGJbMTRdOyBiMyA9IGJbMTVdO1xuICAgIG91dFsxMl0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzEzXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMTRdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFsxNV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDQubXVsID0gbWF0NC5tdWx0aXBseTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdLCB6ID0gdlsyXSxcbiAgICAgICAgYTAwLCBhMDEsIGEwMiwgYTAzLFxuICAgICAgICBhMTAsIGExMSwgYTEyLCBhMTMsXG4gICAgICAgIGEyMCwgYTIxLCBhMjIsIGEyMztcblxuICAgIGlmIChhID09PSBvdXQpIHtcbiAgICAgICAgb3V0WzEyXSA9IGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxXSAqIHggKyBhWzVdICogeSArIGFbOV0gKiB6ICsgYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6ICsgYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcbiAgICAgICAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgICAgICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgICAgIG91dFswXSA9IGEwMDsgb3V0WzFdID0gYTAxOyBvdXRbMl0gPSBhMDI7IG91dFszXSA9IGEwMztcbiAgICAgICAgb3V0WzRdID0gYTEwOyBvdXRbNV0gPSBhMTE7IG91dFs2XSA9IGExMjsgb3V0WzddID0gYTEzO1xuICAgICAgICBvdXRbOF0gPSBhMjA7IG91dFs5XSA9IGEyMTsgb3V0WzEwXSA9IGEyMjsgb3V0WzExXSA9IGEyMztcblxuICAgICAgICBvdXRbMTJdID0gYTAwICogeCArIGExMCAqIHkgKyBhMjAgKiB6ICsgYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhMDEgKiB4ICsgYTExICogeSArIGEyMSAqIHogKyBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGEwMiAqIHggKyBhMTIgKiB5ICsgYTIyICogeiArIGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYTAzICogeCArIGExMyAqIHkgKyBhMjMgKiB6ICsgYVsxNV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICoqL1xubWF0NC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdO1xuXG4gICAgb3V0WzBdID0gYVswXSAqIHg7XG4gICAgb3V0WzFdID0gYVsxXSAqIHg7XG4gICAgb3V0WzJdID0gYVsyXSAqIHg7XG4gICAgb3V0WzNdID0gYVszXSAqIHg7XG4gICAgb3V0WzRdID0gYVs0XSAqIHk7XG4gICAgb3V0WzVdID0gYVs1XSAqIHk7XG4gICAgb3V0WzZdID0gYVs2XSAqIHk7XG4gICAgb3V0WzddID0gYVs3XSAqIHk7XG4gICAgb3V0WzhdID0gYVs4XSAqIHo7XG4gICAgb3V0WzldID0gYVs5XSAqIHo7XG4gICAgb3V0WzEwXSA9IGFbMTBdICogejtcbiAgICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0NCBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQsIGF4aXMpIHtcbiAgICB2YXIgeCA9IGF4aXNbMF0sIHkgPSBheGlzWzFdLCB6ID0gYXhpc1syXSxcbiAgICAgICAgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiksXG4gICAgICAgIHMsIGMsIHQsXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjMsXG4gICAgICAgIGIwMCwgYjAxLCBiMDIsXG4gICAgICAgIGIxMCwgYjExLCBiMTIsXG4gICAgICAgIGIyMCwgYjIxLCBiMjI7XG5cbiAgICBpZiAoTWF0aC5hYnMobGVuKSA8IEdMTUFUX0VQU0lMT04pIHsgcmV0dXJuIG51bGw7IH1cbiAgICBcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHggKj0gbGVuO1xuICAgIHkgKj0gbGVuO1xuICAgIHogKj0gbGVuO1xuXG4gICAgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgdCA9IDEgLSBjO1xuXG4gICAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcbiAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgIC8vIENvbnN0cnVjdCB0aGUgZWxlbWVudHMgb2YgdGhlIHJvdGF0aW9uIG1hdHJpeFxuICAgIGIwMCA9IHggKiB4ICogdCArIGM7IGIwMSA9IHkgKiB4ICogdCArIHogKiBzOyBiMDIgPSB6ICogeCAqIHQgLSB5ICogcztcbiAgICBiMTAgPSB4ICogeSAqIHQgLSB6ICogczsgYjExID0geSAqIHkgKiB0ICsgYzsgYjEyID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gICAgYjIwID0geCAqIHogKiB0ICsgeSAqIHM7IGIyMSA9IHkgKiB6ICogdCAtIHggKiBzOyBiMjIgPSB6ICogeiAqIHQgKyBjO1xuXG4gICAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XG4gICAgb3V0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyO1xuICAgIG91dFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMjtcbiAgICBvdXRbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XG4gICAgb3V0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyO1xuICAgIG91dFs1XSA9IGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMjtcbiAgICBvdXRbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gICAgb3V0WzddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyO1xuICAgIG91dFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMjtcbiAgICBvdXRbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gICAgb3V0WzEwXSA9IGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMjtcbiAgICBvdXRbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGVYID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICAgIG91dFswXSAgPSBhWzBdO1xuICAgICAgICBvdXRbMV0gID0gYVsxXTtcbiAgICAgICAgb3V0WzJdICA9IGFbMl07XG4gICAgICAgIG91dFszXSAgPSBhWzNdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFs0XSA9IGExMCAqIGMgKyBhMjAgKiBzO1xuICAgIG91dFs1XSA9IGExMSAqIGMgKyBhMjEgKiBzO1xuICAgIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICAgIG91dFs3XSA9IGExMyAqIGMgKyBhMjMgKiBzO1xuICAgIG91dFs4XSA9IGEyMCAqIGMgLSBhMTAgKiBzO1xuICAgIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICAgIG91dFsxMF0gPSBhMjIgKiBjIC0gYTEyICogcztcbiAgICBvdXRbMTFdID0gYTIzICogYyAtIGExMyAqIHM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZVkgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzRdICA9IGFbNF07XG4gICAgICAgIG91dFs1XSAgPSBhWzVdO1xuICAgICAgICBvdXRbNl0gID0gYVs2XTtcbiAgICAgICAgb3V0WzddICA9IGFbN107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYyAtIGEyMCAqIHM7XG4gICAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XG4gICAgb3V0WzJdID0gYTAyICogYyAtIGEyMiAqIHM7XG4gICAgb3V0WzNdID0gYTAzICogYyAtIGEyMyAqIHM7XG4gICAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XG4gICAgb3V0WzldID0gYTAxICogcyArIGEyMSAqIGM7XG4gICAgb3V0WzEwXSA9IGEwMiAqIHMgKyBhMjIgKiBjO1xuICAgIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlWiA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sXG4gICAgICAgIGExMSA9IGFbNV0sXG4gICAgICAgIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN107XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFs4XSAgPSBhWzhdO1xuICAgICAgICBvdXRbOV0gID0gYVs5XTtcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgICAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYyArIGExMCAqIHM7XG4gICAgb3V0WzFdID0gYTAxICogYyArIGExMSAqIHM7XG4gICAgb3V0WzJdID0gYTAyICogYyArIGExMiAqIHM7XG4gICAgb3V0WzNdID0gYTAzICogYyArIGExMyAqIHM7XG4gICAgb3V0WzRdID0gYTEwICogYyAtIGEwMCAqIHM7XG4gICAgb3V0WzVdID0gYTExICogYyAtIGEwMSAqIHM7XG4gICAgb3V0WzZdID0gYTEyICogYyAtIGEwMiAqIHM7XG4gICAgb3V0WzddID0gYTEzICogYyAtIGEwMyAqIHM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiBhbmQgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIHZhciBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uIChvdXQsIHEsIHYpIHtcbiAgICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgICB4eiA9IHggKiB6MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSAoeXkgKyB6eik7XG4gICAgb3V0WzFdID0geHkgKyB3ejtcbiAgICBvdXRbMl0gPSB4eiAtIHd5O1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geHkgLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICAgIG91dFs2XSA9IHl6ICsgd3g7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4eiArIHd5O1xuICAgIG91dFs5XSA9IHl6IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSAoeHggKyB5eSk7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1hdDQuZnJvbVF1YXQgPSBmdW5jdGlvbiAob3V0LCBxKSB7XG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB5eCA9IHkgKiB4MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHp4ID0geiAqIHgyLFxuICAgICAgICB6eSA9IHogKiB5MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgICBvdXRbMV0gPSB5eCArIHd6O1xuICAgIG91dFsyXSA9IHp4IC0gd3k7XG4gICAgb3V0WzNdID0gMDtcblxuICAgIG91dFs0XSA9IHl4IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtIHh4IC0geno7XG4gICAgb3V0WzZdID0genkgKyB3eDtcbiAgICBvdXRbN10gPSAwO1xuXG4gICAgb3V0WzhdID0genggKyB3eTtcbiAgICBvdXRbOV0gPSB6eSAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0geHggLSB5eTtcbiAgICBvdXRbMTFdID0gMDtcblxuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgZnJ1c3R1bSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJ1c3R1bSA9IGZ1bmN0aW9uIChvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIHJsID0gMSAvIChyaWdodCAtIGxlZnQpLFxuICAgICAgICB0YiA9IDEgLyAodG9wIC0gYm90dG9tKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IChuZWFyICogMikgKiBybDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IChuZWFyICogMikgKiB0YjtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gKHJpZ2h0ICsgbGVmdCkgKiBybDtcbiAgICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTFdID0gLTE7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IChmYXIgKiBuZWFyICogMikgKiBuZjtcbiAgICBvdXRbMTVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3QgQXNwZWN0IHJhdGlvLiB0eXBpY2FsbHkgdmlld3BvcnQgd2lkdGgvaGVpZ2h0XG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnBlcnNwZWN0aXZlID0gZnVuY3Rpb24gKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgZiA9IDEuMCAvIE1hdGgudGFuKGZvdnkgLyAyKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IGYgLyBhc3BlY3Q7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSBmO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKDIgKiBmYXIgKiBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQub3J0aG8gPSBmdW5jdGlvbiAob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICAgIHZhciBsciA9IDEgLyAobGVmdCAtIHJpZ2h0KSxcbiAgICAgICAgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSAtMiAqIGxyO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gLTIgKiBidDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAyICogbmY7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IChsZWZ0ICsgcmlnaHQpICogbHI7XG4gICAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gICAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGxvb2stYXQgbWF0cml4IHdpdGggdGhlIGdpdmVuIGV5ZSBwb3NpdGlvbiwgZm9jYWwgcG9pbnQsIGFuZCB1cCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHt2ZWMzfSBleWUgUG9zaXRpb24gb2YgdGhlIHZpZXdlclxuICogQHBhcmFtIHt2ZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XG4gKiBAcGFyYW0ge3ZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5sb29rQXQgPSBmdW5jdGlvbiAob3V0LCBleWUsIGNlbnRlciwgdXApIHtcbiAgICB2YXIgeDAsIHgxLCB4MiwgeTAsIHkxLCB5MiwgejAsIHoxLCB6MiwgbGVuLFxuICAgICAgICBleWV4ID0gZXllWzBdLFxuICAgICAgICBleWV5ID0gZXllWzFdLFxuICAgICAgICBleWV6ID0gZXllWzJdLFxuICAgICAgICB1cHggPSB1cFswXSxcbiAgICAgICAgdXB5ID0gdXBbMV0sXG4gICAgICAgIHVweiA9IHVwWzJdLFxuICAgICAgICBjZW50ZXJ4ID0gY2VudGVyWzBdLFxuICAgICAgICBjZW50ZXJ5ID0gY2VudGVyWzFdLFxuICAgICAgICBjZW50ZXJ6ID0gY2VudGVyWzJdO1xuXG4gICAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IEdMTUFUX0VQU0lMT04gJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleSAtIGNlbnRlcnkpIDwgR0xNQVRfRVBTSUxPTiAmJlxuICAgICAgICBNYXRoLmFicyhleWV6IC0gY2VudGVyeikgPCBHTE1BVF9FUFNJTE9OKSB7XG4gICAgICAgIHJldHVybiBtYXQ0LmlkZW50aXR5KG91dCk7XG4gICAgfVxuXG4gICAgejAgPSBleWV4IC0gY2VudGVyeDtcbiAgICB6MSA9IGV5ZXkgLSBjZW50ZXJ5O1xuICAgIHoyID0gZXlleiAtIGNlbnRlcno7XG5cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KHowICogejAgKyB6MSAqIHoxICsgejIgKiB6Mik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG5cbiAgICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyO1xuICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgICBsZW4gPSBNYXRoLnNxcnQoeDAgKiB4MCArIHgxICogeDEgKyB4MiAqIHgyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB4MCA9IDA7XG4gICAgICAgIHgxID0gMDtcbiAgICAgICAgeDIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHgwICo9IGxlbjtcbiAgICAgICAgeDEgKj0gbGVuO1xuICAgICAgICB4MiAqPSBsZW47XG4gICAgfVxuXG4gICAgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgICB5MSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICAgIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG5cbiAgICBsZW4gPSBNYXRoLnNxcnQoeTAgKiB5MCArIHkxICogeTEgKyB5MiAqIHkyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB5MCA9IDA7XG4gICAgICAgIHkxID0gMDtcbiAgICAgICAgeTIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHkwICo9IGxlbjtcbiAgICAgICAgeTEgKj0gbGVuO1xuICAgICAgICB5MiAqPSBsZW47XG4gICAgfVxuXG4gICAgb3V0WzBdID0geDA7XG4gICAgb3V0WzFdID0geTA7XG4gICAgb3V0WzJdID0gejA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4MTtcbiAgICBvdXRbNV0gPSB5MTtcbiAgICBvdXRbNl0gPSB6MTtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHgyO1xuICAgIG91dFs5XSA9IHkyO1xuICAgIG91dFsxMF0gPSB6MjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICAgIG91dFsxM10gPSAtKHkwICogZXlleCArIHkxICogZXlleSArIHkyICogZXlleik7XG4gICAgb3V0WzE0XSA9IC0oejAgKiBleWV4ICsgejEgKiBleWV5ICsgejIgKiBleWV6KTtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0NC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0NCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICBhWzRdICsgJywgJyArIGFbNV0gKyAnLCAnICsgYVs2XSArICcsICcgKyBhWzddICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIGFbOF0gKyAnLCAnICsgYVs5XSArICcsICcgKyBhWzEwXSArICcsICcgKyBhWzExXSArICcsICcgKyBcbiAgICAgICAgICAgICAgICAgICAgYVsxMl0gKyAnLCAnICsgYVsxM10gKyAnLCAnICsgYVsxNF0gKyAnLCAnICsgYVsxNV0gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQ0LmZyb2IgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgTWF0aC5wb3coYVs2XSwgMikgKyBNYXRoLnBvdyhhWzZdLCAyKSArIE1hdGgucG93KGFbN10sIDIpICsgTWF0aC5wb3coYVs4XSwgMikgKyBNYXRoLnBvdyhhWzldLCAyKSArIE1hdGgucG93KGFbMTBdLCAyKSArIE1hdGgucG93KGFbMTFdLCAyKSArIE1hdGgucG93KGFbMTJdLCAyKSArIE1hdGgucG93KGFbMTNdLCAyKSArIE1hdGgucG93KGFbMTRdLCAyKSArIE1hdGgucG93KGFbMTVdLCAyKSApKVxufTtcblxuXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5tYXQ0ID0gbWF0NDtcbn1cbjtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogQGNsYXNzIFF1YXRlcm5pb25cbiAqIEBuYW1lIHF1YXRcbiAqL1xuXG52YXIgcXVhdCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgcXVhdFxuICpcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKi9cbnF1YXQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0cyBhIHF1YXRlcm5pb24gdG8gcmVwcmVzZW50IHRoZSBzaG9ydGVzdCByb3RhdGlvbiBmcm9tIG9uZVxuICogdmVjdG9yIHRvIGFub3RoZXIuXG4gKlxuICogQm90aCB2ZWN0b3JzIGFyZSBhc3N1bWVkIHRvIGJlIHVuaXQgbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvbi5cbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgaW5pdGlhbCB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgZGVzdGluYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRpb25UbyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdG1wdmVjMyA9IHZlYzMuY3JlYXRlKCk7XG4gICAgdmFyIHhVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygxLDAsMCk7XG4gICAgdmFyIHlVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygwLDEsMCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgICAgIHZhciBkb3QgPSB2ZWMzLmRvdChhLCBiKTtcbiAgICAgICAgaWYgKGRvdCA8IC0wLjk5OTk5OSkge1xuICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCB4VW5pdFZlYzMsIGEpO1xuICAgICAgICAgICAgaWYgKHZlYzMubGVuZ3RoKHRtcHZlYzMpIDwgMC4wMDAwMDEpXG4gICAgICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCB5VW5pdFZlYzMsIGEpO1xuICAgICAgICAgICAgdmVjMy5ub3JtYWxpemUodG1wdmVjMywgdG1wdmVjMyk7XG4gICAgICAgICAgICBxdWF0LnNldEF4aXNBbmdsZShvdXQsIHRtcHZlYzMsIE1hdGguUEkpO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSBlbHNlIGlmIChkb3QgPiAwLjk5OTk5OSkge1xuICAgICAgICAgICAgb3V0WzBdID0gMDtcbiAgICAgICAgICAgIG91dFsxXSA9IDA7XG4gICAgICAgICAgICBvdXRbMl0gPSAwO1xuICAgICAgICAgICAgb3V0WzNdID0gMTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIGEsIGIpO1xuICAgICAgICAgICAgb3V0WzBdID0gdG1wdmVjM1swXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHRtcHZlYzNbMV07XG4gICAgICAgICAgICBvdXRbMl0gPSB0bXB2ZWMzWzJdO1xuICAgICAgICAgICAgb3V0WzNdID0gMSArIGRvdDtcbiAgICAgICAgICAgIHJldHVybiBxdWF0Lm5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzcGVjaWZpZWQgcXVhdGVybmlvbiB3aXRoIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlblxuICogYXhlcy4gRWFjaCBheGlzIGlzIGEgdmVjMyBhbmQgaXMgZXhwZWN0ZWQgdG8gYmUgdW5pdCBsZW5ndGggYW5kXG4gKiBwZXJwZW5kaWN1bGFyIHRvIGFsbCBvdGhlciBzcGVjaWZpZWQgYXhlcy5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IHZpZXcgIHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSB2aWV3aW5nIGRpcmVjdGlvblxuICogQHBhcmFtIHt2ZWMzfSByaWdodCB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJyaWdodFwiIGRpcmVjdGlvblxuICogQHBhcmFtIHt2ZWMzfSB1cCAgICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJ1cFwiIGRpcmVjdGlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnNldEF4ZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1hdHIgPSBtYXQzLmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG91dCwgdmlldywgcmlnaHQsIHVwKSB7XG4gICAgICAgIG1hdHJbMF0gPSByaWdodFswXTtcbiAgICAgICAgbWF0clszXSA9IHJpZ2h0WzFdO1xuICAgICAgICBtYXRyWzZdID0gcmlnaHRbMl07XG5cbiAgICAgICAgbWF0clsxXSA9IHVwWzBdO1xuICAgICAgICBtYXRyWzRdID0gdXBbMV07XG4gICAgICAgIG1hdHJbN10gPSB1cFsyXTtcblxuICAgICAgICBtYXRyWzJdID0gLXZpZXdbMF07XG4gICAgICAgIG1hdHJbNV0gPSAtdmlld1sxXTtcbiAgICAgICAgbWF0cls4XSA9IC12aWV3WzJdO1xuXG4gICAgICAgIHJldHVybiBxdWF0Lm5vcm1hbGl6ZShvdXQsIHF1YXQuZnJvbU1hdDMob3V0LCBtYXRyKSk7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuY2xvbmUgPSB2ZWM0LmNsb25lO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmZyb21WYWx1ZXMgPSB2ZWM0LmZyb21WYWx1ZXM7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHF1YXQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBzb3VyY2UgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuY29weSA9IHZlYzQuY29weTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBxdWF0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zZXQgPSB2ZWM0LnNldDtcblxuLyoqXG4gKiBTZXQgYSBxdWF0IHRvIHRoZSBpZGVudGl0eSBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldHMgYSBxdWF0IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFuZCByb3RhdGlvbiBheGlzLFxuICogdGhlbiByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIGFyb3VuZCB3aGljaCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqKi9cbnF1YXQuc2V0QXhpc0FuZ2xlID0gZnVuY3Rpb24ob3V0LCBheGlzLCByYWQpIHtcbiAgICByYWQgPSByYWQgKiAwLjU7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgIG91dFswXSA9IHMgKiBheGlzWzBdO1xuICAgIG91dFsxXSA9IHMgKiBheGlzWzFdO1xuICAgIG91dFsyXSA9IHMgKiBheGlzWzJdO1xuICAgIG91dFszXSA9IE1hdGguY29zKHJhZCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmFkZCA9IHZlYzQuYWRkO1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdLCBidyA9IGJbM107XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0Lm11bCA9IHF1YXQubXVsdGlwbHk7XG5cbi8qKlxuICogU2NhbGVzIGEgcXVhdCBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zY2FsZSA9IHZlYzQuc2NhbGU7XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVggPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYng7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF6ICogYng7XG4gICAgb3V0WzJdID0gYXogKiBidyAtIGF5ICogYng7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYng7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBZIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVkgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ5ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnk7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF4ICogYnk7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF5ICogYnk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBaIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVogPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ6ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF5ICogYno7XG4gICAgb3V0WzFdID0gYXkgKiBidyAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYno7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF6ICogYno7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgVyBjb21wb25lbnQgb2YgYSBxdWF0IGZyb20gdGhlIFgsIFksIGFuZCBaIGNvbXBvbmVudHMuXG4gKiBBc3N1bWVzIHRoYXQgcXVhdGVybmlvbiBpcyAxIHVuaXQgaW4gbGVuZ3RoLlxuICogQW55IGV4aXN0aW5nIFcgY29tcG9uZW50IHdpbGwgYmUgaWdub3JlZC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBXIGNvbXBvbmVudCBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmNhbGN1bGF0ZVcgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG5cbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSAtTWF0aC5zcXJ0KE1hdGguYWJzKDEuMCAtIHggKiB4IC0geSAqIHkgLSB6ICogeikpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmRvdCA9IHZlYzQuZG90O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmxlcnAgPSB2ZWM0LmxlcnA7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuc2xlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgLy8gYmVuY2htYXJrczpcbiAgICAvLyAgICBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXNsZXJwLWltcGxlbWVudGF0aW9uc1xuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXSwgYncgPSBiWzNdO1xuXG4gICAgdmFyICAgICAgICBvbWVnYSwgY29zb20sIHNpbm9tLCBzY2FsZTAsIHNjYWxlMTtcblxuICAgIC8vIGNhbGMgY29zaW5lXG4gICAgY29zb20gPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3O1xuICAgIC8vIGFkanVzdCBzaWducyAoaWYgbmVjZXNzYXJ5KVxuICAgIGlmICggY29zb20gPCAwLjAgKSB7XG4gICAgICAgIGNvc29tID0gLWNvc29tO1xuICAgICAgICBieCA9IC0gYng7XG4gICAgICAgIGJ5ID0gLSBieTtcbiAgICAgICAgYnogPSAtIGJ6O1xuICAgICAgICBidyA9IC0gYnc7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSBjb2VmZmljaWVudHNcbiAgICBpZiAoICgxLjAgLSBjb3NvbSkgPiAwLjAwMDAwMSApIHtcbiAgICAgICAgLy8gc3RhbmRhcmQgY2FzZSAoc2xlcnApXG4gICAgICAgIG9tZWdhICA9IE1hdGguYWNvcyhjb3NvbSk7XG4gICAgICAgIHNpbm9tICA9IE1hdGguc2luKG9tZWdhKTtcbiAgICAgICAgc2NhbGUwID0gTWF0aC5zaW4oKDEuMCAtIHQpICogb21lZ2EpIC8gc2lub207XG4gICAgICAgIHNjYWxlMSA9IE1hdGguc2luKHQgKiBvbWVnYSkgLyBzaW5vbTtcbiAgICB9IGVsc2UgeyAgICAgICAgXG4gICAgICAgIC8vIFwiZnJvbVwiIGFuZCBcInRvXCIgcXVhdGVybmlvbnMgYXJlIHZlcnkgY2xvc2UgXG4gICAgICAgIC8vICAuLi4gc28gd2UgY2FuIGRvIGEgbGluZWFyIGludGVycG9sYXRpb25cbiAgICAgICAgc2NhbGUwID0gMS4wIC0gdDtcbiAgICAgICAgc2NhbGUxID0gdDtcbiAgICB9XG4gICAgLy8gY2FsY3VsYXRlIGZpbmFsIHZhbHVlc1xuICAgIG91dFswXSA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XG4gICAgb3V0WzFdID0gc2NhbGUwICogYXkgKyBzY2FsZTEgKiBieTtcbiAgICBvdXRbMl0gPSBzY2FsZTAgKiBheiArIHNjYWxlMSAqIGJ6O1xuICAgIG91dFszXSA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgaW52ZXJzZSBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBpbnZlcnNlIG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcbiAgICAgICAgZG90ID0gYTAqYTAgKyBhMSphMSArIGEyKmEyICsgYTMqYTMsXG4gICAgICAgIGludkRvdCA9IGRvdCA/IDEuMC9kb3QgOiAwO1xuICAgIFxuICAgIC8vIFRPRE86IFdvdWxkIGJlIGZhc3RlciB0byByZXR1cm4gWzAsMCwwLDBdIGltbWVkaWF0ZWx5IGlmIGRvdCA9PSAwXG5cbiAgICBvdXRbMF0gPSAtYTAqaW52RG90O1xuICAgIG91dFsxXSA9IC1hMSppbnZEb3Q7XG4gICAgb3V0WzJdID0gLWEyKmludkRvdDtcbiAgICBvdXRbM10gPSBhMyppbnZEb3Q7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgY29uanVnYXRlIG9mIGEgcXVhdFxuICogSWYgdGhlIHF1YXRlcm5pb24gaXMgbm9ybWFsaXplZCwgdGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBxdWF0LmludmVyc2UgYW5kIHByb2R1Y2VzIHRoZSBzYW1lIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBjb25qdWdhdGUgb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5jb25qdWdhdGUgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubGVuZ3RoID0gdmVjNC5sZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmxlbiA9IHF1YXQubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zcXVhcmVkTGVuZ3RoID0gdmVjNC5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc3FyTGVuID0gcXVhdC5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubm9ybWFsaXplID0gdmVjNC5ub3JtYWxpemU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gM3gzIHJvdGF0aW9uIG1hdHJpeC5cbiAqXG4gKiBOT1RFOiBUaGUgcmVzdWx0YW50IHF1YXRlcm5pb24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIHlvdSBzaG91bGQgYmUgc3VyZVxuICogdG8gcmVub3JtYWxpemUgdGhlIHF1YXRlcm5pb24geW91cnNlbGYgd2hlcmUgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHttYXQzfSBtIHJvdGF0aW9uIG1hdHJpeFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuZnJvbU1hdDMgPSBmdW5jdGlvbihvdXQsIG0pIHtcbiAgICAvLyBBbGdvcml0aG0gaW4gS2VuIFNob2VtYWtlJ3MgYXJ0aWNsZSBpbiAxOTg3IFNJR0dSQVBIIGNvdXJzZSBub3Rlc1xuICAgIC8vIGFydGljbGUgXCJRdWF0ZXJuaW9uIENhbGN1bHVzIGFuZCBGYXN0IEFuaW1hdGlvblwiLlxuICAgIHZhciBmVHJhY2UgPSBtWzBdICsgbVs0XSArIG1bOF07XG4gICAgdmFyIGZSb290O1xuXG4gICAgaWYgKCBmVHJhY2UgPiAwLjAgKSB7XG4gICAgICAgIC8vIHx3fCA+IDEvMiwgbWF5IGFzIHdlbGwgY2hvb3NlIHcgPiAxLzJcbiAgICAgICAgZlJvb3QgPSBNYXRoLnNxcnQoZlRyYWNlICsgMS4wKTsgIC8vIDJ3XG4gICAgICAgIG91dFszXSA9IDAuNSAqIGZSb290O1xuICAgICAgICBmUm9vdCA9IDAuNS9mUm9vdDsgIC8vIDEvKDR3KVxuICAgICAgICBvdXRbMF0gPSAobVs3XS1tWzVdKSpmUm9vdDtcbiAgICAgICAgb3V0WzFdID0gKG1bMl0tbVs2XSkqZlJvb3Q7XG4gICAgICAgIG91dFsyXSA9IChtWzNdLW1bMV0pKmZSb290O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHx3fCA8PSAxLzJcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBpZiAoIG1bNF0gPiBtWzBdIClcbiAgICAgICAgICBpID0gMTtcbiAgICAgICAgaWYgKCBtWzhdID4gbVtpKjMraV0gKVxuICAgICAgICAgIGkgPSAyO1xuICAgICAgICB2YXIgaiA9IChpKzEpJTM7XG4gICAgICAgIHZhciBrID0gKGkrMiklMztcbiAgICAgICAgXG4gICAgICAgIGZSb290ID0gTWF0aC5zcXJ0KG1baSozK2ldLW1baiozK2pdLW1bayozK2tdICsgMS4wKTtcbiAgICAgICAgb3V0W2ldID0gMC41ICogZlJvb3Q7XG4gICAgICAgIGZSb290ID0gMC41IC8gZlJvb3Q7XG4gICAgICAgIG91dFszXSA9IChtW2sqMytqXSAtIG1baiozK2tdKSAqIGZSb290O1xuICAgICAgICBvdXRbal0gPSAobVtqKjMraV0gKyBtW2kqMytqXSkgKiBmUm9vdDtcbiAgICAgICAgb3V0W2tdID0gKG1bayozK2ldICsgbVtpKjMra10pICogZlJvb3Q7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBxdWF0ZW5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5xdWF0LnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdxdWF0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufTtcblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMucXVhdCA9IHF1YXQ7XG59XG47XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbiAgfSkoc2hpbS5leHBvcnRzKTtcbn0pKHRoaXMpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBwYXJzZUVycm9yc1xuXG5mdW5jdGlvbiBwYXJzZUVycm9ycyhsb2cpIHtcbiAgbG9nID0gU3RyaW5nKGxvZylcblxuICB2YXIgbG9ncyA9IFtdXG4gIHZhciByZXN1bHRcblxuICB3aGlsZSAocmVzdWx0ID0gbG9nLm1hdGNoKC9FUlJPUlxcOihbXlxcbl0rKS8pKSB7XG4gICAgbG9nID0gbG9nLnNsaWNlKHJlc3VsdC5pbmRleCArIDEpXG5cbiAgICB2YXIgbGluZSA9IHJlc3VsdFsxXS50cmltKClcbiAgICB2YXIgc2VwcyA9IGxpbmUuc3BsaXQoJzonKVxuICAgIHZhciBlbXNnID0gc2Vwcy5zbGljZSgyKS5qb2luKCc6JykudHJpbSgpXG4gICAgdmFyIGZpbGUgPSBwYXJzZUludChzZXBzWzBdLCAxMClcbiAgICB2YXIgbGluZSA9IHBhcnNlSW50KHNlcHNbMV0sIDEwKVxuXG4gICAgbG9ncy5wdXNoKHtcbiAgICAgICAgbWVzc2FnZTogZW1zZ1xuICAgICAgLCBmaWxlOiBmaWxlXG4gICAgICAsIGxpbmU6IGxpbmVcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIGxvZ3Ncbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgeWFtbCA9IHJlcXVpcmUoJy4vbGliL2pzLXlhbWwuanMnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHlhbWw7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGxvYWRlciA9IHJlcXVpcmUoJy4vanMteWFtbC9sb2FkZXInKTtcbnZhciBkdW1wZXIgPSByZXF1aXJlKCcuL2pzLXlhbWwvZHVtcGVyJyk7XG5cblxuZnVuY3Rpb24gZGVwcmVjYXRlZChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiAnICsgbmFtZSArICcgaXMgZGVwcmVjYXRlZCBhbmQgY2Fubm90IGJlIHVzZWQuJyk7XG4gIH07XG59XG5cblxubW9kdWxlLmV4cG9ydHMuVHlwZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC90eXBlJyk7XG5tb2R1bGUuZXhwb3J0cy5TY2hlbWEgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYScpO1xubW9kdWxlLmV4cG9ydHMuRkFJTFNBRkVfU0NIRU1BICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZmFpbHNhZmUnKTtcbm1vZHVsZS5leHBvcnRzLkpTT05fU0NIRU1BICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2pzb24nKTtcbm1vZHVsZS5leHBvcnRzLkNPUkVfU0NIRU1BICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfU0FGRV9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9GVUxMX1NDSEVNQSA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XG5tb2R1bGUuZXhwb3J0cy5sb2FkICAgICAgICAgICAgICAgID0gbG9hZGVyLmxvYWQ7XG5tb2R1bGUuZXhwb3J0cy5sb2FkQWxsICAgICAgICAgICAgID0gbG9hZGVyLmxvYWRBbGw7XG5tb2R1bGUuZXhwb3J0cy5zYWZlTG9hZCAgICAgICAgICAgID0gbG9hZGVyLnNhZmVMb2FkO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWRBbGwgICAgICAgICA9IGxvYWRlci5zYWZlTG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLmR1bXAgICAgICAgICAgICAgICAgPSBkdW1wZXIuZHVtcDtcbm1vZHVsZS5leHBvcnRzLnNhZmVEdW1wICAgICAgICAgICAgPSBkdW1wZXIuc2FmZUR1bXA7XG5tb2R1bGUuZXhwb3J0cy5ZQU1MRXhjZXB0aW9uICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL2V4Y2VwdGlvbicpO1xuXG4vLyBEZXByZWNhcmVkIHNjaGVtYSBuYW1lcyBmcm9tIEpTLVlBTUwgMi4wLnhcbm1vZHVsZS5leHBvcnRzLk1JTklNQUxfU0NIRU1BID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9mYWlsc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuU0FGRV9TQ0hFTUEgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xuXG4vLyBEZXByZWNhdGVkIGZ1bmN0aW9ucyBmcm9tIEpTLVlBTUwgMS54Lnhcbm1vZHVsZS5leHBvcnRzLnNjYW4gICAgICAgICAgID0gZGVwcmVjYXRlZCgnc2NhbicpO1xubW9kdWxlLmV4cG9ydHMucGFyc2UgICAgICAgICAgPSBkZXByZWNhdGVkKCdwYXJzZScpO1xubW9kdWxlLmV4cG9ydHMuY29tcG9zZSAgICAgICAgPSBkZXByZWNhdGVkKCdjb21wb3NlJyk7XG5tb2R1bGUuZXhwb3J0cy5hZGRDb25zdHJ1Y3RvciA9IGRlcHJlY2F0ZWQoJ2FkZENvbnN0cnVjdG9yJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gaXNOb3RoaW5nKHN1YmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygc3ViamVjdCA9PT0gJ3VuZGVmaW5lZCcpIHx8IChudWxsID09PSBzdWJqZWN0KTtcbn1cblxuXG5mdW5jdGlvbiBpc09iamVjdChzdWJqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnKSAmJiAobnVsbCAhPT0gc3ViamVjdCk7XG59XG5cblxuZnVuY3Rpb24gdG9BcnJheShzZXF1ZW5jZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzZXF1ZW5jZSkpIHtcbiAgICByZXR1cm4gc2VxdWVuY2U7XG4gIH0gZWxzZSBpZiAoaXNOb3RoaW5nKHNlcXVlbmNlKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gWyBzZXF1ZW5jZSBdO1xufVxuXG5cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICB2YXIgaW5kZXgsIGxlbmd0aCwga2V5LCBzb3VyY2VLZXlzO1xuXG4gIGlmIChzb3VyY2UpIHtcbiAgICBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBzb3VyY2VLZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaW5kZXhdO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIGNvdW50KSB7XG4gIHZhciByZXN1bHQgPSAnJywgY3ljbGU7XG5cbiAgZm9yIChjeWNsZSA9IDA7IGN5Y2xlIDwgY291bnQ7IGN5Y2xlICs9IDEpIHtcbiAgICByZXN1bHQgKz0gc3RyaW5nO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBpc05lZ2F0aXZlWmVybyhudW1iZXIpIHtcbiAgcmV0dXJuICgwID09PSBudW1iZXIpICYmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IDEgLyBudW1iZXIpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLmlzTm90aGluZyAgICAgID0gaXNOb3RoaW5nO1xubW9kdWxlLmV4cG9ydHMuaXNPYmplY3QgICAgICAgPSBpc09iamVjdDtcbm1vZHVsZS5leHBvcnRzLnRvQXJyYXkgICAgICAgID0gdG9BcnJheTtcbm1vZHVsZS5leHBvcnRzLnJlcGVhdCAgICAgICAgID0gcmVwZWF0O1xubW9kdWxlLmV4cG9ydHMuaXNOZWdhdGl2ZVplcm8gPSBpc05lZ2F0aXZlWmVybztcbm1vZHVsZS5leHBvcnRzLmV4dGVuZCAgICAgICAgID0gZXh0ZW5kO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lKi9cblxudmFyIGNvbW1vbiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIFlBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xudmFyIERFRkFVTFRfRlVMTF9TQ0hFTUEgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0X2Z1bGwnKTtcbnZhciBERUZBVUxUX1NBRkVfU0NIRU1BID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdF9zYWZlJyk7XG5cbnZhciBfdG9TdHJpbmcgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBDSEFSX1RBQiAgICAgICAgICAgICAgICAgID0gMHgwOTsgLyogVGFiICovXG52YXIgQ0hBUl9MSU5FX0ZFRUQgICAgICAgICAgICA9IDB4MEE7IC8qIExGICovXG52YXIgQ0hBUl9DQVJSSUFHRV9SRVRVUk4gICAgICA9IDB4MEQ7IC8qIENSICovXG52YXIgQ0hBUl9TUEFDRSAgICAgICAgICAgICAgICA9IDB4MjA7IC8qIFNwYWNlICovXG52YXIgQ0hBUl9FWENMQU1BVElPTiAgICAgICAgICA9IDB4MjE7IC8qICEgKi9cbnZhciBDSEFSX0RPVUJMRV9RVU9URSAgICAgICAgID0gMHgyMjsgLyogXCIgKi9cbnZhciBDSEFSX1NIQVJQICAgICAgICAgICAgICAgID0gMHgyMzsgLyogIyAqL1xudmFyIENIQVJfUEVSQ0VOVCAgICAgICAgICAgICAgPSAweDI1OyAvKiAlICovXG52YXIgQ0hBUl9BTVBFUlNBTkQgICAgICAgICAgICA9IDB4MjY7IC8qICYgKi9cbnZhciBDSEFSX1NJTkdMRV9RVU9URSAgICAgICAgID0gMHgyNzsgLyogJyAqL1xudmFyIENIQVJfQVNURVJJU0sgICAgICAgICAgICAgPSAweDJBOyAvKiAqICovXG52YXIgQ0hBUl9DT01NQSAgICAgICAgICAgICAgICA9IDB4MkM7IC8qICwgKi9cbnZhciBDSEFSX01JTlVTICAgICAgICAgICAgICAgID0gMHgyRDsgLyogLSAqL1xudmFyIENIQVJfQ09MT04gICAgICAgICAgICAgICAgPSAweDNBOyAvKiA6ICovXG52YXIgQ0hBUl9HUkVBVEVSX1RIQU4gICAgICAgICA9IDB4M0U7IC8qID4gKi9cbnZhciBDSEFSX1FVRVNUSU9OICAgICAgICAgICAgID0gMHgzRjsgLyogPyAqL1xudmFyIENIQVJfQ09NTUVSQ0lBTF9BVCAgICAgICAgPSAweDQwOyAvKiBAICovXG52YXIgQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUICA9IDB4NUI7IC8qIFsgKi9cbnZhciBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUID0gMHg1RDsgLyogXSAqL1xudmFyIENIQVJfR1JBVkVfQUNDRU5UICAgICAgICAgPSAweDYwOyAvKiBgICovXG52YXIgQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVQgICA9IDB4N0I7IC8qIHsgKi9cbnZhciBDSEFSX1ZFUlRJQ0FMX0xJTkUgICAgICAgID0gMHg3QzsgLyogfCAqL1xudmFyIENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVCAgPSAweDdEOyAvKiB9ICovXG5cbnZhciBFU0NBUEVfU0VRVUVOQ0VTID0ge307XG5cbkVTQ0FQRV9TRVFVRU5DRVNbMHgwMF0gICA9ICdcXFxcMCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDddICAgPSAnXFxcXGEnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA4XSAgID0gJ1xcXFxiJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOV0gICA9ICdcXFxcdCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MEFdICAgPSAnXFxcXG4nO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBCXSAgID0gJ1xcXFx2JztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQ10gICA9ICdcXFxcZic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MERdICAgPSAnXFxcXHInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDFCXSAgID0gJ1xcXFxlJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMl0gICA9ICdcXFxcXCInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDVDXSAgID0gJ1xcXFxcXFxcJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHg4NV0gICA9ICdcXFxcTic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4QTBdICAgPSAnXFxcXF8nO1xuRVNDQVBFX1NFUVVFTkNFU1sweDIwMjhdID0gJ1xcXFxMJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI5XSA9ICdcXFxcUCc7XG5cbnZhciBERVBSRUNBVEVEX0JPT0xFQU5TX1NZTlRBWCA9IFtcbiAgJ3knLCAnWScsICd5ZXMnLCAnWWVzJywgJ1lFUycsICdvbicsICdPbicsICdPTicsXG4gICduJywgJ04nLCAnbm8nLCAnTm8nLCAnTk8nLCAnb2ZmJywgJ09mZicsICdPRkYnXG5dO1xuXG5mdW5jdGlvbiBjb21waWxlU3R5bGVNYXAoc2NoZW1hLCBtYXApIHtcbiAgdmFyIHJlc3VsdCwga2V5cywgaW5kZXgsIGxlbmd0aCwgdGFnLCBzdHlsZSwgdHlwZTtcblxuICBpZiAobnVsbCA9PT0gbWFwKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgcmVzdWx0ID0ge307XG4gIGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0YWcgPSBrZXlzW2luZGV4XTtcbiAgICBzdHlsZSA9IFN0cmluZyhtYXBbdGFnXSk7XG5cbiAgICBpZiAoJyEhJyA9PT0gdGFnLnNsaWNlKDAsIDIpKSB7XG4gICAgICB0YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6JyArIHRhZy5zbGljZSgyKTtcbiAgICB9XG5cbiAgICB0eXBlID0gc2NoZW1hLmNvbXBpbGVkVHlwZU1hcFt0YWddO1xuXG4gICAgaWYgKHR5cGUgJiYgX2hhc093blByb3BlcnR5LmNhbGwodHlwZS5zdHlsZUFsaWFzZXMsIHN0eWxlKSkge1xuICAgICAgc3R5bGUgPSB0eXBlLnN0eWxlQWxpYXNlc1tzdHlsZV07XG4gICAgfVxuXG4gICAgcmVzdWx0W3RhZ10gPSBzdHlsZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUhleChjaGFyYWN0ZXIpIHtcbiAgdmFyIHN0cmluZywgaGFuZGxlLCBsZW5ndGg7XG5cbiAgc3RyaW5nID0gY2hhcmFjdGVyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXG4gIGlmIChjaGFyYWN0ZXIgPD0gMHhGRikge1xuICAgIGhhbmRsZSA9ICd4JztcbiAgICBsZW5ndGggPSAyO1xuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA8PSAweEZGRkYpIHtcbiAgICBoYW5kbGUgPSAndSc7XG4gICAgbGVuZ3RoID0gNDtcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPD0gMHhGRkZGRkZGRikge1xuICAgIGhhbmRsZSA9ICdVJztcbiAgICBsZW5ndGggPSA4O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdjb2RlIHBvaW50IHdpdGhpbiBhIHN0cmluZyBtYXkgbm90IGJlIGdyZWF0ZXIgdGhhbiAweEZGRkZGRkZGJyk7XG4gIH1cblxuICByZXR1cm4gJ1xcXFwnICsgaGFuZGxlICsgY29tbW9uLnJlcGVhdCgnMCcsIGxlbmd0aCAtIHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBTdGF0ZShvcHRpb25zKSB7XG4gIHRoaXMuc2NoZW1hICAgICAgPSBvcHRpb25zWydzY2hlbWEnXSB8fCBERUZBVUxUX0ZVTExfU0NIRU1BO1xuICB0aGlzLmluZGVudCAgICAgID0gTWF0aC5tYXgoMSwgKG9wdGlvbnNbJ2luZGVudCddIHx8IDIpKTtcbiAgdGhpcy5za2lwSW52YWxpZCA9IG9wdGlvbnNbJ3NraXBJbnZhbGlkJ10gfHwgZmFsc2U7XG4gIHRoaXMuZmxvd0xldmVsICAgPSAoY29tbW9uLmlzTm90aGluZyhvcHRpb25zWydmbG93TGV2ZWwnXSkgPyAtMSA6IG9wdGlvbnNbJ2Zsb3dMZXZlbCddKTtcbiAgdGhpcy5zdHlsZU1hcCAgICA9IGNvbXBpbGVTdHlsZU1hcCh0aGlzLnNjaGVtYSwgb3B0aW9uc1snc3R5bGVzJ10gfHwgbnVsbCk7XG4gIHRoaXMuc29ydEtleXMgICAgPSBvcHRpb25zWydzb3J0S2V5cyddIHx8IGZhbHNlO1xuXG4gIHRoaXMuaW1wbGljaXRUeXBlcyA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkSW1wbGljaXQ7XG4gIHRoaXMuZXhwbGljaXRUeXBlcyA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkRXhwbGljaXQ7XG5cbiAgdGhpcy50YWcgPSBudWxsO1xuICB0aGlzLnJlc3VsdCA9ICcnO1xuXG4gIHRoaXMuZHVwbGljYXRlcyA9IFtdO1xuICB0aGlzLnVzZWREdXBsaWNhdGVzID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaW5kZW50U3RyaW5nKHN0cmluZywgc3BhY2VzKSB7XG4gIHZhciBpbmQgPSBjb21tb24ucmVwZWF0KCcgJywgc3BhY2VzKSxcbiAgICAgIHBvc2l0aW9uID0gMCxcbiAgICAgIG5leHQgPSAtMSxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgbGluZSxcbiAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoKSB7XG4gICAgbmV4dCA9IHN0cmluZy5pbmRleE9mKCdcXG4nLCBwb3NpdGlvbik7XG4gICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICBsaW5lID0gc3RyaW5nLnNsaWNlKHBvc2l0aW9uKTtcbiAgICAgIHBvc2l0aW9uID0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lID0gc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBuZXh0ICsgMSk7XG4gICAgICBwb3NpdGlvbiA9IG5leHQgKyAxO1xuICAgIH1cbiAgICBpZiAobGluZS5sZW5ndGggJiYgbGluZSAhPT0gJ1xcbicpIHtcbiAgICAgIHJlc3VsdCArPSBpbmQ7XG4gICAgfVxuICAgIHJlc3VsdCArPSBsaW5lO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpIHtcbiAgcmV0dXJuICdcXG4nICsgY29tbW9uLnJlcGVhdCgnICcsIHN0YXRlLmluZGVudCAqIGxldmVsKTtcbn1cblxuZnVuY3Rpb24gdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBzdHIpIHtcbiAgdmFyIGluZGV4LCBsZW5ndGgsIHR5cGU7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHN0YXRlLmltcGxpY2l0VHlwZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHR5cGUgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzW2luZGV4XTtcblxuICAgIGlmICh0eXBlLnJlc29sdmUoc3RyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBTdHJpbmdCdWlsZGVyKHNvdXJjZSkge1xuICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgdGhpcy5yZXN1bHQgPSAnJztcbiAgdGhpcy5jaGVja3BvaW50ID0gMDtcbn1cblxuU3RyaW5nQnVpbGRlci5wcm90b3R5cGUudGFrZVVwVG8gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgdmFyIGVyO1xuXG4gIGlmIChwb3NpdGlvbiA8IHRoaXMuY2hlY2twb2ludCkge1xuICAgIGVyID0gbmV3IEVycm9yKCdwb3NpdGlvbiBzaG91bGQgYmUgPiBjaGVja3BvaW50Jyk7XG4gICAgZXIucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICBlci5jaGVja3BvaW50ID0gdGhpcy5jaGVja3BvaW50O1xuICAgIHRocm93IGVyO1xuICB9XG5cbiAgdGhpcy5yZXN1bHQgKz0gdGhpcy5zb3VyY2Uuc2xpY2UodGhpcy5jaGVja3BvaW50LCBwb3NpdGlvbik7XG4gIHRoaXMuY2hlY2twb2ludCA9IHBvc2l0aW9uO1xuICByZXR1cm4gdGhpcztcbn07XG5cblN0cmluZ0J1aWxkZXIucHJvdG90eXBlLmVzY2FwZUNoYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjaGFyYWN0ZXIsIGVzYztcblxuICBjaGFyYWN0ZXIgPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuY2hlY2twb2ludCk7XG4gIGVzYyA9IEVTQ0FQRV9TRVFVRU5DRVNbY2hhcmFjdGVyXSB8fCBlbmNvZGVIZXgoY2hhcmFjdGVyKTtcbiAgdGhpcy5yZXN1bHQgKz0gZXNjO1xuICB0aGlzLmNoZWNrcG9pbnQgKz0gMTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cblN0cmluZ0J1aWxkZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc291cmNlLmxlbmd0aCA+IHRoaXMuY2hlY2twb2ludCkge1xuICAgIHRoaXMudGFrZVVwVG8odGhpcy5zb3VyY2UubGVuZ3RoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVTY2FsYXIoc3RhdGUsIG9iamVjdCwgbGV2ZWwpIHtcbiAgdmFyIHNpbXBsZSwgZmlyc3QsIHNwYWNlV3JhcCwgZm9sZGVkLCBsaXRlcmFsLCBzaW5nbGUsIGRvdWJsZSxcbiAgICAgIHNhd0xpbmVGZWVkLCBsaW5lUG9zaXRpb24sIGxvbmdlc3RMaW5lLCBpbmRlbnQsIG1heCwgY2hhcmFjdGVyLFxuICAgICAgcG9zaXRpb24sIGVzY2FwZVNlcSwgaGV4RXNjLCBwcmV2aW91cywgbGluZUxlbmd0aCwgbW9kaWZpZXIsXG4gICAgICB0cmFpbGluZ0xpbmVCcmVha3MsIHJlc3VsdDtcblxuICBpZiAoMCA9PT0gb2JqZWN0Lmxlbmd0aCkge1xuICAgIHN0YXRlLmR1bXAgPSBcIicnXCI7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKC0xICE9PSBERVBSRUNBVEVEX0JPT0xFQU5TX1NZTlRBWC5pbmRleE9mKG9iamVjdCkpIHtcbiAgICBzdGF0ZS5kdW1wID0gXCInXCIgKyBvYmplY3QgKyBcIidcIjtcbiAgICByZXR1cm47XG4gIH1cblxuICBzaW1wbGUgPSB0cnVlO1xuICBmaXJzdCA9IG9iamVjdC5sZW5ndGggPyBvYmplY3QuY2hhckNvZGVBdCgwKSA6IDA7XG4gIHNwYWNlV3JhcCA9IChDSEFSX1NQQUNFID09PSBmaXJzdCB8fFxuICAgICAgICAgICAgICAgQ0hBUl9TUEFDRSA9PT0gb2JqZWN0LmNoYXJDb2RlQXQob2JqZWN0Lmxlbmd0aCAtIDEpKTtcblxuICAvLyBTaW1wbGlmaWVkIGNoZWNrIGZvciByZXN0cmljdGVkIGZpcnN0IGNoYXJhY3RlcnNcbiAgLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjbnMtcGxhaW4tZmlyc3QlMjhjJTI5XG4gIGlmIChDSEFSX01JTlVTICAgICAgICAgPT09IGZpcnN0IHx8XG4gICAgICBDSEFSX1FVRVNUSU9OICAgICAgPT09IGZpcnN0IHx8XG4gICAgICBDSEFSX0NPTU1FUkNJQUxfQVQgPT09IGZpcnN0IHx8XG4gICAgICBDSEFSX0dSQVZFX0FDQ0VOVCAgPT09IGZpcnN0KSB7XG4gICAgc2ltcGxlID0gZmFsc2U7XG4gIH1cblxuICAvLyBjYW4gb25seSB1c2UgPiBhbmQgfCBpZiBub3Qgd3JhcHBlZCBpbiBzcGFjZXMuXG4gIGlmIChzcGFjZVdyYXApIHtcbiAgICBzaW1wbGUgPSBmYWxzZTtcbiAgICBmb2xkZWQgPSBmYWxzZTtcbiAgICBsaXRlcmFsID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgZm9sZGVkID0gdHJ1ZTtcbiAgICBsaXRlcmFsID0gdHJ1ZTtcbiAgfVxuXG4gIHNpbmdsZSA9IHRydWU7XG4gIGRvdWJsZSA9IG5ldyBTdHJpbmdCdWlsZGVyKG9iamVjdCk7XG5cbiAgc2F3TGluZUZlZWQgPSBmYWxzZTtcbiAgbGluZVBvc2l0aW9uID0gMDtcbiAgbG9uZ2VzdExpbmUgPSAwO1xuXG4gIGluZGVudCA9IHN0YXRlLmluZGVudCAqIGxldmVsO1xuICBtYXggPSA4MDtcbiAgaWYgKGluZGVudCA8IDQwKSB7XG4gICAgbWF4IC09IGluZGVudDtcbiAgfSBlbHNlIHtcbiAgICBtYXggPSA0MDtcbiAgfVxuXG4gIGZvciAocG9zaXRpb24gPSAwOyBwb3NpdGlvbiA8IG9iamVjdC5sZW5ndGg7IHBvc2l0aW9uKyspIHtcbiAgICBjaGFyYWN0ZXIgPSBvYmplY3QuY2hhckNvZGVBdChwb3NpdGlvbik7XG4gICAgaWYgKHNpbXBsZSkge1xuICAgICAgLy8gQ2hhcmFjdGVycyB0aGF0IGNhbiBuZXZlciBhcHBlYXIgaW4gdGhlIHNpbXBsZSBzY2FsYXJcbiAgICAgIGlmICghc2ltcGxlQ2hhcihjaGFyYWN0ZXIpKSB7XG4gICAgICAgIHNpbXBsZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3RpbGwgc2ltcGxlLiAgSWYgd2UgbWFrZSBpdCBhbGwgdGhlIHdheSB0aHJvdWdoIGxpa2VcbiAgICAgICAgLy8gdGhpcywgdGhlbiB3ZSBjYW4ganVzdCBkdW1wIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaW5nbGUgJiYgY2hhcmFjdGVyID09PSBDSEFSX1NJTkdMRV9RVU9URSkge1xuICAgICAgc2luZ2xlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZXNjYXBlU2VxID0gRVNDQVBFX1NFUVVFTkNFU1tjaGFyYWN0ZXJdO1xuICAgIGhleEVzYyA9IG5lZWRzSGV4RXNjYXBlKGNoYXJhY3Rlcik7XG5cbiAgICBpZiAoIWVzY2FwZVNlcSAmJiAhaGV4RXNjKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY2hhcmFjdGVyICE9PSBDSEFSX0xJTkVfRkVFRCAmJlxuICAgICAgICBjaGFyYWN0ZXIgIT09IENIQVJfRE9VQkxFX1FVT1RFICYmXG4gICAgICAgIGNoYXJhY3RlciAhPT0gQ0hBUl9TSU5HTEVfUVVPVEUpIHtcbiAgICAgIGZvbGRlZCA9IGZhbHNlO1xuICAgICAgbGl0ZXJhbCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoY2hhcmFjdGVyID09PSBDSEFSX0xJTkVfRkVFRCkge1xuICAgICAgc2F3TGluZUZlZWQgPSB0cnVlO1xuICAgICAgc2luZ2xlID0gZmFsc2U7XG4gICAgICBpZiAocG9zaXRpb24gPiAwKSB7XG4gICAgICAgIHByZXZpb3VzID0gb2JqZWN0LmNoYXJDb2RlQXQocG9zaXRpb24gLSAxKTtcbiAgICAgICAgaWYgKHByZXZpb3VzID09PSBDSEFSX1NQQUNFKSB7XG4gICAgICAgICAgbGl0ZXJhbCA9IGZhbHNlO1xuICAgICAgICAgIGZvbGRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm9sZGVkKSB7XG4gICAgICAgIGxpbmVMZW5ndGggPSBwb3NpdGlvbiAtIGxpbmVQb3NpdGlvbjtcbiAgICAgICAgbGluZVBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIGlmIChsaW5lTGVuZ3RoID4gbG9uZ2VzdExpbmUpIHtcbiAgICAgICAgICBsb25nZXN0TGluZSA9IGxpbmVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2hhcmFjdGVyICE9PSBDSEFSX0RPVUJMRV9RVU9URSkge1xuICAgICAgc2luZ2xlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZG91YmxlLnRha2VVcFRvKHBvc2l0aW9uKTtcbiAgICBkb3VibGUuZXNjYXBlQ2hhcigpO1xuICB9XG5cbiAgaWYgKHNpbXBsZSAmJiB0ZXN0SW1wbGljaXRSZXNvbHZpbmcoc3RhdGUsIG9iamVjdCkpIHtcbiAgICBzaW1wbGUgPSBmYWxzZTtcbiAgfVxuXG4gIG1vZGlmaWVyID0gJyc7XG4gIGlmIChmb2xkZWQgfHwgbGl0ZXJhbCkge1xuICAgIHRyYWlsaW5nTGluZUJyZWFrcyA9IDA7XG4gICAgaWYgKG9iamVjdC5jaGFyQ29kZUF0KG9iamVjdC5sZW5ndGggLSAxKSA9PT0gQ0hBUl9MSU5FX0ZFRUQpIHtcbiAgICAgIHRyYWlsaW5nTGluZUJyZWFrcyArPSAxO1xuICAgICAgaWYgKG9iamVjdC5jaGFyQ29kZUF0KG9iamVjdC5sZW5ndGggLSAyKSA9PT0gQ0hBUl9MSU5FX0ZFRUQpIHtcbiAgICAgICAgdHJhaWxpbmdMaW5lQnJlYWtzICs9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRyYWlsaW5nTGluZUJyZWFrcyA9PT0gMCkge1xuICAgICAgbW9kaWZpZXIgPSAnLSc7XG4gICAgfSBlbHNlIGlmICh0cmFpbGluZ0xpbmVCcmVha3MgPT09IDIpIHtcbiAgICAgIG1vZGlmaWVyID0gJysnO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsaXRlcmFsICYmIGxvbmdlc3RMaW5lIDwgbWF4KSB7XG4gICAgZm9sZGVkID0gZmFsc2U7XG4gIH1cblxuICAvLyBJZiBpdCdzIGxpdGVyYWxseSBvbmUgbGluZSwgdGhlbiBkb24ndCBib3RoZXIgd2l0aCB0aGUgbGl0ZXJhbC5cbiAgLy8gV2UgbWF5IHN0aWxsIHdhbnQgdG8gZG8gYSBmb2xkLCB0aG91Z2gsIGlmIGl0J3MgYSBzdXBlciBsb25nIGxpbmUuXG4gIGlmICghc2F3TGluZUZlZWQpIHtcbiAgICBsaXRlcmFsID0gZmFsc2U7XG4gIH1cblxuICBpZiAoc2ltcGxlKSB7XG4gICAgc3RhdGUuZHVtcCA9IG9iamVjdDtcbiAgfSBlbHNlIGlmIChzaW5nbGUpIHtcbiAgICBzdGF0ZS5kdW1wID0gJ1xcJycgKyBvYmplY3QgKyAnXFwnJztcbiAgfSBlbHNlIGlmIChmb2xkZWQpIHtcbiAgICByZXN1bHQgPSBmb2xkKG9iamVjdCwgbWF4KTtcbiAgICBzdGF0ZS5kdW1wID0gJz4nICsgbW9kaWZpZXIgKyAnXFxuJyArIGluZGVudFN0cmluZyhyZXN1bHQsIGluZGVudCk7XG4gIH0gZWxzZSBpZiAobGl0ZXJhbCkge1xuICAgIGlmICghbW9kaWZpZXIpIHtcbiAgICAgIG9iamVjdCA9IG9iamVjdC5yZXBsYWNlKC9cXG4kLywgJycpO1xuICAgIH1cbiAgICBzdGF0ZS5kdW1wID0gJ3wnICsgbW9kaWZpZXIgKyAnXFxuJyArIGluZGVudFN0cmluZyhvYmplY3QsIGluZGVudCk7XG4gIH0gZWxzZSBpZiAoZG91YmxlKSB7XG4gICAgZG91YmxlLmZpbmlzaCgpO1xuICAgIHN0YXRlLmR1bXAgPSAnXCInICsgZG91YmxlLnJlc3VsdCArICdcIic7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZHVtcCBzY2FsYXIgdmFsdWUnKTtcbiAgfVxuXG4gIHJldHVybjtcbn1cblxuLy8gVGhlIGB0cmFpbGluZ2AgdmFyIGlzIGEgcmVnZXhwIG1hdGNoIG9mIGFueSB0cmFpbGluZyBgXFxuYCBjaGFyYWN0ZXJzLlxuLy9cbi8vIFRoZXJlIGFyZSB0aHJlZSBjYXNlcyB3ZSBjYXJlIGFib3V0OlxuLy9cbi8vIDEuIE9uZSB0cmFpbGluZyBgXFxuYCBvbiB0aGUgc3RyaW5nLiAgSnVzdCB1c2UgYHxgIG9yIGA+YC5cbi8vICAgIFRoaXMgaXMgdGhlIGFzc3VtZWQgZGVmYXVsdC4gKHRyYWlsaW5nID0gbnVsbClcbi8vIDIuIE5vIHRyYWlsaW5nIGBcXG5gIG9uIHRoZSBzdHJpbmcuICBVc2UgYHwtYCBvciBgPi1gIHRvIFwiY2hvbXBcIiB0aGUgZW5kLlxuLy8gMy4gTW9yZSB0aGFuIG9uZSB0cmFpbGluZyBgXFxuYCBvbiB0aGUgc3RyaW5nLiAgVXNlIGB8K2Agb3IgYD4rYC5cbi8vXG4vLyBJbiB0aGUgY2FzZSBvZiBgPitgLCB0aGVzZSBsaW5lIGJyZWFrcyBhcmUgKm5vdCogZG91YmxlZCAobGlrZSB0aGUgbGluZVxuLy8gYnJlYWtzIHdpdGhpbiB0aGUgc3RyaW5nKSwgc28gaXQncyBpbXBvcnRhbnQgdG8gb25seSBlbmQgd2l0aCB0aGUgZXhhY3Rcbi8vIHNhbWUgbnVtYmVyIGFzIHdlIHN0YXJ0ZWQuXG5mdW5jdGlvbiBmb2xkKG9iamVjdCwgbWF4KSB7XG4gIHZhciByZXN1bHQgPSAnJyxcbiAgICAgIHBvc2l0aW9uID0gMCxcbiAgICAgIGxlbmd0aCA9IG9iamVjdC5sZW5ndGgsXG4gICAgICB0cmFpbGluZyA9IC9cXG4rJC8uZXhlYyhvYmplY3QpLFxuICAgICAgbmV3TGluZTtcblxuICBpZiAodHJhaWxpbmcpIHtcbiAgICBsZW5ndGggPSB0cmFpbGluZy5pbmRleCArIDE7XG4gIH1cblxuICB3aGlsZSAocG9zaXRpb24gPCBsZW5ndGgpIHtcbiAgICBuZXdMaW5lID0gb2JqZWN0LmluZGV4T2YoJ1xcbicsIHBvc2l0aW9uKTtcbiAgICBpZiAobmV3TGluZSA+IGxlbmd0aCB8fCBuZXdMaW5lID09PSAtMSkge1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXN1bHQgKz0gJ1xcblxcbic7XG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gZm9sZExpbmUob2JqZWN0LnNsaWNlKHBvc2l0aW9uLCBsZW5ndGgpLCBtYXgpO1xuICAgICAgcG9zaXRpb24gPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0ICs9ICdcXG5cXG4nO1xuICAgICAgfVxuICAgICAgcmVzdWx0ICs9IGZvbGRMaW5lKG9iamVjdC5zbGljZShwb3NpdGlvbiwgbmV3TGluZSksIG1heCk7XG4gICAgICBwb3NpdGlvbiA9IG5ld0xpbmUgKyAxO1xuICAgIH1cbiAgfVxuICBpZiAodHJhaWxpbmcgJiYgdHJhaWxpbmdbMF0gIT09ICdcXG4nKSB7XG4gICAgcmVzdWx0ICs9IHRyYWlsaW5nWzBdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZm9sZExpbmUobGluZSwgbWF4KSB7XG4gIGlmIChsaW5lID09PSAnJykge1xuICAgIHJldHVybiBsaW5lO1xuICB9XG5cbiAgdmFyIGZvbGRSZSA9IC9bXlxcc10gW15cXHNdL2csXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIHByZXZNYXRjaCA9IDAsXG4gICAgICBmb2xkU3RhcnQgPSAwLFxuICAgICAgbWF0Y2ggPSBmb2xkUmUuZXhlYyhsaW5lKSxcbiAgICAgIGluZGV4LFxuICAgICAgZm9sZEVuZCxcbiAgICAgIGZvbGRlZDtcblxuICB3aGlsZSAobWF0Y2gpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuXG4gICAgLy8gd2hlbiB3ZSBjcm9zcyB0aGUgbWF4IGxlbiwgaWYgdGhlIHByZXZpb3VzIG1hdGNoIHdvdWxkJ3ZlXG4gICAgLy8gYmVlbiBvaywgdXNlIHRoYXQgb25lLCBhbmQgY2Fycnkgb24uICBJZiB0aGVyZSB3YXMgbm8gcHJldmlvdXNcbiAgICAvLyBtYXRjaCBvbiB0aGlzIGZvbGQgc2VjdGlvbiwgdGhlbiBqdXN0IGhhdmUgYSBsb25nIGxpbmUuXG4gICAgaWYgKGluZGV4IC0gZm9sZFN0YXJ0ID4gbWF4KSB7XG4gICAgICBpZiAocHJldk1hdGNoICE9PSBmb2xkU3RhcnQpIHtcbiAgICAgICAgZm9sZEVuZCA9IHByZXZNYXRjaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvbGRFbmQgPSBpbmRleDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICB9XG4gICAgICBmb2xkZWQgPSBsaW5lLnNsaWNlKGZvbGRTdGFydCwgZm9sZEVuZCk7XG4gICAgICByZXN1bHQgKz0gZm9sZGVkO1xuICAgICAgZm9sZFN0YXJ0ID0gZm9sZEVuZCArIDE7XG4gICAgfVxuICAgIHByZXZNYXRjaCA9IGluZGV4ICsgMTtcbiAgICBtYXRjaCA9IGZvbGRSZS5leGVjKGxpbmUpO1xuICB9XG5cbiAgaWYgKHJlc3VsdCkge1xuICAgIHJlc3VsdCArPSAnXFxuJztcbiAgfVxuXG4gIC8vIGlmIHdlIGVuZCB1cCB3aXRoIG9uZSBsYXN0IHdvcmQgYXQgdGhlIGVuZCwgdGhlbiB0aGUgbGFzdCBiaXQgbWlnaHRcbiAgLy8gYmUgc2xpZ2h0bHkgYmlnZ2VyIHRoYW4gd2Ugd2FudGVkLCBiZWNhdXNlIHdlIGV4aXRlZCBvdXQgb2YgdGhlIGxvb3AuXG4gIGlmIChmb2xkU3RhcnQgIT09IHByZXZNYXRjaCAmJiBsaW5lLmxlbmd0aCAtIGZvbGRTdGFydCA+IG1heCkge1xuICAgIHJlc3VsdCArPSBsaW5lLnNsaWNlKGZvbGRTdGFydCwgcHJldk1hdGNoKSArICdcXG4nICtcbiAgICAgICAgICAgICAgbGluZS5zbGljZShwcmV2TWF0Y2ggKyAxKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgKz0gbGluZS5zbGljZShmb2xkU3RhcnQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gUmV0dXJucyB0cnVlIGlmIGNoYXJhY3RlciBjYW4gYmUgZm91bmQgaW4gYSBzaW1wbGUgc2NhbGFyXG5mdW5jdGlvbiBzaW1wbGVDaGFyKGNoYXJhY3Rlcikge1xuICByZXR1cm4gQ0hBUl9UQUIgICAgICAgICAgICAgICAgICAhPT0gY2hhcmFjdGVyICYmXG4gICAgICAgICBDSEFSX0xJTkVfRkVFRCAgICAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcbiAgICAgICAgIENIQVJfQ0FSUklBR0VfUkVUVVJOICAgICAgIT09IGNoYXJhY3RlciAmJlxuICAgICAgICAgQ0hBUl9DT01NQSAgICAgICAgICAgICAgICAhPT0gY2hhcmFjdGVyICYmXG4gICAgICAgICBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQgICE9PSBjaGFyYWN0ZXIgJiZcbiAgICAgICAgIENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQgIT09IGNoYXJhY3RlciAmJlxuICAgICAgICAgQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVQgICAhPT0gY2hhcmFjdGVyICYmXG4gICAgICAgICBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgICE9PSBjaGFyYWN0ZXIgJiZcbiAgICAgICAgIENIQVJfU0hBUlAgICAgICAgICAgICAgICAgIT09IGNoYXJhY3RlciAmJlxuICAgICAgICAgQ0hBUl9BTVBFUlNBTkQgICAgICAgICAgICAhPT0gY2hhcmFjdGVyICYmXG4gICAgICAgICBDSEFSX0FTVEVSSVNLICAgICAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcbiAgICAgICAgIENIQVJfRVhDTEFNQVRJT04gICAgICAgICAgIT09IGNoYXJhY3RlciAmJlxuICAgICAgICAgQ0hBUl9WRVJUSUNBTF9MSU5FICAgICAgICAhPT0gY2hhcmFjdGVyICYmXG4gICAgICAgICBDSEFSX0dSRUFURVJfVEhBTiAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcbiAgICAgICAgIENIQVJfU0lOR0xFX1FVT1RFICAgICAgICAgIT09IGNoYXJhY3RlciAmJlxuICAgICAgICAgQ0hBUl9ET1VCTEVfUVVPVEUgICAgICAgICAhPT0gY2hhcmFjdGVyICYmXG4gICAgICAgICBDSEFSX1BFUkNFTlQgICAgICAgICAgICAgICE9PSBjaGFyYWN0ZXIgJiZcbiAgICAgICAgIENIQVJfQ09MT04gICAgICAgICAgICAgICAgIT09IGNoYXJhY3RlciAmJlxuICAgICAgICAgIUVTQ0FQRV9TRVFVRU5DRVNbY2hhcmFjdGVyXSAgICAgICAgICAgICYmXG4gICAgICAgICAhbmVlZHNIZXhFc2NhcGUoY2hhcmFjdGVyKTtcbn1cblxuLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBjaGFyYWN0ZXIgY29kZSBuZWVkcyB0byBiZSBlc2NhcGVkLlxuZnVuY3Rpb24gbmVlZHNIZXhFc2NhcGUoY2hhcmFjdGVyKSB7XG4gIHJldHVybiAhKCgweDAwMDIwIDw9IGNoYXJhY3RlciAmJiBjaGFyYWN0ZXIgPD0gMHgwMDAwN0UpIHx8XG4gICAgICAgICAgICgweDAwMDg1ID09PSBjaGFyYWN0ZXIpICAgICAgICAgICAgICAgICAgICAgICAgIHx8XG4gICAgICAgICAgICgweDAwMEEwIDw9IGNoYXJhY3RlciAmJiBjaGFyYWN0ZXIgPD0gMHgwMEQ3RkYpIHx8XG4gICAgICAgICAgICgweDBFMDAwIDw9IGNoYXJhY3RlciAmJiBjaGFyYWN0ZXIgPD0gMHgwMEZGRkQpIHx8XG4gICAgICAgICAgICgweDEwMDAwIDw9IGNoYXJhY3RlciAmJiBjaGFyYWN0ZXIgPD0gMHgxMEZGRkYpKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RbaW5kZXhdLCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBpZiAoMCAhPT0gaW5kZXgpIHtcbiAgICAgICAgX3Jlc3VsdCArPSAnLCAnO1xuICAgICAgfVxuICAgICAgX3Jlc3VsdCArPSBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSAnWycgKyBfcmVzdWx0ICsgJ10nO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJsb2NrU2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QsIGNvbXBhY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0W2luZGV4XSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgIGlmICghY29tcGFjdCB8fCAwICE9PSBpbmRleCkge1xuICAgICAgICBfcmVzdWx0ICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICAgIH1cbiAgICAgIF9yZXN1bHQgKz0gJy0gJyArIHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9IF9yZXN1bHQgfHwgJ1tdJzsgLy8gRW1wdHkgc2VxdWVuY2UgaWYgbm8gdmFsaWQgdmFsdWVzLlxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb3dNYXBwaW5nKHN0YXRlLCBsZXZlbCwgb2JqZWN0KSB7XG4gIHZhciBfcmVzdWx0ICAgICAgID0gJycsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9iamVjdEtleSxcbiAgICAgIG9iamVjdFZhbHVlLFxuICAgICAgcGFpckJ1ZmZlcjtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpckJ1ZmZlciA9ICcnO1xuXG4gICAgaWYgKDAgIT09IGluZGV4KSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICcsICc7XG4gICAgfVxuXG4gICAgb2JqZWN0S2V5ID0gb2JqZWN0S2V5TGlzdFtpbmRleF07XG4gICAgb2JqZWN0VmFsdWUgPSBvYmplY3Rbb2JqZWN0S2V5XTtcblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0S2V5LCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZHVtcC5sZW5ndGggPiAxMDI0KSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICc/ICc7XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wICsgJzogJztcblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0VmFsdWUsIGZhbHNlLCBmYWxzZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQgdmFsdWUuXG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgLy8gQm90aCBrZXkgYW5kIHZhbHVlIGFyZSB2YWxpZC5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gJ3snICsgX3Jlc3VsdCArICd9Jztcbn1cblxuZnVuY3Rpb24gd3JpdGVCbG9ja01hcHBpbmcoc3RhdGUsIGxldmVsLCBvYmplY3QsIGNvbXBhY3QpIHtcbiAgdmFyIF9yZXN1bHQgICAgICAgPSAnJyxcbiAgICAgIF90YWcgICAgICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgb2JqZWN0S2V5LFxuICAgICAgb2JqZWN0VmFsdWUsXG4gICAgICBleHBsaWNpdFBhaXIsXG4gICAgICBwYWlyQnVmZmVyO1xuXG4gIC8vIEFsbG93IHNvcnRpbmcga2V5cyBzbyB0aGF0IHRoZSBvdXRwdXQgZmlsZSBpcyBkZXRlcm1pbmlzdGljXG4gIGlmIChzdGF0ZS5zb3J0S2V5cyA9PT0gdHJ1ZSkge1xuICAgIC8vIERlZmF1bHQgc29ydGluZ1xuICAgIG9iamVjdEtleUxpc3Quc29ydCgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzdGF0ZS5zb3J0S2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEN1c3RvbSBzb3J0IGZ1bmN0aW9uXG4gICAgb2JqZWN0S2V5TGlzdC5zb3J0KHN0YXRlLnNvcnRLZXlzKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5zb3J0S2V5cykge1xuICAgIC8vIFNvbWV0aGluZyBpcyB3cm9uZ1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdzb3J0S2V5cyBtdXN0IGJlIGEgYm9vbGVhbiBvciBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpckJ1ZmZlciA9ICcnO1xuXG4gICAgaWYgKCFjb21wYWN0IHx8IDAgIT09IGluZGV4KSB7XG4gICAgICBwYWlyQnVmZmVyICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICB9XG5cbiAgICBvYmplY3RLZXkgPSBvYmplY3RLZXlMaXN0W2luZGV4XTtcbiAgICBvYmplY3RWYWx1ZSA9IG9iamVjdFtvYmplY3RLZXldO1xuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0S2V5LCB0cnVlLCB0cnVlKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCBrZXkuXG4gICAgfVxuXG4gICAgZXhwbGljaXRQYWlyID0gKG51bGwgIT09IHN0YXRlLnRhZyAmJiAnPycgIT09IHN0YXRlLnRhZykgfHxcbiAgICAgICAgICAgICAgICAgICAoc3RhdGUuZHVtcCAmJiBzdGF0ZS5kdW1wLmxlbmd0aCA+IDEwMjQpO1xuXG4gICAgaWYgKGV4cGxpY2l0UGFpcikge1xuICAgICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICBwYWlyQnVmZmVyICs9ICc/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhaXJCdWZmZXIgKz0gJz8gJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXA7XG5cbiAgICBpZiAoZXhwbGljaXRQYWlyKSB7XG4gICAgICBwYWlyQnVmZmVyICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICB9XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RWYWx1ZSwgdHJ1ZSwgZXhwbGljaXRQYWlyKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCB2YWx1ZS5cbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICc6JztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFpckJ1ZmZlciArPSAnOiAnO1xuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIC8vIEJvdGgga2V5IGFuZCB2YWx1ZSBhcmUgdmFsaWQuXG4gICAgX3Jlc3VsdCArPSBwYWlyQnVmZmVyO1xuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9IF9yZXN1bHQgfHwgJ3t9JzsgLy8gRW1wdHkgbWFwcGluZyBpZiBubyB2YWxpZCBwYWlycy5cbn1cblxuZnVuY3Rpb24gZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCBleHBsaWNpdCkge1xuICB2YXIgX3Jlc3VsdCwgdHlwZUxpc3QsIGluZGV4LCBsZW5ndGgsIHR5cGUsIHN0eWxlO1xuXG4gIHR5cGVMaXN0ID0gZXhwbGljaXQgPyBzdGF0ZS5leHBsaWNpdFR5cGVzIDogc3RhdGUuaW1wbGljaXRUeXBlcztcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdHlwZUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHR5cGUgPSB0eXBlTGlzdFtpbmRleF07XG5cbiAgICBpZiAoKHR5cGUuaW5zdGFuY2VPZiAgfHwgdHlwZS5wcmVkaWNhdGUpICYmXG4gICAgICAgICghdHlwZS5pbnN0YW5jZU9mIHx8ICgoJ29iamVjdCcgPT09IHR5cGVvZiBvYmplY3QpICYmIChvYmplY3QgaW5zdGFuY2VvZiB0eXBlLmluc3RhbmNlT2YpKSkgJiZcbiAgICAgICAgKCF0eXBlLnByZWRpY2F0ZSAgfHwgdHlwZS5wcmVkaWNhdGUob2JqZWN0KSkpIHtcblxuICAgICAgc3RhdGUudGFnID0gZXhwbGljaXQgPyB0eXBlLnRhZyA6ICc/JztcblxuICAgICAgaWYgKHR5cGUucmVwcmVzZW50KSB7XG4gICAgICAgIHN0eWxlID0gc3RhdGUuc3R5bGVNYXBbdHlwZS50YWddIHx8IHR5cGUuZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgIGlmICgnW29iamVjdCBGdW5jdGlvbl0nID09PSBfdG9TdHJpbmcuY2FsbCh0eXBlLnJlcHJlc2VudCkpIHtcbiAgICAgICAgICBfcmVzdWx0ID0gdHlwZS5yZXByZXNlbnQob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5LmNhbGwodHlwZS5yZXByZXNlbnQsIHN0eWxlKSkge1xuICAgICAgICAgIF9yZXN1bHQgPSB0eXBlLnJlcHJlc2VudFtzdHlsZV0ob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJyE8JyArIHR5cGUudGFnICsgJz4gdGFnIHJlc29sdmVyIGFjY2VwdHMgbm90IFwiJyArIHN0eWxlICsgJ1wiIHN0eWxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5kdW1wID0gX3Jlc3VsdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTZXJpYWxpemVzIGBvYmplY3RgIGFuZCB3cml0ZXMgaXQgdG8gZ2xvYmFsIGByZXN1bHRgLlxuLy8gUmV0dXJucyB0cnVlIG9uIHN1Y2Nlc3MsIG9yIGZhbHNlIG9uIGludmFsaWQgb2JqZWN0LlxuLy9cbmZ1bmN0aW9uIHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgYmxvY2ssIGNvbXBhY3QpIHtcbiAgc3RhdGUudGFnID0gbnVsbDtcbiAgc3RhdGUuZHVtcCA9IG9iamVjdDtcblxuICBpZiAoIWRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgZmFsc2UpKSB7XG4gICAgZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCB0cnVlKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gX3RvU3RyaW5nLmNhbGwoc3RhdGUuZHVtcCk7XG5cbiAgaWYgKGJsb2NrKSB7XG4gICAgYmxvY2sgPSAoMCA+IHN0YXRlLmZsb3dMZXZlbCB8fCBzdGF0ZS5mbG93TGV2ZWwgPiBsZXZlbCk7XG4gIH1cblxuICBpZiAoKG51bGwgIT09IHN0YXRlLnRhZyAmJiAnPycgIT09IHN0YXRlLnRhZykgfHwgKDIgIT09IHN0YXRlLmluZGVudCAmJiBsZXZlbCA+IDApKSB7XG4gICAgY29tcGFjdCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIG9iamVjdE9yQXJyYXkgPSAnW29iamVjdCBPYmplY3RdJyA9PT0gdHlwZSB8fCAnW29iamVjdCBBcnJheV0nID09PSB0eXBlLFxuICAgICAgZHVwbGljYXRlSW5kZXgsXG4gICAgICBkdXBsaWNhdGU7XG5cbiAgaWYgKG9iamVjdE9yQXJyYXkpIHtcbiAgICBkdXBsaWNhdGVJbmRleCA9IHN0YXRlLmR1cGxpY2F0ZXMuaW5kZXhPZihvYmplY3QpO1xuICAgIGR1cGxpY2F0ZSA9IGR1cGxpY2F0ZUluZGV4ICE9PSAtMTtcbiAgfVxuXG4gIGlmIChkdXBsaWNhdGUgJiYgc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdKSB7XG4gICAgc3RhdGUuZHVtcCA9ICcqcmVmXycgKyBkdXBsaWNhdGVJbmRleDtcbiAgfSBlbHNlIHtcbiAgICBpZiAob2JqZWN0T3JBcnJheSAmJiBkdXBsaWNhdGUgJiYgIXN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSkge1xuICAgICAgc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCdbb2JqZWN0IE9iamVjdF0nID09PSB0eXBlKSB7XG4gICAgICBpZiAoYmxvY2sgJiYgKDAgIT09IE9iamVjdC5rZXlzKHN0YXRlLmR1bXApLmxlbmd0aCkpIHtcbiAgICAgICAgd3JpdGVCbG9ja01hcHBpbmcoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyAoMCA9PT0gbGV2ZWwgPyAnXFxuJyA6ICcnKSArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvd01hcHBpbmcoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wKTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyAnICcgKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgnW29iamVjdCBBcnJheV0nID09PSB0eXBlKSB7XG4gICAgICBpZiAoYmxvY2sgJiYgKDAgIT09IHN0YXRlLmR1bXAubGVuZ3RoKSkge1xuICAgICAgICB3cml0ZUJsb2NrU2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyAoMCA9PT0gbGV2ZWwgPyAnXFxuJyA6ICcnKSArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvd1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJ1tvYmplY3QgU3RyaW5nXScgPT09IHR5cGUpIHtcbiAgICAgIGlmICgnPycgIT09IHN0YXRlLnRhZykge1xuICAgICAgICB3cml0ZVNjYWxhcihzdGF0ZSwgc3RhdGUuZHVtcCwgbGV2ZWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuc2tpcEludmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ3VuYWNjZXB0YWJsZSBraW5kIG9mIGFuIG9iamVjdCB0byBkdW1wICcgKyB0eXBlKTtcbiAgICB9XG5cbiAgICBpZiAobnVsbCAhPT0gc3RhdGUudGFnICYmICc/JyAhPT0gc3RhdGUudGFnKSB7XG4gICAgICBzdGF0ZS5kdW1wID0gJyE8JyArIHN0YXRlLnRhZyArICc+ICcgKyBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXREdXBsaWNhdGVSZWZlcmVuY2VzKG9iamVjdCwgc3RhdGUpIHtcbiAgdmFyIG9iamVjdHMgPSBbXSxcbiAgICAgIGR1cGxpY2F0ZXNJbmRleGVzID0gW10sXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBpbnNwZWN0Tm9kZShvYmplY3QsIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gZHVwbGljYXRlc0luZGV4ZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHN0YXRlLmR1cGxpY2F0ZXMucHVzaChvYmplY3RzW2R1cGxpY2F0ZXNJbmRleGVzW2luZGV4XV0pO1xuICB9XG4gIHN0YXRlLnVzZWREdXBsaWNhdGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3ROb2RlKG9iamVjdCwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpIHtcbiAgdmFyIHR5cGUgPSBfdG9TdHJpbmcuY2FsbChvYmplY3QpLFxuICAgICAgb2JqZWN0S2V5TGlzdCxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGlmIChudWxsICE9PSBvYmplY3QgJiYgJ29iamVjdCcgPT09IHR5cGVvZiBvYmplY3QpIHtcbiAgICBpbmRleCA9IG9iamVjdHMuaW5kZXhPZihvYmplY3QpO1xuICAgIGlmICgtMSAhPT0gaW5kZXgpIHtcbiAgICAgIGlmICgtMSA9PT0gZHVwbGljYXRlc0luZGV4ZXMuaW5kZXhPZihpbmRleCkpIHtcbiAgICAgICAgZHVwbGljYXRlc0luZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdHMucHVzaChvYmplY3QpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgIGluc3BlY3ROb2RlKG9iamVjdFtpbmRleF0sIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgIGluc3BlY3ROb2RlKG9iamVjdFtvYmplY3RLZXlMaXN0W2luZGV4XV0sIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkdW1wKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShvcHRpb25zKTtcblxuICBnZXREdXBsaWNhdGVSZWZlcmVuY2VzKGlucHV0LCBzdGF0ZSk7XG5cbiAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgMCwgaW5wdXQsIHRydWUsIHRydWUpKSB7XG4gICAgcmV0dXJuIHN0YXRlLmR1bXAgKyAnXFxuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIHNhZmVEdW1wKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkdW1wKGlucHV0LCBjb21tb24uZXh0ZW5kKHsgc2NoZW1hOiBERUZBVUxUX1NBRkVfU0NIRU1BIH0sIG9wdGlvbnMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZHVtcCAgICAgPSBkdW1wO1xubW9kdWxlLmV4cG9ydHMuc2FmZUR1bXAgPSBzYWZlRHVtcDtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBZQU1MRXhjZXB0aW9uKHJlYXNvbiwgbWFyaykge1xuICB0aGlzLm5hbWUgICAgPSAnWUFNTEV4Y2VwdGlvbic7XG4gIHRoaXMucmVhc29uICA9IHJlYXNvbjtcbiAgdGhpcy5tYXJrICAgID0gbWFyaztcbiAgdGhpcy5tZXNzYWdlID0gdGhpcy50b1N0cmluZyhmYWxzZSk7XG59XG5cblxuWUFNTEV4Y2VwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhjb21wYWN0KSB7XG4gIHZhciByZXN1bHQ7XG5cbiAgcmVzdWx0ID0gJ0pTLVlBTUw6ICcgKyAodGhpcy5yZWFzb24gfHwgJyh1bmtub3duIHJlYXNvbiknKTtcblxuICBpZiAoIWNvbXBhY3QgJiYgdGhpcy5tYXJrKSB7XG4gICAgcmVzdWx0ICs9ICcgJyArIHRoaXMubWFyay50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBZQU1MRXhjZXB0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4sbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuXG52YXIgY29tbW9uICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgTWFyayAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vbWFyaycpO1xudmFyIERFRkFVTFRfU0FGRV9TQ0hFTUEgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0X3NhZmUnKTtcbnZhciBERUZBVUxUX0ZVTExfU0NIRU1BID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XG5cblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblxudmFyIENPTlRFWFRfRkxPV19JTiAgID0gMTtcbnZhciBDT05URVhUX0ZMT1dfT1VUICA9IDI7XG52YXIgQ09OVEVYVF9CTE9DS19JTiAgPSAzO1xudmFyIENPTlRFWFRfQkxPQ0tfT1VUID0gNDtcblxuXG52YXIgQ0hPTVBJTkdfQ0xJUCAgPSAxO1xudmFyIENIT01QSU5HX1NUUklQID0gMjtcbnZhciBDSE9NUElOR19LRUVQICA9IDM7XG5cblxudmFyIFBBVFRFUk5fTk9OX1BSSU5UQUJMRSAgICAgICAgID0gL1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRlxceDdGLVxceDg0XFx4ODYtXFx4OUZcXHVGRkZFXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vO1xudmFyIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTID0gL1tcXHg4NVxcdTIwMjhcXHUyMDI5XS87XG52YXIgUEFUVEVSTl9GTE9XX0lORElDQVRPUlMgICAgICAgPSAvWyxcXFtcXF1cXHtcXH1dLztcbnZhciBQQVRURVJOX1RBR19IQU5ETEUgICAgICAgICAgICA9IC9eKD86IXwhIXwhW2EtelxcLV0rISkkL2k7XG52YXIgUEFUVEVSTl9UQUdfVVJJICAgICAgICAgICAgICAgPSAvXig/OiF8W14sXFxbXFxdXFx7XFx9XSkoPzolWzAtOWEtZl17Mn18WzAtOWEtelxcLSM7XFwvXFw/OkAmPVxcK1xcJCxfXFwuIX5cXConXFwoXFwpXFxbXFxdXSkqJC9pO1xuXG5cbmZ1bmN0aW9uIGlzX0VPTChjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgwQS8qIExGICovKSB8fCAoYyA9PT0gMHgwRC8qIENSICovKTtcbn1cblxuZnVuY3Rpb24gaXNfV0hJVEVfU1BBQ0UoYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8IChjID09PSAweDIwLyogU3BhY2UgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19XU19PUl9FT0woYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgyMC8qIFNwYWNlICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MEEvKiBMRiAqLykgfHxcbiAgICAgICAgIChjID09PSAweDBELyogQ1IgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19GTE9XX0lORElDQVRPUihjKSB7XG4gIHJldHVybiAweDJDLyogLCAqLyA9PT0gYyB8fFxuICAgICAgICAgMHg1Qi8qIFsgKi8gPT09IGMgfHxcbiAgICAgICAgIDB4NUQvKiBdICovID09PSBjIHx8XG4gICAgICAgICAweDdCLyogeyAqLyA9PT0gYyB8fFxuICAgICAgICAgMHg3RC8qIH0gKi8gPT09IGM7XG59XG5cbmZ1bmN0aW9uIGZyb21IZXhDb2RlKGMpIHtcbiAgdmFyIGxjO1xuXG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cbiAgbGMgPSBjIHwgMHgyMDtcblxuICBpZiAoKDB4NjEvKiBhICovIDw9IGxjKSAmJiAobGMgPD0gMHg2Ni8qIGYgKi8pKSB7XG4gICAgcmV0dXJuIGxjIC0gMHg2MSArIDEwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVkSGV4TGVuKGMpIHtcbiAgaWYgKGMgPT09IDB4NzgvKiB4ICovKSB7IHJldHVybiAyOyB9XG4gIGlmIChjID09PSAweDc1LyogdSAqLykgeyByZXR1cm4gNDsgfVxuICBpZiAoYyA9PT0gMHg1NS8qIFUgKi8pIHsgcmV0dXJuIDg7IH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGZyb21EZWNpbWFsQ29kZShjKSB7XG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFc2NhcGVTZXF1ZW5jZShjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgzMC8qIDAgKi8pID8gJ1xceDAwJyA6XG4gICAgICAgIChjID09PSAweDYxLyogYSAqLykgPyAnXFx4MDcnIDpcbiAgICAgICAgKGMgPT09IDB4NjIvKiBiICovKSA/ICdcXHgwOCcgOlxuICAgICAgICAoYyA9PT0gMHg3NC8qIHQgKi8pID8gJ1xceDA5JyA6XG4gICAgICAgIChjID09PSAweDA5LyogVGFiICovKSA/ICdcXHgwOScgOlxuICAgICAgICAoYyA9PT0gMHg2RS8qIG4gKi8pID8gJ1xceDBBJyA6XG4gICAgICAgIChjID09PSAweDc2LyogdiAqLykgPyAnXFx4MEInIDpcbiAgICAgICAgKGMgPT09IDB4NjYvKiBmICovKSA/ICdcXHgwQycgOlxuICAgICAgICAoYyA9PT0gMHg3Mi8qIHIgKi8pID8gJ1xceDBEJyA6XG4gICAgICAgIChjID09PSAweDY1LyogZSAqLykgPyAnXFx4MUInIDpcbiAgICAgICAgKGMgPT09IDB4MjAvKiBTcGFjZSAqLykgPyAnICcgOlxuICAgICAgICAoYyA9PT0gMHgyMi8qIFwiICovKSA/ICdcXHgyMicgOlxuICAgICAgICAoYyA9PT0gMHgyRi8qIC8gKi8pID8gJy8nIDpcbiAgICAgICAgKGMgPT09IDB4NUMvKiBcXCAqLykgPyAnXFx4NUMnIDpcbiAgICAgICAgKGMgPT09IDB4NEUvKiBOICovKSA/ICdcXHg4NScgOlxuICAgICAgICAoYyA9PT0gMHg1Ri8qIF8gKi8pID8gJ1xceEEwJyA6XG4gICAgICAgIChjID09PSAweDRDLyogTCAqLykgPyAnXFx1MjAyOCcgOlxuICAgICAgICAoYyA9PT0gMHg1MC8qIFAgKi8pID8gJ1xcdTIwMjknIDogJyc7XG59XG5cbmZ1bmN0aW9uIGNoYXJGcm9tQ29kZXBvaW50KGMpIHtcbiAgaWYgKGMgPD0gMHhGRkZGKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gIH1cbiAgLy8gRW5jb2RlIFVURi0xNiBzdXJyb2dhdGUgcGFpclxuICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtMTYjQ29kZV9wb2ludHNfVS4yQjAxMDAwMF90b19VLjJCMTBGRkZGXG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAtIDB4MDEwMDAwKSA+PiAxMCkgKyAweEQ4MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoYyAtIDB4MDEwMDAwKSAmIDB4MDNGRikgKyAweERDMDApO1xufVxuXG52YXIgc2ltcGxlRXNjYXBlQ2hlY2sgPSBuZXcgQXJyYXkoMjU2KTsgLy8gaW50ZWdlciwgZm9yIGZhc3QgYWNjZXNzXG52YXIgc2ltcGxlRXNjYXBlTWFwID0gbmV3IEFycmF5KDI1Nik7XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gIHNpbXBsZUVzY2FwZUNoZWNrW2ldID0gc2ltcGxlRXNjYXBlU2VxdWVuY2UoaSkgPyAxIDogMDtcbiAgc2ltcGxlRXNjYXBlTWFwW2ldID0gc2ltcGxlRXNjYXBlU2VxdWVuY2UoaSk7XG59XG5cblxuZnVuY3Rpb24gU3RhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdGhpcy5pbnB1dCA9IGlucHV0O1xuXG4gIHRoaXMuZmlsZW5hbWUgID0gb3B0aW9uc1snZmlsZW5hbWUnXSAgfHwgbnVsbDtcbiAgdGhpcy5zY2hlbWEgICAgPSBvcHRpb25zWydzY2hlbWEnXSAgICB8fCBERUZBVUxUX0ZVTExfU0NIRU1BO1xuICB0aGlzLm9uV2FybmluZyA9IG9wdGlvbnNbJ29uV2FybmluZyddIHx8IG51bGw7XG4gIHRoaXMubGVnYWN5ICAgID0gb3B0aW9uc1snbGVnYWN5J10gICAgfHwgZmFsc2U7XG5cbiAgdGhpcy5pbXBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdDtcbiAgdGhpcy50eXBlTWFwICAgICAgID0gdGhpcy5zY2hlbWEuY29tcGlsZWRUeXBlTWFwO1xuXG4gIHRoaXMubGVuZ3RoICAgICA9IGlucHV0Lmxlbmd0aDtcbiAgdGhpcy5wb3NpdGlvbiAgID0gMDtcbiAgdGhpcy5saW5lICAgICAgID0gMDtcbiAgdGhpcy5saW5lU3RhcnQgID0gMDtcbiAgdGhpcy5saW5lSW5kZW50ID0gMDtcblxuICB0aGlzLmRvY3VtZW50cyA9IFtdO1xuXG4gIC8qXG4gIHRoaXMudmVyc2lvbjtcbiAgdGhpcy5jaGVja0xpbmVCcmVha3M7XG4gIHRoaXMudGFnTWFwO1xuICB0aGlzLmFuY2hvck1hcDtcbiAgdGhpcy50YWc7XG4gIHRoaXMuYW5jaG9yO1xuICB0aGlzLmtpbmQ7XG4gIHRoaXMucmVzdWx0OyovXG5cbn1cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSB7XG4gIHJldHVybiBuZXcgWUFNTEV4Y2VwdGlvbihcbiAgICBtZXNzYWdlLFxuICAgIG5ldyBNYXJrKHN0YXRlLmZpbGVuYW1lLCBzdGF0ZS5pbnB1dCwgc3RhdGUucG9zaXRpb24sIHN0YXRlLmxpbmUsIChzdGF0ZS5wb3NpdGlvbiAtIHN0YXRlLmxpbmVTdGFydCkpKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICB0aHJvdyBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dXYXJuaW5nKHN0YXRlLCBtZXNzYWdlKSB7XG4gIHZhciBlcnJvciA9IGdlbmVyYXRlRXJyb3Ioc3RhdGUsIG1lc3NhZ2UpO1xuXG4gIGlmIChzdGF0ZS5vbldhcm5pbmcpIHtcbiAgICBzdGF0ZS5vbldhcm5pbmcuY2FsbChudWxsLCBlcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuXG52YXIgZGlyZWN0aXZlSGFuZGxlcnMgPSB7XG5cbiAgWUFNTDogZnVuY3Rpb24gaGFuZGxlWWFtbERpcmVjdGl2ZShzdGF0ZSwgbmFtZSwgYXJncykge1xuXG4gICAgICB2YXIgbWF0Y2gsIG1ham9yLCBtaW5vcjtcblxuICAgICAgaWYgKG51bGwgIT09IHN0YXRlLnZlcnNpb24pIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mICVZQU1MIGRpcmVjdGl2ZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoMSAhPT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1lBTUwgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSBvbmUgYXJndW1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSAvXihbMC05XSspXFwuKFswLTldKykkLy5leGVjKGFyZ3NbMF0pO1xuXG4gICAgICBpZiAobnVsbCA9PT0gbWF0Y2gpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgYXJndW1lbnQgb2YgdGhlIFlBTUwgZGlyZWN0aXZlJyk7XG4gICAgICB9XG5cbiAgICAgIG1ham9yID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgIG1pbm9yID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKTtcblxuICAgICAgaWYgKDEgIT09IG1ham9yKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS52ZXJzaW9uID0gYXJnc1swXTtcbiAgICAgIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IChtaW5vciA8IDIpO1xuXG4gICAgICBpZiAoMSAhPT0gbWlub3IgJiYgMiAhPT0gbWlub3IpIHtcbiAgICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAndW5zdXBwb3J0ZWQgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgVEFHOiBmdW5jdGlvbiBoYW5kbGVUYWdEaXJlY3RpdmUoc3RhdGUsIG5hbWUsIGFyZ3MpIHtcblxuICAgICAgdmFyIGhhbmRsZSwgcHJlZml4O1xuXG4gICAgICBpZiAoMiAhPT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1RBRyBkaXJlY3RpdmUgYWNjZXB0cyBleGFjdGx5IHR3byBhcmd1bWVudHMnKTtcbiAgICAgIH1cblxuICAgICAgaGFuZGxlID0gYXJnc1swXTtcbiAgICAgIHByZWZpeCA9IGFyZ3NbMV07XG5cbiAgICAgIGlmICghUEFUVEVSTl9UQUdfSEFORExFLnRlc3QoaGFuZGxlKSkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgaGFuZGxlIChmaXJzdCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnRhZ01hcCwgaGFuZGxlKSkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGhlcmUgaXMgYSBwcmV2aW91c2x5IGRlY2xhcmVkIHN1ZmZpeCBmb3IgXCInICsgaGFuZGxlICsgJ1wiIHRhZyBoYW5kbGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFQQVRURVJOX1RBR19VUkkudGVzdChwcmVmaXgpKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIHRhZyBwcmVmaXggKHNlY29uZCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUudGFnTWFwW2hhbmRsZV0gPSBwcmVmaXg7XG4gICAgfVxufTtcblxuXG5mdW5jdGlvbiBjYXB0dXJlU2VnbWVudChzdGF0ZSwgc3RhcnQsIGVuZCwgY2hlY2tKc29uKSB7XG4gIHZhciBfcG9zaXRpb24sIF9sZW5ndGgsIF9jaGFyYWN0ZXIsIF9yZXN1bHQ7XG5cbiAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgX3Jlc3VsdCA9IHN0YXRlLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgaWYgKGNoZWNrSnNvbikge1xuICAgICAgZm9yIChfcG9zaXRpb24gPSAwLCBfbGVuZ3RoID0gX3Jlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgIF9wb3NpdGlvbiA8IF9sZW5ndGg7XG4gICAgICAgICAgIF9wb3NpdGlvbiArPSAxKSB7XG4gICAgICAgIF9jaGFyYWN0ZXIgPSBfcmVzdWx0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcbiAgICAgICAgaWYgKCEoMHgwOSA9PT0gX2NoYXJhY3RlciB8fFxuICAgICAgICAgICAgICAweDIwIDw9IF9jaGFyYWN0ZXIgJiYgX2NoYXJhY3RlciA8PSAweDEwRkZGRikpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgdmFsaWQgSlNPTiBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLnJlc3VsdCArPSBfcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlTWFwcGluZ3Moc3RhdGUsIGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgdmFyIHNvdXJjZUtleXMsIGtleSwgaW5kZXgsIHF1YW50aXR5O1xuXG4gIGlmICghY29tbW9uLmlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2Fubm90IG1lcmdlIG1hcHBpbmdzOyB0aGUgcHJvdmlkZWQgc291cmNlIG9iamVjdCBpcyB1bmFjY2VwdGFibGUnKTtcbiAgfVxuXG4gIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IHNvdXJjZUtleXMubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpbmRleF07XG5cbiAgICBpZiAoIV9oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc3RpbmF0aW9uLCBrZXkpKSB7XG4gICAgICBkZXN0aW5hdGlvbltrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKSB7XG4gIHZhciBpbmRleCwgcXVhbnRpdHk7XG5cbiAga2V5Tm9kZSA9IFN0cmluZyhrZXlOb2RlKTtcblxuICBpZiAobnVsbCA9PT0gX3Jlc3VsdCkge1xuICAgIF9yZXN1bHQgPSB7fTtcbiAgfVxuXG4gIGlmICgndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnID09PSBrZXlUYWcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZU5vZGUpKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSB2YWx1ZU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZVtpbmRleF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZU1hcHBpbmdzKHN0YXRlLCBfcmVzdWx0LCB2YWx1ZU5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBfcmVzdWx0W2tleU5vZGVdID0gdmFsdWVOb2RlO1xuICB9XG5cbiAgcmV0dXJuIF9yZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRMaW5lQnJlYWsoc3RhdGUpIHtcbiAgdmFyIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKDB4MEEvKiBMRiAqLyA9PT0gY2gpIHtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICB9IGVsc2UgaWYgKDB4MEQvKiBDUiAqLyA9PT0gY2gpIHtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgIGlmICgweDBBLyogTEYgKi8gPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYSBsaW5lIGJyZWFrIGlzIGV4cGVjdGVkJyk7XG4gIH1cblxuICBzdGF0ZS5saW5lICs9IDE7XG4gIHN0YXRlLmxpbmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xufVxuXG5mdW5jdGlvbiBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBhbGxvd0NvbW1lbnRzLCBjaGVja0luZGVudCkge1xuICB2YXIgbGluZUJyZWFrcyA9IDAsXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlICgwICE9PSBjaCkge1xuICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dDb21tZW50cyAmJiAweDIzLyogIyAqLyA9PT0gY2gpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfSB3aGlsZSAoY2ggIT09IDB4MEEvKiBMRiAqLyAmJiBjaCAhPT0gMHgwRC8qIENSICovICYmIDAgIT09IGNoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBsaW5lQnJlYWtzKys7XG4gICAgICBzdGF0ZS5saW5lSW5kZW50ID0gMDtcblxuICAgICAgd2hpbGUgKDB4MjAvKiBTcGFjZSAqLyA9PT0gY2gpIHtcbiAgICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICgtMSAhPT0gY2hlY2tJbmRlbnQgJiYgMCAhPT0gbGluZUJyZWFrcyAmJiBzdGF0ZS5saW5lSW5kZW50IDwgY2hlY2tJbmRlbnQpIHtcbiAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICdkZWZpY2llbnQgaW5kZW50YXRpb24nKTtcbiAgfVxuXG4gIHJldHVybiBsaW5lQnJlYWtzO1xufVxuXG5mdW5jdGlvbiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG5cbiAgLy8gQ29uZGl0aW9uIHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgaXMgdGVzdGVkXG4gIC8vIGluIHBhcmVudCBvbiBlYWNoIGNhbGwsIGZvciBlZmZpY2llbmN5LiBObyBuZWVkcyB0byB0ZXN0IGhlcmUgYWdhaW4uXG4gIGlmICgoMHgyRC8qIC0gKi8gPT09IGNoIHx8IDB4MkUvKiAuICovID09PSBjaCkgJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uICsgMSkgPT09IGNoICYmXG4gICAgICBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbiArIDIpID09PSBjaCkge1xuXG4gICAgX3Bvc2l0aW9uICs9IDM7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMCB8fCBpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIGNvdW50KSB7XG4gIGlmICgxID09PSBjb3VudCkge1xuICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gIH0gZWxzZSBpZiAoY291bnQgPiAxKSB7XG4gICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGNvdW50IC0gMSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiByZWFkUGxhaW5TY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQsIHdpdGhpbkZsb3dDb2xsZWN0aW9uKSB7XG4gIHZhciBwcmVjZWRpbmcsXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGFzUGVuZGluZ0NvbnRlbnQsXG4gICAgICBfbGluZSxcbiAgICAgIF9saW5lU3RhcnQsXG4gICAgICBfbGluZUluZGVudCxcbiAgICAgIF9raW5kID0gc3RhdGUua2luZCxcbiAgICAgIF9yZXN1bHQgPSBzdGF0ZS5yZXN1bHQsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChpc19XU19PUl9FT0woY2gpICAgICAgICAgICAgIHx8XG4gICAgICBpc19GTE9XX0lORElDQVRPUihjaCkgICAgICAgIHx8XG4gICAgICAweDIzLyogIyAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDI2LyogJiAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDJBLyogKiAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDIxLyogISAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDdDLyogfCAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDNFLyogPiAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDI3LyogJyAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDIyLyogXCIgKi8gICAgICAgICAgID09PSBjaCB8fFxuICAgICAgMHgyNS8qICUgKi8gICAgICAgICAgID09PSBjaCB8fFxuICAgICAgMHg0MC8qIEAgKi8gICAgICAgICAgID09PSBjaCB8fFxuICAgICAgMHg2MC8qIGAgKi8gICAgICAgICAgID09PSBjaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICgweDNGLyogPyAqLyA9PT0gY2ggfHwgMHgyRC8qIC0gKi8gPT09IGNoKSB7XG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpIHx8XG4gICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGZvbGxvd2luZykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG5cbiAgd2hpbGUgKDAgIT09IGNoKSB7XG4gICAgaWYgKDB4M0EvKiA6ICovID09PSBjaCkge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihmb2xsb3dpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgweDIzLyogIyAqLyA9PT0gY2gpIHtcbiAgICAgIHByZWNlZGluZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gLSAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChwcmVjZWRpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB8fFxuICAgICAgICAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgICBicmVhaztcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgX2xpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIF9saW5lSW5kZW50ID0gc3RhdGUubGluZUluZGVudDtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCAtMSk7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID49IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uID0gY2FwdHVyZUVuZDtcbiAgICAgICAgc3RhdGUubGluZSA9IF9saW5lO1xuICAgICAgICBzdGF0ZS5saW5lU3RhcnQgPSBfbGluZVN0YXJ0O1xuICAgICAgICBzdGF0ZS5saW5lSW5kZW50ID0gX2xpbmVJbmRlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nQ29udGVudCkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc3RhdGUubGluZSAtIF9saW5lKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbiArIDE7XG4gICAgfVxuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuXG4gIGlmIChzdGF0ZS5yZXN1bHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSBfa2luZDtcbiAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmICgweDI3LyogJyAqLyAhPT0gY2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBzdGF0ZS5wb3NpdGlvbisrO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKDAgIT09IChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSkge1xuICAgIGlmICgweDI3LyogJyAqLyA9PT0gY2gpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgaWYgKDB4MjcvKiAnICovID09PSBjaCkge1xuICAgICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCkpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgZG9jdW1lbnQgd2l0aGluIGEgc2luZ2xlIHF1b3RlZCBzY2FsYXInKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWREb3VibGVRdW90ZWRTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNhcHR1cmVTdGFydCxcbiAgICAgIGNhcHR1cmVFbmQsXG4gICAgICBoZXhMZW5ndGgsXG4gICAgICBoZXhSZXN1bHQsXG4gICAgICB0bXAsIHRtcEVzYyxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKDB4MjIvKiBcIiAqLyAhPT0gY2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBzdGF0ZS5wb3NpdGlvbisrO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKDAgIT09IChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSkge1xuICAgIGlmICgweDIyLyogXCIgKi8gPT09IGNoKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9IGVsc2UgaWYgKDB4NUMvKiBcXCAqLyA9PT0gY2gpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpO1xuXG4gICAgICAgIC8vIFRPRE86IHJld29yayB0byBpbmxpbmUgZm4gd2l0aCBubyB0eXBlIGNhc3Q/XG4gICAgICB9IGVsc2UgaWYgKGNoIDwgMjU2ICYmIHNpbXBsZUVzY2FwZUNoZWNrW2NoXSkge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gc2ltcGxlRXNjYXBlTWFwW2NoXTtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgICAgfSBlbHNlIGlmICgodG1wID0gZXNjYXBlZEhleExlbihjaCkpID4gMCkge1xuICAgICAgICBoZXhMZW5ndGggPSB0bXA7XG4gICAgICAgIGhleFJlc3VsdCA9IDA7XG5cbiAgICAgICAgZm9yICg7IGhleExlbmd0aCA+IDA7IGhleExlbmd0aC0tKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgICAgaWYgKCh0bXAgPSBmcm9tSGV4Q29kZShjaCkpID49IDApIHtcbiAgICAgICAgICAgIGhleFJlc3VsdCA9IChoZXhSZXN1bHQgPDwgNCkgKyB0bXA7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2V4cGVjdGVkIGhleGFkZWNpbWFsIGNoYXJhY3RlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjaGFyRnJvbUNvZGVwb2ludChoZXhSZXN1bHQpO1xuXG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmtub3duIGVzY2FwZSBzZXF1ZW5jZScpO1xuICAgICAgfVxuXG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBkb3VibGUgcXVvdGVkIHNjYWxhcicpO1xufVxuXG5mdW5jdGlvbiByZWFkRmxvd0NvbGxlY3Rpb24oc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIHJlYWROZXh0ID0gdHJ1ZSxcbiAgICAgIF9saW5lLFxuICAgICAgX3RhZyAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBfcmVzdWx0LFxuICAgICAgX2FuY2hvciAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICB0ZXJtaW5hdG9yLFxuICAgICAgaXNQYWlyLFxuICAgICAgaXNFeHBsaWNpdFBhaXIsXG4gICAgICBpc01hcHBpbmcsXG4gICAgICBrZXlOb2RlLFxuICAgICAga2V5VGFnLFxuICAgICAgdmFsdWVOb2RlLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4NUIvKiBbICovKSB7XG4gICAgdGVybWluYXRvciA9IDB4NUQ7LyogXSAqL1xuICAgIGlzTWFwcGluZyA9IGZhbHNlO1xuICAgIF9yZXN1bHQgPSBbXTtcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHg3Qi8qIHsgKi8pIHtcbiAgICB0ZXJtaW5hdG9yID0gMHg3RDsvKiB9ICovXG4gICAgaXNNYXBwaW5nID0gdHJ1ZTtcbiAgICBfcmVzdWx0ID0ge307XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG51bGwgIT09IHN0YXRlLmFuY2hvcikge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoMCAhPT0gY2gpIHtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IHRlcm1pbmF0b3IpIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgIHN0YXRlLmtpbmQgPSBpc01hcHBpbmcgPyAnbWFwcGluZycgOiAnc2VxdWVuY2UnO1xuICAgICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXJlYWROZXh0KSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbWlzc2VkIGNvbW1hIGJldHdlZW4gZmxvdyBjb2xsZWN0aW9uIGVudHJpZXMnKTtcbiAgICB9XG5cbiAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICBpc1BhaXIgPSBpc0V4cGxpY2l0UGFpciA9IGZhbHNlO1xuXG4gICAgaWYgKDB4M0YvKiA/ICovID09PSBjaCkge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcbiAgICAgICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfRkxPV19JTiwgZmFsc2UsIHRydWUpO1xuICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoaXNFeHBsaWNpdFBhaXIgfHwgc3RhdGUubGluZSA9PT0gX2xpbmUpICYmIDB4M0EvKiA6ICovID09PSBjaCkge1xuICAgICAgaXNQYWlyID0gdHJ1ZTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuICAgICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfRkxPV19JTiwgZmFsc2UsIHRydWUpO1xuICAgICAgdmFsdWVOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgIH1cblxuICAgIGlmIChpc01hcHBpbmcpIHtcbiAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKTtcbiAgICB9IGVsc2UgaWYgKGlzUGFpcikge1xuICAgICAgX3Jlc3VsdC5wdXNoKHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIG51bGwsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9yZXN1bHQucHVzaChrZXlOb2RlKTtcbiAgICB9XG5cbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoMHgyQy8qICwgKi8gPT09IGNoKSB7XG4gICAgICByZWFkTmV4dCA9IHRydWU7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlYWROZXh0ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgZmxvdyBjb2xsZWN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgY2FwdHVyZVN0YXJ0LFxuICAgICAgZm9sZGluZyxcbiAgICAgIGNob21waW5nICAgICAgID0gQ0hPTVBJTkdfQ0xJUCxcbiAgICAgIGRldGVjdGVkSW5kZW50ID0gZmFsc2UsXG4gICAgICB0ZXh0SW5kZW50ICAgICA9IG5vZGVJbmRlbnQsXG4gICAgICBlbXB0eUxpbmVzICAgICA9IDAsXG4gICAgICBhdE1vcmVJbmRlbnRlZCA9IGZhbHNlLFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4N0MvKiB8ICovKSB7XG4gICAgZm9sZGluZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDNFLyogPiAqLykge1xuICAgIGZvbGRpbmcgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG5cbiAgd2hpbGUgKDAgIT09IGNoKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKDB4MkIvKiArICovID09PSBjaCB8fCAweDJELyogLSAqLyA9PT0gY2gpIHtcbiAgICAgIGlmIChDSE9NUElOR19DTElQID09PSBjaG9tcGluZykge1xuICAgICAgICBjaG9tcGluZyA9ICgweDJCLyogKyAqLyA9PT0gY2gpID8gQ0hPTVBJTkdfS0VFUCA6IENIT01QSU5HX1NUUklQO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3JlcGVhdCBvZiBhIGNob21waW5nIG1vZGUgaWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgodG1wID0gZnJvbURlY2ltYWxDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgaWYgKHRtcCA9PT0gMCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGV4cGxpY2l0IGluZGVudGF0aW9uIHdpZHRoIG9mIGEgYmxvY2sgc2NhbGFyOyBpdCBjYW5ub3QgYmUgbGVzcyB0aGFuIG9uZScpO1xuICAgICAgfSBlbHNlIGlmICghZGV0ZWN0ZWRJbmRlbnQpIHtcbiAgICAgICAgdGV4dEluZGVudCA9IG5vZGVJbmRlbnQgKyB0bXAgLSAxO1xuICAgICAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAncmVwZWF0IG9mIGFuIGluZGVudGF0aW9uIHdpZHRoIGlkZW50aWZpZXInKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKTtcblxuICAgIGlmICgweDIzLyogIyAqLyA9PT0gY2gpIHtcbiAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKDAgIT09IGNoKSk7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKDAgIT09IGNoKSB7XG4gICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG4gICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgd2hpbGUgKCghZGV0ZWN0ZWRJbmRlbnQgfHwgc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpICYmXG4gICAgICAgICAgICgweDIwLyogU3BhY2UgKi8gPT09IGNoKSkge1xuICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmICghZGV0ZWN0ZWRJbmRlbnQgJiYgc3RhdGUubGluZUluZGVudCA+IHRleHRJbmRlbnQpIHtcbiAgICAgIHRleHRJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBlbXB0eUxpbmVzKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBFbmQgb2YgdGhlIHNjYWxhci5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpIHtcblxuICAgICAgLy8gUGVyZm9ybSB0aGUgY2hvbXBpbmcuXG4gICAgICBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0tFRVApIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMpO1xuICAgICAgfSBlbHNlIGlmIChjaG9tcGluZyA9PT0gQ0hPTVBJTkdfQ0xJUCkge1xuICAgICAgICBpZiAoZGV0ZWN0ZWRJbmRlbnQpIHsgLy8gaS5lLiBvbmx5IGlmIHRoZSBzY2FsYXIgaXMgbm90IGVtcHR5LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBCcmVhayB0aGlzIGB3aGlsZWAgY3ljbGUgYW5kIGdvIHRvIHRoZSBmdW5jaXRvbidzIGVwaWxvZ3VlLlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gRm9sZGVkIHN0eWxlOiB1c2UgZmFuY3kgcnVsZXMgdG8gaGFuZGxlIGxpbmUgYnJlYWtzLlxuICAgIGlmIChmb2xkaW5nKSB7XG5cbiAgICAgIC8vIExpbmVzIHN0YXJ0aW5nIHdpdGggd2hpdGUgc3BhY2UgY2hhcmFjdGVycyAobW9yZS1pbmRlbnRlZCBsaW5lcykgYXJlIG5vdCBmb2xkZWQuXG4gICAgICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGF0TW9yZUluZGVudGVkID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMgKyAxKTtcblxuICAgICAgLy8gRW5kIG9mIG1vcmUtaW5kZW50ZWQgYmxvY2suXG4gICAgICB9IGVsc2UgaWYgKGF0TW9yZUluZGVudGVkKSB7XG4gICAgICAgIGF0TW9yZUluZGVudGVkID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzICsgMSk7XG5cbiAgICAgIC8vIEp1c3Qgb25lIGxpbmUgYnJlYWsgLSBwZXJjZWl2ZSBhcyB0aGUgc2FtZSBsaW5lLlxuICAgICAgfSBlbHNlIGlmICgwID09PSBlbXB0eUxpbmVzKSB7XG4gICAgICAgIGlmIChkZXRlY3RlZEluZGVudCkgeyAvLyBpLmUuIG9ubHkgaWYgd2UgaGF2ZSBhbHJlYWR5IHJlYWQgc29tZSBzY2FsYXIgY29udGVudC5cbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gJyAnO1xuICAgICAgICB9XG5cbiAgICAgIC8vIFNldmVyYWwgbGluZSBicmVha3MgLSBwZXJjZWl2ZSBhcyBkaWZmZXJlbnQgbGluZXMuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZW1wdHlMaW5lcyk7XG4gICAgICB9XG5cbiAgICAvLyBMaXRlcmFsIHN0eWxlOiBqdXN0IGFkZCBleGFjdCBudW1iZXIgb2YgbGluZSBicmVha3MgYmV0d2VlbiBjb250ZW50IGxpbmVzLlxuICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWRJbmRlbnQpIHtcbiAgICAgIC8vIElmIGN1cnJlbnQgbGluZSBpc24ndCB0aGUgZmlyc3Qgb25lIC0gY291bnQgbGluZSBicmVhayBmcm9tIHRoZSBsYXN0IGNvbnRlbnQgbGluZS5cbiAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluIGNhc2Ugb2YgdGhlIGZpcnN0IGNvbnRlbnQgbGluZSAtIGNvdW50IG9ubHkgZW1wdHkgbGluZXMuXG4gICAgfVxuXG4gICAgZGV0ZWN0ZWRJbmRlbnQgPSB0cnVlO1xuICAgIGVtcHR5TGluZXMgPSAwO1xuICAgIGNhcHR1cmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgd2hpbGUgKCFpc19FT0woY2gpICYmICgwICE9PSBjaCkpIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBfbGluZSxcbiAgICAgIF90YWcgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9hbmNob3IgICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIF9yZXN1bHQgICA9IFtdLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgZGV0ZWN0ZWQgID0gZmFsc2UsXG4gICAgICBjaDtcblxuICBpZiAobnVsbCAhPT0gc3RhdGUuYW5jaG9yKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoMCAhPT0gY2gpIHtcblxuICAgIGlmICgweDJELyogLSAqLyAhPT0gY2gpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgIGlmICghaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgaWYgKHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKSkge1xuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPD0gbm9kZUluZGVudCkge1xuICAgICAgICBfcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9saW5lID0gc3RhdGUubGluZTtcbiAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19JTiwgZmFsc2UsIHRydWUpO1xuICAgIF9yZXN1bHQucHVzaChzdGF0ZS5yZXN1bHQpO1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSAmJiAoMCAhPT0gY2gpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgc2VxdWVuY2UgZW50cnknKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBub2RlSW5kZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoZGV0ZWN0ZWQpIHtcbiAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgc3RhdGUua2luZCA9ICdzZXF1ZW5jZSc7XG4gICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja01hcHBpbmcoc3RhdGUsIG5vZGVJbmRlbnQsIGZsb3dJbmRlbnQpIHtcbiAgdmFyIGZvbGxvd2luZyxcbiAgICAgIGFsbG93Q29tcGFjdCxcbiAgICAgIF9saW5lLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9hbmNob3IgICAgICAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBfcmVzdWx0ICAgICAgID0ge30sXG4gICAgICBrZXlUYWcgICAgICAgID0gbnVsbCxcbiAgICAgIGtleU5vZGUgICAgICAgPSBudWxsLFxuICAgICAgdmFsdWVOb2RlICAgICA9IG51bGwsXG4gICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2UsXG4gICAgICBkZXRlY3RlZCAgICAgID0gZmFsc2UsXG4gICAgICBjaDtcblxuICBpZiAobnVsbCAhPT0gc3RhdGUuYW5jaG9yKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoMCAhPT0gY2gpIHtcbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lOyAvLyBTYXZlIHRoZSBjdXJyZW50IGxpbmUuXG5cbiAgICAvL1xuICAgIC8vIEV4cGxpY2l0IG5vdGF0aW9uIGNhc2UuIFRoZXJlIGFyZSB0d28gc2VwYXJhdGUgYmxvY2tzOlxuICAgIC8vIGZpcnN0IGZvciB0aGUga2V5IChkZW5vdGVkIGJ5IFwiP1wiKSBhbmQgc2Vjb25kIGZvciB0aGUgdmFsdWUgKGRlbm90ZWQgYnkgXCI6XCIpXG4gICAgLy9cbiAgICBpZiAoKDB4M0YvKiA/ICovID09PSBjaCB8fCAweDNBLyogOiAqLyAgPT09IGNoKSAmJiBpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuXG4gICAgICBpZiAoMHgzRi8qID8gKi8gPT09IGNoKSB7XG4gICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwga2V5VGFnLCBrZXlOb2RlLCBudWxsKTtcbiAgICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgYXRFeHBsaWNpdEtleSA9IHRydWU7XG4gICAgICAgIGFsbG93Q29tcGFjdCA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAvLyBpLmUuIDB4M0EvKiA6ICovID09PSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGV4cGxpY2l0IGtleS5cbiAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICBhbGxvd0NvbXBhY3QgPSB0cnVlO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaW5jb21wbGV0ZSBleHBsaWNpdCBtYXBwaW5nIHBhaXI7IGEga2V5IG5vZGUgaXMgbWlzc2VkJyk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gICAgICBjaCA9IGZvbGxvd2luZztcblxuICAgIC8vXG4gICAgLy8gSW1wbGljaXQgbm90YXRpb24gY2FzZS4gRmxvdy1zdHlsZSBub2RlIGFzIHRoZSBrZXkgZmlyc3QsIHRoZW4gXCI6XCIsIGFuZCB0aGUgdmFsdWUuXG4gICAgLy9cbiAgICB9IGVsc2UgaWYgKGNvbXBvc2VOb2RlKHN0YXRlLCBmbG93SW5kZW50LCBDT05URVhUX0ZMT1dfT1VULCBmYWxzZSwgdHJ1ZSkpIHtcblxuICAgICAgaWYgKHN0YXRlLmxpbmUgPT09IF9saW5lKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgweDNBLyogOiAqLyA9PT0gY2gpIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAoIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdhIHdoaXRlc3BhY2UgY2hhcmFjdGVyIGlzIGV4cGVjdGVkIGFmdGVyIHRoZSBrZXktdmFsdWUgc2VwYXJhdG9yIHdpdGhpbiBhIGJsb2NrIG1hcHBpbmcnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwga2V5VGFnLCBrZXlOb2RlLCBudWxsKTtcbiAgICAgICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgICAgYWxsb3dDb21wYWN0ID0gZmFsc2U7XG4gICAgICAgICAga2V5VGFnID0gc3RhdGUudGFnO1xuICAgICAgICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG5cbiAgICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZCkge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW4gbm90IHJlYWQgYW4gaW1wbGljaXQgbWFwcGluZyBwYWlyOyBhIGNvbG9uIGlzIG1pc3NlZCcpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgICAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSByZXN1bHQgb2YgYGNvbXBvc2VOb2RlYC5cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKGRldGVjdGVkKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW4gbm90IHJlYWQgYSBibG9jayBtYXBwaW5nIGVudHJ5OyBhIG11bHRpbGluZSBrZXkgbWF5IG5vdCBiZSBhbiBpbXBsaWNpdCBrZXknKTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEtlZXAgdGhlIHJlc3VsdCBvZiBgY29tcG9zZU5vZGVgLlxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrOyAvLyBSZWFkaW5nIGlzIGRvbmUuIEdvIHRvIHRoZSBlcGlsb2d1ZS5cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIENvbW1vbiByZWFkaW5nIGNvZGUgZm9yIGJvdGggZXhwbGljaXQgYW5kIGltcGxpY2l0IG5vdGF0aW9ucy5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS5saW5lID09PSBfbGluZSB8fCBzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCkge1xuICAgICAgaWYgKGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0JMT0NLX09VVCwgdHJ1ZSwgYWxsb3dDb21wYWN0KSkge1xuICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYXRFeHBsaWNpdEtleSkge1xuICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSk7XG4gICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCAmJiAoMCAhPT0gY2gpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgbWFwcGluZyBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIEVwaWxvZ3VlLlxuICAvL1xuXG4gIC8vIFNwZWNpYWwgY2FzZTogbGFzdCBtYXBwaW5nJ3Mgbm9kZSBjb250YWlucyBvbmx5IHRoZSBrZXkgaW4gZXhwbGljaXQgbm90YXRpb24uXG4gIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwga2V5VGFnLCBrZXlOb2RlLCBudWxsKTtcbiAgfVxuXG4gIC8vIEV4cG9zZSB0aGUgcmVzdWx0aW5nIG1hcHBpbmcuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ21hcHBpbmcnO1xuICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gZGV0ZWN0ZWQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdQcm9wZXJ0eShzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLFxuICAgICAgaXNWZXJiYXRpbSA9IGZhbHNlLFxuICAgICAgaXNOYW1lZCAgICA9IGZhbHNlLFxuICAgICAgdGFnSGFuZGxlLFxuICAgICAgdGFnTmFtZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKDB4MjEvKiAhICovICE9PSBjaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChudWxsICE9PSBzdGF0ZS50YWcpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRpb24gb2YgYSB0YWcgcHJvcGVydHknKTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoMHgzQy8qIDwgKi8gPT09IGNoKSB7XG4gICAgaXNWZXJiYXRpbSA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIH0gZWxzZSBpZiAoMHgyMS8qICEgKi8gPT09IGNoKSB7XG4gICAgaXNOYW1lZCA9IHRydWU7XG4gICAgdGFnSGFuZGxlID0gJyEhJztcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgfSBlbHNlIHtcbiAgICB0YWdIYW5kbGUgPSAnISc7XG4gIH1cblxuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICBpZiAoaXNWZXJiYXRpbSkge1xuICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgd2hpbGUgKDAgIT09IGNoICYmIDB4M0UvKiA+ICovICE9PSBjaCk7XG5cbiAgICBpZiAoc3RhdGUucG9zaXRpb24gPCBzdGF0ZS5sZW5ndGgpIHtcbiAgICAgIHRhZ05hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgdmVyYmF0aW0gdGFnJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlICgwICE9PSBjaCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuXG4gICAgICBpZiAoMHgyMS8qICEgKi8gPT09IGNoKSB7XG4gICAgICAgIGlmICghaXNOYW1lZCkge1xuICAgICAgICAgIHRhZ0hhbmRsZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiAtIDEsIHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgICAgICBpZiAoIVBBVFRFUk5fVEFHX0hBTkRMRS50ZXN0KHRhZ0hhbmRsZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lZCB0YWcgaGFuZGxlIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVycycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlzTmFtZWQgPSB0cnVlO1xuICAgICAgICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBleGNsYW1hdGlvbiBtYXJrcycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICB0YWdOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoUEFUVEVSTl9GTE9XX0lORElDQVRPUlMudGVzdCh0YWdOYW1lKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBzdWZmaXggY2Fubm90IGNvbnRhaW4gZmxvdyBpbmRpY2F0b3IgY2hhcmFjdGVycycpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0YWdOYW1lICYmICFQQVRURVJOX1RBR19VUkkudGVzdCh0YWdOYW1lKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgbmFtZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnM6ICcgKyB0YWdOYW1lKTtcbiAgfVxuXG4gIGlmIChpc1ZlcmJhdGltKSB7XG4gICAgc3RhdGUudGFnID0gdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnRhZ01hcCwgdGFnSGFuZGxlKSkge1xuICAgIHN0YXRlLnRhZyA9IHN0YXRlLnRhZ01hcFt0YWdIYW5kbGVdICsgdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKCchJyA9PT0gdGFnSGFuZGxlKSB7XG4gICAgc3RhdGUudGFnID0gJyEnICsgdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKCchIScgPT09IHRhZ0hhbmRsZSkge1xuICAgIHN0YXRlLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjonICsgdGFnTmFtZTtcblxuICB9IGVsc2Uge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmRlY2xhcmVkIHRhZyBoYW5kbGUgXCInICsgdGFnSGFuZGxlICsgJ1wiJyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFuY2hvclByb3BlcnR5KHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmICgweDI2LyogJiAqLyAhPT0gY2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobnVsbCAhPT0gc3RhdGUuYW5jaG9yKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mIGFuIGFuY2hvciBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoMCAhPT0gY2ggJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYW5jaG9yIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIHN0YXRlLmFuY2hvciA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFsaWFzKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sIGFsaWFzLFxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoLFxuICAgICAgaW5wdXQgPSBzdGF0ZS5pbnB1dCxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKDB4MkEvKiAqICovICE9PSBjaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKDAgIT09IGNoICYmICFpc19XU19PUl9FT0woY2gpICYmICFpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IF9wb3NpdGlvbikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lIG9mIGFuIGFsaWFzIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIGFsaWFzID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKCFzdGF0ZS5hbmNob3JNYXAuaGFzT3duUHJvcGVydHkoYWxpYXMpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuaWRlbnRpZmllZCBhbGlhcyBcIicgKyBhbGlhcyArICdcIicpO1xuICB9XG5cbiAgc3RhdGUucmVzdWx0ID0gc3RhdGUuYW5jaG9yTWFwW2FsaWFzXTtcbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29tcG9zZU5vZGUoc3RhdGUsIHBhcmVudEluZGVudCwgbm9kZUNvbnRleHQsIGFsbG93VG9TZWVrLCBhbGxvd0NvbXBhY3QpIHtcbiAgdmFyIGFsbG93QmxvY2tTdHlsZXMsXG4gICAgICBhbGxvd0Jsb2NrU2NhbGFycyxcbiAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyxcbiAgICAgIGluZGVudFN0YXR1cyA9IDEsIC8vIDE6IHRoaXM+cGFyZW50LCAwOiB0aGlzPXBhcmVudCwgLTE6IHRoaXM8cGFyZW50XG4gICAgICBhdE5ld0xpbmUgID0gZmFsc2UsXG4gICAgICBoYXNDb250ZW50ID0gZmFsc2UsXG4gICAgICB0eXBlSW5kZXgsXG4gICAgICB0eXBlUXVhbnRpdHksXG4gICAgICB0eXBlLFxuICAgICAgZmxvd0luZGVudCxcbiAgICAgIGJsb2NrSW5kZW50LFxuICAgICAgX3Jlc3VsdDtcblxuICBzdGF0ZS50YWcgICAgPSBudWxsO1xuICBzdGF0ZS5hbmNob3IgPSBudWxsO1xuICBzdGF0ZS5raW5kICAgPSBudWxsO1xuICBzdGF0ZS5yZXN1bHQgPSBudWxsO1xuXG4gIGFsbG93QmxvY2tTdHlsZXMgPSBhbGxvd0Jsb2NrU2NhbGFycyA9IGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9XG4gICAgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0IHx8XG4gICAgQ09OVEVYVF9CTE9DS19JTiAgPT09IG5vZGVDb250ZXh0O1xuXG4gIGlmIChhbGxvd1RvU2Vlaykge1xuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGF0TmV3TGluZSA9IHRydWU7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICBpbmRlbnRTdGF0dXMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgxID09PSBpbmRlbnRTdGF0dXMpIHtcbiAgICB3aGlsZSAocmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB8fCByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpKSB7XG4gICAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICAgIGF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGFsbG93QmxvY2tTdHlsZXM7XG5cbiAgICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpbmRlbnRTdGF0dXMgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zKSB7XG4gICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYXROZXdMaW5lIHx8IGFsbG93Q29tcGFjdDtcbiAgfVxuXG4gIGlmICgxID09PSBpbmRlbnRTdGF0dXMgfHwgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0KSB7XG4gICAgaWYgKENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQgfHwgQ09OVEVYVF9GTE9XX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQgKyAxO1xuICAgIH1cblxuICAgIGJsb2NrSW5kZW50ID0gc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnQ7XG5cbiAgICBpZiAoMSA9PT0gaW5kZW50U3RhdHVzKSB7XG4gICAgICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmXG4gICAgICAgICAgKHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCkgfHxcbiAgICAgICAgICAgcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgYmxvY2tJbmRlbnQsIGZsb3dJbmRlbnQpKSB8fFxuICAgICAgICAgIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKGFsbG93QmxvY2tTY2FsYXJzICYmIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHx8XG4gICAgICAgICAgICByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSB8fFxuICAgICAgICAgICAgcmVhZERvdWJsZVF1b3RlZFNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRBbGlhcyhzdGF0ZSkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChudWxsICE9PSBzdGF0ZS50YWcgfHwgbnVsbCAhPT0gc3RhdGUuYW5jaG9yKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYWxpYXMgbm9kZSBzaG91bGQgbm90IGhhdmUgYW55IHByb3BlcnRpZXMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWFkUGxhaW5TY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAobnVsbCA9PT0gc3RhdGUudGFnKSB7XG4gICAgICAgICAgICBzdGF0ZS50YWcgPSAnPyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG51bGwgIT09IHN0YXRlLmFuY2hvcikge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgwID09PSBpbmRlbnRTdGF0dXMpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZTogYmxvY2sgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIHRvIGhhdmUgc2FtZSBpbmRlbnRhdGlvbiBsZXZlbCBhcyB0aGUgcGFyZW50LlxuICAgICAgLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyNzk5Nzg0XG4gICAgICBoYXNDb250ZW50ID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG51bGwgIT09IHN0YXRlLnRhZyAmJiAnIScgIT09IHN0YXRlLnRhZykge1xuICAgIGlmICgnPycgPT09IHN0YXRlLnRhZykge1xuICAgICAgZm9yICh0eXBlSW5kZXggPSAwLCB0eXBlUXVhbnRpdHkgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzLmxlbmd0aDtcbiAgICAgICAgICAgdHlwZUluZGV4IDwgdHlwZVF1YW50aXR5O1xuICAgICAgICAgICB0eXBlSW5kZXggKz0gMSkge1xuICAgICAgICB0eXBlID0gc3RhdGUuaW1wbGljaXRUeXBlc1t0eXBlSW5kZXhdO1xuXG4gICAgICAgIC8vIEltcGxpY2l0IHJlc29sdmluZyBpcyBub3QgYWxsb3dlZCBmb3Igbm9uLXNjYWxhciB0eXBlcywgYW5kICc/J1xuICAgICAgICAvLyBub24tc3BlY2lmaWMgdGFnIGlzIG9ubHkgYXNzaWduZWQgdG8gcGxhaW4gc2NhbGFycy4gU28sIGl0IGlzbid0XG4gICAgICAgIC8vIG5lZWRlZCB0byBjaGVjayBmb3IgJ2tpbmQnIGNvbmZvcm1pdHkuXG5cbiAgICAgICAgaWYgKHR5cGUucmVzb2x2ZShzdGF0ZS5yZXN1bHQpKSB7IC8vIGBzdGF0ZS5yZXN1bHRgIHVwZGF0ZWQgaW4gcmVzb2x2ZXIgaWYgbWF0Y2hlZFxuICAgICAgICAgIHN0YXRlLnJlc3VsdCA9IHR5cGUuY29uc3RydWN0KHN0YXRlLnJlc3VsdCk7XG4gICAgICAgICAgc3RhdGUudGFnID0gdHlwZS50YWc7XG4gICAgICAgICAgaWYgKG51bGwgIT09IHN0YXRlLmFuY2hvcikge1xuICAgICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS50eXBlTWFwLCBzdGF0ZS50YWcpKSB7XG4gICAgICB0eXBlID0gc3RhdGUudHlwZU1hcFtzdGF0ZS50YWddO1xuXG4gICAgICBpZiAobnVsbCAhPT0gc3RhdGUucmVzdWx0ICYmIHR5cGUua2luZCAhPT0gc3RhdGUua2luZCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIG5vZGUga2luZCBmb3IgITwnICsgc3RhdGUudGFnICsgJz4gdGFnOyBpdCBzaG91bGQgYmUgXCInICsgdHlwZS5raW5kICsgJ1wiLCBub3QgXCInICsgc3RhdGUua2luZCArICdcIicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXR5cGUucmVzb2x2ZShzdGF0ZS5yZXN1bHQpKSB7IC8vIGBzdGF0ZS5yZXN1bHRgIHVwZGF0ZWQgaW4gcmVzb2x2ZXIgaWYgbWF0Y2hlZFxuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2Fubm90IHJlc29sdmUgYSBub2RlIHdpdGggITwnICsgc3RhdGUudGFnICsgJz4gZXhwbGljaXQgdGFnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgPSB0eXBlLmNvbnN0cnVjdChzdGF0ZS5yZXN1bHQpO1xuICAgICAgICBpZiAobnVsbCAhPT0gc3RhdGUuYW5jaG9yKSB7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAndW5rbm93biB0YWcgITwnICsgc3RhdGUudGFnICsgJz4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbCAhPT0gc3RhdGUudGFnIHx8IG51bGwgIT09IHN0YXRlLmFuY2hvciB8fCBoYXNDb250ZW50O1xufVxuXG5mdW5jdGlvbiByZWFkRG9jdW1lbnQoc3RhdGUpIHtcbiAgdmFyIGRvY3VtZW50U3RhcnQgPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIF9wb3NpdGlvbixcbiAgICAgIGRpcmVjdGl2ZU5hbWUsXG4gICAgICBkaXJlY3RpdmVBcmdzLFxuICAgICAgaGFzRGlyZWN0aXZlcyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgc3RhdGUudmVyc2lvbiA9IG51bGw7XG4gIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IHN0YXRlLmxlZ2FjeTtcbiAgc3RhdGUudGFnTWFwID0ge307XG4gIHN0YXRlLmFuY2hvck1hcCA9IHt9O1xuXG4gIHdoaWxlICgwICE9PSAoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkpIHtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiAwIHx8IDB4MjUvKiAlICovICE9PSBjaCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgd2hpbGUgKDAgIT09IGNoICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgZGlyZWN0aXZlTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgIGRpcmVjdGl2ZUFyZ3MgPSBbXTtcblxuICAgIGlmIChkaXJlY3RpdmVOYW1lLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkaXJlY3RpdmUgbmFtZSBtdXN0IG5vdCBiZSBsZXNzIHRoYW4gb25lIGNoYXJhY3RlciBpbiBsZW5ndGgnKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoMCAhPT0gY2gpIHtcbiAgICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoMHgyMy8qICMgKi8gPT09IGNoKSB7XG4gICAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICAgIHdoaWxlICgwICE9PSBjaCAmJiAhaXNfRU9MKGNoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgICAgIHdoaWxlICgwICE9PSBjaCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGRpcmVjdGl2ZUFyZ3MucHVzaChzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKSk7XG4gICAgfVxuXG4gICAgaWYgKDAgIT09IGNoKSB7XG4gICAgICByZWFkTGluZUJyZWFrKHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoZGlyZWN0aXZlSGFuZGxlcnMsIGRpcmVjdGl2ZU5hbWUpKSB7XG4gICAgICBkaXJlY3RpdmVIYW5kbGVyc1tkaXJlY3RpdmVOYW1lXShzdGF0ZSwgZGlyZWN0aXZlTmFtZSwgZGlyZWN0aXZlQXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ3Vua25vd24gZG9jdW1lbnQgZGlyZWN0aXZlIFwiJyArIGRpcmVjdGl2ZU5hbWUgKyAnXCInKTtcbiAgICB9XG4gIH1cblxuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgaWYgKDAgPT09IHN0YXRlLmxpbmVJbmRlbnQgJiZcbiAgICAgIDB4MkQvKiAtICovID09PSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSAmJlxuICAgICAgMHgyRC8qIC0gKi8gPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKSAmJlxuICAgICAgMHgyRC8qIC0gKi8gPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAyKSkge1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIH0gZWxzZSBpZiAoaGFzRGlyZWN0aXZlcykge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkaXJlY3RpdmVzIGVuZCBtYXJrIGlzIGV4cGVjdGVkJyk7XG4gIH1cblxuICBjb21wb3NlTm9kZShzdGF0ZSwgc3RhdGUubGluZUluZGVudCAtIDEsIENPTlRFWFRfQkxPQ0tfT1VULCBmYWxzZSwgdHJ1ZSk7XG4gIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICBpZiAoc3RhdGUuY2hlY2tMaW5lQnJlYWtzICYmXG4gICAgICBQQVRURVJOX05PTl9BU0NJSV9MSU5FX0JSRUFLUy50ZXN0KHN0YXRlLmlucHV0LnNsaWNlKGRvY3VtZW50U3RhcnQsIHN0YXRlLnBvc2l0aW9uKSkpIHtcbiAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICdub24tQVNDSUkgbGluZSBicmVha3MgYXJlIGludGVycHJldGVkIGFzIGNvbnRlbnQnKTtcbiAgfVxuXG4gIHN0YXRlLmRvY3VtZW50cy5wdXNoKHN0YXRlLnJlc3VsdCk7XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuXG4gICAgaWYgKDB4MkUvKiAuICovID09PSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkge1xuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMztcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uIDwgKHN0YXRlLmxlbmd0aCAtIDEpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2VuZCBvZiB0aGUgc3RyZWFtIG9yIGEgZG9jdW1lbnQgc2VwYXJhdG9yIGlzIGV4cGVjdGVkJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG59XG5cblxuZnVuY3Rpb24gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucykge1xuICBpbnB1dCA9IFN0cmluZyhpbnB1dCk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbnB1dC5sZW5ndGggIT09IDApIHtcblxuICAgIC8vIEFkZCB0YWlsaW5nIGBcXG5gIGlmIG5vdCBleGlzdHNcbiAgICBpZiAoMHgwQS8qIExGICovICE9PSBpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpICYmXG4gICAgICAgIDB4MEQvKiBDUiAqLyAhPT0gaW5wdXQuY2hhckNvZGVBdChpbnB1dC5sZW5ndGggLSAxKSkge1xuICAgICAgaW5wdXQgKz0gJ1xcbic7XG4gICAgfVxuXG4gICAgLy8gU3RyaXAgQk9NXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgxKTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIGlmIChQQVRURVJOX05PTl9QUklOVEFCTEUudGVzdChzdGF0ZS5pbnB1dCkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGhlIHN0cmVhbSBjb250YWlucyBub24tcHJpbnRhYmxlIGNoYXJhY3RlcnMnKTtcbiAgfVxuXG4gIC8vIFVzZSAwIGFzIHN0cmluZyB0ZXJtaW5hdG9yLiBUaGF0IHNpZ25pZmljYW50bHkgc2ltcGxpZmllcyBib3VuZHMgY2hlY2suXG4gIHN0YXRlLmlucHV0ICs9ICdcXDAnO1xuXG4gIHdoaWxlICgweDIwLyogU3BhY2UgKi8gPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSB7XG4gICAgc3RhdGUubGluZUluZGVudCArPSAxO1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gIH1cblxuICB3aGlsZSAoc3RhdGUucG9zaXRpb24gPCAoc3RhdGUubGVuZ3RoIC0gMSkpIHtcbiAgICByZWFkRG9jdW1lbnQoc3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmRvY3VtZW50cztcbn1cblxuXG5mdW5jdGlvbiBsb2FkQWxsKGlucHV0LCBpdGVyYXRvciwgb3B0aW9ucykge1xuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyksIGluZGV4LCBsZW5ndGg7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGRvY3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgaXRlcmF0b3IoZG9jdW1lbnRzW2luZGV4XSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBsb2FkKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBkb2N1bWVudHMgPSBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKSwgaW5kZXgsIGxlbmd0aDtcblxuICBpZiAoMCA9PT0gZG9jdW1lbnRzLmxlbmd0aCkge1xuICAgIC8qZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkKi9cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKDEgPT09IGRvY3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnRzWzBdO1xuICB9XG4gIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdleHBlY3RlZCBhIHNpbmdsZSBkb2N1bWVudCBpbiB0aGUgc3RyZWFtLCBidXQgZm91bmQgbW9yZScpO1xufVxuXG5cbmZ1bmN0aW9uIHNhZmVMb2FkQWxsKGlucHV0LCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgbG9hZEFsbChpbnB1dCwgb3V0cHV0LCBjb21tb24uZXh0ZW5kKHsgc2NoZW1hOiBERUZBVUxUX1NBRkVfU0NIRU1BIH0sIG9wdGlvbnMpKTtcbn1cblxuXG5mdW5jdGlvbiBzYWZlTG9hZChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbG9hZChpbnB1dCwgY29tbW9uLmV4dGVuZCh7IHNjaGVtYTogREVGQVVMVF9TQUZFX1NDSEVNQSB9LCBvcHRpb25zKSk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMubG9hZEFsbCAgICAgPSBsb2FkQWxsO1xubW9kdWxlLmV4cG9ydHMubG9hZCAgICAgICAgPSBsb2FkO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWRBbGwgPSBzYWZlTG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLnNhZmVMb2FkICAgID0gc2FmZUxvYWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuZnVuY3Rpb24gTWFyayhuYW1lLCBidWZmZXIsIHBvc2l0aW9uLCBsaW5lLCBjb2x1bW4pIHtcbiAgdGhpcy5uYW1lICAgICA9IG5hbWU7XG4gIHRoaXMuYnVmZmVyICAgPSBidWZmZXI7XG4gIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgdGhpcy5saW5lICAgICA9IGxpbmU7XG4gIHRoaXMuY29sdW1uICAgPSBjb2x1bW47XG59XG5cblxuTWFyay5wcm90b3R5cGUuZ2V0U25pcHBldCA9IGZ1bmN0aW9uIGdldFNuaXBwZXQoaW5kZW50LCBtYXhMZW5ndGgpIHtcbiAgdmFyIGhlYWQsIHN0YXJ0LCB0YWlsLCBlbmQsIHNuaXBwZXQ7XG5cbiAgaWYgKCF0aGlzLmJ1ZmZlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaW5kZW50ID0gaW5kZW50IHx8IDQ7XG4gIG1heExlbmd0aCA9IG1heExlbmd0aCB8fCA3NTtcblxuICBoZWFkID0gJyc7XG4gIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbjtcblxuICB3aGlsZSAoc3RhcnQgPiAwICYmIC0xID09PSAnXFx4MDBcXHJcXG5cXHg4NVxcdTIwMjhcXHUyMDI5Jy5pbmRleE9mKHRoaXMuYnVmZmVyLmNoYXJBdChzdGFydCAtIDEpKSkge1xuICAgIHN0YXJ0IC09IDE7XG4gICAgaWYgKHRoaXMucG9zaXRpb24gLSBzdGFydCA+IChtYXhMZW5ndGggLyAyIC0gMSkpIHtcbiAgICAgIGhlYWQgPSAnIC4uLiAnO1xuICAgICAgc3RhcnQgKz0gNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRhaWwgPSAnJztcbiAgZW5kID0gdGhpcy5wb3NpdGlvbjtcblxuICB3aGlsZSAoZW5kIDwgdGhpcy5idWZmZXIubGVuZ3RoICYmIC0xID09PSAnXFx4MDBcXHJcXG5cXHg4NVxcdTIwMjhcXHUyMDI5Jy5pbmRleE9mKHRoaXMuYnVmZmVyLmNoYXJBdChlbmQpKSkge1xuICAgIGVuZCArPSAxO1xuICAgIGlmIChlbmQgLSB0aGlzLnBvc2l0aW9uID4gKG1heExlbmd0aCAvIDIgLSAxKSkge1xuICAgICAgdGFpbCA9ICcgLi4uICc7XG4gICAgICBlbmQgLT0gNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHNuaXBwZXQgPSB0aGlzLmJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTtcblxuICByZXR1cm4gY29tbW9uLnJlcGVhdCgnICcsIGluZGVudCkgKyBoZWFkICsgc25pcHBldCArIHRhaWwgKyAnXFxuJyArXG4gICAgICAgICBjb21tb24ucmVwZWF0KCcgJywgaW5kZW50ICsgdGhpcy5wb3NpdGlvbiAtIHN0YXJ0ICsgaGVhZC5sZW5ndGgpICsgJ14nO1xufTtcblxuXG5NYXJrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbXBhY3QpIHtcbiAgdmFyIHNuaXBwZXQsIHdoZXJlID0gJyc7XG5cbiAgaWYgKHRoaXMubmFtZSkge1xuICAgIHdoZXJlICs9ICdpbiBcIicgKyB0aGlzLm5hbWUgKyAnXCIgJztcbiAgfVxuXG4gIHdoZXJlICs9ICdhdCBsaW5lICcgKyAodGhpcy5saW5lICsgMSkgKyAnLCBjb2x1bW4gJyArICh0aGlzLmNvbHVtbiArIDEpO1xuXG4gIGlmICghY29tcGFjdCkge1xuICAgIHNuaXBwZXQgPSB0aGlzLmdldFNuaXBwZXQoKTtcblxuICAgIGlmIChzbmlwcGV0KSB7XG4gICAgICB3aGVyZSArPSAnOlxcbicgKyBzbmlwcGV0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3aGVyZTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBNYXJrO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xuXG52YXIgY29tbW9uICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgVHlwZSAgICAgICAgICA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG5cbmZ1bmN0aW9uIGNvbXBpbGVMaXN0KHNjaGVtYSwgbmFtZSwgcmVzdWx0KSB7XG4gIHZhciBleGNsdWRlID0gW107XG5cbiAgc2NoZW1hLmluY2x1ZGUuZm9yRWFjaChmdW5jdGlvbiAoaW5jbHVkZWRTY2hlbWEpIHtcbiAgICByZXN1bHQgPSBjb21waWxlTGlzdChpbmNsdWRlZFNjaGVtYSwgbmFtZSwgcmVzdWx0KTtcbiAgfSk7XG5cbiAgc2NoZW1hW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRUeXBlKSB7XG4gICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHByZXZpb3VzVHlwZSwgcHJldmlvdXNJbmRleCkge1xuICAgICAgaWYgKHByZXZpb3VzVHlwZS50YWcgPT09IGN1cnJlbnRUeXBlLnRhZykge1xuICAgICAgICBleGNsdWRlLnB1c2gocHJldmlvdXNJbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXN1bHQucHVzaChjdXJyZW50VHlwZSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQuZmlsdGVyKGZ1bmN0aW9uICh0eXBlLCBpbmRleCkge1xuICAgIHJldHVybiAtMSA9PT0gZXhjbHVkZS5pbmRleE9mKGluZGV4KTtcbiAgfSk7XG59XG5cblxuZnVuY3Rpb24gY29tcGlsZU1hcCgvKiBsaXN0cy4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge30sIGluZGV4LCBsZW5ndGg7XG5cbiAgZnVuY3Rpb24gY29sbGVjdFR5cGUodHlwZSkge1xuICAgIHJlc3VsdFt0eXBlLnRhZ10gPSB0eXBlO1xuICB9XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgYXJndW1lbnRzW2luZGV4XS5mb3JFYWNoKGNvbGxlY3RUeXBlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gU2NoZW1hKGRlZmluaXRpb24pIHtcbiAgdGhpcy5pbmNsdWRlICA9IGRlZmluaXRpb24uaW5jbHVkZSAgfHwgW107XG4gIHRoaXMuaW1wbGljaXQgPSBkZWZpbml0aW9uLmltcGxpY2l0IHx8IFtdO1xuICB0aGlzLmV4cGxpY2l0ID0gZGVmaW5pdGlvbi5leHBsaWNpdCB8fCBbXTtcblxuICB0aGlzLmltcGxpY2l0LmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodHlwZS5sb2FkS2luZCAmJiAnc2NhbGFyJyAhPT0gdHlwZS5sb2FkS2luZCkge1xuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1RoZXJlIGlzIGEgbm9uLXNjYWxhciB0eXBlIGluIHRoZSBpbXBsaWNpdCBsaXN0IG9mIGEgc2NoZW1hLiBJbXBsaWNpdCByZXNvbHZpbmcgb2Ygc3VjaCB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5jb21waWxlZEltcGxpY2l0ID0gY29tcGlsZUxpc3QodGhpcywgJ2ltcGxpY2l0JywgW10pO1xuICB0aGlzLmNvbXBpbGVkRXhwbGljaXQgPSBjb21waWxlTGlzdCh0aGlzLCAnZXhwbGljaXQnLCBbXSk7XG4gIHRoaXMuY29tcGlsZWRUeXBlTWFwICA9IGNvbXBpbGVNYXAodGhpcy5jb21waWxlZEltcGxpY2l0LCB0aGlzLmNvbXBpbGVkRXhwbGljaXQpO1xufVxuXG5cblNjaGVtYS5ERUZBVUxUID0gbnVsbDtcblxuXG5TY2hlbWEuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlU2NoZW1hKCkge1xuICB2YXIgc2NoZW1hcywgdHlwZXM7XG5cbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gIGNhc2UgMTpcbiAgICBzY2hlbWFzID0gU2NoZW1hLkRFRkFVTFQ7XG4gICAgdHlwZXMgPSBhcmd1bWVudHNbMF07XG4gICAgYnJlYWs7XG5cbiAgY2FzZSAyOlxuICAgIHNjaGVtYXMgPSBhcmd1bWVudHNbMF07XG4gICAgdHlwZXMgPSBhcmd1bWVudHNbMV07XG4gICAgYnJlYWs7XG5cbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgU2NoZW1hLmNyZWF0ZSBmdW5jdGlvbicpO1xuICB9XG5cbiAgc2NoZW1hcyA9IGNvbW1vbi50b0FycmF5KHNjaGVtYXMpO1xuICB0eXBlcyA9IGNvbW1vbi50b0FycmF5KHR5cGVzKTtcblxuICBpZiAoIXNjaGVtYXMuZXZlcnkoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hIGluc3RhbmNlb2YgU2NoZW1hOyB9KSkge1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdTcGVjaWZpZWQgbGlzdCBvZiBzdXBlciBzY2hlbWFzIChvciBhIHNpbmdsZSBTY2hlbWEgb2JqZWN0KSBjb250YWlucyBhIG5vbi1TY2hlbWEgb2JqZWN0LicpO1xuICB9XG5cbiAgaWYgKCF0eXBlcy5ldmVyeShmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZSBpbnN0YW5jZW9mIFR5cGU7IH0pKSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1NwZWNpZmllZCBsaXN0IG9mIFlBTUwgdHlwZXMgKG9yIGEgc2luZ2xlIFR5cGUgb2JqZWN0KSBjb250YWlucyBhIG5vbi1UeXBlIG9iamVjdC4nKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2NoZW1hKHtcbiAgICBpbmNsdWRlOiBzY2hlbWFzLFxuICAgIGV4cGxpY2l0OiB0eXBlc1xuICB9KTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWE7XG4iLCIvLyBTdGFuZGFyZCBZQU1MJ3MgQ29yZSBzY2hlbWEuXG4vLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI4MDQ5MjNcbi8vXG4vLyBOT1RFOiBKUy1ZQU1MIGRvZXMgbm90IHN1cHBvcnQgc2NoZW1hLXNwZWNpZmljIHRhZyByZXNvbHV0aW9uIHJlc3RyaWN0aW9ucy5cbi8vIFNvLCBDb3JlIHNjaGVtYSBoYXMgbm8gZGlzdGluY3Rpb25zIGZyb20gSlNPTiBzY2hlbWEgaXMgSlMtWUFNTC5cblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGluY2x1ZGU6IFtcbiAgICByZXF1aXJlKCcuL2pzb24nKVxuICBdXG59KTtcbiIsIi8vIEpTLVlBTUwncyBkZWZhdWx0IHNjaGVtYSBmb3IgYGxvYWRgIGZ1bmN0aW9uLlxuLy8gSXQgaXMgbm90IGRlc2NyaWJlZCBpbiB0aGUgWUFNTCBzcGVjaWZpY2F0aW9uLlxuLy9cbi8vIFRoaXMgc2NoZW1hIGlzIGJhc2VkIG9uIEpTLVlBTUwncyBkZWZhdWx0IHNhZmUgc2NoZW1hIGFuZCBpbmNsdWRlc1xuLy8gSmF2YVNjcmlwdC1zcGVjaWZpYyB0eXBlczogISFqcy91bmRlZmluZWQsICEhanMvcmVnZXhwIGFuZCAhIWpzL2Z1bmN0aW9uLlxuLy9cbi8vIEFsc28gdGhpcyBzY2hlbWEgaXMgdXNlZCBhcyBkZWZhdWx0IGJhc2Ugc2NoZW1hIGF0IGBTY2hlbWEuY3JlYXRlYCBmdW5jdGlvbi5cblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hLkRFRkFVTFQgPSBuZXcgU2NoZW1hKHtcbiAgaW5jbHVkZTogW1xuICAgIHJlcXVpcmUoJy4vZGVmYXVsdF9zYWZlJylcbiAgXSxcbiAgZXhwbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL2pzL3VuZGVmaW5lZCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvanMvcmVnZXhwJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9qcy9mdW5jdGlvbicpXG4gIF1cbn0pO1xuIiwiLy8gSlMtWUFNTCdzIGRlZmF1bHQgc2NoZW1hIGZvciBgc2FmZUxvYWRgIGZ1bmN0aW9uLlxuLy8gSXQgaXMgbm90IGRlc2NyaWJlZCBpbiB0aGUgWUFNTCBzcGVjaWZpY2F0aW9uLlxuLy9cbi8vIFRoaXMgc2NoZW1hIGlzIGJhc2VkIG9uIHN0YW5kYXJkIFlBTUwncyBDb3JlIHNjaGVtYSBhbmQgaW5jbHVkZXMgbW9zdCBvZlxuLy8gZXh0cmEgdHlwZXMgZGVzY3JpYmVkIGF0IFlBTUwgdGFnIHJlcG9zaXRvcnkuIChodHRwOi8veWFtbC5vcmcvdHlwZS8pXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTY2hlbWEoe1xuICBpbmNsdWRlOiBbXG4gICAgcmVxdWlyZSgnLi9jb3JlJylcbiAgXSxcbiAgaW1wbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL3RpbWVzdGFtcCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvbWVyZ2UnKVxuICBdLFxuICBleHBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvYmluYXJ5JyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9vbWFwJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9wYWlycycpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvc2V0JylcbiAgXVxufSk7XG4iLCIvLyBTdGFuZGFyZCBZQU1MJ3MgRmFpbHNhZmUgc2NoZW1hLlxuLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyODAyMzQ2XG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTY2hlbWEoe1xuICBleHBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvc3RyJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9zZXEnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL21hcCcpXG4gIF1cbn0pO1xuIiwiLy8gU3RhbmRhcmQgWUFNTCdzIEpTT04gc2NoZW1hLlxuLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyODAzMjMxXG4vL1xuLy8gTk9URTogSlMtWUFNTCBkb2VzIG5vdCBzdXBwb3J0IHNjaGVtYS1zcGVjaWZpYyB0YWcgcmVzb2x1dGlvbiByZXN0cmljdGlvbnMuXG4vLyBTbywgdGhpcyBzY2hlbWEgaXMgbm90IHN1Y2ggc3RyaWN0IGFzIGRlZmluZWQgaW4gdGhlIFlBTUwgc3BlY2lmaWNhdGlvbi5cbi8vIEl0IGFsbG93cyBudW1iZXJzIGluIGJpbmFyeSBub3RhaW9uLCB1c2UgYE51bGxgIGFuZCBgTlVMTGAgYXMgYG51bGxgLCBldGMuXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTY2hlbWEoe1xuICBpbmNsdWRlOiBbXG4gICAgcmVxdWlyZSgnLi9mYWlsc2FmZScpXG4gIF0sXG4gIGltcGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9udWxsJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9ib29sJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9pbnQnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2Zsb2F0JylcbiAgXVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBZQU1MRXhjZXB0aW9uID0gcmVxdWlyZSgnLi9leGNlcHRpb24nKTtcblxudmFyIFRZUEVfQ09OU1RSVUNUT1JfT1BUSU9OUyA9IFtcbiAgJ2tpbmQnLFxuICAncmVzb2x2ZScsXG4gICdjb25zdHJ1Y3QnLFxuICAnaW5zdGFuY2VPZicsXG4gICdwcmVkaWNhdGUnLFxuICAncmVwcmVzZW50JyxcbiAgJ2RlZmF1bHRTdHlsZScsXG4gICdzdHlsZUFsaWFzZXMnXG5dO1xuXG52YXIgWUFNTF9OT0RFX0tJTkRTID0gW1xuICAnc2NhbGFyJyxcbiAgJ3NlcXVlbmNlJyxcbiAgJ21hcHBpbmcnXG5dO1xuXG5mdW5jdGlvbiBjb21waWxlU3R5bGVBbGlhc2VzKG1hcCkge1xuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgaWYgKG51bGwgIT09IG1hcCkge1xuICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgIG1hcFtzdHlsZV0uZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgICAgcmVzdWx0W1N0cmluZyhhbGlhcyldID0gc3R5bGU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIFR5cGUodGFnLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAoLTEgPT09IFRZUEVfQ09OU1RSVUNUT1JfT1BUSU9OUy5pbmRleE9mKG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVW5rbm93biBvcHRpb24gXCInICsgbmFtZSArICdcIiBpcyBtZXQgaW4gZGVmaW5pdGlvbiBvZiBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVE9ETzogQWRkIHRhZyBmb3JtYXQgY2hlY2suXG4gIHRoaXMudGFnICAgICAgICAgID0gdGFnO1xuICB0aGlzLmtpbmQgICAgICAgICA9IG9wdGlvbnNbJ2tpbmQnXSAgICAgICAgIHx8IG51bGw7XG4gIHRoaXMucmVzb2x2ZSAgICAgID0gb3B0aW9uc1sncmVzb2x2ZSddICAgICAgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgdGhpcy5jb25zdHJ1Y3QgICAgPSBvcHRpb25zWydjb25zdHJ1Y3QnXSAgICB8fCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YTsgfTtcbiAgdGhpcy5pbnN0YW5jZU9mICAgPSBvcHRpb25zWydpbnN0YW5jZU9mJ10gICB8fCBudWxsO1xuICB0aGlzLnByZWRpY2F0ZSAgICA9IG9wdGlvbnNbJ3ByZWRpY2F0ZSddICAgIHx8IG51bGw7XG4gIHRoaXMucmVwcmVzZW50ICAgID0gb3B0aW9uc1sncmVwcmVzZW50J10gICAgfHwgbnVsbDtcbiAgdGhpcy5kZWZhdWx0U3R5bGUgPSBvcHRpb25zWydkZWZhdWx0U3R5bGUnXSB8fCBudWxsO1xuICB0aGlzLnN0eWxlQWxpYXNlcyA9IGNvbXBpbGVTdHlsZUFsaWFzZXMob3B0aW9uc1snc3R5bGVBbGlhc2VzJ10gfHwgbnVsbCk7XG5cbiAgaWYgKC0xID09PSBZQU1MX05PREVfS0lORFMuaW5kZXhPZih0aGlzLmtpbmQpKSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1Vua25vd24ga2luZCBcIicgKyB0aGlzLmtpbmQgKyAnXCIgaXMgc3BlY2lmaWVkIGZvciBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cblxuLy8gQSB0cmljayBmb3IgYnJvd3NlcmlmaWVkIHZlcnNpb24uXG4vLyBTaW5jZSB3ZSBtYWtlIGJyb3dzZXJpZmllciB0byBpZ25vcmUgYGJ1ZmZlcmAgbW9kdWxlLCBOb2RlQnVmZmVyIHdpbGwgYmUgdW5kZWZpbmVkXG52YXIgTm9kZUJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbnZhciBUeXBlICAgICAgID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5cbi8vIFsgNjQsIDY1LCA2NiBdIC0+IFsgcGFkZGluZywgQ1IsIExGIF1cbnZhciBCQVNFNjRfTUFQID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XFxuXFxyJztcblxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEJpbmFyeShkYXRhKSB7XG4gIGlmIChudWxsID09PSBkYXRhKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGNvZGUsIGlkeCwgYml0bGVuID0gMCwgbGVuID0gMCwgbWF4ID0gZGF0YS5sZW5ndGgsIG1hcCA9IEJBU0U2NF9NQVA7XG5cbiAgLy8gQ29udmVydCBvbmUgYnkgb25lLlxuICBmb3IgKGlkeCA9IDA7IGlkeCA8IG1heDsgaWR4KyspIHtcbiAgICBjb2RlID0gbWFwLmluZGV4T2YoZGF0YS5jaGFyQXQoaWR4KSk7XG5cbiAgICAvLyBTa2lwIENSL0xGXG4gICAgaWYgKGNvZGUgPiA2NCkgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gRmFpbCBvbiBpbGxlZ2FsIGNoYXJhY3RlcnNcbiAgICBpZiAoY29kZSA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBiaXRsZW4gKz0gNjtcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGFyZSBhbnkgYml0cyBsZWZ0LCBzb3VyY2Ugd2FzIGNvcnJ1cHRlZFxuICByZXR1cm4gKGJpdGxlbiAlIDgpID09PSAwO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sQmluYXJ5KGRhdGEpIHtcbiAgdmFyIGNvZGUsIGlkeCwgdGFpbGJpdHMsXG4gICAgICBpbnB1dCA9IGRhdGEucmVwbGFjZSgvW1xcclxcbj1dL2csICcnKSwgLy8gcmVtb3ZlIENSL0xGICYgcGFkZGluZyB0byBzaW1wbGlmeSBzY2FuXG4gICAgICBtYXggPSBpbnB1dC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQLFxuICAgICAgYml0cyA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICAvLyBDb2xsZWN0IGJ5IDYqNCBiaXRzICgzIGJ5dGVzKVxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgNCA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQucHVzaCgoYml0cyA+PiAxNikgJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgICByZXN1bHQucHVzaChiaXRzICYgMHhGRik7XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDYpIHwgbWFwLmluZGV4T2YoaW5wdXQuY2hhckF0KGlkeCkpO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbGJpdHMgPSAobWF4ICUgNCkgKiA2O1xuXG4gIGlmICh0YWlsYml0cyA9PT0gMCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goYml0cyAmIDB4RkYpO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxOCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDEwKSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDIpICYgMHhGRik7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDEyKSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gNCkgJiAweEZGKTtcbiAgfVxuXG4gIC8vIFdyYXAgaW50byBCdWZmZXIgZm9yIE5vZGVKUyBhbmQgbGVhdmUgQXJyYXkgZm9yIGJyb3dzZXJcbiAgaWYgKE5vZGVCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IE5vZGVCdWZmZXIocmVzdWx0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxCaW5hcnkob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHZhciByZXN1bHQgPSAnJywgYml0cyA9IDAsIGlkeCwgdGFpbCxcbiAgICAgIG1heCA9IG9iamVjdC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQO1xuXG4gIC8vIENvbnZlcnQgZXZlcnkgdGhyZWUgYnl0ZXMgdG8gNCBBU0NJSSBjaGFyYWN0ZXJzLlxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgMyA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICAgIH1cblxuICAgIGJpdHMgPSAoYml0cyA8PCA4KSArIG9iamVjdFtpZHhdO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbCA9IG1heCAlIDM7XG5cbiAgaWYgKHRhaWwgPT09IDApIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA2KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICB9IGVsc2UgaWYgKHRhaWwgPT09IDIpIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEwKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMSkge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDQpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc0JpbmFyeShvYmplY3QpIHtcbiAgcmV0dXJuIE5vZGVCdWZmZXIgJiYgTm9kZUJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpiaW5hcnknLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEJpbmFyeSxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sQmluYXJ5LFxuICBwcmVkaWNhdGU6IGlzQmluYXJ5LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxCaW5hcnlcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxCb29sZWFuKGRhdGEpIHtcbiAgaWYgKG51bGwgPT09IGRhdGEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGg7XG5cbiAgcmV0dXJuIChtYXggPT09IDQgJiYgKGRhdGEgPT09ICd0cnVlJyB8fCBkYXRhID09PSAnVHJ1ZScgfHwgZGF0YSA9PT0gJ1RSVUUnKSkgfHxcbiAgICAgICAgIChtYXggPT09IDUgJiYgKGRhdGEgPT09ICdmYWxzZScgfHwgZGF0YSA9PT0gJ0ZhbHNlJyB8fCBkYXRhID09PSAnRkFMU0UnKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxCb29sZWFuKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09ICd0cnVlJyB8fFxuICAgICAgICAgZGF0YSA9PT0gJ1RydWUnIHx8XG4gICAgICAgICBkYXRhID09PSAnVFJVRSc7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihvYmplY3QpIHtcbiAgcmV0dXJuICdbb2JqZWN0IEJvb2xlYW5dJyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEJvb2xlYW4sXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEJvb2xlYW4sXG4gIHByZWRpY2F0ZTogaXNCb29sZWFuLFxuICByZXByZXNlbnQ6IHtcbiAgICBsb3dlcmNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICd0cnVlJyA6ICdmYWxzZSc7IH0sXG4gICAgdXBwZXJjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAnVFJVRScgOiAnRkFMU0UnOyB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ1RydWUnIDogJ0ZhbHNlJzsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIFR5cGUgICA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIFlBTUxfRkxPQVRfUEFUVEVSTiA9IG5ldyBSZWdFeHAoXG4gICdeKD86Wy0rXT8oPzpbMC05XVswLTlfXSopXFxcXC5bMC05X10qKD86W2VFXVstK11bMC05XSspPycgK1xuICAnfFxcXFwuWzAtOV9dKyg/OltlRV1bLStdWzAtOV0rKT8nICtcbiAgJ3xbLStdP1swLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrXFxcXC5bMC05X10qJyArXG4gICd8Wy0rXT9cXFxcLig/OmluZnxJbmZ8SU5GKScgK1xuICAnfFxcXFwuKD86bmFufE5hTnxOQU4pKSQnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxGbG9hdChkYXRhKSB7XG4gIGlmIChudWxsID09PSBkYXRhKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHZhbHVlLCBzaWduLCBiYXNlLCBkaWdpdHM7XG5cbiAgaWYgKCFZQU1MX0ZMT0FUX1BBVFRFUk4udGVzdChkYXRhKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEZsb2F0KGRhdGEpIHtcbiAgdmFyIHZhbHVlLCBzaWduLCBiYXNlLCBkaWdpdHM7XG5cbiAgdmFsdWUgID0gZGF0YS5yZXBsYWNlKC9fL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICBzaWduICAgPSAnLScgPT09IHZhbHVlWzBdID8gLTEgOiAxO1xuICBkaWdpdHMgPSBbXTtcblxuICBpZiAoMCA8PSAnKy0nLmluZGV4T2YodmFsdWVbMF0pKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgfVxuXG4gIGlmICgnLmluZicgPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuICgxID09PSBzaWduKSA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICB9IGVsc2UgaWYgKCcubmFuJyA9PT0gdmFsdWUpIHtcbiAgICByZXR1cm4gTmFOO1xuXG4gIH0gZWxzZSBpZiAoMCA8PSB2YWx1ZS5pbmRleE9mKCc6JykpIHtcbiAgICB2YWx1ZS5zcGxpdCgnOicpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIGRpZ2l0cy51bnNoaWZ0KHBhcnNlRmxvYXQodiwgMTApKTtcbiAgICB9KTtcblxuICAgIHZhbHVlID0gMC4wO1xuICAgIGJhc2UgPSAxO1xuXG4gICAgZGlnaXRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhbHVlICs9IGQgKiBiYXNlO1xuICAgICAgYmFzZSAqPSA2MDtcbiAgICB9KTtcblxuICAgIHJldHVybiBzaWduICogdmFsdWU7XG5cbiAgfVxuICByZXR1cm4gc2lnbiAqIHBhcnNlRmxvYXQodmFsdWUsIDEwKTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEZsb2F0KG9iamVjdCwgc3R5bGUpIHtcbiAgaWYgKGlzTmFOKG9iamVjdCkpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgY2FzZSAnbG93ZXJjYXNlJzpcbiAgICAgIHJldHVybiAnLm5hbic7XG4gICAgY2FzZSAndXBwZXJjYXNlJzpcbiAgICAgIHJldHVybiAnLk5BTic7XG4gICAgY2FzZSAnY2FtZWxjYXNlJzpcbiAgICAgIHJldHVybiAnLk5hTic7XG4gICAgfVxuICB9IGVsc2UgaWYgKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA9PT0gb2JqZWN0KSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgIGNhc2UgJ2xvd2VyY2FzZSc6XG4gICAgICByZXR1cm4gJy5pbmYnO1xuICAgIGNhc2UgJ3VwcGVyY2FzZSc6XG4gICAgICByZXR1cm4gJy5JTkYnO1xuICAgIGNhc2UgJ2NhbWVsY2FzZSc6XG4gICAgICByZXR1cm4gJy5JbmYnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IG9iamVjdCkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICBjYXNlICdsb3dlcmNhc2UnOlxuICAgICAgcmV0dXJuICctLmluZic7XG4gICAgY2FzZSAndXBwZXJjYXNlJzpcbiAgICAgIHJldHVybiAnLS5JTkYnO1xuICAgIGNhc2UgJ2NhbWVsY2FzZSc6XG4gICAgICByZXR1cm4gJy0uSW5mJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29tbW9uLmlzTmVnYXRpdmVaZXJvKG9iamVjdCkpIHtcbiAgICByZXR1cm4gJy0wLjAnO1xuICB9XG4gIHJldHVybiBvYmplY3QudG9TdHJpbmcoMTApO1xufVxuXG5mdW5jdGlvbiBpc0Zsb2F0KG9iamVjdCkge1xuICByZXR1cm4gKCdbb2JqZWN0IE51bWJlcl0nID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSkgJiZcbiAgICAgICAgICgwICE9PSBvYmplY3QgJSAxIHx8IGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEZsb2F0LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxGbG9hdCxcbiAgcHJlZGljYXRlOiBpc0Zsb2F0LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxGbG9hdCxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBUeXBlICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIGlzSGV4Q29kZShjKSB7XG4gIHJldHVybiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkgfHxcbiAgICAgICAgICgoMHg0MS8qIEEgKi8gPD0gYykgJiYgKGMgPD0gMHg0Ni8qIEYgKi8pKSB8fFxuICAgICAgICAgKCgweDYxLyogYSAqLyA8PSBjKSAmJiAoYyA8PSAweDY2LyogZiAqLykpO1xufVxuXG5mdW5jdGlvbiBpc09jdENvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM3LyogNyAqLykpO1xufVxuXG5mdW5jdGlvbiBpc0RlY0NvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEludGVnZXIoZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIGhhc0RpZ2l0cyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKCFtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgY2ggPSBkYXRhW2luZGV4XTtcblxuICAvLyBzaWduXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG4gIH1cblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIC8vIDBcbiAgICBpZiAoaW5kZXggKyAxID09PSBtYXgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG5cbiAgICAvLyBiYXNlIDIsIGJhc2UgOCwgYmFzZSAxNlxuXG4gICAgaWYgKGNoID09PSAnYicpIHtcbiAgICAgIC8vIGJhc2UgMlxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmIChjaCAhPT0gJzAnICYmIGNoICE9PSAnMScpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHM7XG4gICAgfVxuXG5cbiAgICBpZiAoY2ggPT09ICd4Jykge1xuICAgICAgLy8gYmFzZSAxNlxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmICghaXNIZXhDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzRGlnaXRzO1xuICAgIH1cblxuICAgIC8vIGJhc2UgOFxuICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgIGlmIChjaCA9PT0gJ18nKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAoIWlzT2N0Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzRGlnaXRzO1xuICB9XG5cbiAgLy8gYmFzZSAxMCAoZXhjZXB0IDApIG9yIGJhc2UgNjBcblxuICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgIGlmIChjaCA9PT0gJ18nKSB7IGNvbnRpbnVlOyB9XG4gICAgaWYgKGNoID09PSAnOicpIHsgYnJlYWs7IH1cbiAgICBpZiAoIWlzRGVjQ29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICB9XG5cbiAgaWYgKCFoYXNEaWdpdHMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gaWYgIWJhc2U2MCAtIGRvbmU7XG4gIGlmIChjaCAhPT0gJzonKSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gYmFzZTYwIGFsbW9zdCBub3QgdXNlZCwgbm8gbmVlZHMgdG8gb3B0aW1pemVcbiAgcmV0dXJuIC9eKDpbMC01XT9bMC05XSkrJC8udGVzdChkYXRhLnNsaWNlKGluZGV4KSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxJbnRlZ2VyKGRhdGEpIHtcbiAgdmFyIHZhbHVlID0gZGF0YSwgc2lnbiA9IDEsIGNoLCBiYXNlLCBkaWdpdHMgPSBbXTtcblxuICBpZiAodmFsdWUuaW5kZXhPZignXycpICE9PSAtMSkge1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXy9nLCAnJyk7XG4gIH1cblxuICBjaCA9IHZhbHVlWzBdO1xuXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBpZiAoY2ggPT09ICctJykgeyBzaWduID0gLTE7IH1cbiAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgIGNoID0gdmFsdWVbMF07XG4gIH1cblxuICBpZiAoJzAnID09PSB2YWx1ZSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGNoID09PSAnMCcpIHtcbiAgICBpZiAodmFsdWVbMV0gPT09ICdiJykge1xuICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgMik7XG4gICAgfVxuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ3gnKSB7XG4gICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLCAxNik7XG4gICAgfVxuICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDgpO1xuXG4gIH1cblxuICBpZiAodmFsdWUuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgIHZhbHVlLnNwbGl0KCc6JykuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgZGlnaXRzLnVuc2hpZnQocGFyc2VJbnQodiwgMTApKTtcbiAgICB9KTtcblxuICAgIHZhbHVlID0gMDtcbiAgICBiYXNlID0gMTtcblxuICAgIGRpZ2l0cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YWx1ZSArPSAoZCAqIGJhc2UpO1xuICAgICAgYmFzZSAqPSA2MDtcbiAgICB9KTtcblxuICAgIHJldHVybiBzaWduICogdmFsdWU7XG5cbiAgfVxuXG4gIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDEwKTtcbn1cblxuZnVuY3Rpb24gaXNJbnRlZ2VyKG9iamVjdCkge1xuICByZXR1cm4gKCdbb2JqZWN0IE51bWJlcl0nID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSkgJiZcbiAgICAgICAgICgwID09PSBvYmplY3QgJSAxICYmICFjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sSW50ZWdlcixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sSW50ZWdlcixcbiAgcHJlZGljYXRlOiBpc0ludGVnZXIsXG4gIHJlcHJlc2VudDoge1xuICAgIGJpbmFyeTogICAgICBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAnMGInICsgb2JqZWN0LnRvU3RyaW5nKDIpOyB9LFxuICAgIG9jdGFsOiAgICAgICBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAnMCcgICsgb2JqZWN0LnRvU3RyaW5nKDgpOyB9LFxuICAgIGRlY2ltYWw6ICAgICBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAgICAgICAgb2JqZWN0LnRvU3RyaW5nKDEwKTsgfSxcbiAgICBoZXhhZGVjaW1hbDogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gJzB4JyArIG9iamVjdC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdkZWNpbWFsJyxcbiAgc3R5bGVBbGlhc2VzOiB7XG4gICAgYmluYXJ5OiAgICAgIFsgMiwgICdiaW4nIF0sXG4gICAgb2N0YWw6ICAgICAgIFsgOCwgICdvY3QnIF0sXG4gICAgZGVjaW1hbDogICAgIFsgMTAsICdkZWMnIF0sXG4gICAgaGV4YWRlY2ltYWw6IFsgMTYsICdoZXgnIF1cbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlc3ByaW1hO1xuXG4vLyBCcm93c2VyaWZpZWQgdmVyc2lvbiBkb2VzIG5vdCBoYXZlIGVzcHJpbWFcbi8vXG4vLyAxLiBGb3Igbm9kZS5qcyBqdXN0IHJlcXVpcmUgbW9kdWxlIGFzIGRlcHNcbi8vIDIuIEZvciBicm93c2VyIHRyeSB0byByZXF1aXJlIG11ZHVsZSB2aWEgZXh0ZXJuYWwgQU1EIHN5c3RlbS5cbi8vICAgIElmIG5vdCBmb3VuZCAtIHRyeSB0byBmYWxsYmFjayB0byB3aW5kb3cuZXNwcmltYS4gSWYgbm90XG4vLyAgICBmb3VuZCB0b28gLSB0aGVuIGZhaWwgdG8gcGFyc2UuXG4vL1xudHJ5IHtcbiAgZXNwcmltYSA9IHJlcXVpcmUoJ2VzcHJpbWEnKTtcbn0gY2F0Y2ggKF8pIHtcbiAgLypnbG9iYWwgd2luZG93ICovXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyBlc3ByaW1hID0gd2luZG93LmVzcHJpbWE7IH1cbn1cblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi8uLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVKYXZhc2NyaXB0RnVuY3Rpb24oZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIHNvdXJjZSA9ICcoJyArIGRhdGEgKyAnKScsXG4gICAgICAgIGFzdCAgICA9IGVzcHJpbWEucGFyc2Uoc291cmNlLCB7IHJhbmdlOiB0cnVlIH0pLFxuICAgICAgICBwYXJhbXMgPSBbXSxcbiAgICAgICAgYm9keTtcblxuICAgIGlmICgnUHJvZ3JhbScgICAgICAgICAgICAgIT09IGFzdC50eXBlICAgICAgICAgfHxcbiAgICAgICAgMSAgICAgICAgICAgICAgICAgICAgICE9PSBhc3QuYm9keS5sZW5ndGggIHx8XG4gICAgICAgICdFeHByZXNzaW9uU3RhdGVtZW50JyAhPT0gYXN0LmJvZHlbMF0udHlwZSB8fFxuICAgICAgICAnRnVuY3Rpb25FeHByZXNzaW9uJyAgIT09IGFzdC5ib2R5WzBdLmV4cHJlc3Npb24udHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdEZ1bmN0aW9uKGRhdGEpIHtcbiAgLypqc2xpbnQgZXZpbDp0cnVlKi9cblxuICB2YXIgc291cmNlID0gJygnICsgZGF0YSArICcpJyxcbiAgICAgIGFzdCAgICA9IGVzcHJpbWEucGFyc2Uoc291cmNlLCB7IHJhbmdlOiB0cnVlIH0pLFxuICAgICAgcGFyYW1zID0gW10sXG4gICAgICBib2R5O1xuXG4gIGlmICgnUHJvZ3JhbScgICAgICAgICAgICAgIT09IGFzdC50eXBlICAgICAgICAgfHxcbiAgICAgIDEgICAgICAgICAgICAgICAgICAgICAhPT0gYXN0LmJvZHkubGVuZ3RoICB8fFxuICAgICAgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnICE9PSBhc3QuYm9keVswXS50eXBlIHx8XG4gICAgICAnRnVuY3Rpb25FeHByZXNzaW9uJyAgIT09IGFzdC5ib2R5WzBdLmV4cHJlc3Npb24udHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHJlc29sdmUgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGFzdC5ib2R5WzBdLmV4cHJlc3Npb24ucGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgcGFyYW1zLnB1c2gocGFyYW0ubmFtZSk7XG4gIH0pO1xuXG4gIGJvZHkgPSBhc3QuYm9keVswXS5leHByZXNzaW9uLmJvZHkucmFuZ2U7XG5cbiAgLy8gRXNwcmltYSdzIHJhbmdlcyBpbmNsdWRlIHRoZSBmaXJzdCAneycgYW5kIHRoZSBsYXN0ICd9JyBjaGFyYWN0ZXJzIG9uXG4gIC8vIGZ1bmN0aW9uIGV4cHJlc3Npb25zLiBTbyBjdXQgdGhlbSBvdXQuXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMqL1xuICByZXR1cm4gbmV3IEZ1bmN0aW9uKHBhcmFtcywgc291cmNlLnNsaWNlKGJvZHlbMF0gKyAxLCBib2R5WzFdIC0gMSkpO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRKYXZhc2NyaXB0RnVuY3Rpb24ob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHJldHVybiBvYmplY3QudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmplY3QpIHtcbiAgcmV0dXJuICdbb2JqZWN0IEZ1bmN0aW9uXScgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy9mdW5jdGlvbicsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0RnVuY3Rpb24sXG4gIGNvbnN0cnVjdDogY29uc3RydWN0SmF2YXNjcmlwdEZ1bmN0aW9uLFxuICBwcmVkaWNhdGU6IGlzRnVuY3Rpb24sXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdEZ1bmN0aW9uXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi8uLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVKYXZhc2NyaXB0UmVnRXhwKGRhdGEpIHtcbiAgaWYgKG51bGwgPT09IGRhdGEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoMCA9PT0gZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gZGF0YSxcbiAgICAgIHRhaWwgICA9IC9cXC8oW2dpbV0qKSQvLmV4ZWMoZGF0YSksXG4gICAgICBtb2RpZmllcnMgPSAnJztcblxuICAvLyBpZiByZWdleHAgc3RhcnRzIHdpdGggJy8nIGl0IGNhbiBoYXZlIG1vZGlmaWVycyBhbmQgbXVzdCBiZSBwcm9wZXJseSBjbG9zZWRcbiAgLy8gYC9mb28vZ2ltYCAtIG1vZGlmaWVycyB0YWlsIGNhbiBiZSBtYXhpbXVtIDMgY2hhcnNcbiAgaWYgKCcvJyA9PT0gcmVnZXhwWzBdKSB7XG4gICAgaWYgKHRhaWwpIHtcbiAgICAgIG1vZGlmaWVycyA9IHRhaWxbMV07XG4gICAgfVxuXG4gICAgaWYgKG1vZGlmaWVycy5sZW5ndGggPiAzKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8vIGlmIGV4cHJlc3Npb24gc3RhcnRzIHdpdGggLywgaXMgc2hvdWxkIGJlIHByb3Blcmx5IHRlcm1pbmF0ZWRcbiAgICBpZiAocmVnZXhwW3JlZ2V4cC5sZW5ndGggLSBtb2RpZmllcnMubGVuZ3RoIC0gMV0gIT09ICcvJykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIHJlZ2V4cCA9IHJlZ2V4cC5zbGljZSgxLCByZWdleHAubGVuZ3RoIC0gbW9kaWZpZXJzLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgZHVtbXkgPSBuZXcgUmVnRXhwKHJlZ2V4cCwgbW9kaWZpZXJzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdFJlZ0V4cChkYXRhKSB7XG4gIHZhciByZWdleHAgPSBkYXRhLFxuICAgICAgdGFpbCAgID0gL1xcLyhbZ2ltXSopJC8uZXhlYyhkYXRhKSxcbiAgICAgIG1vZGlmaWVycyA9ICcnO1xuXG4gIC8vIGAvZm9vL2dpbWAgLSB0YWlsIGNhbiBiZSBtYXhpbXVtIDQgY2hhcnNcbiAgaWYgKCcvJyA9PT0gcmVnZXhwWzBdKSB7XG4gICAgaWYgKHRhaWwpIHtcbiAgICAgIG1vZGlmaWVycyA9IHRhaWxbMV07XG4gICAgfVxuICAgIHJlZ2V4cCA9IHJlZ2V4cC5zbGljZSgxLCByZWdleHAubGVuZ3RoIC0gbW9kaWZpZXJzLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwLCBtb2RpZmllcnMpO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRKYXZhc2NyaXB0UmVnRXhwKG9iamVjdCAvKiwgc3R5bGUqLykge1xuICB2YXIgcmVzdWx0ID0gJy8nICsgb2JqZWN0LnNvdXJjZSArICcvJztcblxuICBpZiAob2JqZWN0Lmdsb2JhbCkge1xuICAgIHJlc3VsdCArPSAnZyc7XG4gIH1cblxuICBpZiAob2JqZWN0Lm11bHRpbGluZSkge1xuICAgIHJlc3VsdCArPSAnbSc7XG4gIH1cblxuICBpZiAob2JqZWN0Lmlnbm9yZUNhc2UpIHtcbiAgICByZXN1bHQgKz0gJ2knO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAob2JqZWN0KSB7XG4gIHJldHVybiAnW29iamVjdCBSZWdFeHBdJyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL3JlZ2V4cCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0UmVnRXhwLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdEphdmFzY3JpcHRSZWdFeHAsXG4gIHByZWRpY2F0ZTogaXNSZWdFeHAsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdFJlZ0V4cFxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlSmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdEphdmFzY3JpcHRVbmRlZmluZWQoKSB7XG4gIC8qZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkKi9cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50SmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChvYmplY3QpIHtcbiAgcmV0dXJuICd1bmRlZmluZWQnID09PSB0eXBlb2Ygb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy91bmRlZmluZWQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlSmF2YXNjcmlwdFVuZGVmaW5lZCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RKYXZhc2NyaXB0VW5kZWZpbmVkLFxuICBwcmVkaWNhdGU6IGlzVW5kZWZpbmVkLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudEphdmFzY3JpcHRVbmRlZmluZWRcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bWFwJywge1xuICBraW5kOiAnbWFwcGluZycsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIG51bGwgIT09IGRhdGEgPyBkYXRhIDoge307IH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxNZXJnZShkYXRhKSB7XG4gIHJldHVybiAnPDwnID09PSBkYXRhIHx8IG51bGwgPT09IGRhdGE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxNZXJnZVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE51bGwoZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoO1xuXG4gIHJldHVybiAobWF4ID09PSAxICYmIGRhdGEgPT09ICd+JykgfHxcbiAgICAgICAgIChtYXggPT09IDQgJiYgKGRhdGEgPT09ICdudWxsJyB8fCBkYXRhID09PSAnTnVsbCcgfHwgZGF0YSA9PT0gJ05VTEwnKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKG9iamVjdCkge1xuICByZXR1cm4gbnVsbCA9PT0gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxOdWxsLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxOdWxsLFxuICBwcmVkaWNhdGU6IGlzTnVsbCxcbiAgcmVwcmVzZW50OiB7XG4gICAgY2Fub25pY2FsOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnfic7ICAgIH0sXG4gICAgbG93ZXJjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnbnVsbCc7IH0sXG4gICAgdXBwZXJjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnTlVMTCc7IH0sXG4gICAgY2FtZWxjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnTnVsbCc7IH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfdG9TdHJpbmcgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE9tYXAoZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIG9iamVjdEtleXMgPSBbXSwgaW5kZXgsIGxlbmd0aCwgcGFpciwgcGFpcktleSwgcGFpckhhc0tleSxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG4gICAgcGFpckhhc0tleSA9IGZhbHNlO1xuXG4gICAgaWYgKCdbb2JqZWN0IE9iamVjdF0nICE9PSBfdG9TdHJpbmcuY2FsbChwYWlyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAocGFpcktleSBpbiBwYWlyKSB7XG4gICAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwocGFpciwgcGFpcktleSkpIHtcbiAgICAgICAgaWYgKCFwYWlySGFzS2V5KSB7XG4gICAgICAgICAgcGFpckhhc0tleSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYWlySGFzS2V5KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKC0xID09PSBvYmplY3RLZXlzLmluZGV4T2YocGFpcktleSkpIHtcbiAgICAgIG9iamVjdEtleXMucHVzaChwYWlyS2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sT21hcChkYXRhKSB7XG4gIHJldHVybiBudWxsICE9PSBkYXRhID8gZGF0YSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE9tYXAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbE9tYXBcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGluZGV4LCBsZW5ndGgsIHBhaXIsIGtleXMsIHJlc3VsdCxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgcmVzdWx0ID0gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAgaWYgKCdbb2JqZWN0IE9iamVjdF0nICE9PSBfdG9TdHJpbmcuY2FsbChwYWlyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwYWlyKTtcblxuICAgIGlmICgxICE9PSBrZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBpbmRleCwgbGVuZ3RoLCBwYWlyLCBrZXlzLCByZXN1bHQsXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIHJlc3VsdCA9IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwYWlyKTtcblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFBhaXJzLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxQYWlyc1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIG51bGwgIT09IGRhdGEgPyBkYXRhIDogW107IH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sU2V0KGRhdGEpIHtcbiAgaWYgKG51bGwgPT09IGRhdGEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBrZXksIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgaWYgKG51bGwgIT09IG9iamVjdFtrZXldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFNldChkYXRhKSB7XG4gIHJldHVybiBudWxsICE9PSBkYXRhID8gZGF0YSA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxTZXQsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFNldFxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBudWxsICE9PSBkYXRhID8gZGF0YSA6ICcnOyB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBZQU1MX1RJTUVTVEFNUF9SRUdFWFAgPSBuZXcgUmVnRXhwKFxuICAnXihbMC05XVswLTldWzAtOV1bMC05XSknICAgICAgICAgICsgLy8gWzFdIHllYXJcbiAgJy0oWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICArIC8vIFsyXSBtb250aFxuICAnLShbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICsgLy8gWzNdIGRheVxuICAnKD86KD86W1R0XXxbIFxcXFx0XSspJyAgICAgICAgICAgICAgKyAvLyAuLi5cbiAgJyhbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICArIC8vIFs0XSBob3VyXG4gICc6KFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNV0gbWludXRlXG4gICc6KFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNl0gc2Vjb25kXG4gICcoPzpcXFxcLihbMC05XSopKT8nICAgICAgICAgICAgICAgICArIC8vIFs3XSBmcmFjdGlvblxuICAnKD86WyBcXFxcdF0qKFp8KFstK10pKFswLTldWzAtOV0/KScgKyAvLyBbOF0gdHogWzldIHR6X3NpZ24gWzEwXSB0el9ob3VyXG4gICcoPzo6KFswLTldWzAtOV0pKT8pKT8pPyQnKTsgICAgICAgICAvLyBbMTFdIHR6X21pbnV0ZVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFRpbWVzdGFtcChkYXRhKSB7XG4gIGlmIChudWxsID09PSBkYXRhKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIG1hdGNoLCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhY3Rpb24gPSAwLFxuICAgICAgZGVsdGEgPSBudWxsLCB0el9ob3VyLCB0el9taW51dGUsIGRhdGU7XG5cbiAgbWF0Y2ggPSBZQU1MX1RJTUVTVEFNUF9SRUdFWFAuZXhlYyhkYXRhKTtcblxuICBpZiAobnVsbCA9PT0gbWF0Y2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFRpbWVzdGFtcChkYXRhKSB7XG4gIHZhciBtYXRjaCwgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWN0aW9uID0gMCxcbiAgICAgIGRlbHRhID0gbnVsbCwgdHpfaG91ciwgdHpfbWludXRlLCBkYXRlO1xuXG4gIG1hdGNoID0gWUFNTF9USU1FU1RBTVBfUkVHRVhQLmV4ZWMoZGF0YSk7XG5cbiAgaWYgKG51bGwgPT09IG1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEYXRlIHJlc29sdmUgZXJyb3InKTtcbiAgfVxuXG4gIC8vIG1hdGNoOiBbMV0geWVhciBbMl0gbW9udGggWzNdIGRheVxuXG4gIHllYXIgPSArKG1hdGNoWzFdKTtcbiAgbW9udGggPSArKG1hdGNoWzJdKSAtIDE7IC8vIEpTIG1vbnRoIHN0YXJ0cyB3aXRoIDBcbiAgZGF5ID0gKyhtYXRjaFszXSk7XG5cbiAgaWYgKCFtYXRjaFs0XSkgeyAvLyBubyBob3VyXG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXkpKTtcbiAgfVxuXG4gIC8vIG1hdGNoOiBbNF0gaG91ciBbNV0gbWludXRlIFs2XSBzZWNvbmQgWzddIGZyYWN0aW9uXG5cbiAgaG91ciA9ICsobWF0Y2hbNF0pO1xuICBtaW51dGUgPSArKG1hdGNoWzVdKTtcbiAgc2Vjb25kID0gKyhtYXRjaFs2XSk7XG5cbiAgaWYgKG1hdGNoWzddKSB7XG4gICAgZnJhY3Rpb24gPSBtYXRjaFs3XS5zbGljZSgwLCAzKTtcbiAgICB3aGlsZSAoZnJhY3Rpb24ubGVuZ3RoIDwgMykgeyAvLyBtaWxsaS1zZWNvbmRzXG4gICAgICBmcmFjdGlvbiArPSAnMCc7XG4gICAgfVxuICAgIGZyYWN0aW9uID0gK2ZyYWN0aW9uO1xuICB9XG5cbiAgLy8gbWF0Y2g6IFs4XSB0eiBbOV0gdHpfc2lnbiBbMTBdIHR6X2hvdXIgWzExXSB0el9taW51dGVcblxuICBpZiAobWF0Y2hbOV0pIHtcbiAgICB0el9ob3VyID0gKyhtYXRjaFsxMF0pO1xuICAgIHR6X21pbnV0ZSA9ICsobWF0Y2hbMTFdIHx8IDApO1xuICAgIGRlbHRhID0gKHR6X2hvdXIgKiA2MCArIHR6X21pbnV0ZSkgKiA2MDAwMDsgLy8gZGVsdGEgaW4gbWlsaS1zZWNvbmRzXG4gICAgaWYgKCctJyA9PT0gbWF0Y2hbOV0pIHtcbiAgICAgIGRlbHRhID0gLWRlbHRhO1xuICAgIH1cbiAgfVxuXG4gIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhY3Rpb24pKTtcblxuICBpZiAoZGVsdGEpIHtcbiAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgLSBkZWx0YSk7XG4gIH1cblxuICByZXR1cm4gZGF0ZTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbFRpbWVzdGFtcChvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgcmV0dXJuIG9iamVjdC50b0lTT1N0cmluZygpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjp0aW1lc3RhbXAnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFRpbWVzdGFtcCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sVGltZXN0YW1wLFxuICBpbnN0YW5jZU9mOiBEYXRlLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxUaW1lc3RhbXBcbn0pO1xuIiwiLypcbiAgQ29weXJpZ2h0IChDKSAyMDEzIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgVGhhZGRlZSBUeWwgPHRoYWRkZWUudHlsQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEzIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XG4gIENvcHlyaWdodCAoQykgMjAxMiBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XG4gIENvcHlyaWdodCAoQykgMjAxMiBKb29zdC1XaW0gQm9la2VzdGVpam4gPGpvb3N0LXdpbUBib2VrZXN0ZWlqbi5ubD5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEtyaXMgS293YWwgPGtyaXMua293YWxAY2l4YXIuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgQXJwYWQgQm9yc29zIDxhcnBhZC5ib3Jzb3NAZ29vZ2xlbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMSBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsXG4gICAgLy8gUmhpbm8sIGFuZCBwbGFpbiBicm93c2VyIGxvYWRpbmcuXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBmYWN0b3J5KGV4cG9ydHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZhY3RvcnkoKHJvb3QuZXNwcmltYSA9IHt9KSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBUb2tlbixcbiAgICAgICAgVG9rZW5OYW1lLFxuICAgICAgICBGbkV4cHJUb2tlbnMsXG4gICAgICAgIFN5bnRheCxcbiAgICAgICAgUGxhY2VIb2xkZXJzLFxuICAgICAgICBNZXNzYWdlcyxcbiAgICAgICAgUmVnZXgsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgc3RyaWN0LFxuICAgICAgICBzb3VyY2VUeXBlLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgbGluZU51bWJlcixcbiAgICAgICAgbGluZVN0YXJ0LFxuICAgICAgICBoYXNMaW5lVGVybWluYXRvcixcbiAgICAgICAgbGFzdEluZGV4LFxuICAgICAgICBsYXN0TGluZU51bWJlcixcbiAgICAgICAgbGFzdExpbmVTdGFydCxcbiAgICAgICAgc3RhcnRJbmRleCxcbiAgICAgICAgc3RhcnRMaW5lTnVtYmVyLFxuICAgICAgICBzdGFydExpbmVTdGFydCxcbiAgICAgICAgc2Nhbm5pbmcsXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgbG9va2FoZWFkLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZXh0cmEsXG4gICAgICAgIGlzQmluZGluZ0VsZW1lbnQsXG4gICAgICAgIGlzQXNzaWdubWVudFRhcmdldCxcbiAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xuXG4gICAgVG9rZW4gPSB7XG4gICAgICAgIEJvb2xlYW5MaXRlcmFsOiAxLFxuICAgICAgICBFT0Y6IDIsXG4gICAgICAgIElkZW50aWZpZXI6IDMsXG4gICAgICAgIEtleXdvcmQ6IDQsXG4gICAgICAgIE51bGxMaXRlcmFsOiA1LFxuICAgICAgICBOdW1lcmljTGl0ZXJhbDogNixcbiAgICAgICAgUHVuY3R1YXRvcjogNyxcbiAgICAgICAgU3RyaW5nTGl0ZXJhbDogOCxcbiAgICAgICAgUmVndWxhckV4cHJlc3Npb246IDksXG4gICAgICAgIFRlbXBsYXRlOiAxMFxuICAgIH07XG5cbiAgICBUb2tlbk5hbWUgPSB7fTtcbiAgICBUb2tlbk5hbWVbVG9rZW4uQm9vbGVhbkxpdGVyYWxdID0gJ0Jvb2xlYW4nO1xuICAgIFRva2VuTmFtZVtUb2tlbi5FT0ZdID0gJzxlbmQ+JztcbiAgICBUb2tlbk5hbWVbVG9rZW4uSWRlbnRpZmllcl0gPSAnSWRlbnRpZmllcic7XG4gICAgVG9rZW5OYW1lW1Rva2VuLktleXdvcmRdID0gJ0tleXdvcmQnO1xuICAgIFRva2VuTmFtZVtUb2tlbi5OdWxsTGl0ZXJhbF0gPSAnTnVsbCc7XG4gICAgVG9rZW5OYW1lW1Rva2VuLk51bWVyaWNMaXRlcmFsXSA9ICdOdW1lcmljJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uUHVuY3R1YXRvcl0gPSAnUHVuY3R1YXRvcic7XG4gICAgVG9rZW5OYW1lW1Rva2VuLlN0cmluZ0xpdGVyYWxdID0gJ1N0cmluZyc7XG4gICAgVG9rZW5OYW1lW1Rva2VuLlJlZ3VsYXJFeHByZXNzaW9uXSA9ICdSZWd1bGFyRXhwcmVzc2lvbic7XG4gICAgVG9rZW5OYW1lW1Rva2VuLlRlbXBsYXRlXSA9ICdUZW1wbGF0ZSc7XG5cbiAgICAvLyBBIGZ1bmN0aW9uIGZvbGxvd2luZyBvbmUgb2YgdGhvc2UgdG9rZW5zIGlzIGFuIGV4cHJlc3Npb24uXG4gICAgRm5FeHByVG9rZW5zID0gWycoJywgJ3snLCAnWycsICdpbicsICd0eXBlb2YnLCAnaW5zdGFuY2VvZicsICduZXcnLFxuICAgICAgICAgICAgICAgICAgICAncmV0dXJuJywgJ2Nhc2UnLCAnZGVsZXRlJywgJ3Rocm93JywgJ3ZvaWQnLFxuICAgICAgICAgICAgICAgICAgICAvLyBhc3NpZ25tZW50IG9wZXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICAnPScsICcrPScsICctPScsICcqPScsICcvPScsICclPScsICc8PD0nLCAnPj49JywgJz4+Pj0nLFxuICAgICAgICAgICAgICAgICAgICAnJj0nLCAnfD0nLCAnXj0nLCAnLCcsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJpbmFyeS91bmFyeSBvcGVyYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgJysnLCAnLScsICcqJywgJy8nLCAnJScsICcrKycsICctLScsICc8PCcsICc+PicsICc+Pj4nLCAnJicsXG4gICAgICAgICAgICAgICAgICAgICd8JywgJ14nLCAnIScsICd+JywgJyYmJywgJ3x8JywgJz8nLCAnOicsICc9PT0nLCAnPT0nLCAnPj0nLFxuICAgICAgICAgICAgICAgICAgICAnPD0nLCAnPCcsICc+JywgJyE9JywgJyE9PSddO1xuXG4gICAgU3ludGF4ID0ge1xuICAgICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJyxcbiAgICAgICAgQXNzaWdubWVudFBhdHRlcm46ICdBc3NpZ25tZW50UGF0dGVybicsXG4gICAgICAgIEFycmF5RXhwcmVzc2lvbjogJ0FycmF5RXhwcmVzc2lvbicsXG4gICAgICAgIEFycmF5UGF0dGVybjogJ0FycmF5UGF0dGVybicsXG4gICAgICAgIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiAnQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nLFxuICAgICAgICBCbG9ja1N0YXRlbWVudDogJ0Jsb2NrU3RhdGVtZW50JyxcbiAgICAgICAgQmluYXJ5RXhwcmVzc2lvbjogJ0JpbmFyeUV4cHJlc3Npb24nLFxuICAgICAgICBCcmVha1N0YXRlbWVudDogJ0JyZWFrU3RhdGVtZW50JyxcbiAgICAgICAgQ2FsbEV4cHJlc3Npb246ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICAgIENhdGNoQ2xhdXNlOiAnQ2F0Y2hDbGF1c2UnLFxuICAgICAgICBDbGFzc0JvZHk6ICdDbGFzc0JvZHknLFxuICAgICAgICBDbGFzc0RlY2xhcmF0aW9uOiAnQ2xhc3NEZWNsYXJhdGlvbicsXG4gICAgICAgIENsYXNzRXhwcmVzc2lvbjogJ0NsYXNzRXhwcmVzc2lvbicsXG4gICAgICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicsXG4gICAgICAgIENvbnRpbnVlU3RhdGVtZW50OiAnQ29udGludWVTdGF0ZW1lbnQnLFxuICAgICAgICBEb1doaWxlU3RhdGVtZW50OiAnRG9XaGlsZVN0YXRlbWVudCcsXG4gICAgICAgIERlYnVnZ2VyU3RhdGVtZW50OiAnRGVidWdnZXJTdGF0ZW1lbnQnLFxuICAgICAgICBFbXB0eVN0YXRlbWVudDogJ0VtcHR5U3RhdGVtZW50JyxcbiAgICAgICAgRXhwb3J0QWxsRGVjbGFyYXRpb246ICdFeHBvcnRBbGxEZWNsYXJhdGlvbicsXG4gICAgICAgIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjogJ0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbicsXG4gICAgICAgIEV4cG9ydE5hbWVkRGVjbGFyYXRpb246ICdFeHBvcnROYW1lZERlY2xhcmF0aW9uJyxcbiAgICAgICAgRXhwb3J0U3BlY2lmaWVyOiAnRXhwb3J0U3BlY2lmaWVyJyxcbiAgICAgICAgRXhwcmVzc2lvblN0YXRlbWVudDogJ0V4cHJlc3Npb25TdGF0ZW1lbnQnLFxuICAgICAgICBGb3JTdGF0ZW1lbnQ6ICdGb3JTdGF0ZW1lbnQnLFxuICAgICAgICBGb3JJblN0YXRlbWVudDogJ0ZvckluU3RhdGVtZW50JyxcbiAgICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogJ0Z1bmN0aW9uRGVjbGFyYXRpb24nLFxuICAgICAgICBGdW5jdGlvbkV4cHJlc3Npb246ICdGdW5jdGlvbkV4cHJlc3Npb24nLFxuICAgICAgICBJZGVudGlmaWVyOiAnSWRlbnRpZmllcicsXG4gICAgICAgIElmU3RhdGVtZW50OiAnSWZTdGF0ZW1lbnQnLFxuICAgICAgICBJbXBvcnREZWNsYXJhdGlvbjogJ0ltcG9ydERlY2xhcmF0aW9uJyxcbiAgICAgICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogJ0ltcG9ydERlZmF1bHRTcGVjaWZpZXInLFxuICAgICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6ICdJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXInLFxuICAgICAgICBJbXBvcnRTcGVjaWZpZXI6ICdJbXBvcnRTcGVjaWZpZXInLFxuICAgICAgICBMaXRlcmFsOiAnTGl0ZXJhbCcsXG4gICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6ICdMYWJlbGVkU3RhdGVtZW50JyxcbiAgICAgICAgTG9naWNhbEV4cHJlc3Npb246ICdMb2dpY2FsRXhwcmVzc2lvbicsXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb246ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgTWV0aG9kRGVmaW5pdGlvbjogJ01ldGhvZERlZmluaXRpb24nLFxuICAgICAgICBOZXdFeHByZXNzaW9uOiAnTmV3RXhwcmVzc2lvbicsXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb246ICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICAgICAgT2JqZWN0UGF0dGVybjogJ09iamVjdFBhdHRlcm4nLFxuICAgICAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXG4gICAgICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxuICAgICAgICBSZXN0RWxlbWVudDogJ1Jlc3RFbGVtZW50JyxcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiAnUmV0dXJuU3RhdGVtZW50JyxcbiAgICAgICAgU2VxdWVuY2VFeHByZXNzaW9uOiAnU2VxdWVuY2VFeHByZXNzaW9uJyxcbiAgICAgICAgU3ByZWFkRWxlbWVudDogJ1NwcmVhZEVsZW1lbnQnLFxuICAgICAgICBTdXBlcjogJ1N1cGVyJyxcbiAgICAgICAgU3dpdGNoQ2FzZTogJ1N3aXRjaENhc2UnLFxuICAgICAgICBTd2l0Y2hTdGF0ZW1lbnQ6ICdTd2l0Y2hTdGF0ZW1lbnQnLFxuICAgICAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246ICdUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24nLFxuICAgICAgICBUZW1wbGF0ZUVsZW1lbnQ6ICdUZW1wbGF0ZUVsZW1lbnQnLFxuICAgICAgICBUZW1wbGF0ZUxpdGVyYWw6ICdUZW1wbGF0ZUxpdGVyYWwnLFxuICAgICAgICBUaGlzRXhwcmVzc2lvbjogJ1RoaXNFeHByZXNzaW9uJyxcbiAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6ICdUaHJvd1N0YXRlbWVudCcsXG4gICAgICAgIFRyeVN0YXRlbWVudDogJ1RyeVN0YXRlbWVudCcsXG4gICAgICAgIFVuYXJ5RXhwcmVzc2lvbjogJ1VuYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgIFVwZGF0ZUV4cHJlc3Npb246ICdVcGRhdGVFeHByZXNzaW9uJyxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogJ1ZhcmlhYmxlRGVjbGFyYXRpb24nLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0b3I6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICBXaGlsZVN0YXRlbWVudDogJ1doaWxlU3RhdGVtZW50JyxcbiAgICAgICAgV2l0aFN0YXRlbWVudDogJ1dpdGhTdGF0ZW1lbnQnXG4gICAgfTtcblxuICAgIFBsYWNlSG9sZGVycyA9IHtcbiAgICAgICAgQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcjogJ0Fycm93UGFyYW1ldGVyUGxhY2VIb2xkZXInXG4gICAgfTtcblxuICAgIC8vIEVycm9yIG1lc3NhZ2VzIHNob3VsZCBiZSBpZGVudGljYWwgdG8gVjguXG4gICAgTWVzc2FnZXMgPSB7XG4gICAgICAgIFVuZXhwZWN0ZWRUb2tlbjogJ1VuZXhwZWN0ZWQgdG9rZW4gJTAnLFxuICAgICAgICBVbmV4cGVjdGVkTnVtYmVyOiAnVW5leHBlY3RlZCBudW1iZXInLFxuICAgICAgICBVbmV4cGVjdGVkU3RyaW5nOiAnVW5leHBlY3RlZCBzdHJpbmcnLFxuICAgICAgICBVbmV4cGVjdGVkSWRlbnRpZmllcjogJ1VuZXhwZWN0ZWQgaWRlbnRpZmllcicsXG4gICAgICAgIFVuZXhwZWN0ZWRSZXNlcnZlZDogJ1VuZXhwZWN0ZWQgcmVzZXJ2ZWQgd29yZCcsXG4gICAgICAgIFVuZXhwZWN0ZWRUZW1wbGF0ZTogJ1VuZXhwZWN0ZWQgcXVhc2kgJTAnLFxuICAgICAgICBVbmV4cGVjdGVkRU9TOiAnVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnLFxuICAgICAgICBOZXdsaW5lQWZ0ZXJUaHJvdzogJ0lsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvdycsXG4gICAgICAgIEludmFsaWRSZWdFeHA6ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbicsXG4gICAgICAgIFVudGVybWluYXRlZFJlZ0V4cDogJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiBtaXNzaW5nIC8nLFxuICAgICAgICBJbnZhbGlkTEhTSW5Bc3NpZ25tZW50OiAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBhc3NpZ25tZW50JyxcbiAgICAgICAgSW52YWxpZExIU0luRm9ySW46ICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci1pbicsXG4gICAgICAgIE11bHRpcGxlRGVmYXVsdHNJblN3aXRjaDogJ01vcmUgdGhhbiBvbmUgZGVmYXVsdCBjbGF1c2UgaW4gc3dpdGNoIHN0YXRlbWVudCcsXG4gICAgICAgIE5vQ2F0Y2hPckZpbmFsbHk6ICdNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgYWZ0ZXIgdHJ5JyxcbiAgICAgICAgVW5rbm93bkxhYmVsOiAnVW5kZWZpbmVkIGxhYmVsIFxcJyUwXFwnJyxcbiAgICAgICAgUmVkZWNsYXJhdGlvbjogJyUwIFxcJyUxXFwnIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWQnLFxuICAgICAgICBJbGxlZ2FsQ29udGludWU6ICdJbGxlZ2FsIGNvbnRpbnVlIHN0YXRlbWVudCcsXG4gICAgICAgIElsbGVnYWxCcmVhazogJ0lsbGVnYWwgYnJlYWsgc3RhdGVtZW50JyxcbiAgICAgICAgSWxsZWdhbFJldHVybjogJ0lsbGVnYWwgcmV0dXJuIHN0YXRlbWVudCcsXG4gICAgICAgIFN0cmljdE1vZGVXaXRoOiAnU3RyaWN0IG1vZGUgY29kZSBtYXkgbm90IGluY2x1ZGUgYSB3aXRoIHN0YXRlbWVudCcsXG4gICAgICAgIFN0cmljdENhdGNoVmFyaWFibGU6ICdDYXRjaCB2YXJpYWJsZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0VmFyTmFtZTogJ1ZhcmlhYmxlIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdFBhcmFtTmFtZTogJ1BhcmFtZXRlciBuYW1lIGV2YWwgb3IgYXJndW1lbnRzIGlzIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0UGFyYW1EdXBlOiAnU3RyaWN0IG1vZGUgZnVuY3Rpb24gbWF5IG5vdCBoYXZlIGR1cGxpY2F0ZSBwYXJhbWV0ZXIgbmFtZXMnLFxuICAgICAgICBTdHJpY3RGdW5jdGlvbk5hbWU6ICdGdW5jdGlvbiBuYW1lIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RPY3RhbExpdGVyYWw6ICdPY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUuJyxcbiAgICAgICAgU3RyaWN0RGVsZXRlOiAnRGVsZXRlIG9mIGFuIHVucXVhbGlmaWVkIGlkZW50aWZpZXIgaW4gc3RyaWN0IG1vZGUuJyxcbiAgICAgICAgU3RyaWN0TEhTQXNzaWdubWVudDogJ0Fzc2lnbm1lbnQgdG8gZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RMSFNQb3N0Zml4OiAnUG9zdGZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0TEhTUHJlZml4OiAnUHJlZml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RSZXNlcnZlZFdvcmQ6ICdVc2Ugb2YgZnV0dXJlIHJlc2VydmVkIHdvcmQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBUZW1wbGF0ZU9jdGFsTGl0ZXJhbDogJ09jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiB0ZW1wbGF0ZSBzdHJpbmdzLicsXG4gICAgICAgIFBhcmFtZXRlckFmdGVyUmVzdFBhcmFtZXRlcjogJ1Jlc3QgcGFyYW1ldGVyIG11c3QgYmUgbGFzdCBmb3JtYWwgcGFyYW1ldGVyJyxcbiAgICAgICAgRGVmYXVsdFJlc3RQYXJhbWV0ZXI6ICdVbmV4cGVjdGVkIHRva2VuID0nLFxuICAgICAgICBPYmplY3RQYXR0ZXJuQXNSZXN0UGFyYW1ldGVyOiAnVW5leHBlY3RlZCB0b2tlbiB7JyxcbiAgICAgICAgRHVwbGljYXRlUHJvdG9Qcm9wZXJ0eTogJ0R1cGxpY2F0ZSBfX3Byb3RvX18gZmllbGRzIGFyZSBub3QgYWxsb3dlZCBpbiBvYmplY3QgbGl0ZXJhbHMnLFxuICAgICAgICBDb25zdHJ1Y3RvclNwZWNpYWxNZXRob2Q6ICdDbGFzcyBjb25zdHJ1Y3RvciBtYXkgbm90IGJlIGFuIGFjY2Vzc29yJyxcbiAgICAgICAgRHVwbGljYXRlQ29uc3RydWN0b3I6ICdBIGNsYXNzIG1heSBvbmx5IGhhdmUgb25lIGNvbnN0cnVjdG9yJyxcbiAgICAgICAgU3RhdGljUHJvdG90eXBlOiAnQ2xhc3NlcyBtYXkgbm90IGhhdmUgc3RhdGljIHByb3BlcnR5IG5hbWVkIHByb3RvdHlwZScsXG4gICAgICAgIE1pc3NpbmdGcm9tQ2xhdXNlOiAnVW5leHBlY3RlZCB0b2tlbicsXG4gICAgICAgIE5vQXNBZnRlckltcG9ydE5hbWVzcGFjZTogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxuICAgICAgICBJbnZhbGlkTW9kdWxlU3BlY2lmaWVyOiAnVW5leHBlY3RlZCB0b2tlbicsXG4gICAgICAgIElsbGVnYWxJbXBvcnREZWNsYXJhdGlvbjogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxuICAgICAgICBJbGxlZ2FsRXhwb3J0RGVjbGFyYXRpb246ICdVbmV4cGVjdGVkIHRva2VuJ1xuICAgIH07XG5cbiAgICAvLyBTZWUgYWxzbyB0b29scy9nZW5lcmF0ZS11bmljb2RlLXJlZ2V4LnB5LlxuICAgIFJlZ2V4ID0ge1xuICAgICAgICBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDogbmV3IFJlZ0V4cCgnW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEIyXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4XFx1MEM1OVxcdTBDNjBcXHUwQzYxXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDYwXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUMxLVxcdTE5QzdcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0Y1XFx1MUNGNlxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJFMkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGQ0NcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFRlxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTc4RVxcdUE3OTAtXFx1QTdBRFxcdUE3QjBcXHVBN0IxXFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNUZcXHVBQjY0XFx1QUI2NVxcdUFCQzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ10nKSxcbiAgICAgICAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDogbmV3IFJlZ0V4cCgnW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzAwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0ODMtXFx1MDQ4N1xcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjEwLVxcdTA2MUFcXHUwNjIwLVxcdTA2NjlcXHUwNjZFLVxcdTA2RDNcXHUwNkQ1LVxcdTA2RENcXHUwNkRGLVxcdTA2RThcXHUwNkVBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMC1cXHUwNzRBXFx1MDc0RC1cXHUwN0IxXFx1MDdDMC1cXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgyRFxcdTA4NDAtXFx1MDg1QlxcdTA4QTAtXFx1MDhCMlxcdTA4RTQtXFx1MDk2M1xcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUYxXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNjYtXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCQy1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNDLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjcxXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEMFxcdTBCRDdcXHUwQkU2LVxcdTBCRUZcXHUwQzAwLVxcdTBDMDNcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNELVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNThcXHUwQzU5XFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MS1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDAxLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNELVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU3XFx1MEQ2MC1cXHUwRDYzXFx1MEQ2Ni1cXHUwRDZGXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4MlxcdTBEODNcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREU2LVxcdTBERUZcXHUwREYyXFx1MERGM1xcdTBFMDEtXFx1MEUzQVxcdTBFNDAtXFx1MEU0RVxcdTBFNTAtXFx1MEU1OVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUI5XFx1MEVCQi1cXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFQzgtXFx1MEVDRFxcdTBFRDAtXFx1MEVEOVxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjE4XFx1MEYxOVxcdTBGMjAtXFx1MEYyOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0UtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGNzEtXFx1MEY4NFxcdTBGODYtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDAwLVxcdTEwNDlcXHUxMDUwLVxcdTEwOURcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM1RC1cXHUxMzVGXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y0XFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzE0XFx1MTcyMC1cXHUxNzM0XFx1MTc0MC1cXHUxNzUzXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3RDNcXHUxN0Q3XFx1MTdEQ1xcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxODBCLVxcdTE4MERcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5M0JcXHUxOTQ2LVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxOUQwLVxcdTE5RDlcXHUxQTAwLVxcdTFBMUJcXHUxQTIwLVxcdTFBNUVcXHUxQTYwLVxcdTFBN0NcXHUxQTdGLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQUE3XFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjRCXFx1MUI1MC1cXHUxQjU5XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQkYzXFx1MUMwMC1cXHUxQzM3XFx1MUM0MC1cXHUxQzQ5XFx1MUM0RC1cXHUxQzdEXFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0Y2XFx1MUNGOFxcdTFDRjlcXHUxRDAwLVxcdTFERjVcXHUxREZDLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAwQ1xcdTIwMERcXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ3Ri1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkRFMC1cXHUyREZGXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyRlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOTlcXHUzMDlBXFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkNDXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY3Ri1cXHVBNjlEXFx1QTY5Ri1cXHVBNkYxXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBN0FEXFx1QTdCMFxcdUE3QjFcXHVBN0Y3LVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzRcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjdcXHVBOEZCXFx1QTkwMC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUZFXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QS1cXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY2XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjVGXFx1QUI2NFxcdUFCNjVcXHVBQkMwLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMUQtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJEXFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjEwLVxcdUZGMTlcXHVGRjIxLVxcdUZGM0FcXHVGRjNGXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXScpXG4gICAgfTtcblxuICAgIC8vIEVuc3VyZSB0aGUgY29uZGl0aW9uIGlzIHRydWUsIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvci5cbiAgICAvLyBUaGlzIGlzIG9ubHkgdG8gaGF2ZSBhIGJldHRlciBjb250cmFjdCBzZW1hbnRpYywgaS5lLiBhbm90aGVyIHNhZmV0eSBuZXRcbiAgICAvLyB0byBjYXRjaCBhIGxvZ2ljIGVycm9yLiBUaGUgY29uZGl0aW9uIHNoYWxsIGJlIGZ1bGZpbGxlZCBpbiBub3JtYWwgY2FzZS5cbiAgICAvLyBEbyBOT1QgdXNlIHRoaXMgdG8gZW5mb3JjZSBhIGNlcnRhaW4gY29uZGl0aW9uIG9uIGFueSB1c2VyIGlucHV0LlxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQVNTRVJUOiAnICsgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID49IDB4MzAgJiYgY2ggPD0gMHgzOSk7ICAgLy8gMC4uOVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSGV4RGlnaXQoY2gpIHtcbiAgICAgICAgcmV0dXJuICcwMTIzNDU2Nzg5YWJjZGVmQUJDREVGJy5pbmRleE9mKGNoKSA+PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2N0YWxEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gJzAxMjM0NTY3Jy5pbmRleE9mKGNoKSA+PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9jdGFsVG9EZWNpbWFsKGNoKSB7XG4gICAgICAgIC8vIFxcMCBpcyBub3Qgb2N0YWwgZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgIHZhciBvY3RhbCA9IChjaCAhPT0gJzAnKSwgY29kZSA9ICcwMTIzNDU2NycuaW5kZXhPZihjaCk7XG5cbiAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGlzT2N0YWxEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xuICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgJzAxMjM0NTY3Jy5pbmRleE9mKHNvdXJjZVtpbmRleCsrXSk7XG5cbiAgICAgICAgICAgIC8vIDMgZGlnaXRzIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiBzdHJpbmcgc3RhcnRzXG4gICAgICAgICAgICAvLyB3aXRoIDAsIDEsIDIsIDNcbiAgICAgICAgICAgIGlmICgnMDEyMycuaW5kZXhPZihjaCkgPj0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBpbmRleCA8IGxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyAnMDEyMzQ1NjcnLmluZGV4T2Yoc291cmNlW2luZGV4KytdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgb2N0YWw6IG9jdGFsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gNy4yIFdoaXRlIFNwYWNlXG5cbiAgICBmdW5jdGlvbiBpc1doaXRlU3BhY2UoY2gpIHtcbiAgICAgICAgcmV0dXJuIChjaCA9PT0gMHgyMCkgfHwgKGNoID09PSAweDA5KSB8fCAoY2ggPT09IDB4MEIpIHx8IChjaCA9PT0gMHgwQykgfHwgKGNoID09PSAweEEwKSB8fFxuICAgICAgICAgICAgKGNoID49IDB4MTY4MCAmJiBbMHgxNjgwLCAweDE4MEUsIDB4MjAwMCwgMHgyMDAxLCAweDIwMDIsIDB4MjAwMywgMHgyMDA0LCAweDIwMDUsIDB4MjAwNiwgMHgyMDA3LCAweDIwMDgsIDB4MjAwOSwgMHgyMDBBLCAweDIwMkYsIDB4MjA1RiwgMHgzMDAwLCAweEZFRkZdLmluZGV4T2YoY2gpID49IDApO1xuICAgIH1cblxuICAgIC8vIDcuMyBMaW5lIFRlcm1pbmF0b3JzXG5cbiAgICBmdW5jdGlvbiBpc0xpbmVUZXJtaW5hdG9yKGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPT09IDB4MEEpIHx8IChjaCA9PT0gMHgwRCkgfHwgKGNoID09PSAweDIwMjgpIHx8IChjaCA9PT0gMHgyMDI5KTtcbiAgICB9XG5cbiAgICAvLyA3LjYgSWRlbnRpZmllciBOYW1lcyBhbmQgSWRlbnRpZmllcnNcblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPT09IDB4MjQpIHx8IChjaCA9PT0gMHg1RikgfHwgIC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXG4gICAgICAgICAgICAoY2ggPj0gMHg0MSAmJiBjaCA8PSAweDVBKSB8fCAgICAgICAgIC8vIEEuLlpcbiAgICAgICAgICAgIChjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EpIHx8ICAgICAgICAgLy8gYS4uelxuICAgICAgICAgICAgKGNoID09PSAweDVDKSB8fCAgICAgICAgICAgICAgICAgICAgICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICAgKChjaCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAweDI0KSB8fCAoY2ggPT09IDB4NUYpIHx8ICAvLyAkIChkb2xsYXIpIGFuZCBfICh1bmRlcnNjb3JlKVxuICAgICAgICAgICAgKGNoID49IDB4NDEgJiYgY2ggPD0gMHg1QSkgfHwgICAgICAgICAvLyBBLi5aXG4gICAgICAgICAgICAoY2ggPj0gMHg2MSAmJiBjaCA8PSAweDdBKSB8fCAgICAgICAgIC8vIGEuLnpcbiAgICAgICAgICAgIChjaCA+PSAweDMwICYmIGNoIDw9IDB4MzkpIHx8ICAgICAgICAgLy8gMC4uOVxuICAgICAgICAgICAgKGNoID09PSAweDVDKSB8fCAgICAgICAgICAgICAgICAgICAgICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICAgKChjaCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJQYXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKTtcbiAgICB9XG5cbiAgICAvLyA3LjYuMS4yIEZ1dHVyZSBSZXNlcnZlZCBXb3Jkc1xuXG4gICAgZnVuY3Rpb24gaXNGdXR1cmVSZXNlcnZlZFdvcmQoaWQpIHtcbiAgICAgICAgc3dpdGNoIChpZCkge1xuICAgICAgICBjYXNlICdlbnVtJzpcbiAgICAgICAgY2FzZSAnZXhwb3J0JzpcbiAgICAgICAgY2FzZSAnaW1wb3J0JzpcbiAgICAgICAgY2FzZSAnc3VwZXInOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAxMS42LjIuMiBGdXR1cmUgUmVzZXJ2ZWQgV29yZHNcblxuICAgIGZ1bmN0aW9uIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZCkge1xuICAgICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxuICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxuICAgICAgICBjYXNlICdwYWNrYWdlJzpcbiAgICAgICAgY2FzZSAncHJpdmF0ZSc6XG4gICAgICAgIGNhc2UgJ3Byb3RlY3RlZCc6XG4gICAgICAgIGNhc2UgJ3B1YmxpYyc6XG4gICAgICAgIGNhc2UgJ3N0YXRpYyc6XG4gICAgICAgIGNhc2UgJ3lpZWxkJzpcbiAgICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNSZXN0cmljdGVkV29yZChpZCkge1xuICAgICAgICByZXR1cm4gaWQgPT09ICdldmFsJyB8fCBpZCA9PT0gJ2FyZ3VtZW50cyc7XG4gICAgfVxuXG4gICAgLy8gNy42LjEuMSBLZXl3b3Jkc1xuXG4gICAgZnVuY3Rpb24gaXNLZXl3b3JkKGlkKSB7XG5cbiAgICAgICAgLy8gJ2NvbnN0JyBpcyBzcGVjaWFsaXplZCBhcyBLZXl3b3JkIGluIFY4LlxuICAgICAgICAvLyAneWllbGQnIGFuZCAnbGV0JyBhcmUgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBTcGlkZXJNb25rZXkgYW5kIEVTLm5leHQuXG4gICAgICAgIC8vIFNvbWUgb3RoZXJzIGFyZSBmcm9tIGZ1dHVyZSByZXNlcnZlZCB3b3Jkcy5cblxuICAgICAgICBzd2l0Y2ggKGlkLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnaWYnKSB8fCAoaWQgPT09ICdpbicpIHx8IChpZCA9PT0gJ2RvJyk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd2YXInKSB8fCAoaWQgPT09ICdmb3InKSB8fCAoaWQgPT09ICduZXcnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ3RyeScpIHx8IChpZCA9PT0gJ2xldCcpO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAndGhpcycpIHx8IChpZCA9PT0gJ2Vsc2UnKSB8fCAoaWQgPT09ICdjYXNlJykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICd2b2lkJykgfHwgKGlkID09PSAnd2l0aCcpIHx8IChpZCA9PT0gJ2VudW0nKTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3doaWxlJykgfHwgKGlkID09PSAnYnJlYWsnKSB8fCAoaWQgPT09ICdjYXRjaCcpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAndGhyb3cnKSB8fCAoaWQgPT09ICdjb25zdCcpIHx8IChpZCA9PT0gJ3lpZWxkJykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICdjbGFzcycpIHx8IChpZCA9PT0gJ3N1cGVyJyk7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdyZXR1cm4nKSB8fCAoaWQgPT09ICd0eXBlb2YnKSB8fCAoaWQgPT09ICdkZWxldGUnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ3N3aXRjaCcpIHx8IChpZCA9PT0gJ2V4cG9ydCcpIHx8IChpZCA9PT0gJ2ltcG9ydCcpO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnZGVmYXVsdCcpIHx8IChpZCA9PT0gJ2ZpbmFsbHknKSB8fCAoaWQgPT09ICdleHRlbmRzJyk7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdmdW5jdGlvbicpIHx8IChpZCA9PT0gJ2NvbnRpbnVlJykgfHwgKGlkID09PSAnZGVidWdnZXInKTtcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpbnN0YW5jZW9mJyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA3LjQgQ29tbWVudHNcblxuICAgIGZ1bmN0aW9uIGFkZENvbW1lbnQodHlwZSwgdmFsdWUsIHN0YXJ0LCBlbmQsIGxvYykge1xuICAgICAgICB2YXIgY29tbWVudDtcblxuICAgICAgICBhc3NlcnQodHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJywgJ0NvbW1lbnQgbXVzdCBoYXZlIHZhbGlkIHBvc2l0aW9uJyk7XG5cbiAgICAgICAgc3RhdGUubGFzdENvbW1lbnRTdGFydCA9IHN0YXJ0O1xuXG4gICAgICAgIGNvbW1lbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgY29tbWVudC5yYW5nZSA9IFtzdGFydCwgZW5kXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICBjb21tZW50LmxvYyA9IGxvYztcbiAgICAgICAgfVxuICAgICAgICBleHRyYS5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICBpZiAoZXh0cmEuYXR0YWNoQ29tbWVudCkge1xuICAgICAgICAgICAgZXh0cmEubGVhZGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICBleHRyYS50cmFpbGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2lwU2luZ2xlTGluZUNvbW1lbnQob2Zmc2V0KSB7XG4gICAgICAgIHZhciBzdGFydCwgbG9jLCBjaCwgY29tbWVudDtcblxuICAgICAgICBzdGFydCA9IGluZGV4IC0gb2Zmc2V0O1xuICAgICAgICBsb2MgPSB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydCAtIG9mZnNldFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICAgICAgICAgICAgaGFzTGluZVRlcm1pbmF0b3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChleHRyYS5jb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gc291cmNlLnNsaWNlKHN0YXJ0ICsgb2Zmc2V0LCBpbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnQgLSAxXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGFkZENvbW1lbnQoJ0xpbmUnLCBjb21tZW50LCBzdGFydCwgaW5kZXggLSAxLCBsb2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDEzICYmIHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRyYS5jb21tZW50cykge1xuICAgICAgICAgICAgY29tbWVudCA9IHNvdXJjZS5zbGljZShzdGFydCArIG9mZnNldCwgaW5kZXgpO1xuICAgICAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhZGRDb21tZW50KCdMaW5lJywgY29tbWVudCwgc3RhcnQsIGluZGV4LCBsb2MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tpcE11bHRpTGluZUNvbW1lbnQoKSB7XG4gICAgICAgIHZhciBzdGFydCwgbG9jLCBjaCwgY29tbWVudDtcblxuICAgICAgICBpZiAoZXh0cmEuY29tbWVudHMpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gaW5kZXggLSAyO1xuICAgICAgICAgICAgbG9jID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnQgLSAyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MEQgJiYgc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSA9PT0gMHgwQSkge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYXNMaW5lVGVybWluYXRvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAweDJBKSB7XG4gICAgICAgICAgICAgICAgLy8gQmxvY2sgY29tbWVudCBlbmRzIHdpdGggJyovJy5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSA9PT0gMHgyRikge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmEuY29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQgKyAyLCBpbmRleCAtIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDb21tZW50KCdCbG9jaycsIGNvbW1lbnQsIHN0YXJ0LCBpbmRleCwgbG9jKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSYW4gb2ZmIHRoZSBlbmQgb2YgdGhlIGZpbGUgLSB0aGUgd2hvbGUgdGhpbmcgaXMgYSBjb21tZW50XG4gICAgICAgIGlmIChleHRyYS5jb21tZW50cykge1xuICAgICAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb21tZW50ID0gc291cmNlLnNsaWNlKHN0YXJ0ICsgMiwgaW5kZXgpO1xuICAgICAgICAgICAgYWRkQ29tbWVudCgnQmxvY2snLCBjb21tZW50LCBzdGFydCwgaW5kZXgsIGxvYyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2lwQ29tbWVudCgpIHtcbiAgICAgICAgdmFyIGNoLCBzdGFydDtcbiAgICAgICAgaGFzTGluZVRlcm1pbmF0b3IgPSBmYWxzZTtcblxuICAgICAgICBzdGFydCA9IChpbmRleCA9PT0gMCk7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICAgICAgICAgIGlmIChpc1doaXRlU3BhY2UoY2gpKSB7XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaCkpIHtcbiAgICAgICAgICAgICAgICBoYXNMaW5lVGVybWluYXRvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MEQgJiYgc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDBBKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAweDJGKSB7IC8vIFUrMDAyRiBpcyAnLydcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAweDJGKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHNraXBTaW5nbGVMaW5lQ29tbWVudCgyKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MkEpIHsgIC8vIFUrMDAyQSBpcyAnKidcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgc2tpcE11bHRpTGluZUNvbW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0ICYmIGNoID09PSAweDJEKSB7IC8vIFUrMDAyRCBpcyAnLSdcbiAgICAgICAgICAgICAgICAvLyBVKzAwM0UgaXMgJz4nXG4gICAgICAgICAgICAgICAgaWYgKChzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpID09PSAweDJEKSAmJiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAyKSA9PT0gMHgzRSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gJy0tPicgaXMgYSBzaW5nbGUtbGluZSBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgICAgICAgICAgIHNraXBTaW5nbGVMaW5lQ29tbWVudCgzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAweDNDKSB7IC8vIFUrMDAzQyBpcyAnPCdcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKGluZGV4ICsgMSwgaW5kZXggKyA0KSA9PT0gJyEtLScpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDsgLy8gYDxgXG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7IC8vIGAhYFxuICAgICAgICAgICAgICAgICAgICArK2luZGV4OyAvLyBgLWBcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDsgLy8gYC1gXG4gICAgICAgICAgICAgICAgICAgIHNraXBTaW5nbGVMaW5lQ29tbWVudCg0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbkhleEVzY2FwZShwcmVmaXgpIHtcbiAgICAgICAgdmFyIGksIGxlbiwgY2gsIGNvZGUgPSAwO1xuXG4gICAgICAgIGxlbiA9IChwcmVmaXggPT09ICd1JykgPyA0IDogMjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgaXNIZXhEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogMTYgKyAnMDEyMzQ1Njc4OWFiY2RlZicuaW5kZXhPZihjaC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCkge1xuICAgICAgICB2YXIgY2gsIGNvZGUsIGN1MSwgY3UyO1xuXG4gICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgY29kZSA9IDA7XG5cbiAgICAgICAgLy8gQXQgbGVhc3QsIG9uZSBoZXggZGlnaXQgaXMgcmVxdWlyZWQuXG4gICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIGlmICghaXNIZXhEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGUgPSBjb2RlICogMTYgKyAnMDEyMzQ1Njc4OWFiY2RlZicuaW5kZXhPZihjaC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID4gMHgxMEZGRkYgfHwgY2ggIT09ICd9Jykge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVURi0xNiBFbmNvZGluZ1xuICAgICAgICBpZiAoY29kZSA8PSAweEZGRkYpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGN1MSA9ICgoY29kZSAtIDB4MTAwMDApID4+IDEwKSArIDB4RDgwMDtcbiAgICAgICAgY3UyID0gKChjb2RlIC0gMHgxMDAwMCkgJiAxMDIzKSArIDB4REMwMDtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY3UxLCBjdTIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVzY2FwZWRJZGVudGlmaWVyKCkge1xuICAgICAgICB2YXIgY2gsIGlkO1xuXG4gICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgrKyk7XG4gICAgICAgIGlkID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG5cbiAgICAgICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICBpZiAoY2ggPT09IDB4NUMpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgIT09IDB4NzUpIHtcbiAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgaWYgKCFjaCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFpc0lkZW50aWZpZXJTdGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZCA9IGNoO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBpZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcblxuICAgICAgICAgICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgaWYgKGNoID09PSAweDVDKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBpZC5zdWJzdHIoMCwgaWQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSAhPT0gMHg3NSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgICAgIGlmICghY2ggfHwgY2ggPT09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyUGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZCArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJZGVudGlmaWVyKCkge1xuICAgICAgICB2YXIgc3RhcnQsIGNoO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXgrKztcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgICAgICAgICAgIC8vIEJsYWNrc2xhc2ggKFUrMDA1QykgbWFya3MgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgaW5kZXggPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RXNjYXBlZElkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZShzdGFydCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5JZGVudGlmaWVyKCkge1xuICAgICAgICB2YXIgc3RhcnQsIGlkLCB0eXBlO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXg7XG5cbiAgICAgICAgLy8gQmFja3NsYXNoIChVKzAwNUMpIHN0YXJ0cyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgaWQgPSAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDVDKSA/IGdldEVzY2FwZWRJZGVudGlmaWVyKCkgOiBnZXRJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgLy8gVGhlcmUgaXMgbm8ga2V5d29yZCBvciBsaXRlcmFsIHdpdGggb25seSBvbmUgY2hhcmFjdGVyLlxuICAgICAgICAvLyBUaHVzLCBpdCBtdXN0IGJlIGFuIGlkZW50aWZpZXIuXG4gICAgICAgIGlmIChpZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHR5cGUgPSBUb2tlbi5JZGVudGlmaWVyO1xuICAgICAgICB9IGVsc2UgaWYgKGlzS2V5d29yZChpZCkpIHtcbiAgICAgICAgICAgIHR5cGUgPSBUb2tlbi5LZXl3b3JkO1xuICAgICAgICB9IGVsc2UgaWYgKGlkID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgIHR5cGUgPSBUb2tlbi5OdWxsTGl0ZXJhbDtcbiAgICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ3RydWUnIHx8IGlkID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICB0eXBlID0gVG9rZW4uQm9vbGVhbkxpdGVyYWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gVG9rZW4uSWRlbnRpZmllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgdmFsdWU6IGlkLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgLy8gNy43IFB1bmN0dWF0b3JzXG5cbiAgICBmdW5jdGlvbiBzY2FuUHVuY3R1YXRvcigpIHtcbiAgICAgICAgdmFyIHRva2VuLCBzdHI7XG5cbiAgICAgICAgdG9rZW4gPSB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IGluZGV4LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBtb3N0IGNvbW1vbiBzaW5nbGUtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxuICAgICAgICBzdHIgPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBzd2l0Y2ggKHN0cikge1xuXG4gICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgICAgaWYgKGV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgICAgICAgZXh0cmEub3BlblBhcmVuVG9rZW4gPSBleHRyYS50b2tlbnMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgaWYgKGV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgICAgICAgZXh0cmEub3BlbkN1cmx5VG9rZW4gPSBleHRyYS50b2tlbnMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUuY3VybHlTdGFjay5wdXNoKCd7Jyk7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICcuJyAmJiBzb3VyY2VbaW5kZXggKyAxXSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgLy8gU3ByZWFkIG9wZXJhdG9yOiAuLi5cbiAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgIHN0ciA9ICcuLi4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgc3RhdGUuY3VybHlTdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcpJzpcbiAgICAgICAgY2FzZSAnOyc6XG4gICAgICAgIGNhc2UgJywnOlxuICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgIGNhc2UgJzonOlxuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgY2FzZSAnfic6XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIDQtY2hhcmFjdGVyIHB1bmN0dWF0b3IuXG4gICAgICAgICAgICBzdHIgPSBzb3VyY2Uuc3Vic3RyKGluZGV4LCA0KTtcbiAgICAgICAgICAgIGlmIChzdHIgPT09ICc+Pj49Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gMy1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigwLCAzKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09PSAnPT09JyB8fCBzdHIgPT09ICchPT0nIHx8IHN0ciA9PT0gJz4+PicgfHxcbiAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnPDw9JyB8fCBzdHIgPT09ICc+Pj0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyAyLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigwLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ciA9PT0gJyYmJyB8fCBzdHIgPT09ICd8fCcgfHwgc3RyID09PSAnPT0nIHx8IHN0ciA9PT0gJyE9JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnKz0nIHx8IHN0ciA9PT0gJy09JyB8fCBzdHIgPT09ICcqPScgfHwgc3RyID09PSAnLz0nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICcrKycgfHwgc3RyID09PSAnLS0nIHx8IHN0ciA9PT0gJzw8JyB8fCBzdHIgPT09ICc+PicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJyY9JyB8fCBzdHIgPT09ICd8PScgfHwgc3RyID09PSAnXj0nIHx8IHN0ciA9PT0gJyU9JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnPD0nIHx8IHN0ciA9PT0gJz49JyB8fCBzdHIgPT09ICc9PicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnPD49ISstKiUmfF4vJy5pbmRleE9mKHN0cikgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPT09IHRva2VuLnN0YXJ0KSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9rZW4uZW5kID0gaW5kZXg7XG4gICAgICAgIHRva2VuLnZhbHVlID0gc3RyO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgLy8gNy44LjMgTnVtZXJpYyBMaXRlcmFsc1xuXG4gICAgZnVuY3Rpb24gc2NhbkhleExpdGVyYWwoc3RhcnQpIHtcbiAgICAgICAgdmFyIG51bWJlciA9ICcnO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFpc0hleERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG51bWJlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludCgnMHgnICsgbnVtYmVyLCAxNiksXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbkJpbmFyeUxpdGVyYWwoc3RhcnQpIHtcbiAgICAgICAgdmFyIGNoLCBudW1iZXI7XG5cbiAgICAgICAgbnVtYmVyID0gJyc7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoY2ggIT09ICcwJyAmJiBjaCAhPT0gJzEnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG51bWJlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIG9ubHkgMGIgb3IgMEJcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjaCkgfHwgaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW1iZXIsIDIpLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5PY3RhbExpdGVyYWwocHJlZml4LCBzdGFydCkge1xuICAgICAgICB2YXIgbnVtYmVyLCBvY3RhbDtcblxuICAgICAgICBpZiAoaXNPY3RhbERpZ2l0KHByZWZpeCkpIHtcbiAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgIG51bWJlciA9ICcwJyArIHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9jdGFsID0gZmFsc2U7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgbnVtYmVyID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvY3RhbCAmJiBudW1iZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBvbmx5IDBvIG9yIDBPXG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkgfHwgaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW1iZXIsIDgpLFxuICAgICAgICAgICAgb2N0YWw6IG9jdGFsLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSW1wbGljaXRPY3RhbExpdGVyYWwoKSB7XG4gICAgICAgIHZhciBpLCBjaDtcblxuICAgICAgICAvLyBJbXBsaWNpdCBvY3RhbCwgdW5sZXNzIHRoZXJlIGlzIGEgbm9uLW9jdGFsIGRpZ2l0LlxuICAgICAgICAvLyAoQW5uZXggQi4xLjEgb24gTnVtZXJpYyBMaXRlcmFscylcbiAgICAgICAgZm9yIChpID0gaW5kZXggKyAxOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2ldO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnOCcgfHwgY2ggPT09ICc5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2Nhbk51bWVyaWNMaXRlcmFsKCkge1xuICAgICAgICB2YXIgbnVtYmVyLCBzdGFydCwgY2g7XG5cbiAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBhc3NlcnQoaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkgfHwgKGNoID09PSAnLicpLFxuICAgICAgICAgICAgJ051bWVyaWMgbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBkZWNpbWFsIGRpZ2l0IG9yIGEgZGVjaW1hbCBwb2ludCcpO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXg7XG4gICAgICAgIG51bWJlciA9ICcnO1xuICAgICAgICBpZiAoY2ggIT09ICcuJykge1xuICAgICAgICAgICAgbnVtYmVyID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuXG4gICAgICAgICAgICAvLyBIZXggbnVtYmVyIHN0YXJ0cyB3aXRoICcweCcuXG4gICAgICAgICAgICAvLyBPY3RhbCBudW1iZXIgc3RhcnRzIHdpdGggJzAnLlxuICAgICAgICAgICAgLy8gT2N0YWwgbnVtYmVyIGluIEVTNiBzdGFydHMgd2l0aCAnMG8nLlxuICAgICAgICAgICAgLy8gQmluYXJ5IG51bWJlciBpbiBFUzYgc3RhcnRzIHdpdGggJzBiJy5cbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09ICcwJykge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3gnIHx8IGNoID09PSAnWCcpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5IZXhMaXRlcmFsKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnYicgfHwgY2ggPT09ICdCJykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhbkJpbmFyeUxpdGVyYWwoc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdvJyB8fCBjaCA9PT0gJ08nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuT2N0YWxMaXRlcmFsKGNoLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW1wbGljaXRPY3RhbExpdGVyYWwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5PY3RhbExpdGVyYWwoY2gsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoY2ggPT09ICcrJyB8fCBjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KG51bWJlciksXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gNy44LjQgU3RyaW5nIExpdGVyYWxzXG5cbiAgICBmdW5jdGlvbiBzY2FuU3RyaW5nTGl0ZXJhbCgpIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnLCBxdW90ZSwgc3RhcnQsIGNoLCB1bmVzY2FwZWQsIG9jdFRvRGVjLCBvY3RhbCA9IGZhbHNlO1xuXG4gICAgICAgIHF1b3RlID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgYXNzZXJ0KChxdW90ZSA9PT0gJ1xcJycgfHwgcXVvdGUgPT09ICdcIicpLFxuICAgICAgICAgICAgJ1N0cmluZyBsaXRlcmFsIG11c3Qgc3RhcnRzIHdpdGggYSBxdW90ZScpO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICsraW5kZXg7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xuICAgICAgICAgICAgICAgIHF1b3RlID0gJyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoIHx8ICFpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZXNjYXBlZCA9IHNjYW5IZXhFc2NhcGUoY2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdW5lc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSB1bmVzY2FwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xccic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcYic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcZic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xceDBCJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICc4JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnOSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdFRvRGVjID0gb2N0YWxUb0RlY2ltYWwoY2gpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2N0YWwgPSBvY3RUb0RlYy5vY3RhbCB8fCBvY3RhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShvY3RUb0RlYy5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgc291cmNlW2luZGV4XSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChxdW90ZSAhPT0gJycpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogVG9rZW4uU3RyaW5nTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBzdHIsXG4gICAgICAgICAgICBvY3RhbDogb2N0YWwsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBzdGFydExpbmVOdW1iZXIsXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IHN0YXJ0TGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5UZW1wbGF0ZSgpIHtcbiAgICAgICAgdmFyIGNvb2tlZCA9ICcnLCBjaCwgc3RhcnQsIHJhd09mZnNldCwgdGVybWluYXRlZCwgaGVhZCwgdGFpbCwgcmVzdG9yZSwgdW5lc2NhcGVkO1xuXG4gICAgICAgIHRlcm1pbmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGFpbCA9IGZhbHNlO1xuICAgICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgICBoZWFkID0gKHNvdXJjZVtpbmRleF0gPT09ICdgJyk7XG4gICAgICAgIHJhd09mZnNldCA9IDI7XG5cbiAgICAgICAgKytpbmRleDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnYCcpIHtcbiAgICAgICAgICAgICAgICByYXdPZmZzZXQgPSAxO1xuICAgICAgICAgICAgICAgIHRhaWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJyQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jdXJseVN0YWNrLnB1c2goJyR7Jyk7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgaWYgKCFpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xccic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RvcmUgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWQgPSBzY2FuSGV4RXNjYXBlKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSB1bmVzY2FwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN0b3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXGInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXGYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXHYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbDogXFwwMSBcXDAyIGFuZCBzbyBvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLlRlbXBsYXRlT2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXDAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbDogXFwxIFxcMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuVGVtcGxhdGVPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcbic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvb2tlZCArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGVybWluYXRlZCkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuY3VybHlTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5UZW1wbGF0ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgY29va2VkOiBjb29rZWQsXG4gICAgICAgICAgICAgICAgcmF3OiBzb3VyY2Uuc2xpY2Uoc3RhcnQgKyAxLCBpbmRleCAtIHJhd09mZnNldClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoZWFkOiBoZWFkLFxuICAgICAgICAgICAgdGFpbDogdGFpbCxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0UmVnRXhwKHBhdHRlcm4sIGZsYWdzKSB7XG4gICAgICAgIHZhciB0bXAgPSBwYXR0ZXJuO1xuXG4gICAgICAgIGlmIChmbGFncy5pbmRleE9mKCd1JykgPj0gMCkge1xuICAgICAgICAgICAgLy8gUmVwbGFjZSBlYWNoIGFzdHJhbCBzeW1ib2wgYW5kIGV2ZXJ5IFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgICAgICAvLyB0aGF0IHBvc3NpYmx5IHJlcHJlc2VudHMgYW4gYXN0cmFsIHN5bWJvbCBvciBhIHBhaXJlZCBzdXJyb2dhdGVcbiAgICAgICAgICAgIC8vIHdpdGggYSBzaW5nbGUgQVNDSUkgc3ltYm9sIHRvIGF2b2lkIHRocm93aW5nIG9uIHJlZ3VsYXJcbiAgICAgICAgICAgIC8vIGV4cHJlc3Npb25zIHRoYXQgYXJlIG9ubHkgdmFsaWQgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgYC91YFxuICAgICAgICAgICAgLy8gZmxhZy5cbiAgICAgICAgICAgIC8vIE5vdGU6IHJlcGxhY2luZyB3aXRoIHRoZSBBU0NJSSBzeW1ib2wgYHhgIG1pZ2h0IGNhdXNlIGZhbHNlXG4gICAgICAgICAgICAvLyBuZWdhdGl2ZXMgaW4gdW5saWtlbHkgc2NlbmFyaW9zLiBGb3IgZXhhbXBsZSwgYFtcXHV7NjF9LWJdYCBpcyBhXG4gICAgICAgICAgICAvLyBwZXJmZWN0bHkgdmFsaWQgcGF0dGVybiB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gYFthLWJdYCwgYnV0IGl0XG4gICAgICAgICAgICAvLyB3b3VsZCBiZSByZXBsYWNlZCBieSBgW3gtYl1gIHdoaWNoIHRocm93cyBhbiBlcnJvci5cbiAgICAgICAgICAgIHRtcCA9IHRtcFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcdVxceyhbMC05YS1mQS1GXSspXFx9L2csIGZ1bmN0aW9uICgkMCwgJDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KCQxLCAxNikgPD0gMHgxMEZGRkYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAneCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obnVsbCwgTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgL1xcXFx1KFthLWZBLUYwLTldezR9KXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2csXG4gICAgICAgICAgICAgICAgICAgICd4J1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXJzdCwgZGV0ZWN0IGludmFsaWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlZ0V4cCh0bXApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihudWxsLCBNZXNzYWdlcy5JbnZhbGlkUmVnRXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QgZm9yIHRoaXMgcGF0dGVybi1mbGFnIHBhaXIsIG9yXG4gICAgICAgIC8vIGBudWxsYCBpbiBjYXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZmxhZ3MgaXRcbiAgICAgICAgLy8gdXNlcy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5SZWdFeHBCb2R5KCkge1xuICAgICAgICB2YXIgY2gsIHN0ciwgY2xhc3NNYXJrZXIsIHRlcm1pbmF0ZWQsIGJvZHk7XG5cbiAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBhc3NlcnQoY2ggPT09ICcvJywgJ1JlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIHNsYXNoJyk7XG4gICAgICAgIHN0ciA9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICBjbGFzc01hcmtlciA9IGZhbHNlO1xuICAgICAgICB0ZXJtaW5hdGVkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIC8vIEVDTUEtMjYyIDcuOC41XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obnVsbCwgTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obnVsbCwgTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NNYXJrZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc01hcmtlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVybWluYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc01hcmtlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0ZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihudWxsLCBNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhjbHVkZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cbiAgICAgICAgYm9keSA9IHN0ci5zdWJzdHIoMSwgc3RyLmxlbmd0aCAtIDIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGJvZHksXG4gICAgICAgICAgICBsaXRlcmFsOiBzdHJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuUmVnRXhwRmxhZ3MoKSB7XG4gICAgICAgIHZhciBjaCwgc3RyLCBmbGFncywgcmVzdG9yZTtcblxuICAgICAgICBzdHIgPSAnJztcbiAgICAgICAgZmxhZ3MgPSAnJztcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RvcmUgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSBzY2FuSGV4RXNjYXBlKCd1Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHN0ciArPSAnXFxcXHUnOyByZXN0b3JlIDwgaW5kZXg7ICsrcmVzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBzb3VyY2VbcmVzdG9yZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3RvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFncyArPSAndSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFx1JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbGFncyArPSBjaDtcbiAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGZsYWdzLFxuICAgICAgICAgICAgbGl0ZXJhbDogc3RyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhblJlZ0V4cCgpIHtcbiAgICAgICAgc2Nhbm5pbmcgPSB0cnVlO1xuICAgICAgICB2YXIgc3RhcnQsIGJvZHksIGZsYWdzLCB2YWx1ZTtcblxuICAgICAgICBsb29rYWhlYWQgPSBudWxsO1xuICAgICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgICBzdGFydCA9IGluZGV4O1xuXG4gICAgICAgIGJvZHkgPSBzY2FuUmVnRXhwQm9keSgpO1xuICAgICAgICBmbGFncyA9IHNjYW5SZWdFeHBGbGFncygpO1xuICAgICAgICB2YWx1ZSA9IHRlc3RSZWdFeHAoYm9keS52YWx1ZSwgZmxhZ3MudmFsdWUpO1xuICAgICAgICBzY2FubmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoZXh0cmEudG9rZW5pemUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUmVndWxhckV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGJvZHkudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzOiBmbGFncy52YWx1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaXRlcmFsOiBib2R5LmxpdGVyYWwgKyBmbGFncy5saXRlcmFsLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgcmVnZXg6IHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBib2R5LnZhbHVlLFxuICAgICAgICAgICAgICAgIGZsYWdzOiBmbGFncy52YWx1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2xsZWN0UmVnZXgoKSB7XG4gICAgICAgIHZhciBwb3MsIGxvYywgcmVnZXgsIHRva2VuO1xuXG4gICAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgICAgcG9zID0gaW5kZXg7XG4gICAgICAgIGxvYyA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnZXggPSBzY2FuUmVnRXhwKCk7XG5cbiAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgIH07XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKCFleHRyYS50b2tlbml6ZSkge1xuICAgICAgICAgICAgLy8gUG9wIHRoZSBwcmV2aW91cyB0b2tlbiwgd2hpY2ggaXMgbGlrZWx5ICcvJyBvciAnLz0nXG4gICAgICAgICAgICBpZiAoZXh0cmEudG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnJhbmdlWzBdID09PSBwb3MgJiYgdG9rZW4udHlwZSA9PT0gJ1B1bmN0dWF0b3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJy8nIHx8IHRva2VuLnZhbHVlID09PSAnLz0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYS50b2tlbnMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4dHJhLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUmVndWxhckV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZWdleC5saXRlcmFsLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiByZWdleC5yZWdleCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3BvcywgaW5kZXhdLFxuICAgICAgICAgICAgICAgIGxvYzogbG9jXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJOYW1lKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyIHx8XG4gICAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkIHx8XG4gICAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5Cb29sZWFuTGl0ZXJhbCB8fFxuICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uTnVsbExpdGVyYWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWR2YW5jZVNsYXNoKCkge1xuICAgICAgICB2YXIgcHJldlRva2VuLFxuICAgICAgICAgICAgY2hlY2tUb2tlbjtcbiAgICAgICAgLy8gVXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXG4gICAgICAgIHByZXZUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICghcHJldlRva2VuKSB7XG4gICAgICAgICAgICAvLyBOb3RoaW5nIGJlZm9yZSB0aGF0OiBpdCBjYW5ub3QgYmUgYSBkaXZpc2lvbi5cbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlRva2VuLnR5cGUgPT09ICdQdW5jdHVhdG9yJykge1xuICAgICAgICAgICAgaWYgKHByZXZUb2tlbi52YWx1ZSA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICBjaGVja1Rva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5QYXJlblRva2VuIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrVG9rZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udHlwZSA9PT0gJ0tleXdvcmQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ2lmJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udmFsdWUgPT09ICd3aGlsZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuLnZhbHVlID09PSAnZm9yJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udmFsdWUgPT09ICd3aXRoJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICd9Jykge1xuICAgICAgICAgICAgICAgIC8vIERpdmlkaW5nIGEgZnVuY3Rpb24gYnkgYW55dGhpbmcgbWFrZXMgbGl0dGxlIHNlbnNlLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIHRvIGNoZWNrIGZvciB0aGF0LlxuICAgICAgICAgICAgICAgIGlmIChleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSAzXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gM10udHlwZSA9PT0gJ0tleXdvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFub255bW91cyBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA0XSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNF0udHlwZSA9PT0gJ0tleXdvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5hbWVkIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNoZWNrVG9rZW4gZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmdW5jdGlvbiBpc1xuICAgICAgICAgICAgICAgIC8vIGEgZGVjbGFyYXRpb24gb3IgYW4gZXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgICBpZiAoRm5FeHByVG9rZW5zLmluZGV4T2YoY2hlY2tUb2tlbi52YWx1ZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJdCBpcyBhbiBleHByZXNzaW9uLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSXQgaXMgYSBkZWNsYXJhdGlvbi5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZUb2tlbi50eXBlID09PSAnS2V5d29yZCcgJiYgcHJldlRva2VuLnZhbHVlICE9PSAndGhpcycpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZHZhbmNlKCkge1xuICAgICAgICB2YXIgY2gsIHRva2VuO1xuXG4gICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uRU9GLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGluZGV4LFxuICAgICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHNjYW5JZGVudGlmaWVyKCk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gVG9rZW4uS2V5d29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZlcnkgY29tbW9uOiAoIGFuZCApIGFuZCA7XG4gICAgICAgIGlmIChjaCA9PT0gMHgyOCB8fCBjaCA9PT0gMHgyOSB8fCBjaCA9PT0gMHgzQikge1xuICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdHJpbmcgbGl0ZXJhbCBzdGFydHMgd2l0aCBzaW5nbGUgcXVvdGUgKFUrMDAyNykgb3IgZG91YmxlIHF1b3RlIChVKzAwMjIpLlxuICAgICAgICBpZiAoY2ggPT09IDB4MjcgfHwgY2ggPT09IDB4MjIpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FuU3RyaW5nTGl0ZXJhbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG90ICguKSBVKzAwMkUgY2FuIGFsc28gc3RhcnQgYSBmbG9hdGluZy1wb2ludCBudW1iZXIsIGhlbmNlIHRoZSBuZWVkXG4gICAgICAgIC8vIHRvIGNoZWNrIHRoZSBuZXh0IGNoYXJhY3Rlci5cbiAgICAgICAgaWYgKGNoID09PSAweDJFKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNsYXNoICgvKSBVKzAwMkYgY2FuIGFsc28gc3RhcnQgYSByZWdleC5cbiAgICAgICAgaWYgKGV4dHJhLnRva2VuaXplICYmIGNoID09PSAweDJGKSB7XG4gICAgICAgICAgICByZXR1cm4gYWR2YW5jZVNsYXNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZW1wbGF0ZSBsaXRlcmFscyBzdGFydCB3aXRoIGAgKFUrMDA2MCkgZm9yIHRlbXBsYXRlIGhlYWRcbiAgICAgICAgLy8gb3IgfSAoVSswMDdEKSBmb3IgdGVtcGxhdGUgbWlkZGxlIG9yIHRlbXBsYXRlIHRhaWwuXG4gICAgICAgIGlmIChjaCA9PT0gMHg2MCB8fCAoY2ggPT09IDB4N0QgJiYgc3RhdGUuY3VybHlTdGFja1tzdGF0ZS5jdXJseVN0YWNrLmxlbmd0aCAtIDFdID09PSAnJHsnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjYW5UZW1wbGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sbGVjdFRva2VuKCkge1xuICAgICAgICB2YXIgbG9jLCB0b2tlbiwgdmFsdWUsIGVudHJ5O1xuXG4gICAgICAgIGxvYyA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdG9rZW4gPSBhZHZhbmNlKCk7XG4gICAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpO1xuICAgICAgICAgICAgZW50cnkgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW5OYW1lW3Rva2VuLnR5cGVdLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICByYW5nZTogW3Rva2VuLnN0YXJ0LCB0b2tlbi5lbmRdLFxuICAgICAgICAgICAgICAgIGxvYzogbG9jXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRva2VuLnJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgZW50cnkucmVnZXggPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IHRva2VuLnJlZ2V4LnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzOiB0b2tlbi5yZWdleC5mbGFnc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHRyYS50b2tlbnMucHVzaChlbnRyeSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIHNjYW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICBsYXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgbGFzdExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICBsYXN0TGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuXG4gICAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgICAgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICBzdGFydExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICBzdGFydExpbmVTdGFydCA9IGxpbmVTdGFydDtcblxuICAgICAgICBsb29rYWhlYWQgPSAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpID8gY29sbGVjdFRva2VuKCkgOiBhZHZhbmNlKCk7XG4gICAgICAgIHNjYW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWVrKCkge1xuICAgICAgICBzY2FubmluZyA9IHRydWU7XG5cbiAgICAgICAgc2tpcENvbW1lbnQoKTtcblxuICAgICAgICBsYXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgbGFzdExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICBsYXN0TGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuXG4gICAgICAgIHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgc3RhcnRMaW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG5cbiAgICAgICAgbG9va2FoZWFkID0gKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSA/IGNvbGxlY3RUb2tlbigpIDogYWR2YW5jZSgpO1xuICAgICAgICBzY2FubmluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLmxpbmUgPSBzdGFydExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMuY29sdW1uID0gc3RhcnRJbmRleCAtIHN0YXJ0TGluZVN0YXJ0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gbmV3IFBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuZW5kID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXcmFwcGluZ1NvdXJjZUxvY2F0aW9uKHN0YXJ0VG9rZW4pIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHtcbiAgICAgICAgICAgIGxpbmU6IHN0YXJ0VG9rZW4ubGluZU51bWJlcixcbiAgICAgICAgICAgIGNvbHVtbjogc3RhcnRUb2tlbi5zdGFydCAtIHN0YXJ0VG9rZW4ubGluZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW5kID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBOb2RlKCkge1xuICAgICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSBbc3RhcnRJbmRleCwgMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgICAgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdyYXBwaW5nTm9kZShzdGFydFRva2VuKSB7XG4gICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5yYW5nZSA9IFtzdGFydFRva2VuLnN0YXJ0LCAwXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICB0aGlzLmxvYyA9IG5ldyBXcmFwcGluZ1NvdXJjZUxvY2F0aW9uKHN0YXJ0VG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgV3JhcHBpbmdOb2RlLnByb3RvdHlwZSA9IE5vZGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIHByb2Nlc3NDb21tZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGFzdENoaWxkLFxuICAgICAgICAgICAgICAgIGxlYWRpbmdDb21tZW50cyxcbiAgICAgICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0ID0gZXh0cmEuYm90dG9tUmlnaHRTdGFjayxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQsXG4gICAgICAgICAgICAgICAgbGFzdCA9IGJvdHRvbVJpZ2h0W2JvdHRvbVJpZ2h0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBTeW50YXguUHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXh0cmEudHJhaWxpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGV4dHJhLnRyYWlsaW5nQ29tbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGV4dHJhLnRyYWlsaW5nQ29tbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LnJhbmdlWzBdID49IHRoaXMucmFuZ2VbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMudW5zaGlmdChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLnRyYWlsaW5nQ29tbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4dHJhLnRyYWlsaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC50cmFpbGluZ0NvbW1lbnRzICYmIGxhc3QudHJhaWxpbmdDb21tZW50c1swXS5yYW5nZVswXSA+PSB0aGlzLnJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMgPSBsYXN0LnRyYWlsaW5nQ29tbWVudHM7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsYXN0LnRyYWlsaW5nQ29tbWVudHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFYXRpbmcgdGhlIHN0YWNrLlxuICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobGFzdCAmJiBsYXN0LnJhbmdlWzBdID49IHRoaXMucmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdENoaWxkID0gbGFzdDtcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGJvdHRvbVJpZ2h0LnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzICYmIGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHNbbGFzdENoaWxkLmxlYWRpbmdDb21tZW50cy5sZW5ndGggLSAxXS5yYW5nZVsxXSA8PSB0aGlzLnJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVhZGluZ0NvbW1lbnRzID0gbGFzdENoaWxkLmxlYWRpbmdDb21tZW50cztcbiAgICAgICAgICAgICAgICAgICAgbGFzdENoaWxkLmxlYWRpbmdDb21tZW50cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4dHJhLmxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gZXh0cmEubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBleHRyYS5sZWFkaW5nQ29tbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LnJhbmdlWzFdIDw9IHRoaXMucmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlYWRpbmdDb21tZW50cy51bnNoaWZ0KGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEubGVhZGluZ0NvbW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBpZiAobGVhZGluZ0NvbW1lbnRzICYmIGxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWFkaW5nQ29tbWVudHMgPSBsZWFkaW5nQ29tbWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhaWxpbmdDb21tZW50cyAmJiB0cmFpbGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWlsaW5nQ29tbWVudHMgPSB0cmFpbGluZ0NvbW1lbnRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBib3R0b21SaWdodC5wdXNoKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZVsxXSA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYy5lbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGxhc3RMaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGxhc3RJbmRleCAtIGxhc3RMaW5lU3RhcnRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChleHRyYS5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2Muc291cmNlID0gZXh0cmEuc291cmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4dHJhLmF0dGFjaENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NDb21tZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQXJyYXlFeHByZXNzaW9uOiBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5BcnJheUV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQXJyYXlQYXR0ZXJuOiBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5BcnJheVBhdHRlcm47XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uIChwYXJhbXMsIGRlZmF1bHRzLCBib2R5LCBleHByZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmlkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbiAob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEFzc2lnbm1lbnRQYXR0ZXJuOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQmluYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gKG9wZXJhdG9yID09PSAnfHwnIHx8IG9wZXJhdG9yID09PSAnJiYnKSA/IFN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbiA6IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hCbG9ja1N0YXRlbWVudDogZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5CbG9ja1N0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQnJlYWtTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkJyZWFrU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaENhbGxFeHByZXNzaW9uOiBmdW5jdGlvbiAoY2FsbGVlLCBhcmdzKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQ2FsbEV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmNhbGxlZSA9IGNhbGxlZTtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnRzID0gYXJncztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hDYXRjaENsYXVzZTogZnVuY3Rpb24gKHBhcmFtLCBib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQ2F0Y2hDbGF1c2U7XG4gICAgICAgICAgICB0aGlzLnBhcmFtID0gcGFyYW07XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaENsYXNzQm9keTogZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5DbGFzc0JvZHk7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaENsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uIChpZCwgc3VwZXJDbGFzcywgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNsYXNzRGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgICAgICB0aGlzLnN1cGVyQ2xhc3MgPSBzdXBlckNsYXNzO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hDbGFzc0V4cHJlc3Npb246IGZ1bmN0aW9uIChpZCwgc3VwZXJDbGFzcywgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNsYXNzRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgICAgIHRoaXMuc3VwZXJDbGFzcyA9IHN1cGVyQ2xhc3M7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaENvbmRpdGlvbmFsRXhwcmVzc2lvbjogZnVuY3Rpb24gKHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNvbmRpdGlvbmFsRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgICAgICB0aGlzLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xuICAgICAgICAgICAgdGhpcy5hbHRlcm5hdGUgPSBhbHRlcm5hdGU7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQ29udGludWVTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNvbnRpbnVlU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaERlYnVnZ2VyU3RhdGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRGVidWdnZXJTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRG9XaGlsZVN0YXRlbWVudDogZnVuY3Rpb24gKGJvZHksIHRlc3QpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Eb1doaWxlU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRW1wdHlTdGF0ZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5FbXB0eVN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hFeHByZXNzaW9uU3RhdGVtZW50OiBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEZvclN0YXRlbWVudDogZnVuY3Rpb24gKGluaXQsIHRlc3QsIHVwZGF0ZSwgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkZvclN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XG4gICAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgICAgdGhpcy51cGRhdGUgPSB1cGRhdGU7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEZvckluU3RhdGVtZW50OiBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Gb3JJblN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5lYWNoID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRnVuY3Rpb25EZWNsYXJhdGlvbjogZnVuY3Rpb24gKGlkLCBwYXJhbXMsIGRlZmF1bHRzLCBib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hGdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uIChpZCwgcGFyYW1zLCBkZWZhdWx0cywgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hJZGVudGlmaWVyOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LklkZW50aWZpZXI7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaElmU3RhdGVtZW50OiBmdW5jdGlvbiAodGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguSWZTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcbiAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaExhYmVsZWRTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChsYWJlbCwgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkxhYmVsZWRTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaExpdGVyYWw6IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkxpdGVyYWw7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgICB0aGlzLnJhdyA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi5yZWdleCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVnZXggPSB0b2tlbi5yZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hNZW1iZXJFeHByZXNzaW9uOiBmdW5jdGlvbiAoYWNjZXNzb3IsIG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlZCA9IGFjY2Vzc29yID09PSAnWyc7XG4gICAgICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hOZXdFeHByZXNzaW9uOiBmdW5jdGlvbiAoY2FsbGVlLCBhcmdzKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguTmV3RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuY2FsbGVlID0gY2FsbGVlO1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudHMgPSBhcmdzO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaE9iamVjdEV4cHJlc3Npb246IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguT2JqZWN0RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoT2JqZWN0UGF0dGVybjogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5PYmplY3RQYXR0ZXJuO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hQb3N0Zml4RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBhcmd1bWVudCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlVwZGF0ZUV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnByZWZpeCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFByb2dyYW06IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguUHJvZ3JhbTtcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICBpZiAoc291cmNlVHlwZSA9PT0gJ21vZHVsZScpIHtcbiAgICAgICAgICAgICAgICAvLyB2ZXJ5IHJlc3RyaWN0aXZlIGZvciBub3dcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZVR5cGUgPSBzb3VyY2VUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFByb3BlcnR5OiBmdW5jdGlvbiAoa2luZCwga2V5LCBjb21wdXRlZCwgdmFsdWUsIG1ldGhvZCwgc2hvcnRoYW5kKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguUHJvcGVydHk7XG4gICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgICAgIHRoaXMuc2hvcnRoYW5kID0gc2hvcnRoYW5kO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFJlc3RFbGVtZW50OiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5SZXN0RWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hSZXR1cm5TdGF0ZW1lbnQ6IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlJldHVyblN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hTZXF1ZW5jZUV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByZXNzaW9ucykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlNlcXVlbmNlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hTcHJlYWRFbGVtZW50OiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5TcHJlYWRFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFN3aXRjaENhc2U6IGZ1bmN0aW9uICh0ZXN0LCBjb25zZXF1ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguU3dpdGNoQ2FzZTtcbiAgICAgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgICAgICB0aGlzLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFN1cGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguU3VwZXI7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoU3dpdGNoU3RhdGVtZW50OiBmdW5jdGlvbiAoZGlzY3JpbWluYW50LCBjYXNlcykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlN3aXRjaFN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuZGlzY3JpbWluYW50ID0gZGlzY3JpbWluYW50O1xuICAgICAgICAgICAgdGhpcy5jYXNlcyA9IGNhc2VzO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjogZnVuY3Rpb24gKHRhZywgcXVhc2kpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgICAgIHRoaXMucXVhc2kgPSBxdWFzaTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hUZW1wbGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uICh2YWx1ZSwgdGFpbCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlRlbXBsYXRlRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IHRhaWw7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoVGVtcGxhdGVMaXRlcmFsOiBmdW5jdGlvbiAocXVhc2lzLCBleHByZXNzaW9ucykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlRlbXBsYXRlTGl0ZXJhbDtcbiAgICAgICAgICAgIHRoaXMucXVhc2lzID0gcXVhc2lzO1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFRoaXNFeHByZXNzaW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVGhpc0V4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoVGhyb3dTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlRocm93U3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFRyeVN0YXRlbWVudDogZnVuY3Rpb24gKGJsb2NrLCBoYW5kbGVyLCBmaW5hbGl6ZXIpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5UcnlTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2s7XG4gICAgICAgICAgICB0aGlzLmd1YXJkZWRIYW5kbGVycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVycyA9IGhhbmRsZXIgPyBbIGhhbmRsZXIgXSA6IFtdO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgICAgIHRoaXMuZmluYWxpemVyID0gZmluYWxpemVyO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFVuYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBhcmd1bWVudCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gKG9wZXJhdG9yID09PSAnKysnIHx8IG9wZXJhdG9yID09PSAnLS0nKSA/IFN5bnRheC5VcGRhdGVFeHByZXNzaW9uIDogU3ludGF4LlVuYXJ5RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICAgICAgICAgIHRoaXMucHJlZml4ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hWYXJpYWJsZURlY2xhcmF0aW9uOiBmdW5jdGlvbiAoZGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb25zO1xuICAgICAgICAgICAgdGhpcy5raW5kID0gJ3Zhcic7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoTGV4aWNhbERlY2xhcmF0aW9uOiBmdW5jdGlvbiAoZGVjbGFyYXRpb25zLCBraW5kKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb25zO1xuICAgICAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hWYXJpYWJsZURlY2xhcmF0b3I6IGZ1bmN0aW9uIChpZCwgaW5pdCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvcjtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoV2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uICh0ZXN0LCBib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguV2hpbGVTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hXaXRoU3RhdGVtZW50OiBmdW5jdGlvbiAob2JqZWN0LCBib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguV2l0aFN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hFeHBvcnRTcGVjaWZpZXI6IGZ1bmN0aW9uIChsb2NhbCwgZXhwb3J0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5FeHBvcnRTcGVjaWZpZXI7XG4gICAgICAgICAgICB0aGlzLmV4cG9ydGVkID0gZXhwb3J0ZWQgfHwgbG9jYWw7XG4gICAgICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogZnVuY3Rpb24gKGxvY2FsKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguSW1wb3J0RGVmYXVsdFNwZWNpZmllcjtcbiAgICAgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IGZ1bmN0aW9uIChsb2NhbCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbiAgICAgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hFeHBvcnROYW1lZERlY2xhcmF0aW9uOiBmdW5jdGlvbiAoZGVjbGFyYXRpb24sIHNwZWNpZmllcnMsIHNyYykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkV4cG9ydE5hbWVkRGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLnNwZWNpZmllcnMgPSBzcGVjaWZpZXJzO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBzcmM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uOiBmdW5jdGlvbiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRXhwb3J0QWxsRGVjbGFyYXRpb246IGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5FeHBvcnRBbGxEZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gc3JjO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEltcG9ydFNwZWNpZmllcjogZnVuY3Rpb24gKGxvY2FsLCBpbXBvcnRlZCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkltcG9ydFNwZWNpZmllcjtcbiAgICAgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbCB8fCBpbXBvcnRlZDtcbiAgICAgICAgICAgIHRoaXMuaW1wb3J0ZWQgPSBpbXBvcnRlZDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hJbXBvcnREZWNsYXJhdGlvbjogZnVuY3Rpb24gKHNwZWNpZmllcnMsIHNyYykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkltcG9ydERlY2xhcmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5zcGVjaWZpZXJzID0gc3BlY2lmaWVycztcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gc3JjO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgZnVuY3Rpb24gcmVjb3JkRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdmFyIGUsIGV4aXN0aW5nO1xuXG4gICAgICAgIGZvciAoZSA9IDA7IGUgPCBleHRyYS5lcnJvcnMubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgICAgIGV4aXN0aW5nID0gZXh0cmEuZXJyb3JzW2VdO1xuICAgICAgICAgICAgLy8gUHJldmVudCBkdXBsaWNhdGVkIGVycm9yLlxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmIChleGlzdGluZy5pbmRleCA9PT0gZXJyb3IuaW5kZXggJiYgZXhpc3RpbmcubWVzc2FnZSA9PT0gZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dHJhLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFcnJvcihsaW5lLCBwb3MsIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignTGluZSAnICsgbGluZSArICc6ICcgKyBkZXNjcmlwdGlvbik7XG4gICAgICAgIGVycm9yLmluZGV4ID0gcG9zO1xuICAgICAgICBlcnJvci5saW5lTnVtYmVyID0gbGluZTtcbiAgICAgICAgZXJyb3IuY29sdW1uID0gcG9zIC0gKHNjYW5uaW5nID8gbGluZVN0YXJ0IDogbGFzdExpbmVTdGFydCkgKyAxO1xuICAgICAgICBlcnJvci5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uXG5cbiAgICBmdW5jdGlvbiB0aHJvd0Vycm9yKG1lc3NhZ2VGb3JtYXQpIHtcbiAgICAgICAgdmFyIGFyZ3MsIG1zZztcblxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgbXNnID0gbWVzc2FnZUZvcm1hdC5yZXBsYWNlKC8lKFxcZCkvZyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICh3aG9sZSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGlkeCA8IGFyZ3MubGVuZ3RoLCAnTWVzc2FnZSByZWZlcmVuY2UgbXVzdCBiZSBpbiByYW5nZScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW2lkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IobGFzdExpbmVOdW1iZXIsIGxhc3RJbmRleCwgbXNnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2xlcmF0ZUVycm9yKG1lc3NhZ2VGb3JtYXQpIHtcbiAgICAgICAgdmFyIGFyZ3MsIG1zZywgZXJyb3I7XG5cbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIG1zZyA9IG1lc3NhZ2VGb3JtYXQucmVwbGFjZSgvJShcXGQpL2csXG4gICAgICAgICAgICBmdW5jdGlvbiAod2hvbGUsIGlkeCkge1xuICAgICAgICAgICAgICAgIGFzc2VydChpZHggPCBhcmdzLmxlbmd0aCwgJ01lc3NhZ2UgcmVmZXJlbmNlIG11c3QgYmUgaW4gcmFuZ2UnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1tpZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGVycm9yID0gY3JlYXRlRXJyb3IobGluZU51bWJlciwgbGFzdEluZGV4LCBtc2cpO1xuICAgICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgICByZWNvcmRFcnJvcihlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIG9mIHRoZSB0b2tlbi5cblxuICAgIGZ1bmN0aW9uIHVuZXhwZWN0ZWRUb2tlbkVycm9yKHRva2VuLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciB2YWx1ZSwgbXNnID0gbWVzc2FnZSB8fCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW47XG5cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBtc2cgPSAodG9rZW4udHlwZSA9PT0gVG9rZW4uRU9GKSA/IE1lc3NhZ2VzLlVuZXhwZWN0ZWRFT1MgOlxuICAgICAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikgPyBNZXNzYWdlcy5VbmV4cGVjdGVkSWRlbnRpZmllciA6XG4gICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSBUb2tlbi5OdW1lcmljTGl0ZXJhbCkgPyBNZXNzYWdlcy5VbmV4cGVjdGVkTnVtYmVyIDpcbiAgICAgICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwpID8gTWVzc2FnZXMuVW5leHBlY3RlZFN0cmluZyA6XG4gICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSBUb2tlbi5UZW1wbGF0ZSkgPyBNZXNzYWdlcy5VbmV4cGVjdGVkVGVtcGxhdGUgOlxuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW47XG5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdXR1cmVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBNZXNzYWdlcy5VbmV4cGVjdGVkUmVzZXJ2ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSAodG9rZW4udHlwZSA9PT0gVG9rZW4uVGVtcGxhdGUpID8gdG9rZW4udmFsdWUucmF3IDogdG9rZW4udmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICdJTExFR0FMJztcbiAgICAgICAgfVxuXG4gICAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKCclMCcsIHZhbHVlKTtcblxuICAgICAgICByZXR1cm4gKHRva2VuICYmIHR5cGVvZiB0b2tlbi5saW5lTnVtYmVyID09PSAnbnVtYmVyJykgP1xuICAgICAgICAgICAgY3JlYXRlRXJyb3IodG9rZW4ubGluZU51bWJlciwgdG9rZW4uc3RhcnQsIG1zZykgOlxuICAgICAgICAgICAgY3JlYXRlRXJyb3Ioc2Nhbm5pbmcgPyBsaW5lTnVtYmVyIDogbGFzdExpbmVOdW1iZXIsIHNjYW5uaW5nID8gaW5kZXggOiBsYXN0SW5kZXgsIG1zZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgdW5leHBlY3RlZFRva2VuRXJyb3IodG9rZW4sIG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHVuZXhwZWN0ZWRUb2tlbkVycm9yKHRva2VuLCBtZXNzYWdlKTtcbiAgICAgICAgaWYgKGV4dHJhLmVycm9ycykge1xuICAgICAgICAgICAgcmVjb3JkRXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuICAgIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuXG4gICAgZnVuY3Rpb24gZXhwZWN0KHZhbHVlKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxleCgpO1xuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvciB8fCB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGV4cGVjdENvbW1hU2VwYXJhdG9yXG4gICAgICogQGRlc2NyaXB0aW9uIFF1aWV0bHkgZXhwZWN0IGEgY29tbWEgd2hlbiBpbiB0b2xlcmFudCBtb2RlLCBvdGhlcndpc2UgZGVsZWdhdGVzXG4gICAgICogdG8gPGNvZGU+ZXhwZWN0KHZhbHVlKTwvY29kZT5cbiAgICAgKiBAc2luY2UgMi4wXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXhwZWN0Q29tbWFTZXBhcmF0b3IoKSB7XG4gICAgICAgIHZhciB0b2tlbjtcblxuICAgICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnZhbHVlID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvciAmJiB0b2tlbi52YWx1ZSA9PT0gJzsnKSB7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQga2V5d29yZC5cbiAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblxuICAgIGZ1bmN0aW9uIGV4cGVjdEtleXdvcmQoa2V5d29yZCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLktleXdvcmQgfHwgdG9rZW4udmFsdWUgIT09IGtleXdvcmQpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuXG4gICAgZnVuY3Rpb24gbWF0Y2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleXdvcmRcblxuICAgIGZ1bmN0aW9uIG1hdGNoS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uS2V5d29yZCAmJiBsb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGNvbnRleHR1YWwga2V5d29yZFxuICAgIC8vICh3aGVyZSBhbiBpZGVudGlmaWVyIGlzIHNvbWV0aW1lcyBhIGtleXdvcmQgZGVwZW5kaW5nIG9uIHRoZSBjb250ZXh0KVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hDb250ZXh0dWFsS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllciAmJiBsb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gaXMgYW4gYXNzaWdubWVudCBvcGVyYXRvclxuXG4gICAgZnVuY3Rpb24gbWF0Y2hBc3NpZ24oKSB7XG4gICAgICAgIHZhciBvcDtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBvcCA9IGxvb2thaGVhZC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG9wID09PSAnPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnKj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJy89JyB8fFxuICAgICAgICAgICAgb3AgPT09ICclPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnKz0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJy09JyB8fFxuICAgICAgICAgICAgb3AgPT09ICc8PD0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJz4+PScgfHxcbiAgICAgICAgICAgIG9wID09PSAnPj4+PScgfHxcbiAgICAgICAgICAgIG9wID09PSAnJj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJ149JyB8fFxuICAgICAgICAgICAgb3AgPT09ICd8PSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uc3VtZVNlbWljb2xvbigpIHtcbiAgICAgICAgLy8gQ2F0Y2ggdGhlIHZlcnkgY29tbW9uIGNhc2UgZmlyc3Q6IGltbWVkaWF0ZWx5IGEgc2VtaWNvbG9uIChVKzAwM0IpLlxuICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoc3RhcnRJbmRleCkgPT09IDB4M0IgfHwgbWF0Y2goJzsnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzTGluZVRlcm1pbmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZJWE1FKGlrYXJpZW5hdG9yKTogdGhpcyBpcyBzZWVtaW5nbHkgYW4gaXNzdWUgaW4gdGhlIHByZXZpb3VzIGxvY2F0aW9uIGluZm8gY29udmVudGlvbi5cbiAgICAgICAgbGFzdEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICAgbGFzdExpbmVOdW1iZXIgPSBzdGFydExpbmVOdW1iZXI7XG4gICAgICAgIGxhc3RMaW5lU3RhcnQgPSBzdGFydExpbmVTdGFydDtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRiAmJiAhbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvdmVyIGdyYW1tYXIgc3VwcG9ydC5cbiAgICAvL1xuICAgIC8vIFdoZW4gYW4gYXNzaWdubWVudCBleHByZXNzaW9uIHBvc2l0aW9uIHN0YXJ0cyB3aXRoIGFuIGxlZnQgcGFyZW50aGVzaXMsIHRoZSBkZXRlcm1pbmF0aW9uIG9mIHRoZSB0eXBlXG4gICAgLy8gb2YgdGhlIHN5bnRheCBpcyB0byBiZSBkZWZlcnJlZCBhcmJpdHJhcmlseSBsb25nIHVudGlsIHRoZSBlbmQgb2YgdGhlIHBhcmVudGhlc2VzIHBhaXIgKHBsdXMgYSBsb29rYWhlYWQpXG4gICAgLy8gb3IgdGhlIGZpcnN0IGNvbW1hLiBUaGlzIHNpdHVhdGlvbiBhbHNvIGRlZmVycyB0aGUgZGV0ZXJtaW5hdGlvbiBvZiBhbGwgdGhlIGV4cHJlc3Npb25zIG5lc3RlZCBpbiB0aGUgcGFpci5cbiAgICAvL1xuICAgIC8vIFRoZXJlIGFyZSB0aHJlZSBwcm9kdWN0aW9ucyB0aGF0IGNhbiBiZSBwYXJzZWQgaW4gYSBwYXJlbnRoZXNlcyBwYWlyIHRoYXQgbmVlZHMgdG8gYmUgZGV0ZXJtaW5lZFxuICAgIC8vIGFmdGVyIHRoZSBvdXRlcm1vc3QgcGFpciBpcyBjbG9zZWQuIFRoZXkgYXJlOlxuICAgIC8vXG4gICAgLy8gICAxLiBBc3NpZ25tZW50RXhwcmVzc2lvblxuICAgIC8vICAgMi4gQmluZGluZ0VsZW1lbnRzXG4gICAgLy8gICAzLiBBc3NpZ25tZW50VGFyZ2V0c1xuICAgIC8vXG4gICAgLy8gSW4gb3JkZXIgdG8gYXZvaWQgZXhwb25lbnRpYWwgYmFja3RyYWNraW5nLCB3ZSB1c2UgdHdvIGZsYWdzIHRvIGRlbm90ZSBpZiB0aGUgcHJvZHVjdGlvbiBjYW4gYmVcbiAgICAvLyBiaW5kaW5nIGVsZW1lbnQgb3IgYXNzaWdubWVudCB0YXJnZXQuXG4gICAgLy9cbiAgICAvLyBUaGUgdGhyZWUgcHJvZHVjdGlvbnMgaGF2ZSB0aGUgcmVsYXRpb25zaGlwOlxuICAgIC8vXG4gICAgLy8gICBCaW5kaW5nRWxlbWVudHMg4oqGIEFzc2lnbm1lbnRUYXJnZXRzIOKKhiBBc3NpZ25tZW50RXhwcmVzc2lvblxuICAgIC8vXG4gICAgLy8gd2l0aCBhIHNpbmdsZSBleGNlcHRpb24gdGhhdCBDb3ZlckluaXRpYWxpemVkTmFtZSB3aGVuIHVzZWQgZGlyZWN0bHkgaW4gYW4gRXhwcmVzc2lvbiwgZ2VuZXJhdGVzXG4gICAgLy8gYW4gZWFybHkgZXJyb3IuIFRoZXJlZm9yZSwgd2UgbmVlZCB0aGUgdGhpcmQgc3RhdGUsIGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciwgdG8gdHJhY2sgdGhlXG4gICAgLy8gZmlyc3QgdXNhZ2Ugb2YgQ292ZXJJbml0aWFsaXplZE5hbWUgYW5kIHJlcG9ydCBpdCB3aGVuIHdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgcGFyZW50aGVzZXMgcGFpci5cbiAgICAvL1xuICAgIC8vIGlzb2xhdGVDb3ZlckdyYW1tYXIgZnVuY3Rpb24gcnVucyB0aGUgZ2l2ZW4gcGFyc2VyIGZ1bmN0aW9uIHdpdGggYSBuZXcgY292ZXIgZ3JhbW1hciBjb250ZXh0LCBhbmQgaXQgZG9lcyBub3RcbiAgICAvLyBlZmZlY3QgdGhlIGN1cnJlbnQgZmxhZ3MuIFRoaXMgbWVhbnMgdGhlIHByb2R1Y3Rpb24gdGhlIHBhcnNlciBwYXJzZXMgaXMgb25seSB1c2VkIGFzIGFuIGV4cHJlc3Npb24uIFRoZXJlZm9yZVxuICAgIC8vIHRoZSBDb3ZlckluaXRpYWxpemVkTmFtZSBjaGVjayBpcyBjb25kdWN0ZWQuXG4gICAgLy9cbiAgICAvLyBpbmhlcml0Q292ZXJHcmFtbWFyIGZ1bmN0aW9uIHJ1bnMgdGhlIGdpdmVuIHBhcnNlIGZ1bmN0aW9uIHdpdGggYSBuZXcgY292ZXIgZ3JhbW1hciBjb250ZXh0LCBhbmQgaXQgcHJvcGFnYXRlc1xuICAgIC8vIHRoZSBmbGFncyBvdXRzaWRlIG9mIHRoZSBwYXJzZXIuIFRoaXMgbWVhbnMgdGhlIHByb2R1Y3Rpb24gdGhlIHBhcnNlciBwYXJzZXMgaXMgdXNlZCBhcyBhIHBhcnQgb2YgYSBwb3RlbnRpYWxcbiAgICAvLyBwYXR0ZXJuLiBUaGUgQ292ZXJJbml0aWFsaXplZE5hbWUgY2hlY2sgaXMgZGVmZXJyZWQuXG4gICAgZnVuY3Rpb24gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZXIpIHtcbiAgICAgICAgdmFyIG9sZElzQmluZGluZ0VsZW1lbnQgPSBpc0JpbmRpbmdFbGVtZW50LFxuICAgICAgICAgICAgb2xkSXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNBc3NpZ25tZW50VGFyZ2V0LFxuICAgICAgICAgICAgb2xkRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yLFxuICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICBpc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcbiAgICAgICAgcmVzdWx0ID0gcGFyc2VyKCk7XG4gICAgICAgIGlmIChmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IG9sZElzQmluZGluZ0VsZW1lbnQ7XG4gICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IG9sZElzQXNzaWdubWVudFRhcmdldDtcbiAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gb2xkRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VyKSB7XG4gICAgICAgIHZhciBvbGRJc0JpbmRpbmdFbGVtZW50ID0gaXNCaW5kaW5nRWxlbWVudCxcbiAgICAgICAgICAgIG9sZElzQXNzaWdubWVudFRhcmdldCA9IGlzQXNzaWdubWVudFRhcmdldCxcbiAgICAgICAgICAgIG9sZEZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcixcbiAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XG4gICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XG4gICAgICAgIGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XG4gICAgICAgIHJlc3VsdCA9IHBhcnNlcigpO1xuICAgICAgICBpc0JpbmRpbmdFbGVtZW50ID0gaXNCaW5kaW5nRWxlbWVudCAmJiBvbGRJc0JpbmRpbmdFbGVtZW50O1xuICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0Fzc2lnbm1lbnRUYXJnZXQgJiYgb2xkSXNBc3NpZ25tZW50VGFyZ2V0O1xuICAgICAgICBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBvbGRGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgfHwgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQXJyYXlQYXR0ZXJuKCkge1xuICAgICAgICB2YXIgbm9kZSA9IG5ldyBOb2RlKCksIGVsZW1lbnRzID0gW10sIHJlc3QsIHJlc3ROb2RlO1xuICAgICAgICBleHBlY3QoJ1snKTtcblxuICAgICAgICB3aGlsZSAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChudWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKCcuLi4nKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN0Tm9kZSA9IG5ldyBOb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgICAgICByZXN0ID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChyZXN0Tm9kZS5maW5pc2hSZXN0RWxlbWVudChyZXN0KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gocGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbWF0Y2goJ10nKSkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnXScpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEFycmF5UGF0dGVybihlbGVtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQcm9wZXJ0eVBhdHRlcm4oKSB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IE5vZGUoKSwga2V5LCBjb21wdXRlZCA9IG1hdGNoKCdbJyksIGluaXQ7XG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAga2V5ID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnPScpKSB7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgaW5pdCA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgJ2luaXQnLCBrZXksIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBuZXcgV3JhcHBpbmdOb2RlKGtleSkuZmluaXNoQXNzaWdubWVudFBhdHRlcm4oa2V5LCBpbml0KSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW1hdGNoKCc6JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnaW5pdCcsIGtleSwgZmFsc2UsIGtleSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdCgnOicpO1xuICAgICAgICBpbml0ID0gcGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoJ2luaXQnLCBrZXksIGNvbXB1dGVkLCBpbml0LCBmYWxzZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0UGF0dGVybigpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgTm9kZSgpLCBwcm9wZXJ0aWVzID0gW107XG5cbiAgICAgICAgZXhwZWN0KCd7Jyk7XG5cbiAgICAgICAgd2hpbGUgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2gocGFyc2VQcm9wZXJ0eVBhdHRlcm4oKSk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxleCgpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaE9iamVjdFBhdHRlcm4ocHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQYXR0ZXJuKCkge1xuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUFycmF5UGF0dGVybigpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCd7JykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdFBhdHRlcm4oKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUGF0dGVybldpdGhEZWZhdWx0KCkge1xuICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IGxvb2thaGVhZCwgcGF0dGVybiwgcmlnaHQ7XG4gICAgICAgIHBhdHRlcm4gPSBwYXJzZVBhdHRlcm4oKTtcbiAgICAgICAgaWYgKG1hdGNoKCc9JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgcmlnaHQgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgcGF0dGVybiA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoQXNzaWdubWVudFBhdHRlcm4ocGF0dGVybiwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgIH1cblxuICAgIC8vIDExLjEuNCBBcnJheSBJbml0aWFsaXNlclxuXG4gICAgZnVuY3Rpb24gcGFyc2VBcnJheUluaXRpYWxpc2VyKCkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXSwgbm9kZSA9IG5ldyBOb2RlKCksIHJlc3RTcHJlYWQ7XG5cbiAgICAgICAgZXhwZWN0KCdbJyk7XG5cbiAgICAgICAgd2hpbGUgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCcuLi4nKSkge1xuICAgICAgICAgICAgICAgIHJlc3RTcHJlYWQgPSBuZXcgTm9kZSgpO1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIHJlc3RTcHJlYWQuZmluaXNoU3ByZWFkRWxlbWVudChpbmhlcml0Q292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcblxuICAgICAgICAgICAgICAgIGlmICghbWF0Y2goJ10nKSkge1xuICAgICAgICAgICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHJlc3RTcHJlYWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxleCgpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEFycmF5RXhwcmVzc2lvbihlbGVtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gMTEuMS41IE9iamVjdCBJbml0aWFsaXNlclxuXG4gICAgZnVuY3Rpb24gcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKG5vZGUsIHBhcmFtSW5mbykge1xuICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QsIGJvZHk7XG5cbiAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuXG4gICAgICAgIHByZXZpb3VzU3RyaWN0ID0gc3RyaWN0O1xuICAgICAgICBib2R5ID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMpO1xuXG4gICAgICAgIGlmIChzdHJpY3QgJiYgcGFyYW1JbmZvLmZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4ocGFyYW1JbmZvLmZpcnN0UmVzdHJpY3RlZCwgcGFyYW1JbmZvLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpY3QgJiYgcGFyYW1JbmZvLnN0cmljdGVkKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihwYXJhbUluZm8uc3RyaWN0ZWQsIHBhcmFtSW5mby5tZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hGdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgcGFyYW1JbmZvLnBhcmFtcywgcGFyYW1JbmZvLmRlZmF1bHRzLCBib2R5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbXMsIG1ldGhvZCwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgcGFyYW1zID0gcGFyc2VQYXJhbXMoKTtcbiAgICAgICAgbWV0aG9kID0gcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKG5vZGUsIHBhcmFtcyk7XG5cbiAgICAgICAgcmV0dXJuIG1ldGhvZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCkge1xuICAgICAgICB2YXIgdG9rZW4sIG5vZGUgPSBuZXcgTm9kZSgpLCBleHByO1xuXG4gICAgICAgIHRva2VuID0gbGV4KCk7XG5cbiAgICAgICAgLy8gTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBmcm9tIHBhcnNlT2JqZWN0UHJvcGVydHkoKSwgd2hlcmVcbiAgICAgICAgLy8gRU9GIGFuZCBQdW5jdHVhdG9yIHRva2VucyBhcmUgYWxyZWFkeSBmaWx0ZXJlZCBvdXQuXG5cbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgVG9rZW4uU3RyaW5nTGl0ZXJhbDpcbiAgICAgICAgY2FzZSBUb2tlbi5OdW1lcmljTGl0ZXJhbDpcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgdG9rZW4ub2N0YWwpIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaExpdGVyYWwodG9rZW4pO1xuICAgICAgICBjYXNlIFRva2VuLklkZW50aWZpZXI6XG4gICAgICAgIGNhc2UgVG9rZW4uQm9vbGVhbkxpdGVyYWw6XG4gICAgICAgIGNhc2UgVG9rZW4uTnVsbExpdGVyYWw6XG4gICAgICAgIGNhc2UgVG9rZW4uS2V5d29yZDpcbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaElkZW50aWZpZXIodG9rZW4udmFsdWUpO1xuICAgICAgICBjYXNlIFRva2VuLlB1bmN0dWF0b3I6XG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdbJykge1xuICAgICAgICAgICAgICAgIGV4cHIgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnXScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb2thaGVhZFByb3BlcnR5TmFtZSgpIHtcbiAgICAgICAgc3dpdGNoIChsb29rYWhlYWQudHlwZSkge1xuICAgICAgICBjYXNlIFRva2VuLklkZW50aWZpZXI6XG4gICAgICAgIGNhc2UgVG9rZW4uU3RyaW5nTGl0ZXJhbDpcbiAgICAgICAgY2FzZSBUb2tlbi5Cb29sZWFuTGl0ZXJhbDpcbiAgICAgICAgY2FzZSBUb2tlbi5OdWxsTGl0ZXJhbDpcbiAgICAgICAgY2FzZSBUb2tlbi5OdW1lcmljTGl0ZXJhbDpcbiAgICAgICAgY2FzZSBUb2tlbi5LZXl3b3JkOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgVG9rZW4uUHVuY3R1YXRvcjpcbiAgICAgICAgICAgIHJldHVybiBsb29rYWhlYWQudmFsdWUgPT09ICdbJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB0byB0cnkgdG8gcGFyc2UgYSBNZXRob2REZWZpbml0aW9uIGFzIGRlZmluZWQgaW4gMTQuMy4gQnV0IGluIHRoZSBjYXNlIG9mIG9iamVjdCBsaXRlcmFscyxcbiAgICAvLyBpdCBtaWdodCBiZSBjYWxsZWQgYXQgYSBwb3NpdGlvbiB3aGVyZSB0aGVyZSBpcyBpbiBmYWN0IGEgc2hvcnQgaGFuZCBpZGVudGlmaWVyIHBhdHRlcm4gb3IgYSBkYXRhIHByb3BlcnR5LlxuICAgIC8vIFRoaXMgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhZnRlciB3ZSBjb25zdW1lZCB1cCB0byB0aGUgbGVmdCBwYXJlbnRoZXNlcy5cbiAgICAvL1xuICAgIC8vIEluIG9yZGVyIHRvIGF2b2lkIGJhY2sgdHJhY2tpbmcsIGl0IHJldHVybnMgYG51bGxgIGlmIHRoZSBwb3NpdGlvbiBpcyBub3QgYSBNZXRob2REZWZpbml0aW9uIGFuZCB0aGUgY2FsbGVyXG4gICAgLy8gaXMgcmVzcG9uc2libGUgdG8gdmlzaXQgb3RoZXIgb3B0aW9ucy5cbiAgICBmdW5jdGlvbiB0cnlQYXJzZU1ldGhvZERlZmluaXRpb24odG9rZW4sIGtleSwgY29tcHV0ZWQsIG5vZGUpIHtcbiAgICAgICAgdmFyIHZhbHVlLCBvcHRpb25zLCBtZXRob2ROb2RlO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgYGdldGAgYW5kIGBzZXRgO1xuXG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdnZXQnICYmIGxvb2thaGVhZFByb3BlcnR5TmFtZSgpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZWQgPSBtYXRjaCgnWycpO1xuICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICAgICAgICBtZXRob2ROb2RlID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoJygnKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoJyknKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlUHJvcGVydHlGdW5jdGlvbihtZXRob2ROb2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogW10sXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgc3RyaWN0ZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdnZXQnLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICdzZXQnICYmIGxvb2thaGVhZFByb3BlcnR5TmFtZSgpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZWQgPSBtYXRjaCgnWycpO1xuICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICAgICAgICBtZXRob2ROb2RlID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogW10sXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDb3VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtU2V0OiB7fVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZVBhcmFtKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKG1ldGhvZE5vZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdzZXQnLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlUHJvcGVydHlNZXRob2RGdW5jdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoJ2luaXQnLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90IGEgTWV0aG9kRGVmaW5pdGlvbi5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tQcm90byhrZXksIGNvbXB1dGVkLCBoYXNQcm90bykge1xuICAgICAgICBpZiAoY29tcHV0ZWQgPT09IGZhbHNlICYmIChrZXkudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYga2V5Lm5hbWUgPT09ICdfX3Byb3RvX18nIHx8XG4gICAgICAgICAgICBrZXkudHlwZSA9PT0gU3ludGF4LkxpdGVyYWwgJiYga2V5LnZhbHVlID09PSAnX19wcm90b19fJykpIHtcbiAgICAgICAgICAgIGlmIChoYXNQcm90by52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuRHVwbGljYXRlUHJvdG9Qcm9wZXJ0eSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhc1Byb3RvLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0UHJvcGVydHkoaGFzUHJvdG8pIHtcbiAgICAgICAgdmFyIHRva2VuID0gbG9va2FoZWFkLCBub2RlID0gbmV3IE5vZGUoKSwgY29tcHV0ZWQsIGtleSwgbWF5YmVNZXRob2QsIHZhbHVlO1xuXG4gICAgICAgIGNvbXB1dGVkID0gbWF0Y2goJ1snKTtcbiAgICAgICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICBtYXliZU1ldGhvZCA9IHRyeVBhcnNlTWV0aG9kRGVmaW5pdGlvbih0b2tlbiwga2V5LCBjb21wdXRlZCwgbm9kZSk7XG5cbiAgICAgICAgaWYgKG1heWJlTWV0aG9kKSB7XG4gICAgICAgICAgICBjaGVja1Byb3RvKG1heWJlTWV0aG9kLmtleSwgbWF5YmVNZXRob2QuY29tcHV0ZWQsIGhhc1Byb3RvKTtcbiAgICAgICAgICAgIC8vIGZpbmlzaGVkXG4gICAgICAgICAgICByZXR1cm4gbWF5YmVNZXRob2Q7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbml0IHByb3BlcnR5IG9yIHNob3J0IGhhbmQgcHJvcGVydHkuXG4gICAgICAgIGNoZWNrUHJvdG8oa2V5LCBjb21wdXRlZCwgaGFzUHJvdG8pO1xuXG4gICAgICAgIGlmIChtYXRjaCgnOicpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHZhbHVlID0gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdpbml0Jywga2V5LCBjb21wdXRlZCwgdmFsdWUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCc9JykpIHtcbiAgICAgICAgICAgICAgICBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdpbml0Jywga2V5LCBjb21wdXRlZCxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFdyYXBwaW5nTm9kZSh0b2tlbikuZmluaXNoQXNzaWdubWVudFBhdHRlcm4oa2V5LCB2YWx1ZSksIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdpbml0Jywga2V5LCBjb21wdXRlZCwga2V5LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0SW5pdGlhbGlzZXIoKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gW10sIGhhc1Byb3RvID0ge3ZhbHVlOiBmYWxzZX0sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuXG4gICAgICAgIHdoaWxlICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHBhcnNlT2JqZWN0UHJvcGVydHkoaGFzUHJvdG8pKTtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0Q29tbWFTZXBhcmF0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnfScpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaE9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gICAgICAgIGNhc2UgU3ludGF4LklkZW50aWZpZXI6XG4gICAgICAgIGNhc2UgU3ludGF4Lk1lbWJlckV4cHJlc3Npb246XG4gICAgICAgIGNhc2UgU3ludGF4LlJlc3RFbGVtZW50OlxuICAgICAgICBjYXNlIFN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN5bnRheC5TcHJlYWRFbGVtZW50OlxuICAgICAgICAgICAgZXhwci50eXBlID0gU3ludGF4LlJlc3RFbGVtZW50O1xuICAgICAgICAgICAgcmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIuYXJndW1lbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3ludGF4LkFycmF5RXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGV4cHIudHlwZSA9IFN5bnRheC5BcnJheVBhdHRlcm47XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXhwci5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChleHByLmVsZW1lbnRzW2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTeW50YXguT2JqZWN0RXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGV4cHIudHlwZSA9IFN5bnRheC5PYmplY3RQYXR0ZXJuO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cHIucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLnByb3BlcnRpZXNbaV0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uOlxuICAgICAgICAgICAgZXhwci50eXBlID0gU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuO1xuICAgICAgICAgICAgcmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIubGVmdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIEFsbG93IG90aGVyIG5vZGUgdHlwZSBmb3IgdG9sZXJhbnQgcGFyc2luZy5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZUVsZW1lbnQob3B0aW9uKSB7XG4gICAgICAgIHZhciBub2RlLCB0b2tlbjtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlRlbXBsYXRlIHx8IChvcHRpb24uaGVhZCAmJiAhbG9va2FoZWFkLmhlYWQpKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG4gICAgICAgIHRva2VuID0gbGV4KCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoVGVtcGxhdGVFbGVtZW50KHsgcmF3OiB0b2tlbi52YWx1ZS5yYXcsIGNvb2tlZDogdG9rZW4udmFsdWUuY29va2VkIH0sIHRva2VuLnRhaWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVGVtcGxhdGVMaXRlcmFsKCkge1xuICAgICAgICB2YXIgcXVhc2ksIHF1YXNpcywgZXhwcmVzc2lvbnMsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIHF1YXNpID0gcGFyc2VUZW1wbGF0ZUVsZW1lbnQoeyBoZWFkOiB0cnVlIH0pO1xuICAgICAgICBxdWFzaXMgPSBbIHF1YXNpIF07XG4gICAgICAgIGV4cHJlc3Npb25zID0gW107XG5cbiAgICAgICAgd2hpbGUgKCFxdWFzaS50YWlsKSB7XG4gICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICAgICAgICAgIHF1YXNpID0gcGFyc2VUZW1wbGF0ZUVsZW1lbnQoeyBoZWFkOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHF1YXNpcy5wdXNoKHF1YXNpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFRlbXBsYXRlTGl0ZXJhbChxdWFzaXMsIGV4cHJlc3Npb25zKTtcbiAgICB9XG5cbiAgICAvLyAxMS4xLjYgVGhlIEdyb3VwaW5nIE9wZXJhdG9yXG5cbiAgICBmdW5jdGlvbiBwYXJzZUdyb3VwRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIsIGV4cHJlc3Npb25zLCBzdGFydFRva2VuLCBpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2goJz0+JykpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoJz0+Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFBsYWNlSG9sZGVycy5BcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICBpZiAobWF0Y2goJy4uLicpKSB7XG4gICAgICAgICAgICBleHByID0gcGFyc2VSZXN0RWxlbWVudCgpO1xuICAgICAgICAgICAgZXhwZWN0KCcpJyk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKCc9PicpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCc9PicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBQbGFjZUhvbGRlcnMuQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFtleHByXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzQmluZGluZ0VsZW1lbnQgPSB0cnVlO1xuICAgICAgICBleHByID0gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcblxuICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBleHByZXNzaW9ucyA9IFtleHByXTtcblxuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxleCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKCcuLi4nKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQmluZGluZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChwYXJzZVJlc3RFbGVtZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoJyknKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCgnPT4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KCc9PicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwcmVzc2lvbnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBQbGFjZUhvbGRlcnMuQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hTZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpO1xuICAgICAgICB9XG5cblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBpZiAobWF0Y2goJz0+JykpIHtcbiAgICAgICAgICAgIGlmICghaXNCaW5kaW5nRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHByLnR5cGUgPT09IFN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXhwci5leHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5leHByZXNzaW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogUGxhY2VIb2xkZXJzLkFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBleHByLnR5cGUgPT09IFN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb24gPyBleHByLmV4cHJlc3Npb25zIDogW2V4cHJdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG5cbiAgICAvLyAxMS4xIFByaW1hcnkgRXhwcmVzc2lvbnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciB0eXBlLCB0b2tlbiwgZXhwciwgbm9kZTtcblxuICAgICAgICBpZiAobWF0Y2goJygnKSkge1xuICAgICAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VHcm91cEV4cHJlc3Npb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmhlcml0Q292ZXJHcmFtbWFyKHBhcnNlQXJyYXlJbml0aWFsaXNlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJ3snKSkge1xuICAgICAgICAgICAgcmV0dXJuIGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VPYmplY3RJbml0aWFsaXNlcik7XG4gICAgICAgIH1cblxuICAgICAgICB0eXBlID0gbG9va2FoZWFkLnR5cGU7XG4gICAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hJZGVudGlmaWVyKGxleCgpLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsIHx8IHR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGxvb2thaGVhZC5vY3RhbCkge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwobGV4KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ3RoaXMnKSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFRoaXNFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdjbGFzcycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQ2xhc3NFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsZXgoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uQm9vbGVhbkxpdGVyYWwpIHtcbiAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9ICh0b2tlbi52YWx1ZSA9PT0gJ3RydWUnKTtcbiAgICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwodG9rZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLk51bGxMaXRlcmFsKSB7XG4gICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgdG9rZW4udmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJy8nKSB8fCBtYXRjaCgnLz0nKSkge1xuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSBzdGFydEluZGV4O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGNvbGxlY3RSZWdleCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHNjYW5SZWdFeHAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZVRlbXBsYXRlTGl0ZXJhbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obGV4KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gMTEuMiBMZWZ0LUhhbmQtU2lkZSBFeHByZXNzaW9uc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VBcmd1bWVudHMoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2goJyknKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0Q29tbWFTZXBhcmF0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpIHtcbiAgICAgICAgdmFyIHRva2VuLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICB0b2tlbiA9IGxleCgpO1xuXG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyTmFtZSh0b2tlbikpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaElkZW50aWZpZXIodG9rZW4udmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKSB7XG4gICAgICAgIGV4cGVjdCgnLicpO1xuXG4gICAgICAgIHJldHVybiBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbXB1dGVkTWVtYmVyKCkge1xuICAgICAgICB2YXIgZXhwcjtcblxuICAgICAgICBleHBlY3QoJ1snKTtcblxuICAgICAgICBleHByID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUV4cHJlc3Npb24pO1xuXG4gICAgICAgIGV4cGVjdCgnXScpO1xuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTmV3RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGNhbGxlZSwgYXJncywgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnbmV3Jyk7XG4gICAgICAgIGNhbGxlZSA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKTtcbiAgICAgICAgYXJncyA9IG1hdGNoKCcoJykgPyBwYXJzZUFyZ3VtZW50cygpIDogW107XG5cbiAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaE5ld0V4cHJlc3Npb24oY2FsbGVlLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKSB7XG4gICAgICAgIHZhciBxdWFzaSwgZXhwciwgYXJncywgcHJvcGVydHksIHN0YXJ0VG9rZW4sIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG5cbiAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHRydWU7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnc3VwZXInKSAmJiBzdGF0ZS5pbkZ1bmN0aW9uQm9keSkge1xuICAgICAgICAgICAgZXhwciA9IG5ldyBOb2RlKCk7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGV4cHIgPSBleHByLmZpbmlzaFN1cGVyKCk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKCcoJykgJiYgIW1hdGNoKCcuJykgJiYgIW1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwciA9IGluaGVyaXRDb3ZlckdyYW1tYXIobWF0Y2hLZXl3b3JkKCduZXcnKSA/IHBhcnNlTmV3RXhwcmVzc2lvbiA6IHBhcnNlUHJpbWFyeUV4cHJlc3Npb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCcuJykpIHtcbiAgICAgICAgICAgICAgICBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKTtcbiAgICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hNZW1iZXJFeHByZXNzaW9uKCcuJywgZXhwciwgcHJvcGVydHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBwYXJzZUFyZ3VtZW50cygpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaENhbGxFeHByZXNzaW9uKGV4cHIsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZUNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignWycsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLlRlbXBsYXRlICYmIGxvb2thaGVhZC5oZWFkKSB7XG4gICAgICAgICAgICAgICAgcXVhc2kgPSBwYXJzZVRlbXBsYXRlTGl0ZXJhbCgpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihleHByLCBxdWFzaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgcXVhc2ksIGV4cHIsIHByb3BlcnR5LCBzdGFydFRva2VuO1xuICAgICAgICBhc3NlcnQoc3RhdGUuYWxsb3dJbiwgJ2NhbGxlZSBvZiBuZXcgZXhwcmVzc2lvbiBhbHdheXMgYWxsb3cgaW4ga2V5d29yZC4nKTtcblxuICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ3N1cGVyJykgJiYgc3RhdGUuaW5GdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgIGV4cHIgPSBuZXcgTm9kZSgpO1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBleHByID0gZXhwci5maW5pc2hTdXBlcigpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnWycpICYmICFtYXRjaCgnLicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHIgPSBpbmhlcml0Q292ZXJHcmFtbWFyKG1hdGNoS2V5d29yZCgnbmV3JykgPyBwYXJzZU5ld0V4cHJlc3Npb24gOiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICAgICAgaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZUNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignWycsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJy4nKSkge1xuICAgICAgICAgICAgICAgIGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VOb25Db21wdXRlZE1lbWJlcigpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaE1lbWJlckV4cHJlc3Npb24oJy4nLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5UZW1wbGF0ZSAmJiBsb29rYWhlYWQuaGVhZCkge1xuICAgICAgICAgICAgICAgIHF1YXNpID0gcGFyc2VUZW1wbGF0ZUxpdGVyYWwoKTtcbiAgICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oZXhwciwgcXVhc2kpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyAxMS4zIFBvc3RmaXggRXhwcmVzc2lvbnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBleHByLCB0b2tlbiwgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgICBleHByID0gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwpO1xuXG4gICAgICAgIGlmICghaGFzTGluZVRlcm1pbmF0b3IgJiYgbG9va2FoZWFkLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnKysnKSB8fCBtYXRjaCgnLS0nKSkge1xuICAgICAgICAgICAgICAgIC8vIDExLjMuMSwgMTEuMy4yXG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBleHByLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIGlzUmVzdHJpY3RlZFdvcmQoZXhwci5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLlN0cmljdExIU1Bvc3RmaXgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaXNBc3NpZ25tZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuSW52YWxpZExIU0luQXNzaWdubWVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hQb3N0Zml4RXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyAxMS40IFVuYXJ5IE9wZXJhdG9yc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VVbmFyeUV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciB0b2tlbiwgZXhwciwgc3RhcnRUb2tlbjtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnR5cGUgIT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpIHtcbiAgICAgICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VVbmFyeUV4cHJlc3Npb24pO1xuICAgICAgICAgICAgLy8gMTEuNC40LCAxMS40LjVcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllciAmJiBpc1Jlc3RyaWN0ZWRXb3JkKGV4cHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLlN0cmljdExIU1ByZWZpeCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNBc3NpZ25tZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaFVuYXJ5RXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwcik7XG4gICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJysnKSB8fCBtYXRjaCgnLScpIHx8IG1hdGNoKCd+JykgfHwgbWF0Y2goJyEnKSkge1xuICAgICAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICBleHByID0gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZVVuYXJ5RXhwcmVzc2lvbik7XG4gICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hVbmFyeUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpO1xuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoS2V5d29yZCgnZGVsZXRlJykgfHwgbWF0Y2hLZXl3b3JkKCd2b2lkJykgfHwgbWF0Y2hLZXl3b3JkKCd0eXBlb2YnKSkge1xuICAgICAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICBleHByID0gaW5oZXJpdENvdmVyR3JhbW1hcihwYXJzZVVuYXJ5RXhwcmVzc2lvbik7XG4gICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hVbmFyeUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBleHByLm9wZXJhdG9yID09PSAnZGVsZXRlJyAmJiBleHByLmFyZ3VtZW50LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5TdHJpY3REZWxldGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0ID0gaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwciA9IHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpbmFyeVByZWNlZGVuY2UodG9rZW4sIGFsbG93SW4pIHtcbiAgICAgICAgdmFyIHByZWMgPSAwO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnR5cGUgIT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICBjYXNlICd8fCc6XG4gICAgICAgICAgICBwcmVjID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJyYmJzpcbiAgICAgICAgICAgIHByZWMgPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgICBwcmVjID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgICAgcHJlYyA9IDQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICAgIHByZWMgPSA1O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICBjYXNlICchPSc6XG4gICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICBwcmVjID0gNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgIGNhc2UgJ2luc3RhbmNlb2YnOlxuICAgICAgICAgICAgcHJlYyA9IDc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdpbic6XG4gICAgICAgICAgICBwcmVjID0gYWxsb3dJbiA/IDcgOiAwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnPDwnOlxuICAgICAgICBjYXNlICc+Pic6XG4gICAgICAgIGNhc2UgJz4+Pic6XG4gICAgICAgICAgICBwcmVjID0gODtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgIHByZWMgPSA5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgIGNhc2UgJy8nOlxuICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgIHByZWMgPSAxMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcmVjO1xuICAgIH1cblxuICAgIC8vIDExLjUgTXVsdGlwbGljYXRpdmUgT3BlcmF0b3JzXG4gICAgLy8gMTEuNiBBZGRpdGl2ZSBPcGVyYXRvcnNcbiAgICAvLyAxMS43IEJpdHdpc2UgU2hpZnQgT3BlcmF0b3JzXG4gICAgLy8gMTEuOCBSZWxhdGlvbmFsIE9wZXJhdG9yc1xuICAgIC8vIDExLjkgRXF1YWxpdHkgT3BlcmF0b3JzXG4gICAgLy8gMTEuMTAgQmluYXJ5IEJpdHdpc2UgT3BlcmF0b3JzXG4gICAgLy8gMTEuMTEgQmluYXJ5IExvZ2ljYWwgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZUJpbmFyeUV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBtYXJrZXIsIG1hcmtlcnMsIGV4cHIsIHRva2VuLCBwcmVjLCBzdGFjaywgcmlnaHQsIG9wZXJhdG9yLCBsZWZ0LCBpO1xuXG4gICAgICAgIG1hcmtlciA9IGxvb2thaGVhZDtcbiAgICAgICAgbGVmdCA9IGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VVbmFyeUV4cHJlc3Npb24pO1xuXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICBwcmVjID0gYmluYXJ5UHJlY2VkZW5jZSh0b2tlbiwgc3RhdGUuYWxsb3dJbik7XG4gICAgICAgIGlmIChwcmVjID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIHRva2VuLnByZWMgPSBwcmVjO1xuICAgICAgICBsZXgoKTtcblxuICAgICAgICBtYXJrZXJzID0gW21hcmtlciwgbG9va2FoZWFkXTtcbiAgICAgICAgcmlnaHQgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlVW5hcnlFeHByZXNzaW9uKTtcblxuICAgICAgICBzdGFjayA9IFtsZWZ0LCB0b2tlbiwgcmlnaHRdO1xuXG4gICAgICAgIHdoaWxlICgocHJlYyA9IGJpbmFyeVByZWNlZGVuY2UobG9va2FoZWFkLCBzdGF0ZS5hbGxvd0luKSkgPiAwKSB7XG5cbiAgICAgICAgICAgIC8vIFJlZHVjZTogbWFrZSBhIGJpbmFyeSBleHByZXNzaW9uIGZyb20gdGhlIHRocmVlIHRvcG1vc3QgZW50cmllcy5cbiAgICAgICAgICAgIHdoaWxlICgoc3RhY2subGVuZ3RoID4gMikgJiYgKHByZWMgPD0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMl0ucHJlYykpIHtcbiAgICAgICAgICAgICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yID0gc3RhY2sucG9wKCkudmFsdWU7XG4gICAgICAgICAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIG1hcmtlcnMucG9wKCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUobWFya2Vyc1ttYXJrZXJzLmxlbmd0aCAtIDFdKS5maW5pc2hCaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChleHByKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2hpZnQuXG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgdG9rZW4ucHJlYyA9IHByZWM7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIG1hcmtlcnMucHVzaChsb29rYWhlYWQpO1xuICAgICAgICAgICAgZXhwciA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VVbmFyeUV4cHJlc3Npb24pO1xuICAgICAgICAgICAgc3RhY2sucHVzaChleHByKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsIHJlZHVjZSB0byBjbGVhbi11cCB0aGUgc3RhY2suXG4gICAgICAgIGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBleHByID0gc3RhY2tbaV07XG4gICAgICAgIG1hcmtlcnMucG9wKCk7XG4gICAgICAgIHdoaWxlIChpID4gMSkge1xuICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUobWFya2Vycy5wb3AoKSkuZmluaXNoQmluYXJ5RXhwcmVzc2lvbihzdGFja1tpIC0gMV0udmFsdWUsIHN0YWNrW2kgLSAyXSwgZXhwcik7XG4gICAgICAgICAgICBpIC09IDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cblxuICAgIC8vIDExLjEyIENvbmRpdGlvbmFsIE9wZXJhdG9yXG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIsIHByZXZpb3VzQWxsb3dJbiwgY29uc2VxdWVudCwgYWx0ZXJuYXRlLCBzdGFydFRva2VuO1xuXG4gICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgICAgZXhwciA9IGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VCaW5hcnlFeHByZXNzaW9uKTtcbiAgICAgICAgaWYgKG1hdGNoKCc/JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgcHJldmlvdXNBbGxvd0luID0gc3RhdGUuYWxsb3dJbjtcbiAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSB0cnVlO1xuICAgICAgICAgICAgY29uc2VxdWVudCA9IGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuICAgICAgICAgICAgZXhwZWN0KCc6Jyk7XG4gICAgICAgICAgICBhbHRlcm5hdGUgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuXG4gICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hDb25kaXRpb25hbEV4cHJlc3Npb24oZXhwciwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKTtcbiAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIFtFUzZdIDE0LjIgQXJyb3cgRnVuY3Rpb25cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ29uY2lzZUJvZHkoKSB7XG4gICAgICAgIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzb2xhdGVDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0pIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHN3aXRjaCAocGFyYW0udHlwZSkge1xuICAgICAgICBjYXNlIFN5bnRheC5JZGVudGlmaWVyOlxuICAgICAgICAgICAgdmFsaWRhdGVQYXJhbShvcHRpb25zLCBwYXJhbSwgcGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTeW50YXguUmVzdEVsZW1lbnQ6XG4gICAgICAgICAgICBjaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbS5hcmd1bWVudCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTeW50YXguQXNzaWdubWVudFBhdHRlcm46XG4gICAgICAgICAgICBjaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbS5sZWZ0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN5bnRheC5BcnJheVBhdHRlcm46XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyYW0uZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0uZWxlbWVudHNbaV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0uZWxlbWVudHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYXNzZXJ0KHBhcmFtLnR5cGUgPT09IFN5bnRheC5PYmplY3RQYXR0ZXJuLCAnSW52YWxpZCB0eXBlJyk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyYW0ucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLnByb3BlcnRpZXNbaV0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVpbnRlcnByZXRBc0NvdmVyRm9ybWFsc0xpc3QoZXhwcikge1xuICAgICAgICB2YXIgaSwgbGVuLCBwYXJhbSwgcGFyYW1zLCBkZWZhdWx0cywgZGVmYXVsdENvdW50LCBvcHRpb25zLCB0b2tlbjtcblxuICAgICAgICBkZWZhdWx0cyA9IFtdO1xuICAgICAgICBkZWZhdWx0Q291bnQgPSAwO1xuICAgICAgICBwYXJhbXMgPSBbZXhwcl07XG5cbiAgICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICAgICAgY2FzZSBTeW50YXguSWRlbnRpZmllcjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFBsYWNlSG9sZGVycy5BcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyOlxuICAgICAgICAgICAgcGFyYW1zID0gZXhwci5wYXJhbXM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHBhcmFtU2V0OiB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHBhcmFtcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcGFyYW0gPSBwYXJhbXNbaV07XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcmFtLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuOlxuICAgICAgICAgICAgICAgIHBhcmFtc1tpXSA9IHBhcmFtLmxlZnQ7XG4gICAgICAgICAgICAgICAgZGVmYXVsdHMucHVzaChwYXJhbS5yaWdodCk7XG4gICAgICAgICAgICAgICAgKytkZWZhdWx0Q291bnQ7XG4gICAgICAgICAgICAgICAgY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0ubGVmdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtKTtcbiAgICAgICAgICAgICAgICBwYXJhbXNbaV0gPSBwYXJhbTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0cy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubWVzc2FnZSA9PT0gTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHN0cmljdCA/IG9wdGlvbnMuc3RyaWN0ZWQgOiBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZDtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBvcHRpb25zLm1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZmF1bHRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgZGVmYXVsdHMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgIGRlZmF1bHRzOiBkZWZhdWx0cyxcbiAgICAgICAgICAgIHN0cmljdGVkOiBvcHRpb25zLnN0cmljdGVkLFxuICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24ob3B0aW9ucywgbm9kZSkge1xuICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QsIGJvZHk7XG5cbiAgICAgICAgaWYgKGhhc0xpbmVUZXJtaW5hdG9yKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQpO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdCgnPT4nKTtcbiAgICAgICAgcHJldmlvdXNTdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICAgICAgYm9keSA9IHBhcnNlQ29uY2lzZUJvZHkoKTtcblxuICAgICAgICBpZiAoc3RyaWN0ICYmIG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCwgb3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaWN0ICYmIG9wdGlvbnMuc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKG9wdGlvbnMuc3RyaWN0ZWQsIG9wdGlvbnMubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihvcHRpb25zLnBhcmFtcywgb3B0aW9ucy5kZWZhdWx0cywgYm9keSwgYm9keS50eXBlICE9PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIDExLjEzIEFzc2lnbm1lbnQgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgdG9rZW4sIGV4cHIsIHJpZ2h0LCBsaXN0LCBzdGFydFRva2VuO1xuXG4gICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICAgIGV4cHIgPSBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGlmIChleHByLnR5cGUgPT09IFBsYWNlSG9sZGVycy5BcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyIHx8IG1hdGNoKCc9PicpKSB7XG4gICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBsaXN0ID0gcmVpbnRlcnByZXRBc0NvdmVyRm9ybWFsc0xpc3QoZXhwcik7XG5cbiAgICAgICAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgICAgICAgICAgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihsaXN0LCBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hBc3NpZ24oKSkge1xuICAgICAgICAgICAgaWYgKCFpc0Fzc2lnbm1lbnRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAxMS4xMy4xXG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgaXNSZXN0cmljdGVkV29yZChleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIE1lc3NhZ2VzLlN0cmljdExIU0Fzc2lnbm1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW1hdGNoKCc9JykpIHtcbiAgICAgICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQgPSBpc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaEFzc2lnbm1lbnRFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByLCByaWdodCk7XG4gICAgICAgICAgICBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gMTEuMTQgQ29tbWEgT3BlcmF0b3JcblxuICAgIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIsIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQsIGV4cHJlc3Npb25zO1xuXG4gICAgICAgIGV4cHIgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuXG4gICAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICBleHByZXNzaW9ucyA9IFtleHByXTtcblxuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaFNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyAxMi4xIEJsb2NrXG5cbiAgICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudExpc3RJdGVtKCkge1xuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobG9va2FoZWFkLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdleHBvcnQnOlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VUeXBlICE9PSAnbW9kdWxlJykge1xuICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQsIE1lc3NhZ2VzLklsbGVnYWxFeHBvcnREZWNsYXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUV4cG9ydERlY2xhcmF0aW9uKCk7XG4gICAgICAgICAgICBjYXNlICdpbXBvcnQnOlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VUeXBlICE9PSAnbW9kdWxlJykge1xuICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihsb29rYWhlYWQsIE1lc3NhZ2VzLklsbGVnYWxJbXBvcnREZWNsYXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUltcG9ydERlY2xhcmF0aW9uKCk7XG4gICAgICAgICAgICBjYXNlICdjb25zdCc6XG4gICAgICAgICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUxleGljYWxEZWNsYXJhdGlvbih7aW5Gb3I6IGZhbHNlfSk7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbihuZXcgTm9kZSgpKTtcbiAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VDbGFzc0RlY2xhcmF0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudExpc3QoKSB7XG4gICAgICAgIHZhciBsaXN0ID0gW107XG4gICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdC5wdXNoKHBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUJsb2NrKCkge1xuICAgICAgICB2YXIgYmxvY2ssIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuXG4gICAgICAgIGJsb2NrID0gcGFyc2VTdGF0ZW1lbnRMaXN0KCk7XG5cbiAgICAgICAgZXhwZWN0KCd9Jyk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQmxvY2tTdGF0ZW1lbnQoYmxvY2spO1xuICAgIH1cblxuICAgIC8vIDEyLjIgVmFyaWFibGUgU3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpIHtcbiAgICAgICAgdmFyIHRva2VuLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICB0b2tlbiA9IGxleCgpO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIHRva2VuLnR5cGUgPT09IFRva2VuLktleXdvcmQgJiYgaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hJZGVudGlmaWVyKHRva2VuLnZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24oKSB7XG4gICAgICAgIHZhciBpbml0ID0gbnVsbCwgaWQsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGlkID0gcGFyc2VQYXR0ZXJuKCk7XG5cbiAgICAgICAgLy8gMTIuMi4xXG4gICAgICAgIGlmIChzdHJpY3QgJiYgaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xuICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5TdHJpY3RWYXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaCgnPScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGluaXQgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGlkLnR5cGUgIT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBleHBlY3QoJz0nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFZhcmlhYmxlRGVjbGFyYXRvcihpZCwgaW5pdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCgpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBsaXN0LnB1c2gocGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uKCkpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgfSB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCk7XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYXJpYWJsZVN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBkZWNsYXJhdGlvbnM7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgndmFyJyk7XG5cbiAgICAgICAgZGVjbGFyYXRpb25zID0gcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCgpO1xuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hWYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMZXhpY2FsQmluZGluZyhraW5kLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBpbml0ID0gbnVsbCwgaWQsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGlkID0gcGFyc2VQYXR0ZXJuKCk7XG5cbiAgICAgICAgLy8gMTIuMi4xXG4gICAgICAgIGlmIChzdHJpY3QgJiYgaWQudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xuICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5TdHJpY3RWYXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChraW5kID09PSAnY29uc3QnKSB7XG4gICAgICAgICAgICBpZiAoIW1hdGNoS2V5d29yZCgnaW4nKSkge1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnPScpO1xuICAgICAgICAgICAgICAgIGluaXQgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCghb3B0aW9ucy5pbkZvciAmJiBpZC50eXBlICE9PSBTeW50YXguSWRlbnRpZmllcikgfHwgbWF0Y2goJz0nKSkge1xuICAgICAgICAgICAgZXhwZWN0KCc9Jyk7XG4gICAgICAgICAgICBpbml0ID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFZhcmlhYmxlRGVjbGFyYXRvcihpZCwgaW5pdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VCaW5kaW5nTGlzdChraW5kLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBsaXN0ID0gW107XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGlzdC5wdXNoKHBhcnNlTGV4aWNhbEJpbmRpbmcoa2luZCwgb3B0aW9ucykpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgfSB3aGlsZSAoc3RhcnRJbmRleCA8IGxlbmd0aCk7XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMZXhpY2FsRGVjbGFyYXRpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIga2luZCwgZGVjbGFyYXRpb25zLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBraW5kID0gbGV4KCkudmFsdWU7XG4gICAgICAgIGFzc2VydChraW5kID09PSAnbGV0JyB8fCBraW5kID09PSAnY29uc3QnLCAnTGV4aWNhbCBkZWNsYXJhdGlvbiBtdXN0IGJlIGVpdGhlciBsZXQgb3IgY29uc3QnKTtcblxuICAgICAgICBkZWNsYXJhdGlvbnMgPSBwYXJzZUJpbmRpbmdMaXN0KGtpbmQsIG9wdGlvbnMpO1xuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hMZXhpY2FsRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVJlc3RFbGVtZW50KCkge1xuICAgICAgICB2YXIgcGFyYW0sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGxleCgpO1xuXG4gICAgICAgIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLk9iamVjdFBhdHRlcm5Bc1Jlc3RQYXJhbWV0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW0gPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnPScpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLkRlZmF1bHRSZXN0UGFyYW1ldGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWF0Y2goJyknKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5QYXJhbWV0ZXJBZnRlclJlc3RQYXJhbWV0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUmVzdEVsZW1lbnQocGFyYW0pO1xuICAgIH1cblxuICAgIC8vIDEyLjMgRW1wdHkgU3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgZXhwZWN0KCc7Jyk7XG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEVtcHR5U3RhdGVtZW50KCk7XG4gICAgfVxuXG4gICAgLy8gMTIuNCBFeHByZXNzaW9uIFN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpO1xuICAgIH1cblxuICAgIC8vIDEyLjUgSWYgc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlmU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZTtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdpZicpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIHRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBjb25zZXF1ZW50ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblxuICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdlbHNlJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgYWx0ZXJuYXRlID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsdGVybmF0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hJZlN0YXRlbWVudCh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpO1xuICAgIH1cblxuICAgIC8vIDEyLjYgSXRlcmF0aW9uIFN0YXRlbWVudHNcblxuICAgIGZ1bmN0aW9uIHBhcnNlRG9XaGlsZVN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBib2R5LCB0ZXN0LCBvbGRJbkl0ZXJhdGlvbjtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdkbycpO1xuXG4gICAgICAgIG9sZEluSXRlcmF0aW9uID0gc3RhdGUuaW5JdGVyYXRpb247XG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gdHJ1ZTtcblxuICAgICAgICBib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblxuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3doaWxlJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnOycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaERvV2hpbGVTdGF0ZW1lbnQoYm9keSwgdGVzdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VXaGlsZVN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciB0ZXN0LCBib2R5LCBvbGRJbkl0ZXJhdGlvbjtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCd3aGlsZScpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIHRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBvbGRJbkl0ZXJhdGlvbiA9IHN0YXRlLmluSXRlcmF0aW9uO1xuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IHRydWU7XG5cbiAgICAgICAgYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG5cbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSBvbGRJbkl0ZXJhdGlvbjtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hXaGlsZVN0YXRlbWVudCh0ZXN0LCBib2R5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUZvclN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBpbml0LCBpbml0U2VxLCBpbml0U3RhcnRUb2tlbiwgdGVzdCwgdXBkYXRlLCBsZWZ0LCByaWdodCwga2luZCwgZGVjbGFyYXRpb25zLFxuICAgICAgICAgICAgYm9keSwgb2xkSW5JdGVyYXRpb24sIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG5cbiAgICAgICAgaW5pdCA9IHRlc3QgPSB1cGRhdGUgPSBudWxsO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2ZvcicpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnOycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ3ZhcicpKSB7XG4gICAgICAgICAgICAgICAgaW5pdCA9IG5ldyBOb2RlKCk7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaW5pdCA9IGluaXQuZmluaXNoVmFyaWFibGVEZWNsYXJhdGlvbihwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KCkpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5pdC5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIG1hdGNoS2V5d29yZCgnaW4nKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnOycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hLZXl3b3JkKCdjb25zdCcpIHx8IG1hdGNoS2V5d29yZCgnbGV0JykpIHtcbiAgICAgICAgICAgICAgICBpbml0ID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgICAgICBraW5kID0gbGV4KCkudmFsdWU7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zID0gcGFyc2VCaW5kaW5nTGlzdChraW5kLCB7aW5Gb3I6IHRydWV9KTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgZGVjbGFyYXRpb25zWzBdLmluaXQgPT09IG51bGwgJiYgbWF0Y2hLZXl3b3JkKCdpbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBpbml0LmZpbmlzaExleGljYWxEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpO1xuICAgICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdCA9IGluaXQuZmluaXNoTGV4aWNhbERlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbml0U3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaW5pdCA9IGluaGVyaXRDb3ZlckdyYW1tYXIocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2luJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Fzc2lnbm1lbnRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuSW52YWxpZExIU0luRm9ySW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihpbml0KTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0U2VxID0gW2luaXRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0U2VxLnB1c2goaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gbmV3IFdyYXBwaW5nTm9kZShpbml0U3RhcnRUb2tlbikuZmluaXNoU2VxdWVuY2VFeHByZXNzaW9uKGluaXRTZXEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnOycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaCgnOycpKSB7XG4gICAgICAgICAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwZWN0KCc7Jyk7XG5cbiAgICAgICAgICAgIGlmICghbWF0Y2goJyknKSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgb2xkSW5JdGVyYXRpb24gPSBzdGF0ZS5pbkl0ZXJhdGlvbjtcbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSB0cnVlO1xuXG4gICAgICAgIGJvZHkgPSBpc29sYXRlQ292ZXJHcmFtbWFyKHBhcnNlU3RhdGVtZW50KTtcblxuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIHJldHVybiAodHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnKSA/XG4gICAgICAgICAgICAgICAgbm9kZS5maW5pc2hGb3JTdGF0ZW1lbnQoaW5pdCwgdGVzdCwgdXBkYXRlLCBib2R5KSA6XG4gICAgICAgICAgICAgICAgbm9kZS5maW5pc2hGb3JJblN0YXRlbWVudChsZWZ0LCByaWdodCwgYm9keSk7XG4gICAgfVxuXG4gICAgLy8gMTIuNyBUaGUgY29udGludWUgc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbnRpbnVlU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gbnVsbCwga2V5O1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2NvbnRpbnVlJyk7XG5cbiAgICAgICAgLy8gT3B0aW1pemUgdGhlIG1vc3QgY29tbW9uIGZvcm06ICdjb250aW51ZTsnLlxuICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoc3RhcnRJbmRleCkgPT09IDB4M0IpIHtcbiAgICAgICAgICAgIGxleCgpO1xuXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmluSXRlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbGxlZ2FsQ29udGludWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hDb250aW51ZVN0YXRlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNMaW5lVGVybWluYXRvcikge1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pbkl0ZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQ29udGludWVTdGF0ZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGxhYmVsID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcblxuICAgICAgICAgICAga2V5ID0gJyQnICsgbGFiZWwubmFtZTtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLmxhYmVsU2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5Vbmtub3duTGFiZWwsIGxhYmVsLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIGlmIChsYWJlbCA9PT0gbnVsbCAmJiAhc3RhdGUuaW5JdGVyYXRpb24pIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaENvbnRpbnVlU3RhdGVtZW50KGxhYmVsKTtcbiAgICB9XG5cbiAgICAvLyAxMi44IFRoZSBicmVhayBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlQnJlYWtTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgbGFiZWwgPSBudWxsLCBrZXk7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnYnJlYWsnKTtcblxuICAgICAgICAvLyBDYXRjaCB0aGUgdmVyeSBjb21tb24gY2FzZSBmaXJzdDogaW1tZWRpYXRlbHkgYSBzZW1pY29sb24gKFUrMDAzQikuXG4gICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChsYXN0SW5kZXgpID09PSAweDNCKSB7XG4gICAgICAgICAgICBsZXgoKTtcblxuICAgICAgICAgICAgaWYgKCEoc3RhdGUuaW5JdGVyYXRpb24gfHwgc3RhdGUuaW5Td2l0Y2gpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbGxlZ2FsQnJlYWspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hCcmVha1N0YXRlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNMaW5lVGVybWluYXRvcikge1xuICAgICAgICAgICAgaWYgKCEoc3RhdGUuaW5JdGVyYXRpb24gfHwgc3RhdGUuaW5Td2l0Y2gpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbGxlZ2FsQnJlYWspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hCcmVha1N0YXRlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgbGFiZWwgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuXG4gICAgICAgICAgICBrZXkgPSAnJCcgKyBsYWJlbC5uYW1lO1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3RhdGUubGFiZWxTZXQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLlVua25vd25MYWJlbCwgbGFiZWwubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgaWYgKGxhYmVsID09PSBudWxsICYmICEoc3RhdGUuaW5JdGVyYXRpb24gfHwgc3RhdGUuaW5Td2l0Y2gpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLklsbGVnYWxCcmVhayk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hCcmVha1N0YXRlbWVudChsYWJlbCk7XG4gICAgfVxuXG4gICAgLy8gMTIuOSBUaGUgcmV0dXJuIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VSZXR1cm5TdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgYXJndW1lbnQgPSBudWxsO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3JldHVybicpO1xuXG4gICAgICAgIGlmICghc3RhdGUuaW5GdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuSWxsZWdhbFJldHVybik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAncmV0dXJuJyBmb2xsb3dlZCBieSBhIHNwYWNlIGFuZCBhbiBpZGVudGlmaWVyIGlzIHZlcnkgY29tbW9uLlxuICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQobGFzdEluZGV4KSA9PT0gMHgyMCkge1xuICAgICAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGxhc3RJbmRleCArIDEpKSkge1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFJldHVyblN0YXRlbWVudChhcmd1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzTGluZVRlcm1pbmF0b3IpIHtcbiAgICAgICAgICAgIC8vIEhBQ0tcbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFJldHVyblN0YXRlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWF0Y2goJzsnKSkge1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnfScpICYmIGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgICAgICBhcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFJldHVyblN0YXRlbWVudChhcmd1bWVudCk7XG4gICAgfVxuXG4gICAgLy8gMTIuMTAgVGhlIHdpdGggc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgb2JqZWN0LCBib2R5O1xuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuU3RyaWN0TW9kZVdpdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnd2l0aCcpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIG9iamVjdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIGJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFdpdGhTdGF0ZW1lbnQob2JqZWN0LCBib2R5KTtcbiAgICB9XG5cbiAgICAvLyAxMi4xMCBUaGUgc3dpdGggc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVN3aXRjaENhc2UoKSB7XG4gICAgICAgIHZhciB0ZXN0LCBjb25zZXF1ZW50ID0gW10sIHN0YXRlbWVudCwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZGVmYXVsdCcpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHRlc3QgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwZWN0S2V5d29yZCgnY2FzZScpO1xuICAgICAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdCgnOicpO1xuXG4gICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ30nKSB8fCBtYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSB8fCBtYXRjaEtleXdvcmQoJ2Nhc2UnKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGVtZW50ID0gcGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpO1xuICAgICAgICAgICAgY29uc2VxdWVudC5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hTd2l0Y2hDYXNlKHRlc3QsIGNvbnNlcXVlbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGRpc2NyaW1pbmFudCwgY2FzZXMsIGNsYXVzZSwgb2xkSW5Td2l0Y2gsIGRlZmF1bHRGb3VuZDtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdzd2l0Y2gnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICBkaXNjcmltaW5hbnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgICBjYXNlcyA9IFtdO1xuXG4gICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFN3aXRjaFN0YXRlbWVudChkaXNjcmltaW5hbnQsIGNhc2VzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9sZEluU3dpdGNoID0gc3RhdGUuaW5Td2l0Y2g7XG4gICAgICAgIHN0YXRlLmluU3dpdGNoID0gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdEZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGF1c2UgPSBwYXJzZVN3aXRjaENhc2UoKTtcbiAgICAgICAgICAgIGlmIChjbGF1c2UudGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5NdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0Rm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZXMucHVzaChjbGF1c2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuaW5Td2l0Y2ggPSBvbGRJblN3aXRjaDtcblxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hTd2l0Y2hTdGF0ZW1lbnQoZGlzY3JpbWluYW50LCBjYXNlcyk7XG4gICAgfVxuXG4gICAgLy8gMTIuMTMgVGhlIHRocm93IHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VUaHJvd1N0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBhcmd1bWVudDtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCd0aHJvdycpO1xuXG4gICAgICAgIGlmIChoYXNMaW5lVGVybWluYXRvcikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5OZXdsaW5lQWZ0ZXJUaHJvdyk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hUaHJvd1N0YXRlbWVudChhcmd1bWVudCk7XG4gICAgfVxuXG4gICAgLy8gMTIuMTQgVGhlIHRyeSBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlQ2F0Y2hDbGF1c2UoKSB7XG4gICAgICAgIHZhciBwYXJhbSwgYm9keSwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnY2F0Y2gnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcbiAgICAgICAgaWYgKG1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGxvb2thaGVhZCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbSA9IHBhcnNlUGF0dGVybigpO1xuXG4gICAgICAgIC8vIDEyLjE0LjFcbiAgICAgICAgaWYgKHN0cmljdCAmJiBpc1Jlc3RyaWN0ZWRXb3JkKHBhcmFtLm5hbWUpKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLlN0cmljdENhdGNoVmFyaWFibGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG4gICAgICAgIGJvZHkgPSBwYXJzZUJsb2NrKCk7XG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaENhdGNoQ2xhdXNlKHBhcmFtLCBib2R5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVRyeVN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBibG9jaywgaGFuZGxlciA9IG51bGwsIGZpbmFsaXplciA9IG51bGw7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgndHJ5Jyk7XG5cbiAgICAgICAgYmxvY2sgPSBwYXJzZUJsb2NrKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnY2F0Y2gnKSkge1xuICAgICAgICAgICAgaGFuZGxlciA9IHBhcnNlQ2F0Y2hDbGF1c2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2ZpbmFsbHknKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBmaW5hbGl6ZXIgPSBwYXJzZUJsb2NrKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhhbmRsZXIgJiYgIWZpbmFsaXplcikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5Ob0NhdGNoT3JGaW5hbGx5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFRyeVN0YXRlbWVudChibG9jaywgaGFuZGxlciwgZmluYWxpemVyKTtcbiAgICB9XG5cbiAgICAvLyAxMi4xNSBUaGUgZGVidWdnZXIgc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZURlYnVnZ2VyU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgZXhwZWN0S2V5d29yZCgnZGVidWdnZXInKTtcblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRGVidWdnZXJTdGF0ZW1lbnQoKTtcbiAgICB9XG5cbiAgICAvLyAxMiBTdGF0ZW1lbnRzXG5cbiAgICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBsb29rYWhlYWQudHlwZSxcbiAgICAgICAgICAgIGV4cHIsXG4gICAgICAgICAgICBsYWJlbGVkQm9keSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG5vZGU7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gJ3snKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VCbG9jaygpO1xuICAgICAgICB9XG4gICAgICAgIGlzQXNzaWdubWVudFRhcmdldCA9IGlzQmluZGluZ0VsZW1lbnQgPSB0cnVlO1xuICAgICAgICBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvcikge1xuICAgICAgICAgICAgc3dpdGNoIChsb29rYWhlYWQudmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJzsnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgICAgc3dpdGNoIChsb29rYWhlYWQudmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2JyZWFrJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VCcmVha1N0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ2NvbnRpbnVlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VDb250aW51ZVN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ2RlYnVnZ2VyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ2RvJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VEb1doaWxlU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnZm9yJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGb3JTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbihub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ2lmJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJZlN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ3JldHVybic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnc3dpdGNoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VTd2l0Y2hTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICd0aHJvdyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVGhyb3dTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICd0cnknOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVRyeVN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ3Zhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVmFyaWFibGVTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICd3aGlsZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICd3aXRoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VXaXRoU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICAvLyAxMi4xMiBMYWJlbGxlZCBTdGF0ZW1lbnRzXG4gICAgICAgIGlmICgoZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikgJiYgbWF0Y2goJzonKSkge1xuICAgICAgICAgICAgbGV4KCk7XG5cbiAgICAgICAgICAgIGtleSA9ICckJyArIGV4cHIubmFtZTtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3RhdGUubGFiZWxTZXQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLlJlZGVjbGFyYXRpb24sICdMYWJlbCcsIGV4cHIubmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXRlLmxhYmVsU2V0W2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgbGFiZWxlZEJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmxhYmVsU2V0W2tleV07XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hMYWJlbGVkU3RhdGVtZW50KGV4cHIsIGxhYmVsZWRCb2R5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpO1xuICAgIH1cblxuICAgIC8vIDEzIEZ1bmN0aW9uIERlZmluaXRpb25cblxuICAgIGZ1bmN0aW9uIHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpIHtcbiAgICAgICAgdmFyIHN0YXRlbWVudCwgYm9keSA9IFtdLCB0b2tlbiwgZGlyZWN0aXZlLCBmaXJzdFJlc3RyaWN0ZWQsXG4gICAgICAgICAgICBvbGRMYWJlbFNldCwgb2xkSW5JdGVyYXRpb24sIG9sZEluU3dpdGNoLCBvbGRJbkZ1bmN0aW9uQm9keSwgb2xkUGFyZW50aGVzaXNDb3VudCxcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuXG4gICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICAgICAgICBzdGF0ZW1lbnQgPSBwYXJzZVN0YXRlbWVudExpc3RJdGVtKCk7XG4gICAgICAgICAgICBib2R5LnB1c2goc3RhdGVtZW50KTtcbiAgICAgICAgICAgIGlmIChzdGF0ZW1lbnQuZXhwcmVzc2lvbi50eXBlICE9PSBTeW50YXguTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IGRpcmVjdGl2ZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlyZWN0aXZlID0gc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0ICsgMSwgdG9rZW4uZW5kIC0gMSk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlID09PSAndXNlIHN0cmljdCcpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdFJlc3RyaWN0ZWQgJiYgdG9rZW4ub2N0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2xkTGFiZWxTZXQgPSBzdGF0ZS5sYWJlbFNldDtcbiAgICAgICAgb2xkSW5JdGVyYXRpb24gPSBzdGF0ZS5pbkl0ZXJhdGlvbjtcbiAgICAgICAgb2xkSW5Td2l0Y2ggPSBzdGF0ZS5pblN3aXRjaDtcbiAgICAgICAgb2xkSW5GdW5jdGlvbkJvZHkgPSBzdGF0ZS5pbkZ1bmN0aW9uQm9keTtcbiAgICAgICAgb2xkUGFyZW50aGVzaXNDb3VudCA9IHN0YXRlLnBhcmVudGhlc2l6ZWRDb3VudDtcblxuICAgICAgICBzdGF0ZS5sYWJlbFNldCA9IHt9O1xuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5pblN3aXRjaCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5pbkZ1bmN0aW9uQm9keSA9IHRydWU7XG4gICAgICAgIHN0YXRlLnBhcmVudGhlc2l6ZWRDb3VudCA9IDA7XG5cbiAgICAgICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5LnB1c2gocGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnfScpO1xuXG4gICAgICAgIHN0YXRlLmxhYmVsU2V0ID0gb2xkTGFiZWxTZXQ7XG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gb2xkSW5JdGVyYXRpb247XG4gICAgICAgIHN0YXRlLmluU3dpdGNoID0gb2xkSW5Td2l0Y2g7XG4gICAgICAgIHN0YXRlLmluRnVuY3Rpb25Cb2R5ID0gb2xkSW5GdW5jdGlvbkJvZHk7XG4gICAgICAgIHN0YXRlLnBhcmVudGhlc2l6ZWRDb3VudCA9IG9sZFBhcmVudGhlc2lzQ291bnQ7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQmxvY2tTdGF0ZW1lbnQoYm9keSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQYXJhbShvcHRpb25zLCBwYXJhbSwgbmFtZSkge1xuICAgICAgICB2YXIga2V5ID0gJyQnICsgbmFtZTtcbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0cmljdGVkID0gcGFyYW07XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UGFyYW1OYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLnBhcmFtU2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3RlZCA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChuYW1lKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkID0gcGFyYW07XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy5wYXJhbVNldCwga2V5KSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkID0gcGFyYW07XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMucGFyYW1TZXRba2V5XSA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQYXJhbShvcHRpb25zKSB7XG4gICAgICAgIHZhciB0b2tlbiwgcGFyYW0sIGRlZjtcblxuICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnLi4uJykge1xuICAgICAgICAgICAgcGFyYW0gPSBwYXJzZVJlc3RFbGVtZW50KCk7XG4gICAgICAgICAgICB2YWxpZGF0ZVBhcmFtKG9wdGlvbnMsIHBhcmFtLmFyZ3VtZW50LCBwYXJhbS5hcmd1bWVudC5uYW1lKTtcbiAgICAgICAgICAgIG9wdGlvbnMucGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0cy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW0gPSBwYXJzZVBhdHRlcm5XaXRoRGVmYXVsdCgpO1xuICAgICAgICB2YWxpZGF0ZVBhcmFtKG9wdGlvbnMsIHRva2VuLCB0b2tlbi52YWx1ZSk7XG5cbiAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFN5bnRheC5Bc3NpZ25tZW50UGF0dGVybikge1xuICAgICAgICAgICAgZGVmID0gcGFyYW0ucmlnaHQ7XG4gICAgICAgICAgICBwYXJhbSA9IHBhcmFtLmxlZnQ7XG4gICAgICAgICAgICArK29wdGlvbnMuZGVmYXVsdENvdW50O1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucy5wYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICAgIG9wdGlvbnMuZGVmYXVsdHMucHVzaChkZWYpO1xuXG4gICAgICAgIHJldHVybiAhbWF0Y2goJyknKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVBhcmFtcyhmaXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnM7XG5cbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHBhcmFtczogW10sXG4gICAgICAgICAgICBkZWZhdWx0Q291bnQ6IDAsXG4gICAgICAgICAgICBkZWZhdWx0czogW10sXG4gICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQ6IGZpcnN0UmVzdHJpY3RlZFxuICAgICAgICB9O1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGlmICghbWF0Y2goJyknKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5wYXJhbVNldCA9IHt9O1xuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlUGFyYW0ob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFyYW1zOiBvcHRpb25zLnBhcmFtcyxcbiAgICAgICAgICAgIGRlZmF1bHRzOiBvcHRpb25zLmRlZmF1bHRzLFxuICAgICAgICAgICAgc3RyaWN0ZWQ6IG9wdGlvbnMuc3RyaWN0ZWQsXG4gICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQ6IG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkLFxuICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucy5tZXNzYWdlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGUsIGlkZW50aWZpZXJJc09wdGlvbmFsKSB7XG4gICAgICAgIHZhciBpZCA9IG51bGwsIHBhcmFtcyA9IFtdLCBkZWZhdWx0cyA9IFtdLCBib2R5LCB0b2tlbiwgc3RyaWN0ZWQsIHRtcCwgZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlLCBwcmV2aW91c1N0cmljdDtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdmdW5jdGlvbicpO1xuICAgICAgICBpZiAoIWlkZW50aWZpZXJJc09wdGlvbmFsIHx8ICFtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIE1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRtcCA9IHBhcnNlUGFyYW1zKGZpcnN0UmVzdHJpY3RlZCk7XG4gICAgICAgIHBhcmFtcyA9IHRtcC5wYXJhbXM7XG4gICAgICAgIGRlZmF1bHRzID0gdG1wLmRlZmF1bHRzO1xuICAgICAgICBzdHJpY3RlZCA9IHRtcC5zdHJpY3RlZDtcbiAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG1wLmZpcnN0UmVzdHJpY3RlZDtcbiAgICAgICAgaWYgKHRtcC5tZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdG1wLm1lc3NhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgYm9keSA9IHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xuICAgICAgICBpZiAoc3RyaWN0ICYmIGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaWN0ICYmIHN0cmljdGVkKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihzdHJpY3RlZCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRnVuY3Rpb25EZWNsYXJhdGlvbihpZCwgcGFyYW1zLCBkZWZhdWx0cywgYm9keSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciB0b2tlbiwgaWQgPSBudWxsLCBzdHJpY3RlZCwgZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlLCB0bXAsXG4gICAgICAgICAgICBwYXJhbXMgPSBbXSwgZGVmYXVsdHMgPSBbXSwgYm9keSwgcHJldmlvdXNTdHJpY3QsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2Z1bmN0aW9uJyk7XG5cbiAgICAgICAgaWYgKCFtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIE1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRtcCA9IHBhcnNlUGFyYW1zKGZpcnN0UmVzdHJpY3RlZCk7XG4gICAgICAgIHBhcmFtcyA9IHRtcC5wYXJhbXM7XG4gICAgICAgIGRlZmF1bHRzID0gdG1wLmRlZmF1bHRzO1xuICAgICAgICBzdHJpY3RlZCA9IHRtcC5zdHJpY3RlZDtcbiAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG1wLmZpcnN0UmVzdHJpY3RlZDtcbiAgICAgICAgaWYgKHRtcC5tZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdG1wLm1lc3NhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgYm9keSA9IHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xuICAgICAgICBpZiAoc3RyaWN0ICYmIGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaWN0ICYmIHN0cmljdGVkKSB7XG4gICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihzdHJpY3RlZCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRnVuY3Rpb25FeHByZXNzaW9uKGlkLCBwYXJhbXMsIGRlZmF1bHRzLCBib2R5KTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ2xhc3NCb2R5KCkge1xuICAgICAgICB2YXIgY2xhc3NCb2R5LCB0b2tlbiwgaXNTdGF0aWMsIGhhc0NvbnN0cnVjdG9yID0gZmFsc2UsIGJvZHksIG1ldGhvZCwgY29tcHV0ZWQsIGtleTtcblxuICAgICAgICBjbGFzc0JvZHkgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuICAgICAgICBib2R5ID0gW107XG4gICAgICAgIHdoaWxlICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgICAgICBpc1N0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gbWF0Y2goJ1snKTtcbiAgICAgICAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5uYW1lID09PSAnc3RhdGljJyAmJiBsb29rYWhlYWRQcm9wZXJ0eU5hbWUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgICAgICAgICAgaXNTdGF0aWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZCA9IG1hdGNoKCdbJyk7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHJ5UGFyc2VNZXRob2REZWZpbml0aW9uKHRva2VuLCBrZXksIGNvbXB1dGVkLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kWydzdGF0aWMnXSA9IGlzU3RhdGljO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmtpbmQgPT09ICdpbml0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLmtpbmQgPSAnbWV0aG9kJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU3RhdGljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGhvZC5jb21wdXRlZCAmJiAobWV0aG9kLmtleS5uYW1lIHx8IG1ldGhvZC5rZXkudmFsdWUudG9TdHJpbmcoKSkgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmtpbmQgIT09ICdtZXRob2QnIHx8ICFtZXRob2QubWV0aG9kIHx8IG1ldGhvZC52YWx1ZS5nZW5lcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIE1lc3NhZ2VzLkNvbnN0cnVjdG9yU3BlY2lhbE1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgTWVzc2FnZXMuRHVwbGljYXRlQ29uc3RydWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NvbnN0cnVjdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLmtpbmQgPSAnY29uc3RydWN0b3InO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXRob2QuY29tcHV0ZWQgJiYgKG1ldGhvZC5rZXkubmFtZSB8fCBtZXRob2Qua2V5LnZhbHVlLnRvU3RyaW5nKCkpID09PSAncHJvdG90eXBlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5TdGF0aWNQcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZC50eXBlID0gU3ludGF4Lk1ldGhvZERlZmluaXRpb247XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtZXRob2QubWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWV0aG9kLnNob3J0aGFuZDtcbiAgICAgICAgICAgICAgICAgICAgYm9keS5wdXNoKG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV4KCk7XG4gICAgICAgIHJldHVybiBjbGFzc0JvZHkuZmluaXNoQ2xhc3NCb2R5KGJvZHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ2xhc3NEZWNsYXJhdGlvbihpZGVudGlmaWVySXNPcHRpb25hbCkge1xuICAgICAgICB2YXIgaWQgPSBudWxsLCBzdXBlckNsYXNzID0gbnVsbCwgY2xhc3NOb2RlID0gbmV3IE5vZGUoKSwgY2xhc3NCb2R5LCBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdjbGFzcycpO1xuXG4gICAgICAgIGlmICghaWRlbnRpZmllcklzT3B0aW9uYWwgfHwgbG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2V4dGVuZHMnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBzdXBlckNsYXNzID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwpO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzQm9keSA9IHBhcnNlQ2xhc3NCb2R5KCk7XG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjbGFzc05vZGUuZmluaXNoQ2xhc3NEZWNsYXJhdGlvbihpZCwgc3VwZXJDbGFzcywgY2xhc3NCb2R5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNsYXNzRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGlkID0gbnVsbCwgc3VwZXJDbGFzcyA9IG51bGwsIGNsYXNzTm9kZSA9IG5ldyBOb2RlKCksIGNsYXNzQm9keSwgcHJldmlvdXNTdHJpY3QgPSBzdHJpY3Q7XG4gICAgICAgIHN0cmljdCA9IHRydWU7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnY2xhc3MnKTtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2V4dGVuZHMnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBzdXBlckNsYXNzID0gaXNvbGF0ZUNvdmVyR3JhbW1hcihwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwpO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzQm9keSA9IHBhcnNlQ2xhc3NCb2R5KCk7XG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjbGFzc05vZGUuZmluaXNoQ2xhc3NFeHByZXNzaW9uKGlkLCBzdXBlckNsYXNzLCBjbGFzc0JvZHkpO1xuICAgIH1cblxuICAgIC8vIE1vZHVsZXMgZ3JhbW1hciBmcm9tOlxuICAgIC8vIHBlb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbFxuXG4gICAgZnVuY3Rpb24gcGFyc2VNb2R1bGVTcGVjaWZpZXIoKSB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSW52YWxpZE1vZHVsZVNwZWNpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoTGl0ZXJhbChsZXgoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHBvcnRTcGVjaWZpZXIoKSB7XG4gICAgICAgIHZhciBleHBvcnRlZCwgbG9jYWwsIG5vZGUgPSBuZXcgTm9kZSgpLCBkZWY7XG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xuICAgICAgICAgICAgLy8gZXhwb3J0IHtkZWZhdWx0fSBmcm9tICdzb21ldGhpbmcnO1xuICAgICAgICAgICAgZGVmID0gbmV3IE5vZGUoKTtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgbG9jYWwgPSBkZWYuZmluaXNoSWRlbnRpZmllcignZGVmYXVsdCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9jYWwgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGV4cG9ydGVkID0gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwb3J0U3BlY2lmaWVyKGxvY2FsLCBleHBvcnRlZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHBvcnROYW1lZERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gbnVsbCxcbiAgICAgICAgICAgIGlzRXhwb3J0RnJvbUlkZW50aWZpZXIsXG4gICAgICAgICAgICBzcmMgPSBudWxsLCBzcGVjaWZpZXJzID0gW107XG5cbiAgICAgICAgLy8gbm9uLWRlZmF1bHQgZXhwb3J0XG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgICAgLy8gY292ZXJzOlxuICAgICAgICAgICAgLy8gZXhwb3J0IHZhciBmID0gMTtcbiAgICAgICAgICAgIHN3aXRjaCAobG9va2FoZWFkLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb25zdCc6XG4gICAgICAgICAgICAgICAgY2FzZSAndmFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwb3J0TmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwgc3BlY2lmaWVycywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJ3snKTtcbiAgICAgICAgaWYgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaXNFeHBvcnRGcm9tSWRlbnRpZmllciA9IGlzRXhwb3J0RnJvbUlkZW50aWZpZXIgfHwgbWF0Y2hLZXl3b3JkKCdkZWZhdWx0Jyk7XG4gICAgICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHBhcnNlRXhwb3J0U3BlY2lmaWVyKCkpO1xuICAgICAgICAgICAgfSB3aGlsZSAobWF0Y2goJywnKSAmJiBsZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwZWN0KCd9Jyk7XG5cbiAgICAgICAgaWYgKG1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xuICAgICAgICAgICAgLy8gY292ZXJpbmc6XG4gICAgICAgICAgICAvLyBleHBvcnQge2RlZmF1bHR9IGZyb20gJ2Zvbyc7XG4gICAgICAgICAgICAvLyBleHBvcnQge2Zvb30gZnJvbSAnZm9vJztcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgc3JjID0gcGFyc2VNb2R1bGVTcGVjaWZpZXIoKTtcbiAgICAgICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0V4cG9ydEZyb21JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAvLyBjb3ZlcmluZzpcbiAgICAgICAgICAgIC8vIGV4cG9ydCB7ZGVmYXVsdH07IC8vIG1pc3NpbmcgZnJvbUNsYXVzZVxuICAgICAgICAgICAgdGhyb3dFcnJvcihsb29rYWhlYWQudmFsdWUgP1xuICAgICAgICAgICAgICAgICAgICBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4gOiBNZXNzYWdlcy5NaXNzaW5nRnJvbUNsYXVzZSwgbG9va2FoZWFkLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNvdmVyXG4gICAgICAgICAgICAvLyBleHBvcnQge2Zvb307XG4gICAgICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwb3J0TmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwgc3BlY2lmaWVycywgc3JjKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IG51bGwsXG4gICAgICAgICAgICBleHByZXNzaW9uID0gbnVsbDtcblxuICAgICAgICAvLyBjb3ZlcnM6XG4gICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IC4uLlxuICAgICAgICBleHBlY3RLZXl3b3JkKCdkZWZhdWx0Jyk7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgLy8gY292ZXJzOlxuICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9vICgpIHt9XG4gICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7fVxuICAgICAgICAgICAgZGVjbGFyYXRpb24gPSBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24obmV3IE5vZGUoKSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2NsYXNzJykpIHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uID0gcGFyc2VDbGFzc0RlY2xhcmF0aW9uKHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCBsb29rYWhlYWQudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY292ZXJzOlxuICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCB7fTtcbiAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgW107XG4gICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0ICgxICsgMik7XG4gICAgICAgIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBwYXJzZUFycmF5SW5pdGlhbGlzZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZXhwcmVzc2lvbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBzcmM7XG5cbiAgICAgICAgLy8gY292ZXJzOlxuICAgICAgICAvLyBleHBvcnQgKiBmcm9tICdmb28nO1xuICAgICAgICBleHBlY3QoJyonKTtcbiAgICAgICAgaWYgKCFtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IobG9va2FoZWFkLnZhbHVlID9cbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuIDogTWVzc2FnZXMuTWlzc2luZ0Zyb21DbGF1c2UsIGxvb2thaGVhZC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV4KCk7XG4gICAgICAgIHNyYyA9IHBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHBvcnRBbGxEZWNsYXJhdGlvbihzcmMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKSB7XG4gICAgICAgIHZhciBub2RlID0gbmV3IE5vZGUoKTtcbiAgICAgICAgaWYgKHN0YXRlLmluRnVuY3Rpb25Cb2R5KSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLklsbGVnYWxFeHBvcnREZWNsYXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdleHBvcnQnKTtcblxuICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2goJyonKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRXhwb3J0QWxsRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlRXhwb3J0TmFtZWREZWNsYXJhdGlvbihub2RlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUltcG9ydFNwZWNpZmllcigpIHtcbiAgICAgICAgLy8gaW1wb3J0IHs8Zm9vIGFzIGJhcj59IC4uLjtcbiAgICAgICAgdmFyIGxvY2FsLCBpbXBvcnRlZCwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgaW1wb3J0ZWQgPSBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKTtcbiAgICAgICAgaWYgKG1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgbG9jYWwgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSW1wb3J0U3BlY2lmaWVyKGxvY2FsLCBpbXBvcnRlZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VOYW1lZEltcG9ydHMoKSB7XG4gICAgICAgIHZhciBzcGVjaWZpZXJzID0gW107XG4gICAgICAgIC8vIHtmb28sIGJhciBhcyBiYXN9XG4gICAgICAgIGV4cGVjdCgneycpO1xuICAgICAgICBpZiAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2gocGFyc2VJbXBvcnRTcGVjaWZpZXIoKSk7XG4gICAgICAgICAgICB9IHdoaWxlIChtYXRjaCgnLCcpICYmIGxleCgpKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJ30nKTtcbiAgICAgICAgcmV0dXJuIHNwZWNpZmllcnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJbXBvcnREZWZhdWx0U3BlY2lmaWVyKCkge1xuICAgICAgICAvLyBpbXBvcnQgPGZvbz4gLi4uO1xuICAgICAgICB2YXIgbG9jYWwsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGxvY2FsID0gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSW1wb3J0RGVmYXVsdFNwZWNpZmllcihsb2NhbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoKSB7XG4gICAgICAgIC8vIGltcG9ydCA8KiBhcyBmb28+IC4uLjtcbiAgICAgICAgdmFyIGxvY2FsLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBleHBlY3QoJyonKTtcbiAgICAgICAgaWYgKCFtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLk5vQXNBZnRlckltcG9ydE5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV4KCk7XG4gICAgICAgIGxvY2FsID0gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKGxvY2FsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUltcG9ydERlY2xhcmF0aW9uKCkge1xuICAgICAgICB2YXIgc3BlY2lmaWVycywgc3JjLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBpZiAoc3RhdGUuaW5GdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSWxsZWdhbEltcG9ydERlY2xhcmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2ltcG9ydCcpO1xuICAgICAgICBzcGVjaWZpZXJzID0gW107XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgICAvLyBjb3ZlcnM6XG4gICAgICAgICAgICAvLyBpbXBvcnQgJ2Zvbyc7XG4gICAgICAgICAgICBzcmMgPSBwYXJzZU1vZHVsZVNwZWNpZmllcigpO1xuICAgICAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSW1wb3J0RGVjbGFyYXRpb24oc3BlY2lmaWVycywgc3JjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykgJiYgaXNJZGVudGlmaWVyTmFtZShsb29rYWhlYWQpKSB7XG4gICAgICAgICAgICAvLyBjb3ZlcnM6XG4gICAgICAgICAgICAvLyBpbXBvcnQgZm9vXG4gICAgICAgICAgICAvLyBpbXBvcnQgZm9vLCAuLi5cbiAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaChwYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIoKSk7XG4gICAgICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCgnKicpKSB7XG4gICAgICAgICAgICAvLyBjb3ZlcnM6XG4gICAgICAgICAgICAvLyBpbXBvcnQgZm9vLCAqIGFzIGZvb1xuICAgICAgICAgICAgLy8gaW1wb3J0ICogYXMgZm9vXG4gICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2gocGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJ3snKSkge1xuICAgICAgICAgICAgLy8gY292ZXJzOlxuICAgICAgICAgICAgLy8gaW1wb3J0IGZvbywge2Jhcn1cbiAgICAgICAgICAgIC8vIGltcG9ydCB7YmFyfVxuICAgICAgICAgICAgc3BlY2lmaWVycyA9IHNwZWNpZmllcnMuY29uY2F0KHBhcnNlTmFtZWRJbXBvcnRzKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IobG9va2FoZWFkLnZhbHVlID9cbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuIDogTWVzc2FnZXMuTWlzc2luZ0Zyb21DbGF1c2UsIGxvb2thaGVhZC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV4KCk7XG4gICAgICAgIHNyYyA9IHBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hJbXBvcnREZWNsYXJhdGlvbihzcGVjaWZpZXJzLCBzcmMpO1xuICAgIH1cblxuICAgIC8vIDE0IFByb2dyYW1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU2NyaXB0Qm9keSgpIHtcbiAgICAgICAgdmFyIHN0YXRlbWVudCwgYm9keSA9IFtdLCB0b2tlbiwgZGlyZWN0aXZlLCBmaXJzdFJlc3RyaWN0ZWQ7XG5cbiAgICAgICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGVtZW50ID0gcGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpO1xuICAgICAgICAgICAgYm9keS5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgICAgICBpZiAoc3RhdGVtZW50LmV4cHJlc3Npb24udHlwZSAhPT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBkaXJlY3RpdmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpcmVjdGl2ZSA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCArIDEsIHRva2VuLmVuZCAtIDEpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZSA9PT0gJ3VzZSBzdHJpY3QnKSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGZpcnN0UmVzdHJpY3RlZCwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZmlyc3RSZXN0cmljdGVkICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChzdGFydEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnQgPSBwYXJzZVN0YXRlbWVudExpc3RJdGVtKCk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keS5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQcm9ncmFtKCkge1xuICAgICAgICB2YXIgYm9keSwgbm9kZTtcblxuICAgICAgICBwZWVrKCk7XG4gICAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGJvZHkgPSBwYXJzZVNjcmlwdEJvZHkoKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvZ3JhbShib2R5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJUb2tlbkxvY2F0aW9uKCkge1xuICAgICAgICB2YXIgaSwgZW50cnksIHRva2VuLCB0b2tlbnMgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXh0cmEudG9rZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBlbnRyeSA9IGV4dHJhLnRva2Vuc1tpXTtcbiAgICAgICAgICAgIHRva2VuID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGVudHJ5LnR5cGUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGVudHJ5LnZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGVudHJ5LnJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgdG9rZW4ucmVnZXggPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGVudHJ5LnJlZ2V4LnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzOiBlbnRyeS5yZWdleC5mbGFnc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi5yYW5nZSA9IGVudHJ5LnJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgICAgICAgIHRva2VuLmxvYyA9IGVudHJ5LmxvYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4dHJhLnRva2VucyA9IHRva2VucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2tlbml6ZShjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0b1N0cmluZyxcbiAgICAgICAgICAgIHRva2VucztcblxuICAgICAgICB0b1N0cmluZyA9IFN0cmluZztcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnc3RyaW5nJyAmJiAhKGNvZGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICAgICAgICBjb2RlID0gdG9TdHJpbmcoY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzb3VyY2UgPSBjb2RlO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGxpbmVOdW1iZXIgPSAoc291cmNlLmxlbmd0aCA+IDApID8gMSA6IDA7XG4gICAgICAgIGxpbmVTdGFydCA9IDA7XG4gICAgICAgIHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgc3RhcnRMaW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIGxvb2thaGVhZCA9IG51bGw7XG4gICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsU2V0OiB7fSxcbiAgICAgICAgICAgIGluRnVuY3Rpb25Cb2R5OiBmYWxzZSxcbiAgICAgICAgICAgIGluSXRlcmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIGluU3dpdGNoOiBmYWxzZSxcbiAgICAgICAgICAgIGxhc3RDb21tZW50U3RhcnQ6IC0xLFxuICAgICAgICAgICAgY3VybHlTdGFjazogW11cbiAgICAgICAgfTtcblxuICAgICAgICBleHRyYSA9IHt9O1xuXG4gICAgICAgIC8vIE9wdGlvbnMgbWF0Y2hpbmcuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8vIE9mIGNvdXJzZSB3ZSBjb2xsZWN0IHRva2VucyBoZXJlLlxuICAgICAgICBvcHRpb25zLnRva2VucyA9IHRydWU7XG4gICAgICAgIGV4dHJhLnRva2VucyA9IFtdO1xuICAgICAgICBleHRyYS50b2tlbml6ZSA9IHRydWU7XG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgdHdvIGZpZWxkcyBhcmUgbmVjZXNzYXJ5IHRvIGNvbXB1dGUgdGhlIFJlZ2V4IHRva2Vucy5cbiAgICAgICAgZXh0cmEub3BlblBhcmVuVG9rZW4gPSAtMTtcbiAgICAgICAgZXh0cmEub3BlbkN1cmx5VG9rZW4gPSAtMTtcblxuICAgICAgICBleHRyYS5yYW5nZSA9ICh0eXBlb2Ygb3B0aW9ucy5yYW5nZSA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnJhbmdlO1xuICAgICAgICBleHRyYS5sb2MgPSAodHlwZW9mIG9wdGlvbnMubG9jID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMubG9jO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5jb21tZW50KSB7XG4gICAgICAgICAgICBleHRyYS5jb21tZW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcbiAgICAgICAgICAgIGV4dHJhLmVycm9ycyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBlZWsoKTtcbiAgICAgICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dHJhLnRva2VucztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICB3aGlsZSAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGxleEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZEVycm9yKGxleEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gYnJlYWsgb24gdGhlIGZpcnN0IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBpbmZpbml0ZSBsb29wcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbGV4RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpbHRlclRva2VuTG9jYXRpb24oKTtcbiAgICAgICAgICAgIHRva2VucyA9IGV4dHJhLnRva2VucztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEuY29tbWVudHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLmNvbW1lbnRzID0gZXh0cmEuY29tbWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmVycm9ycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMuZXJyb3JzID0gZXh0cmEuZXJyb3JzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHByb2dyYW0sIHRvU3RyaW5nO1xuXG4gICAgICAgIHRvU3RyaW5nID0gU3RyaW5nO1xuICAgICAgICBpZiAodHlwZW9mIGNvZGUgIT09ICdzdHJpbmcnICYmICEoY29kZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICAgICAgICAgIGNvZGUgPSB0b1N0cmluZyhjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNvdXJjZSA9IGNvZGU7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgbGluZU51bWJlciA9IChzb3VyY2UubGVuZ3RoID4gMCkgPyAxIDogMDtcbiAgICAgICAgbGluZVN0YXJ0ID0gMDtcbiAgICAgICAgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICBzdGFydExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICBzdGFydExpbmVTdGFydCA9IGxpbmVTdGFydDtcbiAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgbG9va2FoZWFkID0gbnVsbDtcbiAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgbGFiZWxTZXQ6IHt9LFxuICAgICAgICAgICAgaW5GdW5jdGlvbkJvZHk6IGZhbHNlLFxuICAgICAgICAgICAgaW5JdGVyYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgaW5Td2l0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgbGFzdENvbW1lbnRTdGFydDogLTEsXG4gICAgICAgICAgICBjdXJseVN0YWNrOiBbXVxuICAgICAgICB9O1xuICAgICAgICBzb3VyY2VUeXBlID0gJ3NjcmlwdCc7XG4gICAgICAgIHN0cmljdCA9IGZhbHNlO1xuXG4gICAgICAgIGV4dHJhID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGV4dHJhLnJhbmdlID0gKHR5cGVvZiBvcHRpb25zLnJhbmdlID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMucmFuZ2U7XG4gICAgICAgICAgICBleHRyYS5sb2MgPSAodHlwZW9mIG9wdGlvbnMubG9jID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMubG9jO1xuICAgICAgICAgICAgZXh0cmEuYXR0YWNoQ29tbWVudCA9ICh0eXBlb2Ygb3B0aW9ucy5hdHRhY2hDb21tZW50ID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMuYXR0YWNoQ29tbWVudDtcblxuICAgICAgICAgICAgaWYgKGV4dHJhLmxvYyAmJiBvcHRpb25zLnNvdXJjZSAhPT0gbnVsbCAmJiBvcHRpb25zLnNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXh0cmEuc291cmNlID0gdG9TdHJpbmcob3B0aW9ucy5zb3VyY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9rZW5zID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy50b2tlbnMpIHtcbiAgICAgICAgICAgICAgICBleHRyYS50b2tlbnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgZXh0cmEuY29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5lcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5hdHRhY2hDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgZXh0cmEucmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGV4dHJhLmNvbW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgZXh0cmEuYm90dG9tUmlnaHRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICAgIGV4dHJhLnRyYWlsaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBleHRyYS5sZWFkaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNvdXJjZVR5cGUgPT09ICdtb2R1bGUnKSB7XG4gICAgICAgICAgICAgICAgLy8gdmVyeSByZXN0cmljdGl2ZSBjb25kaXRpb24gZm9yIG5vd1xuICAgICAgICAgICAgICAgIHNvdXJjZVR5cGUgPSBvcHRpb25zLnNvdXJjZVR5cGU7XG4gICAgICAgICAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9ncmFtID0gcGFyc2VQcm9ncmFtKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmNvbW1lbnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHByb2dyYW0uY29tbWVudHMgPSBleHRyYS5jb21tZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGZpbHRlclRva2VuTG9jYXRpb24oKTtcbiAgICAgICAgICAgICAgICBwcm9ncmFtLnRva2VucyA9IGV4dHJhLnRva2VucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEuZXJyb3JzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHByb2dyYW0uZXJyb3JzID0gZXh0cmEuZXJyb3JzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cblxuICAgIC8vIFN5bmMgd2l0aCAqLmpzb24gbWFuaWZlc3RzLlxuICAgIGV4cG9ydHMudmVyc2lvbiA9ICcyLjIuMCc7XG5cbiAgICBleHBvcnRzLnRva2VuaXplID0gdG9rZW5pemU7XG5cbiAgICBleHBvcnRzLnBhcnNlID0gcGFyc2U7XG5cbiAgICAvLyBEZWVwIGNvcHkuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBleHBvcnRzLlN5bnRheCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuYW1lLCB0eXBlcyA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdHlwZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChuYW1lIGluIFN5bnRheCkge1xuICAgICAgICAgICAgaWYgKFN5bnRheC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIHR5cGVzW25hbWVdID0gU3ludGF4W25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZnJlZXplID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHR5cGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICB9KCkpO1xuXG59KSk7XG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIiwiLypcclxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxyXG4qXHJcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxyXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cclxuKi9cclxuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xyXG4gICAgfVxyXG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzZWxmID0ge307XHJcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XHJcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XHJcblxyXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gV2UgY2FuJ3QgYnVpbGQgYSByZWFsIG1ldGhvZCB3aXRob3V0IGEgY29uc29sZSB0byBsb2cgdG9cclxuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub29wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xyXG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgc2VsZlttZXRob2ROYW1lXS5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcclxuICAgICAgICBcInRyYWNlXCIsXHJcbiAgICAgICAgXCJkZWJ1Z1wiLFxyXG4gICAgICAgIFwiaW5mb1wiLFxyXG4gICAgICAgIFwid2FyblwiLFxyXG4gICAgICAgIFwiZXJyb3JcIlxyXG4gICAgXTtcclxuXHJcbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xyXG4gICAgICAgICAgICBzZWxmW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgPyBub29wIDogc2VsZi5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xyXG4gICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XHJcblxyXG4gICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVsnbG9nbGV2ZWwnXSA9IGxldmVsTmFtZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cclxuXHJcbiAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9IFwibG9nbGV2ZWw9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcclxuICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbG9hZFBlcnNpc3RlZExldmVsKCkge1xyXG4gICAgICAgIHZhciBzdG9yZWRMZXZlbDtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlWydsb2dsZXZlbCddO1xyXG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvbG9nbGV2ZWw9KFteO10rKS8uZXhlYyh3aW5kb3cuZG9jdW1lbnQuY29va2llKVsxXTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSBcIldBUk5cIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgICpcclxuICAgICAqIFB1YmxpYyBBUElcclxuICAgICAqXHJcbiAgICAgKi9cclxuXHJcbiAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcclxuICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xyXG5cclxuICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBsZXZlbCkge1xyXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XHJcbiAgICAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcclxuICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XHJcbiAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5UKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXHJcbiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XHJcbiAgICBzZWxmLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxyXG4gICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBzZWxmKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9O1xyXG5cclxuICAgIGxvYWRQZXJzaXN0ZWRMZXZlbCgpO1xyXG4gICAgcmV0dXJuIHNlbGY7XHJcbn0pKTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2hpdGVMaXN0ID0gWydub3QnLCAnYW55JywgJ2FsbCcsICdub25lJ107XG5cblxuZnVuY3Rpb24gbm90TnVsbCh4KSAgeyByZXR1cm4geCAhPSBudWxsOyB9XG5mdW5jdGlvbiB0b1N0cmluZyh4KSB7IHJldHVybiB4LnRvU3RyaW5nKCk7IH1cbmZ1bmN0aW9uIHdyYXAoeCkgICAgIHsgcmV0dXJuICcoJyArIHggKyAnKSc7fVxuXG5mdW5jdGlvbiBtYXliZVF1b3RlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuICdcIicgKyB2YWx1ZSArICdcIic7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gbG9va1VwKGtleSkge1xuICAgIGlmIChrZXkubGFzdEluZGV4T2YoJyQnKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJ2NvbnRleHQuJyArIGtleS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIHJldHVybiAnY29udGV4dC5mZWF0dXJlLnByb3BlcnRpZXMuJyArIGtleTtcbn1cblxuZnVuY3Rpb24gbnVsbFZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnbnVsbFZhbHVlJyxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyB0cnVlICc7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUVxdWFsKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAncHJvcGVydHlFcXVhbCcsXG4gICAgICAgIG9wdDogJz09PScgLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAobWF5YmVRdW90ZSh0aGlzLnZhbHVlKSArICcgJyArIHRoaXMub3B0ICsgJyAnICsgbG9va1VwKGtleSkpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlPcihrZXksIHZhbHVlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdwcm9wZXJ0eU9yJyxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlczogdmFsdWVzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gcHJvcGVydHlFcXVhbChrZXksIHgpOyB9KSxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwKHRoaXMudmFsdWVzLm1hcCh0b1N0cmluZykuam9pbignIHx8ICcpKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIG5vdChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ25vdFByb3BlcnR5JyxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiBwYXJzZUZpbHRlcih2YWx1ZSksXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyEnICsgd3JhcCh0aGlzLnZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gbm9uZShrZXksIHZhbHVlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdub25lJyxcbiAgICAgICAgdmFsdWVzOiBhbnkobnVsbCwgdmFsdWVzKSxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnIScgKyB3cmFwKHRoaXMudmFsdWVzLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcHJpbnROZXN0ZWQodmFsdWVzLCBqb2luZXIpIHtcbiAgICByZXR1cm4gd3JhcCh2YWx1ZXMuZmlsdGVyKG5vdE51bGwpLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gd3JhcCh4LmpvaW4oJyAmJiAnKSk7XG4gICAgfSkuam9pbignICcgKyBqb2luZXIgKyAnICcpKTtcbn1cblxuZnVuY3Rpb24gYW55KF8sIHZhbHVlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdhbnknLFxuICAgICAgICB2YWx1ZXM6IHZhbHVlcy5tYXAocGFyc2VGaWx0ZXIpLFxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByaW50TmVzdGVkKHRoaXMudmFsdWVzLCAnfHwnKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGFsbChfLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnYWxsJyxcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMuZmlsdGVyKG5vdE51bGwpLm1hcChwYXJzZUZpbHRlciksXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpbnROZXN0ZWQodGhpcy52YWx1ZXMsICcmJicpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlNYXRjaGVzQm9vbGVhbihrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3Byb3BlcnR5TWF0Y2hlc0Jvb2xlYW4nLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAobG9va1VwKHRoaXMua2V5KSArICh0aGlzLnZhbHVlID8gJyAhPSAnIDogJyA9PSAnKSAgKyAnbnVsbCcpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcmFuZ2VNYXRjaChrZXksIHZhbHVlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdyYW5nZU1hdGNoJyxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlcy5tYXgpIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKCcnICsgbG9va1VwKGtleSkgKyAnIDwgJyArIHRoaXMudmFsdWVzLm1heCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlcy5taW4pIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKCcnICsgbG9va1VwKGtleSkgKyAnID49ICcgKyB0aGlzLnZhbHVlcy5taW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gd3JhcChleHByZXNzaW9ucy5qb2luKCcgJiYgJykpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXIoZmlsdGVyKSB7XG4gICAgdmFyIGZpbHRlckFTVCA9IFtdO1xuXG4gICAgLy8gRnVuY3Rpb24gZmlsdGVyXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZmlsdGVyQVNULnB1c2god3JhcChmaWx0ZXIudG9TdHJpbmcoKSArICcoY29udGV4dCknKSk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJBU1Q7XG4gICAgfVxuXG4gICAgLy8gT2JqZWN0IGZpbHRlclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZmlsdGVyKTtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaWR4KSB7XG5cbiAgICAgICAgdmFyIHZhbHVlID0gZmlsdGVyW2tleV0sXG4gICAgICAgICAgICB0eXBlICA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChwcm9wZXJ0eUVxdWFsKGtleSwgdmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGZpbHRlckFTVC5wdXNoKHByb3BlcnR5TWF0Y2hlc0Jvb2xlYW4oa2V5LCB2YWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGZpbHRlckFTVC5wdXNoKG51bGxWYWx1ZShrZXksIHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2hpdGVMaXN0LmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnbm90JzpcbiAgICAgICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChub3Qoa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYW55JzpcbiAgICAgICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChhbnkoa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYWxsJzpcbiAgICAgICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChhbGwoa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICAgICAgZmlsdGVyQVNULnB1c2gobm9uZShrZXksIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5oYW5kbGVkIFdoaXRlTGlzdGVkIHByb3BlcnR5OiAnICsga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZmlsdGVyQVNULnB1c2gocHJvcGVydHlPcihrZXksIHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLm1heCB8fCB2YWx1ZS5taW4pIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChyYW5nZU1hdGNoKGtleSwgdmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBRdWVyeSBzeXRuYXg6ICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBrZXlzLmxlbmd0aCA9PT0gMCA/IFsndHJ1ZSddIDogZmlsdGVyQVNUO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJUb1N0cmluZyhmaWx0ZXJBU1QpIHtcbiAgICByZXR1cm4gd3JhcChmaWx0ZXJBU1Quam9pbignICYmICcpKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2goZmlsdGVyKSB7XG4gICAgaWYgKGZpbHRlciA9PSBudWxsKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9OyB9XG4gICAgLy8ganNoaW50IGV2aWw6IHRydWVcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdjb250ZXh0JywgJ3JldHVybiAnICsgZmlsdGVyVG9TdHJpbmcocGFyc2VGaWx0ZXIoZmlsdGVyKSkgKyAnOycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtYXRjaDogbWF0Y2gsXG4gICAgZmlsdGVyVG9TdHJpbmc6IGZpbHRlclRvU3RyaW5nLFxuICAgIHBhcnNlRmlsdGVyOiBwYXJzZUZpbHRlclxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gbGlnaHR3ZWlnaHQgQnVmZmVyIHNoaW0gZm9yIHBiZiBicm93c2VyIGJ1aWxkXG4vLyBiYXNlZCBvbiBjb2RlIGZyb20gZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyIChNSVQtbGljZW5zZWQpXG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyO1xuXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKTtcblxudmFyIEJ1ZmZlck1ldGhvZHM7XG5cbmZ1bmN0aW9uIEJ1ZmZlcihsZW5ndGgpIHtcbiAgICB2YXIgYXJyO1xuICAgIGlmIChsZW5ndGggJiYgbGVuZ3RoLmxlbmd0aCkge1xuICAgICAgICBhcnIgPSBsZW5ndGg7XG4gICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgfVxuICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGggfHwgMCk7XG4gICAgaWYgKGFycikgYnVmLnNldChhcnIpO1xuXG4gICAgYnVmLnJlYWRVSW50MzJMRSA9IEJ1ZmZlck1ldGhvZHMucmVhZFVJbnQzMkxFO1xuICAgIGJ1Zi53cml0ZVVJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy53cml0ZVVJbnQzMkxFO1xuICAgIGJ1Zi5yZWFkSW50MzJMRSA9IEJ1ZmZlck1ldGhvZHMucmVhZEludDMyTEU7XG4gICAgYnVmLndyaXRlSW50MzJMRSA9IEJ1ZmZlck1ldGhvZHMud3JpdGVJbnQzMkxFO1xuICAgIGJ1Zi5yZWFkRmxvYXRMRSA9IEJ1ZmZlck1ldGhvZHMucmVhZEZsb2F0TEU7XG4gICAgYnVmLndyaXRlRmxvYXRMRSA9IEJ1ZmZlck1ldGhvZHMud3JpdGVGbG9hdExFO1xuICAgIGJ1Zi5yZWFkRG91YmxlTEUgPSBCdWZmZXJNZXRob2RzLnJlYWREb3VibGVMRTtcbiAgICBidWYud3JpdGVEb3VibGVMRSA9IEJ1ZmZlck1ldGhvZHMud3JpdGVEb3VibGVMRTtcbiAgICBidWYudG9TdHJpbmcgPSBCdWZmZXJNZXRob2RzLnRvU3RyaW5nO1xuICAgIGJ1Zi53cml0ZSA9IEJ1ZmZlck1ldGhvZHMud3JpdGU7XG4gICAgYnVmLnNsaWNlID0gQnVmZmVyTWV0aG9kcy5zbGljZTtcbiAgICBidWYuY29weSA9IEJ1ZmZlck1ldGhvZHMuY29weTtcblxuICAgIGJ1Zi5faXNCdWZmZXIgPSB0cnVlO1xuICAgIHJldHVybiBidWY7XG59XG5cbnZhciBsYXN0U3RyLCBsYXN0U3RyRW5jb2RlZDtcblxuQnVmZmVyTWV0aG9kcyA9IHtcbiAgICByZWFkVUludDMyTEU6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICByZXR1cm4gKCh0aGlzW3Bvc10pIHxcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDFdIDw8IDgpIHxcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDJdIDw8IDE2KSkgK1xuICAgICAgICAgICAgKHRoaXNbcG9zICsgM10gKiAweDEwMDAwMDApO1xuICAgIH0sXG5cbiAgICB3cml0ZVVJbnQzMkxFOiBmdW5jdGlvbih2YWwsIHBvcykge1xuICAgICAgICB0aGlzW3Bvc10gPSB2YWw7XG4gICAgICAgIHRoaXNbcG9zICsgMV0gPSAodmFsID4+PiA4KTtcbiAgICAgICAgdGhpc1twb3MgKyAyXSA9ICh2YWwgPj4+IDE2KTtcbiAgICAgICAgdGhpc1twb3MgKyAzXSA9ICh2YWwgPj4+IDI0KTtcbiAgICB9LFxuXG4gICAgcmVhZEludDMyTEU6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICByZXR1cm4gKCh0aGlzW3Bvc10pIHxcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDFdIDw8IDgpIHxcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDJdIDw8IDE2KSkgK1xuICAgICAgICAgICAgKHRoaXNbcG9zICsgM10gPDwgMjQpO1xuICAgIH0sXG5cbiAgICByZWFkRmxvYXRMRTogIGZ1bmN0aW9uKHBvcykgeyByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIHBvcywgdHJ1ZSwgMjMsIDQpOyB9LFxuICAgIHJlYWREb3VibGVMRTogZnVuY3Rpb24ocG9zKSB7IHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgcG9zLCB0cnVlLCA1MiwgOCk7IH0sXG5cbiAgICB3cml0ZUZsb2F0TEU6ICBmdW5jdGlvbih2YWwsIHBvcykgeyByZXR1cm4gaWVlZTc1NC53cml0ZSh0aGlzLCB2YWwsIHBvcywgdHJ1ZSwgMjMsIDQpOyB9LFxuICAgIHdyaXRlRG91YmxlTEU6IGZ1bmN0aW9uKHZhbCwgcG9zKSB7IHJldHVybiBpZWVlNzU0LndyaXRlKHRoaXMsIHZhbCwgcG9zLCB0cnVlLCA1MiwgOCk7IH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnLFxuICAgICAgICAgICAgdG1wID0gJyc7XG5cbiAgICAgICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbih0aGlzLmxlbmd0aCwgZW5kIHx8IHRoaXMubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChjaCA8PSAweDdGKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IGRlY29kZVVSSUNvbXBvbmVudCh0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgICAgICAgdG1wID0gJyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRtcCArPSAnJScgKyBjaC50b1N0cmluZygxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgKz0gZGVjb2RlVVJJQ29tcG9uZW50KHRtcCk7XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG4gICAgd3JpdGU6IGZ1bmN0aW9uKHN0ciwgcG9zKSB7XG4gICAgICAgIHZhciBieXRlcyA9IHN0ciA9PT0gbGFzdFN0ciA/IGxhc3RTdHJFbmNvZGVkIDogZW5jb2RlU3RyaW5nKHN0cik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXNbcG9zICsgaV0gPSBieXRlc1tpXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzbGljZTogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKTtcbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24oYnVmLCBwb3MpIHtcbiAgICAgICAgcG9zID0gcG9zIHx8IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYnVmW3BvcyArIGldID0gdGhpc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkJ1ZmZlck1ldGhvZHMud3JpdGVJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy53cml0ZVVJbnQzMkxFO1xuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGxhc3RTdHIgPSBzdHI7XG4gICAgbGFzdFN0ckVuY29kZWQgPSBlbmNvZGVTdHJpbmcoc3RyKTtcbiAgICByZXR1cm4gbGFzdFN0ckVuY29kZWQubGVuZ3RoO1xufTtcblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24oYnVmKSB7XG4gICAgcmV0dXJuICEhKGJ1ZiAmJiBidWYuX2lzQnVmZmVyKTtcbn07XG5cbmZ1bmN0aW9uIGVuY29kZVN0cmluZyhzdHIpIHtcbiAgICB2YXIgbGVuZ3RoID0gc3RyLmxlbmd0aCxcbiAgICAgICAgYnl0ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBjLCBsZWFkOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpOyAvLyBjb2RlIHBvaW50XG5cbiAgICAgICAgaWYgKGMgPiAweEQ3RkYgJiYgYyA8IDB4RTAwMCkge1xuXG4gICAgICAgICAgICBpZiAobGVhZCkge1xuICAgICAgICAgICAgICAgIGlmIChjIDwgMHhEQzAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPSBjO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBsZWFkIC0gMHhEODAwIDw8IDEwIHwgYyAtIDB4REMwMCB8IDB4MTAwMDA7XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA+IDB4REJGRiB8fCAoaSArIDEgPT09IGxlbmd0aCkpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgICAgICAgZWxzZSBsZWFkID0gYztcblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAobGVhZCkge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICAgIGxlYWQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweDgwKSBieXRlcy5wdXNoKGMpO1xuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIGJ5dGVzLnB1c2goYyA+PiAweDYgfCAweEMwLCBjICYgMHgzRiB8IDB4ODApO1xuICAgICAgICBlbHNlIGlmIChjIDwgMHgxMDAwMCkgYnl0ZXMucHVzaChjID4+IDB4QyB8IDB4RTAsIGMgPj4gMHg2ICYgMHgzRiB8IDB4ODAsIGMgJiAweDNGIHwgMHg4MCk7XG4gICAgICAgIGVsc2UgYnl0ZXMucHVzaChjID4+IDB4MTIgfCAweEYwLCBjID4+IDB4QyAmIDB4M0YgfCAweDgwLCBjID4+IDB4NiAmIDB4M0YgfCAweDgwLCBjICYgMHgzRiB8IDB4ODApO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGJmO1xuXG52YXIgQnVmZmVyID0gZ2xvYmFsLkJ1ZmZlciB8fCByZXF1aXJlKCcuL2J1ZmZlcicpO1xuXG5mdW5jdGlvbiBQYmYoYnVmKSB7XG4gICAgdGhpcy5idWYgPSAhQnVmZmVyLmlzQnVmZmVyKGJ1ZikgPyBuZXcgQnVmZmVyKGJ1ZiB8fCAwKSA6IGJ1ZjtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLmJ1Zi5sZW5ndGg7XG59XG5cblBiZi5WYXJpbnQgID0gMDsgLy8gdmFyaW50OiBpbnQzMiwgaW50NjQsIHVpbnQzMiwgdWludDY0LCBzaW50MzIsIHNpbnQ2NCwgYm9vbCwgZW51bVxuUGJmLkZpeGVkNjQgPSAxOyAvLyA2NC1iaXQ6IGRvdWJsZSwgZml4ZWQ2NCwgc2ZpeGVkNjRcblBiZi5CeXRlcyAgID0gMjsgLy8gbGVuZ3RoLWRlbGltaXRlZDogc3RyaW5nLCBieXRlcywgZW1iZWRkZWQgbWVzc2FnZXMsIHBhY2tlZCByZXBlYXRlZCBmaWVsZHNcblBiZi5GaXhlZDMyID0gNTsgLy8gMzItYml0OiBmbG9hdCwgZml4ZWQzMiwgc2ZpeGVkMzJcblxudmFyIFNISUZUX0xFRlRfMzIgPSAoMSA8PCAxNikgKiAoMSA8PCAxNiksXG4gICAgU0hJRlRfUklHSFRfMzIgPSAxIC8gU0hJRlRfTEVGVF8zMixcbiAgICBQT1dfMl82MyA9IE1hdGgucG93KDIsIDYzKTtcblxuUGJmLnByb3RvdHlwZSA9IHtcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJ1ZiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8vID09PSBSRUFESU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICByZWFkRmllbGRzOiBmdW5jdGlvbihyZWFkRmllbGQsIHJlc3VsdCwgZW5kKSB7XG4gICAgICAgIGVuZCA9IGVuZCB8fCB0aGlzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLnJlYWRWYXJpbnQoKSxcbiAgICAgICAgICAgICAgICB0YWcgPSB2YWwgPj4gMyxcbiAgICAgICAgICAgICAgICBzdGFydFBvcyA9IHRoaXMucG9zO1xuXG4gICAgICAgICAgICByZWFkRmllbGQodGFnLCByZXN1bHQsIHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0UG9zKSB0aGlzLnNraXAodmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICByZWFkTWVzc2FnZTogZnVuY3Rpb24ocmVhZEZpZWxkLCByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZpZWxkcyhyZWFkRmllbGQsIHJlc3VsdCwgdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcyk7XG4gICAgfSxcblxuICAgIHJlYWRGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRTRml4ZWQzMjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkSW50MzJMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIC8vIDY0LWJpdCBpbnQgaGFuZGxpbmcgaXMgYmFzZWQgb24gZ2l0aHViLmNvbS9kcHcvbm9kZS1idWZmZXItbW9yZS1pbnRzIChNSVQtbGljZW5zZWQpXG5cbiAgICByZWFkRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MpICsgdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zICsgNCkgKiBTSElGVF9MRUZUXzMyO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkU0ZpeGVkNjQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zKSArIHRoaXMuYnVmLnJlYWRJbnQzMkxFKHRoaXMucG9zICsgNCkgKiBTSElGVF9MRUZUXzMyO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkRmxvYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZEZsb2F0TEUodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkRG91YmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWREb3VibGVMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYnVmID0gdGhpcy5idWYsXG4gICAgICAgICAgICB2YWwsIGIsIGIwLCBiMSwgYjIsIGIzO1xuXG4gICAgICAgIGIwID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjAgPCAweDgwKSByZXR1cm4gYjA7ICAgICAgICAgICAgICAgICBiMCA9IGIwICYgMHg3ZjtcbiAgICAgICAgYjEgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMSA8IDB4ODApIHJldHVybiBiMCB8IGIxIDw8IDc7ICAgICAgIGIxID0gKGIxICYgMHg3ZikgPDwgNztcbiAgICAgICAgYjIgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMiA8IDB4ODApIHJldHVybiBiMCB8IGIxIHwgYjIgPDwgMTQ7IGIyID0gKGIyICYgMHg3ZikgPDwgMTQ7XG4gICAgICAgIGIzID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjMgPCAweDgwKSByZXR1cm4gYjAgfCBiMSB8IGIyIHwgYjMgPDwgMjE7XG5cbiAgICAgICAgdmFsID0gYjAgfCBiMSB8IGIyIHwgKGIzICYgMHg3ZikgPDwgMjE7XG5cbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDEwMDAwMDAwOyAgICAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDgwMDAwMDAwMDsgICAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDQwMDAwMDAwMDAwOyAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDIwMDAwMDAwMDAwMDA7ICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDEwMDAwMDAwMDAwMDAwMDsgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDgwMDAwMDAwMDAwMDAwMDA7IGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHZhcmludCBub3QgbW9yZSB0aGFuIDEwIGJ5dGVzJyk7XG4gICAgfSxcblxuICAgIHJlYWRWYXJpbnQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zLFxuICAgICAgICAgICAgdmFsID0gdGhpcy5yZWFkVmFyaW50KCk7XG5cbiAgICAgICAgaWYgKHZhbCA8IFBPV18yXzYzKSByZXR1cm4gdmFsO1xuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcyAtIDI7XG4gICAgICAgIHdoaWxlICh0aGlzLmJ1Zltwb3NdID09PSAweGZmKSBwb3MtLTtcbiAgICAgICAgaWYgKHBvcyA8IHN0YXJ0UG9zKSBwb3MgPSBzdGFydFBvcztcblxuICAgICAgICB2YWwgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvcyAtIHN0YXJ0UG9zICsgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYiA9IH50aGlzLmJ1ZltzdGFydFBvcyArIGldICYgMHg3ZjtcbiAgICAgICAgICAgIHZhbCArPSBpIDwgNCA/IGIgPDwgaSAqIDcgOiBiICogTWF0aC5wb3coMiwgaSAqIDcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC12YWwgLSAxO1xuICAgIH0sXG5cbiAgICByZWFkU1ZhcmludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBudW0gPSB0aGlzLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgcmV0dXJuIG51bSAlIDIgPT09IDEgPyAobnVtICsgMSkgLyAtMiA6IG51bSAvIDI7IC8vIHppZ3phZyBlbmNvZGluZ1xuICAgIH0sXG5cbiAgICByZWFkQm9vbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMucmVhZFZhcmludCgpKTtcbiAgICB9LFxuXG4gICAgcmVhZFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgc3RyID0gdGhpcy5idWYudG9TdHJpbmcoJ3V0ZjgnLCB0aGlzLnBvcywgZW5kKTtcbiAgICAgICAgdGhpcy5wb3MgPSBlbmQ7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuICAgIHJlYWRCeXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgYnVmZmVyID0gdGhpcy5idWYuc2xpY2UodGhpcy5wb3MsIGVuZCk7XG4gICAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH0sXG5cbiAgICAvLyB2ZXJib3NlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOyBkb2Vzbid0IGFmZmVjdCBnemlwcGVkIHNpemVcblxuICAgIHJlYWRQYWNrZWRWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkVmFyaW50KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU1ZhcmludCgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRCb29sZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEJvb2xlYW4oKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRmxvYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkRmxvYXQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRG91YmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZERvdWJsZSgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkU0ZpeGVkMzI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU0ZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZFNGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG5cbiAgICBza2lwOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB2YWwgJiAweDc7XG4gICAgICAgIGlmICh0eXBlID09PSBQYmYuVmFyaW50KSB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gPiAweDdmKSB7fVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBQYmYuQnl0ZXMpIHRoaXMucG9zID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcztcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gUGJmLkZpeGVkMzIpIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFBiZi5GaXhlZDY0KSB0aGlzLnBvcyArPSA4O1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCB0eXBlOiAnICsgdHlwZSk7XG4gICAgfSxcblxuICAgIC8vID09PSBXUklUSU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICB3cml0ZVRhZzogZnVuY3Rpb24odGFnLCB0eXBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoKHRhZyA8PCAzKSB8IHR5cGUpO1xuICAgIH0sXG5cbiAgICByZWFsbG9jOiBmdW5jdGlvbihtaW4pIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDE2O1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGggPCB0aGlzLnBvcyArIG1pbikgbGVuZ3RoICo9IDI7XG5cbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmJ1Zi5jb3B5KGJ1Zik7XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgd3JpdGVGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZVVJbnQzMkxFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZVNGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUodmFsLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgfSxcblxuICAgIHdyaXRlRml4ZWQ2NDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVJbnQzMkxFKHZhbCAmIC0xLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlVUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIHRoaXMucG9zICsgNCk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlU0ZpeGVkNjQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoOCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIHRoaXMucG9zICsgNCk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlVmFyaW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFsID0gK3ZhbDtcblxuICAgICAgICBpZiAodmFsIDw9IDB4N2YpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gdmFsO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4M2ZmZikge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDIpO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMCkgJiAweDdmKSB8IDB4ODA7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiA3KSAmIDB4N2YpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4MWZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMyk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAwKSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDcpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMTQpICYgMHg3Zik7XG5cbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPD0gMHhmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAwKSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDcpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMTQpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMjEpICYgMHg3Zik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHdoaWxlICh2YWwgPj0gMHg4MCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICh2YWwgJiAweGZmKSB8IDB4ODA7XG4gICAgICAgICAgICAgICAgdmFsIC89IDB4ODA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMSk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IHZhbCB8IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgLSBwb3MgPiAxMCkgdGhyb3cgbmV3IEVycm9yKCdHaXZlbiB2YXJpbnQgZG9lc25cXCd0IGZpdCBpbnRvIDEwIGJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd3JpdGVTVmFyaW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh2YWwgPCAwID8gLXZhbCAqIDIgLSAxIDogdmFsICogMik7XG4gICAgfSxcblxuICAgIHdyaXRlQm9vbGVhbjogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoQm9vbGVhbih2YWwpKTtcbiAgICB9LFxuXG4gICAgd3JpdGVTdHJpbmc6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgICAgdmFyIGJ5dGVzID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyKTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChieXRlcyk7XG4gICAgICAgIHRoaXMucmVhbGxvYyhieXRlcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlKHN0ciwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSBieXRlcztcbiAgICB9LFxuXG4gICAgd3JpdGVGbG9hdDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg0KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVGbG9hdExFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZURvdWJsZTogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVEb3VibGVMRSh2YWwsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICB9LFxuXG4gICAgd3JpdGVCeXRlczogZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgIHZhciBsZW4gPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7XG4gICAgICAgIHRoaXMucmVhbGxvYyhsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IGJ1ZmZlcltpXTtcbiAgICB9LFxuXG4gICAgd3JpdGVNZXNzYWdlOiBmdW5jdGlvbih0YWcsIGZuLCBvYmopIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5CeXRlcyk7XG5cbiAgICAgICAgdGhpcy5wb3MrKzsgLy8gcmVzZXJ2ZSAxIGJ5dGUgZm9yIHNob3J0IG1lc3NhZ2UgbGVuZ3RoXG5cbiAgICAgICAgLy8gd3JpdGUgdGhlIG1lc3NhZ2UgZGlyZWN0bHkgdG8gdGhlIGJ1ZmZlciBhbmQgc2VlIGhvdyBtdWNoIHdhcyB3cml0dGVuXG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zO1xuICAgICAgICBmbihvYmosIHRoaXMpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5wb3MgLSBzdGFydFBvcztcblxuICAgICAgICB2YXIgdmFyaW50TGVuID1cbiAgICAgICAgICAgIGxlbiA8PSAweDdmID8gMSA6XG4gICAgICAgICAgICBsZW4gPD0gMHgzZmZmID8gMiA6XG4gICAgICAgICAgICBsZW4gPD0gMHgxZmZmZmYgPyAzIDpcbiAgICAgICAgICAgIGxlbiA8PSAweGZmZmZmZmYgPyA0IDogTWF0aC5jZWlsKE1hdGgubG9nKGxlbikgLyAoTWF0aC5MTjIgKiA3KSk7XG5cbiAgICAgICAgLy8gaWYgMSBieXRlIGlzbid0IGVub3VnaCBmb3IgZW5jb2RpbmcgbWVzc2FnZSBsZW5ndGgsIHNoaWZ0IHRoZSBkYXRhIHRvIHRoZSByaWdodFxuICAgICAgICBpZiAodmFyaW50TGVuID4gMSkge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKHZhcmludExlbiAtIDEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucG9zIC0gMTsgaSA+PSBzdGFydFBvczsgaS0tKSB0aGlzLmJ1ZltpICsgdmFyaW50TGVuIC0gMV0gPSB0aGlzLmJ1ZltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmFsbHksIHdyaXRlIHRoZSBtZXNzYWdlIGxlbmd0aCBpbiB0aGUgcmVzZXJ2ZWQgcGxhY2UgYW5kIHJlc3RvcmUgdGhlIHBvc2l0aW9uXG4gICAgICAgIHRoaXMucG9zID0gc3RhcnRQb3MgLSAxO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbjtcbiAgICB9LFxuXG4gICAgd3JpdGVQYWNrZWRWYXJpbnQ6ICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFZhcmludCwgYXJyKTsgICB9LFxuICAgIHdyaXRlUGFja2VkU1ZhcmludDogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRTVmFyaW50LCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZEJvb2xlYW46ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkQm9vbGVhbiwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRGbG9hdDogICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEZsb2F0LCBhcnIpOyAgICB9LFxuICAgIHdyaXRlUGFja2VkRG91YmxlOiAgIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWREb3VibGUsIGFycik7ICAgfSxcbiAgICB3cml0ZVBhY2tlZEZpeGVkMzI6ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRml4ZWQzMiwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRTRml4ZWQzMjogZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFNGaXhlZDMyLCBhcnIpOyB9LFxuICAgIHdyaXRlUGFja2VkRml4ZWQ2NDogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRGaXhlZDY0LCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkU0ZpeGVkNjQsIGFycik7IH0sXG5cbiAgICB3cml0ZUJ5dGVzRmllbGQ6IGZ1bmN0aW9uKHRhZywgYnVmZmVyKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuICAgICAgICB0aGlzLndyaXRlQnl0ZXMoYnVmZmVyKTtcbiAgICB9LFxuICAgIHdyaXRlRml4ZWQzMkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlRml4ZWQzMih2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTRml4ZWQzMkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlU0ZpeGVkMzIodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuICAgICAgICB0aGlzLndyaXRlRml4ZWQ2NCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuICAgICAgICB0aGlzLndyaXRlU0ZpeGVkNjQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlVmFyaW50RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuVmFyaW50KTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTVmFyaW50RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuVmFyaW50KTtcbiAgICAgICAgdGhpcy53cml0ZVNWYXJpbnQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU3RyaW5nRmllbGQ6IGZ1bmN0aW9uKHRhZywgc3RyKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuICAgICAgICB0aGlzLndyaXRlU3RyaW5nKHN0cik7XG4gICAgfSxcbiAgICB3cml0ZUZsb2F0RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQzMik7XG4gICAgICAgIHRoaXMud3JpdGVGbG9hdCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVEb3VibGVGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDY0KTtcbiAgICAgICAgdGhpcy53cml0ZURvdWJsZSh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVCb29sZWFuRmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnRGaWVsZCh0YWcsIEJvb2xlYW4odmFsKSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVQYWNrZWRWYXJpbnQoYXJyLCBwYmYpICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlVmFyaW50KGFycltpXSk7ICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTVmFyaW50KGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU1ZhcmludChhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGbG9hdChhcnIsIHBiZikgICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRmxvYXQoYXJyW2ldKTsgICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWREb3VibGUoYXJyLCBwYmYpICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRG91YmxlKGFycltpXSk7ICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRCb29sZWFuKGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlQm9vbGVhbihhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDMyKGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRml4ZWQzMihhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTRml4ZWQzMihhcnIsIHBiZikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU0ZpeGVkMzIoYXJyW2ldKTsgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDY0KGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRml4ZWQ2NChhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTRml4ZWQ2NChhcnIsIHBiZikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU0ZpeGVkNjQoYXJyW2ldKTsgfVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTl3WW1ZdmFXNWtaWGd1YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJJaXdpWm1sc1pTSTZJbWRsYm1WeVlYUmxaQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lJbmRYTmxJSE4wY21samRDYzdYRzVjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnVUdKbU8xeHVYRzUyWVhJZ1FuVm1abVZ5SUQwZ1oyeHZZbUZzTGtKMVptWmxjaUI4ZkNCeVpYRjFhWEpsS0NjdUwySjFabVpsY2ljcE8xeHVYRzVtZFc1amRHbHZiaUJRWW1Zb1luVm1LU0I3WEc0Z0lDQWdkR2hwY3k1aWRXWWdQU0FoUW5WbVptVnlMbWx6UW5WbVptVnlLR0oxWmlrZ1B5QnVaWGNnUW5WbVptVnlLR0oxWmlCOGZDQXdLU0E2SUdKMVpqdGNiaUFnSUNCMGFHbHpMbkJ2Y3lBOUlEQTdYRzRnSUNBZ2RHaHBjeTVzWlc1bmRHZ2dQU0IwYUdsekxtSjFaaTVzWlc1bmRHZzdYRzU5WEc1Y2JsQmlaaTVXWVhKcGJuUWdJRDBnTURzZ0x5OGdkbUZ5YVc1ME9pQnBiblF6TWl3Z2FXNTBOalFzSUhWcGJuUXpNaXdnZFdsdWREWTBMQ0J6YVc1ME16SXNJSE5wYm5RMk5Dd2dZbTl2YkN3Z1pXNTFiVnh1VUdKbUxrWnBlR1ZrTmpRZ1BTQXhPeUF2THlBMk5DMWlhWFE2SUdSdmRXSnNaU3dnWm1sNFpXUTJOQ3dnYzJacGVHVmtOalJjYmxCaVppNUNlWFJsY3lBZ0lEMGdNanNnTHk4Z2JHVnVaM1JvTFdSbGJHbHRhWFJsWkRvZ2MzUnlhVzVuTENCaWVYUmxjeXdnWlcxaVpXUmtaV1FnYldWemMyRm5aWE1zSUhCaFkydGxaQ0J5WlhCbFlYUmxaQ0JtYVdWc1pITmNibEJpWmk1R2FYaGxaRE15SUQwZ05Uc2dMeThnTXpJdFltbDBPaUJtYkc5aGRDd2dabWw0WldRek1pd2djMlpwZUdWa016SmNibHh1ZG1GeUlGTklTVVpVWDB4RlJsUmZNeklnUFNBb01TQThQQ0F4TmlrZ0tpQW9NU0E4UENBeE5pa3NYRzRnSUNBZ1UwaEpSbFJmVWtsSFNGUmZNeklnUFNBeElDOGdVMGhKUmxSZlRFVkdWRjh6TWl4Y2JpQWdJQ0JRVDFkZk1sODJNeUE5SUUxaGRHZ3VjRzkzS0RJc0lEWXpLVHRjYmx4dVVHSm1MbkJ5YjNSdmRIbHdaU0E5SUh0Y2JseHVJQ0FnSUdSbGMzUnliM2s2SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TG1KMVppQTlJRzUxYkd3N1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUM4dklEMDlQU0JTUlVGRVNVNUhJRDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5WEc1Y2JpQWdJQ0J5WldGa1JtbGxiR1J6T2lCbWRXNWpkR2x2YmloeVpXRmtSbWxsYkdRc0lISmxjM1ZzZEN3Z1pXNWtLU0I3WEc0Z0lDQWdJQ0FnSUdWdVpDQTlJR1Z1WkNCOGZDQjBhR2x6TG14bGJtZDBhRHRjYmx4dUlDQWdJQ0FnSUNCM2FHbHNaU0FvZEdocGN5NXdiM01nUENCbGJtUXBJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIWmhjaUIyWVd3Z1BTQjBhR2x6TG5KbFlXUldZWEpwYm5Rb0tTeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjBZV2NnUFNCMllXd2dQajRnTXl4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCemRHRnlkRkJ2Y3lBOUlIUm9hWE11Y0c5ek8xeHVYRzRnSUNBZ0lDQWdJQ0FnSUNCeVpXRmtSbWxsYkdRb2RHRm5MQ0J5WlhOMWJIUXNJSFJvYVhNcE8xeHVYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9kR2hwY3k1d2IzTWdQVDA5SUhOMFlYSjBVRzl6S1NCMGFHbHpMbk5yYVhBb2RtRnNLVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnY21WemRXeDBPMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQnlaV0ZrVFdWemMyRm5aVG9nWm5WdVkzUnBiMjRvY21WaFpFWnBaV3hrTENCeVpYTjFiSFFwSUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXVjbVZoWkVacFpXeGtjeWh5WldGa1JtbGxiR1FzSUhKbGMzVnNkQ3dnZEdocGN5NXlaV0ZrVm1GeWFXNTBLQ2tnS3lCMGFHbHpMbkJ2Y3lrN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUhKbFlXUkdhWGhsWkRNeU9pQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlIWmhiQ0E5SUhSb2FYTXVZblZtTG5KbFlXUlZTVzUwTXpKTVJTaDBhR2x6TG5CdmN5azdYRzRnSUNBZ0lDQWdJSFJvYVhNdWNHOXpJQ3M5SURRN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMllXdzdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lISmxZV1JUUm1sNFpXUXpNam9nWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNBZ0lIWmhjaUIyWVd3Z1BTQjBhR2x6TG1KMVppNXlaV0ZrU1c1ME16Sk1SU2gwYUdsekxuQnZjeWs3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjRzl6SUNzOUlEUTdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQjJZV3c3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJQzh2SURZMExXSnBkQ0JwYm5RZ2FHRnVaR3hwYm1jZ2FYTWdZbUZ6WldRZ2IyNGdaMmwwYUhWaUxtTnZiUzlrY0hjdmJtOWtaUzFpZFdabVpYSXRiVzl5WlMxcGJuUnpJQ2hOU1ZRdGJHbGpaVzV6WldRcFhHNWNiaUFnSUNCeVpXRmtSbWw0WldRMk5Eb2dablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0FnSUhaaGNpQjJZV3dnUFNCMGFHbHpMbUoxWmk1eVpXRmtWVWx1ZERNeVRFVW9kR2hwY3k1d2IzTXBJQ3NnZEdocGN5NWlkV1l1Y21WaFpGVkpiblF6TWt4RktIUm9hWE11Y0c5eklDc2dOQ2tnS2lCVFNFbEdWRjlNUlVaVVh6TXlPMXh1SUNBZ0lDQWdJQ0IwYUdsekxuQnZjeUFyUFNBNE8xeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RtRnNPMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQnlaV0ZrVTBacGVHVmtOalE2SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUNBZ0lDQjJZWElnZG1Gc0lEMGdkR2hwY3k1aWRXWXVjbVZoWkZWSmJuUXpNa3hGS0hSb2FYTXVjRzl6S1NBcklIUm9hWE11WW5WbUxuSmxZV1JKYm5Rek1reEZLSFJvYVhNdWNHOXpJQ3NnTkNrZ0tpQlRTRWxHVkY5TVJVWlVYek15TzF4dUlDQWdJQ0FnSUNCMGFHbHpMbkJ2Y3lBclBTQTRPMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkbUZzTzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0J5WldGa1JteHZZWFE2SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUNBZ0lDQjJZWElnZG1Gc0lEMGdkR2hwY3k1aWRXWXVjbVZoWkVac2IyRjBURVVvZEdocGN5NXdiM01wTzF4dUlDQWdJQ0FnSUNCMGFHbHpMbkJ2Y3lBclBTQTBPMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkbUZzTzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0J5WldGa1JHOTFZbXhsT2lCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lDQWdkbUZ5SUhaaGJDQTlJSFJvYVhNdVluVm1MbkpsWVdSRWIzVmliR1ZNUlNoMGFHbHpMbkJ2Y3lrN1hHNGdJQ0FnSUNBZ0lIUm9hWE11Y0c5eklDczlJRGc3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIyWVd3N1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUhKbFlXUldZWEpwYm5RNklHWjFibU4wYVc5dUtDa2dlMXh1SUNBZ0lDQWdJQ0IyWVhJZ1luVm1JRDBnZEdocGN5NWlkV1lzWEc0Z0lDQWdJQ0FnSUNBZ0lDQjJZV3dzSUdJc0lHSXdMQ0JpTVN3Z1lqSXNJR0l6TzF4dVhHNGdJQ0FnSUNBZ0lHSXdJRDBnWW5WbVczUm9hWE11Y0c5ekt5dGRPeUJwWmlBb1lqQWdQQ0F3ZURnd0tTQnlaWFIxY200Z1lqQTdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmlNQ0E5SUdJd0lDWWdNSGczWmp0Y2JpQWdJQ0FnSUNBZ1lqRWdQU0JpZFdaYmRHaHBjeTV3YjNNcksxMDdJR2xtSUNoaU1TQThJREI0T0RBcElISmxkSFZ5YmlCaU1DQjhJR0l4SUR3OElEYzdJQ0FnSUNBZ0lHSXhJRDBnS0dJeElDWWdNSGczWmlrZ1BEd2dOenRjYmlBZ0lDQWdJQ0FnWWpJZ1BTQmlkV1piZEdocGN5NXdiM01ySzEwN0lHbG1JQ2hpTWlBOElEQjRPREFwSUhKbGRIVnliaUJpTUNCOElHSXhJSHdnWWpJZ1BEd2dNVFE3SUdJeUlEMGdLR0l5SUNZZ01IZzNaaWtnUER3Z01UUTdYRzRnSUNBZ0lDQWdJR0l6SUQwZ1luVm1XM1JvYVhNdWNHOXpLeXRkT3lCcFppQW9Zak1nUENBd2VEZ3dLU0J5WlhSMWNtNGdZakFnZkNCaU1TQjhJR0l5SUh3Z1lqTWdQRHdnTWpFN1hHNWNiaUFnSUNBZ0lDQWdkbUZzSUQwZ1lqQWdmQ0JpTVNCOElHSXlJSHdnS0dJeklDWWdNSGczWmlrZ1BEd2dNakU3WEc1Y2JpQWdJQ0FnSUNBZ1lpQTlJR0oxWmx0MGFHbHpMbkJ2Y3lzclhUc2dkbUZzSUNzOUlDaGlJQ1lnTUhnM1ppa2dLaUF3ZURFd01EQXdNREF3T3lBZ0lDQWdJQ0FnSUdsbUlDaGlJRHdnTUhnNE1Da2djbVYwZFhKdUlIWmhiRHRjYmlBZ0lDQWdJQ0FnWWlBOUlHSjFabHQwYUdsekxuQnZjeXNyWFRzZ2RtRnNJQ3M5SUNoaUlDWWdNSGczWmlrZ0tpQXdlRGd3TURBd01EQXdNRHNnSUNBZ0lDQWdJR2xtSUNoaUlEd2dNSGc0TUNrZ2NtVjBkWEp1SUhaaGJEdGNiaUFnSUNBZ0lDQWdZaUE5SUdKMVpsdDBhR2x6TG5CdmN5c3JYVHNnZG1Gc0lDczlJQ2hpSUNZZ01IZzNaaWtnS2lBd2VEUXdNREF3TURBd01EQXdPeUFnSUNBZ0lHbG1JQ2hpSUR3Z01IZzRNQ2tnY21WMGRYSnVJSFpoYkR0Y2JpQWdJQ0FnSUNBZ1lpQTlJR0oxWmx0MGFHbHpMbkJ2Y3lzclhUc2dkbUZzSUNzOUlDaGlJQ1lnTUhnM1ppa2dLaUF3ZURJd01EQXdNREF3TURBd01EQTdJQ0FnSUdsbUlDaGlJRHdnTUhnNE1Da2djbVYwZFhKdUlIWmhiRHRjYmlBZ0lDQWdJQ0FnWWlBOUlHSjFabHQwYUdsekxuQnZjeXNyWFRzZ2RtRnNJQ3M5SUNoaUlDWWdNSGczWmlrZ0tpQXdlREV3TURBd01EQXdNREF3TURBd01Ec2dJR2xtSUNoaUlEd2dNSGc0TUNrZ2NtVjBkWEp1SUhaaGJEdGNiaUFnSUNBZ0lDQWdZaUE5SUdKMVpsdDBhR2x6TG5CdmN5c3JYVHNnZG1Gc0lDczlJQ2hpSUNZZ01IZzNaaWtnS2lBd2VEZ3dNREF3TURBd01EQXdNREF3TURBN0lHbG1JQ2hpSUR3Z01IZzRNQ2tnY21WMGRYSnVJSFpoYkR0Y2JseHVJQ0FnSUNBZ0lDQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb0owVjRjR1ZqZEdWa0lIWmhjbWx1ZENCdWIzUWdiVzl5WlNCMGFHRnVJREV3SUdKNWRHVnpKeWs3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJSEpsWVdSV1lYSnBiblEyTkRvZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCemRHRnlkRkJ2Y3lBOUlIUm9hWE11Y0c5ekxGeHVJQ0FnSUNBZ0lDQWdJQ0FnZG1Gc0lEMGdkR2hwY3k1eVpXRmtWbUZ5YVc1MEtDazdYRzVjYmlBZ0lDQWdJQ0FnYVdZZ0tIWmhiQ0E4SUZCUFYxOHlYell6S1NCeVpYUjFjbTRnZG1Gc08xeHVYRzRnSUNBZ0lDQWdJSFpoY2lCd2IzTWdQU0IwYUdsekxuQnZjeUF0SURJN1hHNGdJQ0FnSUNBZ0lIZG9hV3hsSUNoMGFHbHpMbUoxWmx0d2IzTmRJRDA5UFNBd2VHWm1LU0J3YjNNdExUdGNiaUFnSUNBZ0lDQWdhV1lnS0hCdmN5QThJSE4wWVhKMFVHOXpLU0J3YjNNZ1BTQnpkR0Z5ZEZCdmN6dGNibHh1SUNBZ0lDQWdJQ0IyWVd3Z1BTQXdPMXh1SUNBZ0lDQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUhCdmN5QXRJSE4wWVhKMFVHOXpJQ3NnTVRzZ2FTc3JLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjJZWElnWWlBOUlINTBhR2x6TG1KMVpsdHpkR0Z5ZEZCdmN5QXJJR2xkSUNZZ01IZzNaanRjYmlBZ0lDQWdJQ0FnSUNBZ0lIWmhiQ0FyUFNCcElEd2dOQ0EvSUdJZ1BEd2dhU0FxSURjZ09pQmlJQ29nVFdGMGFDNXdiM2NvTWl3Z2FTQXFJRGNwTzF4dUlDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdjbVYwZFhKdUlDMTJZV3dnTFNBeE8xeHVJQ0FnSUgwc1hHNWNiaUFnSUNCeVpXRmtVMVpoY21sdWREb2dablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0FnSUhaaGNpQnVkVzBnUFNCMGFHbHpMbkpsWVdSV1lYSnBiblFvS1R0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUc1MWJTQWxJRElnUFQwOUlERWdQeUFvYm5WdElDc2dNU2tnTHlBdE1pQTZJRzUxYlNBdklESTdJQzh2SUhwcFozcGhaeUJsYm1OdlpHbHVaMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQnlaV0ZrUW05dmJHVmhiam9nWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCQ2IyOXNaV0Z1S0hSb2FYTXVjbVZoWkZaaGNtbHVkQ2dwS1R0Y2JpQWdJQ0I5TEZ4dVhHNGdJQ0FnY21WaFpGTjBjbWx1WnpvZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCbGJtUWdQU0IwYUdsekxuSmxZV1JXWVhKcGJuUW9LU0FySUhSb2FYTXVjRzl6TEZ4dUlDQWdJQ0FnSUNBZ0lDQWdjM1J5SUQwZ2RHaHBjeTVpZFdZdWRHOVRkSEpwYm1jb0ozVjBaamduTENCMGFHbHpMbkJ2Y3l3Z1pXNWtLVHRjYmlBZ0lDQWdJQ0FnZEdocGN5NXdiM01nUFNCbGJtUTdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQnpkSEk3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJSEpsWVdSQ2VYUmxjem9nWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNBZ0lIWmhjaUJsYm1RZ1BTQjBhR2x6TG5KbFlXUldZWEpwYm5Rb0tTQXJJSFJvYVhNdWNHOXpMRnh1SUNBZ0lDQWdJQ0FnSUNBZ1luVm1abVZ5SUQwZ2RHaHBjeTVpZFdZdWMyeHBZMlVvZEdocGN5NXdiM01zSUdWdVpDazdYRzRnSUNBZ0lDQWdJSFJvYVhNdWNHOXpJRDBnWlc1a08xeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1luVm1abVZ5TzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0F2THlCMlpYSmliM05sSUdadmNpQndaWEptYjNKdFlXNWpaU0J5WldGemIyNXpPeUJrYjJWemJpZDBJR0ZtWm1WamRDQm5lbWx3Y0dWa0lITnBlbVZjYmx4dUlDQWdJSEpsWVdSUVlXTnJaV1JXWVhKcGJuUTZJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQWdJQ0FnSUNCMllYSWdaVzVrSUQwZ2RHaHBjeTV5WldGa1ZtRnlhVzUwS0NrZ0t5QjBhR2x6TG5CdmN5d2dZWEp5SUQwZ1cxMDdYRzRnSUNBZ0lDQWdJSGRvYVd4bElDaDBhR2x6TG5CdmN5QThJR1Z1WkNrZ1lYSnlMbkIxYzJnb2RHaHBjeTV5WldGa1ZtRnlhVzUwS0NrcE8xeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1lYSnlPMXh1SUNBZ0lIMHNYRzRnSUNBZ2NtVmhaRkJoWTJ0bFpGTldZWEpwYm5RNklHWjFibU4wYVc5dUtDa2dlMXh1SUNBZ0lDQWdJQ0IyWVhJZ1pXNWtJRDBnZEdocGN5NXlaV0ZrVm1GeWFXNTBLQ2tnS3lCMGFHbHpMbkJ2Y3l3Z1lYSnlJRDBnVzEwN1hHNGdJQ0FnSUNBZ0lIZG9hV3hsSUNoMGFHbHpMbkJ2Y3lBOElHVnVaQ2tnWVhKeUxuQjFjMmdvZEdocGN5NXlaV0ZrVTFaaGNtbHVkQ2dwS1R0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUdGeWNqdGNiaUFnSUNCOUxGeHVJQ0FnSUhKbFlXUlFZV05yWldSQ2IyOXNaV0Z1T2lCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lDQWdkbUZ5SUdWdVpDQTlJSFJvYVhNdWNtVmhaRlpoY21sdWRDZ3BJQ3NnZEdocGN5NXdiM01zSUdGeWNpQTlJRnRkTzF4dUlDQWdJQ0FnSUNCM2FHbHNaU0FvZEdocGN5NXdiM01nUENCbGJtUXBJR0Z5Y2k1d2RYTm9LSFJvYVhNdWNtVmhaRUp2YjJ4bFlXNG9LU2s3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJoY25JN1hHNGdJQ0FnZlN4Y2JpQWdJQ0J5WldGa1VHRmphMlZrUm14dllYUTZJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQWdJQ0FnSUNCMllYSWdaVzVrSUQwZ2RHaHBjeTV5WldGa1ZtRnlhVzUwS0NrZ0t5QjBhR2x6TG5CdmN5d2dZWEp5SUQwZ1cxMDdYRzRnSUNBZ0lDQWdJSGRvYVd4bElDaDBhR2x6TG5CdmN5QThJR1Z1WkNrZ1lYSnlMbkIxYzJnb2RHaHBjeTV5WldGa1JteHZZWFFvS1NrN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCaGNuSTdYRzRnSUNBZ2ZTeGNiaUFnSUNCeVpXRmtVR0ZqYTJWa1JHOTFZbXhsT2lCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lDQWdkbUZ5SUdWdVpDQTlJSFJvYVhNdWNtVmhaRlpoY21sdWRDZ3BJQ3NnZEdocGN5NXdiM01zSUdGeWNpQTlJRnRkTzF4dUlDQWdJQ0FnSUNCM2FHbHNaU0FvZEdocGN5NXdiM01nUENCbGJtUXBJR0Z5Y2k1d2RYTm9LSFJvYVhNdWNtVmhaRVJ2ZFdKc1pTZ3BLVHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJR0Z5Y2p0Y2JpQWdJQ0I5TEZ4dUlDQWdJSEpsWVdSUVlXTnJaV1JHYVhobFpETXlPaUJtZFc1amRHbHZiaWdwSUh0Y2JpQWdJQ0FnSUNBZ2RtRnlJR1Z1WkNBOUlIUm9hWE11Y21WaFpGWmhjbWx1ZENncElDc2dkR2hwY3k1d2IzTXNJR0Z5Y2lBOUlGdGRPMXh1SUNBZ0lDQWdJQ0IzYUdsc1pTQW9kR2hwY3k1d2IzTWdQQ0JsYm1RcElHRnljaTV3ZFhOb0tIUm9hWE11Y21WaFpFWnBlR1ZrTXpJb0tTazdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQmhjbkk3WEc0Z0lDQWdmU3hjYmlBZ0lDQnlaV0ZrVUdGamEyVmtVMFpwZUdWa016STZJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQWdJQ0FnSUNCMllYSWdaVzVrSUQwZ2RHaHBjeTV5WldGa1ZtRnlhVzUwS0NrZ0t5QjBhR2x6TG5CdmN5d2dZWEp5SUQwZ1cxMDdYRzRnSUNBZ0lDQWdJSGRvYVd4bElDaDBhR2x6TG5CdmN5QThJR1Z1WkNrZ1lYSnlMbkIxYzJnb2RHaHBjeTV5WldGa1UwWnBlR1ZrTXpJb0tTazdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQmhjbkk3WEc0Z0lDQWdmU3hjYmlBZ0lDQnlaV0ZrVUdGamEyVmtSbWw0WldRMk5Eb2dablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0FnSUhaaGNpQmxibVFnUFNCMGFHbHpMbkpsWVdSV1lYSnBiblFvS1NBcklIUm9hWE11Y0c5ekxDQmhjbklnUFNCYlhUdGNiaUFnSUNBZ0lDQWdkMmhwYkdVZ0tIUm9hWE11Y0c5eklEd2daVzVrS1NCaGNuSXVjSFZ6YUNoMGFHbHpMbkpsWVdSR2FYaGxaRFkwS0NrcE8xeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1lYSnlPMXh1SUNBZ0lIMHNYRzRnSUNBZ2NtVmhaRkJoWTJ0bFpGTkdhWGhsWkRZME9pQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlHVnVaQ0E5SUhSb2FYTXVjbVZoWkZaaGNtbHVkQ2dwSUNzZ2RHaHBjeTV3YjNNc0lHRnljaUE5SUZ0ZE8xeHVJQ0FnSUNBZ0lDQjNhR2xzWlNBb2RHaHBjeTV3YjNNZ1BDQmxibVFwSUdGeWNpNXdkWE5vS0hSb2FYTXVjbVZoWkZOR2FYaGxaRFkwS0NrcE8xeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z1lYSnlPMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQnphMmx3T2lCbWRXNWpkR2x2YmloMllXd3BJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlIUjVjR1VnUFNCMllXd2dKaUF3ZURjN1hHNGdJQ0FnSUNBZ0lHbG1JQ2gwZVhCbElEMDlQU0JRWW1ZdVZtRnlhVzUwS1NCM2FHbHNaU0FvZEdocGN5NWlkV1piZEdocGN5NXdiM01ySzEwZ1BpQXdlRGRtS1NCN2ZWeHVJQ0FnSUNBZ0lDQmxiSE5sSUdsbUlDaDBlWEJsSUQwOVBTQlFZbVl1UW5sMFpYTXBJSFJvYVhNdWNHOXpJRDBnZEdocGN5NXlaV0ZrVm1GeWFXNTBLQ2tnS3lCMGFHbHpMbkJ2Y3p0Y2JpQWdJQ0FnSUNBZ1pXeHpaU0JwWmlBb2RIbHdaU0E5UFQwZ1VHSm1Ma1pwZUdWa016SXBJSFJvYVhNdWNHOXpJQ3M5SURRN1hHNGdJQ0FnSUNBZ0lHVnNjMlVnYVdZZ0tIUjVjR1VnUFQwOUlGQmlaaTVHYVhobFpEWTBLU0IwYUdsekxuQnZjeUFyUFNBNE8xeHVJQ0FnSUNBZ0lDQmxiSE5sSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWduVlc1cGJYQnNaVzFsYm5SbFpDQjBlWEJsT2lBbklDc2dkSGx3WlNrN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUM4dklEMDlQU0JYVWtsVVNVNUhJRDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5WEc1Y2JpQWdJQ0IzY21sMFpWUmhaem9nWm5WdVkzUnBiMjRvZEdGbkxDQjBlWEJsS1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11ZDNKcGRHVldZWEpwYm5Rb0tIUmhaeUE4UENBektTQjhJSFI1Y0dVcE8xeHVJQ0FnSUgwc1hHNWNiaUFnSUNCeVpXRnNiRzlqT2lCbWRXNWpkR2x2YmlodGFXNHBJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlHeGxibWQwYUNBOUlIUm9hWE11YkdWdVozUm9JSHg4SURFMk8xeHVYRzRnSUNBZ0lDQWdJSGRvYVd4bElDaHNaVzVuZEdnZ1BDQjBhR2x6TG5CdmN5QXJJRzFwYmlrZ2JHVnVaM1JvSUNvOUlESTdYRzVjYmlBZ0lDQWdJQ0FnYVdZZ0tHeGxibWQwYUNBaFBUMGdkR2hwY3k1c1pXNW5kR2dwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFpoY2lCaWRXWWdQU0J1WlhjZ1FuVm1abVZ5S0d4bGJtZDBhQ2s3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjBhR2x6TG1KMVppNWpiM0I1S0dKMVppazdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbUoxWmlBOUlHSjFaanRjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11YkdWdVozUm9JRDBnYkdWdVozUm9PMXh1SUNBZ0lDQWdJQ0I5WEc0Z0lDQWdmU3hjYmx4dUlDQWdJR1pwYm1semFEb2dablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0FnSUhSb2FYTXViR1Z1WjNSb0lEMGdkR2hwY3k1d2IzTTdYRzRnSUNBZ0lDQWdJSFJvYVhNdWNHOXpJRDBnTUR0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXVZblZtTG5Oc2FXTmxLREFzSUhSb2FYTXViR1Z1WjNSb0tUdGNiaUFnSUNCOUxGeHVYRzRnSUNBZ2QzSnBkR1ZHYVhobFpETXlPaUJtZFc1amRHbHZiaWgyWVd3cElIdGNiaUFnSUNBZ0lDQWdkR2hwY3k1eVpXRnNiRzlqS0RRcE8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG1KMVppNTNjbWwwWlZWSmJuUXpNa3hGS0haaGJDd2dkR2hwY3k1d2IzTXBPMXh1SUNBZ0lDQWdJQ0IwYUdsekxuQnZjeUFyUFNBME8xeHVJQ0FnSUgwc1hHNWNiaUFnSUNCM2NtbDBaVk5HYVhobFpETXlPaUJtZFc1amRHbHZiaWgyWVd3cElIdGNiaUFnSUNBZ0lDQWdkR2hwY3k1eVpXRnNiRzlqS0RRcE8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG1KMVppNTNjbWwwWlVsdWRETXlURVVvZG1Gc0xDQjBhR2x6TG5CdmN5azdYRzRnSUNBZ0lDQWdJSFJvYVhNdWNHOXpJQ3M5SURRN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUhkeWFYUmxSbWw0WldRMk5Eb2dablZ1WTNScGIyNG9kbUZzS1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11Y21WaGJHeHZZeWc0S1R0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTVpZFdZdWQzSnBkR1ZKYm5Rek1reEZLSFpoYkNBbUlDMHhMQ0IwYUdsekxuQnZjeWs3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVZblZtTG5keWFYUmxWVWx1ZERNeVRFVW9UV0YwYUM1bWJHOXZjaWgyWVd3Z0tpQlRTRWxHVkY5U1NVZElWRjh6TWlrc0lIUm9hWE11Y0c5eklDc2dOQ2s3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjRzl6SUNzOUlEZzdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lIZHlhWFJsVTBacGVHVmtOalE2SUdaMWJtTjBhVzl1S0haaGJDa2dlMXh1SUNBZ0lDQWdJQ0IwYUdsekxuSmxZV3hzYjJNb09DazdYRzRnSUNBZ0lDQWdJSFJvYVhNdVluVm1MbmR5YVhSbFNXNTBNekpNUlNoMllXd2dKaUF0TVN3Z2RHaHBjeTV3YjNNcE8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG1KMVppNTNjbWwwWlVsdWRETXlURVVvVFdGMGFDNW1iRzl2Y2loMllXd2dLaUJUU0VsR1ZGOVNTVWRJVkY4ek1pa3NJSFJvYVhNdWNHOXpJQ3NnTkNrN1hHNGdJQ0FnSUNBZ0lIUm9hWE11Y0c5eklDczlJRGc3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJSGR5YVhSbFZtRnlhVzUwT2lCbWRXNWpkR2x2YmloMllXd3BJSHRjYmlBZ0lDQWdJQ0FnZG1Gc0lEMGdLM1poYkR0Y2JseHVJQ0FnSUNBZ0lDQnBaaUFvZG1Gc0lEdzlJREI0TjJZcElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhSb2FYTXVjbVZoYkd4dll5Z3hLVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11WW5WbVczUm9hWE11Y0c5ekt5dGRJRDBnZG1Gc08xeHVYRzRnSUNBZ0lDQWdJSDBnWld4elpTQnBaaUFvZG1Gc0lEdzlJREI0TTJabVppa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ2RHaHBjeTV5WldGc2JHOWpLRElwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1aWRXWmJkR2hwY3k1d2IzTXJLMTBnUFNBb0tIWmhiQ0ErUGo0Z01Da2dKaUF3ZURkbUtTQjhJREI0T0RBN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxtSjFabHQwYUdsekxuQnZjeXNyWFNBOUlDZ29kbUZzSUQ0K1BpQTNLU0FtSURCNE4yWXBPMXh1WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2RtRnNJRHc5SURCNE1XWm1abVptS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxuSmxZV3hzYjJNb015azdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbUoxWmx0MGFHbHpMbkJ2Y3lzclhTQTlJQ2dvZG1Gc0lENCtQaUF3S1NBbUlEQjROMllwSUh3Z01IZzRNRHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11WW5WbVczUm9hWE11Y0c5ekt5dGRJRDBnS0NoMllXd2dQajQrSURjcElDWWdNSGczWmlrZ2ZDQXdlRGd3TzF4dUlDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1aWRXWmJkR2hwY3k1d2IzTXJLMTBnUFNBb0tIWmhiQ0ErUGo0Z01UUXBJQ1lnTUhnM1ppazdYRzVjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJR2xtSUNoMllXd2dQRDBnTUhobVptWm1abVptS1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxuSmxZV3hzYjJNb05DazdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbUoxWmx0MGFHbHpMbkJ2Y3lzclhTQTlJQ2dvZG1Gc0lENCtQaUF3S1NBbUlEQjROMllwSUh3Z01IZzRNRHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIUm9hWE11WW5WbVczUm9hWE11Y0c5ekt5dGRJRDBnS0NoMllXd2dQajQrSURjcElDWWdNSGczWmlrZ2ZDQXdlRGd3TzF4dUlDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1aWRXWmJkR2hwY3k1d2IzTXJLMTBnUFNBb0tIWmhiQ0ErUGo0Z01UUXBJQ1lnTUhnM1ppa2dmQ0F3ZURnd08xeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdocGN5NWlkV1piZEdocGN5NXdiM01ySzEwZ1BTQW9LSFpoYkNBK1BqNGdNakVwSUNZZ01IZzNaaWs3WEc1Y2JpQWdJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFpoY2lCd2IzTWdQU0IwYUdsekxuQnZjenRjYmlBZ0lDQWdJQ0FnSUNBZ0lIZG9hV3hsSUNoMllXd2dQajBnTUhnNE1Da2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFJvYVhNdWNtVmhiR3h2WXlneEtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjBhR2x6TG1KMVpsdDBhR2x6TG5CdmN5c3JYU0E5SUNoMllXd2dKaUF3ZUdabUtTQjhJREI0T0RBN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2RtRnNJQzg5SURCNE9EQTdYRzRnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdJQ0IwYUdsekxuSmxZV3hzYjJNb01TazdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbUoxWmx0MGFHbHpMbkJ2Y3lzclhTQTlJSFpoYkNCOElEQTdYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9kR2hwY3k1d2IzTWdMU0J3YjNNZ1BpQXhNQ2tnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2RIYVhabGJpQjJZWEpwYm5RZ1pHOWxjMjVjWENkMElHWnBkQ0JwYm5SdklERXdJR0o1ZEdWekp5azdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdkM0pwZEdWVFZtRnlhVzUwT2lCbWRXNWpkR2x2YmloMllXd3BJSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NTNjbWwwWlZaaGNtbHVkQ2gyWVd3Z1BDQXdJRDhnTFhaaGJDQXFJRElnTFNBeElEb2dkbUZzSUNvZ01pazdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lIZHlhWFJsUW05dmJHVmhiam9nWm5WdVkzUnBiMjRvZG1Gc0tTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdWQzSnBkR1ZXWVhKcGJuUW9RbTl2YkdWaGJpaDJZV3dwS1R0Y2JpQWdJQ0I5TEZ4dVhHNGdJQ0FnZDNKcGRHVlRkSEpwYm1jNklHWjFibU4wYVc5dUtITjBjaWtnZTF4dUlDQWdJQ0FnSUNCemRISWdQU0JUZEhKcGJtY29jM1J5S1R0Y2JpQWdJQ0FnSUNBZ2RtRnlJR0o1ZEdWeklEMGdRblZtWm1WeUxtSjVkR1ZNWlc1bmRHZ29jM1J5S1R0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTUzY21sMFpWWmhjbWx1ZENoaWVYUmxjeWs3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVjbVZoYkd4dll5aGllWFJsY3lrN1hHNGdJQ0FnSUNBZ0lIUm9hWE11WW5WbUxuZHlhWFJsS0hOMGNpd2dkR2hwY3k1d2IzTXBPMXh1SUNBZ0lDQWdJQ0IwYUdsekxuQnZjeUFyUFNCaWVYUmxjenRjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdkM0pwZEdWR2JHOWhkRG9nWm5WdVkzUnBiMjRvZG1Gc0tTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdWNtVmhiR3h2WXlnMEtUdGNiaUFnSUNBZ0lDQWdkR2hwY3k1aWRXWXVkM0pwZEdWR2JHOWhkRXhGS0haaGJDd2dkR2hwY3k1d2IzTXBPMXh1SUNBZ0lDQWdJQ0IwYUdsekxuQnZjeUFyUFNBME8xeHVJQ0FnSUgwc1hHNWNiaUFnSUNCM2NtbDBaVVJ2ZFdKc1pUb2dablZ1WTNScGIyNG9kbUZzS1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11Y21WaGJHeHZZeWc0S1R0Y2JpQWdJQ0FnSUNBZ2RHaHBjeTVpZFdZdWQzSnBkR1ZFYjNWaWJHVk1SU2gyWVd3c0lIUm9hWE11Y0c5ektUdGNiaUFnSUNBZ0lDQWdkR2hwY3k1d2IzTWdLejBnT0R0Y2JpQWdJQ0I5TEZ4dVhHNGdJQ0FnZDNKcGRHVkNlWFJsY3pvZ1puVnVZM1JwYjI0b1luVm1abVZ5S1NCN1hHNGdJQ0FnSUNBZ0lIWmhjaUJzWlc0Z1BTQmlkV1ptWlhJdWJHVnVaM1JvTzF4dUlDQWdJQ0FnSUNCMGFHbHpMbmR5YVhSbFZtRnlhVzUwS0d4bGJpazdYRzRnSUNBZ0lDQWdJSFJvYVhNdWNtVmhiR3h2WXloc1pXNHBPMXh1SUNBZ0lDQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUd4bGJqc2dhU3NyS1NCMGFHbHpMbUoxWmx0MGFHbHpMbkJ2Y3lzclhTQTlJR0oxWm1abGNsdHBYVHRjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdkM0pwZEdWTlpYTnpZV2RsT2lCbWRXNWpkR2x2YmloMFlXY3NJR1p1TENCdlltb3BJSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NTNjbWwwWlZSaFp5aDBZV2NzSUZCaVppNUNlWFJsY3lrN1hHNWNiaUFnSUNBZ0lDQWdkR2hwY3k1d2IzTXJLenNnTHk4Z2NtVnpaWEoyWlNBeElHSjVkR1VnWm05eUlITm9iM0owSUcxbGMzTmhaMlVnYkdWdVozUm9YRzVjYmlBZ0lDQWdJQ0FnTHk4Z2QzSnBkR1VnZEdobElHMWxjM05oWjJVZ1pHbHlaV04wYkhrZ2RHOGdkR2hsSUdKMVptWmxjaUJoYm1RZ2MyVmxJR2h2ZHlCdGRXTm9JSGRoY3lCM2NtbDBkR1Z1WEc0Z0lDQWdJQ0FnSUhaaGNpQnpkR0Z5ZEZCdmN5QTlJSFJvYVhNdWNHOXpPMXh1SUNBZ0lDQWdJQ0JtYmlodlltb3NJSFJvYVhNcE8xeHVJQ0FnSUNBZ0lDQjJZWElnYkdWdUlEMGdkR2hwY3k1d2IzTWdMU0J6ZEdGeWRGQnZjenRjYmx4dUlDQWdJQ0FnSUNCMllYSWdkbUZ5YVc1MFRHVnVJRDFjYmlBZ0lDQWdJQ0FnSUNBZ0lHeGxiaUE4UFNBd2VEZG1JRDhnTVNBNlhHNGdJQ0FnSUNBZ0lDQWdJQ0JzWlc0Z1BEMGdNSGd6Wm1abUlEOGdNaUE2WEc0Z0lDQWdJQ0FnSUNBZ0lDQnNaVzRnUEQwZ01IZ3habVptWm1ZZ1B5QXpJRHBjYmlBZ0lDQWdJQ0FnSUNBZ0lHeGxiaUE4UFNBd2VHWm1abVptWm1ZZ1B5QTBJRG9nVFdGMGFDNWpaV2xzS0UxaGRHZ3ViRzluS0d4bGJpa2dMeUFvVFdGMGFDNU1UaklnS2lBM0tTazdYRzVjYmlBZ0lDQWdJQ0FnTHk4Z2FXWWdNU0JpZVhSbElHbHpiaWQwSUdWdWIzVm5hQ0JtYjNJZ1pXNWpiMlJwYm1jZ2JXVnpjMkZuWlNCc1pXNW5kR2dzSUhOb2FXWjBJSFJvWlNCa1lYUmhJSFJ2SUhSb1pTQnlhV2RvZEZ4dUlDQWdJQ0FnSUNCcFppQW9kbUZ5YVc1MFRHVnVJRDRnTVNrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnZEdocGN5NXlaV0ZzYkc5aktIWmhjbWx1ZEV4bGJpQXRJREVwTzF4dUlDQWdJQ0FnSUNBZ0lDQWdabTl5SUNoMllYSWdhU0E5SUhSb2FYTXVjRzl6SUMwZ01Uc2dhU0ErUFNCemRHRnlkRkJ2Y3pzZ2FTMHRLU0IwYUdsekxtSjFabHRwSUNzZ2RtRnlhVzUwVEdWdUlDMGdNVjBnUFNCMGFHbHpMbUoxWmx0cFhUdGNiaUFnSUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0FnSUM4dklHWnBibUZzYkhrc0lIZHlhWFJsSUhSb1pTQnRaWE56WVdkbElHeGxibWQwYUNCcGJpQjBhR1VnY21WelpYSjJaV1FnY0d4aFkyVWdZVzVrSUhKbGMzUnZjbVVnZEdobElIQnZjMmwwYVc5dVhHNGdJQ0FnSUNBZ0lIUm9hWE11Y0c5eklEMGdjM1JoY25SUWIzTWdMU0F4TzF4dUlDQWdJQ0FnSUNCMGFHbHpMbmR5YVhSbFZtRnlhVzUwS0d4bGJpazdYRzRnSUNBZ0lDQWdJSFJvYVhNdWNHOXpJQ3M5SUd4bGJqdGNiaUFnSUNCOUxGeHVYRzRnSUNBZ2QzSnBkR1ZRWVdOclpXUldZWEpwYm5RNklDQWdablZ1WTNScGIyNG9kR0ZuTENCaGNuSXBJSHNnZEdocGN5NTNjbWwwWlUxbGMzTmhaMlVvZEdGbkxDQjNjbWwwWlZCaFkydGxaRlpoY21sdWRDd2dZWEp5S1RzZ0lDQjlMRnh1SUNBZ0lIZHlhWFJsVUdGamEyVmtVMVpoY21sdWREb2dJR1oxYm1OMGFXOXVLSFJoWnl3Z1lYSnlLU0I3SUhSb2FYTXVkM0pwZEdWTlpYTnpZV2RsS0hSaFp5d2dkM0pwZEdWUVlXTnJaV1JUVm1GeWFXNTBMQ0JoY25JcE95QWdmU3hjYmlBZ0lDQjNjbWwwWlZCaFkydGxaRUp2YjJ4bFlXNDZJQ0JtZFc1amRHbHZiaWgwWVdjc0lHRnljaWtnZXlCMGFHbHpMbmR5YVhSbFRXVnpjMkZuWlNoMFlXY3NJSGR5YVhSbFVHRmphMlZrUW05dmJHVmhiaXdnWVhKeUtUc2dJSDBzWEc0Z0lDQWdkM0pwZEdWUVlXTnJaV1JHYkc5aGREb2dJQ0FnWm5WdVkzUnBiMjRvZEdGbkxDQmhjbklwSUhzZ2RHaHBjeTUzY21sMFpVMWxjM05oWjJVb2RHRm5MQ0IzY21sMFpWQmhZMnRsWkVac2IyRjBMQ0JoY25JcE95QWdJQ0I5TEZ4dUlDQWdJSGR5YVhSbFVHRmphMlZrUkc5MVlteGxPaUFnSUdaMWJtTjBhVzl1S0hSaFp5d2dZWEp5S1NCN0lIUm9hWE11ZDNKcGRHVk5aWE56WVdkbEtIUmhaeXdnZDNKcGRHVlFZV05yWldSRWIzVmliR1VzSUdGeWNpazdJQ0FnZlN4Y2JpQWdJQ0IzY21sMFpWQmhZMnRsWkVacGVHVmtNekk2SUNCbWRXNWpkR2x2YmloMFlXY3NJR0Z5Y2lrZ2V5QjBhR2x6TG5keWFYUmxUV1Z6YzJGblpTaDBZV2NzSUhkeWFYUmxVR0ZqYTJWa1JtbDRaV1F6TWl3Z1lYSnlLVHNnSUgwc1hHNGdJQ0FnZDNKcGRHVlFZV05yWldSVFJtbDRaV1F6TWpvZ1puVnVZM1JwYjI0b2RHRm5MQ0JoY25JcElIc2dkR2hwY3k1M2NtbDBaVTFsYzNOaFoyVW9kR0ZuTENCM2NtbDBaVkJoWTJ0bFpGTkdhWGhsWkRNeUxDQmhjbklwT3lCOUxGeHVJQ0FnSUhkeWFYUmxVR0ZqYTJWa1JtbDRaV1EyTkRvZ0lHWjFibU4wYVc5dUtIUmhaeXdnWVhKeUtTQjdJSFJvYVhNdWQzSnBkR1ZOWlhOellXZGxLSFJoWnl3Z2QzSnBkR1ZRWVdOclpXUkdhWGhsWkRZMExDQmhjbklwT3lBZ2ZTeGNiaUFnSUNCM2NtbDBaVkJoWTJ0bFpGTkdhWGhsWkRZME9pQm1kVzVqZEdsdmJpaDBZV2NzSUdGeWNpa2dleUIwYUdsekxuZHlhWFJsVFdWemMyRm5aU2gwWVdjc0lIZHlhWFJsVUdGamEyVmtVMFpwZUdWa05qUXNJR0Z5Y2lrN0lIMHNYRzVjYmlBZ0lDQjNjbWwwWlVKNWRHVnpSbWxsYkdRNklHWjFibU4wYVc5dUtIUmhaeXdnWW5WbVptVnlLU0I3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVkM0pwZEdWVVlXY29kR0ZuTENCUVltWXVRbmwwWlhNcE8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG5keWFYUmxRbmwwWlhNb1luVm1abVZ5S1R0Y2JpQWdJQ0I5TEZ4dUlDQWdJSGR5YVhSbFJtbDRaV1F6TWtacFpXeGtPaUJtZFc1amRHbHZiaWgwWVdjc0lIWmhiQ2tnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbmR5YVhSbFZHRm5LSFJoWnl3Z1VHSm1Ma1pwZUdWa016SXBPMXh1SUNBZ0lDQWdJQ0IwYUdsekxuZHlhWFJsUm1sNFpXUXpNaWgyWVd3cE8xeHVJQ0FnSUgwc1hHNGdJQ0FnZDNKcGRHVlRSbWw0WldRek1rWnBaV3hrT2lCbWRXNWpkR2x2YmloMFlXY3NJSFpoYkNrZ2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TG5keWFYUmxWR0ZuS0hSaFp5d2dVR0ptTGtacGVHVmtNeklwTzF4dUlDQWdJQ0FnSUNCMGFHbHpMbmR5YVhSbFUwWnBlR1ZrTXpJb2RtRnNLVHRjYmlBZ0lDQjlMRnh1SUNBZ0lIZHlhWFJsUm1sNFpXUTJORVpwWld4a09pQm1kVzVqZEdsdmJpaDBZV2NzSUhaaGJDa2dlMXh1SUNBZ0lDQWdJQ0IwYUdsekxuZHlhWFJsVkdGbktIUmhaeXdnVUdKbUxrWnBlR1ZrTmpRcE8xeHVJQ0FnSUNBZ0lDQjBhR2x6TG5keWFYUmxSbWw0WldRMk5DaDJZV3dwTzF4dUlDQWdJSDBzWEc0Z0lDQWdkM0pwZEdWVFJtbDRaV1EyTkVacFpXeGtPaUJtZFc1amRHbHZiaWgwWVdjc0lIWmhiQ2tnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbmR5YVhSbFZHRm5LSFJoWnl3Z1VHSm1Ma1pwZUdWa05qUXBPMXh1SUNBZ0lDQWdJQ0IwYUdsekxuZHlhWFJsVTBacGVHVmtOalFvZG1Gc0tUdGNiaUFnSUNCOUxGeHVJQ0FnSUhkeWFYUmxWbUZ5YVc1MFJtbGxiR1E2SUdaMWJtTjBhVzl1S0hSaFp5d2dkbUZzS1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11ZDNKcGRHVlVZV2NvZEdGbkxDQlFZbVl1Vm1GeWFXNTBLVHRjYmlBZ0lDQWdJQ0FnZEdocGN5NTNjbWwwWlZaaGNtbHVkQ2gyWVd3cE8xeHVJQ0FnSUgwc1hHNGdJQ0FnZDNKcGRHVlRWbUZ5YVc1MFJtbGxiR1E2SUdaMWJtTjBhVzl1S0hSaFp5d2dkbUZzS1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11ZDNKcGRHVlVZV2NvZEdGbkxDQlFZbVl1Vm1GeWFXNTBLVHRjYmlBZ0lDQWdJQ0FnZEdocGN5NTNjbWwwWlZOV1lYSnBiblFvZG1Gc0tUdGNiaUFnSUNCOUxGeHVJQ0FnSUhkeWFYUmxVM1J5YVc1blJtbGxiR1E2SUdaMWJtTjBhVzl1S0hSaFp5d2djM1J5S1NCN1hHNGdJQ0FnSUNBZ0lIUm9hWE11ZDNKcGRHVlVZV2NvZEdGbkxDQlFZbVl1UW5sMFpYTXBPMXh1SUNBZ0lDQWdJQ0IwYUdsekxuZHlhWFJsVTNSeWFXNW5LSE4wY2lrN1hHNGdJQ0FnZlN4Y2JpQWdJQ0IzY21sMFpVWnNiMkYwUm1sbGJHUTZJR1oxYm1OMGFXOXVLSFJoWnl3Z2RtRnNLU0I3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVkM0pwZEdWVVlXY29kR0ZuTENCUVltWXVSbWw0WldRek1pazdYRzRnSUNBZ0lDQWdJSFJvYVhNdWQzSnBkR1ZHYkc5aGRDaDJZV3dwTzF4dUlDQWdJSDBzWEc0Z0lDQWdkM0pwZEdWRWIzVmliR1ZHYVdWc1pEb2dablZ1WTNScGIyNG9kR0ZuTENCMllXd3BJSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NTNjbWwwWlZSaFp5aDBZV2NzSUZCaVppNUdhWGhsWkRZMEtUdGNiaUFnSUNBZ0lDQWdkR2hwY3k1M2NtbDBaVVJ2ZFdKc1pTaDJZV3dwTzF4dUlDQWdJSDBzWEc0Z0lDQWdkM0pwZEdWQ2IyOXNaV0Z1Um1sbGJHUTZJR1oxYm1OMGFXOXVLSFJoWnl3Z2RtRnNLU0I3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVkM0pwZEdWV1lYSnBiblJHYVdWc1pDaDBZV2NzSUVKdmIyeGxZVzRvZG1Gc0tTazdYRzRnSUNBZ2ZWeHVmVHRjYmx4dVpuVnVZM1JwYjI0Z2QzSnBkR1ZRWVdOclpXUldZWEpwYm5Rb1lYSnlMQ0J3WW1ZcElDQWdleUJtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeWNpNXNaVzVuZEdnN0lHa3JLeWtnY0dKbUxuZHlhWFJsVm1GeWFXNTBLR0Z5Y2x0cFhTazdJQ0FnZlZ4dVpuVnVZM1JwYjI0Z2QzSnBkR1ZRWVdOclpXUlRWbUZ5YVc1MEtHRnljaXdnY0dKbUtTQWdleUJtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeWNpNXNaVzVuZEdnN0lHa3JLeWtnY0dKbUxuZHlhWFJsVTFaaGNtbHVkQ2hoY25KYmFWMHBPeUFnZlZ4dVpuVnVZM1JwYjI0Z2QzSnBkR1ZRWVdOclpXUkdiRzloZENoaGNuSXNJSEJpWmlrZ0lDQWdleUJtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeWNpNXNaVzVuZEdnN0lHa3JLeWtnY0dKbUxuZHlhWFJsUm14dllYUW9ZWEp5VzJsZEtUc2dJQ0FnZlZ4dVpuVnVZM1JwYjI0Z2QzSnBkR1ZRWVdOclpXUkViM1ZpYkdVb1lYSnlMQ0J3WW1ZcElDQWdleUJtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeWNpNXNaVzVuZEdnN0lHa3JLeWtnY0dKbUxuZHlhWFJsUkc5MVlteGxLR0Z5Y2x0cFhTazdJQ0FnZlZ4dVpuVnVZM1JwYjI0Z2QzSnBkR1ZRWVdOclpXUkNiMjlzWldGdUtHRnljaXdnY0dKbUtTQWdleUJtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeWNpNXNaVzVuZEdnN0lHa3JLeWtnY0dKbUxuZHlhWFJsUW05dmJHVmhiaWhoY25KYmFWMHBPeUFnZlZ4dVpuVnVZM1JwYjI0Z2QzSnBkR1ZRWVdOclpXUkdhWGhsWkRNeUtHRnljaXdnY0dKbUtTQWdleUJtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeWNpNXNaVzVuZEdnN0lHa3JLeWtnY0dKbUxuZHlhWFJsUm1sNFpXUXpNaWhoY25KYmFWMHBPeUFnZlZ4dVpuVnVZM1JwYjI0Z2QzSnBkR1ZRWVdOclpXUlRSbWw0WldRek1paGhjbklzSUhCaVppa2dleUJtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeWNpNXNaVzVuZEdnN0lHa3JLeWtnY0dKbUxuZHlhWFJsVTBacGVHVmtNeklvWVhKeVcybGRLVHNnZlZ4dVpuVnVZM1JwYjI0Z2QzSnBkR1ZRWVdOclpXUkdhWGhsWkRZMEtHRnljaXdnY0dKbUtTQWdleUJtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeWNpNXNaVzVuZEdnN0lHa3JLeWtnY0dKbUxuZHlhWFJsUm1sNFpXUTJOQ2hoY25KYmFWMHBPeUFnZlZ4dVpuVnVZM1JwYjI0Z2QzSnBkR1ZRWVdOclpXUlRSbWw0WldRMk5DaGhjbklzSUhCaVppa2dleUJtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeWNpNXNaVzVuZEdnN0lHa3JLeWtnY0dKbUxuZHlhWFJsVTBacGVHVmtOalFvWVhKeVcybGRLVHNnZlZ4dUlsMTkiLCIvKiFcbiAqIHN0cmlwLWNvbW1lbnRzIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9zdHJpcC1jb21tZW50cz5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgSm9uIFNjaGxpbmtlcnQsIGNvbnRyaWJ1dG9ycy5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljJztcblxudmFyIHJlQmxvY2sgPSAnXFxcXC9cXFxcKic7XG52YXIgcmVCbG9ja0lnbm9yZSA9ICdcXFxcL1xcXFwqKD8hXFxcXCo/XFxcXCEpJztcbnZhciByZUJsb2NrRW5kID0gJygufFtcXFxcclxcXFxuXXxcXFxcbikqP1xcXFwqXFxcXC9cXFxcbj9cXFxcbj8nO1xudmFyIHJlTGluZSA9IC8oXnxbXlxcU1xcbl0pKD86XFwvXFwvKShbXFxzXFxTXSs/KSQvZ207XG52YXIgcmVMaW5lSWdub3JlID0gLyhefFteXFxTXFxuXSkoPzpcXC9cXC9bXiFdKShbXFxzXFxTXSs/KSQvZ207XG5cblxuLyoqXG4gKiBTdHJpcCBhbGwgY29tbWVudHNcbiAqXG4gKiB7JT0gZG9jcyhcInN0cmlwXCIpICV9XG4gKlxuICogQHBhcmFtICAge1N0cmluZ30gYHN0cmAgIGZpbGUgY29udGVudHMgb3Igc3RyaW5nIHRvIHN0cmlwLlxuICogQHBhcmFtICAge09iamVjdH0gYG9wdHNgICBvcHRpb25zIGFyZSBwYXNzZWQgdG8gYC5ibG9ja2AsIGFuZCBgLmxpbmVgXG4gKiBAcmV0dXJuICB7U3RyaW5nfSBTdHJpbmcgd2l0aG91dCBjb21tZW50cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIHN0cmlwID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdHIsIG9wdHMpIHtcbiAgcmV0dXJuIHN0ciA/IHN0cmlwLmJsb2NrKHN0cmlwLmxpbmUoc3RyLCBvcHRzKSwgb3B0cykgOiAnJztcbn07XG5cblxuLyoqXG4gKiBTdHJpcCBvbmx5IGJsb2NrIGNvbW1lbnRzLCBvcHRpb25hbGx5IGxlYXZpbmcgcHJvdGVjdGVkIGNvbW1lbnRzXG4gKiAoZS5nLiBgLyohYCkgaW50YWN0LlxuICpcbiAqIHslPSBkb2NzKFwiYmxvY2tcIikgJX1cbiAqXG4gKiBAcGFyYW0gICB7U3RyaW5nfSBgc3RyYCAgZmlsZSBjb250ZW50IG9yIHN0cmluZyB0byBzdHJpcCB0b1xuICogQHBhcmFtICAge09iamVjdH0gYG9wdHNgICBpZiBgc2FmZTp0cnVlYCwgc3RyaXAgb25seSBjb21tZW50cyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoIGAvKiFgIG9yIGAvKiohYFxuICogQHJldHVybiAge1N0cmluZ30gU3RyaW5nIHdpdGhvdXQgYmxvY2sgY29tbWVudHMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnN0cmlwLmJsb2NrID0gZnVuY3Rpb24oc3RyLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB2YXIgcmUgPSBuZXcgUmVnRXhwKHJlQmxvY2sgKyByZUJsb2NrRW5kLCAnZ20nKTtcbiAgaWYob3B0cy5zYWZlKSB7XG4gICAgcmUgPSBuZXcgUmVnRXhwKHJlQmxvY2tJZ25vcmUgKyByZUJsb2NrRW5kLCAnZ20nKTtcbiAgfVxuICByZXR1cm4gc3RyID8gc3RyLnJlcGxhY2UocmUsICcnKSA6ICcnO1xufTtcblxuXG4vKipcbiAqIFN0cmlwIG9ubHkgbGluZSBjb21tZW50c1xuICpcbiAqIHslPSBkb2NzKFwibGluZVwiKSAlfVxuICpcbiAqIEBwYXJhbSAgIHtTdHJpbmd9IGBzdHJgICBmaWxlIGNvbnRlbnQgb3Igc3RyaW5nIHRvIHN0cmlwIHRvXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBgb3B0c2AgIGlmIGBzYWZlOnRydWVgLCBzdHJpcCBhbGwgdGhhdCBub3Qgc3RhcnRzIHdpdGggYC8vIWBcbiAqIEByZXR1cm4gIHtTdHJpbmd9IFN0cmluZyB3aXRob3V0IGxpbmUgY29tbWVudHMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnN0cmlwLmxpbmUgPSBmdW5jdGlvbihzdHIsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHZhciByZSA9IHJlTGluZTtcbiAgaWYob3B0cy5zYWZlKSB7XG4gICAgcmUgPSByZUxpbmVJZ25vcmU7XG4gIH1cbiAgcmV0dXJuIHN0ciA/IHN0ci5yZXBsYWNlKHJlLCAnJykgOiAnJztcbn07XG4iLCIhZnVuY3Rpb24oKSB7XG4gIHZhciB0b3BvanNvbiA9IHtcbiAgICB2ZXJzaW9uOiBcIjEuNi4xOVwiLFxuICAgIG1lc2g6IGZ1bmN0aW9uKHRvcG9sb2d5KSB7IHJldHVybiBvYmplY3QodG9wb2xvZ3ksIG1lc2hBcmNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpOyB9LFxuICAgIG1lc2hBcmNzOiBtZXNoQXJjcyxcbiAgICBtZXJnZTogZnVuY3Rpb24odG9wb2xvZ3kpIHsgcmV0dXJuIG9iamVjdCh0b3BvbG9neSwgbWVyZ2VBcmNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpOyB9LFxuICAgIG1lcmdlQXJjczogbWVyZ2VBcmNzLFxuICAgIGZlYXR1cmU6IGZlYXR1cmVPckNvbGxlY3Rpb24sXG4gICAgbmVpZ2hib3JzOiBuZWlnaGJvcnMsXG4gICAgcHJlc2ltcGxpZnk6IHByZXNpbXBsaWZ5XG4gIH07XG5cbiAgZnVuY3Rpb24gc3RpdGNoQXJjcyh0b3BvbG9neSwgYXJjcykge1xuICAgIHZhciBzdGl0Y2hlZEFyY3MgPSB7fSxcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0ID0ge30sXG4gICAgICAgIGZyYWdtZW50QnlFbmQgPSB7fSxcbiAgICAgICAgZnJhZ21lbnRzID0gW10sXG4gICAgICAgIGVtcHR5SW5kZXggPSAtMTtcblxuICAgIC8vIFN0aXRjaCBlbXB0eSBhcmNzIGZpcnN0LCBzaW5jZSB0aGV5IG1heSBiZSBzdWJzdW1lZCBieSBvdGhlciBhcmNzLlxuICAgIGFyY3MuZm9yRWFjaChmdW5jdGlvbihpLCBqKSB7XG4gICAgICB2YXIgYXJjID0gdG9wb2xvZ3kuYXJjc1tpIDwgMCA/IH5pIDogaV0sIHQ7XG4gICAgICBpZiAoYXJjLmxlbmd0aCA8IDMgJiYgIWFyY1sxXVswXSAmJiAhYXJjWzFdWzFdKSB7XG4gICAgICAgIHQgPSBhcmNzWysrZW1wdHlJbmRleF0sIGFyY3NbZW1wdHlJbmRleF0gPSBpLCBhcmNzW2pdID0gdDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFyY3MuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgZSA9IGVuZHMoaSksXG4gICAgICAgICAgc3RhcnQgPSBlWzBdLFxuICAgICAgICAgIGVuZCA9IGVbMV0sXG4gICAgICAgICAgZiwgZztcblxuICAgICAgaWYgKGYgPSBmcmFnbWVudEJ5RW5kW3N0YXJ0XSkge1xuICAgICAgICBkZWxldGUgZnJhZ21lbnRCeUVuZFtmLmVuZF07XG4gICAgICAgIGYucHVzaChpKTtcbiAgICAgICAgZi5lbmQgPSBlbmQ7XG4gICAgICAgIGlmIChnID0gZnJhZ21lbnRCeVN0YXJ0W2VuZF0pIHtcbiAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2cuc3RhcnRdO1xuICAgICAgICAgIHZhciBmZyA9IGcgPT09IGYgPyBmIDogZi5jb25jYXQoZyk7XG4gICAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2ZnLnN0YXJ0ID0gZi5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2ZnLmVuZCA9IGcuZW5kXSA9IGZnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmRdID0gZjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmID0gZnJhZ21lbnRCeVN0YXJ0W2VuZF0pIHtcbiAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XTtcbiAgICAgICAgZi51bnNoaWZ0KGkpO1xuICAgICAgICBmLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIGlmIChnID0gZnJhZ21lbnRCeUVuZFtzdGFydF0pIHtcbiAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeUVuZFtnLmVuZF07XG4gICAgICAgICAgdmFyIGdmID0gZyA9PT0gZiA/IGYgOiBnLmNvbmNhdChmKTtcbiAgICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZ2Yuc3RhcnQgPSBnLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZ2YuZW5kID0gZi5lbmRdID0gZ2Y7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmLmVuZF0gPSBmO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmID0gW2ldO1xuICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydCA9IHN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmQgPSBlbmRdID0gZjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGVuZHMoaSkge1xuICAgICAgdmFyIGFyYyA9IHRvcG9sb2d5LmFyY3NbaSA8IDAgPyB+aSA6IGldLCBwMCA9IGFyY1swXSwgcDE7XG4gICAgICBpZiAodG9wb2xvZ3kudHJhbnNmb3JtKSBwMSA9IFswLCAwXSwgYXJjLmZvckVhY2goZnVuY3Rpb24oZHApIHsgcDFbMF0gKz0gZHBbMF0sIHAxWzFdICs9IGRwWzFdOyB9KTtcbiAgICAgIGVsc2UgcDEgPSBhcmNbYXJjLmxlbmd0aCAtIDFdO1xuICAgICAgcmV0dXJuIGkgPCAwID8gW3AxLCBwMF0gOiBbcDAsIHAxXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbHVzaChmcmFnbWVudEJ5RW5kLCBmcmFnbWVudEJ5U3RhcnQpIHtcbiAgICAgIGZvciAodmFyIGsgaW4gZnJhZ21lbnRCeUVuZCkge1xuICAgICAgICB2YXIgZiA9IGZyYWdtZW50QnlFbmRba107XG4gICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF07XG4gICAgICAgIGRlbGV0ZSBmLnN0YXJ0O1xuICAgICAgICBkZWxldGUgZi5lbmQ7XG4gICAgICAgIGYuZm9yRWFjaChmdW5jdGlvbihpKSB7IHN0aXRjaGVkQXJjc1tpIDwgMCA/IH5pIDogaV0gPSAxOyB9KTtcbiAgICAgICAgZnJhZ21lbnRzLnB1c2goZik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmx1c2goZnJhZ21lbnRCeUVuZCwgZnJhZ21lbnRCeVN0YXJ0KTtcbiAgICBmbHVzaChmcmFnbWVudEJ5U3RhcnQsIGZyYWdtZW50QnlFbmQpO1xuICAgIGFyY3MuZm9yRWFjaChmdW5jdGlvbihpKSB7IGlmICghc3RpdGNoZWRBcmNzW2kgPCAwID8gfmkgOiBpXSkgZnJhZ21lbnRzLnB1c2goW2ldKTsgfSk7XG5cbiAgICByZXR1cm4gZnJhZ21lbnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVzaEFyY3ModG9wb2xvZ3ksIG8sIGZpbHRlcikge1xuICAgIHZhciBhcmNzID0gW107XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBnZW9tc0J5QXJjID0gW10sXG4gICAgICAgICAgZ2VvbTtcblxuICAgICAgZnVuY3Rpb24gYXJjKGkpIHtcbiAgICAgICAgdmFyIGogPSBpIDwgMCA/IH5pIDogaTtcbiAgICAgICAgKGdlb21zQnlBcmNbal0gfHwgKGdlb21zQnlBcmNbal0gPSBbXSkpLnB1c2goe2k6IGksIGc6IGdlb219KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbGluZShhcmNzKSB7XG4gICAgICAgIGFyY3MuZm9yRWFjaChhcmMpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwb2x5Z29uKGFyY3MpIHtcbiAgICAgICAgYXJjcy5mb3JFYWNoKGxpbmUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZW9tZXRyeShvKSB7XG4gICAgICAgIGlmIChvLnR5cGUgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIpIG8uZ2VvbWV0cmllcy5mb3JFYWNoKGdlb21ldHJ5KTtcbiAgICAgICAgZWxzZSBpZiAoby50eXBlIGluIGdlb21ldHJ5VHlwZSkgZ2VvbSA9IG8sIGdlb21ldHJ5VHlwZVtvLnR5cGVdKG8uYXJjcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBnZW9tZXRyeVR5cGUgPSB7XG4gICAgICAgIExpbmVTdHJpbmc6IGxpbmUsXG4gICAgICAgIE11bHRpTGluZVN0cmluZzogcG9seWdvbixcbiAgICAgICAgUG9seWdvbjogcG9seWdvbixcbiAgICAgICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihhcmNzKSB7IGFyY3MuZm9yRWFjaChwb2x5Z29uKTsgfVxuICAgICAgfTtcblxuICAgICAgZ2VvbWV0cnkobyk7XG5cbiAgICAgIGdlb21zQnlBcmMuZm9yRWFjaChhcmd1bWVudHMubGVuZ3RoIDwgM1xuICAgICAgICAgID8gZnVuY3Rpb24oZ2VvbXMpIHsgYXJjcy5wdXNoKGdlb21zWzBdLmkpOyB9XG4gICAgICAgICAgOiBmdW5jdGlvbihnZW9tcykgeyBpZiAoZmlsdGVyKGdlb21zWzBdLmcsIGdlb21zW2dlb21zLmxlbmd0aCAtIDFdLmcpKSBhcmNzLnB1c2goZ2VvbXNbMF0uaSk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRvcG9sb2d5LmFyY3MubGVuZ3RoOyBpIDwgbjsgKytpKSBhcmNzLnB1c2goaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHt0eXBlOiBcIk11bHRpTGluZVN0cmluZ1wiLCBhcmNzOiBzdGl0Y2hBcmNzKHRvcG9sb2d5LCBhcmNzKX07XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUFyY3ModG9wb2xvZ3ksIG9iamVjdHMpIHtcbiAgICB2YXIgcG9seWdvbnNCeUFyYyA9IHt9LFxuICAgICAgICBwb2x5Z29ucyA9IFtdLFxuICAgICAgICBjb21wb25lbnRzID0gW107XG5cbiAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24obykge1xuICAgICAgaWYgKG8udHlwZSA9PT0gXCJQb2x5Z29uXCIpIHJlZ2lzdGVyKG8uYXJjcyk7XG4gICAgICBlbHNlIGlmIChvLnR5cGUgPT09IFwiTXVsdGlQb2x5Z29uXCIpIG8uYXJjcy5mb3JFYWNoKHJlZ2lzdGVyKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyKHBvbHlnb24pIHtcbiAgICAgIHBvbHlnb24uZm9yRWFjaChmdW5jdGlvbihyaW5nKSB7XG4gICAgICAgIHJpbmcuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICAgICAgICAocG9seWdvbnNCeUFyY1thcmMgPSBhcmMgPCAwID8gfmFyYyA6IGFyY10gfHwgKHBvbHlnb25zQnlBcmNbYXJjXSA9IFtdKSkucHVzaChwb2x5Z29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHBvbHlnb25zLnB1c2gocG9seWdvbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZXJpb3IocmluZykge1xuICAgICAgcmV0dXJuIGNhcnRlc2lhblJpbmdBcmVhKG9iamVjdCh0b3BvbG9neSwge3R5cGU6IFwiUG9seWdvblwiLCBhcmNzOiBbcmluZ119KS5jb29yZGluYXRlc1swXSkgPiAwOyAvLyBUT0RPIGFsbG93IHNwaGVyaWNhbD9cbiAgICB9XG5cbiAgICBwb2x5Z29ucy5mb3JFYWNoKGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgICAgIGlmICghcG9seWdvbi5fKSB7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSBbXSxcbiAgICAgICAgICAgIG5laWdoYm9ycyA9IFtwb2x5Z29uXTtcbiAgICAgICAgcG9seWdvbi5fID0gMTtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgIHdoaWxlIChwb2x5Z29uID0gbmVpZ2hib3JzLnBvcCgpKSB7XG4gICAgICAgICAgY29tcG9uZW50LnB1c2gocG9seWdvbik7XG4gICAgICAgICAgcG9seWdvbi5mb3JFYWNoKGZ1bmN0aW9uKHJpbmcpIHtcbiAgICAgICAgICAgIHJpbmcuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICAgICAgICAgICAgcG9seWdvbnNCeUFyY1thcmMgPCAwID8gfmFyYyA6IGFyY10uZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwb2x5Z29uLl8pIHtcbiAgICAgICAgICAgICAgICAgIHBvbHlnb24uXyA9IDE7XG4gICAgICAgICAgICAgICAgICBuZWlnaGJvcnMucHVzaChwb2x5Z29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgICAgZGVsZXRlIHBvbHlnb24uXztcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk11bHRpUG9seWdvblwiLFxuICAgICAgYXJjczogY29tcG9uZW50cy5tYXAoZnVuY3Rpb24ocG9seWdvbnMpIHtcbiAgICAgICAgdmFyIGFyY3MgPSBbXTtcblxuICAgICAgICAvLyBFeHRyYWN0IHRoZSBleHRlcmlvciAodW5pcXVlKSBhcmNzLlxuICAgICAgICBwb2x5Z29ucy5mb3JFYWNoKGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgICAgICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgICAgICAgcmluZy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgICAgICAgICAgICBpZiAocG9seWdvbnNCeUFyY1thcmMgPCAwID8gfmFyYyA6IGFyY10ubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIGFyY3MucHVzaChhcmMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU3RpdGNoIHRoZSBhcmNzIGludG8gb25lIG9yIG1vcmUgcmluZ3MuXG4gICAgICAgIGFyY3MgPSBzdGl0Y2hBcmNzKHRvcG9sb2d5LCBhcmNzKTtcblxuICAgICAgICAvLyBJZiBtb3JlIHRoYW4gb25lIHJpbmcgaXMgcmV0dXJuZWQsXG4gICAgICAgIC8vIGF0IG1vc3Qgb25lIG9mIHRoZXNlIHJpbmdzIGNhbiBiZSB0aGUgZXh0ZXJpb3I7XG4gICAgICAgIC8vIHRoaXMgZXh0ZXJpb3IgcmluZyBoYXMgdGhlIHNhbWUgd2luZGluZyBvcmRlclxuICAgICAgICAvLyBhcyBhbnkgZXh0ZXJpb3IgcmluZyBpbiB0aGUgb3JpZ2luYWwgcG9seWdvbnMuXG4gICAgICAgIGlmICgobiA9IGFyY3MubGVuZ3RoKSA+IDEpIHtcbiAgICAgICAgICB2YXIgc2duID0gZXh0ZXJpb3IocG9seWdvbnNbMF1bMF0pO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCB0OyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAoc2duID09PSBleHRlcmlvcihhcmNzW2ldKSkge1xuICAgICAgICAgICAgICB0ID0gYXJjc1swXSwgYXJjc1swXSA9IGFyY3NbaV0sIGFyY3NbaV0gPSB0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJjcztcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZlYXR1cmVPckNvbGxlY3Rpb24odG9wb2xvZ3ksIG8pIHtcbiAgICByZXR1cm4gby50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiID8ge1xuICAgICAgdHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICAgICAgZmVhdHVyZXM6IG8uZ2VvbWV0cmllcy5tYXAoZnVuY3Rpb24obykgeyByZXR1cm4gZmVhdHVyZSh0b3BvbG9neSwgbyk7IH0pXG4gICAgfSA6IGZlYXR1cmUodG9wb2xvZ3ksIG8pO1xuICB9XG5cbiAgZnVuY3Rpb24gZmVhdHVyZSh0b3BvbG9neSwgbykge1xuICAgIHZhciBmID0ge1xuICAgICAgdHlwZTogXCJGZWF0dXJlXCIsXG4gICAgICBpZDogby5pZCxcbiAgICAgIHByb3BlcnRpZXM6IG8ucHJvcGVydGllcyB8fCB7fSxcbiAgICAgIGdlb21ldHJ5OiBvYmplY3QodG9wb2xvZ3ksIG8pXG4gICAgfTtcbiAgICBpZiAoby5pZCA9PSBudWxsKSBkZWxldGUgZi5pZDtcbiAgICByZXR1cm4gZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9iamVjdCh0b3BvbG9neSwgbykge1xuICAgIHZhciBhYnNvbHV0ZSA9IHRyYW5zZm9ybUFic29sdXRlKHRvcG9sb2d5LnRyYW5zZm9ybSksXG4gICAgICAgIGFyY3MgPSB0b3BvbG9neS5hcmNzO1xuXG4gICAgZnVuY3Rpb24gYXJjKGksIHBvaW50cykge1xuICAgICAgaWYgKHBvaW50cy5sZW5ndGgpIHBvaW50cy5wb3AoKTtcbiAgICAgIGZvciAodmFyIGEgPSBhcmNzW2kgPCAwID8gfmkgOiBpXSwgayA9IDAsIG4gPSBhLmxlbmd0aCwgcDsgayA8IG47ICsraykge1xuICAgICAgICBwb2ludHMucHVzaChwID0gYVtrXS5zbGljZSgpKTtcbiAgICAgICAgYWJzb2x1dGUocCwgayk7XG4gICAgICB9XG4gICAgICBpZiAoaSA8IDApIHJldmVyc2UocG9pbnRzLCBuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2ludChwKSB7XG4gICAgICBwID0gcC5zbGljZSgpO1xuICAgICAgYWJzb2x1dGUocCwgMCk7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lKGFyY3MpIHtcbiAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYXJjcy5sZW5ndGg7IGkgPCBuOyArK2kpIGFyYyhhcmNzW2ldLCBwb2ludHMpO1xuICAgICAgaWYgKHBvaW50cy5sZW5ndGggPCAyKSBwb2ludHMucHVzaChwb2ludHNbMF0uc2xpY2UoKSk7XG4gICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmcoYXJjcykge1xuICAgICAgdmFyIHBvaW50cyA9IGxpbmUoYXJjcyk7XG4gICAgICB3aGlsZSAocG9pbnRzLmxlbmd0aCA8IDQpIHBvaW50cy5wdXNoKHBvaW50c1swXS5zbGljZSgpKTtcbiAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9seWdvbihhcmNzKSB7XG4gICAgICByZXR1cm4gYXJjcy5tYXAocmluZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VvbWV0cnkobykge1xuICAgICAgdmFyIHQgPSBvLnR5cGU7XG4gICAgICByZXR1cm4gdCA9PT0gXCJHZW9tZXRyeUNvbGxlY3Rpb25cIiA/IHt0eXBlOiB0LCBnZW9tZXRyaWVzOiBvLmdlb21ldHJpZXMubWFwKGdlb21ldHJ5KX1cbiAgICAgICAgICA6IHQgaW4gZ2VvbWV0cnlUeXBlID8ge3R5cGU6IHQsIGNvb3JkaW5hdGVzOiBnZW9tZXRyeVR5cGVbdF0obyl9XG4gICAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIHZhciBnZW9tZXRyeVR5cGUgPSB7XG4gICAgICBQb2ludDogZnVuY3Rpb24obykgeyByZXR1cm4gcG9pbnQoby5jb29yZGluYXRlcyk7IH0sXG4gICAgICBNdWx0aVBvaW50OiBmdW5jdGlvbihvKSB7IHJldHVybiBvLmNvb3JkaW5hdGVzLm1hcChwb2ludCk7IH0sXG4gICAgICBMaW5lU3RyaW5nOiBmdW5jdGlvbihvKSB7IHJldHVybiBsaW5lKG8uYXJjcyk7IH0sXG4gICAgICBNdWx0aUxpbmVTdHJpbmc6IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYXJjcy5tYXAobGluZSk7IH0sXG4gICAgICBQb2x5Z29uOiBmdW5jdGlvbihvKSB7IHJldHVybiBwb2x5Z29uKG8uYXJjcyk7IH0sXG4gICAgICBNdWx0aVBvbHlnb246IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYXJjcy5tYXAocG9seWdvbik7IH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5KG8pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV2ZXJzZShhcnJheSwgbikge1xuICAgIHZhciB0LCBqID0gYXJyYXkubGVuZ3RoLCBpID0gaiAtIG47IHdoaWxlIChpIDwgLS1qKSB0ID0gYXJyYXlbaV0sIGFycmF5W2krK10gPSBhcnJheVtqXSwgYXJyYXlbal0gPSB0O1xuICB9XG5cbiAgZnVuY3Rpb24gYmlzZWN0KGEsIHgpIHtcbiAgICB2YXIgbG8gPSAwLCBoaSA9IGEubGVuZ3RoO1xuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgIGlmIChhW21pZF0gPCB4KSBsbyA9IG1pZCArIDE7XG4gICAgICBlbHNlIGhpID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG87XG4gIH1cblxuICBmdW5jdGlvbiBuZWlnaGJvcnMob2JqZWN0cykge1xuICAgIHZhciBpbmRleGVzQnlBcmMgPSB7fSwgLy8gYXJjIGluZGV4IC0+IGFycmF5IG9mIG9iamVjdCBpbmRleGVzXG4gICAgICAgIG5laWdoYm9ycyA9IG9iamVjdHMubWFwKGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH0pO1xuXG4gICAgZnVuY3Rpb24gbGluZShhcmNzLCBpKSB7XG4gICAgICBhcmNzLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgICAgICBpZiAoYSA8IDApIGEgPSB+YTtcbiAgICAgICAgdmFyIG8gPSBpbmRleGVzQnlBcmNbYV07XG4gICAgICAgIGlmIChvKSBvLnB1c2goaSk7XG4gICAgICAgIGVsc2UgaW5kZXhlc0J5QXJjW2FdID0gW2ldO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9seWdvbihhcmNzLCBpKSB7XG4gICAgICBhcmNzLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7IGxpbmUoYXJjLCBpKTsgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VvbWV0cnkobywgaSkge1xuICAgICAgaWYgKG8udHlwZSA9PT0gXCJHZW9tZXRyeUNvbGxlY3Rpb25cIikgby5nZW9tZXRyaWVzLmZvckVhY2goZnVuY3Rpb24obykgeyBnZW9tZXRyeShvLCBpKTsgfSk7XG4gICAgICBlbHNlIGlmIChvLnR5cGUgaW4gZ2VvbWV0cnlUeXBlKSBnZW9tZXRyeVR5cGVbby50eXBlXShvLmFyY3MsIGkpO1xuICAgIH1cblxuICAgIHZhciBnZW9tZXRyeVR5cGUgPSB7XG4gICAgICBMaW5lU3RyaW5nOiBsaW5lLFxuICAgICAgTXVsdGlMaW5lU3RyaW5nOiBwb2x5Z29uLFxuICAgICAgUG9seWdvbjogcG9seWdvbixcbiAgICAgIE11bHRpUG9seWdvbjogZnVuY3Rpb24oYXJjcywgaSkgeyBhcmNzLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7IHBvbHlnb24oYXJjLCBpKTsgfSk7IH1cbiAgICB9O1xuXG4gICAgb2JqZWN0cy5mb3JFYWNoKGdlb21ldHJ5KTtcblxuICAgIGZvciAodmFyIGkgaW4gaW5kZXhlc0J5QXJjKSB7XG4gICAgICBmb3IgKHZhciBpbmRleGVzID0gaW5kZXhlc0J5QXJjW2ldLCBtID0gaW5kZXhlcy5sZW5ndGgsIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIGZvciAodmFyIGsgPSBqICsgMTsgayA8IG07ICsraykge1xuICAgICAgICAgIHZhciBpaiA9IGluZGV4ZXNbal0sIGlrID0gaW5kZXhlc1trXSwgbjtcbiAgICAgICAgICBpZiAoKG4gPSBuZWlnaGJvcnNbaWpdKVtpID0gYmlzZWN0KG4sIGlrKV0gIT09IGlrKSBuLnNwbGljZShpLCAwLCBpayk7XG4gICAgICAgICAgaWYgKChuID0gbmVpZ2hib3JzW2lrXSlbaSA9IGJpc2VjdChuLCBpaildICE9PSBpaikgbi5zcGxpY2UoaSwgMCwgaWopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5laWdoYm9ycztcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXNpbXBsaWZ5KHRvcG9sb2d5LCB0cmlhbmdsZUFyZWEpIHtcbiAgICB2YXIgYWJzb2x1dGUgPSB0cmFuc2Zvcm1BYnNvbHV0ZSh0b3BvbG9neS50cmFuc2Zvcm0pLFxuICAgICAgICByZWxhdGl2ZSA9IHRyYW5zZm9ybVJlbGF0aXZlKHRvcG9sb2d5LnRyYW5zZm9ybSksXG4gICAgICAgIGhlYXAgPSBtaW5BcmVhSGVhcCgpO1xuXG4gICAgaWYgKCF0cmlhbmdsZUFyZWEpIHRyaWFuZ2xlQXJlYSA9IGNhcnRlc2lhblRyaWFuZ2xlQXJlYTtcblxuICAgIHRvcG9sb2d5LmFyY3MuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICAgIHZhciB0cmlhbmdsZXMgPSBbXSxcbiAgICAgICAgICBtYXhBcmVhID0gMCxcbiAgICAgICAgICB0cmlhbmdsZTtcblxuICAgICAgLy8gVG8gc3RvcmUgZWFjaCBwb2ludOKAmXMgZWZmZWN0aXZlIGFyZWEsIHdlIGNyZWF0ZSBhIG5ldyBhcnJheSByYXRoZXIgdGhhblxuICAgICAgLy8gZXh0ZW5kaW5nIHRoZSBwYXNzZWQtaW4gcG9pbnQgdG8gd29ya2Fyb3VuZCBhIENocm9tZS9WOCBidWcgKGdldHRpbmdcbiAgICAgIC8vIHN0dWNrIGluIHNtaSBtb2RlKS4gRm9yIG1pZHBvaW50cywgdGhlIGluaXRpYWwgZWZmZWN0aXZlIGFyZWEgb2ZcbiAgICAgIC8vIEluZmluaXR5IHdpbGwgYmUgY29tcHV0ZWQgaW4gdGhlIG5leHQgc3RlcC5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYXJjLmxlbmd0aCwgcDsgaSA8IG47ICsraSkge1xuICAgICAgICBwID0gYXJjW2ldO1xuICAgICAgICBhYnNvbHV0ZShhcmNbaV0gPSBbcFswXSwgcFsxXSwgSW5maW5pdHldLCBpKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDEsIG4gPSBhcmMubGVuZ3RoIC0gMTsgaSA8IG47ICsraSkge1xuICAgICAgICB0cmlhbmdsZSA9IGFyYy5zbGljZShpIC0gMSwgaSArIDIpO1xuICAgICAgICB0cmlhbmdsZVsxXVsyXSA9IHRyaWFuZ2xlQXJlYSh0cmlhbmdsZSk7XG4gICAgICAgIHRyaWFuZ2xlcy5wdXNoKHRyaWFuZ2xlKTtcbiAgICAgICAgaGVhcC5wdXNoKHRyaWFuZ2xlKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0cmlhbmdsZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHRyaWFuZ2xlID0gdHJpYW5nbGVzW2ldO1xuICAgICAgICB0cmlhbmdsZS5wcmV2aW91cyA9IHRyaWFuZ2xlc1tpIC0gMV07XG4gICAgICAgIHRyaWFuZ2xlLm5leHQgPSB0cmlhbmdsZXNbaSArIDFdO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodHJpYW5nbGUgPSBoZWFwLnBvcCgpKSB7XG4gICAgICAgIHZhciBwcmV2aW91cyA9IHRyaWFuZ2xlLnByZXZpb3VzLFxuICAgICAgICAgICAgbmV4dCA9IHRyaWFuZ2xlLm5leHQ7XG5cbiAgICAgICAgLy8gSWYgdGhlIGFyZWEgb2YgdGhlIGN1cnJlbnQgcG9pbnQgaXMgbGVzcyB0aGFuIHRoYXQgb2YgdGhlIHByZXZpb3VzIHBvaW50XG4gICAgICAgIC8vIHRvIGJlIGVsaW1pbmF0ZWQsIHVzZSB0aGUgbGF0dGVyJ3MgYXJlYSBpbnN0ZWFkLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGVcbiAgICAgICAgLy8gY3VycmVudCBwb2ludCBjYW5ub3QgYmUgZWxpbWluYXRlZCB3aXRob3V0IGVsaW1pbmF0aW5nIHByZXZpb3VzbHktXG4gICAgICAgIC8vIGVsaW1pbmF0ZWQgcG9pbnRzLlxuICAgICAgICBpZiAodHJpYW5nbGVbMV1bMl0gPCBtYXhBcmVhKSB0cmlhbmdsZVsxXVsyXSA9IG1heEFyZWE7XG4gICAgICAgIGVsc2UgbWF4QXJlYSA9IHRyaWFuZ2xlWzFdWzJdO1xuXG4gICAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICAgIHByZXZpb3VzWzJdID0gdHJpYW5nbGVbMl07XG4gICAgICAgICAgdXBkYXRlKHByZXZpb3VzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgbmV4dC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICAgIG5leHRbMF0gPSB0cmlhbmdsZVswXTtcbiAgICAgICAgICB1cGRhdGUobmV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXJjLmZvckVhY2gocmVsYXRpdmUpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlKHRyaWFuZ2xlKSB7XG4gICAgICBoZWFwLnJlbW92ZSh0cmlhbmdsZSk7XG4gICAgICB0cmlhbmdsZVsxXVsyXSA9IHRyaWFuZ2xlQXJlYSh0cmlhbmdsZSk7XG4gICAgICBoZWFwLnB1c2godHJpYW5nbGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0b3BvbG9neTtcbiAgfTtcblxuICBmdW5jdGlvbiBjYXJ0ZXNpYW5SaW5nQXJlYShyaW5nKSB7XG4gICAgdmFyIGkgPSAtMSxcbiAgICAgICAgbiA9IHJpbmcubGVuZ3RoLFxuICAgICAgICBhLFxuICAgICAgICBiID0gcmluZ1tuIC0gMV0sXG4gICAgICAgIGFyZWEgPSAwO1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGEgPSBiO1xuICAgICAgYiA9IHJpbmdbaV07XG4gICAgICBhcmVhICs9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZWEgKiAuNTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhcnRlc2lhblRyaWFuZ2xlQXJlYSh0cmlhbmdsZSkge1xuICAgIHZhciBhID0gdHJpYW5nbGVbMF0sIGIgPSB0cmlhbmdsZVsxXSwgYyA9IHRyaWFuZ2xlWzJdO1xuICAgIHJldHVybiBNYXRoLmFicygoYVswXSAtIGNbMF0pICogKGJbMV0gLSBhWzFdKSAtIChhWzBdIC0gYlswXSkgKiAoY1sxXSAtIGFbMV0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhcmVBcmVhKGEsIGIpIHtcbiAgICByZXR1cm4gYVsxXVsyXSAtIGJbMV1bMl07XG4gIH1cblxuICBmdW5jdGlvbiBtaW5BcmVhSGVhcCgpIHtcbiAgICB2YXIgaGVhcCA9IHt9LFxuICAgICAgICBhcnJheSA9IFtdLFxuICAgICAgICBzaXplID0gMDtcblxuICAgIGhlYXAucHVzaCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdXAoYXJyYXlbb2JqZWN0Ll8gPSBzaXplXSA9IG9iamVjdCwgc2l6ZSsrKTtcbiAgICAgIHJldHVybiBzaXplO1xuICAgIH07XG5cbiAgICBoZWFwLnBvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHNpemUgPD0gMCkgcmV0dXJuO1xuICAgICAgdmFyIHJlbW92ZWQgPSBhcnJheVswXSwgb2JqZWN0O1xuICAgICAgaWYgKC0tc2l6ZSA+IDApIG9iamVjdCA9IGFycmF5W3NpemVdLCBkb3duKGFycmF5W29iamVjdC5fID0gMF0gPSBvYmplY3QsIDApO1xuICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfTtcblxuICAgIGhlYXAucmVtb3ZlID0gZnVuY3Rpb24ocmVtb3ZlZCkge1xuICAgICAgdmFyIGkgPSByZW1vdmVkLl8sIG9iamVjdDtcbiAgICAgIGlmIChhcnJheVtpXSAhPT0gcmVtb3ZlZCkgcmV0dXJuOyAvLyBpbnZhbGlkIHJlcXVlc3RcbiAgICAgIGlmIChpICE9PSAtLXNpemUpIG9iamVjdCA9IGFycmF5W3NpemVdLCAoY29tcGFyZUFyZWEob2JqZWN0LCByZW1vdmVkKSA8IDAgPyB1cCA6IGRvd24pKGFycmF5W29iamVjdC5fID0gaV0gPSBvYmplY3QsIGkpO1xuICAgICAgcmV0dXJuIGk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHVwKG9iamVjdCwgaSkge1xuICAgICAgd2hpbGUgKGkgPiAwKSB7XG4gICAgICAgIHZhciBqID0gKChpICsgMSkgPj4gMSkgLSAxLFxuICAgICAgICAgICAgcGFyZW50ID0gYXJyYXlbal07XG4gICAgICAgIGlmIChjb21wYXJlQXJlYShvYmplY3QsIHBhcmVudCkgPj0gMCkgYnJlYWs7XG4gICAgICAgIGFycmF5W3BhcmVudC5fID0gaV0gPSBwYXJlbnQ7XG4gICAgICAgIGFycmF5W29iamVjdC5fID0gaSA9IGpdID0gb2JqZWN0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvd24ob2JqZWN0LCBpKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgciA9IChpICsgMSkgPDwgMSxcbiAgICAgICAgICAgIGwgPSByIC0gMSxcbiAgICAgICAgICAgIGogPSBpLFxuICAgICAgICAgICAgY2hpbGQgPSBhcnJheVtqXTtcbiAgICAgICAgaWYgKGwgPCBzaXplICYmIGNvbXBhcmVBcmVhKGFycmF5W2xdLCBjaGlsZCkgPCAwKSBjaGlsZCA9IGFycmF5W2ogPSBsXTtcbiAgICAgICAgaWYgKHIgPCBzaXplICYmIGNvbXBhcmVBcmVhKGFycmF5W3JdLCBjaGlsZCkgPCAwKSBjaGlsZCA9IGFycmF5W2ogPSByXTtcbiAgICAgICAgaWYgKGogPT09IGkpIGJyZWFrO1xuICAgICAgICBhcnJheVtjaGlsZC5fID0gaV0gPSBjaGlsZDtcbiAgICAgICAgYXJyYXlbb2JqZWN0Ll8gPSBpID0gal0gPSBvYmplY3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYXA7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2Zvcm1BYnNvbHV0ZSh0cmFuc2Zvcm0pIHtcbiAgICBpZiAoIXRyYW5zZm9ybSkgcmV0dXJuIG5vb3A7XG4gICAgdmFyIHgwLFxuICAgICAgICB5MCxcbiAgICAgICAga3ggPSB0cmFuc2Zvcm0uc2NhbGVbMF0sXG4gICAgICAgIGt5ID0gdHJhbnNmb3JtLnNjYWxlWzFdLFxuICAgICAgICBkeCA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMF0sXG4gICAgICAgIGR5ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVsxXTtcbiAgICByZXR1cm4gZnVuY3Rpb24ocG9pbnQsIGkpIHtcbiAgICAgIGlmICghaSkgeDAgPSB5MCA9IDA7XG4gICAgICBwb2ludFswXSA9ICh4MCArPSBwb2ludFswXSkgKiBreCArIGR4O1xuICAgICAgcG9pbnRbMV0gPSAoeTAgKz0gcG9pbnRbMV0pICoga3kgKyBkeTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtUmVsYXRpdmUodHJhbnNmb3JtKSB7XG4gICAgaWYgKCF0cmFuc2Zvcm0pIHJldHVybiBub29wO1xuICAgIHZhciB4MCxcbiAgICAgICAgeTAsXG4gICAgICAgIGt4ID0gdHJhbnNmb3JtLnNjYWxlWzBdLFxuICAgICAgICBreSA9IHRyYW5zZm9ybS5zY2FsZVsxXSxcbiAgICAgICAgZHggPSB0cmFuc2Zvcm0udHJhbnNsYXRlWzBdLFxuICAgICAgICBkeSA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMV07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBvaW50LCBpKSB7XG4gICAgICBpZiAoIWkpIHgwID0geTAgPSAwO1xuICAgICAgdmFyIHgxID0gKHBvaW50WzBdIC0gZHgpIC8ga3ggfCAwLFxuICAgICAgICAgIHkxID0gKHBvaW50WzFdIC0gZHkpIC8ga3kgfCAwO1xuICAgICAgcG9pbnRbMF0gPSB4MSAtIHgwO1xuICAgICAgcG9pbnRbMV0gPSB5MSAtIHkwO1xuICAgICAgeDAgPSB4MTtcbiAgICAgIHkwID0geTE7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKHRvcG9qc29uKTtcbiAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSB0b3BvanNvbjtcbiAgZWxzZSB0aGlzLnRvcG9qc29uID0gdG9wb2pzb247XG59KCk7XG4iLCJtb2R1bGUuZXhwb3J0cy5WZWN0b3JUaWxlID0gcmVxdWlyZSgnLi9saWIvdmVjdG9ydGlsZS5qcycpO1xubW9kdWxlLmV4cG9ydHMuVmVjdG9yVGlsZUZlYXR1cmUgPSByZXF1aXJlKCcuL2xpYi92ZWN0b3J0aWxlZmVhdHVyZS5qcycpO1xubW9kdWxlLmV4cG9ydHMuVmVjdG9yVGlsZUxheWVyID0gcmVxdWlyZSgnLi9saWIvdmVjdG9ydGlsZWxheWVyLmpzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWZWN0b3JUaWxlTGF5ZXIgPSByZXF1aXJlKCcuL3ZlY3RvcnRpbGVsYXllcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGU7XG5cbmZ1bmN0aW9uIFZlY3RvclRpbGUocGJmLCBlbmQpIHtcbiAgICB0aGlzLmxheWVycyA9IHBiZi5yZWFkRmllbGRzKHJlYWRUaWxlLCB7fSwgZW5kKTtcbn1cblxuZnVuY3Rpb24gcmVhZFRpbGUodGFnLCBsYXllcnMsIHBiZikge1xuICAgIGlmICh0YWcgPT09IDMpIHtcbiAgICAgICAgdmFyIGxheWVyID0gbmV3IFZlY3RvclRpbGVMYXllcihwYmYsIHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zKTtcbiAgICAgICAgaWYgKGxheWVyLmxlbmd0aCkgbGF5ZXJzW2xheWVyLm5hbWVdID0gbGF5ZXI7XG4gICAgfVxufVxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmVjdG9yVGlsZUZlYXR1cmU7XG5cbmZ1bmN0aW9uIFZlY3RvclRpbGVGZWF0dXJlKHBiZiwgZW5kLCBleHRlbnQsIGtleXMsIHZhbHVlcykge1xuICAgIC8vIFB1YmxpY1xuICAgIHRoaXMucHJvcGVydGllcyA9IHt9O1xuICAgIHRoaXMuZXh0ZW50ID0gZXh0ZW50O1xuICAgIHRoaXMudHlwZSA9IDA7XG5cbiAgICAvLyBQcml2YXRlXG4gICAgdGhpcy5fcGJmID0gcGJmO1xuICAgIHRoaXMuX2dlb21ldHJ5ID0gLTE7XG4gICAgdGhpcy5fa2V5cyA9IGtleXM7XG4gICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuXG4gICAgcGJmLnJlYWRGaWVsZHMocmVhZEZlYXR1cmUsIHRoaXMsIGVuZCk7XG59XG5cbmZ1bmN0aW9uIHJlYWRGZWF0dXJlKHRhZywgZmVhdHVyZSwgcGJmKSB7XG4gICAgaWYgKHRhZyA9PSAxKSBmZWF0dXJlLl9pZCA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09IDIpIHJlYWRUYWcocGJmLCBmZWF0dXJlKTtcbiAgICBlbHNlIGlmICh0YWcgPT0gMykgZmVhdHVyZS50eXBlID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT0gNCkgZmVhdHVyZS5fZ2VvbWV0cnkgPSBwYmYucG9zO1xufVxuXG5mdW5jdGlvbiByZWFkVGFnKHBiZiwgZmVhdHVyZSkge1xuICAgIHZhciBlbmQgPSBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcztcblxuICAgIHdoaWxlIChwYmYucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhciBrZXkgPSBmZWF0dXJlLl9rZXlzW3BiZi5yZWFkVmFyaW50KCldLFxuICAgICAgICAgICAgdmFsdWUgPSBmZWF0dXJlLl92YWx1ZXNbcGJmLnJlYWRWYXJpbnQoKV07XG4gICAgICAgIGZlYXR1cmUucHJvcGVydGllc1trZXldID0gdmFsdWU7XG4gICAgfVxufVxuXG5WZWN0b3JUaWxlRmVhdHVyZS50eXBlcyA9IFsnVW5rbm93bicsICdQb2ludCcsICdMaW5lU3RyaW5nJywgJ1BvbHlnb24nXTtcblxuVmVjdG9yVGlsZUZlYXR1cmUucHJvdG90eXBlLmxvYWRHZW9tZXRyeSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYmYgPSB0aGlzLl9wYmY7XG4gICAgcGJmLnBvcyA9IHRoaXMuX2dlb21ldHJ5O1xuXG4gICAgdmFyIGVuZCA9IHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zLFxuICAgICAgICBjbWQgPSAxLFxuICAgICAgICBsZW5ndGggPSAwLFxuICAgICAgICB4ID0gMCxcbiAgICAgICAgeSA9IDAsXG4gICAgICAgIGxpbmVzID0gW10sXG4gICAgICAgIGxpbmU7XG5cbiAgICB3aGlsZSAocGJmLnBvcyA8IGVuZCkge1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNtZExlbiA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgICAgICAgICBjbWQgPSBjbWRMZW4gJiAweDc7XG4gICAgICAgICAgICBsZW5ndGggPSBjbWRMZW4gPj4gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aC0tO1xuXG4gICAgICAgIGlmIChjbWQgPT09IDEgfHwgY21kID09PSAyKSB7XG4gICAgICAgICAgICB4ICs9IHBiZi5yZWFkU1ZhcmludCgpO1xuICAgICAgICAgICAgeSArPSBwYmYucmVhZFNWYXJpbnQoKTtcblxuICAgICAgICAgICAgaWYgKGNtZCA9PT0gMSkgeyAvLyBtb3ZlVG9cbiAgICAgICAgICAgICAgICBpZiAobGluZSkgbGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmUucHVzaChuZXcgUG9pbnQoeCwgeSkpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY21kID09PSA3KSB7XG4gICAgICAgICAgICBsaW5lLnB1c2gobGluZVswXS5jbG9uZSgpKTsgLy8gY2xvc2VQb2x5Z29uXG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBjb21tYW5kICcgKyBjbWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxpbmUpIGxpbmVzLnB1c2gobGluZSk7XG5cbiAgICByZXR1cm4gbGluZXM7XG59O1xuXG5WZWN0b3JUaWxlRmVhdHVyZS5wcm90b3R5cGUuYmJveCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYmYgPSB0aGlzLl9wYmY7XG4gICAgcGJmLnBvcyA9IHRoaXMuX2dlb21ldHJ5O1xuXG4gICAgdmFyIGVuZCA9IHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zLFxuICAgICAgICBjbWQgPSAxLFxuICAgICAgICBsZW5ndGggPSAwLFxuICAgICAgICB4ID0gMCxcbiAgICAgICAgeSA9IDAsXG4gICAgICAgIHgxID0gSW5maW5pdHksXG4gICAgICAgIHgyID0gLUluZmluaXR5LFxuICAgICAgICB5MSA9IEluZmluaXR5LFxuICAgICAgICB5MiA9IC1JbmZpbml0eTtcblxuICAgIHdoaWxlIChwYmYucG9zIDwgZW5kKSB7XG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY21kTGVuID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgICAgIGNtZCA9IGNtZExlbiAmIDB4NztcbiAgICAgICAgICAgIGxlbmd0aCA9IGNtZExlbiA+PiAzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoLS07XG5cbiAgICAgICAgaWYgKGNtZCA9PT0gMSB8fCBjbWQgPT09IDIpIHtcbiAgICAgICAgICAgIHggKz0gcGJmLnJlYWRTVmFyaW50KCk7XG4gICAgICAgICAgICB5ICs9IHBiZi5yZWFkU1ZhcmludCgpO1xuICAgICAgICAgICAgaWYgKHggPCB4MSkgeDEgPSB4O1xuICAgICAgICAgICAgaWYgKHggPiB4MikgeDIgPSB4O1xuICAgICAgICAgICAgaWYgKHkgPCB5MSkgeTEgPSB5O1xuICAgICAgICAgICAgaWYgKHkgPiB5MikgeTIgPSB5O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY21kICE9PSA3KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY29tbWFuZCAnICsgY21kKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbeDEsIHkxLCB4MiwgeTJdO1xufTtcblxuVmVjdG9yVGlsZUZlYXR1cmUucHJvdG90eXBlLnRvR2VvSlNPTiA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuZXh0ZW50ICogTWF0aC5wb3coMiwgeiksXG4gICAgICAgIHgwID0gdGhpcy5leHRlbnQgKiB4LFxuICAgICAgICB5MCA9IHRoaXMuZXh0ZW50ICogeSxcbiAgICAgICAgY29vcmRzID0gdGhpcy5sb2FkR2VvbWV0cnkoKSxcbiAgICAgICAgdHlwZSA9IFZlY3RvclRpbGVGZWF0dXJlLnR5cGVzW3RoaXMudHlwZV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGluZSA9IGNvb3Jkc1tpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgcCA9IGxpbmVbal0sIHkyID0gMTgwIC0gKHAueSArIHkwKSAqIDM2MCAvIHNpemU7XG4gICAgICAgICAgICBsaW5lW2pdID0gW1xuICAgICAgICAgICAgICAgIChwLnggKyB4MCkgKiAzNjAgLyBzaXplIC0gMTgwLFxuICAgICAgICAgICAgICAgIDM2MCAvIE1hdGguUEkgKiBNYXRoLmF0YW4oTWF0aC5leHAoeTIgKiBNYXRoLlBJIC8gMTgwKSkgLSA5MFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnUG9pbnQnICYmIGNvb3Jkcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29vcmRzID0gY29vcmRzWzBdWzBdO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1BvaW50Jykge1xuICAgICAgICBjb29yZHMgPSBjb29yZHNbMF07XG4gICAgICAgIHR5cGUgPSAnTXVsdGlQb2ludCc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTGluZVN0cmluZycgJiYgY29vcmRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb29yZHMgPSBjb29yZHNbMF07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTGluZVN0cmluZycpIHtcbiAgICAgICAgdHlwZSA9ICdNdWx0aUxpbmVTdHJpbmcnO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZHNcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcGVydGllczogdGhpcy5wcm9wZXJ0aWVzXG4gICAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWZWN0b3JUaWxlRmVhdHVyZSA9IHJlcXVpcmUoJy4vdmVjdG9ydGlsZWZlYXR1cmUuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3JUaWxlTGF5ZXI7XG5cbmZ1bmN0aW9uIFZlY3RvclRpbGVMYXllcihwYmYsIGVuZCkge1xuICAgIC8vIFB1YmxpY1xuICAgIHRoaXMudmVyc2lvbiA9IDE7XG4gICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICB0aGlzLmV4dGVudCA9IDQwOTY7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUHJpdmF0ZVxuICAgIHRoaXMuX3BiZiA9IHBiZjtcbiAgICB0aGlzLl9rZXlzID0gW107XG4gICAgdGhpcy5fdmFsdWVzID0gW107XG4gICAgdGhpcy5fZmVhdHVyZXMgPSBbXTtcblxuICAgIHBiZi5yZWFkRmllbGRzKHJlYWRMYXllciwgdGhpcywgZW5kKTtcblxuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5fZmVhdHVyZXMubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiByZWFkTGF5ZXIodGFnLCBsYXllciwgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMTUpIGxheWVyLnZlcnNpb24gPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMSkgbGF5ZXIubmFtZSA9IHBiZi5yZWFkU3RyaW5nKCk7XG4gICAgZWxzZSBpZiAodGFnID09PSA1KSBsYXllci5leHRlbnQgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMikgbGF5ZXIuX2ZlYXR1cmVzLnB1c2gocGJmLnBvcyk7XG4gICAgZWxzZSBpZiAodGFnID09PSAzKSBsYXllci5fa2V5cy5wdXNoKHBiZi5yZWFkU3RyaW5nKCkpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNCkgbGF5ZXIuX3ZhbHVlcy5wdXNoKHJlYWRWYWx1ZU1lc3NhZ2UocGJmKSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRWYWx1ZU1lc3NhZ2UocGJmKSB7XG4gICAgdmFyIHZhbHVlID0gbnVsbCxcbiAgICAgICAgZW5kID0gcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3M7XG5cbiAgICB3aGlsZSAocGJmLnBvcyA8IGVuZCkge1xuICAgICAgICB2YXIgdGFnID0gcGJmLnJlYWRWYXJpbnQoKSA+PiAzO1xuXG4gICAgICAgIHZhbHVlID0gdGFnID09PSAxID8gcGJmLnJlYWRTdHJpbmcoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDIgPyBwYmYucmVhZEZsb2F0KCkgOlxuICAgICAgICAgICAgdGFnID09PSAzID8gcGJmLnJlYWREb3VibGUoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDQgPyBwYmYucmVhZFZhcmludDY0KCkgOlxuICAgICAgICAgICAgdGFnID09PSA1ID8gcGJmLnJlYWRWYXJpbnQoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDYgPyBwYmYucmVhZFNWYXJpbnQoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDcgPyBwYmYucmVhZEJvb2xlYW4oKSA6IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyByZXR1cm4gZmVhdHVyZSBgaWAgZnJvbSB0aGlzIGxheWVyIGFzIGEgYFZlY3RvclRpbGVGZWF0dXJlYFxuVmVjdG9yVGlsZUxheWVyLnByb3RvdHlwZS5mZWF0dXJlID0gZnVuY3Rpb24oaSkge1xuICAgIGlmIChpIDwgMCB8fCBpID49IHRoaXMuX2ZlYXR1cmVzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdmZWF0dXJlIGluZGV4IG91dCBvZiBib3VuZHMnKTtcblxuICAgIHRoaXMuX3BiZi5wb3MgPSB0aGlzLl9mZWF0dXJlc1tpXTtcblxuICAgIHZhciBlbmQgPSB0aGlzLl9wYmYucmVhZFZhcmludCgpICsgdGhpcy5fcGJmLnBvcztcbiAgICByZXR1cm4gbmV3IFZlY3RvclRpbGVGZWF0dXJlKHRoaXMuX3BiZiwgZW5kLCB0aGlzLmV4dGVudCwgdGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG5cbmZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG59XG5cblBvaW50LnByb3RvdHlwZSA9IHtcbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpOyB9LFxuXG4gICAgYWRkOiAgICAgZnVuY3Rpb24ocCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQocCk7ICAgICB9LFxuICAgIHN1YjogICAgIGZ1bmN0aW9uKHApIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fc3ViKHApOyAgICAgfSxcbiAgICBtdWx0OiAgICBmdW5jdGlvbihrKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX211bHQoayk7ICAgIH0sXG4gICAgZGl2OiAgICAgZnVuY3Rpb24oaykgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9kaXYoayk7ICAgICB9LFxuICAgIHJvdGF0ZTogIGZ1bmN0aW9uKGEpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm90YXRlKGEpOyAgfSxcbiAgICBtYXRNdWx0OiBmdW5jdGlvbihtKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX21hdE11bHQobSk7IH0sXG4gICAgdW5pdDogICAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3VuaXQoKTsgfSxcbiAgICBwZXJwOiAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcGVycCgpOyB9LFxuICAgIHJvdW5kOiAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpOyB9LFxuXG4gICAgbWFnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gcC54ICYmXG4gICAgICAgICAgICAgICB0aGlzLnkgPT09IHAueTtcbiAgICB9LFxuXG4gICAgZGlzdDogZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdFNxcihwKSk7XG4gICAgfSxcblxuICAgIGRpc3RTcXI6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdmFyIGR4ID0gcC54IC0gdGhpcy54LFxuICAgICAgICAgICAgZHkgPSBwLnkgLSB0aGlzLnk7XG4gICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICB9LFxuXG4gICAgYW5nbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnksIHRoaXMueCk7XG4gICAgfSxcblxuICAgIGFuZ2xlVG86IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55IC0gYi55LCB0aGlzLnggLSBiLngpO1xuICAgIH0sXG5cbiAgICBhbmdsZVdpdGg6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5nbGVXaXRoU2VwKGIueCwgYi55KTtcbiAgICB9LFxuXG4gICAgLy8gRmluZCB0aGUgYW5nbGUgb2YgdGhlIHR3byB2ZWN0b3JzLCBzb2x2aW5nIHRoZSBmb3JtdWxhIGZvciB0aGUgY3Jvc3MgcHJvZHVjdCBhIHggYiA9IHxhfHxifHNpbijOuCkgZm9yIM64LlxuICAgIGFuZ2xlV2l0aFNlcDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMihcbiAgICAgICAgICAgIHRoaXMueCAqIHkgLSB0aGlzLnkgKiB4LFxuICAgICAgICAgICAgdGhpcy54ICogeCArIHRoaXMueSAqIHkpO1xuICAgIH0sXG5cbiAgICBfbWF0TXVsdDogZnVuY3Rpb24obSkge1xuICAgICAgICB2YXIgeCA9IG1bMF0gKiB0aGlzLnggKyBtWzFdICogdGhpcy55LFxuICAgICAgICAgICAgeSA9IG1bMl0gKiB0aGlzLnggKyBtWzNdICogdGhpcy55O1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2FkZDogZnVuY3Rpb24ocCkge1xuICAgICAgICB0aGlzLnggKz0gcC54O1xuICAgICAgICB0aGlzLnkgKz0gcC55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3N1YjogZnVuY3Rpb24ocCkge1xuICAgICAgICB0aGlzLnggLT0gcC54O1xuICAgICAgICB0aGlzLnkgLT0gcC55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX211bHQ6IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgdGhpcy54ICo9IGs7XG4gICAgICAgIHRoaXMueSAqPSBrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2RpdjogZnVuY3Rpb24oaykge1xuICAgICAgICB0aGlzLnggLz0gaztcbiAgICAgICAgdGhpcy55IC89IGs7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfdW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2Rpdih0aGlzLm1hZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9wZXJwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgICAgIHRoaXMueSA9IHRoaXMueDtcbiAgICAgICAgdGhpcy54ID0gLXk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcm90YXRlOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgeCA9IGNvcyAqIHRoaXMueCAtIHNpbiAqIHRoaXMueSxcbiAgICAgICAgICAgIHkgPSBzaW4gKiB0aGlzLnggKyBjb3MgKiB0aGlzLnk7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcm91bmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XG4gICAgICAgIHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuLy8gY29uc3RydWN0cyBQb2ludCBmcm9tIGFuIGFycmF5IGlmIG5lY2Vzc2FyeVxuUG9pbnQuY29udmVydCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChhWzBdLCBhWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59O1xuIiwiLypnbG9iYWwgQ2FtZXJhICovXG5pbXBvcnQgR2VvIGZyb20gJy4vZ2VvJztcbmltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzL3V0aWxzJztcbmltcG9ydCBTaGFkZXJQcm9ncmFtIGZyb20gJy4vZ2wvc2hhZGVyX3Byb2dyYW0nO1xuXG5pbXBvcnQgZ2xNYXRyaXggZnJvbSAnZ2wtbWF0cml4JztcbnZhciBtYXQ0ID0gZ2xNYXRyaXgubWF0NDtcbnZhciB2ZWMzID0gZ2xNYXRyaXgudmVjMztcblxuLy8gQWJzdHJhY3QgYmFzZSBjbGFzc1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FtZXJhIHtcblxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHNjZW5lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy56b29tID0gb3B0aW9ucy56b29tO1xuICAgICAgICAvLyB0aGlzLnVwZGF0ZVNjZW5lKCk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgY2FtZXJhIGJ5IHR5cGUgbmFtZSwgZmFjdG9yeS1zdHlsZVxuICAgIHN0YXRpYyBjcmVhdGUobmFtZSwgc2NlbmUsIGNvbmZpZykge1xuICAgICAgICBzd2l0Y2ggKGNvbmZpZy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdpc29tZXRyaWMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSXNvbWV0cmljQ2FtZXJhKG5hbWUsIHNjZW5lLCBjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnZmxhdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbGF0Q2FtZXJhKG5hbWUsIHNjZW5lLCBjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAncGVyc3BlY3RpdmUnOlxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKG5hbWUsIHNjZW5lLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIG1ldGhvZCBjYWxsZWQgb25jZSBwZXIgZnJhbWVcbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIC8vIHRoaXMudXBkYXRlU2NlbmUoKTtcbiAgICB9XG5cbiAgICAvLyBDYWxsZWQgb25jZSBwZXIgZnJhbWUgcGVyIHByb2dyYW0gKGUuZy4gZm9yIG1haW4gcmVuZGVyIHBhc3MsIHRoZW4gZm9yIGVhY2ggYWRkaXRpb25hbCBwYXNzIGZvciBmZWF0dXJlIHNlbGVjdGlvbiwgZXRjLilcbiAgICBzZXR1cFByb2dyYW0ocHJvZ3JhbSkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICBTeW5jIGNhbWVyYSBwb3NpdGlvbiBhbmQvb3Igem9vbSB0byBzY2VuZVxuICAgICAgICBwb3NpdGlvbjogW2xhdCwgbG5nXSBvciBbbGF0LCBsbmcsIHpvb21dXG4gICAgICAgIHpvb206IHpvb21cbiAgICAqL1xuICAgIHVwZGF0ZVNjZW5lICgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gfHwgdGhpcy56b29tKSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB2aWV3ID0geyBsbmc6IHRoaXMucG9zaXRpb25bMF0sIGxhdDogdGhpcy5wb3NpdGlvblsxXSwgem9vbTogdGhpcy5wb3NpdGlvblsyXSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuem9vbSkge1xuICAgICAgICAgICAgICAgIHZpZXcuem9vbSA9IHRoaXMuem9vbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2NlbmUuc2V0Vmlldyh2aWV3KTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG4vKipcbiAgICBQZXJzcGVjdGl2ZSBtYXRyaXggcHJvamVjdGlvblxuXG4gICAgVGhpcyBpcyBhIHNwZWNpYWxpemVkIHBlcnNwZWN0aXZlIGNhbWVyYSB0aGF0LCBnaXZlbiBhIGRlc2lyZWQgY2FtZXJhIGZvY2FsIGxlbmd0aCAod2hpY2ggY2FuIGFsc28gdmFyeSBieSB6b29tIGxldmVsKSxcbiAgICBjb25zdHJhaW5zIHRoZSBjYW1lcmEgaGVpZ2h0IGFib3ZlIHRoZSBncm91bmQgcGxhbmUgc3VjaCB0aGF0IHRoZSBkaXNwbGF5ZWQgZ3JvdW5kIGFyZWEgb2YgdGhlIG1hcCBtYXRjaGVzIHRoYXQgb2ZcbiAgICBhIHRyYWRpdGlvbmFsIHdlYiBtZXJjYXRvciBtYXAuIFRoaXMgbWVhbnMgeW91IGNhbiBzZXQgdGhlIGNhbWVyYSBsb2NhdGlvbiBieSBbbGF0LCBsbmcsIHpvb21dIGFzIHlvdSB3b3VsZCBhIHR5cGljYWxcbiAgICB3ZWIgbWVyY2F0b3IgbWFwLCB0aGVuIGFkanVzdCB0aGUgZm9jYWwgbGVuZ3RoIGFzIG5lZWRlZC5cblxuICAgIFZhbmlzaGluZyBwb2ludCBjYW4gYWxzbyBiZSBhZGp1c3RlZCB0byBhY2hpZXZlIGRpZmZlcmVudCBcInZpZXdpbmcgYW5nbGVzXCIsIGUuZy4gaW5zdGVhZCBvZiBsb29raW5nIHN0cmFpZ2h0IGRvd24gaW50b1xuICAgIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0LCB0aGUgY2FtZXJhIGFwcGVhcnMgdG8gYmUgdGlsdGVkIGF0IGFuIGFuZ2xlLiBGb3IgZXhhbXBsZTpcblxuICAgIFswLCAwXSA9IGxvb2tpbmcgdG93YXJkcyBjZW50ZXIgb2Ygdmlld3BvcnRcbiAgICBbLTI1MCwgLTI1MF0gPSBsb29raW5nIDI1MCBwaXhlbHMgZnJvbSB0aGUgdmlld3BvcnQgY2VudGVyIHRvIHRoZSBsb3dlci1sZWZ0IGNvcm5lclxuICAgIFs0MDAsIDBdID0gbG9va2luZyA0MDAgcGl4ZWxzIHRvIHRoZSByaWdodCBvZiB0aGUgdmlld3BvcnQgY2VudGVyXG4qL1xuY2xhc3MgUGVyc3BlY3RpdmVDYW1lcmEgZXh0ZW5kcyBDYW1lcmEge1xuXG4gICAgY29uc3RydWN0b3IobmFtZSwgc2NlbmUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcihuYW1lLCBzY2VuZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdwZXJzcGVjdGl2ZSc7XG5cbiAgICAgICAgLy8gYSBzaW5nbGUgc2NhbGFyLCBvciBwYWlycyBvZiBzdG9wcyBtYXBwaW5nIHpvb20gbGV2ZWxzLCBlLmcuIFt6b29tLCBmb2NhbCBsZW5ndGhdXG4gICAgICAgIHRoaXMuZm9jYWxfbGVuZ3RoID0gb3B0aW9ucy5mb2NhbF9sZW5ndGg7XG4gICAgICAgIHRoaXMuZm92ID0gb3B0aW9ucy5mb3Y7XG4gICAgICAgIGlmICghdGhpcy5mb2NhbF9sZW5ndGggJiYgIXRoaXMuZm92KSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IGZvY2FsIGxlbmd0aCByYW5nZXMgYnkgem9vbVxuICAgICAgICAgICAgdGhpcy5mb2NhbF9sZW5ndGggPSBbWzE2LCAyXSwgWzE3LCAyLjVdLCBbMTgsIDNdLCBbMTksIDRdLCBbMjAsIDZdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmFuaXNoaW5nX3BvaW50ID0gb3B0aW9ucy52YW5pc2hpbmdfcG9pbnQgfHwgWzAsIDBdOyAvLyBbeCwgeV1cbiAgICAgICAgdGhpcy52YW5pc2hpbmdfcG9pbnRfc2tldyA9IFtdO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb25fbWV0ZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy52aWV3TWF0cml4ID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuXG4gICAgICAgIC8vICdjYW1lcmEnIGlzIHRoZSBuYW1lIG9mIHRoZSBzaGFkZXIgYmxvY2ssIGUuZy4gZGV0ZXJtaW5lcyB3aGVyZSBpbiB0aGUgc2hhZGVyIHRoaXMgY29kZSBpcyBpbmplY3RlZFxuICAgICAgICBTaGFkZXJQcm9ncmFtLnJlcGxhY2VCbG9jaygnY2FtZXJhJywgYFxuICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVfcHJvamVjdGlvbjtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjMyB1X2V5ZTtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjMiB1X3ZhbmlzaGluZ19wb2ludDtcblxuICAgICAgICAgICAgdm9pZCBjYW1lcmFQcm9qZWN0aW9uIChpbm91dCB2ZWM0IHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSB1X3Byb2plY3Rpb24gKiBwb3NpdGlvbjtcbiAgICAgICAgICAgIH1gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQ29uc3RyYWlucyB0aGUgY2FtZXJhIHNvIHRoYXQgdGhlIHZpZXdhYmxlIGFyZWEgbWF0Y2hlcyBnaXZlbiB0aGUgdmlld3BvcnQgaGVpZ2h0XG4gICAgLy8gKGluIHdvcmxkIHNwYWNlLCBlLmcuIG1ldGVycyksIGdpdmVuIGVpdGhlciBhIGNhbWVyYSBmb2NhbCBsZW5ndGggb3IgZmllbGQtb2Ytdmlld1xuICAgIC8vIChmb2NhbCBsZW5ndGggaXMgdXNlZCBpZiBib3RoIGFyZSBwYXNzZWQpLlxuICAgIGNvbnN0cmFpbkNhbWVyYSh7IHZpZXdfaGVpZ2h0LCBoZWlnaHQsIGZvY2FsX2xlbmd0aCwgZm92IH0pIHtcbiAgICAgICAgLy8gU29sdmUgZm9yIGNhbWVyYSBoZWlnaHRcbiAgICAgICAgaWYgKCFoZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgZm9jYWwgbGVuZ3RoLCBjYWxjdWxhdGUgRk9WXG4gICAgICAgICAgICBpZiAoZm9jYWxfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm92ID0gTWF0aC5hdGFuKDEgLyBmb2NhbF9sZW5ndGgpICogMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGhhdmUgRk9WLCBjYWxjdWxhdGUgZm9jYWwgbGVuZ3RoXG4gICAgICAgICAgICBlbHNlIGlmIChmb3YpIHtcbiAgICAgICAgICAgICAgICBmb3YgPSBmb3YgKiBNYXRoLlBJIC8gMTgwOyAvLyBjb252ZXJ0IEZPViBkZWdyZWVzIHRvIHJhZGlhbnNcbiAgICAgICAgICAgICAgICBmb2NhbF9sZW5ndGggPSAxIC8gTWF0aC50YW4oZm92IC8gMik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc3RhbmNlIHRoYXQgY2FtZXJhIHNob3VsZCBiZSBmcm9tIGdyb3VuZCBzdWNoIHRoYXQgaXQgZml0cyB0aGUgZmllbGQgb2YgdmlldyBleHBlY3RlZFxuICAgICAgICAgICAgLy8gZm9yIGEgY29udmVudGlvbmFsIHdlYiBtZXJjYXRvciBtYXAgYXQgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBhbmQgY2FtZXJhIGZvY2FsIGxlbmd0aFxuICAgICAgICAgICAgaGVpZ2h0ID0gdmlld19oZWlnaHQgLyAyICogZm9jYWxfbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbHZlIGZvciBjYW1lcmEgZm9jYWwgbGVuZ3RoIC8gZmllbGQtb2Ytdmlld1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvY2FsX2xlbmd0aCA9IDIgKiBoZWlnaHQgLyB2aWV3X2hlaWdodDtcbiAgICAgICAgICAgIGZvdiA9IE1hdGguYXRhbigxIC8gZm9jYWxfbGVuZ3RoKSAqIDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB2aWV3X2hlaWdodCwgaGVpZ2h0LCBmb2NhbF9sZW5ndGgsIGZvdiB9O1xuICAgIH1cblxuICAgIHVwZGF0ZU1hdHJpY2VzKCkge1xuICAgICAgICAvLyBUT0RPOiBvbmx5IHJlLWNhbGN1bGF0ZSB0aGVzZSB2YXJzIHdoZW4gbmVjZXNzYXJ5XG5cbiAgICAgICAgLy8gSGVpZ2h0IG9mIHRoZSB2aWV3cG9ydCBpbiBtZXRlcnMgYXQgY3VycmVudCB6b29tXG4gICAgICAgIHZhciB2aWV3cG9ydF9oZWlnaHQgPSB0aGlzLnNjZW5lLmNzc19zaXplLmhlaWdodCAqIEdlby5tZXRlcnNQZXJQaXhlbCh0aGlzLnNjZW5lLnpvb20pO1xuXG4gICAgICAgIC8vIENvbXB1dGUgY2FtZXJhIHByb3BlcnRpZXMgdG8gZml0IGRlc2lyZWQgdmlld1xuICAgICAgICB2YXIgeyBoZWlnaHQsIGZvdiB9ID0gdGhpcy5jb25zdHJhaW5DYW1lcmEoe1xuICAgICAgICAgICAgdmlld19oZWlnaHQ6IHZpZXdwb3J0X2hlaWdodCxcbiAgICAgICAgICAgIGZvY2FsX2xlbmd0aDogVXRpbHMuaW50ZXJwb2xhdGUodGhpcy5zY2VuZS56b29tLCB0aGlzLmZvY2FsX2xlbmd0aCksXG4gICAgICAgICAgICBmb3Y6IFV0aWxzLmludGVycG9sYXRlKHRoaXMuc2NlbmUuem9vbSwgdGhpcy5mb3YpXG4gICAgICAgICB9KTtcblxuICAgICAgICAvLyBWaWV3IG1hdHJpeFxuICAgICAgICB2YXIgcG9zaXRpb24gPSBbdGhpcy5zY2VuZS5jZW50ZXJfbWV0ZXJzLngsIHRoaXMuc2NlbmUuY2VudGVyX21ldGVycy55LCBoZWlnaHRdO1xuICAgICAgICB0aGlzLnBvc2l0aW9uX21ldGVycyA9IHBvc2l0aW9uO1xuXG4gICAgICAgIC8vIG1hdDQubG9va0F0KHRoaXMudmlld01hdHJpeCxcbiAgICAgICAgLy8gICAgIHZlYzMuZnJvbVZhbHVlcyguLi5wb3NpdGlvbiksXG4gICAgICAgIC8vICAgICB2ZWMzLmZyb21WYWx1ZXMocG9zaXRpb25bMF0sIHBvc2l0aW9uWzFdLCBoZWlnaHQgLSAxKSxcbiAgICAgICAgLy8gICAgIHZlYzMuZnJvbVZhbHVlcygwLCAxLCAwKSk7XG4gICAgICAgIC8vIEV4Y2x1ZGUgY2FtZXJhIGhlaWdodCBmcm9tIHZpZXcgbWF0cml4XG4gICAgICAgIG1hdDQubG9va0F0KHRoaXMudmlld01hdHJpeCxcbiAgICAgICAgICAgIHZlYzMuZnJvbVZhbHVlcyhwb3NpdGlvblswXSwgcG9zaXRpb25bMV0sIDApLFxuICAgICAgICAgICAgdmVjMy5mcm9tVmFsdWVzKHBvc2l0aW9uWzBdLCBwb3NpdGlvblsxXSwgLTEpLFxuICAgICAgICAgICAgdmVjMy5mcm9tVmFsdWVzKDAsIDEsIDApKTtcblxuICAgICAgICAvLyBQcm9qZWN0aW9uIG1hdHJpeFxuICAgICAgICBtYXQ0LnBlcnNwZWN0aXZlKHRoaXMucHJvamVjdGlvbk1hdHJpeCwgZm92LCB0aGlzLnNjZW5lLnZpZXdfYXNwZWN0LCAxLCBoZWlnaHQgKiAyKTtcblxuICAgICAgICAvLyBDb252ZXJ0IHZhbmlzaGluZyBwb2ludCBmcm9tIHBpeGVscyB0byB2aWV3cG9ydCBzcGFjZVxuICAgICAgICB0aGlzLnZhbmlzaGluZ19wb2ludF9za2V3WzBdID0gdGhpcy52YW5pc2hpbmdfcG9pbnRbMF0gLyB0aGlzLnNjZW5lLmNzc19zaXplLndpZHRoO1xuICAgICAgICB0aGlzLnZhbmlzaGluZ19wb2ludF9za2V3WzFdID0gdGhpcy52YW5pc2hpbmdfcG9pbnRbMV0gLyB0aGlzLnNjZW5lLmNzc19zaXplLmhlaWdodDtcblxuICAgICAgICAvLyBBZGp1c3QgcHJvamVjdGlvbiBtYXRyaXggdG8gaW5jbHVkZSB2YW5pc2hpbmcgcG9pbnQgc2tld1xuICAgICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXhbOF0gPSAtdGhpcy52YW5pc2hpbmdfcG9pbnRfc2tld1swXTsgLy8geiBjb2x1bW4gb2YgeCByb3csIGUuZy4gYW1vdW50IHogc2tld3MgeFxuICAgICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXhbOV0gPSAtdGhpcy52YW5pc2hpbmdfcG9pbnRfc2tld1sxXTsgLy8geiBjb2x1bW4gb2YgeSByb3csIGUuZy4gYW1vdW50IHogc2tld3MgeVxuXG4gICAgICAgIC8vIFRyYW5zbGF0ZSBnZW9tZXRyeSBpbnRvIHRoZSBkaXN0YW5jZSBzbyB0aGF0IGNhbWVyYSBpcyBhcHByb3ByaWF0ZSBoZWlnaHQgYWJvdmUgZ3JvdW5kXG4gICAgICAgIC8vIEFkZGl0aW9uYWxseSwgYWRqdXN0IHh5IHRvIGNvbXBlbnNhdGUgZm9yIGFueSB2YW5pc2hpbmcgcG9pbnQgc2tldywgZS5nLiBtb3ZlIGdlb21ldHJ5IHNvIHRoYXQgdGhlIGRpc3BsYXllZCBnXG4gICAgICAgIC8vIHBsYW5lIG9mIHRoZSBtYXAgbWF0Y2hlcyB0aGF0IGV4cGVjdGVkIGJ5IGEgdHJhZGl0aW9uYWwgd2ViIG1lcmNhdG9yIG1hcCBhdCB0aGlzIFtsYXQsIGxuZywgem9vbV0uXG4gICAgICAgIG1hdDQudHJhbnNsYXRlKHRoaXMucHJvamVjdGlvbk1hdHJpeCwgdGhpcy5wcm9qZWN0aW9uTWF0cml4LFxuICAgICAgICAgICAgdmVjMy5mcm9tVmFsdWVzKFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0X2hlaWdodC8yICogdGhpcy5zY2VuZS52aWV3X2FzcGVjdCAqIC10aGlzLnZhbmlzaGluZ19wb2ludF9za2V3WzBdLFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0X2hlaWdodC8yICogLXRoaXMudmFuaXNoaW5nX3BvaW50X3NrZXdbMV0sXG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEluY2x1ZGUgY2FtZXJhIGhlaWdodCBpbiBwcm9qZWN0aW9uIG1hdHJpeFxuICAgICAgICBtYXQ0LnRyYW5zbGF0ZSh0aGlzLnByb2plY3Rpb25NYXRyaXgsIHRoaXMucHJvamVjdGlvbk1hdHJpeCwgdmVjMy5mcm9tVmFsdWVzKDAsIDAsIC1oZWlnaHQpKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpY2VzKCk7XG4gICAgfVxuXG4gICAgc2V0dXBQcm9ncmFtKHByb2dyYW0pIHtcbiAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCdNYXRyaXg0ZnYnLCAndV9wcm9qZWN0aW9uJywgZmFsc2UsIHRoaXMucHJvamVjdGlvbk1hdHJpeCk7XG4gICAgICAgIHByb2dyYW0udW5pZm9ybSgnM2YnLCAndV9leWUnLCAwLCAwLCB0aGlzLnBvc2l0aW9uX21ldGVyc1syXSk7XG4gICAgICAgIHByb2dyYW0udW5pZm9ybSgnMmZ2JywgJ3VfdmFuaXNoaW5nX3BvaW50JywgdGhpcy52YW5pc2hpbmdfcG9pbnRfc2tldyk7XG4gICAgfVxuXG59XG5cbi8vIElzb21ldHJpYy1zdHlsZSBwcm9qZWN0aW9uXG4vLyBOb3RlOiB0aGlzIGlzIGFjdHVhbGx5IGFuIFwiYXhvbm9tZXRyaWNcIiBwcm9qZWN0aW9uLCBidXQgSSdtIHVzaW5nIHRoZSBjb2xsb3F1aWFsIHRlcm0gaXNvbWV0cmljIGJlY2F1c2UgaXQgaXMgbW9yZSByZWNvZ25pemFibGUuXG4vLyBBbiBpc29tZXRyaWMgcHJvamVjdGlvbiBpcyBhIHNwZWNpZmljIHN1YnNldCBvZiBheG9ub21ldHJpYyBwcm9qZWN0aW9ucy5cbi8vICdheGlzJyBkZXRlcm1pbmVzIHRoZSB4eSBza2V3IGFwcGxpZWQgdG8gYSB2ZXJ0ZXggYmFzZWQgb24gaXRzIHogY29vcmRpbmF0ZSwgZS5nLiBbMCwgMV0gYXhpcyBjYXVzZXMgYnVpbGRpbmdzIHRvIGJlIGRyYXduXG4vLyBzdHJhaWdodCB1cHdhcmRzIG9uIHNjcmVlbiBhdCB0aGVpciB0cnVlIGhlaWdodCwgWzAsIC41XSB3b3VsZCBkcmF3IHRoZW0gdXAgYXQgaGFsZi1oZWlnaHQsIFsxLCAwXSB3b3VsZCBiZSBzaWRld2F5cywgZXRjLlxuY2xhc3MgSXNvbWV0cmljQ2FtZXJhIGV4dGVuZHMgQ2FtZXJhIHtcblxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHNjZW5lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIobmFtZSwgc2NlbmUsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnaXNvbWV0cmljJztcbiAgICAgICAgdGhpcy5heGlzID0gb3B0aW9ucy5heGlzIHx8IHsgeDogMCwgeTogMSB9O1xuICAgICAgICBpZiAodGhpcy5heGlzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdGhpcy5heGlzID0geyB4OiB0aGlzLmF4aXNbMF0sIHk6IHRoaXMuYXhpc1sxXSB9OyAvLyBhbGxvdyBheGlzIHRvIGFsc28gYmUgcGFzc2VkIGFzIDItZWxlbSBhcnJheVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbl9tZXRlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLnZpZXdwb3J0X2hlaWdodCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy52aWV3TWF0cml4ID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuXG4gICAgICAgIC8vICdjYW1lcmEnIGlzIHRoZSBuYW1lIG9mIHRoZSBzaGFkZXIgYmxvY2ssIGUuZy4gZGV0ZXJtaW5lcyB3aGVyZSBpbiB0aGUgc2hhZGVyIHRoaXMgY29kZSBpcyBpbmplY3RlZFxuICAgICAgICBTaGFkZXJQcm9ncmFtLnJlcGxhY2VCbG9jaygnY2FtZXJhJywgYFxuICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVfcHJvamVjdGlvbjtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjMyB1X2V5ZTtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjMiB1X3ZhbmlzaGluZ19wb2ludDtcblxuICAgICAgICAgICAgdm9pZCBjYW1lcmFQcm9qZWN0aW9uIChpbm91dCB2ZWM0IHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSB1X3Byb2plY3Rpb24gKiBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbi54eSArPSBwb3NpdGlvbi56ICogdV9pc29tZXRyaWNfYXhpcztcblxuICAgICAgICAgICAgICAgIC8vIFJldmVyc2UgeiBmb3IgZGVwdGggYnVmZmVyIHNvIHVwIGlzIG5lZ2F0aXZlLFxuICAgICAgICAgICAgICAgIC8vIGFuZCBzY2FsZSBkb3duIHZhbHVlcyBzbyBvYmplY3RzIGhpZ2hlciB0aGFuIG9uZSBzY3JlZW4gaGVpZ2h0IHdpbGwgbm90IGdldCBjbGlwcGVkXG4gICAgICAgICAgICAgICAgLy8gcHVsbCBmb3J3YXJkIHNsaWdodGx5IHRvIGF2b2lkIGdvaW5nIHBhc3QgZmFyIGNsaXBwaW5nIHBsYW5lXG4gICAgICAgICAgICAgICAgcG9zaXRpb24ueiA9IC1wb3NpdGlvbi56IC8gMTAwLiArIDEuIC0gMC4wMDE7XG4gICAgICAgICAgICB9YFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlKCk7XG5cbiAgICAgICAgdGhpcy52aWV3cG9ydF9oZWlnaHQgPSB0aGlzLnNjZW5lLmNzc19zaXplLmhlaWdodCAqIEdlby5tZXRlcnNQZXJQaXhlbCh0aGlzLnNjZW5lLnpvb20pO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBbdGhpcy5zY2VuZS5jZW50ZXJfbWV0ZXJzLngsIHRoaXMuc2NlbmUuY2VudGVyX21ldGVycy55LCB0aGlzLnZpZXdwb3J0X2hlaWdodF07XG4gICAgICAgIHRoaXMucG9zaXRpb25fbWV0ZXJzID0gcG9zaXRpb247XG5cbiAgICAgICAgLy8gVmlld1xuICAgICAgICBtYXQ0LmlkZW50aXR5KHRoaXMudmlld01hdHJpeCk7XG4gICAgICAgIG1hdDQudHJhbnNsYXRlKHRoaXMudmlld01hdHJpeCwgdGhpcy52aWV3TWF0cml4LCB2ZWMzLmZyb21WYWx1ZXMoLXBvc2l0aW9uWzBdLCAtcG9zaXRpb25bMV0sIDApKTtcblxuICAgICAgICAvLyBQcm9qZWN0aW9uXG4gICAgICAgIG1hdDQuaWRlbnRpdHkodGhpcy5wcm9qZWN0aW9uTWF0cml4KTtcblxuICAgICAgICAvLyBhcHBseSBpc29tZXRyaWMgc2tld1xuICAgICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXhbOF0gPSB0aGlzLmF4aXMueCAvIHRoaXMuc2NlbmUudmlld19hc3BlY3Q7ICAgIC8vIHogY29sdW1uIG9mIHggcm93LCBlLmcuIGFtb3VudCB6IHNrZXdzIHhcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4WzldID0gdGhpcy5heGlzLnk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB6IGNvbHVtbiBvZiB4IHJvdywgZS5nLiBhbW91bnQgeiBza2V3cyB5XG5cbiAgICAgICAgLy8gY29udmVydCBtZXRlcnMgdG8gdmlld3BvcnRcbiAgICAgICAgbWF0NC5zY2FsZSh0aGlzLnByb2plY3Rpb25NYXRyaXgsIHRoaXMucHJvamVjdGlvbk1hdHJpeCxcbiAgICAgICAgICAgIHZlYzMuZnJvbVZhbHVlcyhcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy5zY2VuZS52aWV3cG9ydF9tZXRlcnMueCxcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy5zY2VuZS52aWV3cG9ydF9tZXRlcnMueSxcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy5zY2VuZS52aWV3cG9ydF9tZXRlcnMueVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHNldHVwUHJvZ3JhbShwcm9ncmFtKSB7XG4gICAgICAgIHByb2dyYW0udW5pZm9ybSgnTWF0cml4NGZ2JywgJ3VfcHJvamVjdGlvbicsIGZhbHNlLCB0aGlzLnByb2plY3Rpb25NYXRyaXgpO1xuXG4gICAgICAgIHByb2dyYW0udW5pZm9ybSgnM2YnLCAndV9leWUnLCAwLCAwLCB0aGlzLnZpZXdwb3J0X2hlaWdodCk7XG4gICAgICAgIC8vIHByb2dyYW0udW5pZm9ybSgnM2YnLCAndV9leWUnLCB0aGlzLnZpZXdwb3J0X2hlaWdodCAqIHRoaXMuYXhpcy54LCB0aGlzLnZpZXdwb3J0X2hlaWdodCAqIHRoaXMuYXhpcy55LCB0aGlzLnZpZXdwb3J0X2hlaWdodCk7XG4gICAgICAgIHByb2dyYW0udW5pZm9ybSgnMmYnLCAndV92YW5pc2hpbmdfcG9pbnQnLCAwLCAwKTtcbiAgICB9XG5cbn1cblxuLy8gRmxhdCBwcm9qZWN0aW9uIChlLmcuIGp1c3QgdG9wLWRvd24sIG5vIHBlcnNwZWN0aXZlKSAtIGEgZGVnZW5lcmF0ZSBpc29tZXRyaWMgY2FtZXJhXG5jbGFzcyBGbGF0Q2FtZXJhIGV4dGVuZHMgSXNvbWV0cmljQ2FtZXJhIHtcblxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHNjZW5lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIobmFtZSwgc2NlbmUsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZmxhdCc7XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICAvLyBBeGlzIGlzIGZpeGVkIHRvICgwLCAwKSBmb3IgZmxhdCBjYW1lcmFcbiAgICAgICAgdGhpcy5heGlzLnggPSAwO1xuICAgICAgICB0aGlzLmF4aXMueSA9IDA7XG5cbiAgICAgICAgc3VwZXIudXBkYXRlKCk7XG4gICAgfVxuXG59XG4iLCIvLyBNaXNjZWxsYW5lb3VzIGdlbyBmdW5jdGlvbnNcblxudmFyIEdlbztcbmV4cG9ydCBkZWZhdWx0IEdlbyA9IHt9O1xuXG4vLyBQcm9qZWN0aW9uIGNvbnN0YW50c1xuR2VvLnRpbGVfc2l6ZSA9IDI1Njtcbkdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzID0gMjAwMzc1MDguMzQyNzg5MjQ0O1xuR2VvLmNpcmN1bWZlcmVuY2VfbWV0ZXJzID0gR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnMgKiAyO1xuR2VvLm1pbl96b29tX21ldGVyc19wZXJfcGl4ZWwgPSBHZW8uY2lyY3VtZmVyZW5jZV9tZXRlcnMgLyBHZW8udGlsZV9zaXplOyAvLyBtaW4gem9vbSBkcmF3cyB3b3JsZCBhcyAyIHRpbGVzIHdpZGVcbkdlby5tZXRlcnNfcGVyX3BpeGVsID0gW107XG5HZW8ubWV0ZXJzX3Blcl90aWxlID0gW107XG5HZW8ubWF4X3pvb20gPSAxODtcbmZvciAodmFyIHo9MDsgeiA8PSBHZW8ubWF4X3pvb207IHorKykge1xuICAgIEdlby5tZXRlcnNfcGVyX3BpeGVsW3pdID0gR2VvLm1pbl96b29tX21ldGVyc19wZXJfcGl4ZWwgLyBNYXRoLnBvdygyLCB6KTtcbiAgICBHZW8ubWV0ZXJzX3Blcl90aWxlW3pdID0gR2VvLmNpcmN1bWZlcmVuY2VfbWV0ZXJzIC8gTWF0aC5wb3coMiwgeik7XG59XG5cbkdlby5tZXRlcnNQZXJQaXhlbCA9IGZ1bmN0aW9uICh6b29tKSB7XG4gICAgcmV0dXJuIEdlby5taW5fem9vbV9tZXRlcnNfcGVyX3BpeGVsIC8gTWF0aC5wb3coMiwgem9vbSk7XG59O1xuXG4vLyBDb252ZXJzaW9uIGZ1bmN0aW9ucyBiYXNlZCBvbiBhbiBkZWZpbmVkIHRpbGUgc2NhbGVcbkdlby51bml0c19wZXJfbWV0ZXIgPSBbXTtcbkdlby50aWxlX3NjYWxlID0gNDA5NjsgLy8gY29vcmRpbmF0ZXMgYXJlIGxvY2FsbHkgc2NhbGVkIHRvIHRoZSByYW5nZSBbMCwgdGlsZV9zY2FsZV1cbkdlby51bml0c19wZXJfcGl4ZWwgPSBHZW8udGlsZV9zY2FsZSAvIEdlby50aWxlX3NpemU7XG5cbmZvciAobGV0IHo9MDsgeiA8PSBHZW8ubWF4X3pvb207IHorKykge1xuICAgIEdlby51bml0c19wZXJfbWV0ZXJbel0gPSBHZW8udGlsZV9zY2FsZSAvIChHZW8udGlsZV9zaXplICogR2VvLm1ldGVyc19wZXJfcGl4ZWxbel0pO1xufVxuXG4vLyBDb252ZXJ0IHRpbGUgbG9jYXRpb24gdG8gbWVyY2F0b3IgbWV0ZXJzIC0gbXVsdGlwbHkgYnkgcGl4ZWxzIHBlciB0aWxlLCB0aGVuIGJ5IG1ldGVycyBwZXIgcGl4ZWwsIGFkanVzdCBmb3IgbWFwIG9yaWdpblxuR2VvLm1ldGVyc0ZvclRpbGUgPSBmdW5jdGlvbiAodGlsZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHRpbGUueCAqIEdlby5jaXJjdW1mZXJlbmNlX21ldGVycyAvIE1hdGgucG93KDIsIHRpbGUueikgLSBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycyxcbiAgICAgICAgeTogLSh0aWxlLnkgKiBHZW8uY2lyY3VtZmVyZW5jZV9tZXRlcnMgLyBNYXRoLnBvdygyLCB0aWxlLnopIC0gR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnMpXG4gICAgfTtcbn07XG5cbi8qKlxuICAgR2l2ZW4gYSBwb2ludCBpbiBtZXJjYXRvciBtZXRlcnMgYW5kIGEgem9vbSBsZXZlbCwgcmV0dXJuIHRoZSB0aWxlIFgvWS9aIHRoYXQgdGhlIHBvaW50IGxpZXMgaW5cbiovXG5HZW8udGlsZUZvck1ldGVycyA9IGZ1bmN0aW9uIChbeCwgeV0sIHpvb20pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBNYXRoLmZsb29yKCh4ICsgR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnMpIC8gKEdlby5jaXJjdW1mZXJlbmNlX21ldGVycyAvIE1hdGgucG93KDIsIHpvb20pKSksXG4gICAgICAgIHk6IE1hdGguZmxvb3IoKC15ICsgR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnMpIC8gKEdlby5jaXJjdW1mZXJlbmNlX21ldGVycyAvIE1hdGgucG93KDIsIHpvb20pKSksXG4gICAgICAgIHo6IHpvb21cbiAgICB9O1xufTtcblxuLy8gV3JhcCBhIHRpbGUgdG8gcG9zaXRpdmUgI3MgZm9yIHpvb21cbi8vIE9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgYXhlcyB0byB3cmFwXG5HZW8ud3JhcFRpbGUgPSBmdW5jdGlvbih7IHgsIHksIHogfSwgbWFzayA9IHsgeDogdHJ1ZSwgeTogZmFsc2UgfSkge1xuICAgIHZhciBtID0gKDEgPDwgeikgLSAxO1xuICAgIGlmIChtYXNrLngpIHtcbiAgICAgICAgeCA9IHggJiBtO1xuICAgIH1cbiAgICBpZiAobWFzay55KSB7XG4gICAgICAgIHkgPSB5ICYgbTtcbiAgICB9XG4gICAgcmV0dXJuIHsgeCwgeSwgeiB9O1xufTtcblxuLyoqXG4gICBDb252ZXJ0IG1lcmNhdG9yIG1ldGVycyB0byBsYXQtbG5nXG4qL1xuR2VvLm1ldGVyc1RvTGF0TG5nID0gZnVuY3Rpb24gKFt4LCB5XSkge1xuXG4gICAgeCAvPSBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycztcbiAgICB5IC89IEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzO1xuXG4gICAgeSA9ICgyICogTWF0aC5hdGFuKE1hdGguZXhwKHkgKiBNYXRoLlBJKSkgLSAoTWF0aC5QSSAvIDIpKSAvIE1hdGguUEk7XG5cbiAgICB4ICo9IDE4MDtcbiAgICB5ICo9IDE4MDtcblxuICAgIHJldHVybiBbeCwgeV07XG59O1xuXG4vKipcbiAgQ29udmVydCBsYXQtbG5nIHRvIG1lcmNhdG9yIG1ldGVyc1xuKi9cbkdlby5sYXRMbmdUb01ldGVycyA9IGZ1bmN0aW9uKFt4LCB5XSkge1xuXG4gICAgLy8gTGF0aXR1ZGVcbiAgICB5ID0gTWF0aC5sb2coTWF0aC50YW4oeSpNYXRoLlBJLzM2MCArIE1hdGguUEkvNCkpIC8gTWF0aC5QSTtcbiAgICB5ICo9IEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzO1xuXG4gICAgLy8gTG9uZ2l0dWRlXG4gICAgeCAqPSBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycyAvIDE4MDtcblxuICAgIHJldHVybiBbeCwgeV07XG59O1xuXG5HZW8ud3JhcExuZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA+IDE4MCB8fCB4IDwgLTE4MCkge1xuICAgICAgICB4ID0gKCh4ICsgMTgwKSAlIDM2MCArIDM2MCkgJSAzNjAgLSAxODA7XG4gICAgfVxuICAgIHJldHVybiB4O1xufTtcblxuLy8gUnVuIGFuIGluLXBsYWNlIHRyYW5zZm9ybSBmdW5jdGlvbiBvbiBlYWNoIGNvb29yZGluYXRlIGluIGEgR2VvSlNPTiBnZW9tZXRyeVxuR2VvLnRyYW5zZm9ybUdlb21ldHJ5ID0gZnVuY3Rpb24gKGdlb21ldHJ5LCB0cmFuc2Zvcm0pIHtcbiAgICBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ1BvaW50Jykge1xuICAgICAgICB0cmFuc2Zvcm0oZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgfHwgZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XG4gICAgICAgIGdlb21ldHJ5LmNvb3JkaW5hdGVzLmZvckVhY2godHJhbnNmb3JtKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nIHx8IGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnKSB7XG4gICAgICAgIGdlb21ldHJ5LmNvb3JkaW5hdGVzLmZvckVhY2goY29vcmRpbmF0ZXMgPT4gY29vcmRpbmF0ZXMuZm9yRWFjaCh0cmFuc2Zvcm0pKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgZ2VvbWV0cnkuY29vcmRpbmF0ZXMuZm9yRWFjaChwb2x5Z29uID0+IHtcbiAgICAgICAgICAgIHBvbHlnb24uZm9yRWFjaChjb29yZGluYXRlcyA9PiBjb29yZGluYXRlcy5mb3JFYWNoKHRyYW5zZm9ybSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVE9ETzogc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb25cbn07XG5cbkdlby5ib3hJbnRlcnNlY3QgPSBmdW5jdGlvbiAoYjEsIGIyKSB7XG4gICAgcmV0dXJuICEoXG4gICAgICAgIGIyLnN3LnggPiBiMS5uZS54IHx8XG4gICAgICAgIGIyLm5lLnggPCBiMS5zdy54IHx8XG4gICAgICAgIGIyLnN3LnkgPiBiMS5uZS55IHx8XG4gICAgICAgIGIyLm5lLnkgPCBiMS5zdy55XG4gICAgKTtcbn07XG5cbi8vIEZpbmRzIHRoZSBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94IGZvciBhIHBvbHlnb25cbkdlby5maW5kQm91bmRpbmdCb3ggPSBmdW5jdGlvbiAocG9seWdvbikge1xuICAgIHZhciBtaW5feCA9IEluZmluaXR5LFxuICAgICAgICBtYXhfeCA9IC1JbmZpbml0eSxcbiAgICAgICAgbWluX3kgPSBJbmZpbml0eSxcbiAgICAgICAgbWF4X3kgPSAtSW5maW5pdHk7XG5cbiAgICAvLyBPbmx5IG5lZWQgdG8gZXhhbWluZSBvdXRlciByaW5nIChwb2x5Z29uWzBdKVxuICAgIHZhciBudW1fY29vcmRzID0gcG9seWdvblswXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgYz0wOyBjIDwgbnVtX2Nvb3JkczsgYysrKSB7XG4gICAgICAgIHZhciBjb29yZCA9IHBvbHlnb25bMF1bY107XG5cbiAgICAgICAgaWYgKGNvb3JkWzBdIDwgbWluX3gpIHtcbiAgICAgICAgICAgIG1pbl94ID0gY29vcmRbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvb3JkWzFdIDwgbWluX3kpIHtcbiAgICAgICAgICAgIG1pbl95ID0gY29vcmRbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvb3JkWzBdID4gbWF4X3gpIHtcbiAgICAgICAgICAgIG1heF94ID0gY29vcmRbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvb3JkWzFdID4gbWF4X3kpIHtcbiAgICAgICAgICAgIG1heF95ID0gY29vcmRbMV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW21pbl94LCBtaW5feSwgbWF4X3gsIG1heF95XTtcbn07XG5cbi8vIENvbnZlcnQgZ2VvbWV0cnkgdHlwZSB0byBvbmUgb2Y6ICdwb2ludCcsICdsaW5lJywgJ3BvbHlnb24nXG5HZW8uZ2VvbWV0cnlUeXBlID0gZnVuY3Rpb24odHlwZSkge1xuICAgIGlmICh0eXBlID09PSAnUG9seWdvbicgfHwgdHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgcmV0dXJuICdwb2x5Z29uJztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ0xpbmVTdHJpbmcnIHx8IHR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAnbGluZSc7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnUG9pbnQnIHx8IHR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xuICAgICAgICByZXR1cm4gJ3BvaW50JztcbiAgICB9XG59O1xuXG5HZW8uY2VudHJvaWQgPSBmdW5jdGlvbiAocG9seWdvbikge1xuICAgIGxldCBuID0gcG9seWdvbi5sZW5ndGg7XG4gICAgbGV0IGNlbnRyb2lkID0gWzAsIDBdO1xuXG4gICAgZm9yIChsZXQgcD0wOyBwIDwgcG9seWdvbi5sZW5ndGg7IHArKykge1xuICAgICAgICBjZW50cm9pZFswXSArPSBwb2x5Z29uW3BdWzBdO1xuICAgICAgICBjZW50cm9pZFsxXSArPSBwb2x5Z29uW3BdWzFdO1xuICAgIH1cblxuICAgIGNlbnRyb2lkWzBdIC89IG47XG4gICAgY2VudHJvaWRbMV0gLz0gbjtcblxuICAgIHJldHVybiBjZW50cm9pZDtcbn07XG5cbkdlby5tdWx0aUNlbnRyb2lkID0gZnVuY3Rpb24gKHBvbHlnb25zKSB7XG4gICAgbGV0IG4gPSBwb2x5Z29ucy5sZW5ndGg7XG4gICAgbGV0IGNlbnRyb2lkID0gWzAsIDBdO1xuXG4gICAgZm9yIChsZXQgcD0wOyBwIDwgcG9seWdvbnMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgbGV0IHBvbHlnb24gPSBwb2x5Z29uc1twXVswXTtcbiAgICAgICAgbGV0IGMgPSBHZW8uY2VudHJvaWQocG9seWdvbik7XG4gICAgICAgIGNlbnRyb2lkWzBdICs9IGNbMF07XG4gICAgICAgIGNlbnRyb2lkWzFdICs9IGNbMV07XG4gICAgfVxuXG4gICAgY2VudHJvaWRbMF0gLz0gbjtcbiAgICBjZW50cm9pZFsxXSAvPSBuO1xuXG4gICAgcmV0dXJuIGNlbnRyb2lkO1xufTtcblxuR2VvLnNpZ25lZFBvbHlnb25BcmVhU3VtID0gZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICBsZXQgYXJlYSA9IDA7XG4gICAgbGV0IG4gPSBwb2x5Z29uLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xuICAgICAgICBsZXQgcDAgPSBwb2x5Z29uW2ldO1xuICAgICAgICBsZXQgcDEgPSBwb2x5Z29uW2krMV07XG5cbiAgICAgICAgYXJlYSArPSBwMFswXSAqIHAxWzFdIC0gcDFbMF0gKiBwMFsxXTtcbiAgICB9XG5cbiAgICBhcmVhICs9IHBvbHlnb25bbiAtIDFdWzBdICogcG9seWdvblswXVsxXSAtIHBvbHlnb25bMF1bMF0gKiBwb2x5Z29uW24gLSAxXVsxXTtcbiAgICByZXR1cm4gYXJlYTtcbn07XG5cbi8vIFRPRE86IHN1YnRyYWN0IGlubmVyIHJpbmcgYXJlYXNcbkdlby5wb2x5Z29uQXJlYSA9IGZ1bmN0aW9uIChwb2x5Z29uKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKEdlby5zaWduZWRQb2x5Z29uQXJlYVN1bShwb2x5Z29uKSkgLyAyO1xufTtcblxuR2VvLm11bHRpUG9seWdvbkFyZWEgPSBmdW5jdGlvbiAocG9seWdvbnMpIHtcbiAgICBsZXQgYXJlYSA9IDA7XG5cbiAgICBmb3IgKGxldCBwPTA7IHAgPCBwb2x5Z29ucy5sZW5ndGg7IHArKykge1xuICAgICAgICBsZXQgcG9seWdvbiA9IHBvbHlnb25zW3BdWzBdO1xuICAgICAgICBhcmVhICs9IEdlby5wb2x5Z29uQXJlYShwb2x5Z29uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJlYTtcbn07XG5cbkdlby5yaW5nV2luZGluZyA9IGZ1bmN0aW9uIChyaW5nKSB7XG4gICAgcmV0dXJuIEdlby5zaWduZWRQb2x5Z29uQXJlYVN1bShyaW5nKSA+IDAgPyAnQ1cnIDogJ0NDVyc7XG59O1xuXG4vLyBFbmZvcmNlIHdpbmRpbmcgb3JkZXIgb24gb3V0ZXIvaW5uZXIgcmluZ3Ncbi8vIHdpbmRpbmc6ICdDVycgb3IgJ0NDVydcbkdlby5lbmZvcmNlV2luZGluZyA9IGZ1bmN0aW9uIChnZW9tLCB3aW5kaW5nKSB7XG4gICAgbGV0IHBvbHlzO1xuICAgIGlmIChnZW9tLnR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICBwb2x5cyA9IFtnZW9tLmNvb3JkaW5hdGVzXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ2VvbS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICBwb2x5cyA9IGdlb20uY29vcmRpbmF0ZXM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2VvbTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBwPTA7IHAgPCBwb2x5cy5sZW5ndGg7IHArKykge1xuICAgICAgICBsZXQgcG9seSA9IHBvbHlzW3BdO1xuXG4gICAgICAgIC8vIElmIGZpcnN0IHJpbmcgd2luZGluZyBkb2Vzbid0IG1hdGNoLCByZXZlcnNlIGFsbCByaW5nc1xuICAgICAgICAvLyBOT1RFOiBhc3N1bWVzIHJpbmcgd2luZGluZyBvcmRlcnMgYWxyZWFkeSBhbHRlcm5hdGUgYXMgZXhwZWN0ZWRcbiAgICAgICAgaWYgKEdlby5yaW5nV2luZGluZyhwb2x5WzBdKSAhPT0gd2luZGluZykge1xuICAgICAgICAgICAgZm9yIChsZXQgcmluZyBvZiBwb2x5KSB7XG4gICAgICAgICAgICAgICAgcmluZy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdlb207XG59O1xuIiwiLy8gV2ViR0wgY29uc3RhbnRzIC0gbmVlZCB0byBpbXBvcnQgdGhlc2Ugc2VwYXJhdGVseSB0byBtYWtlIHRoZW0gYXZhaWxhYmxlIGluIHRoZSB3ZWIgd29ya2VyXG5cbnZhciBnbDtcbmV4cG9ydCBkZWZhdWx0IGdsID0ge307XG5cbi8qIERhdGFUeXBlICovXG5nbC5CWVRFICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDE0MDA7XG5nbC5VTlNJR05FRF9CWVRFICAgICAgICAgICAgICAgICAgPSAweDE0MDE7XG5nbC5TSE9SVCAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDE0MDI7XG5nbC5VTlNJR05FRF9TSE9SVCAgICAgICAgICAgICAgICAgPSAweDE0MDM7XG5nbC5JTlQgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDE0MDQ7XG5nbC5VTlNJR05FRF9JTlQgICAgICAgICAgICAgICAgICAgPSAweDE0MDU7XG5nbC5GTE9BVCAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDE0MDY7XG4iLCIvLyBXZWJHTCBjb250ZXh0IHdyYXBwZXJcblxudmFyIENvbnRleHQ7XG5leHBvcnQgZGVmYXVsdCBDb250ZXh0ID0ge307XG5cbi8vIFNldHVwIGEgV2ViR0wgY29udGV4dFxuLy8gSWYgbm8gY2FudmFzIGVsZW1lbnQgaXMgcHJvdmlkZWQsIG9uZSBpcyBjcmVhdGVkIGFuZCBhZGRlZCB0byB0aGUgZG9jdW1lbnQgYm9keVxuQ29udGV4dC5nZXRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q29udGV4dCAoY2FudmFzLCBvcHRpb25zKVxue1xuICAgIHZhciBmdWxsc2NyZWVuID0gZmFsc2U7XG4gICAgaWYgKGNhbnZhcyA9PSBudWxsKSB7XG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBjYW52YXMuc3R5bGUudG9wID0gMDtcbiAgICAgICAgY2FudmFzLnN0eWxlLmxlZnQgPSAwO1xuICAgICAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gLTE7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgZnVsbHNjcmVlbiA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgb3B0aW9ucykgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIG9wdGlvbnMpO1xuICAgIGlmICghZ2wpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgY3JlYXRlIFdlYkdMIGNvbnRleHQuXCIpO1xuICAgIH1cblxuICAgIENvbnRleHQucmVzaXplKGdsLCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0LCBvcHRpb25zLmRldmljZV9waXhlbF9yYXRpbyk7XG4gICAgaWYgKGZ1bGxzY3JlZW4gPT09IHRydWUpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIENvbnRleHQucmVzaXplKGdsLCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdsO1xufTtcblxuQ29udGV4dC5yZXNpemUgPSBmdW5jdGlvbiAoZ2wsIHdpZHRoLCBoZWlnaHQsIGRldmljZV9waXhlbF9yYXRpbylcbntcbiAgICBkZXZpY2VfcGl4ZWxfcmF0aW8gPSBkZXZpY2VfcGl4ZWxfcmF0aW8gfHwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICBnbC5jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgZ2wuY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgZ2wuY2FudmFzLndpZHRoID0gTWF0aC5yb3VuZChnbC5jYW52YXMuc3R5bGUud2lkdGggKiBkZXZpY2VfcGl4ZWxfcmF0aW8pO1xuICAgIGdsLmNhbnZhcy5oZWlnaHQgPSBNYXRoLnJvdW5kKGdsLmNhbnZhcy5zdHlsZS53aWR0aCAqIGRldmljZV9waXhlbF9yYXRpbyk7XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTtcbn07XG4iLCIvLyBXZWJHTCBleHRlbnNpb24gd3JhcHBlclxuLy8gU3RvcmVzIGV4dGVuc2lvbnMgYnkgbmFtZSBhbmQgR0wgY29udGV4dFxuXG5sZXQgZXh0ZW5zaW9ucyA9IG5ldyBNYXAoKTsgLy8gbWFwIG9mIGV4dGVuc2lvbnMgYnkgR0wgY29udGV4dFxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRFeHRlbnNpb24gKGdsLCBuYW1lKSB7XG4gICAgbGV0IGV4dHMgPSBleHRlbnNpb25zLmdldChnbCk7XG4gICAgaWYgKCFleHRzKSB7XG4gICAgICAgIGV4dGVuc2lvbnMuc2V0KGdsLCBuZXcgTWFwKCkpO1xuICAgICAgICBleHRzID0gZXh0ZW5zaW9ucy5nZXQoZ2wpO1xuICAgIH1cblxuICAgIGlmICghZXh0cy5nZXQobmFtZSkpIHtcbiAgICAgICAgZXh0cy5zZXQobmFtZSwgZ2wuZ2V0RXh0ZW5zaW9uKG5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dHMuZ2V0KG5hbWUpO1xufVxuIiwidmFyIEdMU0wgPSB7fTtcbmV4cG9ydCBkZWZhdWx0IEdMU0w7XG5cbi8qKlxuICAgIFBhcnNlIHVuaWZvcm1zIGZyb20gYSBKUyBvYmplY3QsIGluZmVycyB0eXBlcyBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggdGhlXG4gICAgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIHRvIHNldCB1bmlmb3JtIHZhbHVlcyBvbiBhIEdMIHByb2dyYW0uIEVhY2ggb2JqZWN0IGluIHRoZSByZXR1cm5lZFxuICAgIGFycmF5IGhhcyB0aGUgZm9ybTpcbiAgICB7IHR5cGUsIG1ldGhvZCwgbmFtZSwgdmFsdWUgfVxuXG4gICAgdHlwZTogdGhlIEdMIHVuaWZvcm0gdHlwZSwgc3VjaCBhcyAndmVjMycsICdmbG9hdCcsIGV0Yy5cbiAgICBtZXRob2Q6IHRoZSBHTCB1bmlmb3JtIHNldHRlciBtZXRob2QgdG8gdXNlLCBzdWNoIGFzICcxZicsICczZnYnLCBldGMuXG4gICAgbmFtZTogdGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIG9mIHRoZSBHTCB1bmlmb3JtIGxvY2F0aW9uLCBlLmcuICdhcnJheVswXS5maWVsZCcsIGV0Yy5cbiAgICB2YWx1ZTogdGhlIHZhbHVlIHRvIGJlIHBhc3NlZCB0byB0aGUgR0wgdW5pZm9ybSBzZXR0ZXIgZm9yIHRoYXQgdHlwZSwgZS5nLiBbMSwgMiwgM10gZm9yIGEgdmVjM1xuXG4gICAgVGV4dHVyZXMgaGF2ZSBzcGVjaWFsIGJlaGF2aW9yOiB1bmlmb3JtcyB3aXRoIHN0cmluZyB2YWx1ZXMgYXJlIHRyZWF0ZWQgYXMgdGV4dHVyZXMsIGFuZFxuICAgIHRoZSBzdHJpbmcgaXMgdXNlZCBhcyBhIHVuaXF1ZSB0ZXh0dXJlICdrZXknIHRvIGJlIGludGVycHJldGVkIGJ5IHRoZSBjYWxsZXIgKHdoaWNoIGlzIHJlc3BvbnNpYmxlXG4gICAgZm9yIGFjdHVhbGx5IHNldHRpbmcgdGhlIHVuaWZvcm1zKS4gRm9yIGV4YW1wbGUsIHRoaXMgY291bGQgYmUgdXNlZCBhcyBhIGtleSBpbnRvIGEgZGljdGlvbmFyeSBvZlxuICAgIGtub3duIHRleHR1cmUgbmFtZXMsIG9yIGl0IGNvdWxkIHNpbXBseSBiZSB1c2VkIGFzIGEgVVJMIHRvIGR5bmFtaWNhbGx5IGxvYWQgdGhlIHRleHR1cmUgZnJvbS5cbiovXG5HTFNMLnBhcnNlVW5pZm9ybXMgPSBmdW5jdGlvbiAodW5pZm9ybXMsIHByZWZpeCA9IG51bGwpIHtcbiAgICB2YXIgcGFyc2VkID0gW107XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHVuaWZvcm1zKSB7XG4gICAgICAgIHZhciB1bmlmb3JtID0gdW5pZm9ybXNbbmFtZV07XG4gICAgICAgIHZhciB1O1xuXG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIG5hbWUgPSBwcmVmaXggKyAnLicgKyBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2luZ2xlIGZsb2F0XG4gICAgICAgIGlmICh0eXBlb2YgdW5pZm9ybSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJzFmJyxcbiAgICAgICAgICAgICAgICBuYW1lLCB2YWx1ZTpcbiAgICAgICAgICAgICAgICB1bmlmb3JtXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheTogdmVjdG9yLCBhcnJheSBvZiBmbG9hdHMsIGFycmF5IG9mIHRleHR1cmVzLCBvciBhcnJheSBvZiBzdHJ1Y3RzXG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodW5pZm9ybSkpIHtcbiAgICAgICAgICAgIC8vIE51bWVyaWMgdmFsdWVzXG4gICAgICAgICAgICBpZiAodHlwZW9mIHVuaWZvcm1bMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gZmxvYXQgdmVjdG9ycyAodmVjMiwgdmVjMywgdmVjNClcbiAgICAgICAgICAgICAgICBpZiAodW5pZm9ybS5sZW5ndGggPj0gMiAmJiB1bmlmb3JtLmxlbmd0aCA8PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd2ZWMnICsgdW5pZm9ybS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHVuaWZvcm0ubGVuZ3RoICsgJ2Z2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5pZm9ybVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZmxvYXQgYXJyYXlcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh1bmlmb3JtLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Zsb2F0W10nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnMWZ2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgKyAnWzBdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmlmb3JtXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhc3N1bWUgbWF0cml4IGZvciAodHlwZW9mID09IEZsb2F0MzJBcnJheSAmJiBsZW5ndGggPT0gMTYpP1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXJyYXkgb2YgdGV4dHVyZXNcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB1bmlmb3JtWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGZvciAodT0wOyB1IDwgdW5pZm9ybS5sZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc2FtcGxlcjJEJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJzFpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgKyAnWycgKyB1ICsgJ10nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuaWZvcm1bdV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXJyYXkgb2YgYXJyYXlzIC0gYnV0IG9ubHkgYXJyYXlzIG9mIHZlY3RvcnMgYXJlIGFsbG93ZWQgaW4gdGhpcyBjYXNlXG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHVuaWZvcm1bMF0pICYmIHR5cGVvZiB1bmlmb3JtWzBdWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIGZsb2F0IHZlY3RvcnMgKHZlYzIsIHZlYzMsIHZlYzQpXG4gICAgICAgICAgICAgICAgaWYgKHVuaWZvcm1bMF0ubGVuZ3RoID49IDIgJiYgdW5pZm9ybVswXS5sZW5ndGggPD0gNCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGZvciAodT0wOyB1IDwgdW5pZm9ybS5sZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd2ZWMnICsgdW5pZm9ybVswXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiB1bmlmb3JtW3VdLmxlbmd0aCArICdmdicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSArICdbJyArIHUgKyAnXScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuaWZvcm1bdV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVsc2UgZXJyb3I/XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBcnJheSBvZiBzdHJ1Y3R1cmVzXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdW5pZm9ybVswXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHU9MDsgdSA8IHVuaWZvcm0ubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGVhY2ggc3RydWN0IGluIHRoZSBhcnJheVxuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucHVzaCguLi5HTFNMLnBhcnNlVW5pZm9ybXModW5pZm9ybVt1XSwgbmFtZSArICdbJyArIHUgKyAnXScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQm9vbGVhblxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdW5pZm9ybSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBwYXJzZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJzFpJyxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmlmb3JtXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXh0dXJlXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB1bmlmb3JtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzYW1wbGVyMkQnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJzFpJyxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmlmb3JtXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJ1Y3R1cmVcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHVuaWZvcm0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBTZXQgZWFjaCBmaWVsZCBpbiB0aGUgc3RydWN0XG4gICAgICAgICAgICBwYXJzZWQucHVzaCguLi5HTFNMLnBhcnNlVW5pZm9ybXModW5pZm9ybSwgbmFtZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBvdGhlciBub24tZmxvYXQgdHlwZXM/IChpbnQsIGV0Yy4pXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbi8qKlxuICAgIEdlbmVyYXRlIGEgR0xTTCB2YXJpYWJsZSBkZWZpbml0aW9uIGZyb20gYSBKUyBvYmplY3RcbiovXG5HTFNMLmRlZmluZVZhcmlhYmxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBwcmVmaXggPSBudWxsKSB7XG4gICAgdmFyIHR5cGUsIGFycmF5O1xuICAgIHZhciBzdHJ1Y3RzID0gJyc7XG4gICAgcHJlZml4ID0gcHJlZml4ID8gcHJlZml4ICsgJ18nICsgbmFtZSA6IG5hbWU7XG5cbiAgICAvLyBTaW5nbGUgZmxvYXRcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICB0eXBlID0gJ2Zsb2F0JztcbiAgICB9XG4gICAgLy8gTXVsdGlwbGUgZmxvYXRzIC0gdmVjdG9yIG9yIGFycmF5XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgLy8gTnVtZXJpYyB2YWx1ZXNcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVswXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGZsb2F0IHZlY3RvcnMgKHZlYzIsIHZlYzMsIHZlYzQpXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID49IDIgJiYgdmFsdWUubGVuZ3RoIDw9IDQpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ3ZlYycgKyB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmbG9hdCBhcnJheVxuICAgICAgICAgICAgZWxzZSB7IC8vaWYgKHZhbHVlLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2Zsb2F0JztcbiAgICAgICAgICAgICAgICBhcnJheSA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IGFzc3VtZSBtYXRyaXggZm9yICh0eXBlb2YgPT0gRmxvYXQzMkFycmF5ICYmIGxlbmd0aCA9PSAxNik/XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXkgb2YgdGV4dHVyZXNcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHlwZSA9ICdzYW1wbGVyMkQnO1xuICAgICAgICAgICAgYXJyYXkgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXkgb2YgYXJyYXlzIC0gYnV0IG9ubHkgYXJyYXlzIG9mIHZlY3RvcnMgYXJlIGFsbG93ZWQgaW4gdGhpcyBjYXNlXG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVbMF0pICYmIHR5cGVvZiB2YWx1ZVswXVswXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGZsb2F0IHZlY3RvcnMgKHZlYzIsIHZlYzMsIHZlYzQpXG4gICAgICAgICAgICBpZiAodmFsdWVbMF0ubGVuZ3RoID49IDIgJiYgdmFsdWVbMF0ubGVuZ3RoIDw9IDQpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ3ZlYycgKyB2YWx1ZVswXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlIGVycm9yP1xuICAgICAgICAgICAgYXJyYXkgPSB2YWx1ZVswXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXkgb2Ygc3RydWN0dXJlc1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWVbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0eXBlID0gJ190eXBlXycgKyBwcmVmaXg7IC8vIGN1c3RvbSBzdHJ1Y3QgbmFtZVxuICAgICAgICAgICAgYXJyYXkgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBzdHJ1Y3RzICs9IEdMU0wuZGVmaW5lU3RydWN0KHR5cGUsIHZhbHVlWzBdLCBwcmVmaXgpICsgJ1xcbic7IC8vIGJ1aWxkICYgYWRkIHRvIGxpc3Qgb2YgZGVwZW5kZW50IHN0cnVjdHNcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBCb29sZWFuXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdHlwZSA9ICdib29sJztcbiAgICB9XG4gICAgLy8gVGV4dHVyZVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHlwZSA9ICdzYW1wbGVyMkQnO1xuICAgIH1cbiAgICAvLyBTdHJ1Y3R1cmVcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHR5cGUgPSAnX3R5cGVfJyArIHByZWZpeDsgLy8gY3VzdG9tIHN0cnVjdCBuYW1lXG4gICAgICAgIHN0cnVjdHMgKz0gR0xTTC5kZWZpbmVTdHJ1Y3QodHlwZSwgdmFsdWUsIHByZWZpeCkgKyAnXFxuJzsgLy8gYnVpbGQgJiBhZGQgdG8gbGlzdCBvZiBkZXBlbmRlbnQgc3RydWN0c1xuICAgIH1cblxuICAgIC8vIENvbnN0cnVjdCB2YXJpYWJsZSBkZWZpbml0aW9uXG4gICAgdmFyIHZhcmlhYmxlID0gJyc7XG4gICAgdmFyaWFibGUgKz0gYCR7dHlwZX0gJHtuYW1lfWA7XG4gICAgaWYgKGFycmF5KSB7XG4gICAgICAgIHZhcmlhYmxlICs9IGBbJHthcnJheX1dYDtcbiAgICB9XG4gICAgdmFyaWFibGUgKz0gJztcXG4nO1xuXG4gICAgLy8gUmV0dXJuIHRoZSB2YXJpYWJsZSBkZWZpbml0aW9uIGl0c2VsZiwgYW5kIGFueSBkZXBlbmRlbnQgc3RydWN0IGRlZmluaXRpb25zXG4gICAgcmV0dXJuIHsgdmFyaWFibGUsIHN0cnVjdHMgfTtcbn07XG5cbi8qKlxuICAgIEdlbmVyYXRlIGEgR0xTTCBzdHJ1Y3R1cmUgZGVmaW5pdGlvbiBmcm9tIGEgSlMgb2JqZWN0XG4qL1xuR0xTTC5kZWZpbmVTdHJ1Y3QgPSBmdW5jdGlvbiAodHlwZSwgdmFsdWUsIHByZWZpeCA9IG51bGwpIHtcbiAgICB2YXIgc3RydWN0ID0gYHN0cnVjdCAke3R5cGV9IHtcXG5gO1xuICAgIHZhciBkZXBlbmRlbnRzID0gJyc7XG4gICAgZm9yICh2YXIgZmllbGQgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFyIHN1YnZhciA9IEdMU0wuZGVmaW5lVmFyaWFibGUoZmllbGQsIHZhbHVlW2ZpZWxkXSwgcHJlZml4KTtcbiAgICAgICAgc3RydWN0ICs9ICcgICAgJyArIHN1YnZhci52YXJpYWJsZTtcbiAgICAgICAgZGVwZW5kZW50cyArPSBzdWJ2YXIuc3RydWN0cztcbiAgICB9XG4gICAgc3RydWN0ICs9ICd9O1xcbic7XG4gICAgc3RydWN0ID0gZGVwZW5kZW50cyArIHN0cnVjdDtcbiAgICByZXR1cm4gc3RydWN0O1xufTtcblxuLyoqXG4gICAgR2VuZXJhdGUgYSBHTFNMIHVuaWZvcm0gZGVmaW5pdGlvbiBmcm9tIGEgSlMgb2JqZWN0XG4qL1xuR0xTTC5kZWZpbmVVbmlmb3JtID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGRlZiA9IEdMU0wuZGVmaW5lVmFyaWFibGUobmFtZSwgdmFsdWUpO1xuICAgIGRlZiA9IGRlZi5zdHJ1Y3RzICsgJ3VuaWZvcm0gJyArIGRlZi52YXJpYWJsZTtcbiAgICByZXR1cm4gZGVmO1xufTtcblxuLyoqXG4gICAgQ2hlY2sgZm9yIGEgdW5pZm9ybSBkZWZpbml0aW9uIG9mICduYW1lJyBpbiB0aGUgcHJvdmlkZWQgR0xTTCBzb3VyY2VcbiAgICBTaW1wbGUgcmVnZXggY2hlY2sgZm9yICd1bmlmb3JtJyBrZXl3b3JkIGFuZCB2YXIgbmFtZSwgZG9lcyBub3QgYXR0ZW1wdCB0byBwYXJzZS9leHRyYWN0IEdMU0xcbiAgICBOT1RFOiBhc3N1bWVzIGNvbW1lbnRzIGhhdmUgYmVlbiBzdHJpcHBlZCBmcm9tIHNvdXJjZVxuKi9cbkdMU0wuaXNVbmlmb3JtRGVmaW5lZCA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2UpIHtcbiAgICAvLyBNYXRjaCwgaW4gb3JkZXI6XG4gICAgLy8gLSB0aGUga2V5d29yZCAndW5pZm9ybSdcbiAgICAvLyAtIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgdGhhdCBpcyBhbnl0aGluZyBleGNlcHQgYSBzZW1pY29sb24sIDtcbiAgICAvLyAtIG9wdGlvbmFsbHksIGFueXRoaW5nIGVuY2xvc2VkIGluIGN1cmx5IGJyYWNlcywgeyAuLi4gfSAoYW4gaW5saW5lIHN0cnVjdHVyZSBkZWZpbml0aW9uIGNhbiBnbyBoZXJlKVxuICAgIC8vIC0gb3B0aW9uYWxseSwgYW55ICMgb2YgY2hhcmFjdGVycyB0aGF0IGlzIG5vdCBhIHNlbWljb2xvbiwgO1xuICAgIC8vIC0gdGhlIG5hbWUgb2YgdGhlIHVuaWZvcm1cblxuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoJ3VuaWZvcm1bXjtdKyg/OntbXFxcXHNcXFxcU10qfSk/W147XSpcXFxcYicgKyBuYW1lICsgJ1xcXFxiJywgJ2cnKTtcbiAgICBpZiAoc291cmNlLm1hdGNoKHJlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gICAgQ2hlY2sgdGhhdCBhIHN5bWJvbCBpcyByZWZlcmVuY2VkIGluIHRoZSBHTFNMIHNvdXJjZVxuICAgIE5PVEU6IGFzc3VtZXMgY29tbWVudHMgaGF2ZSBiZWVuIHN0cmlwcGVkIGZyb20gc291cmNlXG4qL1xuR0xTTC5pc1N5bWJvbFJlZmVyZW5jZWQgPSBmdW5jdGlvbiAobmFtZSwgc291cmNlKSB7XG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgbmFtZSArICdcXFxcYicsICdnJyk7XG4gICAgaWYgKHNvdXJjZS5zZWFyY2gocmUpID49IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICAgIEV4cGFuZCBhIHNpbmdsZSB2YWx1ZSBvciAyLWVsZW1lbnQgYXJyYXkgaW50byBhIDMtZWxlbWVudCBhcnJheSwgd2l0aCB0aGUgbGFzdCAoIHogKVxuICAgIGNvb3JkaW5hdGUgZGVmYXVsdGluZyB0byAxICh3aXRoIG9wdGlvbiB0byBzcGVjaWZ5KS4gQWxzbyBydW5zIHBhcnNlRmxvYXQgdG8gdHJ5IHRvIG1haW50YWluXG4gICAgZGF0YSBpbnRlZ3JpdHkuIFJldHVybnMgbnVsbCBpZiBpbnB1dCBjb3VsZG4ndCBiZSBwYXJzZWQuXG4qL1xuR0xTTC5leHBhbmRWZWMzID0gZnVuY3Rpb24gKHYsIHogPSAxKSB7XG4gICAgbGV0IHg7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodikgJiYgdi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgeCA9IFsuLi52LCB6XS5tYXAocGFyc2VGbG9hdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB4ID0gW3YsIHYsIHZdLm1hcChwYXJzZUZsb2F0KTtcbiAgICB9XG5cbiAgICBpZiAoeCAmJiB4LmV2ZXJ5KG4gPT4gdHlwZW9mIG4gPT09ICdudW1iZXInICYmICFpc05hTihuKSkpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxufTtcblxuLyoqXG4gICAgRXhwYW5kIGEgc2luZ2xlIHZhbHVlIG9yIDMtZWxlbWVudCBhcnJheSBpbnRvIGEgNC1lbGVtZW50IGFycmF5LCB3aXRoIHRoZSBsYXN0IChlLmcuIHcgb3IgYSlcbiAgICBjb29yZGluYXRlIGRlZmF1bHRpbmcgdG8gMSAod2l0aCBvcHRpb24gdG8gc3BlY2lmeSkuIEFsc28gcnVucyBwYXJzZUZsb2F0IHRvIHRyeSB0byBtYWludGFpblxuICAgIGRhdGEgaW50ZWdyaXR5LiBSZXR1cm5zIG51bGwgaWYgaW5wdXQgY291bGRuJ3QgYmUgcGFyc2VkLlxuKi9cbkdMU0wuZXhwYW5kVmVjNCA9IGZ1bmN0aW9uICh2LCB3ID0gMSkge1xuICAgIGxldCB4O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHYpICYmIHYubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHggPSBbLi4udiwgd10ubWFwKHBhcnNlRmxvYXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgeCA9IFt2LCB2LCB2LCB3XS5tYXAocGFyc2VGbG9hdCk7XG4gICAgfVxuXG4gICAgaWYgKHggJiYgeC5ldmVyeShuID0+IHR5cGVvZiBuID09PSAnbnVtYmVyJyAmJiAhaXNOYU4obikpKSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbn07XG5cblxuIiwiXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJTdGF0ZSB7XG5cdGNvbnN0cnVjdG9yICh2YWx1ZSwgc2V0dXApIHtcbiAgICAgICAgc2V0dXAodmFsdWUpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc2V0dXAgPSBzZXR1cDtcbiAgICB9XG5cbiAgICBzZXQgKHZhbHVlKSB7XG4gICAgXHQvLyBpZiB0aGUgc3RhdGVzIGFyZSBkaWZmZXJlbnQsIGNhbGwgdGhlIEdMIGNvbnRleHQgZm9yIGEgc3RhdGUgY2hhbmdlXG4gICAgXHRpZiAoSlNPTi5zdHJpbmdpZnkodGhpcy52YWx1ZSkgIT09IEpTT04uc3RyaW5naWZ5KHZhbHVlKSkge1xuICAgIFx0XHR0aGlzLnNldHVwKHZhbHVlKTtcbiAgICBcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIFx0fVxuICAgIH1cblxuICAgIHN0YXRpYyBpbml0aWFsaXplIChnbCkge1xuICAgIFx0Ly8gQ3VsbGluZ1xuICAgIFx0UmVuZGVyU3RhdGUuY3VsbGluZyA9IG5ldyBSZW5kZXJTdGF0ZShcbiAgICBcdFx0eyBjdWxsOiB0cnVlLCBmYWNlOiBnbC5CQUNLIH0sXG4gICAgXHRcdCh2YWx1ZSkgPT4ge1xuICAgIFx0XHRcdGlmICh2YWx1ZS5jdWxsKSB7XG4gICAgXHRcdFx0XHRnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgICAgICAgICAgIFx0XHRnbC5jdWxsRmFjZSh2YWx1ZS5mYWNlKTtcbiAgICBcdFx0XHR9IGVsc2Uge1xuICAgIFx0XHRcdFx0Z2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgIFx0XHRcdH1cbiAgICBcdFx0fVxuICAgIFx0KTtcblxuICAgIFx0Ly8gQmxlbmRpbmcgbW9kZVxuICAgIFx0UmVuZGVyU3RhdGUuYmxlbmRpbmcgPSBuZXcgUmVuZGVyU3RhdGUoXG4gICAgXHRcdHsgYmxlbmQ6IGZhbHNlLCBzcmM6IGdsLlNSQ19BTFBIQSwgZHN0OiBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBfSxcbiAgICBcdFx0KHZhbHVlKSA9PiB7XG4gICAgXHRcdFx0aWYgKHZhbHVlLmJsZW5kKSB7XG4gICAgICAgICAgICBcdFx0Z2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgICAgICBcdGdsLmJsZW5kRnVuYyh2YWx1ZS5zcmMsIHZhbHVlLmRzdCk7XG4gICAgXHRcdFx0fSBlbHNlIHtcbiAgICBcdFx0XHRcdGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICAgIFx0XHRcdH1cbiAgICBcdFx0fVxuICAgIFx0KTtcblxuICAgIFx0Ly8gRGVwdGggd3JpdGVcbiAgICBcdFJlbmRlclN0YXRlLmRlcHRoX3dyaXRlID0gbmV3IFJlbmRlclN0YXRlKFxuICAgIFx0XHR7IGRlcHRoX3dyaXRlOiB0cnVlIH0sXG4gICAgXHRcdCh2YWx1ZSkgPT4ge1xuICAgICAgICBcdFx0Z2wuZGVwdGhNYXNrKHZhbHVlLmRlcHRoX3dyaXRlKTtcbiAgICBcdFx0fVxuICAgIFx0KTtcblxuICAgIFx0Ly8gRGVwdGggdGVzdFxuICAgIFx0UmVuZGVyU3RhdGUuZGVwdGhfdGVzdCA9IG5ldyBSZW5kZXJTdGF0ZShcbiAgICBcdFx0eyBkZXB0aF90ZXN0OiB0cnVlLCBkZXB0aF9mdW5jOiBnbC5MRVFVQUwgfSxcbiAgICBcdFx0KHZhbHVlKSA9PiB7XG4gICAgXHRcdFx0aWYgKHZhbHVlLmRlcHRoX3Rlc3QpIHtcbiAgICAgICAgICAgIFx0XHRnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgIFx0XHRcdGdsLmRlcHRoRnVuYyh2YWx1ZS5kZXB0aF9mdW5jKTtcbiAgICBcdFx0XHR9IGVsc2Uge1xuICAgICAgICAgICAgXHRcdGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgXHRcdFx0fVxuICAgIFx0XHR9XG4gICAgXHQpO1xuICAgIH1cbn1cbiIsIi8qIGdsb2JhbCBTaGFkZXJQcm9ncmFtICovXG4vLyBHTCBwcm9ncmFtIHdyYXBwZXIgdG8gY2FjaGUgdW5pZm9ybSBsb2NhdGlvbnMvdmFsdWVzLCBkbyBjb21waWxlLXRpbWUgcHJlLXByb2Nlc3Npbmdcbi8vIChpbmplY3RpbmcgI2RlZmluZXMgYW5kICNwcmFnbWEgYmxvY2tzIGludG8gc2hhZGVycyksIGV0Yy5cblxuaW1wb3J0IEdMU0wgZnJvbSAnLi9nbHNsJztcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4vdGV4dHVyZSc7XG5pbXBvcnQgZ2V0RXh0ZW5zaW9uIGZyb20gJy4vZXh0ZW5zaW9ucyc7XG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHN0cmlwIGZyb20gJ3N0cmlwLWNvbW1lbnRzJztcbmltcG9ydCB7IGRlZmF1bHQgYXMgcGFyc2VTaGFkZXJFcnJvcnMgfSBmcm9tICdnbC1zaGFkZXItZXJyb3JzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyUHJvZ3JhbSB7XG5cbiAgICBjb25zdHJ1Y3RvcihnbCwgdmVydGV4X3NvdXJjZSwgZnJhZ21lbnRfc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb21waWxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbXBpbGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcblxuICAgICAgICAvLyBrZXkvdmFsdWVzIGluc2VydGVkIGFzICNkZWZpbmVzIGludG8gc2hhZGVycyBhdCBjb21waWxlLXRpbWVcbiAgICAgICAgdGhpcy5kZWZpbmVzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5kZWZpbmVzfHx7fSk7XG5cbiAgICAgICAgLy8ga2V5L3ZhbHVlcyBmb3IgYmxvY2tzIHRoYXQgY2FuIGJlIGluamVjdGVkIGludG8gc2hhZGVycyBhdCBjb21waWxlLXRpbWVcbiAgICAgICAgdGhpcy5ibG9ja3MgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmJsb2Nrc3x8e30pO1xuXG4gICAgICAgIC8vIGxpc3Qgb2YgZXh0ZW5zaW9ucyB0byBhY3RpdmF0ZVxuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSBvcHRpb25zLmV4dGVuc2lvbnMgfHwgW107XG5cbiAgICAgICAgLy8gSlMtb2JqZWN0IHVuaWZvcm1zIHRoYXQgYXJlIGV4cGVjdGVkIGJ5IHRoaXMgcHJvZ3JhbVxuICAgICAgICAvLyBJZiB0aGV5IGFyZSBub3QgZm91bmQgaW4gdGhlIGV4aXN0aW5nIHNoYWRlciBzb3VyY2UsIHRoZWlyIHR5cGVzIHdpbGwgYmUgaW5mZXJyZWQgYW5kIGRlZmluaXRpb25zXG4gICAgICAgIC8vIGZvciBlYWNoIHdpbGwgYmUgaW5qZWN0ZWQuXG4gICAgICAgIHRoaXMuZGVwZW5kZW50X3VuaWZvcm1zID0gb3B0aW9ucy51bmlmb3JtcztcblxuICAgICAgICB0aGlzLnVuaWZvcm1zID0ge307IC8vIHByb2dyYW0gbG9jYXRpb25zIG9mIHVuaWZvcm1zLCBsYXppbHkgYWRkZWQgYXMgZWFjaCB1bmlmb3JtIGlzIHNldFxuICAgICAgICB0aGlzLmF0dHJpYnMgPSB7fTsgLy8gcHJvZ3JhbSBsb2NhdGlvbnMgb2YgdmVydGV4IGF0dHJpYnV0ZXMsIGxhemlseSBhZGRlZCBhcyBlYWNoIGF0dHJpYnV0ZSBpcyBhY2Nlc3NlZFxuXG4gICAgICAgIHRoaXMudmVydGV4X3NvdXJjZSA9IHZlcnRleF9zb3VyY2U7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRfc291cmNlID0gZnJhZ21lbnRfc291cmNlO1xuXG4gICAgICAgIHRoaXMuaWQgPSBTaGFkZXJQcm9ncmFtLmlkKys7XG4gICAgICAgIFNoYWRlclByb2dyYW0ucHJvZ3JhbXNbdGhpcy5pZF0gPSB0aGlzO1xuICAgICAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7IC8vIGNhbiBwcm92aWRlIGEgcHJvZ3JhbSBuYW1lICh1c2VmdWwgZm9yIGRlYnVnZ2luZylcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmdsLnVzZVByb2dyYW0obnVsbCk7XG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLnVuaWZvcm1zID0ge307XG4gICAgICAgIHRoaXMuYXR0cmlicyA9IHt9O1xuICAgICAgICBkZWxldGUgU2hhZGVyUHJvZ3JhbS5wcm9ncmFtc1t0aGlzLmlkXTtcbiAgICAgICAgdGhpcy5jb21waWxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFVzZSBwcm9ncmFtIHdyYXBwZXIgd2l0aCBzaW1wbGUgc3RhdGUgY2FjaGVcbiAgICB1c2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb21waWxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFNoYWRlclByb2dyYW0uY3VycmVudCAhPT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5jdXJyZW50ID0gdGhpcztcbiAgICB9XG5cbiAgICBjb21waWxlKCkge1xuICAgICAgICBpZiAodGhpcy5jb21waWxpbmcpIHtcbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcihgU2hhZGVyUHJvZ3JhbS5jb21waWxlKCk6IHNraXBwaW5nIGZvciAke3RoaXMuaWR9ICgke3RoaXMubmFtZX0pIGJlY2F1c2UgYWxyZWFkeSBjb21waWxpbmdgKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21waWxpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbXBpbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuXG4gICAgICAgIC8vIENvcHkgc291cmNlcyBmcm9tIHByZS1tb2RpZmllZCB0ZW1wbGF0ZVxuICAgICAgICB0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2UgPSB0aGlzLnZlcnRleF9zb3VyY2U7XG4gICAgICAgIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlID0gdGhpcy5mcmFnbWVudF9zb3VyY2U7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGV4dGVuc2lvbiBhdmFpbGFiaWxpdHlcbiAgICAgICAgbGV0IGV4dGVuc2lvbnMgPSB0aGlzLmNoZWNrRXh0ZW5zaW9ucygpO1xuXG4gICAgICAgIC8vIE1ha2UgbGlzdCBvZiBkZWZpbmVzIHRvIGJlIGluamVjdGVkIGxhdGVyXG4gICAgICAgIHZhciBkZWZpbmVzID0gdGhpcy5idWlsZERlZmluZUxpc3QoKTtcblxuICAgICAgICAvLyBJbmplY3QgdXNlci1kZWZpbmVkIGJsb2NrcyAoYXJiaXRyYXJ5IGNvZGUgcG9pbnRzIG1hdGNoaW5nIG5hbWVkICNwcmFnbWFzKVxuICAgICAgICAvLyBSZXBsYWNlIGFjY29yZGluZyB0byB0aGlzIHBhdHRlcm46XG4gICAgICAgIC8vICNwcmFnbWEgdGFuZ3JhbTogW2tleV1cbiAgICAgICAgLy8gZS5nLiAjcHJhZ21hIHRhbmdyYW06IGdsb2JhbFxuXG4gICAgICAgIC8vIEdhdGhlciBhbGwgYmxvY2sgY29kZSBzbmlwcGV0c1xuICAgICAgICB2YXIgYmxvY2tzID0gdGhpcy5idWlsZFNoYWRlckJsb2NrTGlzdCgpO1xuICAgICAgICB2YXIgcmVnZXhwO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBibG9ja3MpIHtcbiAgICAgICAgICAgIHZhciBibG9jayA9IGJsb2Nrc1trZXldO1xuICAgICAgICAgICAgaWYgKCFibG9jayB8fCAoQXJyYXkuaXNBcnJheShibG9jaykgJiYgYmxvY2subGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXJzdCBmaW5kIGNvZGUgcmVwbGFjZSBwb2ludHMgaW4gc2hhZGVyc1xuICAgICAgICAgICAgcmVnZXhwID0gbmV3IFJlZ0V4cCgnXlxcXFxzKiNwcmFnbWFcXFxccyt0YW5ncmFtOlxcXFxzKycgKyBrZXkgKyAnXFxcXHMqJCcsICdtJyk7XG4gICAgICAgICAgICB2YXIgaW5qZWN0X3ZlcnRleCA9IHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZS5tYXRjaChyZWdleHApO1xuICAgICAgICAgICAgdmFyIGluamVjdF9mcmFnbWVudCA9IHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlLm1hdGNoKHJlZ2V4cCk7XG5cbiAgICAgICAgICAgIC8vIEF2b2lkIG5ldHdvcmsgcmVxdWVzdCBpZiBub3RoaW5nIHRvIHJlcGxhY2VcbiAgICAgICAgICAgIGlmIChpbmplY3RfdmVydGV4ID09IG51bGwgJiYgaW5qZWN0X2ZyYWdtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRWFjaCBrZXkgY2FuIGJlIGEgc2luZ2xlIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzXG4gICAgICAgICAgICB2YXIgc291cmNlID0gYFxcbiR7YmxvY2t9XFxuYDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJsb2NrKSkge1xuICAgICAgICAgICAgICAgIC8vIENvbWJpbmUgYWxsIGJsb2NrcyBpbnRvIG9uZSBzdHJpbmdcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBibG9jay5yZWR1Y2UoKHByZXYsIGN1cikgPT4gYFxcbiR7cHJldn1cXG4ke2N1cn1cXG5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZSA9IGAvLyB0YW5ncmFtLWJsb2NrLXN0YXJ0OiAke2tleX1cXG5gICsgc291cmNlOyAvLyBtYXJrIHN0YXJ0IGFuZCBlbmQgb2YgYmxvY2tcbiAgICAgICAgICAgIHNvdXJjZSArPSBgLy8gdGFuZ3JhbS1ibG9jay1lbmQ6ICR7a2V5fWA7XG5cbiAgICAgICAgICAgIC8vIEluamVjdFxuICAgICAgICAgICAgaWYgKGluamVjdF92ZXJ0ZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZSA9IHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZS5yZXBsYWNlKHJlZ2V4cCwgc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmplY3RfZnJhZ21lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlID0gdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2UucmVwbGFjZShyZWdleHAsIHNvdXJjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCBhICNkZWZpbmUgZm9yIHRoaXMgaW5qZWN0aW9uIHBvaW50XG4gICAgICAgICAgICBkZWZpbmVzWydUQU5HUkFNX0JMT0NLXycgKyBrZXkucmVwbGFjZSgvW1xccy1dKy9nLCAnXycpLnRvVXBwZXJDYXNlKCldID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsZWFuLXVwIGFueSAjcHJhZ21hcyB0aGF0IHdlcmVuJ3QgcmVwbGFjZWQgKHRvIHByZXZlbnQgY29tcGlsZXIgd2FybmluZ3MpXG4gICAgICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJ15cXFxccyojcHJhZ21hLiokJywgJ2dtJyk7XG4gICAgICAgIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZSA9IHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZS5yZXBsYWNlKHJlZ2V4cCwgJycpO1xuICAgICAgICB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZSA9IHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlLnJlcGxhY2UocmVnZXhwLCAnJyk7XG5cbiAgICAgICAgLy8gRGV0ZWN0IHVuaWZvcm0gZGVmaW5pdGlvbnMsIGluamVjdCBhbnkgbWlzc2luZyBvbmVzXG4gICAgICAgIHRoaXMuZW5zdXJlVW5pZm9ybXModGhpcy5kZXBlbmRlbnRfdW5pZm9ybXMpO1xuXG4gICAgICAgIC8vIEJ1aWxkICYgaW5qZWN0IGV4dGVuc2lvbnMgJiBkZWZpbmVzXG4gICAgICAgIC8vIFRoaXMgaXMgZG9uZSAqYWZ0ZXIqIGNvZGUgaW5qZWN0aW9uIHNvIHRoYXQgd2UgY2FuIGFkZCBkZWZpbmVzIGZvciB3aGljaCBjb2RlIHBvaW50cyB3ZXJlIGluamVjdGVkXG4gICAgICAgIGxldCBpbmZvID0gKHRoaXMubmFtZSA/ICh0aGlzLm5hbWUgKyAnIC8gaWQgJyArIHRoaXMuaWQpIDogKCdpZCAnICsgdGhpcy5pZCkpO1xuICAgICAgICBsZXQgaGVhZGVyID0gYC8vIFByb2dyYW06ICR7aW5mb31cXG5gICtcbiAgICAgICAgICAgIFNoYWRlclByb2dyYW0uYnVpbGRFeHRlbnNpb25TdHJpbmcoZXh0ZW5zaW9ucyk7XG5cbiAgICAgICAgZGVmaW5lc1snVEFOR1JBTV9WRVJURVhfU0hBREVSJ10gPSB0cnVlO1xuICAgICAgICBkZWZpbmVzWydUQU5HUkFNX0ZSQUdNRU5UX1NIQURFUiddID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZSA9IGhlYWRlciArIFNoYWRlclByb2dyYW0uYnVpbGREZWZpbmVTdHJpbmcoZGVmaW5lcykgKyB0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2U7XG5cbiAgICAgICAgZGVmaW5lc1snVEFOR1JBTV9WRVJURVhfU0hBREVSJ10gPSBmYWxzZTtcbiAgICAgICAgZGVmaW5lc1snVEFOR1JBTV9GUkFHTUVOVF9TSEFERVInXSA9IHRydWU7XG4gICAgICAgIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlID0gaGVhZGVyICsgU2hhZGVyUHJvZ3JhbS5idWlsZERlZmluZVN0cmluZyhkZWZpbmVzKSArIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlO1xuXG4gICAgICAgIC8vIEFkZCBwcmVjaXNpb24gcXVhbGlmaWVyXG4gICAgICAgIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlID0gJyNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZW5kaWZcXG5cXG4nICsgdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2U7XG5cbiAgICAgICAgLy8gQ29tcGlsZSAmIHNldCB1bmlmb3JtcyB0byBjYWNoZWQgdmFsdWVzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW0gPSBTaGFkZXJQcm9ncmFtLnVwZGF0ZVByb2dyYW0odGhpcy5nbCwgdGhpcy5wcm9ncmFtLCB0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2UsIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlKTtcbiAgICAgICAgICAgIHRoaXMuY29tcGlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jb21waWxpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY29tcGlsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY29tcGlsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG5cbiAgICAgICAgICAgIC8vIHNoYWRlciBlcnJvciBpbmZvXG4gICAgICAgICAgICBpZiAoZXJyb3IudHlwZSA9PT0gJ3ZlcnRleCcgfHwgZXJyb3IudHlwZSA9PT0gJ2ZyYWdtZW50Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhZGVyX2Vycm9ycyA9IGVycm9yLmVycm9ycztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlIG9mIHRoaXMuc2hhZGVyX2Vycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBlLnR5cGUgPSBlcnJvci50eXBlO1xuICAgICAgICAgICAgICAgICAgICBlLmJsb2NrID0gdGhpcy5ibG9jayhlcnJvci50eXBlLCBlLmxpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cobmV3IEVycm9yKGBTaGFkZXJQcm9ncmFtLmNvbXBpbGUoKTogcHJvZ3JhbSAke3RoaXMuaWR9ICgke3RoaXMubmFtZX0pIGVycm9yOmAsIGVycm9yKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVzZSgpO1xuICAgICAgICB0aGlzLnJlZnJlc2hVbmlmb3JtcygpO1xuICAgICAgICB0aGlzLnJlZnJlc2hBdHRyaWJ1dGVzKCk7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBsaXN0IG9mIGRlZmluZXMgKGdsb2JhbCwgdGhlbiBwcm9ncmFtLXNwZWNpZmljKVxuICAgIGJ1aWxkRGVmaW5lTGlzdCgpIHtcbiAgICAgICAgdmFyIGQsIGRlZmluZXMgPSB7fTtcbiAgICAgICAgZm9yIChkIGluIFNoYWRlclByb2dyYW0uZGVmaW5lcykge1xuICAgICAgICAgICAgZGVmaW5lc1tkXSA9IFNoYWRlclByb2dyYW0uZGVmaW5lc1tkXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGQgaW4gdGhpcy5kZWZpbmVzKSB7XG4gICAgICAgICAgICBkZWZpbmVzW2RdID0gdGhpcy5kZWZpbmVzW2RdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZpbmVzO1xuICAgIH1cblxuICAgIC8vIE1ha2UgbGlzdCBvZiBzaGFkZXIgYmxvY2tzIChnbG9iYWwsIHRoZW4gcHJvZ3JhbS1zcGVjaWZpYylcbiAgICBidWlsZFNoYWRlckJsb2NrTGlzdCgpIHtcbiAgICAgICAgdmFyIGQsIGJsb2NrcyA9IHt9O1xuICAgICAgICBmb3IgKGQgaW4gU2hhZGVyUHJvZ3JhbS5ibG9ja3MpIHtcbiAgICAgICAgICAgIGJsb2Nrc1tkXSA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShTaGFkZXJQcm9ncmFtLmJsb2Nrc1tkXSkpIHtcbiAgICAgICAgICAgICAgICBibG9ja3NbZF0ucHVzaCguLi5TaGFkZXJQcm9ncmFtLmJsb2Nrc1tkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBibG9ja3NbZF0gPSBbU2hhZGVyUHJvZ3JhbS5ibG9ja3NbZF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoZCBpbiB0aGlzLmJsb2Nrcykge1xuICAgICAgICAgICAgYmxvY2tzW2RdID0gYmxvY2tzW2RdIHx8IFtdO1xuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmJsb2Nrc1tkXSkpIHtcbiAgICAgICAgICAgICAgICBibG9ja3NbZF0ucHVzaCguLi50aGlzLmJsb2Nrc1tkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBibG9ja3NbZF0ucHVzaCh0aGlzLmJsb2Nrc1tkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrcztcbiAgICB9XG5cbiAgICAvLyBEZXRlY3QgdW5pZm9ybSBkZWZpbml0aW9ucywgaW5qZWN0IGFueSBtaXNzaW5nIG9uZXNcbiAgICBlbnN1cmVVbmlmb3Jtcyh1bmlmb3Jtcykge1xuICAgICAgICBpZiAoIXVuaWZvcm1zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdnMgPSBzdHJpcCh0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2UpO1xuICAgICAgICB2YXIgZnMgPSBzdHJpcCh0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZSk7XG4gICAgICAgIHZhciBpbmplY3QsIHZzX2luamVjdGlvbnMgPSBbXSwgZnNfaW5qZWN0aW9ucyA9IFtdO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBtaXNzaW5nIHVuaWZvcm0gZGVmaW5pdGlvbnNcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB1bmlmb3Jtcykge1xuICAgICAgICAgICAgaW5qZWN0ID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdmVydGV4IHNoYWRlclxuICAgICAgICAgICAgaWYgKCFHTFNMLmlzVW5pZm9ybURlZmluZWQobmFtZSwgdnMpICYmIEdMU0wuaXNTeW1ib2xSZWZlcmVuY2VkKG5hbWUsIHZzKSkge1xuICAgICAgICAgICAgICAgIGlmICghaW5qZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGluamVjdCA9IEdMU0wuZGVmaW5lVW5pZm9ybShuYW1lLCB1bmlmb3Jtc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZy50cmFjZShgUHJvZ3JhbSAke3RoaXMubmFtZX06ICR7bmFtZX0gbm90IGRlZmluZWQgaW4gdmVydGV4IHNoYWRlciwgaW5qZWN0aW5nOiAnJHtpbmplY3R9J2ApO1xuICAgICAgICAgICAgICAgIHZzX2luamVjdGlvbnMucHVzaChpbmplY3QpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgICAgIGlmICghR0xTTC5pc1VuaWZvcm1EZWZpbmVkKG5hbWUsIGZzKSAmJiBHTFNMLmlzU3ltYm9sUmVmZXJlbmNlZChuYW1lLCBmcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpbmplY3QgPSBHTFNMLmRlZmluZVVuaWZvcm0obmFtZSwgdW5pZm9ybXNbbmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2cudHJhY2UoYFByb2dyYW0gJHt0aGlzLm5hbWV9OiAke25hbWV9IG5vdCBkZWZpbmVkIGluIGZyYWdtZW50IHNoYWRlciwgaW5qZWN0aW5nOiAnJHtpbmplY3R9J2ApO1xuICAgICAgICAgICAgICAgIGZzX2luamVjdGlvbnMucHVzaChpbmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5qZWN0IG1pc3NpbmcgdW5pZm9ybXNcbiAgICAgICAgLy8gTk9URTogdGhlc2UgYXJlIGluamVjdGVkIGF0IHRoZSB2ZXJ5IHRvcCBvZiB0aGUgc2hhZGVycywgZXZlbiBiZWZvcmUgYW55ICNkZWZpbmVzIG9yICNwcmFnbWFzIGFyZSBhZGRlZFxuICAgICAgICAvLyB0aGlzIGNvdWxkIGNhdXNlIHNvbWUgaXNzdWVzIHdpdGggY2VydGFpbiAjcHJhZ21hcywgb3Igb3RoZXIgZnVuY3Rpb25zIHRoYXQgbWlnaHQgZXhwZWN0ICNkZWZpbmVzXG4gICAgICAgIGlmICh2c19pbmplY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZSA9IHZzX2luamVjdGlvbnMuam9pbignXFxuJykgKyB0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZnNfaW5qZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZSA9IGZzX2luamVjdGlvbnMuam9pbignXFxuJykgKyB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCB1bmlmb3JtcyBmcm9tIGEgSlMgb2JqZWN0LCB3aXRoIGluZmVycmVkIHR5cGVzXG4gICAgc2V0VW5pZm9ybXModW5pZm9ybXMsIHJlc2V0X3RleHR1cmVfdW5pdCA9IHRydWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBpbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBvbmx5IHVwZGF0ZSB1bmlmb3JtcyB3aGVuIGNoYW5nZWRcblxuICAgICAgICAvLyBUZXh0dXJlIHVuaXRzIG11c3QgYmUgdHJhY2tlZCBhbmQgaW5jcmVtZW50ZWQgZWFjaCB0aW1lIGEgdGV4dHVyZSBzYW1wbGVyIHVuaWZvcm0gaXMgc2V0LlxuICAgICAgICAvLyBCeSBkZWZhdWx0LCB0aGUgdGV4dHVyZSB1bml0IGlzIHJlc2V0IHRvIDAgZWFjaCB0aW1lIHNldFVuaWZvcm1zIGlzIGNhbGxlZCwgYnV0IHRoZXkgY2FuXG4gICAgICAgIC8vIGFsc28gYmUgcHJlc2VydmVkLCBmb3IgZXhhbXBsZSBpbiBjYXNlcyB3aGVyZSBtdWx0aXBsZSBjYWxscyB0byBzZXRVbmlmb3JtcyBhcmUgZXhwZWN0ZWRcbiAgICAgICAgLy8gKGUuZy4gcHJvZ3JhbS1zcGVjaWZpYyB1bmlmb3JtcyBmb2xsb3dlZCBieSBtZXNoLXNwZWNpZmljIG9uZXMpLlxuICAgICAgICBpZiAocmVzZXRfdGV4dHVyZV91bml0KSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVfdW5pdCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXJzZSB1bmlmb3JtIHR5cGVzIGFuZCB2YWx1ZXMgZnJvbSB0aGUgSlMgb2JqZWN0XG4gICAgICAgIHZhciBwYXJzZWQgPSBHTFNMLnBhcnNlVW5pZm9ybXModW5pZm9ybXMpO1xuXG4gICAgICAgIC8vIFNldCBlYWNoIHVuaWZvcm1cbiAgICAgICAgZm9yICh2YXIgdW5pZm9ybSBvZiBwYXJzZWQpIHtcbiAgICAgICAgICAgIGlmICh1bmlmb3JtLnR5cGUgPT09ICdzYW1wbGVyMkQnKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIHRleHR1cmVzLCB3ZSBuZWVkIHRvIHRyYWNrIHRleHR1cmUgdW5pdHMsIHNvIHdlIGhhdmUgYSBzcGVjaWFsIHNldHRlclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGV4dHVyZVVuaWZvcm0odW5pZm9ybS5uYW1lLCB1bmlmb3JtLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudW5pZm9ybSh1bmlmb3JtLm1ldGhvZCwgdW5pZm9ybS5uYW1lLCB1bmlmb3JtLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhY2hlIHNvbWUgb3IgYWxsIHVuaWZvcm0gdmFsdWVzIHNvIHRoZXkgY2FuIGJlIHJlc3RvcmVkXG4gICAgc2F2ZVVuaWZvcm1zKHN1YnNldCkge1xuICAgICAgICBsZXQgdW5pZm9ybXMgPSBzdWJzZXQgfHwgdGhpcy51bmlmb3JtcztcbiAgICAgICAgZm9yIChsZXQgdSBpbiB1bmlmb3Jtcykge1xuICAgICAgICAgICAgbGV0IHVuaWZvcm0gPSB0aGlzLnVuaWZvcm1zW3VdO1xuICAgICAgICAgICAgaWYgKHVuaWZvcm0pIHtcbiAgICAgICAgICAgICAgICB1bmlmb3JtLnNhdmVkX3ZhbHVlID0gdW5pZm9ybS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNhdmVkX3RleHR1cmVfdW5pdCA9IHRoaXMudGV4dHVyZV91bml0IHx8IDA7XG4gICAgfVxuXG4gICAgLy8gUmVzdG9yZSBzb21lIG9yIGFsbCB1bmlmb3JtcyB0byBzYXZlZCB2YWx1ZXNcbiAgICByZXN0b3JlVW5pZm9ybXMoc3Vic2V0KSB7XG4gICAgICAgIGxldCB1bmlmb3JtcyA9IHN1YnNldCB8fCB0aGlzLnVuaWZvcm1zO1xuICAgICAgICBmb3IgKGxldCB1IGluIHVuaWZvcm1zKSB7XG4gICAgICAgICAgICBsZXQgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNbdV07XG4gICAgICAgICAgICBpZiAodW5pZm9ybSAmJiB1bmlmb3JtLnNhdmVkX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybS52YWx1ZSA9IHVuaWZvcm0uc2F2ZWRfdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVVbmlmb3JtKHUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dHVyZV91bml0ID0gdGhpcy5zYXZlZF90ZXh0dXJlX3VuaXQgfHwgMDtcbiAgICB9XG5cbiAgICAvLyBTZXQgYSB0ZXh0dXJlIHVuaWZvcm0sIGZpbmRzIHRleHR1cmUgYnkgbmFtZSBvciBjcmVhdGVzIGEgbmV3IG9uZVxuICAgIHNldFRleHR1cmVVbmlmb3JtKHVuaWZvcm1fbmFtZSwgdGV4dHVyZV9uYW1lKSB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gVGV4dHVyZS50ZXh0dXJlc1t0ZXh0dXJlX25hbWVdO1xuICAgICAgICBpZiAodGV4dHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0ZXh0dXJlID0gbmV3IFRleHR1cmUodGhpcy5nbCwgdGV4dHVyZV9uYW1lKTtcbiAgICAgICAgICAgIHRleHR1cmUubG9hZCh0ZXh0dXJlX25hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dHVyZS5iaW5kKHRoaXMudGV4dHVyZV91bml0KTtcbiAgICAgICAgdGhpcy51bmlmb3JtKCcxaScsIHVuaWZvcm1fbmFtZSwgdGhpcy50ZXh0dXJlX3VuaXQpO1xuICAgICAgICB0aGlzLnRleHR1cmVfdW5pdCsrOyAvLyBUT0RPOiB0cmFjayBtYXggdGV4dHVyZSB1bml0cyBhbmQgbG9nL3Rocm93IGVycm9yc1xuICAgIH1cblxuICAgIC8vIGV4OiBwcm9ncmFtLnVuaWZvcm0oJzNmJywgJ3Bvc2l0aW9uJywgeCwgeSwgeik7XG4gICAgLy8gVE9ETzogb25seSB1cGRhdGUgdW5pZm9ybXMgd2hlbiBjaGFuZ2VkXG4gICAgdW5pZm9ybShtZXRob2QsIG5hbWUsIC4uLnZhbHVlKSB7IC8vICd2YWx1ZScgaXMgYSBtZXRob2QtYXBwcm9wcmlhdGUgYXJndW1lbnRzIGxpc3RcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBpbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVuaWZvcm1zW25hbWVdID0gdGhpcy51bmlmb3Jtc1tuYW1lXSB8fCB7fTtcbiAgICAgICAgbGV0IHVuaWZvcm0gPSB0aGlzLnVuaWZvcm1zW25hbWVdO1xuICAgICAgICB1bmlmb3JtLm5hbWUgPSBuYW1lO1xuICAgICAgICBpZiAodW5pZm9ybS5sb2NhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB1bmlmb3JtLmxvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB1bmlmb3JtLm1ldGhvZCA9ICd1bmlmb3JtJyArIG1ldGhvZDtcbiAgICAgICAgdW5pZm9ybS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZVVuaWZvcm0obmFtZSk7XG4gICAgfVxuXG4gICAgLy8gU2V0IGEgc2luZ2xlIHVuaWZvcm1cbiAgICB1cGRhdGVVbmlmb3JtKG5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBpbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNbbmFtZV07XG4gICAgICAgIGlmICghdW5pZm9ybSB8fCB1bmlmb3JtLmxvY2F0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXNlKCk7XG4gICAgICAgIHRoaXMuZ2xbdW5pZm9ybS5tZXRob2RdLmFwcGx5KHRoaXMuZ2wsIFt1bmlmb3JtLmxvY2F0aW9uXS5jb25jYXQodW5pZm9ybS52YWx1ZSkpOyAvLyBjYWxsIGFwcHJvcHJpYXRlIEdMIHVuaWZvcm0gbWV0aG9kIGFuZCBwYXNzIHRocm91Z2ggYXJndW1lbnRzXG4gICAgfVxuXG4gICAgLy8gUmVmcmVzaCB1bmlmb3JtIGxvY2F0aW9ucyBhbmQgc2V0IHRvIGxhc3QgY2FjaGVkIHZhbHVlc1xuICAgIHJlZnJlc2hVbmlmb3JtcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBpbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciB1IGluIHRoaXMudW5pZm9ybXMpIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXNbdV0ubG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIHUpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVVbmlmb3JtKHUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVmcmVzaEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIC8vIHZhciBsZW4gPSB0aGlzLmdsLmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5wcm9ncmFtLCB0aGlzLmdsLkFDVElWRV9BVFRSSUJVVEVTKTtcbiAgICAgICAgLy8gZm9yICh2YXIgaT0wOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gICAgIHZhciBhID0gdGhpcy5nbC5nZXRBY3RpdmVBdHRyaWIodGhpcy5wcm9ncmFtLCBpKTtcbiAgICAgICAgLy8gfVxuICAgICAgICB0aGlzLmF0dHJpYnMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIGxvY2F0aW9uIG9mIGEgdmVydGV4IGF0dHJpYnV0ZVxuICAgIGF0dHJpYnV0ZShuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5jb21waWxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0dHJpYiA9ICh0aGlzLmF0dHJpYnNbbmFtZV0gPSB0aGlzLmF0dHJpYnNbbmFtZV0gfHwge30pO1xuICAgICAgICBpZiAoYXR0cmliLmxvY2F0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhdHRyaWI7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWIubmFtZSA9IG5hbWU7XG4gICAgICAgIGF0dHJpYi5sb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCBuYW1lKTtcblxuICAgICAgICAvLyB2YXIgaW5mbyA9IHRoaXMuZ2wuZ2V0QWN0aXZlQXR0cmliKHRoaXMucHJvZ3JhbSwgYXR0cmliLmxvY2F0aW9uKTtcbiAgICAgICAgLy8gYXR0cmliLnR5cGUgPSBpbmZvLnR5cGU7XG4gICAgICAgIC8vIGF0dHJpYi5zaXplID0gaW5mby5zaXplO1xuXG4gICAgICAgIHJldHVybiBhdHRyaWI7XG4gICAgfVxuXG4gICAgLy8gR2V0IHNoYWRlciBzb3VyY2UgYXMgc3RyaW5nXG4gICAgc291cmNlKHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICd2ZXJ0ZXgnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdmcmFnbWVudCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdldCBzaGFkZXIgc291cmNlIGFzIGFycmF5IG9mIGxpbmUgc3RyaW5nc1xuICAgIGxpbmVzKHR5cGUpIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IHRoaXMuc291cmNlKHR5cGUpO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gR2V0IGEgc3BlY2lmaWMgbGluZSBmcm9tIHNoYWRlciBzb3VyY2VcbiAgICBsaW5lKHR5cGUsIG51bSkge1xuICAgICAgICBsZXQgc291cmNlID0gdGhpcy5saW5lcyh0eXBlKTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZVtudW1dO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0IGluZm8gb24gd2hpY2ggc2hhZGVyIGJsb2NrIChpZiBhbnkpIGEgcGFydGljdWxhciBsaW5lIG51bWJlciBpbiBhIHNoYWRlciBpcyBpblxuICAgIC8vIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBpbmZvIGlmIGEgYmxvY2sgaXMgZm91bmQ6IHsgbmFtZSwgbGluZSwgc291cmNlIH1cbiAgICAvLyAgbmFtZTogc2hhZGVyIGJsb2NrIG5hbWUgKGUuZy4gJ2NvbG9yJywgJ3Bvc2l0aW9uJywgJ2dsb2JhbCcpXG4gICAgLy8gIGxpbmU6IGxpbmUgbnVtYmVyICp3aXRoaW4qIHRoZSBzaGFkZXIgYmxvY2sgKG5vdCB0aGUgd2hvbGUgc2hhZGVyIHByb2dyYW0pLCB1c2VmdWwgZm9yIGVycm9yIGhpZ2hsaWdodGluZ1xuICAgIC8vICBzb3VyY2U6IHRoZSBjb2RlIGZvciB0aGUgbGluZVxuICAgIC8vIE5PVEU6IHRoaXMgZG9lcyBhIGJydXRlZm9yY2UgbG9vcCBvdmVyIHRoZSBzaGFkZXIgc291cmNlIGFuZCBsb29rcyBmb3Igc2hhZGVyIGJsb2NrIHN0YXJ0L2VuZCBtYXJrZXJzXG4gICAgLy8gV2UgY291bGQgdHJhY2sgbGluZSByYW5nZXMgZm9yIHNoYWRlciBibG9ja3MgYXMgdGhleSBhcmUgaW5zZXJ0ZWQsIGJ1dCBhcyB0aGlzIGNvZGUgaXMgb25seSB1c2VkIGZvclxuICAgIC8vIGVycm9yIGhhbmRsaW5nIG9uIGNvbXBpbGF0aW9uIGZhaWx1cmUsIGl0IHdhcyBzaW1wbGVyIHRvIGtlZXAgaXQgc2VwYXJhdGUgdGhhbiB0byBidXJkZW4gdGhlIGNvcmVcbiAgICAvLyBjb21waWxhdGlvbiBwYXRoLlxuICAgIGJsb2NrKHR5cGUsIG51bSkge1xuICAgICAgICBsZXQgbGluZXMgPSB0aGlzLmxpbmVzKHR5cGUpO1xuICAgICAgICBsZXQgYmxvY2s7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IG51bSAmJiBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gbGluZXNbaV07XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSBsaW5lLm1hdGNoKC9cXC9cXC8gdGFuZ3JhbS1ibG9jay1zdGFydDogKFxcdyspLyk7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGJsb2NrID0geyBuYW1lOiBtYXRjaFsxXSB9OyAvLyBtYXJrIGN1cnJlbnQgYmxvY2tcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gbGluZS5tYXRjaCgvXFwvXFwvIHRhbmdyYW0tYmxvY2stZW5kOiAoXFx3KykvKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBibG9jayA9IG51bGw7IC8vIGNsZWFyIGN1cnJlbnQgYmxvY2tcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBsaW5lICMgYW5kIGNvbnRlbnRcbiAgICAgICAgICAgIGlmIChibG9jaykge1xuICAgICAgICAgICAgICAgIC8vIGluaXQgdG8gLTEgc28gdGhhdCBsaW5lIDAgaXMgZmlyc3QgYWN0dWFsIGxpbmUgb2YgYmxvY2sgY29kZSwgYWZ0ZXIgY29tbWVudCBtYXJrZXJcbiAgICAgICAgICAgICAgICBibG9jay5saW5lID0gKGJsb2NrLmxpbmUgPT0gbnVsbCkgPyAtMSA6IGJsb2NrLmxpbmUgKyAxO1xuICAgICAgICAgICAgICAgIGJsb2NrLnNvdXJjZSA9IGxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgbGlzdCBvZiBhdmFpbGFibGUgZXh0ZW5zaW9ucyBmcm9tIHRob3NlIHJlcXVlc3RlZFxuICAgIC8vIFNldHMgaW50ZXJuYWwgI2RlZmluZXMgaW5kaWNhdGluZyBhdmFpbGFiaWxpdHkgb2YgZWFjaCByZXF1ZXN0ZWQgZXh0ZW5zaW9uXG4gICAgY2hlY2tFeHRlbnNpb25zKCkge1xuICAgICAgICBsZXQgZXh0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHRoaXMuZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgbGV0IGV4dCA9IGdldEV4dGVuc2lvbih0aGlzLmdsLCBuYW1lKTtcbiAgICAgICAgICAgIGxldCBkZWYgPSBgVEFOR1JBTV9FWFRFTlNJT05fJHtuYW1lfWA7XG5cbiAgICAgICAgICAgIHRoaXMuZGVmaW5lc1tkZWZdID0gKGV4dCAhPSBudWxsKTtcblxuICAgICAgICAgICAgaWYgKGV4dCkge1xuICAgICAgICAgICAgICAgIGV4dHMucHVzaChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhgQ291bGQgbm90IGVuYWJsZSBleHRlbnNpb24gJyR7bmFtZX0nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4dHM7XG4gICAgfVxuXG59XG5cblxuLy8gU3RhdGljIG1ldGhvZHMgYW5kIHN0YXRlXG5cblNoYWRlclByb2dyYW0uaWQgPSAwOyAgICAgICAgICAgLy8gYXNzaWduIGVhY2ggcHJvZ3JhbSBhIHVuaXF1ZSBpZFxuU2hhZGVyUHJvZ3JhbS5wcm9ncmFtcyA9IHt9OyAgICAvLyBwcm9ncmFtcywgYnkgaWRcblNoYWRlclByb2dyYW0uY3VycmVudCA9IG51bGw7ICAgLy8gY3VycmVudGx5IGJvdW5kIHByb2dyYW1cblxuLy8gR2xvYmFsIGNvbmZpZyBhcHBsaWVkIHRvIGFsbCBwcm9ncmFtcyAoZHVwbGljYXRlIHByb3BlcnRpZXMgZm9yIGEgc3BlY2lmaWMgcHJvZ3JhbSB3aWxsIHRha2UgcHJlY2VkZW5jZSlcblNoYWRlclByb2dyYW0uZGVmaW5lcyA9IHt9O1xuU2hhZGVyUHJvZ3JhbS5ibG9ja3MgPSB7fTtcblxuLy8gVHVybiBhbiBvYmplY3Qgb2Yga2V5L3ZhbHVlIHBhaXJzIGludG8gc2luZ2xlIHN0cmluZyBvZiAjZGVmaW5lIHN0YXRlbWVudHNcblNoYWRlclByb2dyYW0uYnVpbGREZWZpbmVTdHJpbmcgPSBmdW5jdGlvbiAoZGVmaW5lcykge1xuICAgIHZhciBkZWZpbmVfc3RyID0gXCJcIjtcbiAgICBmb3IgKHZhciBkIGluIGRlZmluZXMpIHtcbiAgICAgICAgaWYgKGRlZmluZXNbZF0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lc1tkXSA9PT0gJ2Jvb2xlYW4nICYmIGRlZmluZXNbZF0gPT09IHRydWUpIHsgLy8gYm9vbGVhbnMgYXJlIHNpbXBsZSBkZWZpbmVzIHdpdGggbm8gdmFsdWVcbiAgICAgICAgICAgIGRlZmluZV9zdHIgKz0gXCIjZGVmaW5lIFwiICsgZCArIFwiXFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZXNbZF0gPT09ICdudW1iZXInICYmIE1hdGguZmxvb3IoZGVmaW5lc1tkXSkgPT09IGRlZmluZXNbZF0pIHsgLy8gaW50IHRvIGZsb2F0IGNvbnZlcnNpb24gdG8gc2F0aXNmeSBHTFNMIGZsb2F0c1xuICAgICAgICAgICAgZGVmaW5lX3N0ciArPSBcIiNkZWZpbmUgXCIgKyBkICsgXCIgXCIgKyBkZWZpbmVzW2RdLnRvRml4ZWQoMSkgKyBcIlxcblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBhbnkgb3RoZXIgZmxvYXQgb3Igc3RyaW5nIHZhbHVlXG4gICAgICAgICAgICBkZWZpbmVfc3RyICs9IFwiI2RlZmluZSBcIiArIGQgKyBcIiBcIiArIGRlZmluZXNbZF0gKyBcIlxcblwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWZpbmVfc3RyO1xufTtcblxuLy8gVHVybiBhIGxpc3Qgb2YgZXh0ZW5zaW9uIG5hbWVzIGludG8gc2luZ2xlIHN0cmluZyBvZiAjZXh0ZW5zaW9uIHN0YXRlbWVudHNcblNoYWRlclByb2dyYW0uYnVpbGRFeHRlbnNpb25TdHJpbmcgPSBmdW5jdGlvbiAoZXh0ZW5zaW9ucykge1xuICAgIGV4dGVuc2lvbnMgPSBleHRlbnNpb25zIHx8IFtdO1xuICAgIGxldCBzdHIgPSBcIlwiO1xuICAgIGZvciAobGV0IGV4dCBvZiBleHRlbnNpb25zKSB7XG4gICAgICAgIHN0ciArPSBgI2V4dGVuc2lvbiBHTF8ke2V4dH0gOiBlbmFibGVcXG5gO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufTtcblxuU2hhZGVyUHJvZ3JhbS5hZGRCbG9jayA9IGZ1bmN0aW9uIChrZXksIC4uLmJsb2Nrcykge1xuICAgIFNoYWRlclByb2dyYW0uYmxvY2tzW2tleV0gPSBTaGFkZXJQcm9ncmFtLmJsb2Nrc1trZXldIHx8IFtdO1xuICAgIFNoYWRlclByb2dyYW0uYmxvY2tzW2tleV0ucHVzaCguLi5ibG9ja3MpO1xufTtcblxuLy8gUmVtb3ZlIGFsbCBnbG9iYWwgc2hhZGVyIGJsb2NrcyBmb3IgYSBnaXZlbiBrZXlcblNoYWRlclByb2dyYW0ucmVtb3ZlQmxvY2sgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgU2hhZGVyUHJvZ3JhbS5ibG9ja3Nba2V5XSA9IFtdO1xufTtcblxuU2hhZGVyUHJvZ3JhbS5yZXBsYWNlQmxvY2sgPSBmdW5jdGlvbiAoa2V5LCAuLi5ibG9ja3MpIHtcbiAgICBTaGFkZXJQcm9ncmFtLnJlbW92ZUJsb2NrKGtleSk7XG4gICAgU2hhZGVyUHJvZ3JhbS5hZGRCbG9jayhrZXksIC4uLmJsb2Nrcyk7XG59O1xuXG4vLyBDb21waWxlICYgbGluayBhIFdlYkdMIHByb2dyYW0gZnJvbSBwcm92aWRlZCB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlciBzb3VyY2VzXG4vLyB1cGRhdGUgYSBwcm9ncmFtIGlmIG9uZSBpcyBwYXNzZWQgaW4uIENyZWF0ZSBvbmUgaWYgbm90LiBBbGVydCBhbmQgZG9uJ3QgdXBkYXRlIGFueXRoaW5nIGlmIHRoZSBzaGFkZXJzIGRvbid0IGNvbXBpbGUuXG5TaGFkZXJQcm9ncmFtLnVwZGF0ZVByb2dyYW0gPSBmdW5jdGlvbiAoZ2wsIHByb2dyYW0sIHZlcnRleF9zaGFkZXJfc291cmNlLCBmcmFnbWVudF9zaGFkZXJfc291cmNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHZlcnRleF9zaGFkZXIgPSBTaGFkZXJQcm9ncmFtLmNyZWF0ZVNoYWRlcihnbCwgdmVydGV4X3NoYWRlcl9zb3VyY2UsIGdsLlZFUlRFWF9TSEFERVIpO1xuICAgICAgICB2YXIgZnJhZ21lbnRfc2hhZGVyID0gU2hhZGVyUHJvZ3JhbS5jcmVhdGVTaGFkZXIoZ2wsIGZyYWdtZW50X3NoYWRlcl9zb3VyY2UsIGdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgfVxuICAgIGNhdGNoKGVycikge1xuICAgICAgICBsb2cuZXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgZ2wudXNlUHJvZ3JhbShudWxsKTtcbiAgICBpZiAocHJvZ3JhbSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBvbGRfc2hhZGVycyA9IGdsLmdldEF0dGFjaGVkU2hhZGVycyhwcm9ncmFtKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG9sZF9zaGFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBnbC5kZXRhY2hTaGFkZXIocHJvZ3JhbSwgb2xkX3NoYWRlcnNbaV0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICB9XG5cbiAgICBpZiAodmVydGV4X3NoYWRlciA9PSBudWxsIHx8IGZyYWdtZW50X3NoYWRlciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cblxuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhfc2hhZGVyKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRfc2hhZGVyKTtcblxuICAgIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhfc2hhZGVyKTtcbiAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRfc2hhZGVyKTtcblxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBXZWJHTCBwcm9ncmFtIGVycm9yOlxuICAgICAgICAgICAgVkFMSURBVEVfU1RBVFVTOiAke2dsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTKX1cbiAgICAgICAgICAgIEVSUk9SOiAke2dsLmdldEVycm9yKCl9XG4gICAgICAgICAgICAtLS0gVmVydGV4IFNoYWRlciAtLS1cbiAgICAgICAgICAgICR7dmVydGV4X3NoYWRlcl9zb3VyY2V9XG4gICAgICAgICAgICAtLS0gRnJhZ21lbnQgU2hhZGVyIC0tLVxuICAgICAgICAgICAgJHtmcmFnbWVudF9zaGFkZXJfc291cmNlfWApO1xuXG4gICAgICAgIGxldCBlcnJvciA9IHsgdHlwZTogJ3Byb2dyYW0nLCBtZXNzYWdlIH07XG4gICAgICAgIGxvZy5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2dyYW07XG59O1xuXG4vLyBDb21waWxlIGEgdmVydGV4IG9yIGZyYWdtZW50IHNoYWRlciBmcm9tIHByb3ZpZGVkIHNvdXJjZVxuU2hhZGVyUHJvZ3JhbS5jcmVhdGVTaGFkZXIgPSBmdW5jdGlvbiAoZ2wsIHNvdXJjZSwgc3R5cGUpIHtcbiAgICBsZXQgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHN0eXBlKTtcblxuICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgICAgbGV0IHR5cGUgPSAoc3R5cGUgPT09IGdsLlZFUlRFWF9TSEFERVIgPyAndmVydGV4JyA6ICdmcmFnbWVudCcpO1xuICAgICAgICBsZXQgbWVzc2FnZSA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcbiAgICAgICAgbGV0IGVycm9ycyA9IHBhcnNlU2hhZGVyRXJyb3JzKG1lc3NhZ2UpO1xuICAgICAgICB0aHJvdyB7IHR5cGUsIG1lc3NhZ2UsIGVycm9ycyB9O1xuICAgIH1cblxuICAgIHJldHVybiBzaGFkZXI7XG59O1xuIiwiLy8gR2VuZXJhdGVkIGZyb20gR0xTTCBmaWxlcywgZG9uJ3QgZWRpdCFcbnZhciBzaGFkZXJTb3VyY2VzID0ge307XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvYW1iaWVudExpZ2h0J10gPVxuXCIvKlxcblwiICtcblwiXFxuXCIgK1xuXCJFeHBlY3RlZCBnbG9iYWxzOlxcblwiICtcblwibGlnaHRfYWNjdW11bGF0b3JfKlxcblwiICtcblwiXFxuXCIgK1xuXCIqL1xcblwiICtcblwiXFxuXCIgK1xuXCJzdHJ1Y3QgQW1iaWVudExpZ2h0IHtcXG5cIiArXG5cIiAgICB2ZWM0IGFtYmllbnQ7XFxuXCIgK1xuXCJ9O1xcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIGNhbGN1bGF0ZUxpZ2h0KGluIEFtYmllbnRMaWdodCBfbGlnaHQsIGluIHZlYzMgX2V5ZVRvUG9pbnQsIGluIHZlYzMgX25vcm1hbCkge1xcblwiICtcblwiICAgIGxpZ2h0X2FjY3VtdWxhdG9yX2FtYmllbnQgKz0gX2xpZ2h0LmFtYmllbnQ7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9kaXJlY3Rpb25hbExpZ2h0J10gPVxuXCIvKlxcblwiICtcblwiXFxuXCIgK1xuXCJFeHBlY3RlZCBnbG9iYWxzOlxcblwiICtcblwibWF0ZXJpYWxcXG5cIiArXG5cImxpZ2h0X2FjY3VtdWxhdG9yXypcXG5cIiArXG5cIlxcblwiICtcblwiKi9cXG5cIiArXG5cIlxcblwiICtcblwic3RydWN0IERpcmVjdGlvbmFsTGlnaHQge1xcblwiICtcblwiICAgIHZlYzQgYW1iaWVudDtcXG5cIiArXG5cIiAgICB2ZWM0IGRpZmZ1c2U7XFxuXCIgK1xuXCIgICAgdmVjNCBzcGVjdWxhcjtcXG5cIiArXG5cIiAgICB2ZWMzIGRpcmVjdGlvbjtcXG5cIiArXG5cIn07XFxuXCIgK1xuXCJcXG5cIiArXG5cInZvaWQgY2FsY3VsYXRlTGlnaHQoaW4gRGlyZWN0aW9uYWxMaWdodCBfbGlnaHQsIGluIHZlYzMgX2V5ZVRvUG9pbnQsIGluIHZlYzMgX25vcm1hbCkge1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgbGlnaHRfYWNjdW11bGF0b3JfYW1iaWVudCArPSBfbGlnaHQuYW1iaWVudDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGZsb2F0IG5Eb3RWUCA9IGNsYW1wKGRvdChfbm9ybWFsLCAtbm9ybWFsaXplKF9saWdodC5kaXJlY3Rpb24pKSwgMC4wLCAxLjApO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRVxcblwiICtcblwiICAgICAgICBsaWdodF9hY2N1bXVsYXRvcl9kaWZmdXNlICs9IF9saWdodC5kaWZmdXNlICogbkRvdFZQO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgcGYgPSAwLjA7XFxuXCIgK1xuXCIgICAgICAgIGlmIChuRG90VlAgPiAwLjApIHtcXG5cIiArXG5cIiAgICAgICAgICAgIHZlYzMgcmVmbGVjdFZlY3RvciA9IHJlZmxlY3Qobm9ybWFsaXplKF9saWdodC5kaXJlY3Rpb24pLCBfbm9ybWFsKTtcXG5cIiArXG5cIiAgICAgICAgICAgIGZsb2F0IGV5ZURvdFIgPSBtYXgoZG90KG5vcm1hbGl6ZShfZXllVG9Qb2ludCksIHJlZmxlY3RWZWN0b3IpLCAwLjApO1xcblwiICtcblwiICAgICAgICAgICAgcGYgPSBwb3coZXllRG90UiwgbWF0ZXJpYWwuc2hpbmluZXNzKTtcXG5cIiArXG5cIiAgICAgICAgfVxcblwiICtcblwiICAgICAgICBsaWdodF9hY2N1bXVsYXRvcl9zcGVjdWxhciArPSBfbGlnaHQuc3BlY3VsYXIgKiBwZjtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL2xheWVyX29yZGVyJ10gPVxuXCIvLyBBcHBseSBsYXllciBvcmRlcmluZyB0byBhdm9pZCB6LWZpZ2h0aW5nXFxuXCIgK1xuXCJ2b2lkIGFwcGx5TGF5ZXJPcmRlciAoZmxvYXQgbGF5ZXIsIGlub3V0IHZlYzQgcG9zaXRpb24pIHtcXG5cIiArXG5cIiAgICBwb3NpdGlvbi56IC09IGxheWVyICogVEFOR1JBTV9MQVlFUl9ERUxUQSAqIHBvc2l0aW9uLnc7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9tYXRlcmlhbCddID1cblwiLypcXG5cIiArXG5cIlxcblwiICtcblwiRGVmaW5lcyBnbG9iYWxzOlxcblwiICtcblwibWF0ZXJpYWxcXG5cIiArXG5cImxpZ2h0X2FjY3VtdWxhdG9yXypcXG5cIiArXG5cIlxcblwiICtcblwiKi9cXG5cIiArXG5cIlxcblwiICtcblwiXFxuXCIgK1xuXCIvLyBNQVRFUklBTFNcXG5cIiArXG5cIi8vXFxuXCIgK1xuXCJzdHJ1Y3QgTWF0ZXJpYWwge1xcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0VNSVNTSU9OXFxuXCIgK1xuXCIgICAgICAgIHZlYzQgZW1pc3Npb247XFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0VNSVNTSU9OX1RFWFRVUkVcXG5cIiArXG5cIiAgICAgICAgICAgIHZlYzMgZW1pc3Npb25TY2FsZTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9BTUJJRU5UXFxuXCIgK1xuXCIgICAgICAgIHZlYzQgYW1iaWVudDtcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfQU1CSUVOVF9URVhUVVJFXFxuXCIgK1xuXCIgICAgICAgICAgICB2ZWMzIGFtYmllbnRTY2FsZTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFXFxuXCIgK1xuXCIgICAgICAgIHZlYzQgZGlmZnVzZTtcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRV9URVhUVVJFXFxuXCIgK1xuXCIgICAgICAgICAgICB2ZWMzIGRpZmZ1c2VTY2FsZTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUlxcblwiICtcblwiICAgICAgICB2ZWM0IHNwZWN1bGFyO1xcblwiICtcblwiICAgICAgICBmbG9hdCBzaGluaW5lc3M7XFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSX1RFWFRVUkVcXG5cIiArXG5cIiAgICAgICAgICAgIHZlYzMgc3BlY3VsYXJTY2FsZTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX05PUk1BTF9URVhUVVJFXFxuXCIgK1xuXCIgICAgICAgIHZlYzMgbm9ybWFsU2NhbGU7XFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IG5vcm1hbEFtb3VudDtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIn07XFxuXCIgK1xuXCJcXG5cIiArXG5cIi8vIE5vdGU6IHVuaWZvcm0gaXMgY29waWVkIHRvIGEgZ2xvYmFsIGluc3RhbmNlIHRvIGFsbG93IG1vZGlmaWNhdGlvblxcblwiICtcblwidW5pZm9ybSBNYXRlcmlhbCB1X21hdGVyaWFsO1xcblwiICtcblwiTWF0ZXJpYWwgbWF0ZXJpYWwgPSB1X21hdGVyaWFsO1xcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9FTUlTU0lPTl9URVhUVVJFXFxuXCIgK1xuXCJ1bmlmb3JtIHNhbXBsZXIyRCB1X21hdGVyaWFsX2VtaXNzaW9uX3RleHR1cmU7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfQU1CSUVOVF9URVhUVVJFXFxuXCIgK1xuXCJ1bmlmb3JtIHNhbXBsZXIyRCB1X21hdGVyaWFsX2FtYmllbnRfdGV4dHVyZTtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFX1RFWFRVUkVcXG5cIiArXG5cInVuaWZvcm0gc2FtcGxlcjJEIHVfbWF0ZXJpYWxfZGlmZnVzZV90ZXh0dXJlO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSX1RFWFRVUkVcXG5cIiArXG5cInVuaWZvcm0gc2FtcGxlcjJEIHVfbWF0ZXJpYWxfc3BlY3VsYXJfdGV4dHVyZTtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9OT1JNQUxfVEVYVFVSRVxcblwiICtcblwidW5pZm9ybSBzYW1wbGVyMkQgdV9tYXRlcmlhbF9ub3JtYWxfdGV4dHVyZTtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIvLyBHbG9iYWwgbGlnaHQgYWNjdW11bGF0b3JzIGZvciBlYWNoIHByb3BlcnR5XFxuXCIgK1xuXCJ2ZWM0IGxpZ2h0X2FjY3VtdWxhdG9yX2FtYmllbnQgPSB2ZWM0KDAuMCk7XFxuXCIgK1xuXCJ2ZWM0IGxpZ2h0X2FjY3VtdWxhdG9yX2RpZmZ1c2UgPSB2ZWM0KDAuMCk7XFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUlxcblwiICtcblwiICAgIHZlYzQgbGlnaHRfYWNjdW11bGF0b3Jfc3BlY3VsYXIgPSB2ZWM0KDAuMCk7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9URVhUVVJFX1NQSEVSRU1BUFxcblwiICtcblwidmVjNCBnZXRTcGhlcmVNYXAgKGluIHNhbXBsZXIyRCBfdGV4LCBpbiB2ZWMzIF9leWVUb1BvaW50LCBpbiB2ZWMzIF9ub3JtYWwsIGluIHZlYzIgX3NrZXcpIHtcXG5cIiArXG5cIiAgICB2ZWMzIGV5ZSA9IG5vcm1hbGl6ZShfZXllVG9Qb2ludCk7XFxuXCIgK1xuXCIgICAgZXllLnh5IC09IF9za2V3O1xcblwiICtcblwiICAgIGV5ZSA9IG5vcm1hbGl6ZShleWUpO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgdmVjMyByID0gcmVmbGVjdChleWUsIF9ub3JtYWwpO1xcblwiICtcblwiICAgIHIueiArPSAxLjA7XFxuXCIgK1xuXCIgICAgZmxvYXQgbSA9IDIuICogbGVuZ3RoKHIpO1xcblwiICtcblwiICAgIHZlYzIgdXYgPSByLnh5IC8gbSArIC41O1xcblwiICtcblwiICAgIHJldHVybiB0ZXh0dXJlMkQoX3RleCwgdXYpO1xcblwiICtcblwifVxcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfVEVYVFVSRV9UUklQTEFOQVJcXG5cIiArXG5cInZlYzMgZ2V0VHJpUGxhbmFyQmxlbmQgKGluIHZlYzMgX25vcm1hbCkge1xcblwiICtcblwiICAgIHZlYzMgYmxlbmRpbmcgPSBhYnMoX25vcm1hbCk7XFxuXCIgK1xuXCIgICAgYmxlbmRpbmcgPSBub3JtYWxpemUobWF4KGJsZW5kaW5nLCAwLjAwMDAxKSk7XFxuXCIgK1xuXCIgICAgZmxvYXQgYiA9IChibGVuZGluZy54ICsgYmxlbmRpbmcueSArIGJsZW5kaW5nLnopO1xcblwiICtcblwiICAgIHJldHVybiBibGVuZGluZyAvIGI7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcXG5cIiArXG5cInZlYzQgZ2V0VHJpUGxhbmFyIChpbiBzYW1wbGVyMkQgX3RleCwgaW4gdmVjMyBfcG9zLCBpbiB2ZWMzIF9ub3JtYWwsIGluIHZlYzMgX3NjYWxlKSB7XFxuXCIgK1xuXCIgICAgdmVjMyBibGVuZGluZyA9IGdldFRyaVBsYW5hckJsZW5kKF9ub3JtYWwpO1xcblwiICtcblwiICAgIHZlYzQgeGF4aXMgPSB0ZXh0dXJlMkQoX3RleCwgZnJhY3QoX3Bvcy55eiAqIF9zY2FsZS54KSk7XFxuXCIgK1xuXCIgICAgdmVjNCB5YXhpcyA9IHRleHR1cmUyRChfdGV4LCBmcmFjdChfcG9zLnh6ICogX3NjYWxlLnkpKTtcXG5cIiArXG5cIiAgICB2ZWM0IHpheGlzID0gdGV4dHVyZTJEKF90ZXgsIGZyYWN0KF9wb3MueHkgKiBfc2NhbGUueikpO1xcblwiICtcblwiICAgIHJldHVybiAgeGF4aXMgKiBibGVuZGluZy54ICsgeWF4aXMgKiBibGVuZGluZy55ICsgemF4aXMgKiBibGVuZGluZy56O1xcblwiICtcblwifVxcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfVEVYVFVSRV9QTEFOQVJcXG5cIiArXG5cInZlYzQgZ2V0UGxhbmFyIChpbiBzYW1wbGVyMkQgX3RleCwgaW4gdmVjMyBfcG9zLCBpbiB2ZWMyIF9zY2FsZSkge1xcblwiICtcblwiICAgIHJldHVybiB0ZXh0dXJlMkQoIF90ZXgsIGZyYWN0KF9wb3MueHkgKiBfc2NhbGUueCkgKTtcXG5cIiArXG5cIn1cXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX05PUk1BTF9URVhUVVJFXFxuXCIgK1xuXCJ2b2lkIGNhbGN1bGF0ZU5vcm1hbCAoaW5vdXQgdmVjMyBfbm9ybWFsKSB7XFxuXCIgK1xuXCIgICAgLy8gR2V0IE5PUk1BTE1BUFxcblwiICtcblwiICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfTk9STUFMX1RFWFRVUkVfVVZcXG5cIiArXG5cIiAgICBfbm9ybWFsICs9IHRleHR1cmUyRCh1X21hdGVyaWFsX25vcm1hbF90ZXh0dXJlLCBmcmFjdCh2X3RleGNvb3JkKm1hdGVyaWFsLm5vcm1hbFNjYWxlLnh5KSkucmdiKjIuMC0xLjA7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9OT1JNQUxfVEVYVFVSRV9QTEFOQVJcXG5cIiArXG5cIiAgICB2ZWMzIG5vcm1hbFRleCA9IGdldFBsYW5hcih1X21hdGVyaWFsX25vcm1hbF90ZXh0dXJlLCB2X3dvcmxkX3Bvc2l0aW9uLnh5eiwgbWF0ZXJpYWwubm9ybWFsU2NhbGUueHkpLnJnYioyLjAtMS4wO1xcblwiICtcblwiICAgIF9ub3JtYWwgKz0gbm9ybWFsVGV4O1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfTk9STUFMX1RFWFRVUkVfVFJJUExBTkFSXFxuXCIgK1xuXCIgICAgdmVjMyBub3JtYWxUZXggPSBnZXRUcmlQbGFuYXIodV9tYXRlcmlhbF9ub3JtYWxfdGV4dHVyZSwgdl93b3JsZF9wb3NpdGlvbi54eXosIF9ub3JtYWwsIG1hdGVyaWFsLm5vcm1hbFNjYWxlKS5yZ2IqMi4wLTEuMDtcXG5cIiArXG5cIiAgICBfbm9ybWFsICs9IG5vcm1hbFRleDtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIF9ub3JtYWwgPSBub3JtYWxpemUoX25vcm1hbCk7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBjYWxjdWxhdGVNYXRlcmlhbCAoaW4gdmVjMyBfZXllVG9Qb2ludCwgaW5vdXQgdmVjMyBfbm9ybWFsKSB7XFxuXCIgK1xuXCIgICAgLy8gZ2V0IEVNSVNTSU9OIFRFWFRVUkVNQVBcXG5cIiArXG5cIiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0VNSVNTSU9OX1RFWFRVUkVcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRU1JU1NJT05fVEVYVFVSRV9VVlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5lbWlzc2lvbiAqPSB0ZXh0dXJlMkQodV9tYXRlcmlhbF9lbWlzc2lvbl90ZXh0dXJlLHZfdGV4Y29vcmQpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9FTUlTU0lPTl9URVhUVVJFX1BMQU5BUlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5lbWlzc2lvbiAqPSBnZXRQbGFuYXIodV9tYXRlcmlhbF9lbWlzc2lvbl90ZXh0dXJlLCB2X3dvcmxkX3Bvc2l0aW9uLnh5eiwgbWF0ZXJpYWwuZW1pc3Npb25TY2FsZS54eSk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0VNSVNTSU9OX1RFWFRVUkVfVFJJUExBTkFSXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLmVtaXNzaW9uICo9IGdldFRyaVBsYW5hcih1X21hdGVyaWFsX2VtaXNzaW9uX3RleHR1cmUsIHZfd29ybGRfcG9zaXRpb24ueHl6LCBfbm9ybWFsLCBtYXRlcmlhbC5lbWlzc2lvblNjYWxlKTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRU1JU1NJT05fVEVYVFVSRV9TUEhFUkVNQVBcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuZW1pc3Npb24gKj0gZ2V0U3BoZXJlTWFwKHVfbWF0ZXJpYWxfZW1pc3Npb25fdGV4dHVyZSwgX2V5ZVRvUG9pbnQsIF9ub3JtYWwsIHVfdmFuaXNoaW5nX3BvaW50KTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBnZXQgQU1CSUVOVCBURVhUVVJFTUFQXFxuXCIgK1xuXCIgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9BTUJJRU5UX1RFWFRVUkVcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfQU1CSUVOVF9URVhUVVJFX1VWXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLmFtYmllbnQgKj0gdGV4dHVyZTJEKHVfbWF0ZXJpYWxfYW1iaWVudF90ZXh0dXJlLHZfdGV4Y29vcmQpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9BTUJJRU5UX1RFWFRVUkVfUExBTkFSXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLmFtYmllbnQgKj0gZ2V0UGxhbmFyKHVfbWF0ZXJpYWxfYW1iaWVudF90ZXh0dXJlLCB2X3dvcmxkX3Bvc2l0aW9uLnh5eiwgbWF0ZXJpYWwuYW1iaWVudFNjYWxlLnh5KTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfQU1CSUVOVF9URVhUVVJFX1RSSVBMQU5BUlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5hbWJpZW50ICo9IGdldFRyaVBsYW5hcih1X21hdGVyaWFsX2FtYmllbnRfdGV4dHVyZSwgdl93b3JsZF9wb3NpdGlvbi54eXosIF9ub3JtYWwsIG1hdGVyaWFsLmFtYmllbnRTY2FsZSk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0FNQklFTlRfVEVYVFVSRV9TUEhFUkVNQVBcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuYW1iaWVudCAqPSBnZXRTcGhlcmVNYXAodV9tYXRlcmlhbF9hbWJpZW50X3RleHR1cmUsIF9leWVUb1BvaW50LCBfbm9ybWFsLCB1X3ZhbmlzaGluZ19wb2ludCk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gZ2V0IERJRkZVU0UgVEVYVFVSRU1BUFxcblwiICtcblwiICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRV9URVhUVVJFXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VfVEVYVFVSRV9VVlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5kaWZmdXNlICo9IHRleHR1cmUyRCh1X21hdGVyaWFsX2RpZmZ1c2VfdGV4dHVyZSx2X3RleGNvb3JkKTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRV9URVhUVVJFX1BMQU5BUlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5kaWZmdXNlICo9IGdldFBsYW5hcih1X21hdGVyaWFsX2RpZmZ1c2VfdGV4dHVyZSwgdl93b3JsZF9wb3NpdGlvbi54eXosIG1hdGVyaWFsLmRpZmZ1c2VTY2FsZS54eSk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VfVEVYVFVSRV9UUklQTEFOQVJcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuZGlmZnVzZSAqPSBnZXRUcmlQbGFuYXIodV9tYXRlcmlhbF9kaWZmdXNlX3RleHR1cmUsIHZfd29ybGRfcG9zaXRpb24ueHl6LCBfbm9ybWFsLCBtYXRlcmlhbC5kaWZmdXNlU2NhbGUpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFX1RFWFRVUkVfU1BIRVJFTUFQXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLmRpZmZ1c2UgKj0gZ2V0U3BoZXJlTWFwKHVfbWF0ZXJpYWxfZGlmZnVzZV90ZXh0dXJlLCBfZXllVG9Qb2ludCwgX25vcm1hbCwgdV92YW5pc2hpbmdfcG9pbnQpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIGdldCBTUEVDVUxBUiBURVhUVVJFTUFQXFxuXCIgK1xuXCIgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUl9URVhUVVJFXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSX1RFWFRVUkVfVVZcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuc3BlY3VsYXIgKj0gdGV4dHVyZTJEKHVfbWF0ZXJpYWxfc3BlY3VsYXJfdGV4dHVyZSx2X3RleGNvb3JkKTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJfVEVYVFVSRV9QTEFOQVJcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuc3BlY3VsYXIgKj0gZ2V0UGxhbmFyKHVfbWF0ZXJpYWxfc3BlY3VsYXJfdGV4dHVyZSwgdl93b3JsZF9wb3NpdGlvbi54eXosIG1hdGVyaWFsLnNwZWN1bGFyU2NhbGUueHkpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUl9URVhUVVJFX1RSSVBMQU5BUlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5zcGVjdWxhciAqPSBnZXRUcmlQbGFuYXIodV9tYXRlcmlhbF9zcGVjdWxhcl90ZXh0dXJlLCB2X3dvcmxkX3Bvc2l0aW9uLnh5eiwgX25vcm1hbCwgbWF0ZXJpYWwuc3BlY3VsYXJTY2FsZSk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSX1RFWFRVUkVfU1BIRVJFTUFQXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLnNwZWN1bGFyICo9IGdldFNwaGVyZU1hcCh1X21hdGVyaWFsX3NwZWN1bGFyX3RleHR1cmUsIF9leWVUb1BvaW50LCBfbm9ybWFsLCB1X3ZhbmlzaGluZ19wb2ludCk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvcG9pbnRMaWdodCddID1cblwiLypcXG5cIiArXG5cIlxcblwiICtcblwiRXhwZWN0ZWQgZ2xvYmFsczpcXG5cIiArXG5cIm1hdGVyaWFsXFxuXCIgK1xuXCJsaWdodF9hY2N1bXVsYXRvcl8qXFxuXCIgK1xuXCJcXG5cIiArXG5cIiovXFxuXCIgK1xuXCJcXG5cIiArXG5cInN0cnVjdCBQb2ludExpZ2h0IHtcXG5cIiArXG5cIiAgICB2ZWM0IGFtYmllbnQ7XFxuXCIgK1xuXCIgICAgdmVjNCBkaWZmdXNlO1xcblwiICtcblwiICAgIHZlYzQgc3BlY3VsYXI7XFxuXCIgK1xuXCIgICAgdmVjNCBwb3NpdGlvbjtcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9FWFBPTkVOVFxcblwiICtcblwiICAgIGZsb2F0IGF0dGVudWF0aW9uRXhwb25lbnQ7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9JTk5FUl9SQURJVVNcXG5cIiArXG5cIiAgICBmbG9hdCBpbm5lclJhZGl1cztcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX09VVEVSX1JBRElVU1xcblwiICtcblwiICAgIGZsb2F0IG91dGVyUmFkaXVzO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJ9O1xcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIGNhbGN1bGF0ZUxpZ2h0KGluIFBvaW50TGlnaHQgX2xpZ2h0LCBpbiB2ZWMzIF9leWVUb1BvaW50LCBpbiB2ZWMzIF9ub3JtYWwpIHtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgoX2xpZ2h0LnBvc2l0aW9uLnh5eiAtIF9leWVUb1BvaW50KTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIENvbXB1dGUgdmVjdG9yIGZyb20gc3VyZmFjZSB0byBsaWdodCBwb3NpdGlvblxcblwiICtcblwiICAgIHZlYzMgVlAgPSAoX2xpZ2h0LnBvc2l0aW9uLnh5eiAtIF9leWVUb1BvaW50KSAvIGRpc3Q7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBOb3JtYWxpemUgdGhlIHZlY3RvciBmcm9tIHN1cmZhY2UgdG8gbGlnaHQgcG9zaXRpb25cXG5cIiArXG5cIiAgICBmbG9hdCBuRG90VlAgPSBjbGFtcChkb3QoVlAsIF9ub3JtYWwpLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBBdHRlbnVhdGlvbiBkZWZhdWx0c1xcblwiICtcblwiICAgIGZsb2F0IGF0dGVudWF0aW9uID0gMS4wO1xcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fRVhQT05FTlRcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgUmluID0gMS4wO1xcblwiICtcblwiICAgICAgICBmbG9hdCBlID0gX2xpZ2h0LmF0dGVudWF0aW9uRXhwb25lbnQ7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9JTk5FUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgIFJpbiA9IF9saWdodC5pbm5lclJhZGl1cztcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgIGZsb2F0IFJkaWZmID0gX2xpZ2h0Lm91dGVyUmFkaXVzLVJpbjtcXG5cIiArXG5cIiAgICAgICAgICAgIGZsb2F0IGQgPSBjbGFtcChtYXgoMC4wLGRpc3QtUmluKS9SZGlmZiwgMC4wLCAxLjApO1xcblwiICtcblwiICAgICAgICAgICAgYXR0ZW51YXRpb24gPSAxLjAtKHBvdyhkLGUpKTtcXG5cIiArXG5cIiAgICAgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgICAgIC8vIElmIG5vIG91dGVyIGlzIHByb3ZpZGUgYmVoYXZlcyBsaWtlOlxcblwiICtcblwiICAgICAgICAgICAgLy8gaHR0cHM6Ly9pbWRvaW5naXR3cm9uZy53b3JkcHJlc3MuY29tLzIwMTEvMDEvMzEvbGlnaHQtYXR0ZW51YXRpb24vXFxuXCIgK1xuXCIgICAgICAgICAgICBmbG9hdCBkID0gbWF4KDAuMCxkaXN0LVJpbikvUmluKzEuMDtcXG5cIiArXG5cIiAgICAgICAgICAgIGF0dGVudWF0aW9uID0gY2xhbXAoMS4wLyhwb3coZCxlKSksIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgUmluID0gMC4wO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fSU5ORVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICBSaW4gPSBfbGlnaHQuaW5uZXJSYWRpdXM7XFxuXCIgK1xuXCIgICAgICAgICAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX09VVEVSX1JBRElVU1xcblwiICtcblwiICAgICAgICAgICAgICAgIGZsb2F0IFJkaWZmID0gX2xpZ2h0Lm91dGVyUmFkaXVzLVJpbjtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBkID0gY2xhbXAobWF4KDAuMCxkaXN0LVJpbikvUmRpZmYsIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IDEuMC1kKmQ7XFxuXCIgK1xuXCIgICAgICAgICAgICAjZWxzZVxcblwiICtcblwiICAgICAgICAgICAgICAgIC8vIElmIG5vIG91dGVyIGlzIHByb3ZpZGUgYmVoYXZlcyBsaWtlOlxcblwiICtcblwiICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaW1kb2luZ2l0d3Jvbmcud29yZHByZXNzLmNvbS8yMDExLzAxLzMxL2xpZ2h0LWF0dGVudWF0aW9uL1xcblwiICtcblwiICAgICAgICAgICAgICAgIGZsb2F0IGQgPSBtYXgoMC4wLGRpc3QtUmluKS9SaW4rMS4wO1xcblwiICtcblwiICAgICAgICAgICAgICAgIGF0dGVudWF0aW9uID0gY2xhbXAoMS4wL2QsIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICAgICAjZWxzZVxcblwiICtcblwiICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBkID0gY2xhbXAoZGlzdC9fbGlnaHQub3V0ZXJSYWRpdXMsIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IDEuMC1kKmQ7XFxuXCIgK1xuXCIgICAgICAgICAgICAjZWxzZVxcblwiICtcblwiICAgICAgICAgICAgICAgIGF0dGVudWF0aW9uID0gMS4wO1xcblwiICtcblwiICAgICAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gQ29tcHV0ZXIgYWNjdW11bGF0b3JzXFxuXCIgK1xuXCIgICAgbGlnaHRfYWNjdW11bGF0b3JfYW1iaWVudCArPSBfbGlnaHQuYW1iaWVudCAqIGF0dGVudWF0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRVxcblwiICtcblwiICAgICAgICBsaWdodF9hY2N1bXVsYXRvcl9kaWZmdXNlICs9IF9saWdodC5kaWZmdXNlICogbkRvdFZQICogYXR0ZW51YXRpb247XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUlxcblwiICtcblwiICAgICAgICBmbG9hdCBwZiA9IDAuMDsgLy8gcG93ZXIgZmFjdG9yIGZvciBzaGlueSBzcGVjdWxhcnNcXG5cIiArXG5cIiAgICAgICAgaWYgKG5Eb3RWUCA+IDAuMCkge1xcblwiICtcblwiICAgICAgICAgICAgdmVjMyByZWZsZWN0VmVjdG9yID0gcmVmbGVjdCgtVlAsIF9ub3JtYWwpO1xcblwiICtcblwiICAgICAgICAgICAgZmxvYXQgZXllRG90UiA9IG1heCgwLjAsIGRvdCgtbm9ybWFsaXplKF9leWVUb1BvaW50KSwgcmVmbGVjdFZlY3RvcikpO1xcblwiICtcblwiICAgICAgICAgICAgcGYgPSBwb3coZXllRG90UiwgbWF0ZXJpYWwuc2hpbmluZXNzKTtcXG5cIiArXG5cIiAgICAgICAgfVxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIGxpZ2h0X2FjY3VtdWxhdG9yX3NwZWN1bGFyICs9IF9saWdodC5zcGVjdWxhciAqIHBmICogYXR0ZW51YXRpb247XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9zZWxlY3Rpb25fZnJhZ21lbnQnXSA9XG5cIi8vIEZyYWdtZW50IHNoYWRlciBmb3IgZmVhdHVyZSBzZWxlY3Rpb24gcGFzc2VzXFxuXCIgK1xuXCIvLyBSZW5kZXJzIGluIHNpbGhvdWV0dGUgYWNjb3JkaW5nIHRvIHNlbGVjdGlvbiAocGlja2luZykgY29sb3IsIG9yIGJsYWNrIGlmIG5vbmUgZGVmaW5lZFxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9GRUFUVVJFX1NFTEVDVElPTlxcblwiICtcblwiICAgIHZhcnlpbmcgdmVjNCB2X3NlbGVjdGlvbl9jb2xvcjtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIG1haW4gKHZvaWQpIHtcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9GRUFUVVJFX1NFTEVDVElPTlxcblwiICtcblwiICAgICAgICBnbF9GcmFnQ29sb3IgPSB2X3NlbGVjdGlvbl9jb2xvcjtcXG5cIiArXG5cIiAgICAjZWxzZVxcblwiICtcblwiICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuLCAwLiwgMC4sIDEuKTtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3NlbGVjdGlvbl9nbG9iYWxzJ10gPVxuXCIvLyBWZXJ0ZXggYXR0cmlidXRlICsgdmFyeWluZyBmb3IgZmVhdHVyZSBzZWxlY3Rpb25cXG5cIiArXG5cIiNpZiBkZWZpbmVkKFRBTkdSQU1fRkVBVFVSRV9TRUxFQ1RJT04pICYmIGRlZmluZWQoVEFOR1JBTV9WRVJURVhfU0hBREVSKVxcblwiICtcblwiICAgIGF0dHJpYnV0ZSB2ZWM0IGFfc2VsZWN0aW9uX2NvbG9yO1xcblwiICtcblwiICAgIHZhcnlpbmcgdmVjNCB2X3NlbGVjdGlvbl9jb2xvcjtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvc2VsZWN0aW9uX3ZlcnRleCddID1cblwiLy8gU2VsZWN0aW9uIHBhc3Mtc3BlY2lmaWMgcmVuZGVyaW5nXFxuXCIgK1xuXCIjaWYgZGVmaW5lZChUQU5HUkFNX0ZFQVRVUkVfU0VMRUNUSU9OKSAmJiBkZWZpbmVkKFRBTkdSQU1fVkVSVEVYX1NIQURFUilcXG5cIiArXG5cIiAgICBpZiAoYV9zZWxlY3Rpb25fY29sb3IucmdiID09IHZlYzMoMC4pKSB7XFxuXCIgK1xuXCIgICAgICAgIC8vIERpc2NhcmQgYnkgZm9yY2luZyBpbnZhbGlkIHRyaWFuZ2xlIGlmIHdlXFwncmUgaW4gdGhlIGZlYXR1cmVcXG5cIiArXG5cIiAgICAgICAgLy8gc2VsZWN0aW9uIHBhc3MgYnV0IGhhdmUgbm8gc2VsZWN0aW9uIGluZm9cXG5cIiArXG5cIiAgICAgICAgLy8gVE9ETzogaW4gc29tZSBjYXNlcyB3ZSBtYXkgYWN0dWFsbHkgd2FudCBub24tc2VsZWN0YWJsZSBmZWF0dXJlcyB0byBvY2NsdWRlIHNlbGVjdGFibGUgb25lcz9cXG5cIiArXG5cIiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KDAuLCAwLiwgMC4sIDEuKTtcXG5cIiArXG5cIiAgICAgICAgcmV0dXJuO1xcblwiICtcblwiICAgIH1cXG5cIiArXG5cIiAgICB2X3NlbGVjdGlvbl9jb2xvciA9IGFfc2VsZWN0aW9uX2NvbG9yO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9zcGhlcmljYWxfZW52aXJvbm1lbnRfbWFwJ10gPVxuXCIvLyBTcGhlcmljYWwgZW52aXJvbm1lbnQgbWFwXFxuXCIgK1xuXCIvLyBCYXNlZCBvbjogaHR0cDovL3d3dy5jbGlja3RvcmVsZWFzZS5jb20vYmxvZy9jcmVhdGluZy1zcGhlcmljYWwtZW52aXJvbm1lbnQtbWFwcGluZy1zaGFkZXJcXG5cIiArXG5cIlxcblwiICtcblwiLy8gdmlldzogbG9jYXRpb24gb2YgY2FtZXJhXFxuXCIgK1xuXCIvLyBwb3NpdGlvbjogbG9jYXRpb24gb2YgY3VycmVudCBwb2ludCBvbiBzdXJmYWNlXFxuXCIgK1xuXCIvLyBub3JtYWw6IG5vcm1hbCBvZiBjdXJyZW50IHBvaW50IG9uIHN1cmZhY2VcXG5cIiArXG5cIi8vIHNrZXc6IHNrZXdpbmcgZmFjdG9yICh1c2VkIHRvIGNvbXBlbnNhdGUgZm9yIGFsdGVyZWQgdmFuaXNoaW5nIHBvaW50KVxcblwiICtcblwiLy8gZW52bWFwOiBzcGhlcmljYWwgZW52aXJvbm1lbnQgbWFwIHRleHR1cmVcXG5cIiArXG5cIlxcblwiICtcblwidmVjNCBzcGhlcmljYWxFbnZpcm9ubWVudE1hcCh2ZWMzIHZpZXcsIHZlYzMgcG9zaXRpb24sIHZlYzMgbm9ybWFsLCB2ZWMyIHNrZXcsIHNhbXBsZXIyRCBlbnZtYXApIHtcXG5cIiArXG5cIiAgICAvLyBOb3JtYWxpemVkIHZlY3RvciBmcm9tIGNhbWVyYSB0byBzdXJmYWNlXFxuXCIgK1xuXCIgICAgdmVjMyBleWUgPSBub3JtYWxpemUocG9zaXRpb24ueHl6IC0gdmlldy54eXopO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gU2tld1xcblwiICtcblwiICAgIGV5ZS54eSAtPSBza2V3O1xcblwiICtcblwiICAgIGV5ZSA9IG5vcm1hbGl6ZShleWUpO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gUmVmbGVjdGlvbiBvZiBleWUgb2ZmIG9mIHN1cmZhY2Ugbm9ybWFsXFxuXCIgK1xuXCIgICAgdmVjMyByID0gcmVmbGVjdChleWUsIG5vcm1hbCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBNYXAgcmVmbGVjdGVkIHZlY3RvciBvbnRvIHRoZSBzdXJmYWNlIG9mIGEgc3BoZXJlXFxuXCIgK1xuXCIgICAgci56ICs9IDEuO1xcblwiICtcblwiICAgIGZsb2F0IG0gPSAyLiAqIGxlbmd0aChyKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIEFkanVzdCB4eSB0byBhY2NvdW50IGZvciBzcGhlcmljYWwgc2hhcGUsIGFuZCBjZW50ZXIgaW4gbWlkZGxlIG9mIHRleHR1cmVcXG5cIiArXG5cIiAgICB2ZWMyIHV2ID0gci54eSAvIG0gKyAuNTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFNhbXBsZSB0aGUgZW52aXJvbm1lbnQgbWFwXFxuXCIgK1xuXCIgICAgcmV0dXJuIHRleHR1cmUyRChlbnZtYXAsIHV2KTtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3Nwb3RMaWdodCddID1cblwiLypcXG5cIiArXG5cIlxcblwiICtcblwiRXhwZWN0ZWQgZ2xvYmFsczpcXG5cIiArXG5cIm1hdGVyaWFsXFxuXCIgK1xuXCJsaWdodF9hY2N1bXVsYXRvcl8qXFxuXCIgK1xuXCJcXG5cIiArXG5cIiovXFxuXCIgK1xuXCJcXG5cIiArXG5cInN0cnVjdCBTcG90TGlnaHQge1xcblwiICtcblwiICAgIHZlYzQgYW1iaWVudDtcXG5cIiArXG5cIiAgICB2ZWM0IGRpZmZ1c2U7XFxuXCIgK1xuXCIgICAgdmVjNCBzcGVjdWxhcjtcXG5cIiArXG5cIiAgICB2ZWM0IHBvc2l0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0VYUE9ORU5UXFxuXCIgK1xuXCIgICAgZmxvYXQgYXR0ZW51YXRpb25FeHBvbmVudDtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0lOTkVSX1JBRElVU1xcblwiICtcblwiICAgIGZsb2F0IGlubmVyUmFkaXVzO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fT1VURVJfUkFESVVTXFxuXCIgK1xuXCIgICAgZmxvYXQgb3V0ZXJSYWRpdXM7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIHZlYzMgZGlyZWN0aW9uO1xcblwiICtcblwiICAgIGZsb2F0IHNwb3RDb3NDdXRvZmY7XFxuXCIgK1xuXCIgICAgZmxvYXQgc3BvdEV4cG9uZW50O1xcblwiICtcblwifTtcXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBjYWxjdWxhdGVMaWdodChpbiBTcG90TGlnaHQgX2xpZ2h0LCBpbiB2ZWMzIF9leWVUb1BvaW50LCBpbiB2ZWMzIF9ub3JtYWwpIHtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgoX2xpZ2h0LnBvc2l0aW9uLnh5eiAtIF9leWVUb1BvaW50KTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIENvbXB1dGUgdmVjdG9yIGZyb20gc3VyZmFjZSB0byBsaWdodCBwb3NpdGlvblxcblwiICtcblwiICAgIHZlYzMgVlAgPSAoX2xpZ2h0LnBvc2l0aW9uLnh5eiAtIF9leWVUb1BvaW50KSAvIGRpc3Q7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBub3JtYWwgLiBsaWdodCBkaXJlY3Rpb25cXG5cIiArXG5cIiAgICBmbG9hdCBuRG90VlAgPSBjbGFtcChkb3QoX25vcm1hbCwgVlApLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBBdHRlbnVhdGlvbiBkZWZhdWx0c1xcblwiICtcblwiICAgIGZsb2F0IGF0dGVudWF0aW9uID0gMS4wO1xcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fRVhQT05FTlRcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgUmluID0gMS4wO1xcblwiICtcblwiICAgICAgICBmbG9hdCBlID0gX2xpZ2h0LmF0dGVudWF0aW9uRXhwb25lbnQ7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9JTk5FUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgIFJpbiA9IF9saWdodC5pbm5lclJhZGl1cztcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgIGZsb2F0IFJkaWZmID0gX2xpZ2h0Lm91dGVyUmFkaXVzLVJpbjtcXG5cIiArXG5cIiAgICAgICAgICAgIGZsb2F0IGQgPSBjbGFtcChtYXgoMC4wLGRpc3QtUmluKS9SZGlmZiwgMC4wLCAxLjApO1xcblwiICtcblwiICAgICAgICAgICAgYXR0ZW51YXRpb24gPSAxLjAtKHBvdyhkLGUpKTtcXG5cIiArXG5cIiAgICAgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgICAgIC8vIElmIG5vIG91dGVyIGlzIHByb3ZpZGUgYmVoYXZlcyBsaWtlOlxcblwiICtcblwiICAgICAgICAgICAgLy8gaHR0cHM6Ly9pbWRvaW5naXR3cm9uZy53b3JkcHJlc3MuY29tLzIwMTEvMDEvMzEvbGlnaHQtYXR0ZW51YXRpb24vXFxuXCIgK1xuXCIgICAgICAgICAgICBmbG9hdCBkID0gbWF4KDAuMCxkaXN0LVJpbikvUmluKzEuMDtcXG5cIiArXG5cIiAgICAgICAgICAgIGF0dGVudWF0aW9uID0gY2xhbXAoMS4wLyhwb3coZCxlKSksIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgUmluID0gMC4wO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fSU5ORVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICBSaW4gPSBfbGlnaHQuaW5uZXJSYWRpdXM7XFxuXCIgK1xuXCIgICAgICAgICAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX09VVEVSX1JBRElVU1xcblwiICtcblwiICAgICAgICAgICAgICAgIGZsb2F0IFJkaWZmID0gX2xpZ2h0Lm91dGVyUmFkaXVzLVJpbjtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBkID0gY2xhbXAobWF4KDAuMCxkaXN0LVJpbikvUmRpZmYsIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IDEuMC1kKmQ7XFxuXCIgK1xuXCIgICAgICAgICAgICAjZWxzZVxcblwiICtcblwiICAgICAgICAgICAgICAgIC8vIElmIG5vIG91dGVyIGlzIHByb3ZpZGUgYmVoYXZlcyBsaWtlOlxcblwiICtcblwiICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaW1kb2luZ2l0d3Jvbmcud29yZHByZXNzLmNvbS8yMDExLzAxLzMxL2xpZ2h0LWF0dGVudWF0aW9uL1xcblwiICtcblwiICAgICAgICAgICAgICAgIGZsb2F0IGQgPSBtYXgoMC4wLGRpc3QtUmluKS9SaW4rMS4wO1xcblwiICtcblwiICAgICAgICAgICAgICAgIGF0dGVudWF0aW9uID0gY2xhbXAoMS4wL2QsIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICAgICAjZWxzZVxcblwiICtcblwiICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBkID0gY2xhbXAoZGlzdC9fbGlnaHQub3V0ZXJSYWRpdXMsIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IDEuMC1kKmQ7XFxuXCIgK1xuXCIgICAgICAgICAgICAjZWxzZVxcblwiICtcblwiICAgICAgICAgICAgICAgIGF0dGVudWF0aW9uID0gMS4wO1xcblwiICtcblwiICAgICAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gc3BvdGxpZ2h0IGF0dGVudWF0aW9uIGZhY3RvclxcblwiICtcblwiICAgIGZsb2F0IHNwb3RBdHRlbnVhdGlvbiA9IDAuMDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFNlZSBpZiBwb2ludCBvbiBzdXJmYWNlIGlzIGluc2lkZSBjb25lIG9mIGlsbHVtaW5hdGlvblxcblwiICtcblwiICAgIGZsb2F0IHNwb3REb3QgPSBjbGFtcChkb3QoLVZQLCBub3JtYWxpemUoX2xpZ2h0LmRpcmVjdGlvbikpLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBpZiAoc3BvdERvdCA+PSBfbGlnaHQuc3BvdENvc0N1dG9mZikge1xcblwiICtcblwiICAgICAgICBzcG90QXR0ZW51YXRpb24gPSBwb3coc3BvdERvdCwgX2xpZ2h0LnNwb3RFeHBvbmVudCk7XFxuXCIgK1xuXCIgICAgfVxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgbGlnaHRfYWNjdW11bGF0b3JfYW1iaWVudCArPSBfbGlnaHQuYW1iaWVudCAqIGF0dGVudWF0aW9uICogc3BvdEF0dGVudWF0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRVxcblwiICtcblwiICAgICAgICBsaWdodF9hY2N1bXVsYXRvcl9kaWZmdXNlICs9IF9saWdodC5kaWZmdXNlICogbkRvdFZQICogYXR0ZW51YXRpb24gKiBzcG90QXR0ZW51YXRpb247XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUlxcblwiICtcblwiICAgICAgICAvLyBQb3dlciBmYWN0b3IgZm9yIHNoaW55IHNwZWN1bGFyc1xcblwiICtcblwiICAgICAgICBmbG9hdCBwZiA9IDAuMDtcXG5cIiArXG5cIiAgICAgICAgaWYgKG5Eb3RWUCA+IDAuMCkge1xcblwiICtcblwiICAgICAgICAgICAgdmVjMyByZWZsZWN0VmVjdG9yID0gcmVmbGVjdCgtVlAsIF9ub3JtYWwpO1xcblwiICtcblwiICAgICAgICAgICAgZmxvYXQgZXllRG90UiA9IG1heChkb3QoLW5vcm1hbGl6ZShfZXllVG9Qb2ludCksIHJlZmxlY3RWZWN0b3IpLCAwLjApO1xcblwiICtcblwiICAgICAgICAgICAgcGYgPSBwb3coZXllRG90UiwgbWF0ZXJpYWwuc2hpbmluZXNzKTtcXG5cIiArXG5cIiAgICAgICAgfVxcblwiICtcblwiICAgICAgICBsaWdodF9hY2N1bXVsYXRvcl9zcGVjdWxhciArPSBfbGlnaHQuc3BlY3VsYXIgKiBwZiAqIGF0dGVudWF0aW9uICogc3BvdEF0dGVudWF0aW9uO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvd29ybGRfcG9zaXRpb25fd3JhcCddID1cblwiLy8gRGVmaW5lIGEgd3JhcCB2YWx1ZSBmb3Igd29ybGQgY29vcmRpbmF0ZXMgKGFsbG93cyBtb3JlIHByZWNpc2lvbiBhdCBoaWdoZXIgem9vbXMpXFxuXCIgK1xuXCIvLyBlLmcuIGF0IHdyYXAgMTAwMCwgdGhlIHdvcmxkIHNwYWNlIHdpbGwgd3JhcCBldmVyeSAxMDAwIG1ldGVyc1xcblwiICtcblwiI2lmIGRlZmluZWQoVEFOR1JBTV9XT1JMRF9QT1NJVElPTl9XUkFQKVxcblwiICtcblwiICAgIHZlYzIgd29ybGRfcG9zaXRpb25fYW5jaG9yID0gdmVjMihmbG9vcih1X3RpbGVfb3JpZ2luIC8gVEFOR1JBTV9XT1JMRF9QT1NJVElPTl9XUkFQKSAqIFRBTkdSQU1fV09STERfUE9TSVRJT05fV1JBUCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBDb252ZXJ0IGJhY2sgdG8gYWJzb2x1dGUgd29ybGQgcG9zaXRpb24gaWYgbmVlZGVkXFxuXCIgK1xuXCIgICAgdmVjNCBhYnNvbHV0ZVdvcmxkUG9zaXRpb24gKCkge1xcblwiICtcblwiICAgICAgICByZXR1cm4gdmVjNCh2X3dvcmxkX3Bvc2l0aW9uLnh5ICsgd29ybGRfcG9zaXRpb25fYW5jaG9yLCB2X3dvcmxkX3Bvc2l0aW9uLnosIHZfd29ybGRfcG9zaXRpb24udyk7XFxuXCIgK1xuXCIgICAgfVxcblwiICtcblwiI2Vsc2VcXG5cIiArXG5cIiAgICB2ZWM0IGFic29sdXRlV29ybGRQb3NpdGlvbiAoKSB7XFxuXCIgK1xuXCIgICAgICAgIHJldHVybiB2X3dvcmxkX3Bvc2l0aW9uO1xcblwiICtcblwiICAgIH1cXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ3N0eWxlcy9wb2ludHMvcG9pbnRzX2ZyYWdtZW50J10gPVxuXCJ1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X21ldGVyc19wZXJfcGl4ZWw7XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfZGV2aWNlX3BpeGVsX3JhdGlvO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X3RpbWU7XFxuXCIgK1xuXCJ1bmlmb3JtIHZlYzMgdV9tYXBfcG9zaXRpb247XFxuXCIgK1xuXCJ1bmlmb3JtIHZlYzMgdV90aWxlX29yaWdpbjtcXG5cIiArXG5cIlxcblwiICtcblwidW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlO1xcblwiICtcblwiXFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cIiArXG5cInZhcnlpbmcgdmVjMiB2X3RleGNvb3JkO1xcblwiICtcblwidmFyeWluZyB2ZWM0IHZfd29ybGRfcG9zaXRpb247XFxuXCIgK1xuXCJcXG5cIiArXG5cIi8vIEFscGhhIGRpc2NhcmQgdGhyZXNob2xkIChzdWJzdGl0dXRlIGZvciBhbHBoYSBibGVuZGluZylcXG5cIiArXG5cIiNpZm5kZWYgVEFOR1JBTV9BTFBIQV9ESVNDQVJEXFxuXCIgK1xuXCIjZGVmaW5lIFRBTkdSQU1fQUxQSEFfRElTQ0FSRCAwLjVcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIvLyBBbHBoYSBmYWRlIHJhbmdlIGZvciBlZGdlcyBvZiBwb2ludHNcXG5cIiArXG5cIiNpZm5kZWYgVEFOR1JBTV9GQURFX1JBTkdFXFxuXCIgK1xuXCIjZGVmaW5lIFRBTkdSQU1fRkFERV9SQU5HRSAuMTVcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiI2RlZmluZSBUQU5HUkFNX0ZBREVfU1RBUlQgKDEuIC0gVEFOR1JBTV9GQURFX1JBTkdFKVxcblwiICtcblwiXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGdsb2JhbFxcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIG1haW4gKHZvaWQpIHtcXG5cIiArXG5cIiAgICB2ZWM0IGNvbG9yID0gdl9jb2xvcjtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIEFwcGx5IGEgdGV4dHVyZVxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UX1RFWFRVUkVcXG5cIiArXG5cIiAgICAgICAgY29sb3IgKj0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl90ZXhjb29yZCk7XFxuXCIgK1xuXCIgICAgLy8gRHJhdyBhIHBvaW50XFxuXCIgK1xuXCIgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgLy8gRmFkZSBhbHBoYSBuZWFyIGNpcmNsZSBlZGdlXFxuXCIgK1xuXCIgICAgICAgIHZlYzIgdXYgPSB2X3RleGNvb3JkICogMi4gLSAxLjtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgcG9pbnRfZGlzdCA9IGxlbmd0aCh1dik7XFxuXCIgK1xuXCIgICAgICAgIGNvbG9yLmEgPSBjbGFtcCgxLiAtIChzbW9vdGhzdGVwKDAuLCBUQU5HUkFNX0ZBREVfUkFOR0UsIChwb2ludF9kaXN0IC0gVEFOR1JBTV9GQURFX1NUQVJUKSkgLyBUQU5HUkFNX0ZBREVfUkFOR0UpLCAwLiwgMS4pO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gSWYgYmxlbmRpbmcgaXMgb2ZmLCB1c2UgYWxwaGEgZGlzY2FyZCBhcyBhIGxvd2VyLXF1YWxpdHkgc3Vic3RpdHV0ZVxcblwiICtcblwiICAgICNpZm5kZWYgVEFOR1JBTV9CTEVORF9PVkVSTEFZXFxuXCIgK1xuXCIgICAgICAgIGlmIChjb2xvci5hIDwgVEFOR1JBTV9BTFBIQV9ESVNDQVJEKSB7XFxuXCIgK1xuXCIgICAgICAgICAgICBkaXNjYXJkO1xcblwiICtcblwiICAgICAgICB9XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBNYW51YWxseSB1bi1tdWx0aXBseSBhbHBoYSwgZm9yIGNhc2VzIHdoZXJlIHRleHR1cmUgaGFzIHByZS1tdWx0aXBsaWVkIGFscGhhXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fVU5NVUxUSVBMWV9BTFBIQVxcblwiICtcblwiICAgICAgICBjb2xvci5yZ2IgLz0gbWF4KGNvbG9yLmEsIDAuMDAxKTtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNwcmFnbWEgdGFuZ3JhbTogY29sb3JcXG5cIiArXG5cIiAgICAjcHJhZ21hIHRhbmdyYW06IGZpbHRlclxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snc3R5bGVzL3BvaW50cy9wb2ludHNfdmVydGV4J10gPVxuXCJ1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X3RpbWU7XFxuXCIgK1xuXCJ1bmlmb3JtIHZlYzMgdV9tYXBfcG9zaXRpb247XFxuXCIgK1xuXCJ1bmlmb3JtIHZlYzMgdV90aWxlX29yaWdpbjtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV9tZXRlcnNfcGVyX3BpeGVsO1xcblwiICtcblwiXFxuXCIgK1xuXCJ1bmlmb3JtIG1hdDQgdV9tb2RlbDtcXG5cIiArXG5cInVuaWZvcm0gbWF0NCB1X21vZGVsVmlldztcXG5cIiArXG5cIlxcblwiICtcblwiYXR0cmlidXRlIHZlYzQgYV9wb3NpdGlvbjtcXG5cIiArXG5cImF0dHJpYnV0ZSB2ZWM0IGFfc2hhcGU7XFxuXCIgK1xuXCJhdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcblwiICtcblwiYXR0cmlidXRlIHZlYzIgYV90ZXhjb29yZDtcXG5cIiArXG5cIlxcblwiICtcblwidmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzIgdl90ZXhjb29yZDtcXG5cIiArXG5cInZhcnlpbmcgdmVjNCB2X3dvcmxkX3Bvc2l0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGNhbWVyYVxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBnbG9iYWxcXG5cIiArXG5cIlxcblwiICtcblwidmVjMiByb3RhdGUyRCh2ZWMyIF9zdCwgZmxvYXQgX2FuZ2xlKSB7XFxuXCIgK1xuXCIgICAgcmV0dXJuIG1hdDIoY29zKF9hbmdsZSksLXNpbihfYW5nbGUpLFxcblwiICtcblwiICAgICAgICAgICAgICAgIHNpbihfYW5nbGUpLGNvcyhfYW5nbGUpKSAqIF9zdDtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBtYWluKCkge1xcblwiICtcblwiICAgIC8vIEFkZHMgdmVydGV4IHNoYWRlciBzdXBwb3J0IGZvciBmZWF0dXJlIHNlbGVjdGlvblxcblwiICtcblwiICAgICNwcmFnbWEgdGFuZ3JhbTogZmVhdHVyZS1zZWxlY3Rpb24tdmVydGV4XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICB2X2NvbG9yID0gYV9jb2xvcjtcXG5cIiArXG5cIiAgICB2X3RleGNvb3JkID0gYV90ZXhjb29yZDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIEFwcGx5IHNjYWxpbmcgaW4gc2NyZWVuIHNwYWNlXFxuXCIgK1xuXCIgICAgdmVjNCBzaGFwZSA9IGFfc2hhcGU7XFxuXCIgK1xuXCIgICAgZmxvYXQgenNjYWxlID0gZnJhY3QodV9tYXBfcG9zaXRpb24ueikgKiAoc2hhcGUudyAqIDI1Ni4gLSAxLikgKyAxLjtcXG5cIiArXG5cIiAgICAvLyBmbG9hdCB6c2NhbGUgPSBsb2coZnJhY3QodV9tYXBfcG9zaXRpb24ueikgKyAxLikgLyBsb2coMi4pICogKHNoYXBlLncgLSAxLikgKyAxLjtcXG5cIiArXG5cIiAgICB2ZWMyIHNoYXBlX29mZnNldCA9IHNoYXBlLnh5ICogMjU2LiAqIHpzY2FsZTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFBvc2l0aW9uXFxuXCIgK1xuXCIgICAgdmVjNCBwb3NpdGlvbiA9IHVfbW9kZWxWaWV3ICogdmVjNChhX3Bvc2l0aW9uLnh5eiAqIDMyNzY3LiwgMS4pO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gV29ybGQgY29vcmRpbmF0ZXMgZm9yIDNkIHByb2NlZHVyYWwgdGV4dHVyZXNcXG5cIiArXG5cIiAgICB2X3dvcmxkX3Bvc2l0aW9uID0gdV9tb2RlbCAqIHBvc2l0aW9uO1xcblwiICtcblwiICAgIHZfd29ybGRfcG9zaXRpb24ueHkgKz0gc2hhcGVfb2Zmc2V0ICogdV9tZXRlcnNfcGVyX3BpeGVsO1xcblwiICtcblwiICAgICNpZiBkZWZpbmVkKFRBTkdSQU1fV09STERfUE9TSVRJT05fV1JBUClcXG5cIiArXG5cIiAgICAgICAgdl93b3JsZF9wb3NpdGlvbi54eSAtPSB3b3JsZF9wb3NpdGlvbl9hbmNob3I7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBNb2RpZnkgcG9zaXRpb24gYmVmb3JlIGNhbWVyYSBwcm9qZWN0aW9uXFxuXCIgK1xuXCIgICAgI3ByYWdtYSB0YW5ncmFtOiBwb3NpdGlvblxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgY2FtZXJhUHJvamVjdGlvbihwb3NpdGlvbik7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9MQVlFUl9PUkRFUlxcblwiICtcblwiICAgICAgICBhcHBseUxheWVyT3JkZXIoYV9wb3NpdGlvbi53ICogMzI3NjcuLCBwb3NpdGlvbik7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBwb3NpdGlvbi54eSArPSByb3RhdGUyRChzaGFwZV9vZmZzZXQsIHJhZGlhbnMoc2hhcGUueiAqIDM2MC4pKSAqIDIuICogcG9zaXRpb24udyAvIHVfcmVzb2x1dGlvbjtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGdsX1Bvc2l0aW9uID0gcG9zaXRpb247XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snc3R5bGVzL3BvbHlnb25zL3BvbHlnb25zX2ZyYWdtZW50J10gPVxuXCJ1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X21ldGVyc19wZXJfcGl4ZWw7XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfZGV2aWNlX3BpeGVsX3JhdGlvO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X3RpbWU7XFxuXCIgK1xuXCJ1bmlmb3JtIHZlYzMgdV9tYXBfcG9zaXRpb247XFxuXCIgK1xuXCJ1bmlmb3JtIHZlYzMgdV90aWxlX29yaWdpbjtcXG5cIiArXG5cIlxcblwiICtcblwidmFyeWluZyB2ZWM0IHZfcG9zaXRpb247XFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzMgdl9ub3JtYWw7XFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cIiArXG5cInZhcnlpbmcgdmVjNCB2X3dvcmxkX3Bvc2l0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9URVhUVVJFX0NPT1JEU1xcblwiICtcblwiICAgIHZhcnlpbmcgdmVjMiB2X3RleGNvb3JkO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZiBkZWZpbmVkKFRBTkdSQU1fTElHSFRJTkdfVkVSVEVYKVxcblwiICtcblwiICAgIHZhcnlpbmcgdmVjNCB2X2xpZ2h0aW5nO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNwcmFnbWEgdGFuZ3JhbTogY2FtZXJhXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IG1hdGVyaWFsXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGxpZ2h0aW5nXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGdsb2JhbFxcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIG1haW4gKHZvaWQpIHtcXG5cIiArXG5cIiAgICB2ZWM0IGNvbG9yID0gdl9jb2xvcjtcXG5cIiArXG5cIiAgICB2ZWMzIG5vcm1hbCA9IHZfbm9ybWFsO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfTk9STUFMX1RFWFRVUkVcXG5cIiArXG5cIiAgICAgICAgY2FsY3VsYXRlTm9ybWFsKG5vcm1hbCk7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBNb2RpZnkgbm9ybWFsIGJlZm9yZSBsaWdodGluZ1xcblwiICtcblwiICAgICNwcmFnbWEgdGFuZ3JhbTogbm9ybWFsXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBNb2RpZnkgY29sb3IgYW5kIG1hdGVyaWFsIHByb3BlcnRpZXMgYmVmb3JlIGxpZ2h0aW5nXFxuXCIgK1xuXCIgICAgI2lmICFkZWZpbmVkKFRBTkdSQU1fTElHSFRJTkdfVkVSVEVYKVxcblwiICtcblwiICAgICNwcmFnbWEgdGFuZ3JhbTogY29sb3JcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZiBkZWZpbmVkKFRBTkdSQU1fTElHSFRJTkdfRlJBR01FTlQpXFxuXCIgK1xuXCIgICAgICAgIGNvbG9yID0gY2FsY3VsYXRlTGlnaHRpbmcodl9wb3NpdGlvbi54eXogLSB1X2V5ZSwgbm9ybWFsLCBjb2xvcik7XFxuXCIgK1xuXCIgICAgI2VsaWYgZGVmaW5lZChUQU5HUkFNX0xJR0hUSU5HX1ZFUlRFWClcXG5cIiArXG5cIiAgICAgICAgY29sb3IgPSB2X2xpZ2h0aW5nO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gTW9kaWZ5IGNvbG9yIGFmdGVyIGxpZ2h0aW5nIChmaWx0ZXItbGlrZSBlZmZlY3RzIHRoYXQgZG9uXFwndCByZXF1aXJlIGEgYWRkaXRpb25hbCByZW5kZXIgcGFzc2VzKVxcblwiICtcblwiICAgICNwcmFnbWEgdGFuZ3JhbTogZmlsdGVyXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydzdHlsZXMvcG9seWdvbnMvcG9seWdvbnNfdmVydGV4J10gPVxuXCJ1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X3RpbWU7XFxuXCIgK1xuXCJ1bmlmb3JtIHZlYzMgdV9tYXBfcG9zaXRpb247XFxuXCIgK1xuXCJ1bmlmb3JtIHZlYzMgdV90aWxlX29yaWdpbjtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV9tZXRlcnNfcGVyX3BpeGVsO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X2RldmljZV9waXhlbF9yYXRpbztcXG5cIiArXG5cIlxcblwiICtcblwidW5pZm9ybSBtYXQ0IHVfbW9kZWw7XFxuXCIgK1xuXCJ1bmlmb3JtIG1hdDQgdV9tb2RlbFZpZXc7XFxuXCIgK1xuXCJ1bmlmb3JtIG1hdDMgdV9ub3JtYWxNYXRyaXg7XFxuXCIgK1xuXCJcXG5cIiArXG5cImF0dHJpYnV0ZSB2ZWM0IGFfcG9zaXRpb247XFxuXCIgK1xuXCJhdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcblwiICtcblwiXFxuXCIgK1xuXCIvLyBPcHRpb25hbCBub3JtYWwgYXR0cmlidXRlLCBvdGhlcndpc2UgZGVmYXVsdCB0byB1cFxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTk9STUFMX0FUVFJJQlVURVxcblwiICtcblwiICAgIGF0dHJpYnV0ZSB2ZWMzIGFfbm9ybWFsO1xcblwiICtcblwiICAgICNkZWZpbmUgVEFOR1JBTV9OT1JNQUwgYV9ub3JtYWxcXG5cIiArXG5cIiNlbHNlXFxuXCIgK1xuXCIgICAgI2RlZmluZSBUQU5HUkFNX05PUk1BTCB2ZWMzKDAuLCAwLiwgMS4pXFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiLy8gT3B0aW9uYWwgZHluYW1pYyBsaW5lIGV4dHJ1c2lvblxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fRVhUUlVERV9MSU5FU1xcblwiICtcblwiICAgIC8vIHh5OiBleHRydXNpb24gZGlyZWN0aW9uIGluIHh5IHBsYW5lXFxuXCIgK1xuXCIgICAgLy8gejogIGhhbGYtd2lkdGggb2YgbGluZSAoYW1vdW50IHRvIGV4dHJ1ZGUpXFxuXCIgK1xuXCIgICAgLy8gdzogIHNjYWxpbmcgZmFjdG9yIGZvciBpbnRlcnBvbGF0aW5nIHdpZHRoIGJldHdlZW4gem9vbXNcXG5cIiArXG5cIiAgICBhdHRyaWJ1dGUgdmVjNCBhX2V4dHJ1ZGU7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwidmFyeWluZyB2ZWM0IHZfcG9zaXRpb247XFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzMgdl9ub3JtYWw7XFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cIiArXG5cInZhcnlpbmcgdmVjNCB2X3dvcmxkX3Bvc2l0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCIvLyBPcHRpb25hbCB0ZXh0dXJlIFVWc1xcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fVEVYVFVSRV9DT09SRFNcXG5cIiArXG5cIiAgICBhdHRyaWJ1dGUgdmVjMiBhX3RleGNvb3JkO1xcblwiICtcblwiICAgIHZhcnlpbmcgdmVjMiB2X3RleGNvb3JkO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZiBkZWZpbmVkKFRBTkdSQU1fTElHSFRJTkdfVkVSVEVYKVxcblwiICtcblwiICAgIHZhcnlpbmcgdmVjNCB2X2xpZ2h0aW5nO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNwcmFnbWEgdGFuZ3JhbTogY2FtZXJhXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IG1hdGVyaWFsXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGxpZ2h0aW5nXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGdsb2JhbFxcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIG1haW4oKSB7XFxuXCIgK1xuXCIgICAgLy8gQWRkcyB2ZXJ0ZXggc2hhZGVyIHN1cHBvcnQgZm9yIGZlYXR1cmUgc2VsZWN0aW9uXFxuXCIgK1xuXCIgICAgI3ByYWdtYSB0YW5ncmFtOiBmZWF0dXJlLXNlbGVjdGlvbi12ZXJ0ZXhcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFRleHR1cmUgVVZzXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fVEVYVFVSRV9DT09SRFNcXG5cIiArXG5cIiAgICAgICAgdl90ZXhjb29yZCA9IGFfdGV4Y29vcmQ7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBQb3NpdGlvblxcblwiICtcblwiICAgIHZlYzQgcG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24ueHl6ICogMzI3NjcuLCAxLik7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9FWFRSVURFX0xJTkVTXFxuXCIgK1xuXCIgICAgICAgIHZlYzIgZXh0cnVkZSA9IGFfZXh0cnVkZS54eSAqIDI1NS47XFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IHdpZHRoID0gYV9leHRydWRlLnogKiAzMjc2Ny47XFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IHNjYWxlID0gYV9leHRydWRlLncgKiAyNTUuO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIC8vIEtlZXAgbGluZSB3aWR0aCBjb25zdGFudCBpbiBzY3JlZW4tc3BhY2VcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgenNjYWxlID0gdV90aWxlX29yaWdpbi56IC0gdV9tYXBfcG9zaXRpb24uejtcXG5cIiArXG5cIiAgICAgICAgd2lkdGggKj0gcG93KDIuLCB6c2NhbGUpO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIC8vIFNtb290aGx5IGludGVycG9sYXRlIGxpbmUgd2lkdGggYmV0d2VlbiB6b29tc1xcblwiICtcblwiICAgICAgICB3aWR0aCA9IG1peCh3aWR0aCwgd2lkdGggKiBzY2FsZSwgLXpzY2FsZSk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgLy8gTW9kaWZ5IGxpbmUgd2lkdGggYmVmb3JlIGV4dHJ1c2lvblxcblwiICtcblwiICAgICAgICAjcHJhZ21hIHRhbmdyYW06IHdpZHRoXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgcG9zaXRpb24ueHkgKz0gZXh0cnVkZSAqIHdpZHRoO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gV29ybGQgY29vcmRpbmF0ZXMgZm9yIDNkIHByb2NlZHVyYWwgdGV4dHVyZXNcXG5cIiArXG5cIiAgICB2X3dvcmxkX3Bvc2l0aW9uID0gdV9tb2RlbCAqIHBvc2l0aW9uO1xcblwiICtcblwiICAgICNpZiBkZWZpbmVkKFRBTkdSQU1fV09STERfUE9TSVRJT05fV1JBUClcXG5cIiArXG5cIiAgICAgICAgdl93b3JsZF9wb3NpdGlvbi54eSAtPSB3b3JsZF9wb3NpdGlvbl9hbmNob3I7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBBZGp1c3QgZm9yIHRpbGUgYW5kIHZpZXcgcG9zaXRpb25cXG5cIiArXG5cIiAgICBwb3NpdGlvbiA9IHVfbW9kZWxWaWV3ICogcG9zaXRpb247XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBNb2RpZnkgcG9zaXRpb24gYmVmb3JlIGNhbWVyYSBwcm9qZWN0aW9uXFxuXCIgK1xuXCIgICAgI3ByYWdtYSB0YW5ncmFtOiBwb3NpdGlvblxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gU2V0dXAgdmFyeWluZ3NcXG5cIiArXG5cIiAgICB2X3Bvc2l0aW9uID0gcG9zaXRpb247XFxuXCIgK1xuXCIgICAgdl9ub3JtYWwgPSBub3JtYWxpemUodV9ub3JtYWxNYXRyaXggKiBUQU5HUkFNX05PUk1BTCk7XFxuXCIgK1xuXCIgICAgdl9jb2xvciA9IGFfY29sb3I7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBWZXJ0ZXggbGlnaHRpbmdcXG5cIiArXG5cIiAgICAjaWYgZGVmaW5lZChUQU5HUkFNX0xJR0hUSU5HX1ZFUlRFWClcXG5cIiArXG5cIiAgICAgICAgdmVjNCBjb2xvciA9IGFfY29sb3I7XFxuXCIgK1xuXCIgICAgICAgIHZlYzMgbm9ybWFsID0gVEFOR1JBTV9OT1JNQUw7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgLy8gTW9kaWZ5IG5vcm1hbCBiZWZvcmUgbGlnaHRpbmdcXG5cIiArXG5cIiAgICAgICAgI3ByYWdtYSB0YW5ncmFtOiBub3JtYWxcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAvLyBNb2RpZnkgY29sb3IgYW5kIG1hdGVyaWFsIHByb3BlcnRpZXMgYmVmb3JlIGxpZ2h0aW5nXFxuXCIgK1xuXCIgICAgICAgICNwcmFnbWEgdGFuZ3JhbTogY29sb3JcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICB2X2xpZ2h0aW5nID0gY2FsY3VsYXRlTGlnaHRpbmcocG9zaXRpb24ueHl6LCBub3JtYWwsIGNvbG9yKTtcXG5cIiArXG5cIiAgICAgICAgdl9jb2xvciA9IGNvbG9yO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gQ2FtZXJhXFxuXCIgK1xuXCIgICAgY2FtZXJhUHJvamVjdGlvbihwb3NpdGlvbik7XFxuXCIgK1xuXCIgICAgYXBwbHlMYXllck9yZGVyKGFfcG9zaXRpb24udyAqIDMyNzY3LiwgcG9zaXRpb24pO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgZ2xfUG9zaXRpb24gPSBwb3NpdGlvbjtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWRlclNvdXJjZXM7XG4iLCIvKmdsb2JhbCBUZXh0dXJlICovXG4vLyBUZXh0dXJlIG1hbmFnZW1lbnRcbmltcG9ydCBVdGlscyBmcm9tICcuLi91dGlscy91dGlscyc7XG5pbXBvcnQgc3Vic2NyaWJlTWl4aW4gZnJvbSAnLi4vdXRpbHMvc3Vic2NyaWJlJztcbmltcG9ydCBXb3JrZXJCcm9rZXIgZnJvbSAnLi4vdXRpbHMvd29ya2VyX2Jyb2tlcic7XG5pbXBvcnQgQnVpbGRlcnMgZnJvbSAnLi4vc3R5bGVzL2J1aWxkZXJzJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG4vLyBHTCB0ZXh0dXJlIHdyYXBwZXIgb2JqZWN0IGZvciBrZWVwaW5nIHRyYWNrIG9mIGEgZ2xvYmFsIHNldCBvZiB0ZXh0dXJlcywga2V5ZWQgYnkgYSB1bmlxdWUgdXNlci1kZWZpbmVkIG5hbWVcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmUge1xuXG4gICAgY29uc3RydWN0b3IoZ2wsIG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLmdsID0gZ2w7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaW5kKCk7XG4gICAgICAgIHRoaXMuaW1hZ2UgPSBudWxsOyAgICAgIC8vIGFuIEltYWdlIG9iamVjdC9lbGVtZW50IHRoYXQgaXMgdGhlIHNvdXJjZSBmb3IgdGhpcyB0ZXh0dXJlXG4gICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDsgICAgIC8vIGEgQ2FudmFzIG9iamVjdC9lbGVtZW50IHRoYXQgaXMgdGhlIHNvdXJjZSBmb3IgdGhpcyB0ZXh0dXJlXG4gICAgICAgIHRoaXMubG9hZGluZyA9IG51bGw7ICAgIC8vIGEgUHJvbWlzZSBvYmplY3QgdG8gdHJhY2sgdGhlIGxvYWRpbmcgc3RhdGUgb2YgdGhpcyB0ZXh0dXJlXG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBhIDEtcGl4ZWwgYmxhY2sgdGV4dHVyZSBzbyB3ZSBjYW4gc2FmZWx5IHJlbmRlciB3aGlsZSB3ZSB3YWl0IGZvciBhbiBpbWFnZSB0byBsb2FkXG4gICAgICAgIC8vIFNlZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xOTcyMjI0Ny93ZWJnbC13YWl0LWZvci10ZXh0dXJlLXRvLWxvYWRcbiAgICAgICAgdGhpcy5zZXREYXRhKDEsIDEsIG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAyNTVdKSwgeyBmaWx0ZXJpbmc6ICduZWFyZXN0JyB9KTtcblxuICAgICAgICAvLyBUT0RPOiBiZXR0ZXIgc3VwcG9ydCBmb3Igbm9uLVVSTCBzb3VyY2VzOiBjYW52YXMvdmlkZW8gZWxlbWVudHMsIHJhdyBwaXhlbCBidWZmZXJzXG5cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5maWx0ZXJpbmcgPSBvcHRpb25zLmZpbHRlcmluZztcblxuICAgICAgICAvLyBEZXN0cm95IHByZXZpb3VzIHRleHR1cmUgaWYgcHJlc2VudFxuICAgICAgICBpZiAoVGV4dHVyZS50ZXh0dXJlc1t0aGlzLm5hbWVdKSB7XG4gICAgICAgICAgICBUZXh0dXJlLnRleHR1cmVzW3RoaXMubmFtZV0uZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgVGV4dHVyZS50ZXh0dXJlc1t0aGlzLm5hbWVdID0gdGhpcztcblxuICAgICAgICB0aGlzLnNwcml0ZXMgPSBvcHRpb25zLnNwcml0ZXM7XG4gICAgICAgIHRoaXMudGV4Y29vcmRzID0ge307XG4gICAgfVxuXG4gICAgLy8gRGVzdHJveSBhIHNpbmdsZSB0ZXh0dXJlIGluc3RhbmNlXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nbC5kZWxldGVUZXh0dXJlKHRoaXMudGV4dHVyZSk7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRhdGE7XG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgICAgIGRlbGV0ZSBUZXh0dXJlLnRleHR1cmVzW3RoaXMubmFtZV07XG4gICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBiaW5kKHVuaXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB1bml0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKFRleHR1cmUuYWN0aXZlVW5pdCAhPT0gdW5pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkUwICsgdW5pdCk7XG4gICAgICAgICAgICAgICAgVGV4dHVyZS5hY3RpdmVVbml0ID0gdW5pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoVGV4dHVyZS5hY3RpdmVUZXh0dXJlICE9PSB0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgICAgICAgICAgVGV4dHVyZS5hY3RpdmVUZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTG9hZHMgYSB0ZXh0dXJlIGZyb20gYSBVUkxcbiAgICBsb2FkKHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICghdGhpcy52YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFRleHR1cmUuYmFzZV91cmwpIHtcbiAgICAgICAgICAgIHVybCA9IFV0aWxzLmFkZEJhc2VVUkwodXJsLCBUZXh0dXJlLmJhc2VfdXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubG9hZGluZyA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRleHR1cmVGaWx0ZXJpbmcob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlU3ByaXRlcygpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDsgLy8gbXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggb3RoZXIgdHlwZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4oYFRleHR1cmU6IGZhaWxlZCB0byBsb2FkIHVybDogJyR7dXJsfSdgLCBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgVGV4dHVyZS50cmlnZ2VyKCd3YXJuaW5nJywgeyBtZXNzYWdlOiBgRmFpbGVkIHRvIGxvYWQgdGV4dHVyZSBmcm9tICR7dXJsfWAsIGVycm9yOiBlLCB0ZXh0dXJlOiBvcHRpb25zIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5pbWFnZS5vbmVycm9yID0gZSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gV2FybiBhbmQgcmVzb2x2ZSBvbiBlcnJvclxuICAgICAgICAgICAgICAgIGxvZy53YXJuKGBUZXh0dXJlOiBmYWlsZWQgdG8gbG9hZCB1cmw6ICcke3VybH0nYCwgZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgVGV4dHVyZS50cmlnZ2VyKCd3YXJuaW5nJywgeyBtZXNzYWdlOiBgRmFpbGVkIHRvIGxvYWQgdGV4dHVyZSBmcm9tICR7dXJsfWAsIGVycm9yOiBlLCB0ZXh0dXJlOiBvcHRpb25zIH0pO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5pbWFnZS5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuICAgICAgICAgICAgdGhpcy5pbWFnZS5zcmMgPSB1cmw7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkaW5nO1xuICAgIH1cblxuICAgIC8vIFNldHMgdGV4dHVyZSB0byBhIHJhdyBpbWFnZSBidWZmZXJcbiAgICBzZXREYXRhKHdpZHRoLCBoZWlnaHQsIGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuXG4gICAgICAgIHRoaXMuaW1hZ2UgPSBudWxsOyAvLyBtdXR1YWxseSBleGNsdXNpdmUgd2l0aCBvdGhlciB0eXBlc1xuICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy51cGRhdGUob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZUZpbHRlcmluZyhvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBTZXRzIHRoZSB0ZXh0dXJlIHRvIHRyYWNrIGEgY2FudmFzIGVsZW1lbnRcbiAgICBzZXRDYW52YXMoY2FudmFzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICB0aGlzLnVwZGF0ZShvcHRpb25zKTtcbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlRmlsdGVyaW5nKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuaW1hZ2UgPSBudWxsOyAvLyBtdXR1YWxseSBleGNsdXNpdmUgd2l0aCBvdGhlciB0eXBlc1xuICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFVwbG9hZHMgY3VycmVudCBpbWFnZSBvciBidWZmZXIgdG8gdGhlIEdQVSAoY2FuIGJlIHVzZWQgdG8gdXBkYXRlIGFuaW1hdGVkIHRleHR1cmVzIG9uIHRoZSBmbHkpXG4gICAgdXBkYXRlKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoIXRoaXMudmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYmluZCgpO1xuICAgICAgICB0aGlzLmdsLnBpeGVsU3RvcmVpKHRoaXMuZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgKG9wdGlvbnMuVU5QQUNLX0ZMSVBfWV9XRUJHTCA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWUpKTtcbiAgICAgICAgdGhpcy5nbC5waXhlbFN0b3JlaSh0aGlzLmdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgb3B0aW9ucy5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wgfHwgZmFsc2UpO1xuXG4gICAgICAgIC8vIEltYWdlIGVsZW1lbnRcbiAgICAgICAgaWYgKHRoaXMuaW1hZ2UgJiYgdGhpcy5pbWFnZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuVU5TSUdORURfQllURSwgdGhpcy5pbWFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FudmFzIGVsZW1lbnRcbiAgICAgICAgZWxzZSBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuVU5TSUdORURfQllURSwgdGhpcy5jYW52YXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJhdyBpbWFnZSBidWZmZXJcbiAgICAgICAgZWxzZSBpZiAodGhpcy53aWR0aCAmJiB0aGlzLmhlaWdodCkgeyAvLyBOT1RFOiB0aGlzLmRhdGEgY2FuIGJlIG51bGwsIHRvIHplcm8gb3V0IHRleHR1cmVcbiAgICAgICAgICAgIHRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZ2wuUkdCQSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDAsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5VTlNJR05FRF9CWVRFLCB0aGlzLmRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgVGV4dHVyZS50cmlnZ2VyKCd1cGRhdGUnLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmVzIGFwcHJvcHJpYXRlIGZpbHRlcmluZyBtb2RlXG4gICAgc2V0VGV4dHVyZUZpbHRlcmluZyhvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zLmZpbHRlcmluZyA9IG9wdGlvbnMuZmlsdGVyaW5nIHx8IHRoaXMuZmlsdGVyaW5nIHx8ICdsaW5lYXInO1xuXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHRoaXMuYmluZCgpO1xuXG4gICAgICAgIC8vIEZvciBwb3dlci1vZi0yIHRleHR1cmVzLCB0aGUgZm9sbG93aW5nIHByZXNldHMgYXJlIGF2YWlsYWJsZTpcbiAgICAgICAgLy8gbWlwbWFwOiBsaW5lYXIgYmxlbmQgZnJvbSBuZWFyZXN0IG1pcFxuICAgICAgICAvLyBsaW5lYXI6IGxpbmVhciBibGVuZCBmcm9tIG9yaWdpbmFsIGltYWdlIChubyBtaXBzKVxuICAgICAgICAvLyBuZWFyZXN0OiBuZWFyZXN0IHBpeGVsIGZyb20gb3JpZ2luYWwgaW1hZ2UgKG5vIG1pcHMsICdibG9ja3knIGxvb2spXG4gICAgICAgIGlmIChVdGlscy5pc1Bvd2VyT2YyKHRoaXMud2lkdGgpICYmIFV0aWxzLmlzUG93ZXJPZjIodGhpcy5oZWlnaHQpKSB7XG4gICAgICAgICAgICB0aGlzLnBvd2VyX29mXzIgPSB0cnVlO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgb3B0aW9ucy5URVhUVVJFX1dSQVBfUyB8fCAob3B0aW9ucy5yZXBlYXQgJiYgZ2wuUkVQRUFUKSB8fCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIG9wdGlvbnMuVEVYVFVSRV9XUkFQX1QgfHwgKG9wdGlvbnMucmVwZWF0ICYmIGdsLlJFUEVBVCkgfHwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cbiAgICAgICAgICAgIC8vIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIG9wdGlvbnMuVEVYVFVSRV9XUkFQX1MgfHwgZ2wuUkVQRUFUKTtcbiAgICAgICAgICAgIC8vIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIG9wdGlvbnMuVEVYVFVSRV9XUkFQX1QgfHwgZ2wuUkVQRUFUKTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmlsdGVyaW5nID09PSAnbWlwbWFwJykge1xuICAgICAgICAgICAgICAgIGxvZy50cmFjZSgncG93ZXItb2YtMiBNSVBNQVAnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmluZyA9ICdtaXBtYXAnO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUik7IC8vIFRPRE86IHVzZSB0cmlsaW5lYXIgZmlsdGVyaW5nIGJ5IGRlZnVhbHQgaW5zdGVhZD9cbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZmlsdGVyaW5nID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgICAgIGxvZy50cmFjZSgncG93ZXItb2YtMiBMSU5FQVInKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmluZyA9ICdsaW5lYXInO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5maWx0ZXJpbmcgPT09ICduZWFyZXN0Jykge1xuICAgICAgICAgICAgICAgIGxvZy50cmFjZSgncG93ZXItb2YtMiBORUFSRVNUJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJpbmcgPSAnbmVhcmVzdCc7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlYkdMIGhhcyBzdHJpY3QgcmVxdWlyZW1lbnRzIG9uIG5vbi1wb3dlci1vZi0yIHRleHR1cmVzOlxuICAgICAgICAgICAgLy8gTm8gbWlwbWFwcyBhbmQgbXVzdCBjbGFtcCB0byBlZGdlXG4gICAgICAgICAgICB0aGlzLnBvd2VyX29mXzIgPSBmYWxzZTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZpbHRlcmluZyA9PT0gJ25lYXJlc3QnKSB7XG4gICAgICAgICAgICAgICAgbG9nLnRyYWNlKCdwb3dlci1vZi0yIE5FQVJFU1QnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmluZyA9ICduZWFyZXN0JztcbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIGRlZmF1bHQgdG8gbGluZWFyIGZvciBub24tcG93ZXItb2YtMiB0ZXh0dXJlc1xuICAgICAgICAgICAgICAgIGxvZy50cmFjZSgncG93ZXItb2YtMiBMSU5FQVInKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmluZyA9ICdsaW5lYXInO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgVGV4dHVyZS50cmlnZ2VyKCd1cGRhdGUnLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBQcmUtY2FsYyBzcHJpdGUgcmVnaW9ucyBmb3IgYSB0ZXh0dXJlIHNwcml0ZSBpbiBVViBbMCwgMV0gc3BhY2VcbiAgICBjYWxjdWxhdGVTcHJpdGVzKCkge1xuICAgICAgICBpZiAodGhpcy5zcHJpdGVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzIGluIHRoaXMuc3ByaXRlcykge1xuICAgICAgICAgICAgICAgIGxldCBzcHJpdGUgPSB0aGlzLnNwcml0ZXNbc107XG5cbiAgICAgICAgICAgICAgICAvLyBNYXAgWzAsIDBdIHRvIFsxLCAxXSBjb29yZHMgdG8gdGhlIGFwcHJvcHJpYXRlIHNwcml0ZSBzdWItYXJlYSBvZiB0aGUgdGV4dHVyZVxuICAgICAgICAgICAgICAgIHRoaXMudGV4Y29vcmRzW3NdID0gQnVpbGRlcnMuZ2V0VGV4Y29vcmRzRm9yU3ByaXRlKFxuICAgICAgICAgICAgICAgICAgICBbc3ByaXRlWzBdLCBzcHJpdGVbMV1dLFxuICAgICAgICAgICAgICAgICAgICBbc3ByaXRlWzJdLCBzcHJpdGVbM11dLFxuICAgICAgICAgICAgICAgICAgICBbdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5cbi8vIFN0YXRpYy9jbGFzcyBtZXRob2RzIGFuZCBzdGF0ZVxuXG4vLyBEZXN0cm95IGFsbCB0ZXh0dXJlIGluc3RhbmNlcyBmb3IgYSBnaXZlbiBHTCBjb250ZXh0XG5UZXh0dXJlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZ2wpIHtcbiAgICB2YXIgdGV4dHVyZXMgPSBPYmplY3Qua2V5cyhUZXh0dXJlLnRleHR1cmVzKTtcbiAgICBmb3IgKHZhciB0IG9mIHRleHR1cmVzKSB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gVGV4dHVyZS50ZXh0dXJlc1t0XTtcbiAgICAgICAgaWYgKHRleHR1cmUuZ2wgPT09IGdsKSB7XG4gICAgICAgICAgICBsb2cudHJhY2UoYGRlc3Ryb3lpbmcgVGV4dHVyZSAke3RleHR1cmUubmFtZX1gKTtcbiAgICAgICAgICAgIHRleHR1cmUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gR2V0IHNwcml0ZSBzdWItYXJlYSB0byB1c2UgZm9yIHRleHR1cmUgY29vcmRpbmF0ZXMgKGRlZmF1bHQgaXMgWzAsIDFdKVxuVGV4dHVyZS5nZXRTcHJpdGVUZXhjb29yZHMgPSBmdW5jdGlvbiAodGV4bmFtZSwgc3ByaXRlKSB7XG4gICAgbGV0IHRleHR1cmUgPSBUZXh0dXJlLnRleHR1cmVzW3RleG5hbWVdO1xuICAgIHJldHVybiB0ZXh0dXJlICYmIHRleHR1cmUudGV4Y29vcmRzW3Nwcml0ZV07XG59O1xuXG4vLyBDcmVhdGUgYSBzZXQgb2YgdGV4dHVyZXMga2V5ZWQgaW4gYW4gb2JqZWN0XG4vLyBPcHRpb25hbGx5IGxvYWQgZWFjaCBpZiBpdCBoYXMgYSBVUkwgc3BlY2lmaWVkXG5UZXh0dXJlLmNyZWF0ZUZyb21PYmplY3QgPSBmdW5jdGlvbiAoZ2wsIHRleHR1cmVzKSB7XG4gICAgbGV0IGxvYWRpbmcgPSBbXTtcbiAgICBpZiAodGV4dHVyZXMpIHtcbiAgICAgICAgZm9yIChsZXQgdGV4bmFtZSBpbiB0ZXh0dXJlcykge1xuICAgICAgICAgICAgbGV0IGNvbmZpZyA9IHRleHR1cmVzW3RleG5hbWVdO1xuICAgICAgICAgICAgbGV0IHRleHR1cmUgPSBuZXcgVGV4dHVyZShnbCwgdGV4bmFtZSwgY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChjb25maWcudXJsKSB7XG4gICAgICAgICAgICAgICAgbG9hZGluZy5wdXNoKHRleHR1cmUubG9hZChjb25maWcudXJsLCBjb25maWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwobG9hZGluZyk7XG59O1xuXG4vLyBHZXQgbWV0YWRhdGEgZm9yIGEgdGV4dHVyZSBieSBuYW1lXG4vLyBSZXR1cm5zIHZpYSBwcm9taXNlLCBpbiBjYXNlIHRleHR1cmUgaXMgc3RpbGwgbG9hZGluZ1xuLy8gQ2FuIGJlIGNhbGxlZCBvbiBtYWluIHRocmVhZCBmcm9tIHdvcmtlciwgdG8gc3luYyB0ZXh0dXJlIGluZm8gdG8gd29ya2VyXG5UZXh0dXJlLmdldEluZm8gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIC8vIEdldCBpbmZvIGZvciBhbGwgdGV4dHVyZXMgYnkgZGVmYXVsdFxuICAgIGlmICghbmFtZSkge1xuICAgICAgICBuYW1lID0gT2JqZWN0LmtleXMoVGV4dHVyZS50ZXh0dXJlcyk7XG4gICAgfVxuXG4gICAgLy8gR2V0IG11bHRpcGxlIHRleHR1cmVzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG5hbWUubWFwKG4gPT4gVGV4dHVyZS5nZXRJbmZvKG4pKSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHNpbmdsZSB0ZXh0dXJlXG4gICAgdmFyIHRleCA9IFRleHR1cmUudGV4dHVyZXNbbmFtZV07XG4gICAgaWYgKHRleCkge1xuICAgICAgICAvLyBXYWl0IGZvciB0aGlzIHRleHR1cmUgdG8gZmluaXNoIGxvYWRpbmcsIG9yIHJldHVybiBpbW1lZGlhdGVseVxuICAgICAgICB2YXIgbG9hZGluZyA9IHRleC5sb2FkaW5nIHx8IFByb21pc2UucmVzb2x2ZSh0ZXgpO1xuICAgICAgICByZXR1cm4gbG9hZGluZy50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFJldHVybiBhIHN1YnNldCBvZiB0ZXh0dXJlIGluZm9cbiAgICAgICAgICAgIC8vIChjb21wYXRpYmxlIHcvc3RydWN0dXJlZCBjbG9uaW5nLCBzdWl0YWJsZSBmb3IgcGFzc2luZyB0byBhIHdvcmtlcilcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogdGV4Lm5hbWUsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRleC53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRleC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgc3ByaXRlczogdGV4LnNwcml0ZXMsXG4gICAgICAgICAgICAgICAgdGV4Y29vcmRzOiB0ZXgudGV4Y29vcmRzLFxuICAgICAgICAgICAgICAgIGZpbHRlcmluZzogdGV4LmZpbHRlcmluZyxcbiAgICAgICAgICAgICAgICBwb3dlcl9vZl8yOiB0ZXgucG93ZXJfb2ZfMixcbiAgICAgICAgICAgICAgICB2YWxpZDogdGV4LnZhbGlkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE5vIHRleHR1cmUgZm91bmRcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG59O1xuXG4vLyBTeW5jIHRleHR1cmUgaW5mbyB0byB3b3JrZXJcbi8vIENhbGxlZCBmcm9tIHdvcmtlciwgZ2V0cyBpbmZvIG9uIG9uZSBvciBtb3JlIHRleHR1cmVzIGluZm8gZnJvbSBtYWluIHRocmVhZCB2aWEgcmVtb3RlIGNhbGwsIHRoZW4gc3RvcmVzIGl0XG4vLyBsb2NhbGx5IGluIHdvcmtlci4gJ3RleHR1cmVzJyBjYW4gYmUgYW4gYXJyYXkgb2YgdGV4dHVyZSBuYW1lcyB0byBzeW5jLCBvciBpZiBudWxsLCBhbGwgdGV4dHVyZXMgYXJlIHN5bmNlZC5cblRleHR1cmUuc3luY1RleHR1cmVzVG9Xb3JrZXIgPSBmdW5jdGlvbiAobmFtZXMpIHtcbiAgICByZXR1cm4gV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKCdUZXh0dXJlJywgJ2dldEluZm8nLCBuYW1lcykuXG4gICAgICAgIHRoZW4odGV4dHVyZXMgPT4ge1xuICAgICAgICAgICAgZm9yICh2YXIgdGV4IG9mIHRleHR1cmVzKSB7XG4gICAgICAgICAgICAgICAgVGV4dHVyZS50ZXh0dXJlc1t0ZXgubmFtZV0gPSB0ZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVGV4dHVyZS50ZXh0dXJlcztcbiAgICAgICAgfSk7XG59O1xuXG4vLyBHbG9iYWwgc2V0IG9mIHRleHR1cmVzLCBieSBuYW1lXG5UZXh0dXJlLnRleHR1cmVzID0ge307XG5UZXh0dXJlLmJvdW5kVGV4dHVyZSA9IC0xO1xuVGV4dHVyZS5hY3RpdmVVbml0ID0gLTE7XG5cblRleHR1cmUuYmFzZV91cmwgPSBudWxsOyAvLyBvcHRpb25hbCBiYXNlIFVSTCB0byBhZGQgdG8gdGV4dHVyZXNcblxuc3Vic2NyaWJlTWl4aW4oVGV4dHVyZSk7XG4iLCIvLyBDcmVhdGVzIGEgVmVydGV4IEFycmF5IE9iamVjdCBpZiB0aGUgZXh0ZW5zaW9uIGlzIGF2YWlsYWJsZSwgb3IgZmFsbHMgYmFjayBvbiBzdGFuZGFyZCBhdHRyaWJ1dGUgY2FsbHNcblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbnZhciBWZXJ0ZXhBcnJheU9iamVjdDtcbmV4cG9ydCBkZWZhdWx0IFZlcnRleEFycmF5T2JqZWN0ID0ge307XG5cblZlcnRleEFycmF5T2JqZWN0LmRpc2FibGVkID0gZmFsc2U7IC8vIHNldCB0byB0cnVlIHRvIGRpc2FibGUgVkFPcyBldmVuIGlmIGV4dGVuc2lvbiBpcyBhdmFpbGFibGVcblZlcnRleEFycmF5T2JqZWN0LmJvdW5kX3ZhbyA9IG51bGw7IC8vIGN1cnJlbnRseSBib3VuZCBWQU9cblxuVmVydGV4QXJyYXlPYmplY3QuaW5pdCA9IGZ1bmN0aW9uIChnbCkge1xuICAgIGlmIChWZXJ0ZXhBcnJheU9iamVjdC5leHQgPT0gbnVsbCkge1xuICAgICAgICBpZiAoVmVydGV4QXJyYXlPYmplY3QuZGlzYWJsZWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgIFZlcnRleEFycmF5T2JqZWN0LmV4dCA9IGdsLmdldEV4dGVuc2lvbihcIk9FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFZlcnRleEFycmF5T2JqZWN0LmV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBsb2cuaW5mbygnVmVydGV4IEFycmF5IE9iamVjdCBleHRlbnNpb24gYXZhaWxhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVmVydGV4QXJyYXlPYmplY3QuZGlzYWJsZWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKCdWZXJ0ZXggQXJyYXkgT2JqZWN0IGV4dGVuc2lvbiBOT1QgYXZhaWxhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2cud2FybignVmVydGV4IEFycmF5IE9iamVjdCBleHRlbnNpb24gZm9yY2UgZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblZlcnRleEFycmF5T2JqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChzZXR1cCwgdGVhcmRvd24pIHtcbiAgICBsZXQgdmFvID0ge307XG4gICAgdmFvLnNldHVwID0gc2V0dXA7XG4gICAgdmFvLnRlYXJkb3duID0gdGVhcmRvd247XG5cbiAgICBsZXQgZXh0ID0gVmVydGV4QXJyYXlPYmplY3QuZXh0O1xuICAgIGlmIChleHQgIT0gbnVsbCkge1xuICAgICAgICB2YW8uX3ZhbyA9IGV4dC5jcmVhdGVWZXJ0ZXhBcnJheU9FUygpO1xuICAgICAgICBleHQuYmluZFZlcnRleEFycmF5T0VTKHZhby5fdmFvKTtcbiAgICB9XG5cbiAgICB2YW8uc2V0dXAodHJ1ZSk7XG5cbiAgICByZXR1cm4gdmFvO1xufTtcblxuVmVydGV4QXJyYXlPYmplY3QuYmluZCA9IGZ1bmN0aW9uICh2YW8pIHtcbiAgICBsZXQgZXh0ID0gVmVydGV4QXJyYXlPYmplY3QuZXh0O1xuICAgIGlmICh2YW8gIT0gbnVsbCkge1xuICAgICAgICBpZiAoZXh0ICE9IG51bGwgJiYgdmFvLl92YW8gIT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0LmJpbmRWZXJ0ZXhBcnJheU9FUyh2YW8uX3Zhbyk7XG4gICAgICAgICAgICBWZXJ0ZXhBcnJheU9iamVjdC5ib3VuZF92YW8gPSB2YW87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YW8uc2V0dXAoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dC5iaW5kVmVydGV4QXJyYXlPRVMobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVmVydGV4QXJyYXlPYmplY3QuYm91bmRfdmFvICE9IG51bGwgJiYgdHlwZW9mIFZlcnRleEFycmF5T2JqZWN0LmJvdW5kX3Zhby50ZWFyZG93biA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgVmVydGV4QXJyYXlPYmplY3QuYm91bmRfdmFvLnRlYXJkb3duKCk7XG4gICAgICAgIH1cbiAgICAgICAgVmVydGV4QXJyYXlPYmplY3QuYm91bmRfdmFvID0gbnVsbDtcbiAgICB9XG59O1xuIiwiLyogZ2xvYmFsIFZCT01lc2ggKi9cbi8vIE1hbmFnZSByZW5kZXJpbmcgZm9yIHByaW1pdGl2ZXNcbmltcG9ydCBHTFNMIGZyb20gJy4vZ2xzbCc7XG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tICcuL3NoYWRlcl9wcm9ncmFtJztcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4vdGV4dHVyZSc7XG5pbXBvcnQgVmVydGV4QXJyYXlPYmplY3QgZnJvbSAnLi92YW8nO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbi8vIEEgc2luZ2xlIG1lc2gvVkJPLCBkZXNjcmliZWQgYnkgYSB2ZXJ0ZXggbGF5b3V0LCB0aGF0IGNhbiBiZSBkcmF3biB3aXRoIG9uZSBvciBtb3JlIHByb2dyYW1zXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWQk9NZXNoICB7XG5cbiAgICBjb25zdHJ1Y3RvcihnbCwgdmVydGV4X2RhdGEsIHZlcnRleF9sYXlvdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy5nbCA9IGdsO1xuICAgICAgICB0aGlzLnZlcnRleF9kYXRhID0gdmVydGV4X2RhdGE7IC8vIHR5cGVkIGFycmF5XG4gICAgICAgIHRoaXMudmVydGV4X2xheW91dCA9IHZlcnRleF9sYXlvdXQ7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgdGhpcy5kcmF3X21vZGUgPSBvcHRpb25zLmRyYXdfbW9kZSB8fCB0aGlzLmdsLlRSSUFOR0xFUztcbiAgICAgICAgdGhpcy5kYXRhX3VzYWdlID0gb3B0aW9ucy5kYXRhX3VzYWdlIHx8IHRoaXMuZ2wuU1RBVElDX0RSQVc7XG4gICAgICAgIHRoaXMudmVydGljZXNfcGVyX2dlb21ldHJ5ID0gMzsgLy8gVE9ETzogc3VwcG9ydCBsaW5lcywgc3RyaXAsIGZhbiwgZXRjLlxuICAgICAgICB0aGlzLnVuaWZvcm1zID0gb3B0aW9ucy51bmlmb3JtcztcbiAgICAgICAgdGhpcy5yZXRhaW4gPSBvcHRpb25zLnJldGFpbiB8fCBmYWxzZTsgLy8gd2hldGhlciB0byByZXRhaW4gbWVzaCBkYXRhIGluIENQVSBhZnRlciB1cGxvYWRpbmcgdG8gR1BVXG5cbiAgICAgICAgdGhpcy52ZXJ0ZXhfY291bnQgPSB0aGlzLnZlcnRleF9kYXRhLmJ5dGVMZW5ndGggLyB0aGlzLnZlcnRleF9sYXlvdXQuc3RyaWRlO1xuICAgICAgICB0aGlzLmdlb21ldHJ5X2NvdW50ID0gdGhpcy52ZXJ0ZXhfY291bnQgLyB0aGlzLnZlcnRpY2VzX3Blcl9nZW9tZXRyeTtcbiAgICAgICAgdGhpcy52YW9zID0gbmV3IE1hcCgpOyAvLyBtYXAgb2YgVmVydGV4QXJyYXlPYmplY3RzLCBrZXllZCBieSBwcm9ncmFtXG5cbiAgICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuZ2wuYnVmZmVyRGF0YSh0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhfZGF0YSwgdGhpcy5kYXRhX3VzYWdlKTtcblxuICAgICAgICBpZiAoIXRoaXMucmV0YWluKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy52ZXJ0ZXhfZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBSZW5kZXIsIGJ5IGRlZmF1bHQgd2l0aCBjdXJyZW50bHkgYm91bmQgcHJvZ3JhbSwgb3Igb3RoZXJ3aXNlIHdpdGggb3B0aW9uYWxseSBwcm92aWRlZCBvbmVcbiAgICByZW5kZXIob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICghdGhpcy52YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9yZW5kZXJfc2V0dXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcl9zZXR1cCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb2dyYW0gPSBvcHRpb25zLnByb2dyYW0gfHwgU2hhZGVyUHJvZ3JhbS5jdXJyZW50O1xuICAgICAgICBwcm9ncmFtLnVzZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLnVuaWZvcm1zKSB7XG4gICAgICAgICAgICBwcm9ncmFtLnNhdmVVbmlmb3Jtcyh0aGlzLnVuaWZvcm1zKTtcbiAgICAgICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybXModGhpcy51bmlmb3JtcywgZmFsc2UpOyAvLyBkb24ndCByZXNldCB0ZXh0dXJlIHVuaXRcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYmluZChwcm9ncmFtKTtcblxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGVsZW1lbnQgYXJyYXkgbW9kZVxuICAgICAgICB0aGlzLmdsLmRyYXdBcnJheXModGhpcy5kcmF3X21vZGUsIDAsIHRoaXMudmVydGV4X2NvdW50KTtcbiAgICAgICAgVmVydGV4QXJyYXlPYmplY3QuYmluZChudWxsKTtcblxuICAgICAgICBpZiAodGhpcy51bmlmb3Jtcykge1xuICAgICAgICAgICAgcHJvZ3JhbS5yZXN0b3JlVW5pZm9ybXModGhpcy51bmlmb3Jtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBCaW5kIGJ1ZmZlcnMgYW5kIHZlcnRleCBhdHRyaWJ1dGVzIHRvIHByZXBhcmUgZm9yIHJlbmRlcmluZ1xuICAgIGJpbmQocHJvZ3JhbSkge1xuICAgICAgICAvLyBCaW5kIFZBTyBmb3IgdGhpcyBwcm9nYW0sIG9yIGNyZWF0ZSBvbmVcbiAgICAgICAgbGV0IHZhbyA9IHRoaXMudmFvcy5nZXQocHJvZ3JhbSk7XG4gICAgICAgIGlmICh2YW8pIHtcbiAgICAgICAgICAgIFZlcnRleEFycmF5T2JqZWN0LmJpbmQodmFvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFvcy5zZXQocHJvZ3JhbSwgVmVydGV4QXJyYXlPYmplY3QuY3JlYXRlKChmb3JjZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMudmVydGV4X2xheW91dC5lbmFibGUodGhpcy5nbCwgcHJvZ3JhbSwgZm9yY2UpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWxpZCA9IGZhbHNlO1xuXG4gICAgICAgIGxvZy50cmFjZSgnVkJPTWVzaC5kZXN0cm95OiBkZWxldGUgYnVmZmVyJyArICh0aGlzLnZlcnRleF9kYXRhID8gYCBvZiBzaXplICR7dGhpcy52ZXJ0ZXhfZGF0YS5ieXRlTGVuZ3RofWAgOiAnJykpO1xuXG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlQnVmZmVyKHRoaXMuYnVmZmVyKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICBkZWxldGUgdGhpcy52ZXJ0ZXhfZGF0YTtcblxuICAgICAgICAvLyBGcmVlIHRleHR1cmUgdW5pZm9ybXMgdGhhdCBhcmUgb3duZWQgYnkgdGhpcyBtZXNoXG4gICAgICAgIGZvciAobGV0IHt0eXBlLCB2YWx1ZX0gb2YgR0xTTC5wYXJzZVVuaWZvcm1zKHRoaXMudW5pZm9ybXMpKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3NhbXBsZXIyRCcgJiYgVGV4dHVyZS50ZXh0dXJlc1t2YWx1ZV0pIHtcbiAgICAgICAgICAgICAgICBUZXh0dXJlLnRleHR1cmVzW3ZhbHVlXS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbn1cbiIsIi8qIGdsb2JhbCBWZXJ0ZXhEYXRhICovXG5cbmltcG9ydCBnbCBmcm9tICcuL2NvbnN0YW50cyc7IC8vIHdlYiB3b3JrZXJzIGRvbid0IGhhdmUgYWNjZXNzIHRvIEdMIGNvbnRleHQsIHNvIGltcG9ydCBhbGwgR0wgY29uc3RhbnRzXG5pbXBvcnQge2xvZ30gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuXG4vLyBNYXBzIEdMIHR5cGVzIHRvIEpTIGFycmF5IHR5cGVzXG5sZXQgYXJyYXlfdHlwZXMgPSB7XG4gICAgW2dsLkZMT0FUXTogRmxvYXQzMkFycmF5LFxuICAgIFtnbC5CWVRFXTogSW50OEFycmF5LFxuICAgIFtnbC5VTlNJR05FRF9CWVRFXTogVWludDhBcnJheSxcbiAgICBbZ2wuSU5UXTogSW50MzJBcnJheSxcbiAgICBbZ2wuVU5TSUdORURfSU5UXTogVWludDMyQXJyYXksXG4gICAgW2dsLlNIT1JUXTogSW50MTZBcnJheSxcbiAgICBbZ2wuVU5TSUdORURfU0hPUlRdOiBVaW50MTZBcnJheVxufTtcblxuLy8gQW4gaW50ZXJtZWRpYXJ5IG9iamVjdCB0aGF0IGhvbGRzIHZlcnRleCBkYXRhIGluIHR5cGVkIGFycmF5cywgYWNjb3JkaW5nIHRvIGEgZ2l2ZW4gdmVydGV4IGxheW91dFxuLy8gVXNlZCB0byBjb25zdHJ1Y3QgYSBtZXNoL1ZCTyBmb3IgcmVuZGVyaW5nXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZXJ0ZXhEYXRhIHtcblxuICAgIGNvbnN0cnVjdG9yICh2ZXJ0ZXhfbGF5b3V0LCB7IHByZWFsbG9jIH0gPSB7fSkge1xuICAgICAgICB0aGlzLnZlcnRleF9sYXlvdXQgPSB2ZXJ0ZXhfbGF5b3V0O1xuXG4gICAgICAgIGlmIChWZXJ0ZXhEYXRhLmFycmF5X3Bvb2wubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBWZXJ0ZXhEYXRhLmFycmF5X3Bvb2wucG9wKCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcl9sZW5ndGggPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJfc2l6ZSA9IE1hdGguZmxvb3IodGhpcy5idWZmZXJfbGVuZ3RoIC8gdGhpcy52ZXJ0ZXhfbGF5b3V0LnN0cmlkZSk7XG4gICAgICAgICAgICBsb2coJ3RyYWNlJywgYFZlcnRleERhdGE6IHJldXNlZCBidWZmZXIgb2YgYnl0ZXMgJHt0aGlzLmJ1ZmZlcl9sZW5ndGh9LCAke3RoaXMuYnVmZmVyX3NpemV9IHZlcnRpY2VzYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcl9zaXplID0gcHJlYWxsb2MgfHwgNTAwOyAvLyAjIG9mIHZlcnRpY2VzIHRvIGFsbG9jYXRlXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcl9sZW5ndGggPSB0aGlzLnZlcnRleF9sYXlvdXQuc3RyaWRlICogdGhpcy5idWZmZXJfc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXJfbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlcl9vZmZzZXQgPSAwOyAgICAgICAgICAgICAvLyBieXRlIG9mZnNldCBpbnRvIGN1cnJlbnRseSBhbGxvY2F0ZWQgYnVmZmVyXG5cbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0gW107XG4gICAgICAgIGZvciAodmFyIGNvbXBvbmVudCBvZiB0aGlzLnZlcnRleF9sYXlvdXQuY29tcG9uZW50cykge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLnB1c2goWy4uLmNvbXBvbmVudF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVydGV4X2NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5yZWFsbG9jX2NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5zZXRCdWZmZXJWaWV3cygpO1xuICAgIH1cblxuICAgIC8vIChSZS0pYWxsb2NhdGUgdHlwZWQgdmlld3MgaW50byB0aGUgbWFpbiBidWZmZXIgLSBvbmx5IGNyZWF0ZSB0aGUgdHlwZXMgd2UgbmVlZCBmb3IgdGhpcyBsYXlvdXRcbiAgICBzZXRCdWZmZXJWaWV3cyAoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyX3ZpZXdzID0ge307XG4gICAgICAgIHRoaXMuYnVmZmVyX3ZpZXdzW2dsLlVOU0lHTkVEX0JZVEVdID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGZvciAodmFyIGF0dHJpYiBvZiB0aGlzLnZlcnRleF9sYXlvdXQuYXR0cmlicykge1xuICAgICAgICAgICAgLy8gTmVlZCB2aWV3IGZvciB0aGlzIHR5cGU/XG4gICAgICAgICAgICBpZiAodGhpcy5idWZmZXJfdmlld3NbYXR0cmliLnR5cGVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXlfdHlwZSA9IGFycmF5X3R5cGVzW2F0dHJpYi50eXBlXTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcl92aWV3c1thdHRyaWIudHlwZV0gPSBuZXcgYXJyYXlfdHlwZSh0aGlzLmJ1ZmZlci5idWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIGNvbXBvbmVudCBidWZmZXIgcG9pbnRlcnNcbiAgICAgICAgZm9yICh2YXIgY29tcG9uZW50IG9mIHRoaXMuY29tcG9uZW50cykge1xuICAgICAgICAgICAgY29tcG9uZW50WzFdID0gdGhpcy5idWZmZXJfdmlld3NbY29tcG9uZW50WzBdXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGFsbG9jYXRlZCBidWZmZXIgc2l6ZSwgZXhwYW5kL3JlYWxsb2MgYnVmZmVyIGlmIG5lZWRlZFxuICAgIGNoZWNrQnVmZmVyU2l6ZSAoKSB7XG4gICAgICAgIGlmICgodGhpcy5idWZmZXJfb2Zmc2V0ICsgdGhpcy52ZXJ0ZXhfbGF5b3V0LnN0cmlkZSkgPiB0aGlzLmJ1ZmZlcl9sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyX3NpemUgPSBNYXRoLmZsb29yKHRoaXMuYnVmZmVyX3NpemUgKiAxLjUpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJfc2l6ZSAtPSB0aGlzLmJ1ZmZlcl9zaXplICUgNDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyX2xlbmd0aCA9IHRoaXMudmVydGV4X2xheW91dC5zdHJpZGUgKiB0aGlzLmJ1ZmZlcl9zaXplO1xuICAgICAgICAgICAgdmFyIG5ld192aWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXJfbGVuZ3RoKTtcbiAgICAgICAgICAgIG5ld192aWV3LnNldCh0aGlzLmJ1ZmZlcik7IC8vIGNvcHkgZXhpc3RpbmcgZGF0YSB0byBuZXcgYnVmZmVyXG4gICAgICAgICAgICBWZXJ0ZXhEYXRhLmFycmF5X3Bvb2wucHVzaCh0aGlzLmJ1ZmZlcik7IC8vIHNhdmUgcHJldmlvdXMgYnVmZmVyIGZvciB1c2UgYnkgbmV4dCB0aWxlXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ld192aWV3O1xuICAgICAgICAgICAgdGhpcy5zZXRCdWZmZXJWaWV3cygpO1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jX2NvdW50Kys7XG4gICAgICAgICAgICAvLyBsb2cuaW5mbyhgVmVydGV4RGF0YTogZXhwYW5kZWQgdmVydGV4IGJsb2NrIHRvICR7dGhpcy5idWZmZXJfc2l6ZX0gdmVydGljZXNgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBhIHZlcnRleCwgY29waWVkIGZyb20gYSBwbGFpbiBKUyBhcnJheSBvZiBlbGVtZW50cyBtYXRjaGluZyB0aGUgb3JkZXIgb2YgdGhlIHZlcnRleCBsYXlvdXQuXG4gICAgLy8gTm90ZTogdXNlcyBwcmUtY2FsY3VsYXRlZCBpbmZvIGFib3V0IGVhY2ggYXR0cmlidXRlLCBpbmNsdWRpbmcgcG9pbnRlciB0byBhcHByb3ByaWF0ZSB0eXBlZCBhcnJheVxuICAgIC8vIHZpZXcgYW5kIG9mZnNldCBpbnRvIGl0LiBUaGlzIHdhcyB0aGUgZmFzdGVzdCBtZXRob2QgcHJvZmlsZWQgc28gZmFyIGZvciBmaWxsaW5nIGEgbWl4ZWQtdHlwZVxuICAgIC8vIHZlcnRleCBsYXlvdXQgKHRob3VnaCBzdGlsbCBzbG93ZXIgdGhhbiB0aGUgcHJldmlvdXMgbWV0aG9kIHRoYXQgb25seSBzdXBwb3J0ZWQgRmxvYXQzMkFycmF5IGF0dHJpYnV0ZXMpLlxuICAgIGFkZFZlcnRleCAodmVydGV4KSB7XG4gICAgICAgIHRoaXMuY2hlY2tCdWZmZXJTaXplKCk7XG4gICAgICAgIHZhciBpPTA7XG5cbiAgICAgICAgdmFyIGNsZW4gPSB0aGlzLmNvbXBvbmVudHMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBjPTA7IGMgPCBjbGVuOyBjKyspIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudHNbY107XG4gICAgICAgICAgICBjb21wb25lbnRbMV1bKHRoaXMuYnVmZmVyX29mZnNldCA+PiBjb21wb25lbnRbMl0pICsgY29tcG9uZW50WzNdXSA9IHZlcnRleFtpKytdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5idWZmZXJfb2Zmc2V0ICs9IHRoaXMudmVydGV4X2xheW91dC5zdHJpZGU7XG4gICAgICAgIHRoaXMudmVydGV4X2NvdW50Kys7XG4gICAgfVxuXG4gICAgLy8gRmluYWxpemUgdmVydGV4IGJ1ZmZlciBmb3IgdXNlIGluIGNvbnN0cnVjdGluZyBhIG1lc2hcbiAgICBlbmQgKCkge1xuICAgICAgICAvLyBDbGlwIHRoZSBidWZmZXIgdG8gc2l6ZSB1c2VkIGZvciB0aGlzIFZCT1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnN1YmFycmF5KDAsIHRoaXMuYnVmZmVyX29mZnNldCk7XG4gICAgICAgIGxvZygndHJhY2UnLCBgVmVydGV4RGF0YTogJHt0aGlzLmJ1ZmZlcl9zaXplfSB2ZXJ0aWNlcyB0b3RhbCwgcmVhbGxvYyBjb3VudCAke3RoaXMucmVhbGxvY19jb3VudH1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG59XG5cblZlcnRleERhdGEuYXJyYXlfcG9vbCA9IFtdOyAvLyBwb29sIG9mIGN1cnJlbnRseSBhdmFpbGFibGUgKHByZXZpb3VzbHkgdXNlZCkgYnVmZmVycyAodWludDgpXG4iLCIvKiBnbG9iYWwgVmVydGV4TGF5b3V0ICovXG5cbmltcG9ydCBnbCBmcm9tICcuL2NvbnN0YW50cyc7IC8vIHdlYiB3b3JrZXJzIGRvbid0IGhhdmUgYWNjZXNzIHRvIEdMIGNvbnRleHQsIHNvIGltcG9ydCBhbGwgR0wgY29uc3RhbnRzXG5pbXBvcnQgVmVydGV4RGF0YSBmcm9tICcuL3ZlcnRleF9kYXRhJztcblxuLy8gRGVzY3JpYmVzIGEgdmVydGV4IGxheW91dCB0aGF0IGNhbiBiZSB1c2VkIHdpdGggbWFueSBkaWZmZXJlbnQgR0wgcHJvZ3JhbXMuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZXJ0ZXhMYXlvdXQge1xuICAgIC8vIEF0dHJpYnMgYXJlIGFuIGFycmF5LCBpbiBsYXlvdXQgb3JkZXIsIG9mOiBuYW1lLCBzaXplLCB0eXBlLCBub3JtYWxpemVkXG4gICAgLy8gZXg6IHsgbmFtZTogJ3Bvc2l0aW9uJywgc2l6ZTogMywgdHlwZTogZ2wuRkxPQVQsIG5vcm1hbGl6ZWQ6IGZhbHNlIH1cbiAgICBjb25zdHJ1Y3RvciAoYXR0cmlicykge1xuICAgICAgICB0aGlzLmF0dHJpYnMgPSBhdHRyaWJzOyAvLyBkaWN0aW9uYXJ5IG9mIGF0dHJpYnV0ZXMsIHNwZWNpZmllZCBhcyBzdGFuZGFyZCBHTCBhdHRyaWIgb3B0aW9uc1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSBbXTsgICAvLyBsaXN0IG9mIHR5cGUgYW5kIG9mZnNldCBpbmZvIGFib3V0IGVhY2ggYXR0cmlidXRlIGNvbXBvbmVudFxuICAgICAgICB0aGlzLmluZGV4ID0ge307ICAgICAgICAvLyBsaW5lYXIgYnVmZmVyIGluZGV4IG9mIGVhY2ggYXR0cmlidXRlIGNvbXBvbmVudCwgZS5nLiB0aGlzLmluZGV4LnBvc2l0aW9uLnhcblxuICAgICAgICAvLyBDYWxjIHZlcnRleCBzdHJpZGVcbiAgICAgICAgdGhpcy5zdHJpZGUgPSAwO1xuXG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIGF0dHJpYiBvZiB0aGlzLmF0dHJpYnMpIHtcbiAgICAgICAgICAgIGF0dHJpYi5vZmZzZXQgPSB0aGlzLnN0cmlkZTtcbiAgICAgICAgICAgIGF0dHJpYi5ieXRlX3NpemUgPSBhdHRyaWIuc2l6ZTtcbiAgICAgICAgICAgIHZhciBzaGlmdCA9IDA7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoYXR0cmliLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIGdsLkZMT0FUOlxuICAgICAgICAgICAgICAgIGNhc2UgZ2wuSU5UOlxuICAgICAgICAgICAgICAgIGNhc2UgZ2wuVU5TSUdORURfSU5UOlxuICAgICAgICAgICAgICAgICAgICBhdHRyaWIuYnl0ZV9zaXplICo9IDQ7XG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBnbC5TSE9SVDpcbiAgICAgICAgICAgICAgICBjYXNlIGdsLlVOU0lHTkVEX1NIT1JUOlxuICAgICAgICAgICAgICAgICAgICBhdHRyaWIuYnl0ZV9zaXplICo9IDI7XG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvcmNlIDQtYnl0ZSBhbGlnbm1lbnQgb24gYXR0cmlidXRlc1xuICAgICAgICAgICAgdGhpcy5zdHJpZGUgKz0gYXR0cmliLmJ5dGVfc2l6ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmlkZSAmIDMpIHsgLy8gcGFkIHRvIG11bHRpcGxlIG9mIDQgYnl0ZXNcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmlkZSArPSA0IC0gKHRoaXMuc3RyaWRlICYgMyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCBpbmZvIHRvIGxpc3Qgb2YgYXR0cmlidXRlIGNvbXBvbmVudHNcbiAgICAgICAgICAgIC8vIFVzZWQgdG8gYnVpbGQgdGhlIHZlcnRleCBkYXRhLCBwcm92aWRlcyBwb2ludGVycyBhbmQgb2Zmc2V0cyBpbnRvIGVhY2ggdHlwZWQgYXJyYXkgdmlld1xuICAgICAgICAgICAgLy8gRWFjaCBjb21wb25lbnQgaXMgYW4gYXJyYXkgb2Y6XG4gICAgICAgICAgICAvLyBbR0wgYXR0cmliIHR5cGUsIHBvaW50ZXIgdG8gdHlwZWQgYXJyYXkgdmlldywgYml0cyB0byBzaGlmdCByaWdodCB0byBkZXRlcm1pbmUgYnVmZmVyIG9mZnNldCwgYWRkaXRpb25hbCBidWZmZXIgb2Zmc2V0IGZvciB0aGUgY29tcG9uZW50XVxuICAgICAgICAgICAgdmFyIG9mZnNldF90eXBlZCA9IGF0dHJpYi5vZmZzZXQgPj4gc2hpZnQ7XG4gICAgICAgICAgICBpZiAoYXR0cmliLnNpemUgPiAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYT0wOyBhIDwgYXR0cmliLnNpemU7IGErKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMucHVzaChbYXR0cmliLnR5cGUsIG51bGwsIHNoaWZ0LCBvZmZzZXRfdHlwZWQrK10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5wdXNoKFthdHRyaWIudHlwZSwgbnVsbCwgc2hpZnQsIG9mZnNldF90eXBlZF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcm92aWRlIGFuIGluZGV4IGludG8gdGhlIHZlcnRleCBkYXRhIGJ1ZmZlciBmb3IgZWFjaCBhdHRyaWJ1dGUgY29tcG9uZW50XG4gICAgICAgICAgICB0aGlzLmluZGV4W2F0dHJpYi5uYW1lXSA9IGNvdW50O1xuICAgICAgICAgICAgY291bnQgKz0gYXR0cmliLnNpemU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXR1cCBhIHZlcnRleCBsYXlvdXQgZm9yIGEgc3BlY2lmaWMgR0wgcHJvZ3JhbVxuICAgIC8vIEFzc3VtZXMgdGhhdCB0aGUgZGVzaXJlZCB2ZXJ0ZXggYnVmZmVyIChWQk8pIGlzIGFscmVhZHkgYm91bmRcbiAgICAvLyBJZiBhIGdpdmVuIHByb2dyYW0gZG9lc24ndCBpbmNsdWRlIGFsbCBhdHRyaWJ1dGVzLCBpdCBjYW4gc3RpbGwgdXNlIHRoZSB2ZXJ0ZXggbGF5b3V0XG4gICAgLy8gdG8gcmVhZCB0aG9zZSBhdHRyaWJzIHRoYXQgaXQgZG9lcyByZWNvZ25pemUsIHVzaW5nIHRoZSBhdHRyaWIgb2Zmc2V0cyB0byBza2lwIG90aGVycy5cbiAgICBlbmFibGUgKGdsLCBwcm9ncmFtLCBmb3JjZSlcbiAgICB7XG4gICAgICAgIHZhciBhdHRyaWIsIGxvY2F0aW9uO1xuXG4gICAgICAgIC8vIEVuYWJsZSBhbGwgYXR0cmlidXRlcyBmb3IgdGhpcyBsYXlvdXRcbiAgICAgICAgZm9yICh2YXIgYT0wOyBhIDwgdGhpcy5hdHRyaWJzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICBhdHRyaWIgPSB0aGlzLmF0dHJpYnNbYV07XG4gICAgICAgICAgICBsb2NhdGlvbiA9IHByb2dyYW0uYXR0cmlidXRlKGF0dHJpYi5uYW1lKS5sb2NhdGlvbjtcblxuICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmICghVmVydGV4TGF5b3V0LmVuYWJsZWRfYXR0cmlic1tsb2NhdGlvbl0gfHwgZm9yY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvY2F0aW9uLCBhdHRyaWIuc2l6ZSwgYXR0cmliLnR5cGUsIGF0dHJpYi5ub3JtYWxpemVkLCB0aGlzLnN0cmlkZSwgYXR0cmliLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgVmVydGV4TGF5b3V0LmVuYWJsZWRfYXR0cmlic1tsb2NhdGlvbl0gPSBwcm9ncmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGlzYWJsZSBhbnkgcHJldmlvdXNseSBib3VuZCBhdHRyaWJ1dGVzIHRoYXQgYXJlbid0IGZvciB0aGlzIGxheW91dFxuICAgICAgICBmb3IgKGxvY2F0aW9uIGluIFZlcnRleExheW91dC5lbmFibGVkX2F0dHJpYnMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZShnbCwgbG9jYXRpb24sIHByb2dyYW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGlzYWJsZSBhbiBhdHRyaWJ1dGUgaWYgaXQgd2FzIG5vdCBlbmFibGVkIGZvciB0aGUgc3BlY2lmaWVkIHByb2dyYW1cbiAgICAvLyBOT1RFOiB0aGlzIHdhcyBtb3ZlZCBvdXQgb2YgdGhlIGlubmVyIGxvb3AgaW4gZW5hYmxlKCkgdG8gYXNzaXN0IHcvVk0gb3B0aW1pemF0aW9uXG4gICAgZGlzYWJsZVVudXNlZEF0dHJpYnV0ZSAoZ2wsIGxvY2F0aW9uLCBwcm9ncmFtKSB7XG4gICAgICAgIGlmIChWZXJ0ZXhMYXlvdXQuZW5hYmxlZF9hdHRyaWJzW2xvY2F0aW9uXSAhPT0gcHJvZ3JhbSkge1xuICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY2F0aW9uKTtcbiAgICAgICAgICAgIGRlbGV0ZSBWZXJ0ZXhMYXlvdXQuZW5hYmxlZF9hdHRyaWJzW2xvY2F0aW9uXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNyZWF0ZVZlcnRleERhdGEgKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlcnRleERhdGEodGhpcyk7XG4gICAgfVxuXG59XG5cbi8vIFRyYWNrIGN1cnJlbnRseSBlbmFibGVkIGF0dHJpYnMsIGJ5IHRoZSBwcm9ncmFtIHRoZXkgYXJlIGJvdW5kIHRvXG4vLyBTdGF0aWMgY2xhc3MgcHJvcGVydHkgdG8gcmVmbGVjdCBnbG9iYWwgR0wgc3RhdGVcblZlcnRleExheW91dC5lbmFibGVkX2F0dHJpYnMgPSB7fTtcbiIsImltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzL3V0aWxzJztcbmltcG9ydCBTY2VuZSBmcm9tICcuL3NjZW5lJztcblxuLy8gRXhwb3J0cyBtdXN0IGFwcGVhciBvdXRzaWRlIGEgZnVuY3Rpb24sIGJ1dCB3aWxsIG9ubHkgYmUgZGVmaW5lZCBpbiBtYWluIHRocmVhZCAoYmVsb3cpXG5leHBvcnQgdmFyIExlYWZsZXRMYXllcjtcbmV4cG9ydCBmdW5jdGlvbiBsZWFmbGV0TGF5ZXIob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgTGVhZmxldExheWVyKG9wdGlvbnMpO1xufVxuXG4vLyBMZWFmbGV0IGxheWVyIGZ1bmN0aW9uYWxpdHkgaXMgb25seSBkZWZpbmVkIGluIG1haW4gdGhyZWFkXG5pZiAoVXRpbHMuaXNNYWluVGhyZWFkKSB7XG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgd2UgYXJlIGV4dGVuZGluZyB0aGUgbGVhZmxldCAwLjcueCBUaWxlTGF5ZXIgY2xhc3MsIG9yIHRoZSBuZXdlclxuICAgIC8vIGxlYWZsZXQgMS54IEdyaWRMYXllciBjbGFzcy5cbiAgICBsZXQgbGF5ZXJCYXNlQ2xhc3MgPSBMLkdyaWRMYXllciA/IEwuR3JpZExheWVyIDogTC5UaWxlTGF5ZXI7XG4gICAgbGV0IGxlYWZsZXRWZXJzaW9uID0gbGF5ZXJCYXNlQ2xhc3MgPT09IEwuR3JpZExheWVyID8gJzEueCcgOiAnMC43LngnO1xuICAgIGxldCBsYXllckNsYXNzQ29uZmlnID0ge307XG5cbiAgICAvLyBJZiBleHRlbmRpbmcgbGVhZmxldCAwLjcueCBUaWxlTGF5ZXIsIG1ha2UgYWRkL3JlbW92ZSB0aWxlIG5vIG9wc1xuICAgIGlmIChsYXllckJhc2VDbGFzcyA9PT0gTC5UaWxlTGF5ZXIpIHtcbiAgICAgICAgbGF5ZXJDbGFzc0NvbmZpZy5fYWRkVGlsZSA9IGZ1bmN0aW9uKCl7fTtcbiAgICAgICAgbGF5ZXJDbGFzc0NvbmZpZy5fcmVtb3ZlVGlsZSA9IGZ1bmN0aW9uKCl7fTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgY3VzdG9tIGxheWVyIG1ldGhvZHNcbiAgICBPYmplY3QuYXNzaWduKGxheWVyQ2xhc3NDb25maWcsIHtcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgLy8gRGVmYXVsdHNcbiAgICAgICAgICAgIG9wdGlvbnMuc2hvd0RlYnVnID0gKCFvcHRpb25zLnNob3dEZWJ1ZyA/IGZhbHNlIDogdHJ1ZSk7XG5cbiAgICAgICAgICAgIEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU2NlbmUoKTtcbiAgICAgICAgICAgIHRoaXMuaG9va3MgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0gPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gRm9yY2UgbGVhZmxldCB6b29tIGFuaW1hdGlvbnMgb2ZmXG4gICAgICAgICAgICB0aGlzLl96b29tQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVTY2VuZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zY2VuZSA9IFNjZW5lLmNyZWF0ZShcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2NlbmUsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBudW1Xb3JrZXJzOiB0aGlzLm9wdGlvbnMubnVtV29ya2VycyxcbiAgICAgICAgICAgICAgICAgICAgcHJlVXBkYXRlOiB0aGlzLm9wdGlvbnMucHJlVXBkYXRlLFxuICAgICAgICAgICAgICAgICAgICBwb3N0VXBkYXRlOiB0aGlzLm9wdGlvbnMucG9zdFVwZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGludW91c1pvb206IChMZWFmbGV0TGF5ZXIubGVhZmxldFZlcnNpb24gPT09ICcxLngnKSxcbiAgICAgICAgICAgICAgICAgICAgaGlnaERlbnNpdHlEaXNwbGF5OiB0aGlzLm9wdGlvbnMuaGlnaERlbnNpdHlEaXNwbGF5LFxuICAgICAgICAgICAgICAgICAgICBsb2dMZXZlbDogdGhpcy5vcHRpb25zLmxvZ0xldmVsLFxuICAgICAgICAgICAgICAgICAgICAvLyBhZHZhbmNlZCBvcHRpb24sIGFwcCB3aWxsIGhhdmUgdG8gbWFudWFsbHkgY2FsbGVkIHNjZW5lLnVwZGF0ZSgpIHBlciBmcmFtZVxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlUmVuZGVyTG9vcDogdGhpcy5vcHRpb25zLmRpc2FibGVSZW5kZXJMb29wLFxuICAgICAgICAgICAgICAgICAgICAvLyBhZHZhbmNlZCBvcHRpb24sIHdpbGwgcmVxdWlyZSBsaWJyYXJ5IHRvIGJlIHNlcnZlZCBhcyBzYW1lIGhvc3QgYXMgcGFnZVxuICAgICAgICAgICAgICAgICAgICBhbGxvd0Nyb3NzRG9tYWluV29ya2VyczogdGhpcy5vcHRpb25zLmFsbG93Q3Jvc3NEb21haW5Xb3JrZXJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRmluaXNoIGluaXRpYWxpemluZyBzY2VuZSBhbmQgc2V0dXAgZXZlbnRzIHdoZW4gbGF5ZXIgaXMgYWRkZWQgdG8gbWFwXG4gICAgICAgIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2NlbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVNjZW5lKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxheWVyQmFzZUNsYXNzLnByb3RvdHlwZS5vbkFkZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICB0aGlzLmhvb2tzLnJlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IG1hcC5nZXRTaXplKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5yZXNpemVNYXAoc2l6ZS54LCBzaXplLnkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0gPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtYXAub24oJ3Jlc2l6ZScsIHRoaXMuaG9va3MucmVzaXplKTtcblxuICAgICAgICAgICAgdGhpcy5ob29rcy5tb3ZlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91cGRhdGluZ190YW5ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgdmlldyA9IG1hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgICAgICAgICB2aWV3Lnpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5zZXRWaWV3KHZpZXcpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuaW1tZWRpYXRlUmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1hcC5vbignbW92ZScsIHRoaXMuaG9va3MubW92ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuaG9va3Muem9vbXN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91cGRhdGluZ190YW5ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnN0YXJ0Wm9vbSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0gPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtYXAub24oJ3pvb21zdGFydCcsIHRoaXMuaG9va3Muem9vbXN0YXJ0KTtcblxuICAgICAgICAgICAgdGhpcy5ob29rcy5kcmFnc3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5wYW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtYXAub24oJ2RyYWdzdGFydCcsIHRoaXMuaG9va3MuZHJhZ3N0YXJ0KTtcblxuICAgICAgICAgICAgdGhpcy5ob29rcy5kcmFnZW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUucGFubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1hcC5vbignZHJhZ2VuZCcsIHRoaXMuaG9va3MuZHJhZ2VuZCk7XG5cbiAgICAgICAgICAgIC8vIEZvcmNlIGxlYWZsZXQgem9vbSBhbmltYXRpb25zIG9mZlxuICAgICAgICAgICAgbWFwLl96b29tQW5pbWF0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gTW9kaWZ5IGRlZmF1bHQgbGVhZmxldCBzY3JvbGwgd2hlZWwgYmVoYXZpb3JcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5U2Nyb2xsV2hlZWxCZWhhdmlvcihtYXApO1xuXG4gICAgICAgICAgICAvLyBDYW52YXMgZWxlbWVudCB3aWxsIGJlIGluc2VydGVkIGFmdGVyIG1hcCBjb250YWluZXIgKGxlYWZsZXQgdHJhbnNmb3JtcyBzaG91bGRuJ3QgYmUgYXBwbGllZCB0byB0aGUgR0wgY2FudmFzKVxuICAgICAgICAgICAgLy8gVE9ETzogZmluZCBhIGJldHRlciB3YXkgdG8gZGVhbCB3aXRoIHRoaXM/IHJpZ2h0IG5vdyBHTCBtYXAgb25seSByZW5kZXJzIGNvcnJlY3RseSBhcyB0aGUgYm90dG9tIGxheWVyXG4gICAgICAgICAgICB0aGlzLnNjZW5lLmNvbnRhaW5lciA9IG1hcC5nZXRDb250YWluZXIoKTtcblxuICAgICAgICAgICAgLy8gSW5pdGlhbCB2aWV3XG4gICAgICAgICAgICB2YXIgdmlldyA9IG1hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgICAgIHZpZXcuem9vbSA9IG1hcC5nZXRab29tKCk7XG4gICAgICAgICAgICB0aGlzLnNjZW5lLnNldFZpZXcodmlldyk7XG5cbiAgICAgICAgICAgIC8vIFN1YnNjcmliZSB0byB0YW5ncmFtIGV2ZW50c1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgIG1vdmU6IHRoaXMub25UYW5ncmFtVmlld1VwZGF0ZS5iaW5kKHRoaXMpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVXNlIGxlYWZsZXQncyBleGlzdGluZyBldmVudCBzeXN0ZW0gYXMgdGhlIGNhbGxiYWNrIG1lY2hhbmlzbVxuICAgICAgICAgICAgdGhpcy5zY2VuZS5sb2FkKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdpbml0Jyk7XG4gICAgICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBsYXllckJhc2VDbGFzcy5wcm90b3R5cGUub25SZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgbWFwLm9mZigncmVzaXplJywgdGhpcy5ob29rcy5yZXNpemUpO1xuICAgICAgICAgICAgbWFwLm9mZignbW92ZScsIHRoaXMuaG9va3MubW92ZSk7XG4gICAgICAgICAgICBtYXAub2ZmKCd6b29tc3RhcnQnLCB0aGlzLmhvb2tzLnpvb21zdGFydCk7XG4gICAgICAgICAgICBtYXAub2ZmKCdkcmFnc3RhcnQnLCB0aGlzLmhvb2tzLmRyYWdzdGFydCk7XG4gICAgICAgICAgICBtYXAub2ZmKCdkcmFnZW5kJywgdGhpcy5ob29rcy5kcmFnZW5kKTtcbiAgICAgICAgICAgIHRoaXMuaG9va3MgPSB7fTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gY29vcmRzLnggKyAnLycgKyBjb29yZHMueSArICcvJyArIGNvb3Jkcy56O1xuICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnZGF0YS10aWxlLWtleScsIGtleSk7XG4gICAgICAgICAgICBkaXYuc3R5bGUud2lkdGggPSAnMjU2cHgnO1xuICAgICAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9ICcyNTZweCc7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0RlYnVnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlYnVnX292ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBkZWJ1Z19vdmVybGF5LnRleHRDb250ZW50ID0ga2V5O1xuICAgICAgICAgICAgICAgIGRlYnVnX292ZXJsYXkuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgICAgIGRlYnVnX292ZXJsYXkuc3R5bGUubGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgZGVidWdfb3ZlcmxheS5zdHlsZS50b3AgPSAwO1xuICAgICAgICAgICAgICAgIGRlYnVnX292ZXJsYXkuc3R5bGUuY29sb3IgPSAnd2hpdGUnO1xuICAgICAgICAgICAgICAgIGRlYnVnX292ZXJsYXkuc3R5bGUuZm9udFNpemUgPSAnMTZweCc7XG4gICAgICAgICAgICAgICAgZGVidWdfb3ZlcmxheS5zdHlsZS50ZXh0T3V0bGluZSA9ICcxcHggIzAwMDAwMCc7XG4gICAgICAgICAgICAgICAgZGVidWdfb3ZlcmxheS5zdHlsZS5wYWRkaW5nID0gJzhweCc7XG5cbiAgICAgICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoZGVidWdfb3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLmJvcmRlclN0eWxlID0gJ3NvbGlkJztcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUuYm9yZGVyQ29sb3IgPSAnd2hpdGUnO1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5ib3JkZXJXaWR0aCA9ICcxcHgnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGl2O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE1vZGlmeSBsZWFmbGV0J3MgZGVmYXVsdCBzY3JvbGwgd2hlZWwgYmVoYXZpb3IgdG8gaGF2ZSBhIG11Y2ggbW9yZSBzZW5zaXR2ZS9jb250aW51b3VzIHpvb21cbiAgICAgICAgLy8gTm90ZTogdGhpcyBzaG91bGQgYmUgZGVwcmVjYXRlZCBvbmNlIGxlYWZsZXQgY29udGludW91cyB6b29tIGlzIG1vcmUgd2lkZWx5IHVzZWQgYW5kIHRoZVxuICAgICAgICAvLyBkZWZhdWx0IGJlaGF2aW9yIGlzIHByZXN1bWFibHkgaW1wcm92ZWRcbiAgICAgICAgbW9kaWZ5U2Nyb2xsV2hlZWxCZWhhdmlvcjogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmUuY29udGludW91c196b29tICYmIG1hcC5zY3JvbGxXaGVlbFpvb20gJiYgdGhpcy5vcHRpb25zLm1vZGlmeVNjcm9sbFdoZWVsICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG1hcC5zY3JvbGxXaGVlbFpvb20uX3BlcmZvcm1ab29tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSB0aGlzLl9kZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIG1hcC5zdG9wKCk7IC8vIHN0b3AgcGFubmluZyBhbmQgZmx5IGFuaW1hdGlvbnMgaWYgYW55XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogdGhpcyBpcyB0aGUgb25seSByZWFsIG1vZGlmaWNhdGlvbiB0byBkZWZhdWx0IGxlYWZsZXQgYmVoYXZpb3JcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgLz0gNDA7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSBNYXRoLm1heChNYXRoLm1pbihkZWx0YSwgNCksIC00KTtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSBtYXAuX2xpbWl0Wm9vbSh6b29tICsgZGVsdGEpIC0gem9vbTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWx0YSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWx0YSkgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobWFwLm9wdGlvbnMuc2Nyb2xsV2hlZWxab29tID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLnNldFpvb20oem9vbSArIGRlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5zZXRab29tQXJvdW5kKHRoaXMuX2xhc3RNb3VzZVBvcywgem9vbSArIGRlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvblRhbmdyYW1WaWV3VXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl91cGRhdGluZ190YW5ncmFtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9tYXAuc2V0VmlldyhbdGhpcy5zY2VuZS5jZW50ZXIubGF0LCB0aGlzLnNjZW5lLmNlbnRlci5sbmddLCB0aGlzLnNjZW5lLnpvb20sIHsgYW5pbWF0ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2NlbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNjZW5lLnVwZGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSB0aGUgbGF5ZXIgY2xhc3NcbiAgICBMZWFmbGV0TGF5ZXIgPSBsYXllckJhc2VDbGFzcy5leHRlbmQobGF5ZXJDbGFzc0NvbmZpZyk7XG5cbiAgICAvLyBQb2x5ZmlsbCBzb21lIDEuMCBtZXRob2RzXG4gICAgaWYgKHR5cGVvZiBMZWFmbGV0TGF5ZXIucmVtb3ZlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIExlYWZsZXRMYXllci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5maXJlKCdyZW1vdmUnKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBMZWFmbGV0TGF5ZXIubGF5ZXJCYXNlQ2xhc3MgPSBsYXllckJhc2VDbGFzcztcbiAgICBMZWFmbGV0TGF5ZXIubGVhZmxldFZlcnNpb24gPSBsZWFmbGV0VmVyc2lvbjtcblxufVxuIiwiLypnbG9iYWwgTGlnaHQgKi9cbmltcG9ydCBTaGFkZXJQcm9ncmFtIGZyb20gJy4vZ2wvc2hhZGVyX3Byb2dyYW0nO1xuaW1wb3J0IHNoYWRlclNvdXJjZXMgZnJvbSAnLi9nbC9zaGFkZXJfc291cmNlcyc7IC8vIGJ1aWx0LWluIHNoYWRlcnNcbmltcG9ydCBHTFNMIGZyb20gJy4vZ2wvZ2xzbCc7XG5pbXBvcnQgR2VvIGZyb20gJy4vZ2VvJztcbmltcG9ydCB7U3R5bGVQYXJzZXJ9IGZyb20gJy4vc3R5bGVzL3N0eWxlX3BhcnNlcic7XG5cbi8vIEFic3RyYWN0IGxpZ2h0XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaWdodCB7XG5cbiAgICBjb25zdHJ1Y3RvciAoc2NlbmUsIGNvbmZpZykge1xuICAgICAgICB0aGlzLm5hbWUgPSBjb25maWcubmFtZTtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuXG4gICAgICAgIGlmIChjb25maWcuYW1iaWVudCA9PSBudWxsIHx8IHR5cGVvZiBjb25maWcuYW1iaWVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuYW1iaWVudCA9IEdMU0wuZXhwYW5kVmVjNChjb25maWcuYW1iaWVudCB8fCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYW1iaWVudCA9IFN0eWxlUGFyc2VyLnBhcnNlQ29sb3IoY29uZmlnLmFtYmllbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5kaWZmdXNlID09IG51bGwgfHwgdHlwZW9mIGNvbmZpZy5kaWZmdXNlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5kaWZmdXNlID0gR0xTTC5leHBhbmRWZWM0KGNvbmZpZy5kaWZmdXNlICE9IG51bGwgPyBjb25maWcuZGlmZnVzZSA6IDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaWZmdXNlID0gU3R5bGVQYXJzZXIucGFyc2VDb2xvcihjb25maWcuZGlmZnVzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLnNwZWN1bGFyID09IG51bGwgfHwgdHlwZW9mIGNvbmZpZy5zcGVjdWxhciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuc3BlY3VsYXIgPSBHTFNMLmV4cGFuZFZlYzQoY29uZmlnLnNwZWN1bGFyIHx8IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zcGVjdWxhciA9IFN0eWxlUGFyc2VyLnBhcnNlQ29sb3IoY29uZmlnLnNwZWN1bGFyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIGxpZ2h0IGJ5IHR5cGUgbmFtZSwgZmFjdG9yeS1zdHlsZVxuICAgIC8vICdjb25maWcnIG11c3QgaW5jbHVkZSAnbmFtZScgYW5kICd0eXBlJywgYWxvbmcgd2l0aCBhbnkgb3RoZXIgdHlwZS1zcGVjaWZpYyBwcm9wZXJ0aWVzXG4gICAgc3RhdGljIGNyZWF0ZSAoc2NlbmUsIGNvbmZpZykge1xuICAgICAgICBpZiAoTGlnaHQudHlwZXNbY29uZmlnLnR5cGVdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpZ2h0LnR5cGVzW2NvbmZpZy50eXBlXShzY2VuZSwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCBsaWdodCBmb3IgYSBzdHlsZTogZnJhZ21lbnQgbGlnaHRpbmcsIHZlcnRleCBsaWdodGluZywgb3Igbm9uZVxuICAgIHN0YXRpYyBzZXRNb2RlIChtb2RlLCBzdHlsZSkge1xuICAgICAgICBpZiAobW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbW9kZSA9ICdmcmFnbWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZSA9IExpZ2h0LmVuYWJsZWQgJiYgKChtb2RlICE9IG51bGwpID8gbW9kZSA6ICdmcmFnbWVudCcpOyAvLyBkZWZhdWx0IHRvIGZyYWdtZW50IGxpZ2h0aW5nXG4gICAgICAgIHN0eWxlLmRlZmluZXNbJ1RBTkdSQU1fTElHSFRJTkdfRlJBR01FTlQnXSA9IChtb2RlID09PSAnZnJhZ21lbnQnKTtcbiAgICAgICAgc3R5bGUuZGVmaW5lc1snVEFOR1JBTV9MSUdIVElOR19WRVJURVgnXSA9IChtb2RlID09PSAndmVydGV4Jyk7XG4gICAgfVxuXG4gICAgLy8gSW5qZWN0IGFsbCBwcm92aWRlZCBsaWdodCBkZWZpbml0aW9ucywgYW5kIGNhbGN1bGF0ZSBjdW11bGF0aXZlIGxpZ2h0IGZ1bmN0aW9uXG4gICAgc3RhdGljIGluamVjdCAobGlnaHRzKSB7XG4gICAgICAgIC8vIENsZWFyIHByZXZpb3VzIGluamVjdGlvbnNcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5yZW1vdmVCbG9jayhMaWdodC5ibG9jayk7XG5cbiAgICAgICAgLy8gSWYgbGlnaHRpbmcgaXMgZ2xvYmFsbHkgZGlzYWJsZWQsIG5vdGhpbmcgaXMgaW5qZWN0ZWQgKG1vc3RseSBmb3IgZGVidWdnaW5nIG9yIGxpdmUgZWRpdGluZylcbiAgICAgICAgaWYgKCFMaWdodC5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb25zdHJ1Y3QgY29kZSB0byBjYWxjdWxhdGUgZWFjaCBsaWdodCBpbnN0YW5jZVxuICAgICAgICBsZXQgY2FsY3VsYXRlTGlnaHRzID0gXCJcIjtcbiAgICAgICAgaWYgKGxpZ2h0cyAmJiBPYmplY3Qua2V5cyhsaWdodHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIENvbGxlY3QgdW5pcXVlcyB0eXBlcyBvZiBsaWdodHNcbiAgICAgICAgICAgIGxldCB0eXBlcyA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgbGlnaHRfbmFtZSBpbiBsaWdodHMpIHtcbiAgICAgICAgICAgICAgICB0eXBlc1tsaWdodHNbbGlnaHRfbmFtZV0udHlwZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbmplY3QgZWFjaCB0eXBlIG9mIGxpZ2h0XG4gICAgICAgICAgICBmb3IgKGxldCB0eXBlIGluIHR5cGVzKSB7XG4gICAgICAgICAgICAgICAgTGlnaHQudHlwZXNbdHlwZV0uaW5qZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluamVjdCBwZXItaW5zdGFuY2UgYmxvY2tzIGFuZCBjb25zdHJ1Y3QgdGhlIGxpc3Qgb2YgZnVuY3Rpb25zIHRvIGNhbGN1bGF0ZSBlYWNoIGxpZ2h0XG4gICAgICAgICAgICBmb3IgKGxldCBsaWdodF9uYW1lIGluIGxpZ2h0cykge1xuICAgICAgICAgICAgICAgIC8vIERlZmluZSBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIGxpZ2h0c1tsaWdodF9uYW1lXS5pbmplY3QoKTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY2FsY3VsYXRpb24gZnVuY3Rpb24gdG8gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVMaWdodHMgKz0gYGNhbGN1bGF0ZUxpZ2h0KCR7bGlnaHRfbmFtZX0sIF9leWVUb1BvaW50LCBfbm9ybWFsKTtcXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbm8gbGlnaHQgaXMgZGVmaW5lZCwgdXNlIDEwMCUgb21uaWRpcmVjdGlvbmFsIGRpZmZ1c2UgbGlnaHRcbiAgICAgICAgICAgIGNhbGN1bGF0ZUxpZ2h0cyA9IGBcbiAgICAgICAgICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFXG4gICAgICAgICAgICAgICAgICAgIGxpZ2h0X2FjY3VtdWxhdG9yX2RpZmZ1c2UgPSB2ZWM0KDEuKTtcbiAgICAgICAgICAgICAgICAjZW5kaWZcbiAgICAgICAgICAgIGA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHbHVlIHRvZ2V0aGVyIHRoZSBmaW5hbCBsaWdodGluZyBmdW5jdGlvbiB0aGF0IHN1bXMgYWxsIHRoZSBsaWdodHNcbiAgICAgICAgbGV0IGNhbGN1bGF0ZUZ1bmN0aW9uID0gYFxuICAgICAgICAgICAgdmVjNCBjYWxjdWxhdGVMaWdodGluZyhpbiB2ZWMzIF9leWVUb1BvaW50LCBpbiB2ZWMzIF9ub3JtYWwsIGluIHZlYzQgX2NvbG9yKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBEbyBpbml0aWFsIG1hdGVyaWFsIGNhbGN1bGF0aW9ucyBvdmVyIG5vcm1hbCwgZW1pc3Npb24sIGFtYmllbnQsIGRpZmZ1c2UgYW5kIHNwZWN1bGFyIHZhbHVlc1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZU1hdGVyaWFsKF9leWVUb1BvaW50LF9ub3JtYWwpO1xuXG4gICAgICAgICAgICAgICAgLy8gVW4gcm9sbCB0aGUgbG9vcCBvZiBpbmRpdmlkdWFsIGxpZ3RocyB0byBjYWxjdWxhdGVcbiAgICAgICAgICAgICAgICAke2NhbGN1bGF0ZUxpZ2h0c31cblxuICAgICAgICAgICAgICAgIC8vICBGaW5hbCBsaWdodCBpbnRlbnNpdHkgY2FsY3VsYXRpb25cbiAgICAgICAgICAgICAgICB2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xuXG4gICAgICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRU1JU1NJT05cbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBtYXRlcmlhbC5lbWlzc2lvbjtcbiAgICAgICAgICAgICAgICAjZW5kaWZcblxuICAgICAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0FNQklFTlRcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgKz0gbGlnaHRfYWNjdW11bGF0b3JfYW1iaWVudCAqIF9jb2xvciAqIG1hdGVyaWFsLmFtYmllbnQ7XG4gICAgICAgICAgICAgICAgI2Vsc2VcbiAgICAgICAgICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgKz0gbGlnaHRfYWNjdW11bGF0b3JfYW1iaWVudCAqIF9jb2xvciAqIG1hdGVyaWFsLmRpZmZ1c2U7XG4gICAgICAgICAgICAgICAgICAgICNlbmRpZlxuICAgICAgICAgICAgICAgICNlbmRpZlxuXG4gICAgICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRVxuICAgICAgICAgICAgICAgICAgICBjb2xvciArPSBsaWdodF9hY2N1bXVsYXRvcl9kaWZmdXNlICogX2NvbG9yICogbWF0ZXJpYWwuZGlmZnVzZTtcbiAgICAgICAgICAgICAgICAjZW5kaWZcblxuICAgICAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yICs9IGxpZ2h0X2FjY3VtdWxhdG9yX3NwZWN1bGFyICogbWF0ZXJpYWwuc3BlY3VsYXI7XG4gICAgICAgICAgICAgICAgI2VuZGlmXG5cbiAgICAgICAgICAgICAgICAvLyBDbGFtcCBmaW5hbCBjb2xvclxuICAgICAgICAgICAgICAgIGNvbG9yID0gY2xhbXAoY29sb3IsIDAuMCwgMS4wKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgICAgIH1gO1xuXG4gICAgICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soTGlnaHQuYmxvY2ssIGNhbGN1bGF0ZUZ1bmN0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBDb21tb24gaW5zdGFuY2UgZGVmaW5pdGlvblxuICAgIGluamVjdCAoKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9ICBgXG4gICAgICAgICAgICB1bmlmb3JtICR7dGhpcy5zdHJ1Y3RfbmFtZX0gdV8ke3RoaXMubmFtZX07XG4gICAgICAgICAgICAke3RoaXMuc3RydWN0X25hbWV9ICR7dGhpcy5uYW1lfSA9IHVfJHt0aGlzLm5hbWV9O1xcbmA7XG5cbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5hZGRCbG9jayhMaWdodC5ibG9jaywgaW5zdGFuY2UpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBtZXRob2QgY2FsbGVkIG9uY2UgcGVyIGZyYW1lXG4gICAgdXBkYXRlICgpIHtcbiAgICB9XG5cbiAgICAvLyBDYWxsZWQgb25jZSBwZXIgZnJhbWUgcGVyIHByb2dyYW0gKGUuZy4gZm9yIG1haW4gcmVuZGVyIHBhc3MsIHRoZW4gZm9yIGVhY2ggYWRkaXRpb25hbFxuICAgIC8vIHBhc3MgZm9yIGZlYXR1cmUgc2VsZWN0aW9uLCBldGMuKVxuICAgIHNldHVwUHJvZ3JhbSAoX3Byb2dyYW0pIHtcbiAgICAgICAgLy8gIFRocmVlIGNvbW1vbiBsaWdodCBwcm9wZXJ0aWVzXG4gICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzRmdicsIGB1XyR7dGhpcy5uYW1lfS5hbWJpZW50YCwgdGhpcy5hbWJpZW50KTtcbiAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnNGZ2JywgYHVfJHt0aGlzLm5hbWV9LmRpZmZ1c2VgLCB0aGlzLmRpZmZ1c2UpO1xuICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCc0ZnYnLCBgdV8ke3RoaXMubmFtZX0uc3BlY3VsYXJgLCB0aGlzLnNwZWN1bGFyKTtcbiAgICB9XG5cbn1cblxuTGlnaHQudHlwZXMgPSB7fTsgLy8gcmVmZXJlbmNlcyB0byBzdWJjbGFzc2VzIGJ5IHNob3J0IG5hbWVcbkxpZ2h0LmJsb2NrID0gJ2xpZ2h0aW5nJzsgLy8gc2hhZGVyIGJsb2NrIG5hbWVcbkxpZ2h0LmVuYWJsZWQgPSB0cnVlOyAvLyBsaWdodGluZyBjYW4gYmUgZ2xvYmFsbHkgZW5hYmxlZC9kaXNhYmxlZFxuXG5cbi8vIExpZ2h0IHN1YmNsYXNzZXNcbmNsYXNzIEFtYmllbnRMaWdodCBleHRlbmRzIExpZ2h0IHtcblxuICAgIGNvbnN0cnVjdG9yKHNjZW5lLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIoc2NlbmUsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdhbWJpZW50JztcbiAgICAgICAgdGhpcy5zdHJ1Y3RfbmFtZSA9ICdBbWJpZW50TGlnaHQnO1xuICAgIH1cblxuICAgIC8vIEluamVjdCBzdHJ1Y3QgYW5kIGNhbGN1bGF0ZSBmdW5jdGlvblxuICAgIHN0YXRpYyBpbmplY3QoKSB7XG4gICAgICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soTGlnaHQuYmxvY2ssIHNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvYW1iaWVudExpZ2h0J10pO1xuICAgIH1cblxuICAgIHNldHVwUHJvZ3JhbSAoX3Byb2dyYW0pIHtcbiAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnNGZ2JywgYHVfJHt0aGlzLm5hbWV9LmFtYmllbnRgLCB0aGlzLmFtYmllbnQpO1xuICAgIH1cblxufVxuTGlnaHQudHlwZXNbJ2FtYmllbnQnXSA9IEFtYmllbnRMaWdodDtcblxuY2xhc3MgRGlyZWN0aW9uYWxMaWdodCBleHRlbmRzIExpZ2h0IHtcblxuICAgIGNvbnN0cnVjdG9yKHNjZW5lLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIoc2NlbmUsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdkaXJlY3Rpb25hbCc7XG4gICAgICAgIHRoaXMuc3RydWN0X25hbWUgPSAnRGlyZWN0aW9uYWxMaWdodCc7XG5cbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSAoY29uZmlnLmRpcmVjdGlvbiB8fCBbMC4yLCAwLjcsIC0wLjVdKS5tYXAocGFyc2VGbG9hdCk7IC8vIFt4LCB5LCB6XVxuICAgIH1cblxuICAgIC8vIEluamVjdCBzdHJ1Y3QgYW5kIGNhbGN1bGF0ZSBmdW5jdGlvblxuICAgIHN0YXRpYyBpbmplY3QoKSB7XG4gICAgICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soTGlnaHQuYmxvY2ssIHNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvZGlyZWN0aW9uYWxMaWdodCddKTtcbiAgICB9XG5cbiAgICBzZXR1cFByb2dyYW0gKF9wcm9ncmFtKSB7XG4gICAgICAgIHN1cGVyLnNldHVwUHJvZ3JhbShfcHJvZ3JhbSk7XG4gICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzNmdicsIGB1XyR7dGhpcy5uYW1lfS5kaXJlY3Rpb25gLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgfVxuXG59XG5MaWdodC50eXBlc1snZGlyZWN0aW9uYWwnXSA9IERpcmVjdGlvbmFsTGlnaHQ7XG5cblxuY2xhc3MgUG9pbnRMaWdodCBleHRlbmRzIExpZ2h0IHtcblxuICAgIGNvbnN0cnVjdG9yIChzY2VuZSwgY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKHNjZW5lLCBjb25maWcpO1xuICAgICAgICB0aGlzLnR5cGUgPSAncG9pbnQnO1xuICAgICAgICB0aGlzLnN0cnVjdF9uYW1lID0gJ1BvaW50TGlnaHQnO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBjb25maWcucG9zaXRpb24gfHwgWzAsIDAsIDBdO1xuICAgICAgICB0aGlzLnBvc2l0aW9uX2V5ZSA9IFtdOyAvLyBwb3NpdGlvbiBpbiBleWVzcGFjZVxuICAgICAgICB0aGlzLm9yaWdpbiA9IGNvbmZpZy5vcmlnaW4gfHwgJ3dvcmxkJztcbiAgICAgICAgdGhpcy5hdHRlbnVhdGlvbiA9ICFpc05hTihwYXJzZUZsb2F0KGNvbmZpZy5hdHRlbnVhdGlvbikpID8gcGFyc2VGbG9hdChjb25maWcuYXR0ZW51YXRpb24pIDogMDtcblxuICAgICAgICBpZiAoY29uZmlnLnJhZGl1cykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLnJhZGl1cykgJiYgY29uZmlnLnJhZGl1cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhZGl1cyA9IGNvbmZpZy5yYWRpdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhZGl1cyA9IFtudWxsLCBjb25maWcucmFkaXVzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluamVjdCBzdHJ1Y3QgYW5kIGNhbGN1bGF0ZSBmdW5jdGlvblxuICAgIHN0YXRpYyBpbmplY3QgKCkge1xuICAgICAgICBTaGFkZXJQcm9ncmFtLmFkZEJsb2NrKExpZ2h0LmJsb2NrLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3BvaW50TGlnaHQnXSk7XG4gICAgfVxuXG4gICAgLy8gSW5qZWN0IGlzbnRhbmNlLXNwZWNpZmljIHNldHRpbmdzXG4gICAgaW5qZWN0KCkge1xuICAgICAgICBzdXBlci5pbmplY3QoKTtcblxuICAgICAgICBTaGFkZXJQcm9ncmFtLmRlZmluZXNbJ1RBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9FWFBPTkVOVCddID0gKHRoaXMuYXR0ZW51YXRpb24gIT09IDApO1xuICAgICAgICBTaGFkZXJQcm9ncmFtLmRlZmluZXNbJ1RBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9JTk5FUl9SQURJVVMnXSA9ICh0aGlzLnJhZGl1cyAhPSBudWxsICYmIHRoaXMucmFkaXVzWzBdICE9IG51bGwpO1xuICAgICAgICBTaGFkZXJQcm9ncmFtLmRlZmluZXNbJ1RBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVMnXSA9ICh0aGlzLnJhZGl1cyAhPSBudWxsKTtcbiAgICB9XG5cbiAgICB1cGRhdGUgKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUV5ZVBvc2l0aW9uKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlRXllUG9zaXRpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vcmlnaW4gPT09ICd3b3JsZCcpIHtcbiAgICAgICAgICAgIC8vIEZvciB3b3JsZCBvcmlnaW4sIGZvcm1hdCBpczogW2xvbmdpdHVkZSwgbGF0aXR1ZGUsIG1ldGVycyAoZGVmYXVsdCkgb3IgcGl4ZWxzIHcvcHggdW5pdHNdXG5cbiAgICAgICAgICAgIC8vIE1vdmUgbGlnaHQncyB3b3JsZCBwb3NpdGlvbiBpbnRvIGNhbWVyYSBzcGFjZVxuICAgICAgICAgICAgbGV0IFt4LCB5XSA9IEdlby5sYXRMbmdUb01ldGVycyh0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25fZXllWzBdID0geCAtIHRoaXMuc2NlbmUuY2FtZXJhLnBvc2l0aW9uX21ldGVyc1swXTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25fZXllWzFdID0geSAtIHRoaXMuc2NlbmUuY2FtZXJhLnBvc2l0aW9uX21ldGVyc1sxXTtcblxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbl9leWVbMl0gPSBTdHlsZVBhcnNlci5jb252ZXJ0VW5pdHModGhpcy5wb3NpdGlvblsyXSwgeyB6b29tOiB0aGlzLnNjZW5lLnpvb20gfSk7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uX2V5ZVsyXSA9IHRoaXMucG9zaXRpb25fZXllWzJdIC0gdGhpcy5zY2VuZS5jYW1lcmEucG9zaXRpb25fbWV0ZXJzWzJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2dyb3VuZCcgfHwgdGhpcy5vcmlnaW4gPT09ICdjYW1lcmEnKSB7XG4gICAgICAgICAgICAvLyBGb3IgY2FtZXJhIG9yIGdyb3VuZCBvcmlnaW4sIGZvcm1hdCBpczogW3gsIHksIHpdIGluIG1ldGVycyAoZGVmYXVsdCkgb3IgcGl4ZWxzIHcvcHggdW5pdHNcblxuICAgICAgICAgICAgLy8gTGlnaHQgaXMgaW4gY2FtZXJhIHNwYWNlIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25fZXllID0gU3R5bGVQYXJzZXIuY29udmVydFVuaXRzKHRoaXMucG9zaXRpb24sIHsgem9vbTogdGhpcy5zY2VuZS56b29tIH0pO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdncm91bmQnKSB7XG4gICAgICAgICAgICAgICAgLy8gTGVhdmUgbGlnaHQncyB4eSBpbiBjYW1lcmEgc3BhY2UsIGJ1dCB6IG5lZWRzIHRvIGJlIG1vdmVkIHJlbGF0aXZlIHRvIGdyb3VuZCBwbGFuZVxuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25fZXllWzJdID0gdGhpcy5wb3NpdGlvbl9leWVbMl0gLSB0aGlzLnNjZW5lLmNhbWVyYS5wb3NpdGlvbl9tZXRlcnNbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXR1cFByb2dyYW0gKF9wcm9ncmFtKSB7XG4gICAgICAgIHN1cGVyLnNldHVwUHJvZ3JhbShfcHJvZ3JhbSk7XG5cbiAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnNGYnLCBgdV8ke3RoaXMubmFtZX0ucG9zaXRpb25gLFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbl9leWVbMF0sIHRoaXMucG9zaXRpb25fZXllWzFdLCB0aGlzLnBvc2l0aW9uX2V5ZVsyXSwgMSk7XG5cbiAgICAgICAgaWYoU2hhZGVyUHJvZ3JhbS5kZWZpbmVzWydUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fRVhQT05FTlQnXSkge1xuICAgICAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnMWYnLCBgdV8ke3RoaXMubmFtZX0uYXR0ZW51YXRpb25FeHBvbmVudGAsIHRoaXMuYXR0ZW51YXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoU2hhZGVyUHJvZ3JhbS5kZWZpbmVzWydUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fSU5ORVJfUkFESVVTJ10pIHtcbiAgICAgICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzFmJywgYHVfJHt0aGlzLm5hbWV9LmlubmVyUmFkaXVzYCxcbiAgICAgICAgICAgICAgICBTdHlsZVBhcnNlci5jb252ZXJ0VW5pdHModGhpcy5yYWRpdXNbMF0sIHsgem9vbTogdGhpcy5zY2VuZS56b29tIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKFNoYWRlclByb2dyYW0uZGVmaW5lc1snVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX09VVEVSX1JBRElVUyddKSB7XG4gICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCcxZicsIGB1XyR7dGhpcy5uYW1lfS5vdXRlclJhZGl1c2AsXG4gICAgICAgICAgICAgICAgU3R5bGVQYXJzZXIuY29udmVydFVuaXRzKHRoaXMucmFkaXVzWzFdLCB7IHpvb206IHRoaXMuc2NlbmUuem9vbSB9KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5MaWdodC50eXBlc1sncG9pbnQnXSA9IFBvaW50TGlnaHQ7XG5cblxuY2xhc3MgU3BvdExpZ2h0IGV4dGVuZHMgUG9pbnRMaWdodCB7XG5cbiAgICBjb25zdHJ1Y3RvciAoc2NlbmUsIGNvbmZpZykge1xuICAgICAgICBzdXBlcihzY2VuZSwgY29uZmlnKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3Nwb3RsaWdodCc7XG4gICAgICAgIHRoaXMuc3RydWN0X25hbWUgPSAnU3BvdExpZ2h0JztcblxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IChjb25maWcuZGlyZWN0aW9uIHx8IFswLCAwLCAtMV0pLm1hcChwYXJzZUZsb2F0KTsgLy8gW3gsIHksIHpdXG4gICAgICAgIHRoaXMuZXhwb25lbnQgPSBjb25maWcuZXhwb25lbnQgPyBwYXJzZUZsb2F0KGNvbmZpZy5leHBvbmVudCkgOiAwLjI7XG4gICAgICAgIHRoaXMuYW5nbGUgPSBjb25maWcuYW5nbGUgPyBwYXJzZUZsb2F0KGNvbmZpZy5hbmdsZSkgOiAyMDtcbiAgICB9XG5cbiAgICAvLyBJbmplY3Qgc3RydWN0IGFuZCBjYWxjdWxhdGUgZnVuY3Rpb25cbiAgICBzdGF0aWMgaW5qZWN0ICgpIHtcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5hZGRCbG9jayhMaWdodC5ibG9jaywgc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9zcG90TGlnaHQnXSk7XG4gICAgfVxuXG4gICAgc2V0dXBQcm9ncmFtIChfcHJvZ3JhbSkge1xuICAgICAgICBzdXBlci5zZXR1cFByb2dyYW0oX3Byb2dyYW0pO1xuXG4gICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzNmdicsIGB1XyR7dGhpcy5uYW1lfS5kaXJlY3Rpb25gLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzFmJywgYHVfJHt0aGlzLm5hbWV9LnNwb3RDb3NDdXRvZmZgLCBNYXRoLmNvcyh0aGlzLmFuZ2xlICogMy4xNDE1OSAvIDE4MCkpO1xuICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCcxZicsIGB1XyR7dGhpcy5uYW1lfS5zcG90RXhwb25lbnRgLCB0aGlzLmV4cG9uZW50KTtcbiAgICB9XG5cbn1cbkxpZ2h0LnR5cGVzWydzcG90bGlnaHQnXSA9IFNwb3RMaWdodDtcbiIsIi8qZ2xvYmFsIE1hdGVyaWFsICovXG5pbXBvcnQgc2hhZGVyU291cmNlcyBmcm9tICcuL2dsL3NoYWRlcl9zb3VyY2VzJzsgLy8gYnVpbHQtaW4gc2hhZGVyc1xuaW1wb3J0IEdMU0wgZnJvbSAnLi9nbC9nbHNsJztcbmltcG9ydCB7U3R5bGVQYXJzZXJ9IGZyb20gJy4vc3R5bGVzL3N0eWxlX3BhcnNlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdGVyaWFsIHtcbiAgICBjb25zdHJ1Y3RvciAoY29uZmlnKSB7XG5cbiAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgYWxsIGhhdmUgdGhlIHNhbWUgZGVmYXVsdHMsIHNvIHRoZXkgY2FuIGJlIHNldCBpbiBidWxrXG4gICAgICAgIGZvciAobGV0IHByb3Agb2YgWydlbWlzc2lvbicsICdhbWJpZW50JywgJ2RpZmZ1c2UnLCAnc3BlY3VsYXInXSkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ1twcm9wXS50ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlOiBjb25maWdbcHJvcF0udGV4dHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNvbmZpZ1twcm9wXS5tYXBwaW5nIHx8ICdzcGhlcmVtYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGU6IEdMU0wuZXhwYW5kVmVjMyhjb25maWdbcHJvcF0uc2NhbGUgIT0gbnVsbCA/IGNvbmZpZ1twcm9wXS5zY2FsZSA6IDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBHTFNMLmV4cGFuZFZlYzQoY29uZmlnW3Byb3BdLmFtb3VudCAhPSBudWxsID8gY29uZmlnW3Byb3BdLmFtb3VudCA6IDEpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb25maWdbcHJvcF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcF0gPSB7IGFtb3VudDogR0xTTC5leHBhbmRWZWM0KGNvbmZpZ1twcm9wXSkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbmZpZ1twcm9wXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wXSA9IHsgYW1vdW50OiBTdHlsZVBhcnNlci5wYXJzZUNvbG9yKGNvbmZpZ1twcm9wXSkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcF0gPSBjb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXh0cmEgc3BlY3VsYXIgcHJvcHNcbiAgICAgICAgaWYgKHRoaXMuc3BlY3VsYXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3BlY3VsYXIuc2hpbmluZXNzID0gY29uZmlnLnNoaW5pbmVzcyA/IHBhcnNlRmxvYXQoY29uZmlnLnNoaW5pbmVzcykgOiAwLjI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3JtYWwgbWFwcGluZ1xuICAgICAgICBpZiAoY29uZmlnLm5vcm1hbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm5vcm1hbCA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlOiBjb25maWcubm9ybWFsLnRleHR1cmUsXG4gICAgICAgICAgICAgICAgbWFwcGluZzogY29uZmlnLm5vcm1hbC5tYXBwaW5nIHx8ICd0cmlwbGFuYXInLFxuICAgICAgICAgICAgICAgIHNjYWxlOiBHTFNMLmV4cGFuZFZlYzMoY29uZmlnLm5vcm1hbC5zY2FsZSAhPSBudWxsID8gY29uZmlnLm5vcm1hbC5zY2FsZSA6IDEpLFxuICAgICAgICAgICAgICAgIGFtb3VudDogY29uZmlnLm5vcm1hbC5hbW91bnQgIT0gbnVsbCA/IGNvbmZpZy5ub3JtYWwuYW1vdW50IDogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIERldGVybWluZSBpZiBhIG1hdGVyaWFsIGNvbmZpZyBibG9jayBoYXMgc3VmZmljaWVudCBwcm9wZXJ0aWVzIHRvIGNyZWF0ZSBhIG1hdGVyaWFsXG4gICAgc3RhdGljIGlzVmFsaWQgKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuZW1pc3Npb24gPT0gbnVsbCAmJlxuICAgICAgICAgICAgY29uZmlnLmFtYmllbnQgPT0gbnVsbCAmJlxuICAgICAgICAgICAgY29uZmlnLmRpZmZ1c2UgPT0gbnVsbCAmJlxuICAgICAgICAgICAgY29uZmlnLnNwZWN1bGFyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGluamVjdCAoc3R5bGUpIHtcbiAgICAgICAgLy8gRm9yIGVhY2ggcHJvcGVydHksIHNldHMgZGVmaW5lcyB0byBjb25maWd1cmUgdGV4dHVyZSBtYXBwaW5nLCB3aXRoIGEgcGF0dGVybiBsaWtlOlxuICAgICAgICAvLyAgIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRSwgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFX1RFWFRVUkUsIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRV9URVhUVVJFX1NQSEVSRU1BUFxuICAgICAgICAvLyBBbHNvIHNldHMgZmxhZ3MgdG8ga2VlcCB0cmFjayBvZiBlYWNoIHVuaXF1ZSBtYXBwaW5nIHR5cGUgYmVpbmcgdXNlZCwgZS5nLjpcbiAgICAgICAgLy8gICBUQU5HUkFNX01BVEVSSUFMX1RFWFRVUkVfU1BIRVJFTUFQXG4gICAgICAgIC8vIEVuYWJsZXMgdGV4dHVyZSBjb29yZGluYXRlcyBpZiBuZWVkZWQgYW5kIG5vdCBhbHJlYWR5IG9uXG4gICAgICAgIGZvciAobGV0IHByb3Agb2YgWydlbWlzc2lvbicsICdhbWJpZW50JywgJ2RpZmZ1c2UnLCAnc3BlY3VsYXInXSkge1xuICAgICAgICAgICAgbGV0IGRlZiA9IGBUQU5HUkFNX01BVEVSSUFMXyR7cHJvcC50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICAgICAgICBsZXQgdGV4ZGVmID0gZGVmICsgJ19URVhUVVJFJztcbiAgICAgICAgICAgIHN0eWxlLmRlZmluZXNbZGVmXSA9ICh0aGlzW3Byb3BdICE9IG51bGwpO1xuICAgICAgICAgICAgaWYgKHRoaXNbcHJvcF0gJiYgdGhpc1twcm9wXS50ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuZGVmaW5lc1t0ZXhkZWZdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdHlsZS5kZWZpbmVzW3RleGRlZiArICdfJyArIHRoaXNbcHJvcF0ubWFwcGluZy50b1VwcGVyQ2FzZSgpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3R5bGUuZGVmaW5lc1tgVEFOR1JBTV9NQVRFUklBTF9URVhUVVJFXyR7dGhpc1twcm9wXS5tYXBwaW5nLnRvVXBwZXJDYXNlKCl9YF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0eWxlLnRleGNvb3JkcyA9IHN0eWxlLnRleGNvb3JkcyB8fCAodGhpc1twcm9wXS5tYXBwaW5nID09PSAndXYnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vcm1hbCBtYXBwaW5nXG4gICAgICAgIC8vIEFzIGFub3ZlLCBzZXRzIGZsYWdzIHRvIGtlZXAgdHJhY2sgb2YgZWFjaCB1bmlxdWUgbWFwcGluZyB0eXBlIGJlaW5nIHVzZWQsIGUuZy46XG4gICAgICAgIC8vICAgVEFOR1JBTV9NQVRFUklBTF9URVhUVVJFX1NQSEVSRU1BUFxuICAgICAgICBpZiAodGhpcy5ub3JtYWwgJiYgdGhpcy5ub3JtYWwudGV4dHVyZSkge1xuICAgICAgICAgICAgc3R5bGUuZGVmaW5lc1snVEFOR1JBTV9NQVRFUklBTF9OT1JNQUxfVEVYVFVSRSddID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0eWxlLmRlZmluZXNbJ1RBTkdSQU1fTUFURVJJQUxfTk9STUFMX1RFWFRVUkVfJyArIHRoaXMubm9ybWFsLm1hcHBpbmcudG9VcHBlckNhc2UoKV0gPSB0cnVlO1xuICAgICAgICAgICAgc3R5bGUuZGVmaW5lc1tgVEFOR1JBTV9NQVRFUklBTF9URVhUVVJFXyR7dGhpcy5ub3JtYWwubWFwcGluZy50b1VwcGVyQ2FzZSgpfWBdID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0eWxlLnRleGNvb3JkcyA9IHN0eWxlLnRleGNvb3JkcyB8fCAodGhpcy5ub3JtYWwubWFwcGluZyA9PT0gJ3V2Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZS5yZXBsYWNlU2hhZGVyQmxvY2soTWF0ZXJpYWwuYmxvY2ssIHNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvbWF0ZXJpYWwnXSk7XG4gICAgfVxuXG4gICAgc2V0dXBQcm9ncmFtIChfcHJvZ3JhbSkge1xuICAgICAgICAvLyBGb3IgZWFjaCBwcm9wZXJ0eSwgc2V0cyB1bmlmb3JtcyBpbiB0aGUgcGF0dGVybjpcbiAgICAgICAgLy8gdV9tYXRlcmlhbC5kaWZmdXNlLCB1X21hdGVyaWFsLmRpZmZ1c2VTY2FsZSB1X21hdGVyaWFsX2RpZmZ1c2VfdGV4dHVyZVxuICAgICAgICBmb3IgKGxldCBwcm9wIG9mIFsnZW1pc3Npb24nLCAnYW1iaWVudCcsICdkaWZmdXNlJywgJ3NwZWN1bGFyJ10pIHtcbiAgICAgICAgICAgIGlmICh0aGlzW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbcHJvcF0udGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBfcHJvZ3JhbS5zZXRUZXh0dXJlVW5pZm9ybShgdV9tYXRlcmlhbF8ke3Byb3B9X3RleHR1cmVgLCB0aGlzW3Byb3BdLnRleHR1cmUpO1xuICAgICAgICAgICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCczZnYnLCBgdV9tYXRlcmlhbC4ke3Byb3B9U2NhbGVgLCB0aGlzW3Byb3BdLnNjYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnNGZ2JywgYHVfbWF0ZXJpYWwuJHtwcm9wfWAsIHRoaXNbcHJvcF0uYW1vdW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXNbcHJvcF0uYW1vdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzRmdicsIGB1X21hdGVyaWFsLiR7cHJvcH1gLCB0aGlzW3Byb3BdLmFtb3VudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXh0cmEgc3BlY3VsYXIgcHJvcHNcbiAgICAgICAgaWYgKHRoaXMuc3BlY3VsYXIpIHtcbiAgICAgICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzFmJywgJ3VfbWF0ZXJpYWwuc2hpbmluZXNzJywgdGhpcy5zcGVjdWxhci5zaGluaW5lc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm9ybWFsIG1hcHBpbmdcbiAgICAgICAgaWYgKHRoaXMubm9ybWFsICYmIHRoaXMubm9ybWFsLnRleHR1cmUpIHtcbiAgICAgICAgICAgIF9wcm9ncmFtLnNldFRleHR1cmVVbmlmb3JtKCd1X21hdGVyaWFsX25vcm1hbF90ZXh0dXJlJywgdGhpcy5ub3JtYWwudGV4dHVyZSk7XG4gICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCczZnYnLCAndV9tYXRlcmlhbC5ub3JtYWxTY2FsZScsIHRoaXMubm9ybWFsLnNjYWxlKTtcbiAgICAgICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzFmJywgJ3VfbWF0ZXJpYWwubm9ybWFsQW1vdW50JywgdGhpcy5ub3JtYWwuYW1vdW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuTWF0ZXJpYWwuYmxvY2sgPSAnbWF0ZXJpYWwnO1xuIiwiLypqc2hpbnQgd29ya2VyOiB0cnVlKi9cblxuLy8gTW9kdWxlcyBhbmQgZGVwZW5kZW5jaWVzIHRvIGV4cG9zZSBpbiB0aGUgcHVibGljIFRhbmdyYW0gbW9kdWxlXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscy91dGlscyc7XG5cbi8vIFRoZSBsZWFmbGV0IGxheWVyIHBsdWdpbiBpcyBjdXJyZW50bHkgdGhlIHByaW1hcnkgcHVibGljIEFQSVxuaW1wb3J0IHtMZWFmbGV0TGF5ZXIsIGxlYWZsZXRMYXllcn0gZnJvbSAnLi9sZWFmbGV0X2xheWVyJztcblxuLy8gVGhlIHNjZW5lIHdvcmtlciBpcyBvbmx5IGFjdGl2YXRlZCB3aGVuIGEgd29ya2VyIHRocmVhZCBpcyBpbnN0YW50aWF0ZWQsIGJ1dCBtdXN0IGFsd2F5cyBiZSBsb2FkZWRcbmltcG9ydCB7U2NlbmVXb3JrZXJ9IGZyb20gJy4uL3NyYy9zY2VuZV93b3JrZXInO1xuXG4vLyBBZGRpdGlvbmFsIG1vZHVsZXMgYXJlIGV4cG9zZWQgZm9yIGRlYnVnZ2luZ1xuaW1wb3J0IHZlcnNpb24gZnJvbSAnLi91dGlscy92ZXJzaW9uJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IEdlbyBmcm9tICcuL2dlbyc7XG5pbXBvcnQgRGF0YVNvdXJjZSBmcm9tICcuL3NvdXJjZXMvZGF0YV9zb3VyY2UnO1xuaW1wb3J0ICcuL3NvdXJjZXMvZ2VvanNvbic7XG5pbXBvcnQgJy4vc291cmNlcy90b3BvanNvbic7XG5pbXBvcnQgJy4vc291cmNlcy9tdnQnO1xuaW1wb3J0IFRpbGVNYW5hZ2VyIGZyb20gJy4vdGlsZV9tYW5hZ2VyJztcbmltcG9ydCBHTFNMIGZyb20gJy4vZ2wvZ2xzbCc7XG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tICcuL2dsL3NoYWRlcl9wcm9ncmFtJztcbmltcG9ydCBWZXJ0ZXhEYXRhIGZyb20gJy4vZ2wvdmVydGV4X2RhdGEnO1xuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi9nbC90ZXh0dXJlJztcbmltcG9ydCBNYXRlcmlhbCBmcm9tICcuL21hdGVyaWFsJztcbmltcG9ydCBMaWdodCBmcm9tICcuL2xpZ2h0JztcbmltcG9ydCBXb3JrZXJCcm9rZXIgZnJvbSAnLi91dGlscy93b3JrZXJfYnJva2VyJztcbmltcG9ydCB7cnVsZUNhY2hlfSBmcm9tICcuL3N0eWxlcy9ydWxlJztcbmltcG9ydCB7U3R5bGVNYW5hZ2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9tYW5hZ2VyJztcbmltcG9ydCB7U3R5bGVQYXJzZXJ9IGZyb20gJy4vc3R5bGVzL3N0eWxlX3BhcnNlcic7XG5pbXBvcnQgRmVhdHVyZVNlbGVjdGlvbiBmcm9tICcuL3NlbGVjdGlvbic7XG5cbmltcG9ydCBnbE1hdHJpeCBmcm9tICdnbC1tYXRyaXgnO1xuXG4vLyBEZWZhdWx0IHRvIDY0LWJpdCBiZWNhdXNlIHdlIG5lZWQgdGhlIGV4dHJhIHByZWNpc2lvbiB3aGVuIG11bHRpcGx5aW5nIG1hdHJpY2VzIHcvbWVyY2F0b3IgcHJvamVjdGVkIHZhbHVlc1xuZ2xNYXRyaXguZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlKEZsb2F0NjRBcnJheSk7XG5cbi8vIE1ha2Ugc29tZSBtb2R1bGVzIGFjY2Vzc2libGUgZm9yIGRlYnVnZ2luZ1xudmFyIGRlYnVnID0ge1xuICAgIGxvZyxcbiAgICBVdGlscyxcbiAgICBHZW8sXG4gICAgRGF0YVNvdXJjZSxcbiAgICBUaWxlTWFuYWdlcixcbiAgICBHTFNMLFxuICAgIFNoYWRlclByb2dyYW0sXG4gICAgVmVydGV4RGF0YSxcbiAgICBUZXh0dXJlLFxuICAgIE1hdGVyaWFsLFxuICAgIExpZ2h0LFxuICAgIFNjZW5lV29ya2VyLFxuICAgIFdvcmtlckJyb2tlcixcbiAgICBydWxlQ2FjaGUsXG4gICAgU3R5bGVNYW5hZ2VyLFxuICAgIFN0eWxlUGFyc2VyLFxuICAgIEZlYXR1cmVTZWxlY3Rpb25cbn07XG5cbi8vIFdpbmRvdyBjYW4gb25seSBiZSBzZXQgaW4gbWFpbiB0aHJlYWRcbmlmIChVdGlscy5pc01haW5UaHJlYWQpIHtcbiAgICAvLyBNYWluIHRocmVhZCBvYmplY3RzIHRoYXQgY2FuIGJlIGNhbGxlZCBmcm9tIHdvcmtlcnNcbiAgICBXb3JrZXJCcm9rZXIuYWRkVGFyZ2V0KCdUZXh0dXJlJywgVGV4dHVyZSk7XG5cbiAgICB3aW5kb3cuVGFuZ3JhbSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBMZWFmbGV0TGF5ZXIsXG4gICAgICAgIGxlYWZsZXRMYXllcixcbiAgICAgICAgZGVidWcsXG4gICAgICAgIHZlcnNpb246IHZlcnNpb24uc3RyaW5nXG4gICAgfTtcblxufVxuXG5pZiAoVXRpbHMuaXNXb3JrZXJUaHJlYWQpIHtcbiAgICBzZWxmLlRhbmdyYW0gPSB7XG4gICAgICAgIGRlYnVnLFxuICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uLnN0cmluZ1xuICAgIH07XG59XG5cbmlmIChVdGlscy5pc01haW5UaHJlYWQpIHtcbiAgICBVdGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVQb2x5ZmlsbCgpO1xufVxuXG4vLyBTZXR1cCBsb2dnaW5nIHRvIHByZWZpeCB3aXRoIFRhbmdyYW0gdmVyc2lvblxudmFyIG9yaWdpbmFsRmFjdG9yeSA9IGxvZy5tZXRob2RGYWN0b3J5O1xubG9nLm1ldGhvZEZhY3RvcnkgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgbG9nTGV2ZWwpIHtcbiAgICB2YXIgcmF3TWV0aG9kID0gb3JpZ2luYWxGYWN0b3J5KG1ldGhvZE5hbWUsIGxvZ0xldmVsKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLm1lc3NhZ2UpIHtcbiAgICAgICAgcmF3TWV0aG9kKGBUYW5ncmFtICR7dmVyc2lvbi5zdHJpbmd9OmAsIC4uLm1lc3NhZ2UpO1xuICAgIH07XG59O1xuIiwiLypnbG9iYWwgU2NlbmUgKi9cbmltcG9ydCBHZW8gZnJvbSAnLi9nZW8nO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IFdvcmtlckJyb2tlciBmcm9tICcuL3V0aWxzL3dvcmtlcl9icm9rZXInO1xuaW1wb3J0IHN1YnNjcmliZU1peGluIGZyb20gJy4vdXRpbHMvc3Vic2NyaWJlJztcbmltcG9ydCBDb250ZXh0IGZyb20gJy4vZ2wvY29udGV4dCc7XG5pbXBvcnQgVGV4dHVyZSBmcm9tICcuL2dsL3RleHR1cmUnO1xuaW1wb3J0IFZlcnRleEFycmF5T2JqZWN0IGZyb20gJy4vZ2wvdmFvJztcbmltcG9ydCB7U3R5bGVNYW5hZ2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9tYW5hZ2VyJztcbmltcG9ydCB7U3R5bGVQYXJzZXJ9IGZyb20gJy4vc3R5bGVzL3N0eWxlX3BhcnNlcic7XG5pbXBvcnQgQ2FtZXJhIGZyb20gJy4vY2FtZXJhJztcbmltcG9ydCBMaWdodCBmcm9tICcuL2xpZ2h0JztcbmltcG9ydCBUaWxlTWFuYWdlciBmcm9tICcuL3RpbGVfbWFuYWdlcic7XG5pbXBvcnQgRGF0YVNvdXJjZSBmcm9tICcuL3NvdXJjZXMvZGF0YV9zb3VyY2UnO1xuaW1wb3J0IEZlYXR1cmVTZWxlY3Rpb24gZnJvbSAnLi9zZWxlY3Rpb24nO1xuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4vZ2wvcmVuZGVyX3N0YXRlJztcblxuaW1wb3J0IHtQb2x5Z29uc30gZnJvbSAnLi9zdHlsZXMvcG9seWdvbnMvcG9seWdvbnMnO1xuaW1wb3J0IHtMaW5lc30gZnJvbSAnLi9zdHlsZXMvbGluZXMvbGluZXMnO1xuaW1wb3J0IHtQb2ludHN9IGZyb20gJy4vc3R5bGVzL3BvaW50cy9wb2ludHMnO1xuaW1wb3J0IHtUZXh0U3R5bGV9IGZyb20gJy4vc3R5bGVzL3RleHQvdGV4dCc7XG5cbi8vIEFkZCBidWlsdC1pbiByZW5kZXJpbmcgc3R5bGVzXG5TdHlsZU1hbmFnZXIucmVnaXN0ZXIoUG9seWdvbnMpO1xuU3R5bGVNYW5hZ2VyLnJlZ2lzdGVyKExpbmVzKTtcblN0eWxlTWFuYWdlci5yZWdpc3RlcihQb2ludHMpO1xuU3R5bGVNYW5hZ2VyLnJlZ2lzdGVyKFRleHRTdHlsZSk7XG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IGdsTWF0cml4IGZyb20gJ2dsLW1hdHJpeCc7XG5sZXQgbWF0NCA9IGdsTWF0cml4Lm1hdDQ7XG5sZXQgbWF0MyA9IGdsTWF0cml4Lm1hdDM7XG5sZXQgdmVjMyA9IGdsTWF0cml4LnZlYzM7XG5cbi8vIExvYWQgc2NlbmUgZGVmaW5pdGlvbjogcGFzcyBhbiBvYmplY3QgZGlyZWN0bHksIG9yIGEgVVJMIGFzIHN0cmluZyB0byBsb2FkIHJlbW90ZWx5XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWdfc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBzdWJzY3JpYmVNaXhpbih0aGlzKTtcblxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc291cmNlcyA9IHt9O1xuXG4gICAgICAgIHRoaXMudGlsZV9tYW5hZ2VyID0gVGlsZU1hbmFnZXI7XG4gICAgICAgIHRoaXMudGlsZV9tYW5hZ2VyLmluaXQodGhpcyk7XG4gICAgICAgIHRoaXMubnVtX3dvcmtlcnMgPSBvcHRpb25zLm51bVdvcmtlcnMgfHwgMjtcbiAgICAgICAgdGhpcy5jb250aW51b3VzX3pvb20gPSAodHlwZW9mIG9wdGlvbnMuY29udGludW91c1pvb20gPT09ICdib29sZWFuJykgPyBvcHRpb25zLmNvbnRpbnVvdXNab29tIDogdHJ1ZTtcbiAgICAgICAgdGhpcy50aWxlX3NpbXBsaWZpY2F0aW9uX2xldmVsID0gMDsgLy8gbGV2ZWwtb2YtZGV0YWlsIGRvd25zYW1wbGluZyB0byBhcHBseSB0byB0aWxlIGxvYWRpbmdcbiAgICAgICAgdGhpcy5hbGxvd19jcm9zc19kb21haW5fd29ya2VycyA9IChvcHRpb25zLmFsbG93Q3Jvc3NEb21haW5Xb3JrZXJzID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZSk7XG4gICAgICAgIHRoaXMud29ya2VyX3VybCA9IG9wdGlvbnMud29ya2VyVXJsO1xuICAgICAgICBpZiAob3B0aW9ucy5kaXNhYmxlVmVydGV4QXJyYXlPYmplY3RzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBWZXJ0ZXhBcnJheU9iamVjdC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBVdGlscy51c2VfaGlnaF9kZW5zaXR5X2Rpc3BsYXkgPSBvcHRpb25zLmhpZ2hEZW5zaXR5RGlzcGxheSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5oaWdoRGVuc2l0eURpc3BsYXkgOiB0cnVlO1xuICAgICAgICBVdGlscy51cGRhdGVEZXZpY2VQaXhlbFJhdGlvKCk7XG5cbiAgICAgICAgdGhpcy5jb25maWcgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbmZpZ19zb3VyY2UgPSBjb25maWdfc291cmNlO1xuICAgICAgICB0aGlzLmNvbmZpZ19zZXJpYWxpemVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0X3ZhbGlkX2NvbmZpZ19zb3VyY2UgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuc3R5bGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3RpdmVfc3R5bGVzID0ge307XG5cbiAgICAgICAgdGhpcy5idWlsZGluZyA9IG51bGw7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJhY2tzIGN1cnJlbnQgc2NlbmUgYnVpbGRpbmcgc3RhdGUgKHRpbGVzIGJlaW5nIGJ1aWx0LCBldGMuKVxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IGEgcmVkcmF3XG4gICAgICAgIHRoaXMuYW5pbWF0ZWQgPSBmYWxzZTsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QgcmVkcmF3IGV2ZXJ5IGZyYW1lXG4gICAgICAgIHRoaXMucHJlVXBkYXRlID0gb3B0aW9ucy5wcmVVcGRhdGU7ICAgICAgICAgICAgIC8vIG9wdGlvbmFsIHByZS1yZW5kZXIgbG9vcCBob29rXG4gICAgICAgIHRoaXMucG9zdFVwZGF0ZSA9IG9wdGlvbnMucG9zdFVwZGF0ZTsgICAgICAgICAgIC8vIG9wdGlvbmFsIHBvc3QtcmVuZGVyIGxvb3AgaG9va1xuICAgICAgICB0aGlzLnJlbmRlcl9sb29wID0gIW9wdGlvbnMuZGlzYWJsZVJlbmRlckxvb3A7ICAvLyBkaXNhYmxlIHJlbmRlciBsb29wIC0gYXBwIHdpbGwgaGF2ZSB0byBtYW51YWxseSBjYWxsIFNjZW5lLnJlbmRlcigpIHBlciBmcmFtZVxuICAgICAgICB0aGlzLnJlbmRlcl9sb29wX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbmRlcl9sb29wX3N0b3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mcmFtZSA9IDA7XG4gICAgICAgIHRoaXMucmVzZXRUaW1lKCk7XG5cbiAgICAgICAgdGhpcy56b29tID0gbnVsbDtcbiAgICAgICAgdGhpcy5jZW50ZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByZXNlcnZlX3RpbGVzX3dpdGhpbl96b29tID0gMTtcbiAgICAgICAgdGhpcy5wYW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG5cbiAgICAgICAgdGhpcy5jYW1lcmEgPSBudWxsO1xuICAgICAgICB0aGlzLmxpZ2h0cyA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IG51bGw7XG5cbiAgICAgICAgLy8gTW9kZWwtdmlldyBtYXRyaWNlc1xuICAgICAgICAvLyA2NC1iaXQgdmVyc2lvbnMgYXJlIGZvciBDUFUgY2FsY3VhdGlvbnNcbiAgICAgICAgLy8gMzItYml0IHZlcnNpb25zIGFyZSBkb3duc2FtcGxlZCBhbmQgc2VudCB0byBHUFVcbiAgICAgICAgdGhpcy5tb2RlbE1hdHJpeCA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICAgICAgICB0aGlzLm1vZGVsTWF0cml4MzIgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICAgICAgdGhpcy5tb2RlbFZpZXdNYXRyaXggPSBuZXcgRmxvYXQ2NEFycmF5KDE2KTtcbiAgICAgICAgdGhpcy5tb2RlbFZpZXdNYXRyaXgzMiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICAgICAgICB0aGlzLm5vcm1hbE1hdHJpeCA9IG5ldyBGbG9hdDY0QXJyYXkoOSk7XG4gICAgICAgIHRoaXMubm9ybWFsTWF0cml4MzIgPSBuZXcgRmxvYXQzMkFycmF5KDkpO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZXh0dXJlX2xpc3RlbmVyID0gbnVsbDtcblxuICAgICAgICAvLyBEZWJ1ZyBjb25maWdcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IHtcbiAgICAgICAgICAgIHByb2ZpbGU6IHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeV9idWlsZDogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnVwZGF0aW5nID0gMDtcbiAgICAgICAgdGhpcy5nZW5lcmF0aW9uID0gMDsgLy8gYW4gaWQgdGhhdCBpcyBpbmNyZW1lbnRlZCBlYWNoIHRpbWUgdGhlIHNjZW5lIGNvbmZpZyBpcyBpbnZhbGlkYXRlZFxuXG4gICAgICAgIHRoaXMubG9nTGV2ZWwgPSBvcHRpb25zLmxvZ0xldmVsIHx8ICd3YXJuJztcbiAgICAgICAgbG9nLnNldExldmVsKHRoaXMubG9nTGV2ZWwpO1xuICAgIH1cblxuICAgIC8vIExvYWQgKG9yIHJlbG9hZCkgc2NlbmUgY29uZmlnXG4gICAgLy8gT3B0aW9uYWxseSBzcGVjaWZ5IG5ldyBzY2VuZSBmaWxlIFVSTFxuICAgIGxvYWQoY29uZmlnX3NvdXJjZSA9IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0aW5nKys7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXppbmcgPSB0cnVlO1xuXG4gICAgICAgIC8vIExvYWQgc2NlbmUgZGVmaW5pdGlvbiAoc291cmNlcywgc3R5bGVzLCBldGMuKSwgdGhlbiBjcmVhdGUgc3R5bGVzICYgd29ya2Vyc1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkU2NlbmUoY29uZmlnX3NvdXJjZSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuY3JlYXRlV29ya2VycygpKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlQ2FudmFzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldEZlYXR1cmVTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy50ZXh0dXJlX2xpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZV9saXN0ZW5lciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogKCkgPT4gdGhpcy5kaXJ0eSA9IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nOiAoZGF0YSkgPT4gdGhpcy50cmlnZ2VyKCd3YXJuaW5nJywgT2JqZWN0LmFzc2lnbih7IHR5cGU6ICd0ZXh0dXJlcycgfSwgZGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIFRleHR1cmUuc3Vic2NyaWJlKHRoaXMudGV4dHVyZV9saXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRpbGVzIGJlZm9yZSByZWJ1aWxkaW5nXG4gICAgICAgICAgICAgICAgdGhpcy50aWxlX21hbmFnZXIucmVtb3ZlVGlsZXModGlsZSA9PiAhdGlsZS52aXNpYmxlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVDb25maWcoeyByZWJ1aWxkOiB0cnVlIH0pO1xuICAgICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGluZy0tO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0X3ZhbGlkX2NvbmZpZ19zb3VyY2UgPSB0aGlzLmNvbmZpZ19zb3VyY2U7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJfbG9vcCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR1cFJlbmRlckxvb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnVwZGF0aW5nID0gMDtcblxuICAgICAgICAgICAgLy8gUmVwb3J0IGFuZCByZXZlcnQgdG8gbGFzdCB2YWxpZCBjb25maWcgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBsZXQgdHlwZSwgbWVzc2FnZTtcbiAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnWUFNTEV4Y2VwdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ3lhbWwnO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSAnRXJyb3IgcGFyc2luZyBzY2VuZSBZQU1MJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IG1vcmUgZXJyb3IgdHlwZXNcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gJ0Vycm9yIGluaXRpYWxpemluZyBzY2VuZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJywgeyB0eXBlLCBtZXNzYWdlLCBlcnJvciwgdXJsOiB0aGlzLmNvbmZpZ19zb3VyY2UgfSk7XG5cbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgU2NlbmUubG9hZCgpIGZhaWxlZCB0byBsb2FkICR7dGhpcy5jb25maWdfc291cmNlfTogJHtlcnJvci5tZXNzYWdlfWA7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0X3ZhbGlkX2NvbmZpZ19zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBsb2cud2FybihtZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgbG9nLmluZm8oYFNjZW5lLmxvYWQoKSByZXZlcnRpbmcgdG8gbGFzdCB2YWxpZCBjb25maWd1cmF0aW9uYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZCh0aGlzLmxhc3RfdmFsaWRfY29uZmlnX3NvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2cuZXJyb3IobWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEZvciBBUEkgY29tcGF0aWJpbGl0eVxuICAgIHJlbG9hZChjb25maWdfc291cmNlID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkKGNvbmZpZ19zb3VyY2UpO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW5kZXJfbG9vcF9zdG9wID0gdHJ1ZTsgLy8gc2NoZWR1bGUgcmVuZGVyIGxvb3AgdG8gc3RvcFxuXG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVBbGwoKTsgLy8gY2xlYXIgYWxsIGV2ZW50IGxpc3RlbmVyc1xuXG4gICAgICAgIFRleHR1cmUudW5zdWJzY3JpYmUodGhpcy50ZXh0dXJlX2xpc3RlbmVyKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlX2xpc3RlbmVyID0gbnVsbDtcblxuICAgICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZ2wpIHtcbiAgICAgICAgICAgIFRleHR1cmUuZGVzdHJveSh0aGlzLmdsKTtcbiAgICAgICAgICAgIFN0eWxlTWFuYWdlci5kZXN0cm95KHRoaXMuZ2wpO1xuICAgICAgICAgICAgdGhpcy5zdHlsZXMgPSB7fTtcblxuICAgICAgICAgICAgdGhpcy5nbCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNvdXJjZXMgPSB7fTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLndvcmtlcnMpKSB7XG4gICAgICAgICAgICB0aGlzLndvcmtlcnMuZm9yRWFjaCgod29ya2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLndvcmtlcnMgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50aWxlX21hbmFnZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIGNyZWF0ZUNhbnZhcygpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUudG9wID0gMDtcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUubGVmdCA9IDA7XG5cbiAgICAgICAgLy8gRm9yY2UgdGFuZ3JhbSBjYW52YXMgdW5kZXJuZWF0aCBhbGwgbGVhZmxldCBsYXllcnMsIGFuZCBzZXQgYmFja2dyb3VuZCB0byB0cmFuc3BhcmVudFxuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS56SW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7JztcbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmdsID0gQ29udGV4dC5nZXRDb250ZXh0KHRoaXMuY2FudmFzLCB7XG4gICAgICAgICAgICAgICAgYWxwaGE6IGZhbHNlIC8qcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSovLFxuICAgICAgICAgICAgICAgIGRldmljZV9waXhlbF9yYXRpbzogVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDb3VsZG4ndCBjcmVhdGUgV2ViR0wgY29udGV4dC4gXCIgK1xuICAgICAgICAgICAgICAgIFwiWW91ciBicm93c2VyIG1heSBub3Qgc3VwcG9ydCBXZWJHTCwgb3IgaXQncyB0dXJuZWQgb2ZmPyBcIiArXG4gICAgICAgICAgICAgICAgXCJWaXNpdCBodHRwOi8vd2ViZ2xyZXBvcnQuY29tLyBmb3IgbW9yZSBpbmZvLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXNpemVNYXAodGhpcy5jb250YWluZXIuY2xpZW50V2lkdGgsIHRoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodCk7XG4gICAgICAgIFZlcnRleEFycmF5T2JqZWN0LmluaXQodGhpcy5nbCk7XG4gICAgICAgIFJlbmRlclN0YXRlLmluaXRpYWxpemUodGhpcy5nbCk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBVUkwgdG8gbG9hZCB0aGUgd2ViIHdvcmtlciBmcm9tXG4gICAgZ2V0V29ya2VyVXJsKCkge1xuICAgICAgICBsZXQgd29ya2VyX3VybCA9IHRoaXMud29ya2VyX3VybCB8fCBVdGlscy5maW5kQ3VycmVudFVSTCgndGFuZ3JhbS5kZWJ1Zy5qcycsICd0YW5ncmFtLm1pbi5qcycpO1xuXG4gICAgICAgIGlmICghd29ya2VyX3VybCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgbG9hZCB3b3JrZXIgYmVjYXVzZSBjb3VsZG4ndCBmaW5kIGJhc2UgVVJMIHRoYXQgbGlicmFyeSB3YXMgbG9hZGVkIGZyb21cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hbGxvd19jcm9zc19kb21haW5fd29ya2Vycykge1xuICAgICAgICAgICAgbGV0IGJvZHkgPSBgaW1wb3J0U2NyaXB0cygnJHt3b3JrZXJfdXJsfScpO2A7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtib2R5XSwgeyB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JrZXJfdXJsO1xuICAgIH1cblxuICAgIC8vIFdlYiB3b3JrZXJzIGhhbmRsZSBoZWF2eSBkdXR5IHRpbGUgY29uc3RydWN0aW9uOiBuZXR3b3JraW5nLCBnZW9tZXRyeSBwcm9jZXNzaW5nLCBldGMuXG4gICAgY3JlYXRlV29ya2VycygpIHtcbiAgICAgICAgaWYgKCF0aGlzLndvcmtlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VXb3JrZXJzKHRoaXMuZ2V0V29ya2VyVXJsKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICAvLyBJbnN0YW50aWF0ZSB3b3JrZXJzIGZyb20gVVJMLCBpbml0IGV2ZW50IGhhbmRsZXJzXG4gICAgbWFrZVdvcmtlcnModXJsKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuXG4gICAgICAgIHRoaXMud29ya2VycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpZD0wOyBpZCA8IHRoaXMubnVtX3dvcmtlcnM7IGlkKyspIHtcbiAgICAgICAgICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKHVybCk7XG4gICAgICAgICAgICB0aGlzLndvcmtlcnNbaWRdID0gd29ya2VyO1xuXG4gICAgICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMud29ya2VyTG9nTWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIFdvcmtlckJyb2tlci5hZGRXb3JrZXIod29ya2VyKTtcblxuICAgICAgICAgICAgbG9nLmRlYnVnKGBTY2VuZS5tYWtlV29ya2VyczogaW5pdGlhbGl6aW5nIHdvcmtlciAke2lkfWApO1xuICAgICAgICAgICAgbGV0IF9pZCA9IGlkO1xuICAgICAgICAgICAgcXVldWUucHVzaChXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2Uod29ya2VyLCAnaW5pdCcsIGlkLCB0aGlzLm51bV93b3JrZXJzLCBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW8pLnRoZW4oXG4gICAgICAgICAgICAgICAgKGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhgU2NlbmUubWFrZVdvcmtlcnM6IGluaXRpYWxpemVkIHdvcmtlciAke2lkfWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLmVycm9yKGBTY2VuZS5tYWtlV29ya2VyczogZmFpbGVkIHRvIGluaXRpYWxpemUgd29ya2VyICR7X2lkfTpgLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5leHRfd29ya2VyID0gMDtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHF1ZXVlKTtcbiAgICB9XG5cbiAgICAvLyBSb3VuZCByb2JpbiBzZWxlY3Rpb24gb2YgbmV4dCB3b3JrZXJcbiAgICBuZXh0V29ya2VyKCkge1xuICAgICAgICB2YXIgd29ya2VyID0gdGhpcy53b3JrZXJzW3RoaXMubmV4dF93b3JrZXJdO1xuICAgICAgICB0aGlzLm5leHRfd29ya2VyID0gKHRoaXMubmV4dF93b3JrZXIgKyAxKSAlIHRoaXMud29ya2Vycy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB3b3JrZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgIFNldCB0aGUgbWFwIHZpZXcsIGNhbiBiZSBwYXNzZWQgYW4gb2JqZWN0IHdpdGggbGF0L2xuZyBhbmQvb3Igem9vbVxuICAgICovXG4gICAgc2V0Vmlldyh7IGxuZywgbGF0LCB6b29tIH0gPSB7fSkge1xuICAgICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFNldCBjZW50ZXJcbiAgICAgICAgaWYgKHR5cGVvZiBsbmcgPT09ICdudW1iZXInICYmIHR5cGVvZiBsYXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2VudGVyIHx8IGxuZyAhPT0gdGhpcy5jZW50ZXIubG5nIHx8IGxhdCAhPT0gdGhpcy5jZW50ZXIubGF0KSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jZW50ZXIgPSB7IGxuZzogR2VvLndyYXBMbmcobG5nKSwgbGF0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgem9vbVxuICAgICAgICBpZiAodHlwZW9mIHpvb20gPT09ICdudW1iZXInICYmIHpvb20gIT09IHRoaXMuem9vbSkge1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNldFpvb20oem9vbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCb3VuZHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG5cbiAgICBzdGFydFpvb20oKSB7XG4gICAgICAgIHRoaXMubGFzdF96b29tID0gdGhpcy56b29tO1xuICAgICAgICB0aGlzLnpvb21pbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIENob29zZSB0aGUgYmFzZSB6b29tIGxldmVsIHRvIHVzZSBmb3IgYSBnaXZlbiBmcmFjdGlvbmFsIHpvb21cbiAgICBiYXNlWm9vbSh6b29tKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHpvb20pO1xuICAgIH1cblxuICAgIC8vIEZvciBhIGdpdmVuIHZpZXcgem9vbSwgd2hhdCB0aWxlIHpvb20gc2hvdWxkIGJlIGxvYWRlZD9cbiAgICB0aWxlWm9vbSh2aWV3X3pvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVpvb20odmlld196b29tKSAtIHRoaXMudGlsZV9zaW1wbGlmaWNhdGlvbl9sZXZlbDtcbiAgICB9XG5cbiAgICAvLyBGb3IgYSBnaXZlbiB0aWxlIHpvb20sIHdoYXQgc3R5bGUgem9vbSBzaG91bGQgYmUgdXNlZD9cbiAgICBzdHlsZVpvb20odGlsZV96b29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2Vab29tKHRpbGVfem9vbSkgKyB0aGlzLnRpbGVfc2ltcGxpZmljYXRpb25fbGV2ZWw7XG4gICAgfVxuXG4gICAgc2V0Wm9vbSh6b29tKSB7XG4gICAgICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xuICAgICAgICBsZXQgdGlsZV96b29tID0gdGhpcy50aWxlWm9vbSh6b29tKTtcblxuICAgICAgICBpZiAoIXRoaXMuY29udGludW91c196b29tKSB7XG4gICAgICAgICAgICB6b29tID0gdGlsZV96b29tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRpbGVfem9vbSAhPT0gdGhpcy50aWxlWm9vbSh0aGlzLmxhc3Rfem9vbSkpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aWxlcyBvdXRzaWRlIGN1cnJlbnQgem9vbSB0aGF0IGFyZSBzdGlsbCBsb2FkaW5nXG4gICAgICAgICAgICB0aGlzLnRpbGVfbWFuYWdlci5yZW1vdmVUaWxlcyh0aWxlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGlsZS5sb2FkaW5nICYmIHRoaXMudGlsZVpvb20odGlsZS5jb29yZHMueikgIT09IHRpbGVfem9vbSkge1xuICAgICAgICAgICAgICAgICAgICBsb2cudHJhY2UoYHJlbW92ZWQgJHt0aWxlLmtleX0gKHdhcyBsb2FkaW5nLCBidXQgb3V0c2lkZSBjdXJyZW50IHpvb20pYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0X3pvb20gPSB0aGlzLnpvb207XG4gICAgICAgIHRoaXMuem9vbSA9IHpvb207XG4gICAgICAgIHRoaXMudGlsZV96b29tID0gdGlsZV96b29tO1xuXG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRzKCk7XG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmlld1JlYWR5KCkge1xuICAgICAgICBpZiAodGhpcy5jc3Nfc2l6ZSA9PSBudWxsIHx8IHRoaXMuY2VudGVyID09IG51bGwgfHwgdGhpcy56b29tID09IG51bGwgfHwgT2JqZWN0LmtleXModGhpcy5zb3VyY2VzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHZpZXdwb3J0IGJvdW5kcyBiYXNlZCBvbiBjdXJyZW50IGNlbnRlciBhbmQgem9vbVxuICAgIHVwZGF0ZUJvdW5kcygpIHtcbiAgICAgICAgLy8gVE9ETzogYmV0dGVyIGNvbmNlcHQgb2YgXCJyZWFkaW5lc3NcIiBzdGF0ZT9cbiAgICAgICAgaWYgKCF0aGlzLnZpZXdSZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1ldGVyc19wZXJfcGl4ZWwgPSBHZW8ubWV0ZXJzUGVyUGl4ZWwodGhpcy56b29tKTtcblxuICAgICAgICAvLyBTaXplIG9mIHRoZSBoYWxmLXZpZXdwb3J0IGluIG1ldGVycyBhdCBjdXJyZW50IHpvb21cbiAgICAgICAgdGhpcy52aWV3cG9ydF9tZXRlcnMgPSB7XG4gICAgICAgICAgICB4OiB0aGlzLmNzc19zaXplLndpZHRoICogdGhpcy5tZXRlcnNfcGVyX3BpeGVsLFxuICAgICAgICAgICAgeTogdGhpcy5jc3Nfc2l6ZS5oZWlnaHQgKiB0aGlzLm1ldGVyc19wZXJfcGl4ZWxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDZW50ZXIgb2Ygdmlld3BvcnQgaW4gbWV0ZXJzLCBhbmQgdGlsZVxuICAgICAgICBsZXQgW3gsIHldID0gR2VvLmxhdExuZ1RvTWV0ZXJzKFt0aGlzLmNlbnRlci5sbmcsIHRoaXMuY2VudGVyLmxhdF0pO1xuICAgICAgICB0aGlzLmNlbnRlcl9tZXRlcnMgPSB7IHgsIHkgfTtcblxuICAgICAgICBsZXQgeiA9IHRoaXMudGlsZVpvb20odGhpcy56b29tKTtcbiAgICAgICAgdGhpcy5jZW50ZXJfdGlsZSA9IEdlby50aWxlRm9yTWV0ZXJzKFt0aGlzLmNlbnRlcl9tZXRlcnMueCwgdGhpcy5jZW50ZXJfbWV0ZXJzLnldLCB6KTtcblxuICAgICAgICB0aGlzLmJvdW5kc19tZXRlcnMgPSB7XG4gICAgICAgICAgICBzdzoge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMuY2VudGVyX21ldGVycy54IC0gdGhpcy52aWV3cG9ydF9tZXRlcnMueCAvIDIsXG4gICAgICAgICAgICAgICAgeTogdGhpcy5jZW50ZXJfbWV0ZXJzLnkgLSB0aGlzLnZpZXdwb3J0X21ldGVycy55IC8gMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5lOiB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy5jZW50ZXJfbWV0ZXJzLnggKyB0aGlzLnZpZXdwb3J0X21ldGVycy54IC8gMixcbiAgICAgICAgICAgICAgICB5OiB0aGlzLmNlbnRlcl9tZXRlcnMueSArIHRoaXMudmlld3BvcnRfbWV0ZXJzLnkgLyAyXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy50aWxlX21hbmFnZXIudXBkYXRlVGlsZXNGb3JWaWV3KCk7XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdtb3ZlJyk7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cblxuICAgIGZpbmRWaXNpYmxlVGlsZUNvb3JkaW5hdGVzKHsgYnVmZmVyIH0gPSB7fSkge1xuICAgICAgICBpZiAoIXRoaXMuYm91bmRzX21ldGVycykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHogPSB0aGlzLnRpbGVab29tKHRoaXMuem9vbSk7XG4gICAgICAgIGxldCBzdyA9IEdlby50aWxlRm9yTWV0ZXJzKFt0aGlzLmJvdW5kc19tZXRlcnMuc3cueCwgdGhpcy5ib3VuZHNfbWV0ZXJzLnN3LnldLCB6KTtcbiAgICAgICAgbGV0IG5lID0gR2VvLnRpbGVGb3JNZXRlcnMoW3RoaXMuYm91bmRzX21ldGVycy5uZS54LCB0aGlzLmJvdW5kc19tZXRlcnMubmUueV0sIHopO1xuICAgICAgICBidWZmZXIgPSBidWZmZXIgfHwgMDtcblxuICAgICAgICBsZXQgY29vcmRzID0gW107XG4gICAgICAgIGZvciAobGV0IHggPSBzdy54IC0gYnVmZmVyOyB4IDw9IG5lLnggKyBidWZmZXI7IHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IG5lLnkgLSBidWZmZXI7IHkgPD0gc3cueSArIGJ1ZmZlcjsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY29vcmRzLnB1c2goeyB4LCB5LCB6IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb29yZHM7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHRpbGVzIHRvbyBmYXIgb3V0c2lkZSBvZiB2aWV3XG4gICAgcHJ1bmVUaWxlQ29vcmRpbmF0ZXNGb3JWaWV3KGJvcmRlcl9idWZmZXIgPSAyKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3UmVhZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRpbGVzIHRoYXQgYXJlIGEgc3BlY2lmaWVkICMgb2YgdGlsZXMgb3V0c2lkZSBvZiB0aGUgdmlld3BvcnQgYm9yZGVyXG4gICAgICAgIGxldCBib3JkZXJfdGlsZXMgPSBbXG4gICAgICAgICAgICBNYXRoLmNlaWwoKE1hdGguZmxvb3IodGhpcy5jc3Nfc2l6ZS53aWR0aCAvIEdlby50aWxlX3NpemUpICsgMikgLyAyKSxcbiAgICAgICAgICAgIE1hdGguY2VpbCgoTWF0aC5mbG9vcih0aGlzLmNzc19zaXplLmhlaWdodCAvIEdlby50aWxlX3NpemUpICsgMikgLyAyKVxuICAgICAgICBdO1xuICAgICAgICBsZXQgc3R5bGVfem9vbSA9IHRoaXMudGlsZVpvb20odGhpcy56b29tKTtcblxuICAgICAgICB0aGlzLnRpbGVfbWFuYWdlci5yZW1vdmVUaWxlcyh0aWxlID0+IHtcbiAgICAgICAgICAgIC8vIElnbm9yZSB2aXNpYmxlIHRpbGVzXG4gICAgICAgICAgICBpZiAodGlsZS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEaXNjYXJkIGlmIHRvbyBmYXIgZnJvbSBjdXJyZW50IHpvb21cbiAgICAgICAgICAgIGxldCB6ZGlmZiA9IHRpbGUuY29vcmRzLnogLSBzdHlsZV96b29tO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHpkaWZmKSA+IHRoaXMucHJlc2VydmVfdGlsZXNfd2l0aGluX3pvb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGFuZGxlIHRpbGVzIGF0IGRpZmZlcmVudCB6b29tc1xuICAgICAgICAgICAgbGV0IHp0cmFucyA9IE1hdGgucG93KDIsIHpkaWZmKTtcbiAgICAgICAgICAgIGxldCBjb29yZHMgPSB7XG4gICAgICAgICAgICAgICAgeDogTWF0aC5mbG9vcih0aWxlLmNvb3Jkcy54IC8genRyYW5zKSxcbiAgICAgICAgICAgICAgICB5OiBNYXRoLmZsb29yKHRpbGUuY29vcmRzLnkgLyB6dHJhbnMpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBEaXNjYXJkIHRpbGVzIG91dHNpZGUgYW4gYXJlYSBzdXJyb3VuZGluZyB0aGUgdmlld3BvcnRcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhjb29yZHMueCAtIHRoaXMuY2VudGVyX3RpbGUueCkgLSBib3JkZXJfdGlsZXNbMF0gPiBib3JkZXJfYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgbG9nLnRyYWNlKGBTY2VuZTogcmVtb3ZlIHRpbGUgJHt0aWxlLmtleX0gKGFzICR7Y29vcmRzLnh9LyR7Y29vcmRzLnl9LyR7c3R5bGVfem9vbX0pIGZvciBiZWluZyB0b28gZmFyIG91dCBvZiB2aXNpYmxlIGFyZWEgKioqYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhjb29yZHMueSAtIHRoaXMuY2VudGVyX3RpbGUueSkgLSBib3JkZXJfdGlsZXNbMV0gPiBib3JkZXJfYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgbG9nLnRyYWNlKGBTY2VuZTogcmVtb3ZlIHRpbGUgJHt0aWxlLmtleX0gKGFzICR7Y29vcmRzLnh9LyR7Y29vcmRzLnl9LyR7c3R5bGVfem9vbX0pIGZvciBiZWluZyB0b28gZmFyIG91dCBvZiB2aXNpYmxlIGFyZWEgKioqYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlc2l6ZU1hcCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuY3NzX3NpemUgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcbiAgICAgICAgdGhpcy5kZXZpY2Vfc2l6ZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKHRoaXMuY3NzX3NpemUud2lkdGggKiBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW8pLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKHRoaXMuY3NzX3NpemUuaGVpZ2h0ICogVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnZpZXdfYXNwZWN0ID0gdGhpcy5jc3Nfc2l6ZS53aWR0aCAvIHRoaXMuY3NzX3NpemUuaGVpZ2h0O1xuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kcygpO1xuXG4gICAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSB0aGlzLmNzc19zaXplLndpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9IHRoaXMuY3NzX3NpemUuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5kZXZpY2Vfc2l6ZS53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuZGV2aWNlX3NpemUuaGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5nbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXF1ZXN0IHNjZW5lIGJlIHJlZHJhd24gYXQgbmV4dCBhbmltYXRpb24gbG9vcFxuICAgIHJlcXVlc3RSZWRyYXcoKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFJlZHJhdyBzY2VuZSBpbW1lZGlhdGVseSAtIGRvbid0IHdhaXQgZm9yIGFuaW1hdGlvbiBsb29wXG4gICAgLy8gVXNlIHNwYXJpbmdseSwgYnV0IGZvciBjYXNlcyB3aGVyZSB5b3UgbmVlZCB0aGUgY2xvc2VzdCBwb3NzaWJsZSBzeW5jIHdpdGggb3RoZXIgVUkgZWxlbWVudHMsXG4gICAgLy8gc3VjaCBhcyBvdGhlciwgbm9uLVdlYkdMIG1hcCBsYXllcnMgKGUuZy4gTGVhZmxldCByYXN0ZXIgbGF5ZXJzLCBtYXJrZXJzLCBldGMuKVxuICAgIGltbWVkaWF0ZVJlZHJhdygpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcmVuZGVyTG9vcCAoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyX2xvb3BfYWN0aXZlID0gdHJ1ZTsgLy8gb25seSBsZXQgdGhlIHJlbmRlciBsb29wIGluc3RhbnRpYXRlIG9uY2VcblxuICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSBzY2VuZVxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlcXVlc3QgdGhlIG5leHQgZnJhbWUgaWYgbm90IHNjaGVkdWxlZCB0byBzdG9wXG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJfbG9vcF9zdG9wKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVyTG9vcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyX2xvb3Bfc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJfbG9vcF9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldHVwIHRoZSByZW5kZXIgbG9vcFxuICAgIHNldHVwUmVuZGVyTG9vcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcl9sb29wX2FjdGl2ZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMucmVuZGVyTG9vcCgpOyB9LCAwKTsgLy8gZGVsYXkgc3RhcnQgYnkgb25lIHRpY2tcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy50aWxlX21hbmFnZXIubG9hZFF1ZXVlZENvb3JkaW5hdGVzKCk7XG5cbiAgICAgICAgLy8gUmVuZGVyIG9uIGRlbWFuZFxuICAgICAgICB2YXIgd2lsbF9yZW5kZXIgPSAhKFxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICB0aGlzLnVwZGF0aW5nID4gMCB8fFxuICAgICAgICAgICAgdGhpcy52aWV3UmVhZHkoKSA9PT0gZmFsc2VcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBQcmUtcmVuZGVyIGxvb3AgaG9va1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnByZVVwZGF0ZSh3aWxsX3JlbmRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCYWlsIGlmIG5vIG5lZWQgdG8gcmVuZGVyXG4gICAgICAgIGlmICghd2lsbF9yZW5kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7IC8vIHN1YmNsYXNzZXMgY2FuIHNldCB0aGlzIGJhY2sgdG8gdHJ1ZSB3aGVuIGFuaW1hdGlvbiBpcyBuZWVkZWRcblxuICAgICAgICAvLyBSZW5kZXIgdGhlIHNjZW5lXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG5cbiAgICAgICAgLy8gUG9zdC1yZW5kZXIgbG9vcCBob29rXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wb3N0VXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnBvc3RVcGRhdGUod2lsbF9yZW5kZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVkcmF3IGV2ZXJ5IGZyYW1lIGlmIGFuaW1hdGluZ1xuICAgICAgICBpZiAodGhpcy5hbmltYXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZyYW1lKys7XG4gICAgICAgIGxvZy50cmFjZSgnU2NlbmUucmVuZGVyKCknKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgICAgIC8vIE1hcCB0cmFuc2Zvcm1zXG4gICAgICAgIGlmICghdGhpcy5jZW50ZXJfbWV0ZXJzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgc3R5bGVzLCBjYW1lcmEsIGxpZ2h0c1xuICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGUoKTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5hY3RpdmVfc3R5bGVzKS5mb3JFYWNoKGkgPT4gdGhpcy5zdHlsZXNbaV0udXBkYXRlKCkpO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmxpZ2h0cykuZm9yRWFjaChpID0+IHRoaXMubGlnaHRzW2ldLnVwZGF0ZSgpKTtcblxuICAgICAgICAvLyBSZW5kZXJhYmxlIHRpbGUgbGlzdFxuICAgICAgICB0aGlzLnJlbmRlcmFibGVfdGlsZXMgPSB0aGlzLnRpbGVfbWFuYWdlci5nZXRSZW5kZXJhYmxlVGlsZXMoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJhYmxlX3RpbGVzX2NvdW50ID0gdGhpcy5yZW5kZXJhYmxlX3RpbGVzLmxlbmd0aDtcblxuICAgICAgICAvLyBSZW5kZXIgbWFpbiBwYXNzXG4gICAgICAgIHRoaXMucmVuZGVyX2NvdW50ID0gdGhpcy5yZW5kZXJQYXNzKCk7XG5cbiAgICAgICAgLy8gUmVuZGVyIHNlbGVjdGlvbiBwYXNzIChpZiBuZWVkZWQpXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5wZW5kaW5nUmVxdWVzdHMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFubmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uYmluZCgpOyAgICAgICAgICAgICAgICAgIC8vIHN3aXRjaCB0byBGQk9cbiAgICAgICAgICAgIHRoaXMucmVuZGVyUGFzcyhcbiAgICAgICAgICAgICAgICAnc2VsZWN0aW9uX3Byb2dyYW0nLCAgICAgICAgICAgICAgICAvLyByZW5kZXIgdy9hbHRlcm5hdGUgcHJvZ3JhbVxuICAgICAgICAgICAgICAgIHsgYWxsb3dfYWxwaGFfYmxlbmQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ucmVhZCgpOyAgICAgICAgICAgICAgICAgIC8vIHJlYWQgcmVzdWx0cyBmcm9tIHNlbGVjdGlvbiBidWZmZXJcblxuICAgICAgICAgICAgLy8gUmVzZXQgdG8gc2NyZWVuIGJ1ZmZlclxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucmVuZGVyX2NvdW50ICE9PSB0aGlzLmxhc3RfcmVuZGVyX2NvdW50KSB7XG4gICAgICAgICAgICB0aGlzLmdldEZlYXR1cmVTZWxlY3Rpb25NYXBTaXplKCkudGhlbihzaXplID0+IHtcbiAgICAgICAgICAgICAgICBsb2cuaW5mbyhgU2NlbmU6IHJlbmRlcmVkICR7dGhpcy5yZW5kZXJfY291bnR9IHByaW1pdGl2ZXMgKCR7c2l6ZX0gZmVhdHVyZXMgaW4gc2VsZWN0aW9uIG1hcClgKTtcbiAgICAgICAgICAgIH0sICgpID0+IHt9KTsgLy8gbm8gb3Agd2hlbiBwcm9taXNlIHJlamVjdHMgKG9ubHkgcHJpbnQgbGFzdCByZXNwb25zZSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RfcmVuZGVyX2NvdW50ID0gdGhpcy5yZW5kZXJfY291bnQ7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gUmVuZGVyIGFsbCBhY3RpdmUgc3R5bGVzLCBncm91cGVkIGJ5IGJsZW5kL2RlcHRoIHR5cGUgKG9wYXF1ZSwgb3ZlcmxheSwgZXRjLikgYW5kIGJ5IHByb2dyYW0gKHN0eWxlKVxuICAgIC8vIENhbGxlZCBib3RoIGZvciBtYWluIHJlbmRlciBwYXNzLCBhbmQgZm9yIHNlY29uZGFyeSBwYXNzZXMgbGlrZSBzZWxlY3Rpb24gYnVmZmVyXG4gICAgcmVuZGVyUGFzcyhwcm9ncmFtX2tleSA9ICdwcm9ncmFtJywgeyBhbGxvd19hbHBoYV9ibGVuZCB9ID0ge30pIHtcbiAgICAgICAgbGV0IHN0eWxlcztcbiAgICAgICAgbGV0IGNvdW50ID0gMDsgLy8gaG93IG1hbnkgcHJpbWl0aXZlcyB3ZXJlIHJlbmRlcmVkXG5cbiAgICAgICAgLy8gb3B0aW9uYWxseSBmb3JjZSBhbHBoYSBvZmYgKGUuZy4gZm9yIHNlbGVjdGlvbiBwYXNzKVxuICAgICAgICBhbGxvd19hbHBoYV9ibGVuZCA9IChhbGxvd19hbHBoYV9ibGVuZCA9PSBudWxsKSA/IHRydWUgOiBhbGxvd19hbHBoYV9ibGVuZDtcblxuICAgICAgICB0aGlzLmNsZWFyRnJhbWUoeyBjbGVhcl9jb2xvcjogdHJ1ZSwgY2xlYXJfZGVwdGg6IHRydWUgfSk7XG5cbiAgICAgICAgLy8gT3BhcXVlIHN0eWxlczogZGVwdGggdGVzdCBvbiwgZGVwdGggd3JpdGUgb24sIGJsZW5kaW5nIG9mZlxuICAgICAgICBzdHlsZXMgPSBPYmplY3Qua2V5cyh0aGlzLmFjdGl2ZV9zdHlsZXMpLmZpbHRlcihzID0+IHRoaXMuc3R5bGVzW3NdLmJsZW5kID09PSAnb3BhcXVlJyk7XG4gICAgICAgIGlmIChzdHlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zZXRSZW5kZXJTdGF0ZSh7IGRlcHRoX3Rlc3Q6IHRydWUsIGRlcHRoX3dyaXRlOiB0cnVlLCBhbHBoYV9ibGVuZDogZmFsc2UgfSk7XG4gICAgICAgICAgICBjb3VudCArPSB0aGlzLnJlbmRlclN0eWxlcyhzdHlsZXMsIHByb2dyYW1fa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYW5zcGFyZW50IHN0eWxlczogZGVwdGggdGVzdCBvZmYsIGRlcHRoIHdyaXRlIG9uLCBjdXN0b20gYmxlbmRpbmdcbiAgICAgICAgc3R5bGVzID0gT2JqZWN0LmtleXModGhpcy5hY3RpdmVfc3R5bGVzKS5maWx0ZXIocyA9PiB0aGlzLnN0eWxlc1tzXS5ibGVuZCA9PT0gJ2FkZCcpO1xuICAgICAgICBpZiAoc3R5bGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UmVuZGVyU3RhdGUoeyBkZXB0aF90ZXN0OiB0cnVlLCBkZXB0aF93cml0ZTogZmFsc2UsIGFscGhhX2JsZW5kOiAoYWxsb3dfYWxwaGFfYmxlbmQgJiYgJ2FkZCcpIH0pO1xuICAgICAgICAgICAgY291bnQgKz0gdGhpcy5yZW5kZXJTdHlsZXMoc3R5bGVzLCBwcm9ncmFtX2tleSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZXMgPSBPYmplY3Qua2V5cyh0aGlzLmFjdGl2ZV9zdHlsZXMpLmZpbHRlcihzID0+IHRoaXMuc3R5bGVzW3NdLmJsZW5kID09PSAnbXVsdGlwbHknKTtcbiAgICAgICAgaWYgKHN0eWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldFJlbmRlclN0YXRlKHsgZGVwdGhfdGVzdDogdHJ1ZSwgZGVwdGhfd3JpdGU6IGZhbHNlLCBhbHBoYV9ibGVuZDogKGFsbG93X2FscGhhX2JsZW5kICYmICdtdWx0aXBseScpIH0pO1xuICAgICAgICAgICAgY291bnQgKz0gdGhpcy5yZW5kZXJTdHlsZXMoc3R5bGVzLCBwcm9ncmFtX2tleSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbmxheSBzdHlsZXM6IGRlcHRoIHRlc3Qgb24sIGRlcHRoIHdyaXRlIG9mZiwgYmxlbmRpbmcgb25cbiAgICAgICAgc3R5bGVzID0gT2JqZWN0LmtleXModGhpcy5zdHlsZXMpLmZpbHRlcihzID0+IHRoaXMuc3R5bGVzW3NdLmJsZW5kID09PSAnaW5sYXknKTtcbiAgICAgICAgaWYgKHN0eWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldFJlbmRlclN0YXRlKHsgZGVwdGhfdGVzdDogdHJ1ZSwgZGVwdGhfd3JpdGU6IGZhbHNlLCBhbHBoYV9ibGVuZDogYWxsb3dfYWxwaGFfYmxlbmQgfSk7XG4gICAgICAgICAgICBjb3VudCArPSB0aGlzLnJlbmRlclN0eWxlcyhzdHlsZXMsIHByb2dyYW1fa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE92ZXJsYXkgc3R5bGVzOiBkZXB0aCB0ZXN0IG9mZiwgZGVwdGggd3JpdGUgb2ZmLCBibGVuZGluZyBvblxuICAgICAgICBzdHlsZXMgPSBPYmplY3Qua2V5cyh0aGlzLnN0eWxlcykuZmlsdGVyKHMgPT4gdGhpcy5zdHlsZXNbc10uYmxlbmQgPT09ICdvdmVybGF5Jyk7XG4gICAgICAgIGlmIChzdHlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zZXRSZW5kZXJTdGF0ZSh7IGRlcHRoX3Rlc3Q6IGZhbHNlLCBkZXB0aF93cml0ZTogZmFsc2UsIGFscGhhX2JsZW5kOiBhbGxvd19hbHBoYV9ibGVuZCB9KTtcbiAgICAgICAgICAgIGNvdW50ICs9IHRoaXMucmVuZGVyU3R5bGVzKHN0eWxlcywgcHJvZ3JhbV9rZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cblxuICAgIHJlbmRlclN0eWxlcyhzdHlsZXMsIHByb2dyYW1fa2V5KSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IHN0eWxlIG9mIHN0eWxlcykge1xuICAgICAgICAgICAgbGV0IHByb2dyYW0gPSB0aGlzLnN0eWxlc1tzdHlsZV1bcHJvZ3JhbV9rZXldO1xuICAgICAgICAgICAgaWYgKCFwcm9ncmFtIHx8ICFwcm9ncmFtLmNvbXBpbGVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudCArPSB0aGlzLnJlbmRlclN0eWxlKHN0eWxlLCBwcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuXG4gICAgcmVuZGVyU3R5bGUoc3R5bGUsIHByb2dyYW0pIHtcbiAgICAgICAgdmFyIGZpcnN0X2Zvcl9zdHlsZSA9IHRydWU7XG4gICAgICAgIHZhciByZW5kZXJfY291bnQgPSAwO1xuXG4gICAgICAgIC8vIFJlbmRlciB0aWxlIEdMIGdlb21ldHJpZXNcbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLnJlbmRlcmFibGVfdGlsZXMpIHtcbiAgICAgICAgICAgIHZhciB0aWxlID0gdGhpcy5yZW5kZXJhYmxlX3RpbGVzW3RdO1xuXG4gICAgICAgICAgICBpZiAodGlsZS5tZXNoZXNbc3R5bGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXR1cCBzdHlsZSBpZiBlbmNvdW50ZXJpbmcgZm9yIGZpcnN0IHRpbWUgdGhpcyBmcmFtZVxuICAgICAgICAgICAgICAgIC8vIChsYXp5IGluaXQsIG5vdCBhbGwgc3R5bGVzIHdpbGwgYmUgdXNlZCBpbiBhbGwgc2NyZWVuIHZpZXdzOyBzb21lIHN0eWxlcyBtaWdodCBiZSBkZWZpbmVkIGJ1dCBuZXZlciB1c2VkKVxuICAgICAgICAgICAgICAgIGlmIChmaXJzdF9mb3Jfc3R5bGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RfZm9yX3N0eWxlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS51c2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbc3R5bGVdLnNldHVwKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZG9uJ3Qgc2V0IHVuaWZvcm1zIHdoZW4gdGhleSBoYXZlbid0IGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCcyZicsICd1X3Jlc29sdXRpb24nLCB0aGlzLmRldmljZV9zaXplLndpZHRoLCB0aGlzLmRldmljZV9zaXplLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyYW0udW5pZm9ybSgnMWYnLCAndV90aW1lJywgKCgrbmV3IERhdGUoKSkgLSB0aGlzLnN0YXJ0X3RpbWUpIC8gMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyYW0udW5pZm9ybSgnM2YnLCAndV9tYXBfcG9zaXRpb24nLCB0aGlzLmNlbnRlcl9tZXRlcnMueCwgdGhpcy5jZW50ZXJfbWV0ZXJzLnksIHRoaXMuem9vbSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IodGhpcy56b29tKSArIChNYXRoLmxvZygodGhpcy56b29tICUgMSkgKyAxKSAvIE1hdGguTE4yIC8vIHNjYWxlIGZyYWN0aW9uYWwgem9vbSBieSBsb2dcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCcxZicsICd1X21ldGVyc19wZXJfcGl4ZWwnLCB0aGlzLm1ldGVyc19wZXJfcGl4ZWwpO1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzFmJywgJ3VfZGV2aWNlX3BpeGVsX3JhdGlvJywgVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWwgbWF0cml4IC0gdHJhbnNmb3JtcyBzdXJmYWNlIG5vcm1hbHMgaW50byB2aWV3IHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgbWF0cml4IGlzIGNvbnN0YW50IHNpbmNlIHRoZSB2aWV3IGRvZXNuJ3Qgcm90YXRlIGZvciBub3dcbiAgICAgICAgICAgICAgICAgICAgbWF0My5ub3JtYWxGcm9tTWF0NCh0aGlzLm5vcm1hbE1hdHJpeDMyLCB0aGlzLm1vZGVsVmlld01hdHJpeDMyKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCdNYXRyaXgzZnYnLCAndV9ub3JtYWxNYXRyaXgnLCBmYWxzZSwgdGhpcy5ub3JtYWxNYXRyaXgzMik7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW1lcmEuc2V0dXBQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpIGluIHRoaXMubGlnaHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpZ2h0c1tpXS5zZXR1cFByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBjYWxjIHRoZXNlIG9uY2UgcGVyIHRpbGUgKGN1cnJlbnRseSBiZWluZyBuZWVkbGVzc2x5IHJlLWNhbGN1bGF0ZWQgcGVyLXRpbGUtcGVyLXN0eWxlKVxuXG4gICAgICAgICAgICAgICAgLy8gVGlsZSBvcmlnaW5cbiAgICAgICAgICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzNmJywgJ3VfdGlsZV9vcmlnaW4nLCB0aWxlLm1pbi54LCB0aWxlLm1pbi55LCB0aWxlLnN0eWxlX3pvb20pO1xuXG4gICAgICAgICAgICAgICAgLy8gTW9kZWwgbWF0cml4IC0gdHJhbnNmb3JtIHRpbGUgc3BhY2UgaW50byB3b3JsZCBzcGFjZSAobWV0ZXJzLCBhYnNvbHV0ZSBtZXJjYXRvciBwb3NpdGlvbilcbiAgICAgICAgICAgICAgICBtYXQ0LmlkZW50aXR5KHRoaXMubW9kZWxNYXRyaXgpO1xuICAgICAgICAgICAgICAgIG1hdDQudHJhbnNsYXRlKHRoaXMubW9kZWxNYXRyaXgsIHRoaXMubW9kZWxNYXRyaXgsIHZlYzMuZnJvbVZhbHVlcyh0aWxlLm1pbi54LCB0aWxlLm1pbi55LCAwKSk7XG4gICAgICAgICAgICAgICAgbWF0NC5zY2FsZSh0aGlzLm1vZGVsTWF0cml4LCB0aGlzLm1vZGVsTWF0cml4LCB2ZWMzLmZyb21WYWx1ZXModGlsZS5zcGFuLnggLyBHZW8udGlsZV9zY2FsZSwgLTEgKiB0aWxlLnNwYW4ueSAvIEdlby50aWxlX3NjYWxlLCAxKSk7IC8vIHNjYWxlIHRpbGUgbG9jYWwgY29vcmRzIHRvIG1ldGVyc1xuICAgICAgICAgICAgICAgIG1hdDQuY29weSh0aGlzLm1vZGVsTWF0cml4MzIsIHRoaXMubW9kZWxNYXRyaXgpO1xuICAgICAgICAgICAgICAgIHByb2dyYW0udW5pZm9ybSgnTWF0cml4NGZ2JywgJ3VfbW9kZWwnLCBmYWxzZSwgdGhpcy5tb2RlbE1hdHJpeDMyKTtcblxuICAgICAgICAgICAgICAgIC8vIE1vZGVsIHZpZXcgbWF0cml4IC0gdHJhbnNmb3JtIHRpbGUgc3BhY2UgaW50byB2aWV3IHNwYWNlIChtZXRlcnMsIHJlbGF0aXZlIHRvIGNhbWVyYSlcbiAgICAgICAgICAgICAgICBtYXQ0Lm11bHRpcGx5KHRoaXMubW9kZWxWaWV3TWF0cml4MzIsIHRoaXMuY2FtZXJhLnZpZXdNYXRyaXgsIHRoaXMubW9kZWxNYXRyaXgpO1xuICAgICAgICAgICAgICAgIHByb2dyYW0udW5pZm9ybSgnTWF0cml4NGZ2JywgJ3VfbW9kZWxWaWV3JywgZmFsc2UsIHRoaXMubW9kZWxWaWV3TWF0cml4MzIpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVuZGVyIHRpbGVcbiAgICAgICAgICAgICAgICB0aWxlLm1lc2hlc1tzdHlsZV0ucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgcmVuZGVyX2NvdW50ICs9IHRpbGUubWVzaGVzW3N0eWxlXS5nZW9tZXRyeV9jb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW5kZXJfY291bnQ7XG4gICAgfVxuXG4gICAgY2xlYXJGcmFtZSh7IGNsZWFyX2NvbG9yLCBjbGVhcl9kZXB0aCB9ID0ge30pIHtcbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0c1xuICAgICAgICBjbGVhcl9jb2xvciA9IChjbGVhcl9jb2xvciA9PT0gZmFsc2UpID8gZmFsc2UgOiB0cnVlOyAvLyBkZWZhdWx0IHRydWVcbiAgICAgICAgY2xlYXJfZGVwdGggPSAoY2xlYXJfZGVwdGggPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZTsgLy8gZGVmYXVsdCB0cnVlXG5cbiAgICAgICAgLy8gUmVzZXQgZnJhbWUgc3RhdGVcbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcblxuICAgICAgICBpZiAoY2xlYXJfY29sb3IpIHtcbiAgICAgICAgICAgIGdsLmNsZWFyQ29sb3IoLi4udGhpcy5iYWNrZ3JvdW5kLmNvbG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbGVhcl9kZXB0aCkge1xuICAgICAgICAgICAgZ2wuZGVwdGhNYXNrKHRydWUpOyAvLyBhbHdheXMgY2xlYXIgZGVwdGggaWYgcmVxdWVzdGVkLCBldmVuIGlmIGRlcHRoIHdyaXRlIHdpbGwgYmUgdHVybmVkIG9mZlxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsZWFyX2NvbG9yIHx8IGNsZWFyX2RlcHRoKSB7XG4gICAgICAgICAgICBsZXQgbWFzayA9IChjbGVhcl9jb2xvciAmJiBnbC5DT0xPUl9CVUZGRVJfQklUKSB8IChjbGVhcl9kZXB0aCAmJiBnbC5ERVBUSF9CVUZGRVJfQklUKTtcbiAgICAgICAgICAgIGdsLmNsZWFyKG1hc2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0UmVuZGVyU3RhdGUoeyBkZXB0aF90ZXN0LCBkZXB0aF93cml0ZSwgY3VsbF9mYWNlLCBhbHBoYV9ibGVuZCB9ID0ge30pIHtcbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0c1xuICAgICAgICAvLyBUT0RPOiB3aGVuIHdlIGFic3RyYWN0IG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSByZW5kZXIgcGFzc2VzLCB0aGVzZSBjYW4gYmUgcGVyLXBhc3MgY29uZmlnIG9wdGlvbnNcbiAgICAgICAgZGVwdGhfdGVzdCA9IChkZXB0aF90ZXN0ID09PSBmYWxzZSkgPyBmYWxzZSA6IHRydWU7ICAgICAgICAgLy8gZGVmYXVsdCB0cnVlXG4gICAgICAgIGRlcHRoX3dyaXRlID0gKGRlcHRoX3dyaXRlID09PSBmYWxzZSkgPyBmYWxzZSA6IHRydWU7ICAgICAgIC8vIGRlZmF1bHQgdHJ1ZVxuICAgICAgICBjdWxsX2ZhY2UgPSAoY3VsbF9mYWNlID09PSBmYWxzZSkgPyBmYWxzZSA6IHRydWU7ICAgICAgICAgICAvLyBkZWZhdWx0IHRydWVcbiAgICAgICAgYWxwaGFfYmxlbmQgPSAoYWxwaGFfYmxlbmQgIT0gbnVsbCkgPyBhbHBoYV9ibGVuZCA6IGZhbHNlOyAgLy8gZGVmYXVsdCBmYWxzZVxuXG4gICAgICAgIC8vIFJlc2V0IGZyYW1lIHN0YXRlXG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG5cbiAgICAgICAgUmVuZGVyU3RhdGUuZGVwdGhfdGVzdC5zZXQoeyBkZXB0aF90ZXN0OiBkZXB0aF90ZXN0LCBkZXB0aF9mdW5jOiBnbC5MRVFVQUwgfSk7XG4gICAgICAgIFJlbmRlclN0YXRlLmRlcHRoX3dyaXRlLnNldCh7IGRlcHRoX3dyaXRlOiBkZXB0aF93cml0ZSB9KTtcbiAgICAgICAgUmVuZGVyU3RhdGUuY3VsbGluZy5zZXQoeyBjdWxsOiBjdWxsX2ZhY2UsIGZhY2U6IGdsLkJBQ0sgfSk7XG5cbiAgICAgICAgaWYgKGFscGhhX2JsZW5kKSB7XG4gICAgICAgICAgICAvLyBUcmFkaXRpb25hbCBibGVuZGluZ1xuICAgICAgICAgICAgaWYgKGFscGhhX2JsZW5kID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgUmVuZGVyU3RhdGUuYmxlbmRpbmcuc2V0KHsgYmxlbmQ6IHRydWUsIHNyYzogZ2wuU1JDX0FMUEhBLCBkc3Q6IGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGRpdGl2ZSBibGVuZGluZ1xuICAgICAgICAgICAgZWxzZSBpZiAoYWxwaGFfYmxlbmQgPT09ICdhZGQnKSB7XG4gICAgICAgICAgICAgICAgUmVuZGVyU3RhdGUuYmxlbmRpbmcuc2V0KHsgYmxlbmQ6IHRydWUsIHNyYzogZ2wuT05FLCBkc3Q6IGdsLk9ORSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE11bHRpcGxpY2F0aXZlIGJsZW5kaW5nXG4gICAgICAgICAgICBlbHNlIGlmIChhbHBoYV9ibGVuZCA9PT0gJ211bHRpcGx5Jykge1xuICAgICAgICAgICAgICAgIFJlbmRlclN0YXRlLmJsZW5kaW5nLnNldCh7IGJsZW5kOiB0cnVlLCBzcmM6IGdsLlpFUk8sIGRzdDogZ2wuU1JDX0NPTE9SIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgUmVuZGVyU3RhdGUuYmxlbmRpbmcuc2V0KHsgYmxlbmQ6IGZhbHNlLCBzcmM6IG51bGwsIGRzdDogbnVsbH0gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlcXVlc3QgZmVhdHVyZSBzZWxlY3Rpb24gYXQgZ2l2ZW4gcGl4ZWwuIFJ1bnMgYXN5bmMgYW5kIHJldHVybnMgcmVzdWx0cyB2aWEgYSBwcm9taXNlLlxuICAgIGdldEZlYXR1cmVBdChwaXhlbCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIlNjZW5lLmdldEZlYXR1cmVBdCgpIGNhbGxlZCBiZWZvcmUgc2NlbmUgd2FzIGluaXRpYWxpemVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUG9pbnQgc2NhbGVkIHRvIFswLi4xXSByYW5nZVxuICAgICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgICAgICB4OiBwaXhlbC54ICogVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvIC8gdGhpcy5kZXZpY2Vfc2l6ZS53aWR0aCxcbiAgICAgICAgICAgIHk6IHBpeGVsLnkgKiBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW8gLyB0aGlzLmRldmljZV9zaXplLmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlOyAvLyBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgc2NlbmUgcmUtcmVuZGVycyBmb3IgdGhlc2UgdG8gYmUgcHJvY2Vzc2VkXG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5nZXRGZWF0dXJlQXQocG9pbnQpO1xuICAgIH1cblxuICAgIC8vIFJlYnVpbGQgZ2VvbWV0cnksIHdpdGhvdXQgcmUtcGFyc2luZyB0aGUgY29uZmlnIG9yIHJlLWNvbXBpbGluZyBzdHlsZXNcbiAgICAvLyBUT0RPOiBkZXRlY3Qgd2hpY2ggZWxlbWVudHMgbmVlZCB0byBiZSByZWZyZXNoZWQvcmVidWlsdCAoc3R5bGVzaGVldCBjaGFuZ2VzLCBldGMuKVxuICAgIHJlYnVpbGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYnVpbGRHZW9tZXRyeSgpO1xuICAgIH1cblxuICAgIC8vIFJlYnVpbGQgYWxsIHRpbGVzXG4gICAgcmVidWlsZEdlb21ldHJ5KCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gU2tpcCByZWJ1aWxkIGlmIGFscmVhZHkgaW4gcHJvZ3Jlc3NcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1aWxkaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gUXVldWUgdXAgdG8gb25lIHJlYnVpbGQgY2FsbCBhdCBhIHRpbWUsIG9ubHkgc2F2ZSBsYXN0IHJlcXVlc3RcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5idWlsZGluZy5xdWV1ZWQgJiYgdGhpcy5idWlsZGluZy5xdWV1ZWQucmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGlmeSBwcmV2aW91cyByZXF1ZXN0IHRoYXQgaXQgZGlkIG5vdCBjb21wbGV0ZVxuICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoJ1NjZW5lLnJlYnVpbGRHZW9tZXRyeTogcmVxdWVzdCBzdXBlcmNlZGVkIGJ5IGEgbmV3ZXIgY2FsbCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkaW5nLnF1ZXVlZC5yZXNvbHZlKGZhbHNlKTsgLy8gZmFsc2UgZmxhZyBpbmRpY2F0ZXMgcmVidWlsZCByZXF1ZXN0IHdhcyBzdXBlcmNlZGVkXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBxdWV1ZWQgcmVxdWVzdFxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRpbmcucXVldWVkID0geyByZXNvbHZlLCByZWplY3QgfTtcbiAgICAgICAgICAgICAgICBsb2cudHJhY2UoYFNjZW5lLnJlYnVpbGRHZW9tZXRyeSgpOiBxdWV1aW5nIHJlcXVlc3RgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRyYWNrIHRpbGUgYnVpbGQgc3RhdGVcbiAgICAgICAgICAgIHRoaXMuYnVpbGRpbmcgPSB7IHJlc29sdmUsIHJlamVjdCB9O1xuXG4gICAgICAgICAgICAvLyBQcm9maWxpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnLnByb2ZpbGUuZ2VvbWV0cnlfYnVpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9maWxlKCdyZWJ1aWxkR2VvbWV0cnknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRlIGNvbmZpZyAoaW4gY2FzZSBKUyBvYmplY3RzIHdlcmUgbWFuaXB1bGF0ZWQgZGlyZWN0bHkpXG4gICAgICAgICAgICB0aGlzLnN5bmNDb25maWdUb1dvcmtlcigpO1xuICAgICAgICAgICAgU3R5bGVNYW5hZ2VyLmNvbXBpbGUodGhpcy51cGRhdGVBY3RpdmVTdHlsZXMoKSwgdGhpcyk7IC8vIG9ubHkgcmVjb21waWxlIG5ld2x5IGFjdGl2ZSBzdHlsZXNcbiAgICAgICAgICAgIHRoaXMucmVzZXRGZWF0dXJlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0VGltZSgpO1xuXG4gICAgICAgICAgICAvLyBSZWJ1aWxkIHZpc2libGUgdGlsZXMsIHNvcnRlZCBmcm9tIGNlbnRlclxuICAgICAgICAgICAgbGV0IGJ1aWxkID0gW107XG4gICAgICAgICAgICB0aGlzLnRpbGVfbWFuYWdlci5mb3JFYWNoVGlsZSgodGlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aWxlLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGQucHVzaCh0aWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGlsZV9tYW5hZ2VyLnJlbW92ZVRpbGUodGlsZS5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50aWxlX21hbmFnZXIuYnVpbGRUaWxlcyhidWlsZCk7XG4gICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gUHJvZmlsaW5nXG4gICAgICAgICAgICBpZiAodGhpcy5kZWJ1Zy5wcm9maWxlLmdlb21ldHJ5X2J1aWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZmlsZUVuZCgncmVidWlsZEdlb21ldHJ5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFRpbGUgbWFuYWdlciBmaW5pc2hlZCBidWlsZGluZyB0aWxlc1xuICAgIHRpbGVNYW5hZ2VyQnVpbGREb25lKCkge1xuICAgICAgICBpZiAodGhpcy5idWlsZGluZykge1xuICAgICAgICAgICAgbG9nLmluZm8oYFNjZW5lOiBidWlsZCBnZW9tZXRyeSBmaW5pc2hlZGApO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVpbGRpbmcucmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRpbmcucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQW5vdGhlciByZWJ1aWxkIHF1ZXVlZD9cbiAgICAgICAgICAgIHZhciBxdWV1ZWQgPSB0aGlzLmJ1aWxkaW5nLnF1ZXVlZDtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRpbmcgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHF1ZXVlZCkge1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhgU2NlbmU6IHN0YXJ0aW5nIHF1ZXVlZCByZWJ1aWxkR2VvbWV0cnkoKSByZXF1ZXN0YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWJ1aWxkR2VvbWV0cnkoKS50aGVuKHF1ZXVlZC5yZXNvbHZlLCBxdWV1ZWQucmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAgIExvYWQgKG9yIHJlbG9hZCkgdGhlIHNjZW5lIGNvbmZpZ1xuICAgICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgICBsb2FkU2NlbmUoY29uZmlnX3NvdXJjZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb25maWdfc291cmNlID0gY29uZmlnX3NvdXJjZSB8fCB0aGlzLmNvbmZpZ19zb3VyY2U7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb25maWdfc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5jb25maWdfcGF0aCA9IFV0aWxzLnBhdGhGb3JVUkwodGhpcy5jb25maWdfc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnX3BhdGggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIFRleHR1cmUuYmFzZV91cmwgPSB0aGlzLmNvbmZpZ19wYXRoO1xuXG4gICAgICAgIHJldHVybiBVdGlscy5sb2FkUmVzb3VyY2UodGhpcy5jb25maWdfc291cmNlKS50aGVuKChjb25maWcpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlUHJvY2Vzc0NvbmZpZygpLnRoZW4oKCkgPT4geyB0aGlzLnRyaWdnZXIoJ2xvYWQnLCB7IGNvbmZpZzogdGhpcy5jb25maWcgfSk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBsb2FkRGF0YVNvdXJjZXMoKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5jb25maWcuc291cmNlcykge1xuICAgICAgICAgICAgbGV0IHNvdXJjZSA9IHRoaXMuY29uZmlnLnNvdXJjZXNbbmFtZV07XG4gICAgICAgICAgICBzb3VyY2UudXJsID0gVXRpbHMuYWRkQmFzZVVSTChzb3VyY2UudXJsKTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlc1tuYW1lXSA9IERhdGFTb3VyY2UuY3JlYXRlKE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZSwge25hbWV9KSk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5zb3VyY2VzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc291cmNlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBsb2cud2FybihgU2NlbmU6IGNvdWxkIG5vdCBjcmVhdGUgZGF0YSBzb3VyY2VgLCBzb3VyY2UpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignd2FybmluZycsIHsgdHlwZTogJ3NvdXJjZXMnLCBzb3VyY2UsIG1lc3NhZ2U6IGBDb3VsZCBub3QgY3JlYXRlIGRhdGEgc291cmNlYCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSBzb21lIHNldHRpbmdzIHRoYXQgbWF5IG5vdCBoYXZlIGJlZW4gZXhwbGljaXRseSBzcGVjaWZpZWQgaW4gdGhlIHNjZW5lIGRlZmluaXRpb25cbiAgICBwcmVQcm9jZXNzQ29uZmlnKCkge1xuICAgICAgICAvLyBBc3NpZ24gaWRzIHRvIGRhdGEgc291cmNlc1xuICAgICAgICBsZXQgc291cmNlX2lkID0gMDtcbiAgICAgICAgZm9yIChsZXQgc291cmNlIGluIHRoaXMuY29uZmlnLnNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnNvdXJjZXNbc291cmNlXS5pZCA9IHNvdXJjZV9pZCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgb25seSBvbmUgY2FtZXJhIHNwZWNpZmllZCwgc2V0IGl0IGFzIGRlZmF1bHRcbiAgICAgICAgdGhpcy5jb25maWcuY2FtZXJhcyA9IHRoaXMuY29uZmlnLmNhbWVyYXMgfHwge307XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5jYW1lcmEpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmNhbWVyYXMuZGVmYXVsdCA9IHRoaXMuY29uZmlnLmNhbWVyYTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2FtZXJhX25hbWVzID0gT2JqZWN0LmtleXModGhpcy5jb25maWcuY2FtZXJhcyk7XG4gICAgICAgIGlmIChjYW1lcmFfbmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5jYW1lcmFzLmRlZmF1bHQgPSB7IGFjdGl2ZTogdHJ1ZSB9O1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2FjdGl2ZV9jYW1lcmEpIHtcbiAgICAgICAgICAgIC8vIElmIG5vIGNhbWVyYSBzZXQgYXMgYWN0aXZlLCB1c2UgZmlyc3Qgb25lXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5jYW1lcmFzW2NhbWVyYV9uYW1lc1swXV0uYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29uZmlnLmxpZ2h0cyA9IHRoaXMuY29uZmlnLmxpZ2h0cyB8fCB7fTsgLy8gZW5zdXJlIGxpZ2h0cyBvYmplY3RcbiAgICAgICAgdGhpcy5jb25maWcuc3R5bGVzID0gdGhpcy5jb25maWcuc3R5bGVzIHx8IHt9OyAvLyBlbnN1cmUgc3R5bGVzIG9iamVjdFxuXG4gICAgICAgIHJldHVybiBTdHlsZU1hbmFnZXIucHJlbG9hZCh0aGlzLmNvbmZpZy5zdHlsZXMsIHRoaXMuY29uZmlnX3BhdGgpO1xuICAgIH1cblxuICAgIC8vIExvYWQgYWxsIHRleHR1cmVzIGluIHRoZSBzY2VuZSBkZWZpbml0aW9uXG4gICAgbG9hZFRleHR1cmVzKCkge1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZVRleHR1cmVzKCk7XG4gICAgICAgIHJldHVybiBUZXh0dXJlLmNyZWF0ZUZyb21PYmplY3QodGhpcy5nbCwgdGhpcy5jb25maWcudGV4dHVyZXMpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBzaW5nbGUgb3IgbXVsdGktdGV4dHVyZSBzeW50YXgsIGZvciBzdHlsZXNoZWV0IGNvbnZlbmllbmNlXG4gICAgbm9ybWFsaXplVGV4dHVyZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcuc3R5bGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBbc3R5bGVfbmFtZSwgc3R5bGVdIG9mIFV0aWxzLmVudHJpZXModGhpcy5jb25maWcuc3R5bGVzKSkge1xuICAgICAgICAgICAgLy8gSWYgc3R5bGUgaGFzIGEgc2luZ2xlICd0ZXh0dXJlJyBvYmplY3QsIG1vdmUgaXQgdG8gdGhlIGdsb2JhbCBzY2VuZSB0ZXh0dXJlIHNldFxuICAgICAgICAgICAgLy8gYW5kIGdpdmUgaXQgYSBkZWZhdWx0IG5hbWVcbiAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0dXJlICYmIHR5cGVvZiBzdHlsZS50ZXh0dXJlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0dXJlX25hbWUgPSAnX18nICsgc3R5bGVfbmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy50ZXh0dXJlcyA9IHRoaXMuY29uZmlnLnRleHR1cmVzIHx8IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnRleHR1cmVzW3RleHR1cmVfbmFtZV0gPSBzdHlsZS50ZXh0dXJlO1xuICAgICAgICAgICAgICAgIHN0eWxlLnRleHR1cmUgPSB0ZXh0dXJlX25hbWU7IC8vIHBvaW50IHN0bHllIHRvIGxvY2F0aW9uIG9mIHRleHR1cmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhbGxlZCAoY3VycmVudGx5IG1hbnVhbGx5KSBhZnRlciBzdHlsZXMgYXJlIHVwZGF0ZWQgaW4gc3R5bGVzaGVldFxuICAgIHVwZGF0ZVN0eWxlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkICYmICF0aGlzLmluaXRpYWxpemluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY2VuZS51cGRhdGVTdHlsZXMoKSBjYWxsZWQgYmVmb3JlIHNjZW5lIHdhcyBpbml0aWFsaXplZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gKFJlKWJ1aWxkIHN0eWxlcyBmcm9tIGNvbmZpZ1xuICAgICAgICBTdHlsZU1hbmFnZXIuaW5pdCgpO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFN0eWxlTWFuYWdlci5idWlsZCh0aGlzLmNvbmZpZy5zdHlsZXMsIHRoaXMpO1xuXG4gICAgICAgIC8vIE9wdGlvbmFsbHkgc2V0IEdMIGNvbnRleHQgKHVzZWQgd2hlbiBpbml0aWFsaXppbmcgb3IgcmUtaW5pdGlhbGl6aW5nIEdMIHJlc291cmNlcylcbiAgICAgICAgZm9yICh2YXIgc3R5bGUgb2YgVXRpbHMudmFsdWVzKHRoaXMuc3R5bGVzKSkge1xuICAgICAgICAgICAgc3R5bGUuc2V0R0wodGhpcy5nbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kICYgY29tcGlsZSBhY3RpdmUgc3R5bGVzXG4gICAgICAgIHRoaXMudXBkYXRlQWN0aXZlU3R5bGVzKCk7XG4gICAgICAgIFN0eWxlTWFuYWdlci5jb21waWxlKE9iamVjdC5rZXlzKHRoaXMuYWN0aXZlX3N0eWxlcyksIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cblxuICAgIHVwZGF0ZUFjdGl2ZVN0eWxlcygpIHtcbiAgICAgICAgLy8gTWFrZSBhIHNldCBvZiBjdXJyZW50bHkgYWN0aXZlIHN0eWxlcyAodXNlZCBpbiBhIGRyYXcgcnVsZSlcbiAgICAgICAgLy8gTm90ZTogZG9lc24ndCBhY3R1YWxseSBjaGVjayBpZiBhbnkgZ2VvbWV0cnkgbWF0Y2hlcyB0aGUgcnVsZSwganVzdCB0aGF0IHRoZSBzdHlsZSBpcyBwb3RlbnRpYWxseSByZW5kZXJhYmxlXG4gICAgICAgIGxldCBwcmV2X3N0eWxlcyA9IE9iamVjdC5rZXlzKHRoaXMuYWN0aXZlX3N0eWxlcyB8fCB7fSk7XG4gICAgICAgIHRoaXMuYWN0aXZlX3N0eWxlcyA9IHt9O1xuICAgICAgICB2YXIgYW5pbWF0ZWQgPSBmYWxzZTsgLy8gaXMgYW55IGFjdGl2ZSBzdHlsZSBhbmltYXRlZD9cbiAgICAgICAgZm9yICh2YXIgcnVsZSBvZiBVdGlscy5yZWN1cnNlVmFsdWVzKHRoaXMuY29uZmlnLmxheWVycykpIHtcbiAgICAgICAgICAgIGlmIChydWxlLmRyYXcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBbbmFtZSwgZ3JvdXBdIG9mIFV0aWxzLmVudHJpZXMocnVsZS5kcmF3KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3YXJuIG9uIG5vbi1vYmplY3QgZHJhdyBncm91cFxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGdyb3VwID09PSAnb2JqZWN0JyAmJiBncm91cC52aXNpYmxlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0eWxlX25hbWUgPSBncm91cC5zdHlsZSB8fCBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0eWxlcyA9IFtzdHlsZV9uYW1lXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9uYWwgYWRkaXRpb25hbCBvdXRsaW5lIHN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAub3V0bGluZSAmJiBncm91cC5vdXRsaW5lLnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goZ3JvdXAub3V0bGluZS5zdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcyA9IHN0eWxlcy5maWx0ZXIoeCA9PiB0aGlzLnN0eWxlc1t4XSkuZm9yRWFjaChzdHlsZV9uYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGUgPSB0aGlzLnN0eWxlc1tzdHlsZV9uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVfc3R5bGVzW3N0eWxlX25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlLmFuaW1hdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZSBleHBsaWNpdGx5IHNldCBzY2VuZSBhbmltYXRpb24gZmxhZyBpZiBkZWZpbmVkLCBvdGhlcndpc2UgdHVybiBvbiBhbmltYXRpb25cbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIGFueSBhbmltYXRlZCBzdHlsZXNcbiAgICAgICAgdGhpcy5hbmltYXRlZCA9IHRoaXMuY29uZmlnLnNjZW5lLmFuaW1hdGVkICE9PSB1bmRlZmluZWQgPyB0aGlzLmNvbmZpZy5zY2VuZS5hbmltYXRlZCA6IGFuaW1hdGVkO1xuXG4gICAgICAgIC8vIENvbXBpbGUgbmV3bHkgYWN0aXZlIHN0eWxlc1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5hY3RpdmVfc3R5bGVzKS5maWx0ZXIocyA9PiBwcmV2X3N0eWxlcy5pbmRleE9mKHMpID09PSAtMSk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGNhbWVyYVxuICAgIGNyZWF0ZUNhbWVyYSgpIHtcbiAgICAgICAgbGV0IGFjdGl2ZV9jYW1lcmEgPSB0aGlzLl9hY3RpdmVfY2FtZXJhO1xuICAgICAgICBpZiAoYWN0aXZlX2NhbWVyYSkge1xuICAgICAgICAgICAgdGhpcy5jYW1lcmEgPSBDYW1lcmEuY3JlYXRlKGFjdGl2ZV9jYW1lcmEsIHRoaXMsIHRoaXMuY29uZmlnLmNhbWVyYXNbdGhpcy5fYWN0aXZlX2NhbWVyYV0pO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHRoaXMgYW5kIG1vdmUgYWxsIHBvc2l0aW9uIGluZm8gdG8gY2FtZXJhXG4gICAgICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGVTY2VuZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0IGFjdGl2ZSBjYW1lcmEgLSBmb3IgcHVibGljIEFQSVxuICAgIGdldEFjdGl2ZUNhbWVyYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZV9jYW1lcmE7XG4gICAgfVxuXG4gICAgLy8gU2V0IGFjdGl2ZSBjYW1lcmEgYW5kIHJlY29tcGlsZSAtIGZvciBwdWJsaWMgQVBJXG4gICAgc2V0QWN0aXZlQ2FtZXJhKG5hbWUpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlX2NhbWVyYSA9IG5hbWU7XG4gICAgICAgIHRoaXMudXBkYXRlQ29uZmlnKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVfY2FtZXJhO1xuICAgIH1cblxuICAgIC8vIEludGVybmFsIG1hbmFnZW1lbnQgb2YgYWN0aXZlIGNhbWVyYVxuICAgIGdldCBfYWN0aXZlX2NhbWVyYSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnICYmIHRoaXMuY29uZmlnLmNhbWVyYXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5jb25maWcuY2FtZXJhcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5jYW1lcmFzW25hbWVdLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgX2FjdGl2ZV9jYW1lcmEobmFtZSkge1xuICAgICAgICB2YXIgcHJldiA9IHRoaXMuX2FjdGl2ZV9jYW1lcmE7XG5cbiAgICAgICAgLy8gU2V0IG5ldyBhY3RpdmUgY2FtZXJhXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5jYW1lcmFzW25hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5jYW1lcmFzW25hbWVdLmFjdGl2ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIENsZWFyIHByZXZpb3VzbHkgYWN0aXZlIGNhbWVyYVxuICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldiAhPT0gbmFtZSAmJiB0aGlzLmNvbmZpZy5jYW1lcmFzW3ByZXZdKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29uZmlnLmNhbWVyYXNbcHJldl0uYWN0aXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGxpZ2h0aW5nXG4gICAgY3JlYXRlTGlnaHRzKCkge1xuICAgICAgICB0aGlzLmxpZ2h0cyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpIGluIHRoaXMuY29uZmlnLmxpZ2h0cykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5saWdodHNbaV0gfHwgdHlwZW9mIHRoaXMuY29uZmlnLmxpZ2h0c1tpXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsaWdodCA9IHRoaXMuY29uZmlnLmxpZ2h0c1tpXTtcbiAgICAgICAgICAgIGxpZ2h0Lm5hbWUgPSBpLnJlcGxhY2UoJy0nLCAnXycpOyAvLyBsaWdodCBuYW1lcyBhcmUgaW5qZWN0ZWQgaW4gc2hhZGVycywgY2FuJ3QgaGF2ZSBoeXBoZW5zXG4gICAgICAgICAgICBsaWdodC52aXNpYmxlID0gKGxpZ2h0LnZpc2libGUgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgICAgICAgIGlmIChsaWdodC52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saWdodHNbbGlnaHQubmFtZV0gPSBMaWdodC5jcmVhdGUodGhpcywgbGlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIExpZ2h0LmluamVjdCh0aGlzLmxpZ2h0cyk7XG4gICAgfVxuXG4gICAgLy8gU2V0IGJhY2tncm91bmQgY29sb3JcbiAgICBzZXRCYWNrZ3JvdW5kKCkge1xuICAgICAgICBsZXQgYmcgPSB0aGlzLmNvbmZpZy5zY2VuZS5iYWNrZ3JvdW5kO1xuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSB7fTtcbiAgICAgICAgaWYgKGJnICYmIGJnLmNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmQuY29sb3IgPSBTdHlsZVBhcnNlci5wYXJzZUNvbG9yKGJnLmNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuYmFja2dyb3VuZC5jb2xvcikge1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLmNvbG9yID0gWzAsIDAsIDAsIDFdOyAvLyBkZWZhdWx0IGJhY2tncm91bmQgdG8gYmxhY2tcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzY2VuZSBjb25maWcsIGFuZCBvcHRpb25hbGx5IHJlYnVpbGQgZ2VvbWV0cnlcbiAgICB1cGRhdGVDb25maWcoeyByZWJ1aWxkIH0gPSB7fSkge1xuICAgICAgICB0aGlzLmdlbmVyYXRpb24rKztcbiAgICAgICAgdGhpcy51cGRhdGluZysrO1xuICAgICAgICB0aGlzLmNvbmZpZy5zY2VuZSA9IHRoaXMuY29uZmlnLnNjZW5lIHx8IHt9O1xuICAgICAgICB0aGlzLmNyZWF0ZUNhbWVyYSgpO1xuICAgICAgICB0aGlzLmNyZWF0ZUxpZ2h0cygpO1xuICAgICAgICB0aGlzLmxvYWREYXRhU291cmNlcygpO1xuICAgICAgICB0aGlzLmxvYWRUZXh0dXJlcygpO1xuICAgICAgICB0aGlzLnNldEJhY2tncm91bmQoKTtcbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZHMoKTtcblxuICAgICAgICAvLyBUT0RPOiBkZXRlY3QgY2hhbmdlcyB0byBzdHlsZXM/IGFscmVhZHkgKGN1cnJlbnRseSkgbmVlZCB0byByZWNvbXBpbGUgYW55d2F5IHdoZW4gY2FtZXJhIG9yIGxpZ2h0cyBjaGFuZ2VcbiAgICAgICAgdGhpcy51cGRhdGVTdHlsZXMoKTtcbiAgICAgICAgdGhpcy5zeW5jQ29uZmlnVG9Xb3JrZXIoKTtcbiAgICAgICAgaWYgKHJlYnVpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYnVpbGRHZW9tZXRyeSgpLnRoZW4oKCkgPT4gdGhpcy51cGRhdGluZy0tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRpbmctLTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNlcmlhbGl6ZSBjb25maWcgYW5kIHNlbmQgdG8gd29ya2VyXG4gICAgc3luY0NvbmZpZ1RvV29ya2VyKCkge1xuICAgICAgICAvLyBUZWxsIHdvcmtlcnMgd2UncmUgYWJvdXQgdG8gcmVidWlsZCAoc28gdGhleSBjYW4gdXBkYXRlIHN0eWxlcywgZXRjLilcbiAgICAgICAgdGhpcy5jb25maWdfc2VyaWFsaXplZCA9IFV0aWxzLnNlcmlhbGl6ZVdpdGhGdW5jdGlvbnModGhpcy5jb25maWcpO1xuICAgICAgICB0aGlzLndvcmtlcnMuZm9yRWFjaCh3b3JrZXIgPT4ge1xuICAgICAgICAgICAgV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHdvcmtlciwgJ3VwZGF0ZUNvbmZpZycsIHtcbiAgICAgICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnX3NlcmlhbGl6ZWQsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGlvbjogdGhpcy5nZW5lcmF0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzZXRGZWF0dXJlU2VsZWN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IG5ldyBGZWF0dXJlU2VsZWN0aW9uKHRoaXMuZ2wsIHRoaXMud29ya2Vycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy53b3JrZXJzKSB7XG4gICAgICAgICAgICB0aGlzLndvcmtlcnMuZm9yRWFjaCh3b3JrZXIgPT4gV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHdvcmtlciwgJ3Jlc2V0RmVhdHVyZVNlbGVjdGlvbicpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdldHMgdGhlIGN1cnJlbnQgZmVhdHVyZSBzZWxlY3Rpb24gbWFwIHNpemUgYWNyb3NzIGFsbCB3b3JrZXJzLiBSZXR1cm5zIGEgcHJvbWlzZS5cbiAgICBnZXRGZWF0dXJlU2VsZWN0aW9uTWFwU2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmV0Y2hpbmdfc2VsZWN0aW9uX21hcCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mZXRjaGluZ19zZWxlY3Rpb25fbWFwID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZVxuICAgICAgICAgICAgLmFsbCh0aGlzLndvcmtlcnMubWFwKHdvcmtlciA9PiBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2Uod29ya2VyLCAnZ2V0RmVhdHVyZVNlbGVjdGlvbk1hcFNpemUnKSkpXG4gICAgICAgICAgICAudGhlbihzaXplcyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5mZXRjaGluZ19zZWxlY3Rpb25fbWFwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgaW50ZXJuYWwgY2xvY2ssIG1vc3RseSB1c2VmdWwgZm9yIGNvbnNpc3RlbnQgZXhwZXJpZW5jZSB3aGVuIGNoYW5naW5nIHN0eWxlcy9kZWJ1Z2dpbmdcbiAgICByZXNldFRpbWUoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRfdGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgIH1cblxuXG4gICAgLy8gU3RhdHMvZGVidWcvcHJvZmlsaW5nIG1ldGhvZHNcblxuICAgIC8vIExvZyBtZXNzYWdlcyBwYXNzIHRocm91Z2ggZnJvbSB3ZWIgd29ya2Vyc1xuICAgIHdvcmtlckxvZ01lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSAhPT0gJ2xvZycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB7IHdvcmtlcl9pZCwgbGV2ZWwsIG1zZyB9ID0gZXZlbnQuZGF0YTtcblxuICAgICAgICBpZiAobG9nW2xldmVsXSkge1xuICAgICAgICAgICAgbG9nW2xldmVsXShgd29ya2VyICR7d29ya2VyX2lkfTpgLCAgLi4ubXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcihgU2NlbmUud29ya2VyTG9nTWVzc2FnZTogdW5yZWNvZ25pemVkIGxvZyBsZXZlbCAke2xldmVsfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJvZmlsZSBoZWxwZXJzLCBpc3N1ZXMgYSBwcm9maWxlIG9uIG1haW4gdGhyZWFkICYgYWxsIHdvcmtlcnNcbiAgICBfcHJvZmlsZShuYW1lKSB7XG4gICAgICAgIGNvbnNvbGUucHJvZmlsZShgbWFpbiB0aHJlYWQ6ICR7bmFtZX1gKTtcbiAgICAgICAgdGhpcy53b3JrZXJzLmZvckVhY2godyA9PiBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UodywgJ3Byb2ZpbGUnLCBuYW1lKSk7XG4gICAgfVxuXG4gICAgX3Byb2ZpbGVFbmQobmFtZSkge1xuICAgICAgICBjb25zb2xlLnByb2ZpbGVFbmQoYG1haW4gdGhyZWFkOiAke25hbWV9YCk7XG4gICAgICAgIHRoaXMud29ya2Vycy5mb3JFYWNoKHcgPT4gV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHcsICdwcm9maWxlRW5kJywgbmFtZSkpO1xuICAgIH1cblxufVxuXG4vLyBTdGF0aWMgbWV0aG9kcy9zdGF0ZVxuXG5TY2VuZS5jcmVhdGUgPSBmdW5jdGlvbiAoY29uZmlnLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFNjZW5lKGNvbmZpZywgb3B0aW9ucyk7XG59O1xuIiwiLypqc2hpbnQgd29ya2VyOiB0cnVlKi9cbmltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzL3V0aWxzJztcbmltcG9ydCBXb3JrZXJCcm9rZXIgZnJvbSAnLi91dGlscy93b3JrZXJfYnJva2VyJzsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5pbXBvcnQgVGlsZSBmcm9tICcuL3RpbGUnO1xuaW1wb3J0IERhdGFTb3VyY2UgZnJvbSAnLi9zb3VyY2VzL2RhdGFfc291cmNlJztcbmltcG9ydCBGZWF0dXJlU2VsZWN0aW9uIGZyb20gJy4vc2VsZWN0aW9uJztcbmltcG9ydCB7U3R5bGVQYXJzZXJ9IGZyb20gJy4vc3R5bGVzL3N0eWxlX3BhcnNlcic7XG5pbXBvcnQge1N0eWxlTWFuYWdlcn0gZnJvbSAnLi9zdHlsZXMvc3R5bGVfbWFuYWdlcic7XG5pbXBvcnQge3BhcnNlUnVsZXN9IGZyb20gJy4vc3R5bGVzL3J1bGUnO1xuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi9nbC90ZXh0dXJlJztcblxuZXhwb3J0IHZhciBTY2VuZVdvcmtlciA9IHNlbGY7XG5cbi8vIFdvcmtlciBmdW5jdGlvbmFsaXR5IHdpbGwgb25seSBiZSBkZWZpbmVkIGluIHdvcmtlciB0aHJlYWRcblV0aWxzLmlzV29ya2VyVGhyZWFkICYmIE9iamVjdC5hc3NpZ24oc2VsZiwge1xuXG4gICAgRmVhdHVyZVNlbGVjdGlvbixcblxuICAgIHNvdXJjZXM6IHtcbiAgICAgICAgdGlsZXM6IHt9LFxuICAgICAgICBvYmplY3RzOiB7fVxuICAgIH0sXG4gICAgc3R5bGVzOiB7fSxcbiAgICBydWxlczoge30sXG4gICAgbGF5ZXJzOiB7fSxcbiAgICB0aWxlczoge30sXG4gICAgb2JqZWN0czoge30sXG4gICAgY29uZmlnOiB7fSxcblxuICAgIC8vIEluaXRpYWxpemUgd29ya2VyXG4gICAgaW5pdCAod29ya2VyX2lkLCBudW1fd29ya2VycywgZGV2aWNlX3BpeGVsX3JhdGlvKSB7XG4gICAgICAgIHNlbGYuX3dvcmtlcl9pZCA9IHdvcmtlcl9pZDtcbiAgICAgICAgc2VsZi5udW1fd29ya2VycyA9IG51bV93b3JrZXJzO1xuICAgICAgICBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW8gPSBkZXZpY2VfcGl4ZWxfcmF0aW87XG4gICAgICAgIEZlYXR1cmVTZWxlY3Rpb24uc2V0UHJlZml4KHNlbGYuX3dvcmtlcl9pZCk7XG4gICAgICAgIHJldHVybiB3b3JrZXJfaWQ7XG4gICAgfSxcblxuICAgIC8vIFN0YXJ0cyBhIGNvbmZpZyByZWZyZXNoXG4gICAgdXBkYXRlQ29uZmlnICh7IGNvbmZpZywgZ2VuZXJhdGlvbiB9KSB7XG4gICAgICAgIHNlbGYuY29uZmlnID0gbnVsbDtcbiAgICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShjb25maWcpO1xuXG4gICAgICAgIHNlbGYuZ2VuZXJhdGlvbiA9IGdlbmVyYXRpb247XG4gICAgICAgIHNlbGYuc3R5bGVzID0gbnVsbDtcblxuICAgICAgICAvLyBEYXRhIGJsb2NrIGZ1bmN0aW9ucyBhcmUgbm90IG1hY3JvJ2VkIGFuZCB3cmFwcGVkIGxpa2UgdGhlIHJlc3Qgb2YgdGhlIHN0eWxlIGZ1bmN0aW9ucyBhcmVcbiAgICAgICAgLy8gVE9ETzogcHJvYmFibHkgd2FudCBhIGNsZWFuZXIgd2F5IHRvIGV4Y2x1ZGUgdGhlc2VcbiAgICAgICAgZm9yICh2YXIgbGF5ZXIgaW4gY29uZmlnLmxheWVycykge1xuICAgICAgICAgICAgY29uZmlnLmxheWVyc1tsYXllcl0uZGF0YSA9IFV0aWxzLnN0cmluZ3NUb0Z1bmN0aW9ucyhjb25maWcubGF5ZXJzW2xheWVyXS5kYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBkYXRhIHNvdXJjZXNcbiAgICAgICAgY29uZmlnLnNvdXJjZXMgPSBVdGlscy5zdHJpbmdzVG9GdW5jdGlvbnMoU3R5bGVQYXJzZXIuZXhwYW5kTWFjcm9zKGNvbmZpZy5zb3VyY2VzKSk7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gY29uZmlnLnNvdXJjZXMpIHtcbiAgICAgICAgICAgIGxldCBzb3VyY2UgPSBEYXRhU291cmNlLmNyZWF0ZShPYmplY3QuYXNzaWduKGNvbmZpZy5zb3VyY2VzW25hbWVdLCB7bmFtZX0pKTtcbiAgICAgICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzb3VyY2UudGlsZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNvdXJjZXMudGlsZXNbbmFtZV0gPSBzb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEaXN0cmlidXRlIG9iamVjdCBzb3VyY2VzIGFjcm9zcyB3b3JrZXJzXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5pZCAlIHNlbGYubnVtX3dvcmtlcnMgPT09IHNlbGYuX3dvcmtlcl9pZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBMb2FkIHNvdXJjZSBpZiBub3QgY2FjaGVkXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc291cmNlcy5vYmplY3RzW25hbWVdID0gc291cmNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYub2JqZWN0c1tzb3VyY2UubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub2JqZWN0c1tzb3VyY2UubmFtZV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5sb2FkKHNlbGYub2JqZWN0c1tzb3VyY2UubmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhwYW5kIHN0eWxlc1xuICAgICAgICBzZWxmLmNvbmZpZyA9IFV0aWxzLnN0cmluZ3NUb0Z1bmN0aW9ucyhTdHlsZVBhcnNlci5leHBhbmRNYWNyb3MoY29uZmlnKSwgU3R5bGVQYXJzZXIud3JhcEZ1bmN0aW9uKTtcbiAgICAgICAgc2VsZi5zdHlsZXMgPSBTdHlsZU1hbmFnZXIuYnVpbGQoc2VsZi5jb25maWcuc3R5bGVzLCB7IGdlbmVyYXRpb246IHNlbGYuZ2VuZXJhdGlvbiB9KTtcblxuICAgICAgICAvLyBQYXJzZSBlYWNoIHRvcC1sZXZlbCBsYXllciBhcyBhIHNlcGFyYXRlIHJ1bGUgdHJlZVxuICAgICAgICAvLyBUT0RPOiBmaW5kIGEgbW9yZSBncmFjZWZ1bCB3YXkgdG8gaW5jb3Jwb3JhdGUgdGhpc1xuXG4gICAgICAgIHNlbGYucnVsZXMgPSBwYXJzZVJ1bGVzKHNlbGYuY29uZmlnLmxheWVycyk7XG5cbiAgICAgICAgLy8gU3luYyB0ZXR4dXJlIGluZm8gZnJvbSBtYWluIHRocmVhZFxuICAgICAgICBzZWxmLnN5bmNpbmdfdGV4dHVyZXMgPSBzZWxmLnN5bmNUZXh0dXJlcygpO1xuXG4gICAgICAgIC8vIFJldHVybiBwcm9taXNlIGZvciB3aGVuIGNvbmZpZyByZWZyZXNoIGZpbmlzaGVzXG4gICAgICAgIHNlbGYuY29uZmlndXJpbmcgPSBzZWxmLnN5bmNpbmdfdGV4dHVyZXMudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBVdGlscy5sb2coJ2RlYnVnJywgYHVwZGF0ZWQgY29uZmlnYCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdoZW4gY29uZmlnIHJlZnJlc2ggaXMgZmluaXNoZWRcbiAgICBhd2FpdENvbmZpZ3VyYXRpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5jb25maWd1cmluZztcbiAgICB9LFxuXG4gICAgLy8gQnVpbGQgYSB0aWxlOiBsb2FkIGZyb20gdGlsZSBzb3VyY2UgaWYgYnVpbGRpbmcgZm9yIGZpcnN0IHRpbWUsIG90aGVyd2lzZSByZWJ1aWxkIHdpdGggZXhpc3RpbmcgZGF0YVxuICAgIGJ1aWxkVGlsZSAoeyB0aWxlIH0pIHtcbiAgICAgICAgLy8gVGlsZSBjYWNoZWQ/XG4gICAgICAgIGlmIChzZWxmLnRpbGVzW3RpbGUua2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IGxvYWRpbmc/XG4gICAgICAgICAgICBpZiAoc2VsZi50aWxlc1t0aWxlLmtleV0ubG9hZGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aWxlIGNhY2hlXG4gICAgICAgIHRpbGUgPSBzZWxmLnRpbGVzW3RpbGUua2V5XSA9IE9iamVjdC5hc3NpZ24oc2VsZi50aWxlc1t0aWxlLmtleV0gfHwge30sIHRpbGUpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBjb25maWcgKHN0eWxlcywgZXRjLiksIHRoZW4gYnVpbGQgdGlsZVxuICAgICAgICByZXR1cm4gc2VsZi5hd2FpdENvbmZpZ3VyYXRpb24oKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEZpcnN0IHRpbWUgYnVpbGRpbmcgdGhlIHRpbGVcbiAgICAgICAgICAgIGlmICh0aWxlLmxvYWRlZCAhPT0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICB0aWxlLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aWxlLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aWxlLmVycm9yID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLmxvYWRUaWxlU291cmNlRGF0YSh0aWxlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhcm4gYW5kIGNvbnRpbnVlIG9uIGRhdGEgc291cmNlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGlsZS5zb3VyY2VfZGF0YS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFV0aWxzLmxvZygnd2FybicsIGB0aWxlIGxvYWQgZXJyb3IocykgZm9yICR7dGlsZS5rZXl9OiAke3RpbGUuc291cmNlX2RhdGEuZXJyb3J9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgVGlsZS5idWlsZEdlb21ldHJ5KHRpbGUsIHNlbGYuY29uZmlnLmxheWVycywgc2VsZi5ydWxlcywgc2VsZi5zdHlsZXMpLnRoZW4oa2V5cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHRpbGU6IFRpbGUuc2xpY2UodGlsZSwga2V5cykgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGUubG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlLmVycm9yID0gZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFV0aWxzLmxvZygnZXJyb3InLCBgdGlsZSBsb2FkIGVycm9yIGZvciAke3RpbGUua2V5fTogJHtlcnJvci5zdGFja31gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHRpbGU6IFRpbGUuc2xpY2UodGlsZSkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGlsZSBhbHJlYWR5IGxvYWRlZCwganVzdCByZWJ1aWxkXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBVdGlscy5sb2coJ3RyYWNlJywgYHVzZWQgd29ya2VyIGNhY2hlIGZvciB0aWxlICR7dGlsZS5rZXl9YCk7XG5cbiAgICAgICAgICAgICAgICAvLyBCdWlsZCBnZW9tZXRyeVxuICAgICAgICAgICAgICAgIHJldHVybiBUaWxlLmJ1aWxkR2VvbWV0cnkodGlsZSwgc2VsZi5jb25maWcubGF5ZXJzLCBzZWxmLnJ1bGVzLCBzZWxmLnN0eWxlcykudGhlbihrZXlzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdGlsZTogVGlsZS5zbGljZSh0aWxlLCBrZXlzKSB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gTG9hZCB0aGlzIHRpbGUncyBkYXRhIHNvdXJjZVxuICAgIGxvYWRUaWxlU291cmNlRGF0YSAodGlsZSkge1xuICAgICAgICByZXR1cm4gc2VsZi5zb3VyY2VzLnRpbGVzW3RpbGUuc291cmNlXS5sb2FkKHRpbGUpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgdGlsZVxuICAgIHJlbW92ZVRpbGUgKGtleSkge1xuICAgICAgICB2YXIgdGlsZSA9IHNlbGYudGlsZXNba2V5XTtcblxuICAgICAgICBpZiAodGlsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBDYW5jZWwgaWYgbG9hZGluZ1xuICAgICAgICAgICAgaWYgKHRpbGUubG9hZGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIFV0aWxzLmxvZygndHJhY2UnLCBgY2FuY2VsIHRpbGUgbG9hZCBmb3IgJHtrZXl9YCk7XG4gICAgICAgICAgICAgICAgdGlsZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFRpbGUuY2FuY2VsKHRpbGUpO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBjYWNoZVxuICAgICAgICAgICAgRmVhdHVyZVNlbGVjdGlvbi5jbGVhclRpbGUoa2V5KTtcbiAgICAgICAgICAgIGRlbGV0ZSBzZWxmLnRpbGVzW2tleV07XG4gICAgICAgICAgICBVdGlscy5sb2coJ3RyYWNlJywgYHJlbW92ZSB0aWxlIGZyb20gY2FjaGUgZm9yICR7a2V5fWApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEdldCBhIGZlYXR1cmUgZnJvbSB0aGUgc2VsZWN0aW9uIG1hcFxuICAgIGdldEZlYXR1cmVTZWxlY3Rpb24gKHsgaWQsIGtleSB9ID0ge30pIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IEZlYXR1cmVTZWxlY3Rpb24ubWFwW2tleV07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGZlYXR1cmU6IChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmZlYXR1cmUpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIFJlc2V0cyB0aGUgZmVhdHVyZSBzZWxlY3Rpb24gc3RhdGVcbiAgICByZXNldEZlYXR1cmVTZWxlY3Rpb24gKCkge1xuICAgICAgICBGZWF0dXJlU2VsZWN0aW9uLnJlc2V0KCk7XG4gICAgfSxcblxuICAgIC8vIFNlbGVjdGlvbiBtYXAgc2l6ZSBmb3IgdGhpcyB3b3JrZXJcbiAgICBnZXRGZWF0dXJlU2VsZWN0aW9uTWFwU2l6ZSAoKSB7XG4gICAgICAgIHJldHVybiBGZWF0dXJlU2VsZWN0aW9uLmdldE1hcFNpemUoKTtcbiAgICB9LFxuXG4gICAgLy8gVGV4dHVyZSBpbmZvIG5lZWRzIHRvIGJlIHN5bmNlZCBmcm9tIG1haW4gdGhyZWFkXG4gICAgc3luY1RleHR1cmVzICgpIHtcbiAgICAgICAgLy8gV2UncmUgb25seSBzeW5jaW5nIHRoZSB0ZXh0dXJlcyB0aGF0IGhhdmUgc3ByaXRlcyBkZWZpbmVkLCBzaW5jZSB0aGVzZSBhcmUgKGN1cnJlbnRseSkgdGhlIG9ubHkgb25lcyB3ZVxuICAgICAgICAvLyBuZWVkIGluZm8gYWJvdXQgZm9yIGdlb21ldHJ5IGNvbnN0cnVjdGlvbiAoZS5nLiB3aWR0aC9oZWlnaHQsIHdoaWNoIHdlIG9ubHkga25vdyBhZnRlciB0aGUgdGV4dHVyZSBsb2FkcylcbiAgICAgICAgbGV0IHRleHR1cmVzID0gW107XG4gICAgICAgIGlmIChzZWxmLmNvbmZpZy50ZXh0dXJlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgW3RleG5hbWUsIHRleHR1cmVdIG9mIFV0aWxzLmVudHJpZXMoc2VsZi5jb25maWcudGV4dHVyZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRleHR1cmUuc3ByaXRlcykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlcy5wdXNoKHRleG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFV0aWxzLmxvZygndHJhY2UnLCAnc3luYyB0ZXh0dXJlcyB0byB3b3JrZXI6JywgdGV4dHVyZXMpO1xuICAgICAgICBpZiAodGV4dHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUuc3luY1RleHR1cmVzVG9Xb3JrZXIodGV4dHVyZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9LFxuXG4gICAgLy8gUHJvZmlsaW5nIGhlbHBlcnNcbiAgICBwcm9maWxlIChuYW1lKSB7XG4gICAgICAgIGNvbnNvbGUucHJvZmlsZShgd29ya2VyICR7c2VsZi5fd29ya2VyX2lkfTogJHtuYW1lfWApO1xuICAgIH0sXG5cbiAgICBwcm9maWxlRW5kIChuYW1lKSB7XG4gICAgICAgIGNvbnNvbGUucHJvZmlsZUVuZChgd29ya2VyICR7c2VsZi5fd29ya2VyX2lkfTogJHtuYW1lfWApO1xuICAgIH1cblxufSk7XG4iLCJpbXBvcnQgVGV4dHVyZSBmcm9tICcuL2dsL3RleHR1cmUnO1xuaW1wb3J0IFdvcmtlckJyb2tlciBmcm9tICcuL3V0aWxzL3dvcmtlcl9icm9rZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGZWF0dXJlU2VsZWN0aW9uIHtcblxuICAgIGNvbnN0cnVjdG9yKGdsLCB3b3JrZXJzKSB7XG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgdGhpcy53b3JrZXJzID0gd29ya2VyczsgLy8gcG9vbCBvZiB3b3JrZXJzIHRvIHJlcXVlc3QgZmVhdHVyZSBsb29rLXVwcyBmcm9tLCBrZXllZCBieSBpZFxuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG5cbiAgICBpbml0KCkge1xuICAgICAgICAvLyBTZWxlY3Rpb24gc3RhdGUgdHJhY2tpbmdcbiAgICAgICAgdGhpcy5yZXF1ZXN0cyA9IHt9OyAvLyBwZW5kaW5nIHNlbGVjdGlvbiByZXF1ZXN0c1xuICAgICAgICB0aGlzLmZlYXR1cmUgPSBudWxsOyAvLyBjdXJyZW50bHkgc2VsZWN0ZWQgZmVhdHVyZVxuICAgICAgICB0aGlzLnJlYWRfZGVsYXkgPSA1OyAvLyBkZWxheSB0aW1lIGZyb20gc2VsZWN0aW9uIHJlbmRlciB0byBmcmFtZWJ1ZmZlciBzYW1wbGUsIHRvIGF2b2lkIENQVS9HUFUgc3luYyBsb2NrXG4gICAgICAgIHRoaXMucmVhZF9kZWxheV90aW1lciA9IG51bGw7IC8vIGN1cnJlbnQgdGltZXIgKHNldFRpbWVvdXQpIGZvciBkZWxheWVkIHNlbGVjdGlvbiByZWFkc1xuXG4gICAgICAgIHRoaXMucGl4ZWwgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgdGhpcy5waXhlbDMyID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnBpeGVsLmJ1ZmZlcik7XG5cbiAgICAgICAgLy8gRnJhbWUgYnVmZmVyIGZvciBzZWxlY3Rpb25cbiAgICAgICAgLy8gVE9ETzogaW5pdGlhdGUgbGF6aWx5IGluIGNhc2Ugd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnkgc2VsZWN0aW9uXG4gICAgICAgIHRoaXMuZmJvID0gdGhpcy5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgICB0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLmdsLkZSQU1FQlVGRkVSLCB0aGlzLmZibyk7XG4gICAgICAgIHRoaXMuZmJvX3NpemUgPSB7IHdpZHRoOiAyNTYsIGhlaWdodDogMjU2IH07IC8vIFRPRE86IG1ha2UgY29uZmlndXJhYmxlIC8gYWRhcHRpdmUgYmFzZWQgb24gY2FudmFzIHNpemVcbiAgICAgICAgdGhpcy5mYm9fc2l6ZS5hc3BlY3QgPSB0aGlzLmZib19zaXplLndpZHRoIC8gdGhpcy5mYm9fc2l6ZS5oZWlnaHQ7XG5cbiAgICAgICAgLy8gVGV4dHVyZSBmb3IgdGhlIEZCTyBjb2xvciBhdHRhY2htZW50XG4gICAgICAgIHZhciBmYm9fdGV4dHVyZSA9IG5ldyBUZXh0dXJlKHRoaXMuZ2wsICdzZWxlY3Rpb25fZmJvJyk7XG4gICAgICAgIGZib190ZXh0dXJlLnNldERhdGEodGhpcy5mYm9fc2l6ZS53aWR0aCwgdGhpcy5mYm9fc2l6ZS5oZWlnaHQsIG51bGwsIHsgZmlsdGVyaW5nOiAnbmVhcmVzdCcgfSk7XG4gICAgICAgIHRoaXMuZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQodGhpcy5nbC5GUkFNRUJVRkZFUiwgdGhpcy5nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgdGhpcy5nbC5URVhUVVJFXzJELCBmYm9fdGV4dHVyZS50ZXh0dXJlLCAwKTtcblxuICAgICAgICAvLyBSZW5kZXJidWZmZXIgZm9yIHRoZSBGQk8gZGVwdGggYXR0YWNobWVudFxuICAgICAgICB2YXIgZmJvX2RlcHRoX3JiID0gdGhpcy5nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgICAgdGhpcy5nbC5iaW5kUmVuZGVyYnVmZmVyKHRoaXMuZ2wuUkVOREVSQlVGRkVSLCBmYm9fZGVwdGhfcmIpO1xuICAgICAgICB0aGlzLmdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UodGhpcy5nbC5SRU5ERVJCVUZGRVIsIHRoaXMuZ2wuREVQVEhfQ09NUE9ORU5UMTYsIHRoaXMuZmJvX3NpemUud2lkdGgsIHRoaXMuZmJvX3NpemUuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcih0aGlzLmdsLkZSQU1FQlVGRkVSLCB0aGlzLmdsLkRFUFRIX0FUVEFDSE1FTlQsIHRoaXMuZ2wuUkVOREVSQlVGRkVSLCBmYm9fZGVwdGhfcmIpO1xuXG4gICAgICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmdsICYmIHRoaXMuZmJvKSB7XG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuZmJvKTtcbiAgICAgICAgICAgIHRoaXMuZmJvID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogZnJlZSB0ZXh0dXJlP1xuICAgIH1cblxuICAgIGJpbmQoKSB7XG4gICAgICAgIC8vIFN3aXRjaCB0byBGQk9cbiAgICAgICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgdGhpcy5mYm8pO1xuICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuZmJvX3NpemUud2lkdGgsIHRoaXMuZmJvX3NpemUuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvLyBSZXF1ZXN0IGZlYXR1cmUgc2VsZWN0aW9uXG4gICAgLy8gUnVucyBhc3luY2hyb25vdXNseSwgc2NoZWR1bGVzIHNlbGVjdGlvbiBidWZmZXIgdG8gYmUgdXBkYXRlZFxuICAgIGdldEZlYXR1cmVBdChwb2ludCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gUXVldWUgcmVxdWVzdHMgZm9yIGZlYXR1cmUgc2VsZWN0aW9uLCBhbmQgdGhleSB3aWxsIGJlIHBpY2tlZCB1cCBieSB0aGUgcmVuZGVyIGxvb3BcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uX3JlcXVlc3RfaWQgPSAodGhpcy5zZWxlY3Rpb25fcmVxdWVzdF9pZCArIDEpIHx8IDA7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RzW3RoaXMuc2VsZWN0aW9uX3JlcXVlc3RfaWRdID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdwb2ludCcsXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuc2VsZWN0aW9uX3JlcXVlc3RfaWQsXG4gICAgICAgICAgICAgICAgcG9pbnQsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQW55IHBlbmRpbmcgc2VsZWN0aW9uIHJlcXVlc3RzXG4gICAgcGVuZGluZ1JlcXVlc3RzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0cztcbiAgICB9XG5cbiAgICAvLyBSZWFkIHBlbmRpbmcgcmVzdWx0cyBmcm9tIHRoZSBzZWxlY3Rpb24gYnVmZmVyLiBDYWxsZWQgYWZ0ZXIgcmVuZGVyaW5nIHRvIHNlbGVjdGlvbiBidWZmZXIuXG4gICAgcmVhZCgpIHtcbiAgICAgICAgLy8gRGVsYXkgcmVhZGluZyB0aGUgcGl4ZWwgcmVzdWx0IGZyb20gdGhlIHNlbGVjdGlvbiBidWZmZXIgdG8gYXZvaWQgQ1BVL0dQVSBzeW5jIGxvY2suXG4gICAgICAgIC8vIENhbGxpbmcgcmVhZFBpeGVscyBzeW5jaHJvbm91c2x5IGNhdXNlZCBhIG1hc3NpdmUgcGVyZm9ybWFuY2UgaGl0LCBwcmVzdW1hYmx5IHNpbmNlIGl0XG4gICAgICAgIC8vIGZvcmNlZCB0aGlzIGZ1bmN0aW9uIHRvIHdhaXQgZm9yIHRoZSBHUFUgdG8gZmluaXNoIHJlbmRlcmluZyBhbmQgcmV0cmlldmUgdGhlIHRleHR1cmUgY29udGVudHMuXG4gICAgICAgIGlmICh0aGlzLnJlYWRfZGVsYXlfdGltZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVhZF9kZWxheV90aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFkX2RlbGF5X3RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZmJvKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgciBpbiB0aGlzLnJlcXVlc3RzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzW3JdO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyByZXF1ZXN0IHdhcyBhbHJlYWR5IHNlbnQgdG8gdGhlIHdvcmtlciwgd2UncmUganVzdCBhd2FpdGluZyBpdHMgcmVwbHlcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHN1cHBvcnQgb3RoZXIgc2VsZWN0aW9uIHR5cGVzLCBzdWNoIGFzIGZlYXR1cmVzIHdpdGhpbiBhIGJveFxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnR5cGUgIT09ICdwb2ludCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgc2VsZWN0aW9uIG1hcCBhZ2FpbnN0IEZCT1xuICAgICAgICAgICAgICAgIGdsLnJlYWRQaXhlbHMoXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IocmVxdWVzdC5wb2ludC54ICogdGhpcy5mYm9fc2l6ZS53aWR0aCksXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKDEgLSByZXF1ZXN0LnBvaW50LnkpICogdGhpcy5mYm9fc2l6ZS5oZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgICAxLCAxLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLnBpeGVsKTtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZV9rZXkgPSAodGhpcy5waXhlbFswXSArICh0aGlzLnBpeGVsWzFdIDw8IDgpICsgKHRoaXMucGl4ZWxbMl0gPDwgMTYpICsgKHRoaXMucGl4ZWxbM10gPDwgMjQpKSA+Pj4gMDtcblxuICAgICAgICAgICAgICAgIC8vIElmIGZlYXR1cmUgZm91bmQsIGFzayBhcHByb3ByaWF0ZSB3ZWIgd29ya2VyIHRvIGxvb2t1cCBmZWF0dXJlXG4gICAgICAgICAgICAgICAgdmFyIHdvcmtlcl9pZCA9IHRoaXMucGl4ZWxbM107XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtlcl9pZCAhPT0gMjU1KSB7IC8vIDI1NSBpbmRpY2F0ZXMgYW4gZW1wdHkgc2VsZWN0aW9uIGJ1ZmZlciBwaXhlbFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy53b3JrZXJzW3dvcmtlcl9pZF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud29ya2Vyc1t3b3JrZXJfaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdnZXRGZWF0dXJlU2VsZWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGlkOiByZXF1ZXN0LmlkLCBrZXk6IGZlYXR1cmVfa2V5IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaFJlYWQobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBObyBmZWF0dXJlIGZvdW5kLCBidXQgc3RpbGwgbmVlZCB0byByZXNvbHZlIHByb21pc2VcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5pc2hSZWFkKHsgaWQ6IHJlcXVlc3QuaWQsIGZlYXR1cmU6IG51bGwgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuICAgICAgICB9LCB0aGlzLnJlYWRfZGVsYXkpO1xuICAgIH1cblxuICAgIC8vIENhbGxlZCBvbiBtYWluIHRocmVhZCB3aGVuIGEgd2ViIHdvcmtlciBmaW5kcyBhIGZlYXR1cmUgaW4gdGhlIHNlbGVjdGlvbiBidWZmZXJcbiAgICBmaW5pc2hSZWFkIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0c1ttZXNzYWdlLmlkXTtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGZWF0dXJlU2VsZWN0aW9uLmZpbmlzaFJlYWQoKSBjYWxsZWQgd2l0aG91dCBhbnkgbWVzc2FnZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmZWF0dXJlID0gbWVzc2FnZS5mZWF0dXJlO1xuICAgICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoKGZlYXR1cmUgIT0gbnVsbCAmJiB0aGlzLmZlYXR1cmUgPT0gbnVsbCkgfHxcbiAgICAgICAgICAgIChmZWF0dXJlID09IG51bGwgJiYgdGhpcy5mZWF0dXJlICE9IG51bGwpIHx8XG4gICAgICAgICAgICAoZmVhdHVyZSAhPSBudWxsICYmIHRoaXMuZmVhdHVyZSAhPSBudWxsICYmIGZlYXR1cmUuaWQgIT09IHRoaXMuZmVhdHVyZS5pZCkpIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mZWF0dXJlID0gZmVhdHVyZTsgLy8gc3RvcmUgdGhlIG1vc3QgcmVjZW50bHkgc2VsZWN0ZWQgZmVhdHVyZVxuXG4gICAgICAgIC8vIFJlc29sdmUgdGhlIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdC5yZXNvbHZlKHsgZmVhdHVyZSwgY2hhbmdlZCwgcmVxdWVzdCB9KTtcbiAgICAgICAgZGVsZXRlIHRoaXMucmVxdWVzdHNbbWVzc2FnZS5pZF07IC8vIGRvbmUgcHJvY2Vzc2luZyB0aGlzIHJlcXVlc3RcbiAgICB9XG5cblxuICAgIC8vIFNlbGVjdGlvbiBtYXAgZ2VuZXJhdGlvblxuICAgIC8vIEVhY2ggd29ya2VyIHdpbGwgY3JlYXRlIGl0cyBvd24gaW5kZXBlbmRlbnQsICdsb2NhbCcgc2VsZWN0aW9uIG1hcFxuXG4gICAgLy8gQ3JlYXRlIGEgdW5pcXVlIDMyLWJpdCBjb2xvciB0byBpZGVudGlmeSBhIGZlYXR1cmVcbiAgICAvLyBXb3JrZXJzIGluZGVwZW5kZW50bHkgY3JlYXRlL21vZGlmeSBzZWxlY3Rpb24gY29sb3JzIGluIHRoZWlyIG93biB0aHJlYWRzLCBidXQgd2UgYWxzb1xuICAgIC8vIG5lZWQgdGhlIG1haW4gdGhyZWFkIHRvIGtub3cgd2hlcmUgZWFjaCBmZWF0dXJlIGNvbG9yIG9yaWdpbmF0ZWQuIFRvIGFjY29tcGxpc2ggdGhpcyxcbiAgICAvLyB3ZSBwYXJ0aXRpb24gdGhlIG1hcCBieSBzZXR0aW5nIHRoZSA0dGggY29tcG9uZW50IChhbHBoYSBjaGFubmVsKSB0byB0aGUgd29ya2VyJ3MgaWQuXG4gICAgc3RhdGljIG1ha2VFbnRyeSh0aWxlKSB7XG4gICAgICAgIC8vIDMyLWJpdCBjb2xvciBrZXlcbiAgICAgICAgdGhpcy5tYXBfZW50cnkrKztcbiAgICAgICAgdmFyIGlyID0gdGhpcy5tYXBfZW50cnkgJiAyNTU7XG4gICAgICAgIHZhciBpZyA9ICh0aGlzLm1hcF9lbnRyeSA+PiA4KSAmIDI1NTtcbiAgICAgICAgdmFyIGliID0gKHRoaXMubWFwX2VudHJ5ID4+IDE2KSAmIDI1NTtcbiAgICAgICAgdmFyIGlhID0gdGhpcy5tYXBfcHJlZml4O1xuICAgICAgICB2YXIgciA9IGlyIC8gMjU1O1xuICAgICAgICB2YXIgZyA9IGlnIC8gMjU1O1xuICAgICAgICB2YXIgYiA9IGliIC8gMjU1O1xuICAgICAgICB2YXIgYSA9IGlhIC8gMjU1O1xuICAgICAgICB2YXIga2V5ID0gKGlyICsgKGlnIDw8IDgpICsgKGliIDw8IDE2KSArIChpYSA8PCAyNCkpID4+PiAwOyAvLyBuZWVkIHVuc2lnbmVkIHJpZ2h0IHNoaWZ0IHRvIGNvbnZlcnQgdG8gcG9zaXRpdmUgI1xuXG4gICAgICAgIHRoaXMubWFwW2tleV0gPSB7XG4gICAgICAgICAgICBjb2xvcjogW3IsIGcsIGIsIGFdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1hcF9zaXplKys7XG5cbiAgICAgICAgdGhpcy50aWxlc1t0aWxlLmtleV0gPSB0aGlzLnRpbGVzW3RpbGUua2V5XSB8fCBbXTtcbiAgICAgICAgdGhpcy50aWxlc1t0aWxlLmtleV0ucHVzaChrZXkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLm1hcFtrZXldO1xuICAgIH1cblxuICAgIHN0YXRpYyBtYWtlQ29sb3IoZmVhdHVyZSwgdGlsZSkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLm1ha2VFbnRyeSh0aWxlKTtcbiAgICAgICAgc2VsZWN0b3IuZmVhdHVyZSA9IHtcbiAgICAgICAgICAgIGlkOiBmZWF0dXJlLmlkLFxuICAgICAgICAgICAgcHJvcGVydGllczogZmVhdHVyZS5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgdGlsZTogdGlsZS5rZXlcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VsZWN0b3IuY29sb3I7XG4gICAgfVxuXG4gICAgc3RhdGljIHJlc2V0KCkge1xuICAgICAgICB0aGlzLm1hcCA9IHt9O1xuICAgICAgICB0aGlzLm1hcF9zaXplID0gMDtcbiAgICAgICAgdGhpcy5tYXBfZW50cnkgPSAwO1xuICAgIH1cblxuICAgIHN0YXRpYyBjbGVhclRpbGUoa2V5KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMudGlsZXNba2V5XSkpIHtcbiAgICAgICAgICAgIHRoaXMudGlsZXNba2V5XS5mb3JFYWNoKGsgPT4gZGVsZXRlIHRoaXMubWFwW2tdKTtcbiAgICAgICAgICAgIHRoaXMubWFwX3NpemUgLT0gdGhpcy50aWxlc1trZXldLmxlbmd0aDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRpbGVzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0TWFwU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwX3NpemU7XG4gICAgfVxuXG4gICAgc3RhdGljIHNldFByZWZpeChwcmVmaXgpIHtcbiAgICAgICAgdGhpcy5tYXBfcHJlZml4ID0gcHJlZml4O1xuICAgIH1cblxufVxuXG4vLyBTdGF0aWMgcHJvcGVydGllc1xuRmVhdHVyZVNlbGVjdGlvbi5tYXAgPSB7fTsgICAvLyB0aGlzIHdpbGwgYmUgdW5pcXVlIHBlciBtb2R1bGUgaW5zdGFuY2UgKHNvIHVuaXF1ZSBwZXIgd29ya2VyKVxuRmVhdHVyZVNlbGVjdGlvbi50aWxlcyA9IHt9OyAvLyBzZWxlY3Rpb24ga2V5cywgYnkgdGlsZVxuRmVhdHVyZVNlbGVjdGlvbi5tYXBfc2l6ZSA9IDA7XG5GZWF0dXJlU2VsZWN0aW9uLm1hcF9lbnRyeSA9IDA7XG5GZWF0dXJlU2VsZWN0aW9uLm1hcF9wcmVmaXggPSAwOyAvLyBzZXQgYnkgd29ya2VyIHRvIHdvcmtlciBpZCAjXG5GZWF0dXJlU2VsZWN0aW9uLmRlZmF1bHRDb2xvciA9IFswLCAwLCAwLCAxXTtcbiIsIi8qanNoaW50IHdvcmtlcjogdHJ1ZSAqL1xuaW1wb3J0IEdlbyBmcm9tICcuLi9nZW8nO1xuaW1wb3J0IHtNZXRob2ROb3RJbXBsZW1lbnRlZH0gZnJvbSAnLi4vdXRpbHMvZXJyb3JzJztcbmltcG9ydCBVdGlscyBmcm9tICcuLi91dGlscy91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGFTb3VyY2Uge1xuXG4gICAgY29uc3RydWN0b3IgKHNvdXJjZSkge1xuICAgICAgICB0aGlzLmlkID0gc291cmNlLmlkO1xuICAgICAgICB0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcbiAgICAgICAgdGhpcy51cmwgPSBzb3VyY2UudXJsO1xuICAgICAgICB0aGlzLnBhZF9zY2FsZSA9IHNvdXJjZS5wYWRfc2NhbGUgfHwgMC4wMDA1OyAvLyBzY2FsZSB0aWxlIHVwIGJ5IHNtYWxsIGZhY3RvciB0byBjb3ZlciBzZWFtc1xuICAgICAgICB0aGlzLmVuZm9yY2Vfd2luZGluZyA9IHNvdXJjZS5lbmZvcmNlX3dpbmRpbmcgfHwgZmFsc2U7IC8vIHdoZXRoZXIgdG8gZW5mb3JjZSB3aW5kaW5nIG9yZGVyXG5cbiAgICAgICAgLy8gT3B0aW9uYWwgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIHNvdXJjZSBkYXRhXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gc291cmNlLnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0uYmluZCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9wdGlvbmFsIGFkZGl0aW9uYWwgZGF0YSB0byBwYXNzIHRvIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb25cbiAgICAgICAgdGhpcy5leHRyYV9kYXRhID0gc291cmNlLmV4dHJhX2RhdGE7XG5cbiAgICAgICAgLy8gT3B0aW9uYWwgYWRkaXRpb25hbCBzY3JpcHRzIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb25cbiAgICAgICAgaWYgKHR5cGVvZiBpbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nICYmIHNvdXJjZS5zY3JpcHRzKSB7XG4gICAgICAgICAgICBzb3VyY2Uuc2NyaXB0cy5mb3JFYWNoKGZ1bmN0aW9uKHMsIHNpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0U2NyaXB0cyhzKTtcbiAgICAgICAgICAgICAgICAgICAgVXRpbHMubG9nKCdpbmZvJywgJ0RhdGFTb3VyY2U6IGxvYWRlZCBsaWJyYXJ5OiAnICsgcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIFV0aWxzLmxvZygnZXJyb3InLCAnRGF0YVNvdXJjZTogZmFpbGVkIHRvIGxvYWQgbGlicmFyeTogJyArIHMpO1xuICAgICAgICAgICAgICAgICAgICBVdGlscy5sb2coJ2Vycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdmVyem9vbSB3aWxsIGFwcGx5IGZvciB6b29tcyBoaWdoZXIgdGhhbiB0aGlzXG4gICAgICAgIHRoaXMubWF4X3pvb20gPSBNYXRoLm1pbihzb3VyY2UubWF4X3pvb20gfHwgR2VvLm1heF96b29tLCBHZW8ubWF4X3pvb20pO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIHRpbGUgc291cmNlIGJ5IHR5cGUsIGZhY3Rvcnktc3R5bGVcbiAgICBzdGF0aWMgY3JlYXRlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKERhdGFTb3VyY2UudHlwZXNbc291cmNlLnR5cGVdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGFTb3VyY2UudHlwZXNbc291cmNlLnR5cGVdKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNZXJjYXRvciBwcm9qZWN0aW9uXG4gICAgc3RhdGljIHByb2plY3REYXRhIChzb3VyY2UpIHtcbiAgICAgICAgdmFyIHRpbWVyID0gK25ldyBEYXRlKCk7XG4gICAgICAgIGZvciAodmFyIHQgaW4gc291cmNlLmxheWVycykge1xuICAgICAgICAgICAgdmFyIG51bV9mZWF0dXJlcyA9IHNvdXJjZS5sYXllcnNbdF0uZmVhdHVyZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgZj0wOyBmIDwgbnVtX2ZlYXR1cmVzOyBmKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZSA9IHNvdXJjZS5sYXllcnNbdF0uZmVhdHVyZXNbZl07XG4gICAgICAgICAgICAgICAgR2VvLnRyYW5zZm9ybUdlb21ldHJ5KGZlYXR1cmUuZ2VvbWV0cnksIGNvb3JkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFt4LCB5XSA9IEdlby5sYXRMbmdUb01ldGVycyhjb29yZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkWzBdID0geDtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRbMV0gPSB5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvdXJjZS5kZWJ1ZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzb3VyY2UuZGVidWcucHJvamVjdGlvbiA9ICtuZXcgRGF0ZSgpIC0gdGltZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgUmUtc2NhbGUgZ2VvbWV0cmllcyB3aXRoaW4gZWFjaCBzb3VyY2UgdG8gaW50ZXJuYWwgdGlsZSB1bml0c1xuICAgICovXG4gICAgc3RhdGljIHNjYWxlRGF0YSAoc291cmNlLCB7Y29vcmRzOiB7en0sIG1pbiwgbWF4fSkge1xuICAgICAgICBmb3IgKHZhciB0IGluIHNvdXJjZS5sYXllcnMpIHtcbiAgICAgICAgICAgIHZhciBudW1fZmVhdHVyZXMgPSBzb3VyY2UubGF5ZXJzW3RdLmZlYXR1cmVzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGY9MDsgZiA8IG51bV9mZWF0dXJlczsgZisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBzb3VyY2UubGF5ZXJzW3RdLmZlYXR1cmVzW2ZdO1xuICAgICAgICAgICAgICAgIEdlby50cmFuc2Zvcm1HZW9tZXRyeShmZWF0dXJlLmdlb21ldHJ5LCBjb29yZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkWzBdID0gKGNvb3JkWzBdIC0gbWluLngpICogR2VvLnVuaXRzX3Blcl9tZXRlclt6XTtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRbMV0gPSAoY29vcmRbMV0gLSBtaW4ueSkgKiBHZW8udW5pdHNfcGVyX21ldGVyW3pdICogLTE7IC8vIGZsaXAgY29vcmRzIHBvc2l0aXZlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsb2FkKGRlc3QpIHtcbiAgICAgICAgZGVzdC5zb3VyY2VfZGF0YSA9IHt9O1xuICAgICAgICBkZXN0LnNvdXJjZV9kYXRhLmxheWVycyA9IHt9O1xuICAgICAgICBkZXN0LnBhZF9zY2FsZSA9IHRoaXMucGFkX3NjYWxlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkKGRlc3QpLnRoZW4oKGRlc3QpID0+IHtcbiAgICAgICAgICAgIC8vIFBvc3QtcHJvY2Vzc2luZ1xuICAgICAgICAgICAgZm9yIChsZXQgbGF5ZXIgaW4gZGVzdC5zb3VyY2VfZGF0YS5sYXllcnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IGRlc3Quc291cmNlX2RhdGEubGF5ZXJzW2xheWVyXTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmZlYXR1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZmVhdHVyZXMuZm9yRWFjaChmZWF0dXJlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEdlby50cmFuc2Zvcm1HZW9tZXRyeShmZWF0dXJlLmdlb21ldHJ5LCBjb29yZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmxpcCBZIGNvb3Jkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkWzFdID0gLWNvb3JkWzFdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2xpZ2h0bHkgc2NhbGUgdXAgdGlsZSB0byBjb3ZlciBzZWFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhZF9zY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZFswXSA9IE1hdGgucm91bmQoY29vcmRbMF0gKiAoMSArIHRoaXMucGFkX3NjYWxlKSAtIChHZW8udGlsZV9zY2FsZSAqIHRoaXMucGFkX3NjYWxlLzIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRbMV0gPSBNYXRoLnJvdW5kKGNvb3JkWzFdICogKDEgKyB0aGlzLnBhZF9zY2FsZSkgLSAoR2VvLnRpbGVfc2NhbGUgKiB0aGlzLnBhZF9zY2FsZS8yKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wdGlvbmFsbHkgZW5mb3JjZSB3aW5kaW5nIG9yZGVyIHNpbmNlIG5vdCBhbGwgZGF0YSBzb3VyY2VzIGd1YXJhbnRlZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5mb3JjZV93aW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgR2VvLmVuZm9yY2VXaW5kaW5nKGZlYXR1cmUuZ2VvbWV0cnksICdDQ1cnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTdWItY2xhc3NlcyBtdXN0IGltcGxlbWVudFxuICAgIF9sb2FkKGRlc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1ldGhvZE5vdEltcGxlbWVudGVkKCdfbG9hZCcpO1xuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyIGEgbmV3IGRhdGEgc291cmNlIHR5cGUsIHVuZGVyIGEgdHlwZSBuYW1lXG4gICAgc3RhdGljIHJlZ2lzdGVyKHR5cGVfY2xhc3MsIHR5cGVfbmFtZSkge1xuICAgICAgICBpZiAoIXR5cGVfY2xhc3MgfHwgIXR5cGVfbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgRGF0YVNvdXJjZS50eXBlc1t0eXBlX25hbWVdID0gdHlwZV9jbGFzcztcbiAgICB9XG5cbn1cblxuRGF0YVNvdXJjZS50eXBlcyA9IHt9OyAvLyBzZXQgb2Ygc3VwcG9ydGVkIGRhdGEgc291cmNlIGNsYXNzZXMsIHJlZmVyZW5jZWQgYnkgdHlwZSBuYW1lXG5cblxuLyoqKiBHZW5lcmljIG5ldHdvcmsgbG9hZGluZyBzb3VyY2UgLSBhYnN0cmFjdCBjbGFzcyAqKiovXG5cbmV4cG9ydCBjbGFzcyBOZXR3b3JrU291cmNlIGV4dGVuZHMgRGF0YVNvdXJjZSB7XG5cbiAgICBjb25zdHJ1Y3RvciAoc291cmNlKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZSk7XG4gICAgICAgIHRoaXMucmVzcG9uc2VfdHlwZSA9IFwiXCI7IC8vIHVzZSB0byBzZXQgZXhwbGljaXQgWEhSIHR5cGVcbiAgICB9XG5cbiAgICBfbG9hZCAoZGVzdCkge1xuICAgICAgICAvLyBzdXBlci5sb2FkKGRlc3QpO1xuXG4gICAgICAgIGxldCB1cmwgPSB0aGlzLmZvcm1hdFVybChkZXN0KTtcblxuICAgICAgICBsZXQgc291cmNlX2RhdGEgPSBkZXN0LnNvdXJjZV9kYXRhO1xuICAgICAgICBzb3VyY2VfZGF0YS51cmwgPSB1cmw7XG4gICAgICAgIGRlc3QuZGVidWcgPSBkZXN0LmRlYnVnIHx8IHt9O1xuICAgICAgICBkZXN0LmRlYnVnLm5ldHdvcmsgPSArbmV3IERhdGUoKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgc291cmNlX2RhdGEuZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgLy8gRm9yIHRlc3RpbmcgbmV0d29yayBlcnJvcnNcbiAgICAgICAgICAgIC8vIHZhciBwcm9taXNlID0gVXRpbHMuaW8odXJsLCA2MCAqIDEwMCwgdGhpcy5yZXNwb25zZV90eXBlKTtcbiAgICAgICAgICAgIC8vIGlmIChNYXRoLnJhbmRvbSgpIDwgLjcpIHtcbiAgICAgICAgICAgIC8vICAgICBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QoRXJyb3IoJ2Zha2UgZGF0YSBzb3VyY2UgZXJyb3InKSk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyBwcm9taXNlLnRoZW4oKGJvZHkpID0+IHtcbiAgICAgICAgICAgIGxldCBwcm9taXNlID0gVXRpbHMuaW8odXJsLCA2MCAqIDEwMDAsIHRoaXMucmVzcG9uc2VfdHlwZSk7XG4gICAgICAgICAgICBzb3VyY2VfZGF0YS5yZXF1ZXN0ID0gcHJvbWlzZS5yZXF1ZXN0O1xuXG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oKGJvZHkpID0+IHtcbiAgICAgICAgICAgICAgICBkZXN0LmRlYnVnLnJlc3BvbnNlX3NpemUgPSBib2R5Lmxlbmd0aCB8fCBib2R5LmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgZGVzdC5kZWJ1Zy5uZXR3b3JrID0gK25ldyBEYXRlKCkgLSBkZXN0LmRlYnVnLm5ldHdvcms7XG4gICAgICAgICAgICAgICAgZGVzdC5kZWJ1Zy5wYXJzaW5nID0gK25ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVNvdXJjZURhdGEoZGVzdCwgc291cmNlX2RhdGEsIGJvZHkpO1xuICAgICAgICAgICAgICAgIGRlc3QuZGVidWcucGFyc2luZyA9ICtuZXcgRGF0ZSgpIC0gZGVzdC5kZWJ1Zy5wYXJzaW5nO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGVzdCk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBzb3VyY2VfZGF0YS5lcnJvciA9IGVycm9yLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkZXN0KTsgLy8gcmVzb2x2ZSByZXF1ZXN0IGJ1dCBwYXNzIGFsb25nIGVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU3ViLWNsYXNzZXMgbXVzdCBpbXBsZW1lbnQ6XG5cbiAgICBmb3JtYXRVcmwgKGRlc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1ldGhvZE5vdEltcGxlbWVudGVkKCdmb3JtYXRVcmwnKTtcbiAgICB9XG5cbiAgICBwYXJzZVNvdXJjZURhdGEgKGRlc3QsIHNvdXJjZSwgcmVwb25zZSkge1xuICAgICAgICB0aHJvdyBuZXcgTWV0aG9kTm90SW1wbGVtZW50ZWQoJ3BhcnNlU291cmNlRGF0YScpO1xuICAgIH1cbn1cblxuXG4vKioqIEdlbmVyaWMgbmV0d29yayB0aWxlIGxvYWRpbmcgLSBhYnN0cmFjdCBjbGFzcyAqKiovXG5cbmV4cG9ydCBjbGFzcyBOZXR3b3JrVGlsZVNvdXJjZSBleHRlbmRzIE5ldHdvcmtTb3VyY2Uge1xuXG4gICAgY29uc3RydWN0b3IgKHNvdXJjZSkge1xuICAgICAgICBzdXBlcihzb3VyY2UpO1xuXG4gICAgICAgIHRoaXMudGlsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnVybF9ob3N0cyA9IG51bGw7XG4gICAgICAgIHZhciBob3N0X21hdGNoID0gdGhpcy51cmwubWF0Y2goL3tzOlxcWyhbXn0rXSspXFxdfS8pO1xuICAgICAgICBpZiAoaG9zdF9tYXRjaCAhPSBudWxsICYmIGhvc3RfbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy51cmxfaG9zdHMgPSBob3N0X21hdGNoWzFdLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICB0aGlzLm5leHRfaG9zdCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3JtYXRVcmwodGlsZSkge1xuICAgICAgICBsZXQgY29vcmRzID0gR2VvLndyYXBUaWxlKHRpbGUuY29vcmRzLCB7IHg6IHRydWUgfSk7XG4gICAgICAgIHZhciB1cmwgPSB0aGlzLnVybC5yZXBsYWNlKCd7eH0nLCBjb29yZHMueCkucmVwbGFjZSgne3l9JywgY29vcmRzLnkpLnJlcGxhY2UoJ3t6fScsIGNvb3Jkcy56KTtcblxuICAgICAgICBpZiAodGhpcy51cmxfaG9zdHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoL3tzOlxcWyhbXn0rXSspXFxdfS8sIHRoaXMudXJsX2hvc3RzW3RoaXMubmV4dF9ob3N0XSk7XG4gICAgICAgICAgICB0aGlzLm5leHRfaG9zdCA9ICh0aGlzLm5leHRfaG9zdCArIDEpICUgdGhpcy51cmxfaG9zdHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2tzIGZvciB0aGUgeC95L3ogdGlsZSBwYXR0ZXJuIGluIFVSTCB0ZW1wbGF0ZVxuICAgIHVybEhhc1RpbGVQYXR0ZXJuKHVybCkge1xuICAgICAgICByZXR1cm4gdXJsICYmXG4gICAgICAgICAgICB1cmwuc2VhcmNoKCd7eH0nKSA+IC0xICYmXG4gICAgICAgICAgICB1cmwuc2VhcmNoKCd7eX0nKSA+IC0xICYmXG4gICAgICAgICAgICB1cmwuc2VhcmNoKCd7en0nKSA+IC0xO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IERhdGFTb3VyY2UsIHtOZXR3b3JrU291cmNlLCBOZXR3b3JrVGlsZVNvdXJjZX0gZnJvbSAnLi9kYXRhX3NvdXJjZSc7XG5pbXBvcnQgR2VvIGZyb20gJy4uL2dlbyc7XG5cbi8vIEZvciB0aWxpbmcgR2VvSlNPTiBjbGllbnQtc2lkZVxuaW1wb3J0IGdlb2pzb252dCBmcm9tICdnZW9qc29uLXZ0JztcblxuXG4vKipcbiBNYXB6ZW4vT1NNLlVTLXN0eWxlIEdlb0pTT04gdmVjdG9yIHRpbGVzXG4gQGNsYXNzIEdlb0pTT05UaWxlU291cmNlXG4qL1xuZXhwb3J0IGNsYXNzIEdlb0pTT05UaWxlU291cmNlIGV4dGVuZHMgTmV0d29ya1RpbGVTb3VyY2Uge1xuXG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIFVSTCB0aWxlIHBhdHRlcm4sIGlmIG5vdCBmb3VuZCwgdHJlYXQgYXMgc3RhbmRhbG9uZSBHZW9KU09OL1RvcG9KU09OIG9iamVjdFxuICAgICAgICBpZiAoIXRoaXMudXJsSGFzVGlsZVBhdHRlcm4odGhpcy51cmwpKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpbnN0YW5jZSB0eXBlIGZyb20gcGFyZW50IGNsYXNzXG4gICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEdlb0pTT05UaWxlU291cmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBpbnN0YW5jZSB0eXBlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW9KU09OU291cmNlKHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBQYXNzIGJhY2sgdG8gcGFyZW50IGNsYXNzIHRvIGluc3RhbnRpYXRlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcGFyc2VTb3VyY2VEYXRhICh0aWxlLCBzb3VyY2UsIHJlc3BvbnNlKSB7XG4gICAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZSk7XG4gICAgICAgIHRoaXMucHJlcGFyZUdlb0pTT04oZGF0YSwgdGlsZSwgc291cmNlKTtcbiAgICB9XG5cbiAgICBwcmVwYXJlR2VvSlNPTiAoZGF0YSwgdGlsZSwgc291cmNlKSB7XG4gICAgICAgIC8vIEFwcGx5IG9wdGlvbmFsIGRhdGEgdHJhbnNmb3JtXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLnRyYW5zZm9ybShkYXRhLCBzb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc291cmNlLmxheWVycyA9IEdlb0pTT05Tb3VyY2UucHJvdG90eXBlLmdldExheWVycyhkYXRhKTtcblxuICAgICAgICAvLyBBIFwic3ludGhldGljXCIgdGlsZSB0aGF0IGFkanVzdHMgdGhlIHRpbGUgbWluIGFuY2hvciB0byBhY2NvdW50IGZvciB0aWxlIGxvbmdpdHVkZSB3cmFwcGluZ1xuICAgICAgICBsZXQgYW5jaG9yID0ge1xuICAgICAgICAgICAgY29vcmRzOiB0aWxlLmNvb3JkcyxcbiAgICAgICAgICAgIG1pbjogR2VvLm1ldGVyc0ZvclRpbGUoR2VvLndyYXBUaWxlKHRpbGUuY29vcmRzLCB7IHg6IHRydWUgfSkpXG4gICAgICAgIH07XG5cbiAgICAgICAgRGF0YVNvdXJjZS5wcm9qZWN0RGF0YShzb3VyY2UpOyAvLyBtZXJjYXRvciBwcm9qZWN0aW9uXG4gICAgICAgIERhdGFTb3VyY2Uuc2NhbGVEYXRhKHNvdXJjZSwgYW5jaG9yKTsgLy8gcmUtc2NhbGUgZnJvbSBtZXRlcnMgdG8gbG9jYWwgdGlsZSBjb29yZHNcbiAgICB9XG5cbn1cblxuXG4vKipcbiBHZW9KU09OIHN0YW5kYWxvbmUgKG5vbi10aWxlZCkgc291cmNlXG4gVXNlcyBnZW9qc29uLXZ0IHNwbGl0IGludG8gdGlsZXMgY2xpZW50LXNpZGVcbiovXG5cbmV4cG9ydCBjbGFzcyBHZW9KU09OU291cmNlIGV4dGVuZHMgTmV0d29ya1NvdXJjZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoc291cmNlKTtcbiAgICAgICAgdGhpcy50aWxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubG9hZF9kYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy50aWxlX2luZGV4ZXMgPSB7fTsgLy8gZ2VvanNvbi12dCB0aWxlIGluZGljZXMsIGJ5IGxheWVyIG5hbWVcbiAgICAgICAgdGhpcy5tYXhfem9vbSA9IE1hdGgubWF4KHRoaXMubWF4X3pvb20gfHwgMCwgMTUpOyAvLyBUT0RPOiBtYXggem9vbSA8IDE1IGNhdXNlcyBhcnRpZmFjdHMvbm8tZHJhdyBhdCAyMCwgaW52ZXN0aWdhdGVcbiAgICAgICAgdGhpcy5wYWRfc2NhbGUgPSAwOyAvLyB3ZSBkb24ndCB3YW50IHBhZGRpbmcgb24gYXV0by10aWxlZCBzb3VyY2VzXG4gICAgICAgIHRoaXMuZW5mb3JjZV93aW5kaW5nID0gKHNvdXJjZS5lbmZvcmNlX3dpbmRpbmcgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZTsgLy8gZGVmYXVsdCBvbiwgY2FuIGJlIGZvcmNlZCBvZmZcbiAgICB9XG5cbiAgICBfbG9hZChkZXN0KSB7XG4gICAgICAgIGlmICghdGhpcy5sb2FkX2RhdGEpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZF9kYXRhID0gc3VwZXIuX2xvYWQoeyBzb3VyY2VfZGF0YTogeyBsYXllcnM6IHt9IH0gfSkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbGF5ZXJzID0gZGF0YS5zb3VyY2VfZGF0YS5sYXllcnM7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbGF5ZXJfbmFtZSBpbiBsYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aWxlX2luZGV4ZXNbbGF5ZXJfbmFtZV0gPSBnZW9qc29udnQobGF5ZXJzW2xheWVyX25hbWVdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhab29tOiB0aGlzLm1heF96b29tLCAgLy8gbWF4IHpvb20gdG8gcHJlc2VydmUgZGV0YWlsIG9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2xlcmFuY2U6IDMsIC8vIHNpbXBsaWZpY2F0aW9uIHRvbGVyYW5jZSAoaGlnaGVyIG1lYW5zIHNpbXBsZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnQ6IEdlby50aWxlX3NjYWxlLCAvLyB0aWxlIGV4dGVudCAoYm90aCB3aWR0aCBhbmQgaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiAwICAgICAvLyB0aWxlIGJ1ZmZlciBvbiBlYWNoIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkX2RhdGEudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBsYXllcl9uYW1lIGluIHRoaXMudGlsZV9pbmRleGVzKSB7XG4gICAgICAgICAgICAgICAgZGVzdC5zb3VyY2VfZGF0YS5sYXllcnNbbGF5ZXJfbmFtZV0gPSB0aGlzLmdldFRpbGVGZWF0dXJlcyhkZXN0LCBsYXllcl9uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRUaWxlRmVhdHVyZXModGlsZSwgbGF5ZXJfbmFtZSkge1xuICAgICAgICBsZXQgY29vcmRzID0gR2VvLndyYXBUaWxlKHRpbGUuY29vcmRzLCB7IHg6IHRydWUgfSk7XG5cbiAgICAgICAgLy8gcmVxdWVzdCBhIHBhcnRpY3VsYXIgdGlsZVxuICAgICAgICBsZXQgdCA9IHRoaXMudGlsZV9pbmRleGVzW2xheWVyX25hbWVdLmdldFRpbGUoY29vcmRzLnosIGNvb3Jkcy54LCBjb29yZHMueSk7XG5cbiAgICAgICAgLy8gQ29udmVydCBmcm9tIE1WVC1zdHlsZSBKU09OIHN0cnVjdCB0byBHZW9KU09OXG4gICAgICAgIGxldCBjb2xsZWN0aW9uO1xuICAgICAgICBpZiAodCAmJiB0LmZlYXR1cmVzKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgICAgICAgICAgZmVhdHVyZXM6IFtdXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKGxldCBmZWF0dXJlIG9mIHQuZmVhdHVyZXMpIHtcblxuICAgICAgICAgICAgICAgIC8vIENvcHkgZ2VvbWV0cnkgKGRvbid0IHdhbnQgdG8gbW9kaWZ5IGludGVybmFsIGdlb2pzb24tdnQgZGF0YSlcbiAgICAgICAgICAgICAgICBsZXQgZ2VvbSA9IGZlYXR1cmUuZ2VvbWV0cnkubWFwKHJpbmcgPT5cbiAgICAgICAgICAgICAgICAgICAgcmluZy5tYXAoY29vcmQgPT4gW2Nvb3JkWzBdLCBjb29yZFsxXV0pXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGxldCB0eXBlO1xuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLnR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdNdWx0aVBvaW50JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmVhdHVyZS50eXBlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnTXVsdGlMaW5lU3RyaW5nJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmVhdHVyZS50eXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnTXVsdGlQb2x5Z29uJztcbiAgICAgICAgICAgICAgICAgICAgZ2VvbSA9IHRoaXMuZGVjb2RlTXVsdGlQb2x5Z29uKGdlb20pOyAvLyB1bi1mbGF0dGVuIHJpbmdzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgZiA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBnZW9tXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IGZlYXR1cmUudGFnc1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmZlYXR1cmVzLnB1c2goZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICAvLyBEZWNvZGUgbXVsdGlwb2x5Z29ucywgd2hpY2ggYXJlIGVuY29kZWQgYXMgYSBzaW5nbGUgc2V0IG9mIHJpbmdzXG4gICAgLy8gT3V0ZXIgcmluZ3MgYXJlIHdvdW5kIENDVywgaW5uZXIgYXJlIENXXG4gICAgLy8gQSBDQ1cgcmluZyBpbmRpY2F0ZXMgdGhlIHN0YXJ0IG9mIGEgbmV3IHBvbHlnb25cbiAgICBkZWNvZGVNdWx0aVBvbHlnb24gKGdlb20pIHtcbiAgICAgICAgbGV0IHBvbHlzID0gW107XG4gICAgICAgIGxldCBwb2x5ID0gW107XG4gICAgICAgIGZvciAobGV0IHJpbmcgb2YgZ2VvbSkge1xuICAgICAgICAgICAgbGV0IHdpbmRpbmcgPSBHZW8ucmluZ1dpbmRpbmcocmluZyk7XG4gICAgICAgICAgICBpZiAod2luZGluZyA9PT0gJ0NDVycgJiYgcG9seS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcG9seXMucHVzaChwb2x5KTtcbiAgICAgICAgICAgICAgICBwb2x5ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2x5LnB1c2gocmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvbHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcG9seXMucHVzaChwb2x5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9seXM7XG4gICAgfVxuXG4gICAgZm9ybWF0VXJsIChkZXN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVybDtcbiAgICB9XG5cbiAgICBwYXJzZVNvdXJjZURhdGEgKHRpbGUsIHNvdXJjZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgc291cmNlLmxheWVycyA9IHRoaXMuZ2V0TGF5ZXJzKEpTT04ucGFyc2UocmVzcG9uc2UpKTtcbiAgICB9XG5cbiAgICAvLyBEZXRlY3Qgc2luZ2xlIG9yIG11bHRpcGxlIGxheWVycyBpbiByZXR1cm5lZCBkYXRhXG4gICAgZ2V0TGF5ZXJzIChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdGZWF0dXJlJyB8fCBkYXRhLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB7IF9kZWZhdWx0OiBkYXRhIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5EYXRhU291cmNlLnJlZ2lzdGVyKEdlb0pTT05UaWxlU291cmNlLCAnR2VvSlNPTicpOyAgICAgIC8vIHByZWZlcmVkIHNob3J0ZXIgbmFtZVxuRGF0YVNvdXJjZS5yZWdpc3RlcihHZW9KU09OVGlsZVNvdXJjZSwgJ0dlb0pTT05UaWxlcycpOyAvLyBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHlcbiIsImltcG9ydCBEYXRhU291cmNlLCB7TmV0d29ya1RpbGVTb3VyY2V9IGZyb20gJy4vZGF0YV9zb3VyY2UnO1xuXG5pbXBvcnQgUGJmIGZyb20gJ3BiZic7XG5pbXBvcnQge1ZlY3RvclRpbGUsIFZlY3RvclRpbGVGZWF0dXJlfSBmcm9tICd2ZWN0b3ItdGlsZSc7XG5cbi8qKlxuIE1hcGJveCBWZWN0b3IgVGlsZSBmb3JtYXRcbiBAY2xhc3MgTVZUU291cmNlXG4qL1xuZXhwb3J0IGNsYXNzIE1WVFNvdXJjZSBleHRlbmRzIE5ldHdvcmtUaWxlU291cmNlIHtcblxuICAgIGNvbnN0cnVjdG9yIChzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoc291cmNlKTtcbiAgICAgICAgdGhpcy5yZXNwb25zZV90eXBlID0gXCJhcnJheWJ1ZmZlclwiOyAvLyBiaW5hcnkgZGF0YVxuICAgIH1cblxuICAgIHBhcnNlU291cmNlRGF0YSAodGlsZSwgc291cmNlLCByZXNwb25zZSkge1xuICAgICAgICAvLyBDb252ZXJ0IE1hcGJveCB2ZWN0b3IgdGlsZSB0byBHZW9KU09OXG4gICAgICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpO1xuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IFBiZihkYXRhKTtcbiAgICAgICAgc291cmNlLmRhdGEgPSBuZXcgVmVjdG9yVGlsZShidWZmZXIpO1xuICAgICAgICBzb3VyY2UubGF5ZXJzID0gdGhpcy50b0dlb0pTT04oc291cmNlLmRhdGEpO1xuICAgICAgICBkZWxldGUgc291cmNlLmRhdGE7IC8vIGNvbW1lbnQgb3V0IHRvIHNhdmUgcmF3IGRhdGEgZm9yIGRlYnVnZ2luZ1xuICAgIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCBsYXllcnMvZmVhdHVyZXMgdXNpbmcgTWFwYm94IGxpYiBBUEksIGNvbnZlcnQgdG8gR2VvSlNPTiBmZWF0dXJlc1xuICAgIC8vIFJldHVybnMgYW4gb2JqZWN0IHdpdGgga2V5cyBmb3IgZWFjaCBsYXllciwgZS5nLiB7IGxheWVyOiBnZW9qc29uIH1cbiAgICB0b0dlb0pTT04gKHRpbGUpIHtcbiAgICAgICAgdmFyIGxheWVycyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBsIGluIHRpbGUubGF5ZXJzKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aWxlLmxheWVyc1tsXTtcbiAgICAgICAgICAgIHZhciBsYXllcl9nZW9qc29uID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgICAgICAgICAgZmVhdHVyZXM6IFtdXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBmPTA7IGYgPCBsYXllci5sZW5ndGg7IGYrKykge1xuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlID0gbGF5ZXIuZmVhdHVyZShmKTtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZV9nZW9qc29uID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiB7fSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogZmVhdHVyZS5wcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBnZW9tZXRyeSA9IGZlYXR1cmVfZ2VvanNvbi5nZW9tZXRyeTtcbiAgICAgICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBmZWF0dXJlLmxvYWRHZW9tZXRyeSgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHI9MDsgciA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByaW5nID0gY29vcmRpbmF0ZXNbcl07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGM9MDsgYyA8IHJpbmcubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpbmdbY10gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmluZ1tjXS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpbmdbY10ueVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5jb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzO1xuXG4gICAgICAgICAgICAgICAgaWYgKFZlY3RvclRpbGVGZWF0dXJlLnR5cGVzW2ZlYXR1cmUudHlwZV0gPT09ICdQb2ludCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkudHlwZSA9ICdQb2ludCc7XG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1bMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFZlY3RvclRpbGVGZWF0dXJlLnR5cGVzW2ZlYXR1cmUudHlwZV0gPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS50eXBlID0gJ0xpbmVTdHJpbmcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5jb29yZGluYXRlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LnR5cGUgPSAnTXVsdGlMaW5lU3RyaW5nJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChWZWN0b3JUaWxlRmVhdHVyZS50eXBlc1tmZWF0dXJlLnR5cGVdID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkudHlwZSA9ICdQb2x5Z29uJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsYXllcl9nZW9qc29uLmZlYXR1cmVzLnB1c2goZmVhdHVyZV9nZW9qc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxheWVyc1tsXSA9IGxheWVyX2dlb2pzb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxheWVycztcbiAgICB9XG5cbn1cblxuRGF0YVNvdXJjZS5yZWdpc3RlcihNVlRTb3VyY2UsICdNVlQnKTtcbiIsImltcG9ydCBEYXRhU291cmNlIGZyb20gJy4vZGF0YV9zb3VyY2UnO1xuaW1wb3J0IHtHZW9KU09OU291cmNlLCBHZW9KU09OVGlsZVNvdXJjZX0gZnJvbSAnLi9nZW9qc29uJztcblxuaW1wb3J0IHRvcG9qc29uIGZyb20gJ3RvcG9qc29uJztcblxuXG4vKipcbiBNYXB6ZW4vT1NNLlVTLXN0eWxlIFRvcG9KU09OIHZlY3RvciB0aWxlc1xuIEBjbGFzcyBUb3BvSlNPTlRpbGVTb3VyY2VcbiovXG5leHBvcnQgY2xhc3MgVG9wb0pTT05UaWxlU291cmNlIGV4dGVuZHMgR2VvSlNPTlRpbGVTb3VyY2Uge1xuXG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgIGxldCBfdGhpcyA9IHN1cGVyKHNvdXJjZSk7XG5cbiAgICAgICAgLy8gUmVwbGFjZSB3aXRoIG5vbi10aWxlZCBzb3VyY2UgaWYgdGlsZWQgc291cmNlIGZhaWxlZCB0byBpbnN0YW50aWF0ZVxuICAgICAgICBpZiAoX3RoaXMgIT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVG9wb0pTT05Tb3VyY2Uoc291cmNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhcnNlU291cmNlRGF0YSAodGlsZSwgc291cmNlLCByZXNwb25zZSkge1xuICAgICAgICBsZXQgZGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2UpO1xuICAgICAgICBkYXRhID0gVG9wb0pTT05Tb3VyY2UucHJvdG90eXBlLnRvR2VvSlNPTihkYXRhKTtcbiAgICAgICAgdGhpcy5wcmVwYXJlR2VvSlNPTihkYXRhLCB0aWxlLCBzb3VyY2UpO1xuICAgIH1cblxufVxuXG5cbi8qKlxuIFRvcG9KU09OIHN0YW5kYWxvbmUgKG5vbi10aWxlZCkgc291cmNlXG4gVXNlcyBnZW9qc29uLXZ0IHNwbGl0IGludG8gdGlsZXMgY2xpZW50LXNpZGVcbiovXG5cbmV4cG9ydCBjbGFzcyBUb3BvSlNPTlNvdXJjZSBleHRlbmRzIEdlb0pTT05Tb3VyY2Uge1xuXG4gICAgcGFyc2VTb3VyY2VEYXRhICh0aWxlLCBzb3VyY2UsIHJlc3BvbnNlKSB7XG4gICAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZSk7XG4gICAgICAgIGRhdGEgPSB0aGlzLnRvR2VvSlNPTihkYXRhKTtcbiAgICAgICAgc291cmNlLmxheWVycyA9IHRoaXMuZ2V0TGF5ZXJzKGRhdGEpO1xuICAgIH1cblxuICAgIHRvR2VvSlNPTiAoZGF0YSkge1xuICAgICAgICAvLyBTaW5nbGUgbGF5ZXJcbiAgICAgICAgaWYgKGRhdGEub2JqZWN0cyAmJlxuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YS5vYmplY3RzKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGxldCBsYXllciA9IE9iamVjdC5rZXlzKGRhdGEub2JqZWN0cylbMF07XG4gICAgICAgICAgICBkYXRhID0gdG9wb2pzb24uZmVhdHVyZShkYXRhLCBkYXRhLm9iamVjdHNbbGF5ZXJdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsZSBsYXllcnNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGF5ZXJzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gZGF0YS5vYmplY3RzKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJzW2tleV0gPSB0b3BvanNvbi5mZWF0dXJlKGRhdGEsIGRhdGEub2JqZWN0c1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEgPSBsYXllcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG59XG5cbkRhdGFTb3VyY2UucmVnaXN0ZXIoVG9wb0pTT05UaWxlU291cmNlLCAnVG9wb0pTT04nKTsgICAgICAgIC8vIHByZWZlcmVkIHNob3J0ZXIgbmFtZVxuRGF0YVNvdXJjZS5yZWdpc3RlcihUb3BvSlNPTlRpbGVTb3VyY2UsICdUb3BvSlNPTlRpbGVzJyk7ICAgLy8gZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5XG5cbiIsIi8vIEdlb21ldHJ5IGJ1aWxkaW5nIGZ1bmN0aW9uc1xuXG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5pbXBvcnQgR2VvIGZyb20gJy4uL2dlbyc7XG5cbmltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcblxudmFyIEJ1aWxkZXJzO1xuZXhwb3J0IGRlZmF1bHQgQnVpbGRlcnMgPSB7fTtcblxuQnVpbGRlcnMuZGVidWcgPSBmYWxzZTtcblxuQnVpbGRlcnMudGlsZV9ib3VuZHMgPSBbXG4gICAgeyB4OiAwLCB5OiAwfSxcbiAgICB7IHg6IEdlby50aWxlX3NjYWxlLCB5OiAtR2VvLnRpbGVfc2NhbGUgfSAvLyBUT0RPOiBjb3JyZWN0IGZvciBmbGlwcGVkIHktYXhpcz9cbl07XG5cbi8vIFJlLXNjYWxlIFVWcyBmcm9tIFswLCAxXSByYW5nZSB0byBhIHNtYWxsZXIgYXJlYSB3aXRoaW4gdGhlIGltYWdlXG5CdWlsZGVycy5zY2FsZVRleGNvb3Jkc1RvU3ByaXRlID0gZnVuY3Rpb24gKHV2LCBhcmVhX29yaWdpbiwgYXJlYV9zaXplLCB0ZXhfc2l6ZSkge1xuICAgIHZhciBhcmVhX29yaWdpbl95ID0gdGV4X3NpemVbMV0gLSBhcmVhX29yaWdpblsxXSAtIGFyZWFfc2l6ZVsxXTtcbiAgICB2YXIgc3V2ID0gW107XG4gICAgc3V2WzBdID0gKHV2WzBdICogYXJlYV9zaXplWzBdICsgYXJlYV9vcmlnaW5bMF0pIC8gdGV4X3NpemVbMF07XG4gICAgc3V2WzFdID0gKHV2WzFdICogYXJlYV9zaXplWzFdICsgYXJlYV9vcmlnaW5feSkgLyB0ZXhfc2l6ZVsxXTtcbiAgICByZXR1cm4gc3V2O1xufTtcblxuQnVpbGRlcnMuZ2V0VGV4Y29vcmRzRm9yU3ByaXRlID0gZnVuY3Rpb24gKGFyZWFfb3JpZ2luLCBhcmVhX3NpemUsIHRleF9zaXplKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgQnVpbGRlcnMuc2NhbGVUZXhjb29yZHNUb1Nwcml0ZShbMCwgMF0sIGFyZWFfb3JpZ2luLCBhcmVhX3NpemUsIHRleF9zaXplKSxcbiAgICAgICAgQnVpbGRlcnMuc2NhbGVUZXhjb29yZHNUb1Nwcml0ZShbMSwgMV0sIGFyZWFfb3JpZ2luLCBhcmVhX3NpemUsIHRleF9zaXplKVxuICAgIF07XG59O1xuXG4vLyBUZXNzZWxhdGUgYSBmbGF0IDJEIHBvbHlnb25cbi8vIHggJiB5IGNvb3JkaW5hdGVzIHdpbGwgYmUgc2V0IGFzIGZpcnN0IHR3byBlbGVtZW50cyBvZiBwcm92aWRlZCB2ZXJ0ZXhfdGVtcGxhdGVcbkJ1aWxkZXJzLmJ1aWxkUG9seWdvbnMgPSBmdW5jdGlvbiAoXG4gICAgcG9seWdvbnMsXG4gICAgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSxcbiAgICB7IHRleGNvb3JkX2luZGV4LCB0ZXhjb29yZF9zY2FsZSwgdGV4Y29vcmRfbm9ybWFsaXplIH0pIHtcblxuICAgIGlmICh0ZXhjb29yZF9pbmRleCkge1xuICAgICAgICB0ZXhjb29yZF9ub3JtYWxpemUgPSB0ZXhjb29yZF9ub3JtYWxpemUgfHwgMTtcbiAgICAgICAgdmFyIFtbbWluX3UsIG1pbl92XSwgW21heF91LCBtYXhfdl1dID0gdGV4Y29vcmRfc2NhbGUgfHwgW1swLCAwXSwgWzEsIDFdXTtcbiAgICB9XG5cbiAgICB2YXIgbnVtX3BvbHlnb25zID0gcG9seWdvbnMubGVuZ3RoO1xuICAgIGZvciAodmFyIHA9MDsgcCA8IG51bV9wb2x5Z29uczsgcCsrKSB7XG4gICAgICAgIHZhciBwb2x5Z29uID0gcG9seWdvbnNbcF07XG5cbiAgICAgICAgLy8gRmluZCBwb2x5Z29uIGV4dGVudHMgdG8gY2FsY3VsYXRlIFVWcywgZml0IHRoZW0gdG8gdGhlIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3hcbiAgICAgICAgaWYgKHRleGNvb3JkX2luZGV4KSB7XG4gICAgICAgICAgICB2YXIgW21pbl94LCBtaW5feSwgbWF4X3gsIG1heF95XSA9IEdlby5maW5kQm91bmRpbmdCb3gocG9seWdvbik7XG4gICAgICAgICAgICB2YXIgc3Bhbl94ID0gbWF4X3ggLSBtaW5feDtcbiAgICAgICAgICAgIHZhciBzcGFuX3kgPSBtYXhfeSAtIG1pbl95O1xuICAgICAgICAgICAgdmFyIHNjYWxlX3UgPSAobWF4X3UgLSBtaW5fdSkgLyBzcGFuX3g7XG4gICAgICAgICAgICB2YXIgc2NhbGVfdiA9IChtYXhfdiAtIG1pbl92KSAvIHNwYW5feTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlc3NlbGxhdGVcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gQnVpbGRlcnMudHJpYW5ndWxhdGVQb2x5Z29uKHBvbHlnb24pO1xuXG4gICAgICAgIC8vIEFkZCB2ZXJ0ZXggZGF0YVxuICAgICAgICB2YXIgbnVtX3ZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciB2PTA7IHYgPCBudW1fdmVydGljZXM7IHYrKykge1xuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzW3ZdO1xuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlWzBdID0gdmVydGV4WzBdO1xuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlWzFdID0gdmVydGV4WzFdO1xuXG4gICAgICAgICAgICAvLyBBZGQgVVZzXG4gICAgICAgICAgICBpZiAodGV4Y29vcmRfaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAwXSA9ICgodmVydGV4WzBdIC0gbWluX3gpICogc2NhbGVfdSArIG1pbl91KSAqIHRleGNvb3JkX25vcm1hbGl6ZTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAxXSA9ICgodmVydGV4WzFdIC0gbWluX3kpICogc2NhbGVfdiArIG1pbl92KSAqIHRleGNvb3JkX25vcm1hbGl6ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmVydGV4X2RhdGEuYWRkVmVydGV4KHZlcnRleF90ZW1wbGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBUZXNzZWxhdGUgYW5kIGV4dHJ1ZGUgYSBmbGF0IDJEIHBvbHlnb24gaW50byBhIHNpbXBsZSAzRCBtb2RlbCB3aXRoIGZpeGVkIGhlaWdodCBhbmQgYWRkIHRvIEdMIHZlcnRleCBidWZmZXJcbkJ1aWxkZXJzLmJ1aWxkRXh0cnVkZWRQb2x5Z29ucyA9IGZ1bmN0aW9uIChcbiAgICBwb2x5Z29ucyxcbiAgICB6LCBoZWlnaHQsIG1pbl9oZWlnaHQsXG4gICAgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSxcbiAgICBub3JtYWxfaW5kZXgsXG4gICAgbm9ybWFsX25vcm1hbGl6ZSxcbiAgICB7IHRleGNvb3JkX2luZGV4LCB0ZXhjb29yZF9zY2FsZSwgdGV4Y29vcmRfbm9ybWFsaXplIH0pIHtcblxuICAgIC8vIFRvcFxuICAgIHZhciBtaW5feiA9IHogKyAobWluX2hlaWdodCB8fCAwKTtcbiAgICB2YXIgbWF4X3ogPSB6ICsgaGVpZ2h0O1xuICAgIHZlcnRleF90ZW1wbGF0ZVsyXSA9IG1heF96O1xuICAgIEJ1aWxkZXJzLmJ1aWxkUG9seWdvbnMocG9seWdvbnMsIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsIHsgdGV4Y29vcmRfaW5kZXgsIHRleGNvb3JkX3NjYWxlLCB0ZXhjb29yZF9ub3JtYWxpemUgfSk7XG5cbiAgICAvLyBXYWxsc1xuICAgIC8vIEZpdCBVVnMgdG8gd2FsbCBxdWFkXG4gICAgaWYgKHRleGNvb3JkX2luZGV4KSB7XG4gICAgICAgIHRleGNvb3JkX25vcm1hbGl6ZSA9IHRleGNvb3JkX25vcm1hbGl6ZSB8fCAxO1xuICAgICAgICB2YXIgW1ttaW5fdSwgbWluX3ZdLCBbbWF4X3UsIG1heF92XV0gPSB0ZXhjb29yZF9zY2FsZSB8fCBbWzAsIDBdLCBbMSwgMV1dO1xuICAgICAgICB2YXIgdGV4Y29vcmRzID0gW1xuICAgICAgICAgICAgW21pbl91LCBtYXhfdl0sXG4gICAgICAgICAgICBbbWluX3UsIG1pbl92XSxcbiAgICAgICAgICAgIFttYXhfdSwgbWluX3ZdLFxuXG4gICAgICAgICAgICBbbWF4X3UsIG1pbl92XSxcbiAgICAgICAgICAgIFttYXhfdSwgbWF4X3ZdLFxuICAgICAgICAgICAgW21pbl91LCBtYXhfdl1cbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICB2YXIgbnVtX3BvbHlnb25zID0gcG9seWdvbnMubGVuZ3RoO1xuICAgIGZvciAodmFyIHA9MDsgcCA8IG51bV9wb2x5Z29uczsgcCsrKSB7XG4gICAgICAgIHZhciBwb2x5Z29uID0gcG9seWdvbnNbcF07XG5cbiAgICAgICAgZm9yICh2YXIgcT0wOyBxIDwgcG9seWdvbi5sZW5ndGg7IHErKykge1xuICAgICAgICAgICAgdmFyIGNvbnRvdXIgPSBwb2x5Z29uW3FdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciB3PTA7IHcgPCBjb250b3VyLmxlbmd0aCAtIDE7IHcrKykge1xuICAgICAgICAgICAgICAgIC8vIFR3byB0cmlhbmdsZXMgZm9yIHRoZSBxdWFkIGZvcm1lZCBieSBlYWNoIHZlcnRleCBwYWlyLCBnb2luZyBmcm9tIGJvdHRvbSB0byB0b3AgaGVpZ2h0XG4gICAgICAgICAgICAgICAgdmFyIHdhbGxfdmVydGljZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaWFuZ2xlXG4gICAgICAgICAgICAgICAgICAgIFtjb250b3VyW3crMV1bMF0sIGNvbnRvdXJbdysxXVsxXSwgbWF4X3pdLFxuICAgICAgICAgICAgICAgICAgICBbY29udG91clt3KzFdWzBdLCBjb250b3VyW3crMV1bMV0sIG1pbl96XSxcbiAgICAgICAgICAgICAgICAgICAgW2NvbnRvdXJbd11bMF0sIGNvbnRvdXJbd11bMV0sIG1pbl96XSxcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpYW5nbGVcbiAgICAgICAgICAgICAgICAgICAgW2NvbnRvdXJbd11bMF0sIGNvbnRvdXJbd11bMV0sIG1pbl96XSxcbiAgICAgICAgICAgICAgICAgICAgW2NvbnRvdXJbd11bMF0sIGNvbnRvdXJbd11bMV0sIG1heF96XSxcbiAgICAgICAgICAgICAgICAgICAgW2NvbnRvdXJbdysxXVswXSwgY29udG91clt3KzFdWzFdLCBtYXhfel1cbiAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2FsYyB0aGUgbm9ybWFsIG9mIHRoZSB3YWxsIGZyb20gdXAgdmVjdG9yIGFuZCBvbmUgc2VnbWVudCBvZiB0aGUgd2FsbCB0cmlhbmdsZXNcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsID0gVmVjdG9yLmNyb3NzKFxuICAgICAgICAgICAgICAgICAgICBbMCwgMCwgMV0sXG4gICAgICAgICAgICAgICAgICAgIFZlY3Rvci5ub3JtYWxpemUoW2NvbnRvdXJbdysxXVswXSAtIGNvbnRvdXJbd11bMF0sIGNvbnRvdXJbdysxXVsxXSAtIGNvbnRvdXJbd11bMV0sIDBdKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdmVydGV4IHRlbXBsYXRlIHdpdGggY3VycmVudCBzdXJmYWNlIG5vcm1hbFxuICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtub3JtYWxfaW5kZXggKyAwXSA9IG5vcm1hbFswXSAqIG5vcm1hbF9ub3JtYWxpemU7XG4gICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW25vcm1hbF9pbmRleCArIDFdID0gbm9ybWFsWzFdICogbm9ybWFsX25vcm1hbGl6ZTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbbm9ybWFsX2luZGV4ICsgMl0gPSBub3JtYWxbMl0gKiBub3JtYWxfbm9ybWFsaXplO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgd3Y9MDsgd3YgPCB3YWxsX3ZlcnRpY2VzLmxlbmd0aDsgd3YrKykge1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbMF0gPSB3YWxsX3ZlcnRpY2VzW3d2XVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlWzFdID0gd2FsbF92ZXJ0aWNlc1t3dl1bMV07XG4gICAgICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVsyXSA9IHdhbGxfdmVydGljZXNbd3ZdWzJdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXhjb29yZF9pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3RleGNvb3JkX2luZGV4ICsgMF0gPSB0ZXhjb29yZHNbd3ZdWzBdICogdGV4Y29vcmRfbm9ybWFsaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3RleGNvb3JkX2luZGV4ICsgMV0gPSB0ZXhjb29yZHNbd3ZdWzFdICogdGV4Y29vcmRfbm9ybWFsaXplO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmVydGV4X2RhdGEuYWRkVmVydGV4KHZlcnRleF90ZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gQnVpbGQgdGVzc2VsbGF0ZWQgdHJpYW5nbGVzIGZvciBhIHBvbHlsaW5lXG5CdWlsZGVycy5idWlsZFBvbHlsaW5lcyA9IGZ1bmN0aW9uIChcbiAgICBsaW5lcyxcbiAgICB3aWR0aCxcbiAgICB2ZXJ0ZXhfZGF0YSwgdmVydGV4X3RlbXBsYXRlLFxuICAgIHtcbiAgICAgICAgY2xvc2VkX3BvbHlnb24sXG4gICAgICAgIHJlbW92ZV90aWxlX2VkZ2VzLFxuICAgICAgICB0aWxlX2VkZ2VfdG9sZXJhbmNlLFxuICAgICAgICB0ZXhjb29yZF9pbmRleCxcbiAgICAgICAgdGV4Y29vcmRfc2NhbGUsXG4gICAgICAgIHRleGNvb3JkX25vcm1hbGl6ZSxcbiAgICAgICAgc2NhbGluZ19pbmRleCxcbiAgICAgICAgc2NhbGluZ19ub3JtYWxpemUsXG4gICAgICAgIGpvaW4sIGNhcFxuICAgIH0pIHtcblxuICAgIHZhciBjb3JuZXJzT25DYXAgPSAoY2FwID09PSBcInNxdWFyZVwiKSA/IDIgOiAoKGNhcCA9PT0gXCJyb3VuZFwiKSA/IDMgOiAwKTsgIC8vIEJ1dHQgaXMgdGhlIGltcGxpY2l0IGRlZmF1bHRcbiAgICB2YXIgdHJpYW5nbGVzT25Kb2luID0gKGpvaW4gPT09IFwiYmV2ZWxcIikgPyAxIDogKChqb2luID09PSBcInJvdW5kXCIpID8gMyA6IDApOyAgLy8gTWl0ZXIgaXMgdGhlIGltcGxpY2l0IGRlZmF1bHRcblxuICAgIC8vIEJ1aWxkIHZhcmlhYmxlc1xuICAgIHRleGNvb3JkX25vcm1hbGl6ZSA9IHRleGNvb3JkX25vcm1hbGl6ZSB8fCAxO1xuICAgIHZhciBbW21pbl91LCBtaW5fdl0sIFttYXhfdSwgbWF4X3ZdXSA9IHRleGNvb3JkX3NjYWxlIHx8IFtbMCwgMF0sIFsxLCAxXV07XG5cbiAgICAvLyBWYWx1ZXMgdGhhdCBhcmUgY29uc3RhbnQgZm9yIGVhY2ggbGluZSBhbmQgYXJlIHBhc3NlZCB0byBoZWxwZXIgZnVuY3Rpb25zXG4gICAgdmFyIGNvbnN0YW50cyA9IHtcbiAgICAgICAgdmVydGV4X2RhdGEsXG4gICAgICAgIHZlcnRleF90ZW1wbGF0ZSxcbiAgICAgICAgaGFsZldpZHRoOiB3aWR0aC8yLFxuICAgICAgICB2ZXJ0aWNlczogW10sXG4gICAgICAgIHNjYWxpbmdfaW5kZXgsXG4gICAgICAgIHNjYWxpbmdfbm9ybWFsaXplLFxuICAgICAgICBzY2FsaW5nVmVjczogc2NhbGluZ19pbmRleCAmJiBbXSxcbiAgICAgICAgdGV4Y29vcmRfaW5kZXgsXG4gICAgICAgIHRleGNvb3JkczogdGV4Y29vcmRfaW5kZXggJiYgW10sXG4gICAgICAgIHRleGNvb3JkX25vcm1hbGl6ZSxcbiAgICAgICAgbWluX3UsIG1pbl92LCBtYXhfdSwgbWF4X3YsXG4gICAgICAgIG5QYWlyczogMFxuICAgIH07XG5cbiAgICBmb3IgKHZhciBsbiA9IDA7IGxuIDwgbGluZXMubGVuZ3RoOyBsbisrKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbbG5dO1xuICAgICAgICB2YXIgbGluZVNpemUgPSBsaW5lLmxlbmd0aDtcblxuICAgICAgICAvLyBJZ25vcmUgbm9uLWxpbmVzXG4gICAgICAgIGlmIChsaW5lU2l6ZSA8IDIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIEluaXRpYWxpemUgdmFyaWFibGVzXG4gICAgICAgIHZhciBjb29yZFByZXYgPSBbMCwgMF0sIC8vIFByZXZpb3VzIHBvaW50IGNvb3JkaW5hdGVzXG4gICAgICAgICAgICBjb29yZEN1cnIgPSBbMCwgMF0sIC8vIEN1cnJlbnQgcG9pbnQgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIGNvb3JkTmV4dCA9IFswLCAwXTsgLy8gTmV4dCBwb2ludCBjb29yZGluYXRlc1xuXG4gICAgICAgIHZhciBub3JtUHJldiA9IFswLCAwXSwgIC8vIFJpZ2h0IG5vcm1hbCB0byBzZWdtZW50IGJldHdlZW4gcHJldmlvdXMgYW5kIGN1cnJlbnQgbV9wb2ludHNcbiAgICAgICAgICAgIG5vcm1DdXJyID0gWzAsIDBdLCAgLy8gUmlnaHQgbm9ybWFsIGF0IGN1cnJlbnQgcG9pbnQsIHNjYWxlZCBmb3IgbWl0ZXIgam9pbnRcbiAgICAgICAgICAgIG5vcm1OZXh0ID0gWzAsIDBdOyAgLy8gUmlnaHQgbm9ybWFsIHRvIHNlZ21lbnQgYmV0d2VlbiBjdXJyZW50IGFuZCBuZXh0IG1fcG9pbnRzXG5cbiAgICAgICAgdmFyIGlzUHJldiA9IGZhbHNlLFxuICAgICAgICAgICAgaXNOZXh0ID0gdHJ1ZTtcblxuICAgICAgICAvLyBBZGQgdmVydGljZXMgdG8gYnVmZmVyIGFjY29yZGluZyB0byB0aGVpciBpbmRleFxuICAgICAgICBpbmRleFBhaXJzKGNvbnN0YW50cyk7XG5cbiAgICAgICAgLy8gRG8gdGhpcyB3aXRoIHRoZSByZXN0IChleGNlcHQgdGhlIGxhc3Qgb25lKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVTaXplIDsgaSsrKSB7XG5cbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgbmV4dCBvbmU/XG4gICAgICAgICAgICBpc05leHQgPSBpKzEgPCBsaW5lU2l6ZTtcblxuICAgICAgICAgICAgaWYgKGlzUHJldikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcHJldmlvdXMgb25lLCBjb3B5IHRoZSBjdXJyZW50IChwcmV2aW91cykgdmFsdWVzIG9uICpQcmV2XG4gICAgICAgICAgICAgICAgY29vcmRQcmV2ID0gY29vcmRDdXJyO1xuICAgICAgICAgICAgICAgIG5vcm1QcmV2ID0gVmVjdG9yLm5vcm1hbGl6ZShWZWN0b3IucGVycChjb29yZFByZXYsIGxpbmVbaV0pKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCAmJiBjbG9zZWRfcG9seWdvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgdGhlIGZpcnN0IHBvaW50IGFuZCBpcyBhIGNsb3NlZCBwb2x5Z29uXG5cbiAgICAgICAgICAgICAgICB2YXIgbmVlZFRvQ2xvc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVfdGlsZV9lZGdlcykge1xuICAgICAgICAgICAgICAgICAgICBpZihCdWlsZGVycy5pc09uVGlsZUVkZ2UobGluZVtpXSwgbGluZVtsaW5lU2l6ZS0yXSwgeyB0b2xlcmFuY2U6IHRpbGVfZWRnZV90b2xlcmFuY2UgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRUb0Nsb3NlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobmVlZFRvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRQcmV2ID0gbGluZVtsaW5lU2l6ZS0yXTtcbiAgICAgICAgICAgICAgICAgICAgbm9ybVByZXYgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5wZXJwKGNvb3JkUHJldiwgbGluZVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICBpc1ByZXYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXNzaWduIGN1cnJlbnQgY29vcmRpbmF0ZVxuICAgICAgICAgICAgY29vcmRDdXJyID0gbGluZVtpXTtcblxuICAgICAgICAgICAgaWYgKGlzTmV4dCkge1xuICAgICAgICAgICAgICAgIGNvb3JkTmV4dCA9IGxpbmVbaSsxXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xvc2VkX3BvbHlnb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIHRoZSBsYXN0IHBvaW50IGluIGEgY2xvc2VkIHBvbHlnb25cbiAgICAgICAgICAgICAgICBjb29yZE5leHQgPSBsaW5lWzFdO1xuICAgICAgICAgICAgICAgIGlzTmV4dCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc05leHQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIG5vdCB0aGUgbGFzdCBvbmUgZ2V0IG5leHQgY29vcmRpbmF0ZXMgYW5kIGNhbGN1bGF0ZSB0aGUgcmlnaHQgbm9ybWFsXG5cbiAgICAgICAgICAgICAgICBub3JtTmV4dCA9IFZlY3Rvci5ub3JtYWxpemUoVmVjdG9yLnBlcnAoY29vcmRDdXJyLCBjb29yZE5leHQpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlX3RpbGVfZWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJ1aWxkZXJzLmlzT25UaWxlRWRnZShjb29yZEN1cnIsIGNvb3JkTmV4dCwgeyB0b2xlcmFuY2U6IHRpbGVfZWRnZV90b2xlcmFuY2UgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1DdXJyID0gVmVjdG9yLm5vcm1hbGl6ZShWZWN0b3IucGVycChjb29yZFByZXYsIGNvb3JkQ3VycikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJldikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleFBhaXIoY29vcmRDdXJyLCBub3JtQ3VyciwgaS9saW5lU2l6ZSwgY29uc3RhbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudHMublBhaXJzKys7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdmVydGljZXMgdG8gYnVmZmVyIGFjb3JkaW5nIHRoZWlyIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhQYWlycyhjb25zdGFudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmV2ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gIENvbXB1dGUgY3VycmVudCBub3JtYWxcbiAgICAgICAgICAgIGlmIChpc1ByZXYpIHtcbiAgICAgICAgICAgICAgICAvLyAgSWYgdGhlcmUgaXMgYSBQUkVWSU9VUyAuLi5cbiAgICAgICAgICAgICAgICBpZiAoaXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLiBhbmQgYSBORVhUIE9ORSwgY29tcHV0ZSBwcmV2aW91cyBhbmQgbmV4dCBub3JtYWxzIChzY2FsZWQgYnkgdGhlIGFuZ2xlIHdpdGggdGhlIGxhc3QgcHJldilcbiAgICAgICAgICAgICAgICAgICAgbm9ybUN1cnIgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5hZGQobm9ybVByZXYsIG5vcm1OZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IDIgLyAoMSArIE1hdGguYWJzKFZlY3Rvci5kb3Qobm9ybVByZXYsIG5vcm1DdXJyKSkpO1xuICAgICAgICAgICAgICAgICAgICBub3JtQ3VyciA9IFZlY3Rvci5tdWx0KG5vcm1DdXJyLHNjYWxlKnNjYWxlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyAuLi4gYW5kIHRoZXJlIGlzIE5PVCBhIE5FWFQgT05FLCBjb3B5IHRoZSBwcmV2aW91cyBuZXh0IG9uZSAod2hpY2ggaXMgdGhlIGN1cnJlbnQgb25lKVxuICAgICAgICAgICAgICAgICAgICBub3JtQ3VyciA9IFZlY3Rvci5ub3JtYWxpemUoVmVjdG9yLnBlcnAoY29vcmRQcmV2LCBjb29yZEN1cnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIE5PIFBSRVZJT1VTIC4uLlxuICAgICAgICAgICAgICAgIGlmIChpc05leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uIGFuZCBhIE5FWFQgT05FLFxuICAgICAgICAgICAgICAgICAgICBub3JtTmV4dCA9IFZlY3Rvci5ub3JtYWxpemUoVmVjdG9yLnBlcnAoY29vcmRDdXJyLCBjb29yZE5leHQpKTtcbiAgICAgICAgICAgICAgICAgICAgbm9ybUN1cnIgPSBub3JtTmV4dDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyAuLi4gYW5kIE5PIE5FWFQgT05FLCBub3RoaW5nIHRvIGRvICh3aXRob3V0IHByZXYgb3IgbmV4dCBvbmUgdGhpcyBpcyBqdXN0IGEgcG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzUHJldiB8fCBpc05leHQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIHRoZSBCRUdJTk5JTkcgb2YgYSBMSU5FXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgJiYgIWlzUHJldiAmJiAhY2xvc2VkX3BvbHlnb24pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2FwKGNvb3JkQ3Vyciwgbm9ybUN1cnIsIGNvcm5lcnNPbkNhcCwgdHJ1ZSwgY29uc3RhbnRzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGEgSk9JTlxuICAgICAgICAgICAgICAgIGlmKHRyaWFuZ2xlc09uSm9pbiAhPT0gMCAmJiBpc1ByZXYgJiYgaXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZEpvaW4oW2Nvb3JkUHJldiwgY29vcmRDdXJyLCBjb29yZE5leHRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtub3JtUHJldixub3JtQ3Vyciwgbm9ybU5leHRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkvbGluZVNpemUsIHRyaWFuZ2xlc09uSm9pbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleFBhaXIoY29vcmRDdXJyLCBub3JtQ3VyciwgaS8obGluZVNpemUtMSksIGNvbnN0YW50cyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzTmV4dCkge1xuICAgICAgICAgICAgICAgICAgIGNvbnN0YW50cy5uUGFpcnMrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpc1ByZXYgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHZlcnRpY2VzIHRvIGJ1ZmZlciBhY2NvcmRpbmcgdG8gdGhlaXIgaW5kZXhcbiAgICAgICAgaW5kZXhQYWlycyhjb25zdGFudHMpO1xuXG4gICAgICAgICAvLyBJZiBpdCdzIHRoZSBFTkQgb2YgYSBMSU5FXG4gICAgICAgIGlmKCFjbG9zZWRfcG9seWdvbikge1xuICAgICAgICAgICAgYWRkQ2FwKGNvb3JkQ3Vyciwgbm9ybUN1cnIsIGNvcm5lcnNPbkNhcCAsIGZhbHNlLCBjb25zdGFudHMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gQWRkIHRvIGVxdWlkaXN0YW50IHBhaXJzIG9mIHZlcnRpY2VzIChpbnRlcm5hbCBtZXRob2QgZm9yIHBvbHlsaW5lIGJ1aWxkZXIpXG5mdW5jdGlvbiBhZGRWZXJ0ZXgoY29vcmQsIG5vcm1hbCwgdXYsIHsgaGFsZldpZHRoLCB2ZXJ0aWNlcywgc2NhbGluZ1ZlY3MsIHRleGNvb3JkcyB9KSB7XG4gICAgaWYgKHNjYWxpbmdWZWNzKSB7XG4gICAgICAgIC8vICBhLiBJZiBzY2FsaW5nIGlzIG9uIGFkZCB0aGUgdmVydGV4ICh0aGUgY3VyckNvb3JkKSBhbmQgdGhlIHNjYWxpbmcgVmVjcyAobm9ybWFscyBwb2ludGluZyB3aGVyZSB0byBleHRydWRlIHRoZSB2ZXJ0aWNlcylcbiAgICAgICAgdmVydGljZXMucHVzaChjb29yZCk7XG4gICAgICAgIHNjYWxpbmdWZWNzLnB1c2gobm9ybWFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyAgYi4gQWRkIHRoZSBleHRydWRlZCB2ZXJ0aWNlc1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKFtjb29yZFswXSArIG5vcm1hbFswXSAqIGhhbGZXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgY29vcmRbMV0gKyBub3JtYWxbMV0gKiBoYWxmV2lkdGhdKTtcbiAgICB9XG5cbiAgICAvLyBjKSBBZGQgVVZzIGlmIHRoZXkgYXJlIGVuYWJsZWRcbiAgICBpZiAodGV4Y29vcmRzKSB7XG4gICAgICAgIHRleGNvb3Jkcy5wdXNoKHV2KTtcbiAgICB9XG59XG5cbi8vICBBZGQgdG8gZXF1aWRpc3RhbnQgcGFpcnMgb2YgdmVydGljZXMgKGludGVybmFsIG1ldGhvZCBmb3IgcG9seWxpbmUgYnVpbGRlcilcbmZ1bmN0aW9uIGFkZFZlcnRleFBhaXIgKGNvb3JkLCBub3JtYWwsIHZfcGN0LCBjb25zdGFudHMpIHtcbiAgICBhZGRWZXJ0ZXgoY29vcmQsIG5vcm1hbCwgW2NvbnN0YW50cy5tYXhfdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl0sIGNvbnN0YW50cyk7XG4gICAgYWRkVmVydGV4KGNvb3JkLCBWZWN0b3IubmVnKG5vcm1hbCksIFtjb25zdGFudHMubWluX3UsICgxLXZfcGN0KSpjb25zdGFudHMubWluX3YgKyB2X3BjdCpjb25zdGFudHMubWF4X3ZdLCBjb25zdGFudHMpO1xufVxuXG4vLyAgVGVzc2FsYXRlIGEgRkFOIGdlb21ldHJ5IGJldHdlZW4gcG9pbnRzIEEgICAgICAgQlxuLy8gIHVzaW5nIHRoZWlyIG5vcm1hbHMgZnJvbSBhIGNlbnRlciAgICAgICAgXFwgLiAuIC9cbi8vICBhbmQgaW50ZXJwb2xhdGluZyB0aGVpciBVVnMgICAgICAgICAgICAgICBcXCBwIC9cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFwuL1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ1xuZnVuY3Rpb24gYWRkRmFuIChjb29yZCwgbkEsIG5DLCBuQiwgdUEsIHVDLCB1Qiwgc2lnbmVkLCBudW1UcmlhbmdsZXMsIGNvbnN0YW50cykge1xuXG4gICAgaWYgKG51bVRyaWFuZ2xlcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEFkZCBwcmV2aW91cyB2ZXJ0aWNlcyB0byBidWZmZXIgYW5kIGNsZWFyIHRoZSBidWZmZXJzIGFuZCBpbmRleCBwYWlyc1xuICAgIC8vIGJlY2F1c2Ugd2UgYXJlIGdvaW5nIHRvIGFkZCBtb3JlIHRyaWFuZ2xlcy5cbiAgICBpbmRleFBhaXJzKGNvbnN0YW50cyk7XG5cbiAgICB2YXIgbm9ybUN1cnIgPSBWZWN0b3Iuc2V0KG5BKTtcbiAgICB2YXIgbm9ybVByZXYgPSBbMCwwXTtcblxuICAgIHZhciBhbmdsZV9kZWx0YSA9IFZlY3Rvci5kb3QobkEsIG5CKTtcbiAgICBpZiAoYW5nbGVfZGVsdGEgPCAtMSkge1xuICAgICAgICBhbmdsZV9kZWx0YSA9IC0xO1xuICAgIH1cbiAgICBhbmdsZV9kZWx0YSA9IE1hdGguYWNvcyhhbmdsZV9kZWx0YSkvbnVtVHJpYW5nbGVzO1xuXG4gICAgaWYgKCFzaWduZWQpIHtcbiAgICAgICAgYW5nbGVfZGVsdGEgKj0gLTE7XG4gICAgfVxuXG4gICAgdmFyIHV2Q3VyciA9IFZlY3Rvci5zZXQodUEpO1xuICAgIHZhciB1dl9kZWx0YSA9IFZlY3Rvci5kaXYoVmVjdG9yLnN1Yih1Qix1QSksIG51bVRyaWFuZ2xlcyk7XG5cbiAgICAvLyAgQWRkIHRoZSBGSVJTVCBhbmQgQ0VOVEVSIHZlcnRleFxuICAgIC8vICBUaGUgdHJpYW5nbGVzIHdpbGwgYmUgY29tcG9zZWQgaW4gYSBGQU4gc3R5bGUgYXJvdW5kIGl0XG4gICAgYWRkVmVydGV4KGNvb3JkLCBuQywgdUMsIGNvbnN0YW50cyk7XG5cbiAgICAvLyAgQWRkIGZpcnN0IGNvcm5lclxuICAgIGFkZFZlcnRleChjb29yZCwgbm9ybUN1cnIsIHVBLCBjb25zdGFudHMpO1xuXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSByZXN0IG9mIHRoZSBjb3JuZXJzXG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1UcmlhbmdsZXM7IHQrKykge1xuICAgICAgICBub3JtUHJldiA9IFZlY3Rvci5ub3JtYWxpemUobm9ybUN1cnIpO1xuICAgICAgICBub3JtQ3VyciA9IFZlY3Rvci5yb3QoIFZlY3Rvci5ub3JtYWxpemUobm9ybUN1cnIpLCBhbmdsZV9kZWx0YSk7ICAgICAvLyAgUm90YXRlIHRoZSBleHRydXNpb24gbm9ybWFsXG5cbiAgICAgICAgaWYgKG51bVRyaWFuZ2xlcyA9PT0gNCAmJiAodCA9PT0gMCB8fCB0ID09PSBudW1UcmlhbmdsZXMgLSAyKSkge1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gMiAvICgxICsgTWF0aC5hYnMoVmVjdG9yLmRvdChub3JtUHJldiwgbm9ybUN1cnIpKSk7XG4gICAgICAgICAgICBub3JtQ3VyciA9IFZlY3Rvci5tdWx0KG5vcm1DdXJyLCBzY2FsZSpzY2FsZSk7XG4gICAgICAgIH1cblxuICAgICAgICB1dkN1cnIgPSBWZWN0b3IuYWRkKHV2Q3Vycix1dl9kZWx0YSk7XG5cbiAgICAgICAgYWRkVmVydGV4KGNvb3JkLCBub3JtQ3VyciwgdXZDdXJyLCBjb25zdGFudHMpOyAgICAgIC8vICBBZGQgY29tcHV0ZWQgY29ybmVyXG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UcmlhbmdsZXM7IGkrKykge1xuICAgICAgICBpZiAoc2lnbmVkKSB7XG4gICAgICAgICAgICBhZGRJbmRleChpKzIsIGNvbnN0YW50cyk7XG4gICAgICAgICAgICBhZGRJbmRleCgwLCBjb25zdGFudHMpO1xuICAgICAgICAgICAgYWRkSW5kZXgoaSsxLCBjb25zdGFudHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkSW5kZXgoaSsxLCBjb25zdGFudHMpO1xuICAgICAgICAgICAgYWRkSW5kZXgoMCwgY29uc3RhbnRzKTtcbiAgICAgICAgICAgIGFkZEluZGV4KGkrMiwgY29uc3RhbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENsZWFyIHRoZSBidWZmZXJcbiAgICBjb25zdGFudHMudmVydGljZXMgPSBbXTtcbiAgICBpZiAoY29uc3RhbnRzLnNjYWxpbmdWZWNzKSB7XG4gICAgICAgIGNvbnN0YW50cy5zY2FsaW5nVmVjcyA9IFtdO1xuICAgIH1cbiAgICBpZiAoY29uc3RhbnRzLnRleGNvb3Jkcykge1xuICAgICAgICBjb25zdGFudHMudGV4Y29vcmRzID0gW107XG4gICAgfVxufVxuXG4vLyAgQWRkIHNwZWNpYWwgam9pbnMgKG5vdCBtaXRlcikgdHlwZXMgdGhhdCByZXF1aXJlIEZBTiB0ZXNzZWxsYXRpb25zXG4vLyAgVXNpbmcgaHR0cDovL3d3dy5jb2RlcHJvamVjdC5jb20vQXJ0aWNsZXMvMjI2NTY5L0RyYXdpbmctcG9seWxpbmVzLWJ5LXRlc3NlbGxhdGlvbiBhcyByZWZlcmVuY2VcbmZ1bmN0aW9uIGFkZEpvaW4gKGNvb3Jkcywgbm9ybWFscywgdl9wY3QsIG5UcmlhbmdsZXMsIGNvbnN0YW50cykge1xuXG4gICAgdmFyIFQgPSBbVmVjdG9yLnNldChub3JtYWxzWzBdKSwgVmVjdG9yLnNldChub3JtYWxzWzFdKSwgVmVjdG9yLnNldChub3JtYWxzWzJdKV07XG4gICAgdmFyIHNpZ25lZCA9IFZlY3Rvci5zaWduZWRfYXJlYShjb29yZHNbMF0sIGNvb3Jkc1sxXSwgY29vcmRzWzJdKSA+IDA7XG5cbiAgICB2YXIgbkEgPSBUWzBdLCAgICAgICAgICAgICAgLy8gbm9ybWFsIHRvIHBvaW50IEEgKGFUKVxuICAgICAgICBuQyA9IFZlY3Rvci5uZWcoVFsxXSksICAvLyBub3JtYWwgdG8gY2VudGVyICgtdlApXG4gICAgICAgIG5CID0gVFsyXTsgICAgICAgICAgICAgIC8vIG5vcm1hbCB0byBwb2ludCBCIChiVClcblxuICAgIHZhciB1QSA9IFtjb25zdGFudHMubWF4X3UsICgxLXZfcGN0KSpjb25zdGFudHMubWluX3YgKyB2X3BjdCpjb25zdGFudHMubWF4X3ZdLFxuICAgICAgICB1QyA9IFtjb25zdGFudHMubWluX3UsICgxLXZfcGN0KSpjb25zdGFudHMubWluX3YgKyB2X3BjdCpjb25zdGFudHMubWF4X3ZdLFxuICAgICAgICB1QiA9IFtjb25zdGFudHMubWF4X3UsICgxLXZfcGN0KSpjb25zdGFudHMubWluX3YgKyB2X3BjdCpjb25zdGFudHMubWF4X3ZdO1xuXG4gICAgaWYgKHNpZ25lZCkge1xuICAgICAgICBhZGRWZXJ0ZXgoY29vcmRzWzFdLCBuQSwgdUEsIGNvbnN0YW50cyk7XG4gICAgICAgIGFkZFZlcnRleChjb29yZHNbMV0sIG5DLCB1QywgY29uc3RhbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuQSA9IFZlY3Rvci5uZWcoVFswXSk7XG4gICAgICAgIG5DID0gVFsxXTtcbiAgICAgICAgbkIgPSBWZWN0b3IubmVnKFRbMl0pO1xuICAgICAgICB1QSA9IFtjb25zdGFudHMubWluX3UsICgxLXZfcGN0KSpjb25zdGFudHMubWluX3YgKyB2X3BjdCpjb25zdGFudHMubWF4X3ZdO1xuICAgICAgICB1QyA9IFtjb25zdGFudHMubWF4X3UsICgxLXZfcGN0KSpjb25zdGFudHMubWluX3YgKyB2X3BjdCpjb25zdGFudHMubWF4X3ZdO1xuICAgICAgICB1QiA9IFtjb25zdGFudHMubWluX3UsICgxLXZfcGN0KSpjb25zdGFudHMubWluX3YgKyB2X3BjdCpjb25zdGFudHMubWF4X3ZdO1xuICAgICAgICBhZGRWZXJ0ZXgoY29vcmRzWzFdLCBuQywgdUMsIGNvbnN0YW50cyk7XG4gICAgICAgIGFkZFZlcnRleChjb29yZHNbMV0sIG5BLCB1QSwgY29uc3RhbnRzKTtcbiAgICB9XG5cbiAgICBhZGRGYW4oY29vcmRzWzFdLCBuQSwgbkMsIG5CLCB1QSwgdUMsIHVCLCBzaWduZWQsIG5UcmlhbmdsZXMsIGNvbnN0YW50cyk7XG5cbiAgICBpZiAoc2lnbmVkKSB7XG4gICAgICAgIGFkZFZlcnRleChjb29yZHNbMV0sIG5CLCB1QiwgY29uc3RhbnRzKTtcbiAgICAgICAgYWRkVmVydGV4KGNvb3Jkc1sxXSwgbkMsIHVDLCBjb25zdGFudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZFZlcnRleChjb29yZHNbMV0sIG5DLCB1QywgY29uc3RhbnRzKTtcbiAgICAgICAgYWRkVmVydGV4KGNvb3Jkc1sxXSwgbkIsIHVCLCBjb25zdGFudHMpO1xuICAgIH1cbn1cblxuLy8gIEZ1bmN0aW9uIHRvIGFkZCB0aGUgdmVydGV4IG5lZWQgZm9yIGxpbmUgY2Fwcyxcbi8vICBiZWNhdXNlIHJlLXVzZSB0aGUgYnVmZmVycyBuZWVkcyB0byBiZSBhdCB0aGUgZW5kXG5mdW5jdGlvbiBhZGRDYXAgKGNvb3JkLCBub3JtYWwsIG51bUNvcm5lcnMsIGlzQmVnaW5uaW5nLCBjb25zdGFudHMpIHtcblxuICAgIGlmIChudW1Db3JuZXJzIDwgMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVVZzXG4gICAgdmFyIHV2QSA9IFtjb25zdGFudHMubWluX3UsY29uc3RhbnRzLm1pbl92XSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBCZWdpbm5pbmcgYW5nbGUgVVZzXG4gICAgICAgIHV2QyA9IFtjb25zdGFudHMubWluX3UrKGNvbnN0YW50cy5tYXhfdS1jb25zdGFudHMubWluX3UpLzIsIGNvbnN0YW50cy5taW5fdl0sICAgLy8gY2VudGVyIHBvaW50IFVWc1xuICAgICAgICB1dkIgPSBbY29uc3RhbnRzLm1heF91LGNvbnN0YW50cy5taW5fdl07ICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kaW5nIGFuZ2xlIFVWc1xuXG4gICAgaWYgKCFpc0JlZ2lubmluZykge1xuICAgICAgICB1dkEgPSBbY29uc3RhbnRzLm1pbl91LGNvbnN0YW50cy5tYXhfdl0sICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmVnaW5pbmcgYW5nbGUgVVZzXG4gICAgICAgIHV2QyA9IFtjb25zdGFudHMubWluX3UrKGNvbnN0YW50cy5tYXhfdS1jb25zdGFudHMubWluX3UpLzIsIGNvbnN0YW50cy5tYXhfdl0sICAgLy8gY2VudGVyIHBvaW50IFVWc1xuICAgICAgICB1dkIgPSBbY29uc3RhbnRzLm1heF91LGNvbnN0YW50cy5tYXhfdl07XG4gICAgfVxuXG4gICAgYWRkRmFuKCBjb29yZCxcbiAgICAgICAgICAgIFZlY3Rvci5uZWcobm9ybWFsKSwgWzAsIDBdLCBub3JtYWwsXG4gICAgICAgICAgICB1dkEsIHV2QywgdXZCLFxuICAgICAgICAgICAgaXNCZWdpbm5pbmcsIG51bUNvcm5lcnMqMiwgY29uc3RhbnRzKTtcbn1cblxuLy8gQWRkIGEgdmVydGV4IGJhc2VkIG9uIHRoZSBpbmRleCBwb3NpdGlvbiBpbnRvIHRoZSBWQk8gKGludGVybmFsIG1ldGhvZCBmb3IgcG9seWxpbmUgYnVpbGRlcilcbmZ1bmN0aW9uIGFkZEluZGV4IChpbmRleCwgeyB2ZXJ0ZXhfZGF0YSwgdmVydGV4X3RlbXBsYXRlLCBoYWxmV2lkdGgsIHZlcnRpY2VzLCBzY2FsaW5nX2luZGV4LCBzY2FsaW5nX25vcm1hbGl6ZSwgc2NhbGluZ1ZlY3MsIHRleGNvb3JkX2luZGV4LCB0ZXhjb29yZHMsIHRleGNvb3JkX25vcm1hbGl6ZSB9KSB7XG4gICAgLy8gUHJldmVudCBhY2Nlc3MgdG8gdW5kZWZpbmVkIHZlcnRpY2VzXG4gICAgaWYgKGluZGV4ID49IHZlcnRpY2VzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2V0IHZlcnRleCBwb3NpdGlvblxuICAgIHZlcnRleF90ZW1wbGF0ZVswXSA9IHZlcnRpY2VzW2luZGV4XVswXTtcbiAgICB2ZXJ0ZXhfdGVtcGxhdGVbMV0gPSB2ZXJ0aWNlc1tpbmRleF1bMV07XG5cbiAgICAvLyBzZXQgVVZzXG4gICAgaWYgKHRleGNvb3JkX2luZGV4KSB7XG4gICAgICAgIHZlcnRleF90ZW1wbGF0ZVt0ZXhjb29yZF9pbmRleCArIDBdID0gdGV4Y29vcmRzW2luZGV4XVswXSAqIHRleGNvb3JkX25vcm1hbGl6ZTtcbiAgICAgICAgdmVydGV4X3RlbXBsYXRlW3RleGNvb3JkX2luZGV4ICsgMV0gPSB0ZXhjb29yZHNbaW5kZXhdWzFdICogdGV4Y29vcmRfbm9ybWFsaXplO1xuICAgIH1cblxuICAgIC8vIHNldCBTY2FsaW5nIHZlcnRleCAoWCwgWSBub3JtYWwgZGlyZWN0aW9uICsgWiBoYWxmd2lkdGggYXMgYXR0cmlidXRlKVxuICAgIGlmIChzY2FsaW5nX2luZGV4KSB7XG4gICAgICAgIHZlcnRleF90ZW1wbGF0ZVtzY2FsaW5nX2luZGV4ICsgMF0gPSBzY2FsaW5nVmVjc1tpbmRleF1bMF0gKiBzY2FsaW5nX25vcm1hbGl6ZTtcbiAgICAgICAgdmVydGV4X3RlbXBsYXRlW3NjYWxpbmdfaW5kZXggKyAxXSA9IHNjYWxpbmdWZWNzW2luZGV4XVsxXSAqIHNjYWxpbmdfbm9ybWFsaXplO1xuICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbc2NhbGluZ19pbmRleCArIDJdID0gaGFsZldpZHRoO1xuICAgIH1cblxuICAgIC8vICBBZGQgdmVydGV4IHRvIFZCT1xuICAgIHZlcnRleF9kYXRhLmFkZFZlcnRleCh2ZXJ0ZXhfdGVtcGxhdGUpO1xufVxuXG4vLyBBZGQgdGhlIGluZGV4IHZlcnRleCB0byB0aGUgVkJPIGFuZCBjbGVhbiB0aGUgYnVmZmVyc1xuZnVuY3Rpb24gaW5kZXhQYWlycyAoY29uc3RhbnRzKSB7XG4gICAgLy8gQWRkIHZlcnRpY2VzIHRvIGJ1ZmZlciBhY29yZGluZyB0aGVpciBpbmRleFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uc3RhbnRzLm5QYWlyczsgaSsrKSB7XG4gICAgICAgIGFkZEluZGV4KDIqaSsyLCBjb25zdGFudHMpO1xuICAgICAgICBhZGRJbmRleCgyKmkrMSwgY29uc3RhbnRzKTtcbiAgICAgICAgYWRkSW5kZXgoMippKzAsIGNvbnN0YW50cyk7XG5cbiAgICAgICAgYWRkSW5kZXgoMippKzIsIGNvbnN0YW50cyk7XG4gICAgICAgIGFkZEluZGV4KDIqaSszLCBjb25zdGFudHMpO1xuICAgICAgICBhZGRJbmRleCgyKmkrMSwgY29uc3RhbnRzKTtcbiAgICB9XG5cbiAgICBjb25zdGFudHMublBhaXJzID0gMDtcblxuICAgIC8vIENsZWFuIHRoZSBidWZmZXJcbiAgICBjb25zdGFudHMudmVydGljZXMgPSBbXTtcbiAgICBpZiAoY29uc3RhbnRzLnNjYWxpbmdWZWNzKSB7XG4gICAgICAgIGNvbnN0YW50cy5zY2FsaW5nVmVjcyA9IFtdO1xuICAgIH1cbiAgICBpZiAoY29uc3RhbnRzLnRleGNvb3Jkcykge1xuICAgICAgICBjb25zdGFudHMudGV4Y29vcmRzID0gW107XG4gICAgfVxufVxuXG4vLyBCdWlsZCBhIGJpbGxib2FyZCBzcHJpdGUgcXVhZCBjZW50ZXJlZCBvbiBhIHBvaW50LiBTcHJpdGVzIGFyZSBpbnRlbmRlZCB0byBiZSBkcmF3biBpbiBzY3JlZW5zcGFjZSwgYW5kIGhhdmVcbi8vIHByb3BlcnRpZXMgZm9yIHdpZHRoLCBoZWlnaHQsIGFuZ2xlLCBhbmQgYSBzY2FsZSBmYWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byBpbnRlcnBvbGF0ZSB0aGUgc2NyZWVuc3BhY2Ugc2l6ZVxuLy8gb2YgYSBzcHJpdGUgYmV0d2VlbiB0d28gem9vbSBsZXZlbHMuXG5CdWlsZGVycy5idWlsZFF1YWRzRm9yUG9pbnRzID0gZnVuY3Rpb24gKFxuICAgIHBvaW50cyxcbiAgICB3aWR0aCwgaGVpZ2h0LCBhbmdsZSwgc2NhbGUsXG4gICAgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSxcbiAgICBzY2FsaW5nX2luZGV4LFxuICAgIHsgdGV4Y29vcmRfaW5kZXgsIHRleGNvb3JkX3NjYWxlLCB0ZXhjb29yZF9ub3JtYWxpemUgfSkge1xuXG4gICAgbGV0IHcyID0gd2lkdGggLyAyO1xuICAgIGxldCBoMiA9IGhlaWdodCAvIDI7XG4gICAgbGV0IHNjYWxpbmcgPSBbXG4gICAgICAgIFstdzIsIC1oMl0sXG4gICAgICAgIFt3MiwgLWgyXSxcbiAgICAgICAgW3cyLCBoMl0sXG5cbiAgICAgICAgWy13MiwgLWgyXSxcbiAgICAgICAgW3cyLCBoMl0sXG4gICAgICAgIFstdzIsIGgyXVxuICAgIF07XG5cbiAgICBsZXQgdGV4Y29vcmRzO1xuICAgIGlmICh0ZXhjb29yZF9pbmRleCkge1xuICAgICAgICB0ZXhjb29yZF9ub3JtYWxpemUgPSB0ZXhjb29yZF9ub3JtYWxpemUgfHwgMTtcblxuICAgICAgICBsZXQgW1ttaW5fdSwgbWluX3ZdLCBbbWF4X3UsIG1heF92XV0gPSB0ZXhjb29yZF9zY2FsZSB8fCBbWzAsIDBdLCBbMSwgMV1dO1xuICAgICAgICB0ZXhjb29yZHMgPSBbXG4gICAgICAgICAgICBbbWluX3UsIG1pbl92XSxcbiAgICAgICAgICAgIFttYXhfdSwgbWluX3ZdLFxuICAgICAgICAgICAgW21heF91LCBtYXhfdl0sXG5cbiAgICAgICAgICAgIFttaW5fdSwgbWluX3ZdLFxuICAgICAgICAgICAgW21heF91LCBtYXhfdl0sXG4gICAgICAgICAgICBbbWluX3UsIG1heF92XVxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGxldCBudW1fcG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBwPTA7IHAgPCBudW1fcG9pbnRzOyBwKyspIHtcbiAgICAgICAgbGV0IHBvaW50ID0gcG9pbnRzW3BdO1xuXG4gICAgICAgIGZvciAobGV0IHBvcz0wOyBwb3MgPCA2OyBwb3MrKykge1xuICAgICAgICAgICAgLy8gQWRkIHRleGNvb3Jkc1xuICAgICAgICAgICAgaWYgKHRleGNvb3JkX2luZGV4KSB7XG4gICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3RleGNvb3JkX2luZGV4ICsgMF0gPSB0ZXhjb29yZHNbcG9zXVswXSAqIHRleGNvb3JkX25vcm1hbGl6ZTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAxXSA9IHRleGNvb3Jkc1twb3NdWzFdICogdGV4Y29vcmRfbm9ybWFsaXplO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbMF0gPSBwb2ludFswXTtcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVsxXSA9IHBvaW50WzFdO1xuXG4gICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbc2NhbGluZ19pbmRleCArIDBdID0gc2NhbGluZ1twb3NdWzBdO1xuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3NjYWxpbmdfaW5kZXggKyAxXSA9IHNjYWxpbmdbcG9zXVsxXTtcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtzY2FsaW5nX2luZGV4ICsgMl0gPSBhbmdsZTtcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtzY2FsaW5nX2luZGV4ICsgM10gPSBzY2FsZTtcblxuICAgICAgICAgICAgdmVydGV4X2RhdGEuYWRkVmVydGV4KHZlcnRleF90ZW1wbGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qIFV0aWxpdHkgZnVuY3Rpb25zICovXG5cbi8vIFRyaWFuZ3VsYXRpb24gdXNpbmcgZWFyY3V0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L2VhcmN1dFxuQnVpbGRlcnMudHJpYW5ndWxhdGVQb2x5Z29uID0gZnVuY3Rpb24gKGNvbnRvdXJzKVxue1xuICAgIHJldHVybiBlYXJjdXQoY29udG91cnMpO1xufTtcblxuLy8gVGVzdHMgaWYgYSBsaW5lIHNlZ21lbnQgKGZyb20gcG9pbnQgQSB0byBCKSBpcyBuZWFybHkgY29pbmNpZGVudCB3aXRoIHRoZSBlZGdlIG9mIGEgdGlsZVxuQnVpbGRlcnMuaXNPblRpbGVFZGdlID0gZnVuY3Rpb24gKHBhLCBwYiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIHRvbGVyYW5jZV9mdW5jdGlvbiA9IG9wdGlvbnMudG9sZXJhbmNlX2Z1bmN0aW9uIHx8IEJ1aWxkZXJzLnZhbHVlc1dpdGhpblRvbGVyYW5jZTtcbiAgICB2YXIgdG9sZXJhbmNlID0gb3B0aW9ucy50b2xlcmFuY2UgfHwgMTtcbiAgICB2YXIgdGlsZV9taW4gPSBCdWlsZGVycy50aWxlX2JvdW5kc1swXTtcbiAgICB2YXIgdGlsZV9tYXggPSBCdWlsZGVycy50aWxlX2JvdW5kc1sxXTtcbiAgICB2YXIgZWRnZSA9IG51bGw7XG5cbiAgICBpZiAodG9sZXJhbmNlX2Z1bmN0aW9uKHBhWzBdLCB0aWxlX21pbi54LCB0b2xlcmFuY2UpICYmIHRvbGVyYW5jZV9mdW5jdGlvbihwYlswXSwgdGlsZV9taW4ueCwgdG9sZXJhbmNlKSkge1xuICAgICAgICBlZGdlID0gJ2xlZnQnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0b2xlcmFuY2VfZnVuY3Rpb24ocGFbMF0sIHRpbGVfbWF4LngsIHRvbGVyYW5jZSkgJiYgdG9sZXJhbmNlX2Z1bmN0aW9uKHBiWzBdLCB0aWxlX21heC54LCB0b2xlcmFuY2UpKSB7XG4gICAgICAgIGVkZ2UgPSAncmlnaHQnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0b2xlcmFuY2VfZnVuY3Rpb24ocGFbMV0sIHRpbGVfbWluLnksIHRvbGVyYW5jZSkgJiYgdG9sZXJhbmNlX2Z1bmN0aW9uKHBiWzFdLCB0aWxlX21pbi55LCB0b2xlcmFuY2UpKSB7XG4gICAgICAgIGVkZ2UgPSAndG9wJztcbiAgICB9XG4gICAgZWxzZSBpZiAodG9sZXJhbmNlX2Z1bmN0aW9uKHBhWzFdLCB0aWxlX21heC55LCB0b2xlcmFuY2UpICYmIHRvbGVyYW5jZV9mdW5jdGlvbihwYlsxXSwgdGlsZV9tYXgueSwgdG9sZXJhbmNlKSkge1xuICAgICAgICBlZGdlID0gJ2JvdHRvbSc7XG4gICAgfVxuICAgIHJldHVybiBlZGdlO1xufTtcblxuQnVpbGRlcnMudmFsdWVzV2l0aGluVG9sZXJhbmNlID0gZnVuY3Rpb24gKGEsIGIsIHRvbGVyYW5jZSkge1xuICAgIHRvbGVyYW5jZSA9IHRvbGVyYW5jZSB8fCAxO1xuICAgIHJldHVybiAoTWF0aC5hYnMoYSAtIGIpIDwgdG9sZXJhbmNlKTtcbn07XG4iLCIvLyBMaW5lIHJlbmRlcmluZyBzdHlsZVxuXG5pbXBvcnQge1N0eWxlfSBmcm9tICcuLi9zdHlsZSc7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuLi9zdHlsZV9wYXJzZXInO1xuaW1wb3J0IHtTdHlsZU1hbmFnZXJ9IGZyb20gJy4uL3N0eWxlX21hbmFnZXInO1xuaW1wb3J0IGdsIGZyb20gJy4uLy4uL2dsL2NvbnN0YW50cyc7IC8vIHdlYiB3b3JrZXJzIGRvbid0IGhhdmUgYWNjZXNzIHRvIEdMIGNvbnRleHQsIHNvIGltcG9ydCBhbGwgR0wgY29uc3RhbnRzXG5pbXBvcnQgVmVydGV4TGF5b3V0IGZyb20gJy4uLy4uL2dsL3ZlcnRleF9sYXlvdXQnO1xuaW1wb3J0IEJ1aWxkZXJzIGZyb20gJy4uL2J1aWxkZXJzJztcbmltcG9ydCBHZW8gZnJvbSAnLi4vLi4vZ2VvJztcbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi91dGlscy91dGlscyc7XG5cbmV4cG9ydCB2YXIgTGluZXMgPSBPYmplY3QuY3JlYXRlKFN0eWxlKTtcblxuT2JqZWN0LmFzc2lnbihMaW5lcywge1xuICAgIG5hbWU6ICdsaW5lcycsXG4gICAgYnVpbHRfaW46IHRydWUsXG4gICAgdmVydGV4X3NoYWRlcl9rZXk6ICdzdHlsZXMvcG9seWdvbnMvcG9seWdvbnNfdmVydGV4JywgLy8gcmUtdXNlIHBvbHlnb24gc2hhZGVyc1xuICAgIGZyYWdtZW50X3NoYWRlcl9rZXk6ICdzdHlsZXMvcG9seWdvbnMvcG9seWdvbnNfZnJhZ21lbnQnLFxuICAgIHNlbGVjdGlvbjogdHJ1ZSwgLy8gdHVybiBmZWF0dXJlIHNlbGVjdGlvbiBvblxuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgU3R5bGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIC8vIEJhc2ljIGF0dHJpYnV0ZXMsIG90aGVycyBjYW4gYmUgYWRkZWQgKHNlZSB0ZXh0dXJlIFVWcyBiZWxvdylcbiAgICAgICAgdmFyIGF0dHJpYnMgPSBbXG4gICAgICAgICAgICB7IG5hbWU6ICdhX3Bvc2l0aW9uJywgc2l6ZTogNCwgdHlwZTogZ2wuU0hPUlQsIG5vcm1hbGl6ZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfZXh0cnVkZScsIHNpemU6IDQsIHR5cGU6IGdsLlNIT1JULCBub3JtYWxpemVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX2NvbG9yJywgc2l6ZTogNCwgdHlwZTogZ2wuVU5TSUdORURfQllURSwgbm9ybWFsaXplZDogdHJ1ZSB9XG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gVGVsbCB0aGUgc2hhZGVyIHdlIHdhbnQgYSBvcmRlciBpbiB2ZXJ0ZXggYXR0cmlidXRlcywgYW5kIHRvIGV4dHJ1ZGUgbGluZXNcbiAgICAgICAgdGhpcy5kZWZpbmVzLlRBTkdSQU1fTEFZRVJfT1JERVIgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlZmluZXMuVEFOR1JBTV9FWFRSVURFX0xJTkVTID0gdHJ1ZTtcblxuICAgICAgICAvLyBPcHRpb25hbCBmZWF0dXJlIHNlbGVjdGlvblxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGF0dHJpYnMucHVzaCh7IG5hbWU6ICdhX3NlbGVjdGlvbl9jb2xvcicsIHNpemU6IDQsIHR5cGU6IGdsLlVOU0lHTkVEX0JZVEUsIG5vcm1hbGl6ZWQ6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPcHRpb25hbCB0ZXh0dXJlIFVWc1xuICAgICAgICBpZiAodGhpcy50ZXhjb29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5lcy5UQU5HUkFNX1RFWFRVUkVfQ09PUkRTID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gQWRkIHZlcnRleCBhdHRyaWJ1dGUgZm9yIFVWcyBvbmx5IHdoZW4gbmVlZGVkXG4gICAgICAgICAgICBhdHRyaWJzLnB1c2goeyBuYW1lOiAnYV90ZXhjb29yZCcsIHNpemU6IDIsIHR5cGU6IGdsLlVOU0lHTkVEX1NIT1JULCBub3JtYWxpemVkOiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52ZXJ0ZXhfbGF5b3V0ID0gbmV3IFZlcnRleExheW91dChhdHRyaWJzKTtcbiAgICB9LFxuXG4gICAgX3BhcnNlRmVhdHVyZSAoZmVhdHVyZSwgcnVsZV9zdHlsZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmZlYXR1cmVfc3R5bGU7XG5cbiAgICAgICAgbGV0IGlubmVyX3dpZHRoID0gcnVsZV9zdHlsZS53aWR0aCAmJiBTdHlsZVBhcnNlci5jYWNoZURpc3RhbmNlKHJ1bGVfc3R5bGUud2lkdGgsIGNvbnRleHQpO1xuICAgICAgICBpZiAoIWlubmVyX3dpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUud2lkdGggPSBpbm5lcl93aWR0aCAqIGNvbnRleHQudW5pdHNfcGVyX21ldGVyO1xuXG4gICAgICAgIC8vIFNtb290aGx5IGludGVycG9sYXRlIGxpbmUgd2lkdGggYmV0d2VlbiB6b29tczogZ2V0IHNjYWxlIGZhY3RvciB0byBuZXh0IHpvb21cbiAgICAgICAgLy8gQWRqdXN0IGJ5IGZhY3RvciBvZiAyIGJlY2F1c2UgdGlsZSB1bml0cyBhcmUgem9vbS1kZXBlbmRlbnQgKGEgZ2l2ZW4gdmFsdWUgaXMgdHdpY2UgYXNcbiAgICAgICAgLy8gYmlnIGluIHdvcmxkIHNwYWNlIGF0IHRoZSBuZXh0IHpvb20gdGhhbiBhdCB0aGUgcHJldmlvdXMpXG4gICAgICAgIGNvbnRleHQuem9vbSArKztcbiAgICAgICAgY29udGV4dC51bml0c19wZXJfbWV0ZXIgKj0gMjtcbiAgICAgICAgbGV0IG5leHRfd2lkdGggPSBTdHlsZVBhcnNlci5jYWNoZURpc3RhbmNlKHJ1bGVfc3R5bGUubmV4dF93aWR0aCwgY29udGV4dCk7XG4gICAgICAgIHN0eWxlLm5leHRfd2lkdGggPSBVdGlscy5zY2FsZUludDE2KG5leHRfd2lkdGggKiBjb250ZXh0LnVuaXRzX3Blcl9tZXRlciAvIHN0eWxlLndpZHRoLCAyNTYpO1xuICAgICAgICBjb250ZXh0Lnpvb20tLTtcbiAgICAgICAgY29udGV4dC51bml0c19wZXJfbWV0ZXIgLz0gMjsgLy8gcmVzZXQgdG8gb3JpZ2luYWwgc2NhbGVcblxuICAgICAgICBzdHlsZS5jb2xvciA9IHRoaXMucGFyc2VDb2xvcihydWxlX3N0eWxlLmNvbG9yLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKCFzdHlsZS5jb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoZWlnaHQgZGVmYXVsdHMgdG8gZmVhdHVyZSBoZWlnaHQsIGJ1dCBleHRydWRlIHN0eWxlIGNhbiBkeW5hbWljYWxseSBhZGp1c3QgaGVpZ2h0IGJ5IHJldHVybmluZyBhIG51bWJlciBvciBhcnJheSAoaW5zdGVhZCBvZiBhIGJvb2xlYW4pXG4gICAgICAgIHN0eWxlLnogPSAocnVsZV9zdHlsZS56ICYmIFN0eWxlUGFyc2VyLmNhY2hlRGlzdGFuY2UocnVsZV9zdHlsZS56IHx8IDAsIGNvbnRleHQpKSB8fCBTdHlsZVBhcnNlci5kZWZhdWx0cy56O1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBmZWF0dXJlLnByb3BlcnRpZXMuaGVpZ2h0IHx8IFN0eWxlUGFyc2VyLmRlZmF1bHRzLmhlaWdodDtcbiAgICAgICAgc3R5bGUuZXh0cnVkZSA9IHJ1bGVfc3R5bGUuZXh0cnVkZTtcbiAgICAgICAgaWYgKHN0eWxlLmV4dHJ1ZGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGUuZXh0cnVkZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHN0eWxlLmV4dHJ1ZGUgPSBzdHlsZS5leHRydWRlKGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlLmV4dHJ1ZGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gc3R5bGUuZXh0cnVkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUuZXh0cnVkZSkpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBzdHlsZS5leHRydWRlWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmFpc2UgbGluZSBoZWlnaHQgaWYgZXh0cnVkZWRcbiAgICAgICAgaWYgKHN0eWxlLmV4dHJ1ZGUgJiYgc3R5bGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICBzdHlsZS56ICs9IHN0eWxlLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlLmNhcCA9IHJ1bGVfc3R5bGUuY2FwO1xuICAgICAgICBzdHlsZS5qb2luID0gcnVsZV9zdHlsZS5qb2luO1xuICAgICAgICBzdHlsZS50aWxlX2VkZ2VzID0gcnVsZV9zdHlsZS50aWxlX2VkZ2VzO1xuXG4gICAgICAgIC8vIENvbnN0cnVjdCBhbiBvdXRsaW5lIHN0eWxlXG4gICAgICAgIHN0eWxlLm91dGxpbmUgPSBzdHlsZS5vdXRsaW5lIHx8IHt9O1xuICAgICAgICBpZiAocnVsZV9zdHlsZS5vdXRsaW5lICYmIHJ1bGVfc3R5bGUub3V0bGluZS5jb2xvciAmJiBydWxlX3N0eWxlLm91dGxpbmUud2lkdGgpIHtcbiAgICAgICAgICAgIGxldCBvdXRsaW5lX3dpZHRoID0gU3R5bGVQYXJzZXIuY2FjaGVEaXN0YW5jZShydWxlX3N0eWxlLm91dGxpbmUud2lkdGgsIGNvbnRleHQpICogMjtcblxuICAgICAgICAgICAgY29udGV4dC56b29tICsrO1xuICAgICAgICAgICAgY29udGV4dC51bml0c19wZXJfbWV0ZXIgKj0gMjtcbiAgICAgICAgICAgIGxldCBvdXRsaW5lX25leHRfd2lkdGggPSBTdHlsZVBhcnNlci5jYWNoZURpc3RhbmNlKHJ1bGVfc3R5bGUub3V0bGluZS5uZXh0X3dpZHRoLCBjb250ZXh0KSAqIDI7XG4gICAgICAgICAgICBjb250ZXh0Lnpvb20tLTtcbiAgICAgICAgICAgIGNvbnRleHQudW5pdHNfcGVyX21ldGVyIC89IDI7IC8vIHJlc2V0IHRvIG9yaWdpbmFsIHNjYWxlXG5cbiAgICAgICAgICAgIC8vIE1haW50YWluIGNvbnNpc3RlbnQgb3V0bGluZSB3aWR0aCBhcm91bmQgdGhlIGlubmVyIGxpbmVcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUud2lkdGggPSB7IHZhbHVlOiBvdXRsaW5lX3dpZHRoICsgaW5uZXJfd2lkdGggfTtcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUubmV4dF93aWR0aCA9IHsgdmFsdWU6IG91dGxpbmVfbmV4dF93aWR0aCArIG5leHRfd2lkdGggfTtcblxuICAgICAgICAgICAgc3R5bGUub3V0bGluZS5jb2xvciA9IHJ1bGVfc3R5bGUub3V0bGluZS5jb2xvcjtcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUuY2FwID0gcnVsZV9zdHlsZS5vdXRsaW5lLmNhcCB8fCBydWxlX3N0eWxlLmNhcDtcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUuam9pbiA9IHJ1bGVfc3R5bGUub3V0bGluZS5qb2luIHx8IHJ1bGVfc3R5bGUuam9pbjtcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUuc3R5bGUgPSBydWxlX3N0eWxlLm91dGxpbmUuc3R5bGUgfHwgdGhpcy5uYW1lO1xuXG4gICAgICAgICAgICAvLyBFeHBsaWNpdGx5IGRlZmluZWQgb3V0bGluZSBvcmRlciwgb3IgaW5oZXJpdGVkIGZyb20gaW5uZXIgbGluZVxuICAgICAgICAgICAgaWYgKHJ1bGVfc3R5bGUub3V0bGluZS5vcmRlcikge1xuICAgICAgICAgICAgICAgIHN0eWxlLm91dGxpbmUub3JkZXIgPSB0aGlzLnBhcnNlT3JkZXIocnVsZV9zdHlsZS5vdXRsaW5lLm9yZGVyLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlLm91dGxpbmUub3JkZXIgPSBzdHlsZS5vcmRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRG9uJ3QgbGV0IG91dGxpbmUgYmUgYWJvdmUgaW5uZXIgbGluZVxuICAgICAgICAgICAgaWYgKHN0eWxlLm91dGxpbmUub3JkZXIgPiBzdHlsZS5vcmRlcikge1xuICAgICAgICAgICAgICAgIHN0eWxlLm91dGxpbmUub3JkZXIgPSBzdHlsZS5vcmRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3V0bGluZXMgYXJlIGFsd2F5cyBhdCBoYWxmLWxheWVyIGludGVydmFscyB0byBhdm9pZCBjb25mbGljdGluZyB3aXRoIGlubmVyIGxpbmVzXG4gICAgICAgICAgICBzdHlsZS5vdXRsaW5lLm9yZGVyIC09IDAuNTtcblxuICAgICAgICAgICAgc3R5bGUub3V0bGluZS5wcmVwcm9jZXNzZWQgPSB0cnVlOyAvLyBzaWduYWwgdGhhdCB3ZSd2ZSBhbHJlYWR5IHdyYXBwZWQgcHJvcGVydGllcyBpbiBjYWNoZSBvYmplY3RzXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5vdXRsaW5lLmNvbG9yID0gbnVsbDtcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUud2lkdGggPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBwcmVwcm9jZXNzIChkcmF3KSB7XG4gICAgICAgIGRyYXcuY29sb3IgPSBkcmF3LmNvbG9yICYmIHsgdmFsdWU6IGRyYXcuY29sb3IgfTtcbiAgICAgICAgZHJhdy53aWR0aCA9IGRyYXcud2lkdGggJiYgeyB2YWx1ZTogZHJhdy53aWR0aCB9O1xuICAgICAgICBkcmF3Lm5leHRfd2lkdGggPSBkcmF3LndpZHRoICYmIHsgdmFsdWU6IGRyYXcud2lkdGgudmFsdWUgfTtcbiAgICAgICAgZHJhdy56ID0gZHJhdy56ICYmIHsgdmFsdWU6IGRyYXcueiB9O1xuXG4gICAgICAgIGlmIChkcmF3Lm91dGxpbmUpIHtcbiAgICAgICAgICAgIGRyYXcub3V0bGluZS5jb2xvciA9IGRyYXcub3V0bGluZS5jb2xvciAmJiB7IHZhbHVlOiBkcmF3Lm91dGxpbmUuY29sb3IgfTtcbiAgICAgICAgICAgIGRyYXcub3V0bGluZS53aWR0aCA9IGRyYXcub3V0bGluZS53aWR0aCAmJiB7IHZhbHVlOiBkcmF3Lm91dGxpbmUud2lkdGggfTtcbiAgICAgICAgICAgIGRyYXcub3V0bGluZS5uZXh0X3dpZHRoID0gZHJhdy5vdXRsaW5lLndpZHRoICYmIHsgdmFsdWU6IGRyYXcub3V0bGluZS53aWR0aC52YWx1ZSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgXCJ0ZW1wbGF0ZVwiIHRoYXQgc2V0cyBjb25zdGFudCBhdHRpYnV0ZXMgZm9yIGVhY2ggdmVydGV4LCB3aGljaCBpcyB0aGVuIG1vZGlmaWVkIHBlciB2ZXJ0ZXggb3IgcGVyIGZlYXR1cmUuXG4gICAgICogQSBwbGFpbiBKUyBhcnJheSBtYXRjaGluZyB0aGUgb3JkZXIgb2YgdGhlIHZlcnRleCBsYXlvdXQuXG4gICAgICovXG4gICAgbWFrZVZlcnRleFRlbXBsYXRlKHN0eWxlKSB7XG4gICAgICAgIGxldCBpID0gMDtcblxuICAgICAgICAvLyBwb3NpdGlvbiAtIHggJiB5IGNvb3JkcyB3aWxsIGJlIGZpbGxlZCBpbiBwZXItdmVydGV4IGJlbG93XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gMDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLnogfHwgMDtcblxuICAgICAgICAvLyBsYXllciBvcmRlciAtIHcgY29vcmQgb2YgJ3Bvc2l0aW9uJyBhdHRyaWJ1dGUgKGZvciBwYWNraW5nIGVmZmljaWVuY3kpXG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5vcmRlcjtcblxuICAgICAgICAvLyBleHRydXNpb24gdmVjdG9yXG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gMDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IDA7XG5cbiAgICAgICAgLy8gc2NhbGluZyB0byBwcmV2aW91cyBhbmQgbmV4dCB6b29tXG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5uZXh0X3dpZHRoO1xuXG4gICAgICAgIC8vIGNvbG9yXG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5jb2xvclswXSAqIDI1NTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLmNvbG9yWzFdICogMjU1O1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gc3R5bGUuY29sb3JbMl0gKiAyNTU7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5jb2xvclszXSAqIDI1NTtcblxuICAgICAgICAvLyBzZWxlY3Rpb24gY29sb3JcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzBdICogMjU1O1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLnNlbGVjdGlvbl9jb2xvclsxXSAqIDI1NTtcbiAgICAgICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5zZWxlY3Rpb25fY29sb3JbMl0gKiAyNTU7XG4gICAgICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzNdICogMjU1O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRleHR1cmUgVVZzIHRvIHRlbXBsYXRlIG9ubHkgaWYgbmVlZGVkXG4gICAgICAgIGlmICh0aGlzLnRleGNvb3Jkcykge1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IDA7XG4gICAgICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRleF90ZW1wbGF0ZTtcbiAgICB9LFxuXG4gICAgYnVpbGRMaW5lcyhsaW5lcywgc3R5bGUsIHZlcnRleF9kYXRhLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB2ZXJ0ZXhfdGVtcGxhdGUgPSB0aGlzLm1ha2VWZXJ0ZXhUZW1wbGF0ZShzdHlsZSk7XG5cbiAgICAgICAgLy8gTWFpbiBsaW5lXG4gICAgICAgIGlmIChzdHlsZS5jb2xvciAmJiBzdHlsZS53aWR0aCkge1xuICAgICAgICAgICAgQnVpbGRlcnMuYnVpbGRQb2x5bGluZXMoXG4gICAgICAgICAgICAgICAgbGluZXMsXG4gICAgICAgICAgICAgICAgc3R5bGUud2lkdGgsXG4gICAgICAgICAgICAgICAgdmVydGV4X2RhdGEsXG4gICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2FwOiBzdHlsZS5jYXAsXG4gICAgICAgICAgICAgICAgICAgIGpvaW46IHN0eWxlLmpvaW4sXG4gICAgICAgICAgICAgICAgICAgIHNjYWxpbmdfaW5kZXg6IHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX2V4dHJ1ZGUsXG4gICAgICAgICAgICAgICAgICAgIHNjYWxpbmdfbm9ybWFsaXplOiBVdGlscy5zY2FsZUludDE2KDEsIDI1NiksIC8vIHNjYWxlIGV4dHJ1c2lvbiBub3JtYWxzIHRvIHNpZ25lZCBzaG9ydHMgdy8yNTYgdW5pdCBiYXNpc1xuICAgICAgICAgICAgICAgICAgICB0ZXhjb29yZF9pbmRleDogdGhpcy52ZXJ0ZXhfbGF5b3V0LmluZGV4LmFfdGV4Y29vcmQsXG4gICAgICAgICAgICAgICAgICAgIHRleGNvb3JkX3NjYWxlOiB0aGlzLnRleGNvb3JkX3NjYWxlLFxuICAgICAgICAgICAgICAgICAgICB0ZXhjb29yZF9ub3JtYWxpemU6IDY1NTM1LCAvLyBzY2FsZSBVVnMgdG8gdW5zaWduZWQgc2hvcnRzXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlZF9wb2x5Z29uOiBvcHRpb25zICYmIG9wdGlvbnMuY2xvc2VkX3BvbHlnb24sXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZV90aWxlX2VkZ2VzOiAhc3R5bGUudGlsZV9lZGdlcyAmJiBvcHRpb25zICYmIG9wdGlvbnMucmVtb3ZlX3RpbGVfZWRnZXMsXG4gICAgICAgICAgICAgICAgICAgIHRpbGVfZWRnZV90b2xlcmFuY2U6IEdlby50aWxlX3NjYWxlICogY29udGV4dC50aWxlLnBhZF9zY2FsZSAqIDRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3V0bGluZVxuICAgICAgICAgaWYgKHN0eWxlLm91dGxpbmUgJiYgc3R5bGUub3V0bGluZS5jb2xvciAmJiBzdHlsZS5vdXRsaW5lLndpZHRoKSB7XG4gICAgICAgICAgICB2YXIgb3V0bGluZV9zdHlsZSA9IFN0eWxlTWFuYWdlci5zdHlsZXNbc3R5bGUub3V0bGluZS5zdHlsZV07XG4gICAgICAgICAgICBpZiAob3V0bGluZV9zdHlsZSkge1xuICAgICAgICAgICAgICAgIG91dGxpbmVfc3R5bGUuYWRkRmVhdHVyZShjb250ZXh0LmZlYXR1cmUsIHN0eWxlLm91dGxpbmUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGJ1aWxkUG9seWdvbnMocG9seWdvbnMsIHN0eWxlLCB2ZXJ0ZXhfZGF0YSwgY29udGV4dCkge1xuICAgICAgICAvLyBSZW5kZXIgcG9seWdvbnMgYXMgaW5kaXZpZHVhbCBsaW5lc1xuICAgICAgICBmb3IgKGxldCBwPTA7IHAgPCBwb2x5Z29ucy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgdGhpcy5idWlsZExpbmVzKHBvbHlnb25zW3BdLCBzdHlsZSwgdmVydGV4X2RhdGEsIGNvbnRleHQsIHsgY2xvc2VkX3BvbHlnb246IHRydWUsIHJlbW92ZV90aWxlX2VkZ2VzOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcbiIsIi8vIFBvaW50IHJlbmRlcmluZyBzdHlsZVxuXG5pbXBvcnQge1N0eWxlfSBmcm9tICcuLi9zdHlsZSc7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuLi9zdHlsZV9wYXJzZXInO1xuaW1wb3J0IGdsIGZyb20gJy4uLy4uL2dsL2NvbnN0YW50cyc7IC8vIHdlYiB3b3JrZXJzIGRvbid0IGhhdmUgYWNjZXNzIHRvIEdMIGNvbnRleHQsIHNvIGltcG9ydCBhbGwgR0wgY29uc3RhbnRzXG5pbXBvcnQgVmVydGV4TGF5b3V0IGZyb20gJy4uLy4uL2dsL3ZlcnRleF9sYXlvdXQnO1xuaW1wb3J0IEJ1aWxkZXJzIGZyb20gJy4uL2J1aWxkZXJzJztcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4uLy4uL2dsL3RleHR1cmUnO1xuaW1wb3J0IEdlbyBmcm9tICcuLi8uLi9nZW8nO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCB2YXIgUG9pbnRzID0gT2JqZWN0LmNyZWF0ZShTdHlsZSk7XG5cbk9iamVjdC5hc3NpZ24oUG9pbnRzLCB7XG4gICAgbmFtZTogJ3BvaW50cycsXG4gICAgYnVpbHRfaW46IHRydWUsXG4gICAgc2VsZWN0aW9uOiB0cnVlLCAvLyB0dXJuIGZlYXR1cmUgc2VsZWN0aW9uIG9uXG4gICAgYmxlbmQ6ICdvdmVybGF5JywgLy8gb3ZlcmxheXMgZHJhd24gb24gdG9wIG9mIGFsbCBvdGhlciBzdHlsZXMsIHdpdGggYmxlbmRpbmdcblxuICAgIGluaXQob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIFN0eWxlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAvLyBCYXNlIHNoYWRlcnNcbiAgICAgICAgdGhpcy52ZXJ0ZXhfc2hhZGVyX2tleSA9ICdzdHlsZXMvcG9pbnRzL3BvaW50c192ZXJ0ZXgnO1xuICAgICAgICB0aGlzLmZyYWdtZW50X3NoYWRlcl9rZXkgPSAnc3R5bGVzL3BvaW50cy9wb2ludHNfZnJhZ21lbnQnO1xuXG4gICAgICAgIHZhciBhdHRyaWJzID0gW1xuICAgICAgICAgICAgeyBuYW1lOiAnYV9wb3NpdGlvbicsIHNpemU6IDQsIHR5cGU6IGdsLlNIT1JULCBub3JtYWxpemVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX3NoYXBlJywgc2l6ZTogNCwgdHlwZTogZ2wuU0hPUlQsIG5vcm1hbGl6ZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfdGV4Y29vcmQnLCBzaXplOiAyLCB0eXBlOiBnbC5VTlNJR05FRF9TSE9SVCwgbm9ybWFsaXplZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYV9jb2xvcicsIHNpemU6IDQsIHR5cGU6IGdsLlVOU0lHTkVEX0JZVEUsIG5vcm1hbGl6ZWQ6IHRydWUgfVxuICAgICAgICBdO1xuXG4gICAgICAgIC8vIE9wdGlvbmFsIGZlYXR1cmUgc2VsZWN0aW9uXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgYXR0cmlicy5wdXNoKHsgbmFtZTogJ2Ffc2VsZWN0aW9uX2NvbG9yJywgc2l6ZTogNCwgdHlwZTogZ2wuVU5TSUdORURfQllURSwgbm9ybWFsaXplZDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlJ3JlIG5vdCByZW5kZXJpbmcgYXMgb3ZlcmxheSwgd2UgbmVlZCBhIGxheWVyIGF0dHJpYnV0ZVxuICAgICAgICBpZiAodGhpcy5ibGVuZCAhPT0gJ292ZXJsYXknKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmluZXMuVEFOR1JBTV9MQVlFUl9PUkRFUiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZlcnRleF9sYXlvdXQgPSBuZXcgVmVydGV4TGF5b3V0KGF0dHJpYnMpO1xuXG4gICAgICAgIGlmICh0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5lcy5UQU5HUkFNX1BPSU5UX1RFWFRVUkUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zaGFkZXJzLnVuaWZvcm1zID0gdGhpcy5zaGFkZXJzLnVuaWZvcm1zIHx8IHt9O1xuICAgICAgICAgICAgdGhpcy5zaGFkZXJzLnVuaWZvcm1zLnVfdGV4dHVyZSA9IHRoaXMudGV4dHVyZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcGFyc2VGZWF0dXJlIChmZWF0dXJlLCBydWxlX3N0eWxlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuZmVhdHVyZV9zdHlsZTtcbiAgICAgICAgbGV0IHRpbGUgPSBjb250ZXh0LnRpbGUua2V5O1xuXG4gICAgICAgIHN0eWxlLmNvbG9yID0gdGhpcy5wYXJzZUNvbG9yKHJ1bGVfc3R5bGUuY29sb3IsIGNvbnRleHQpO1xuXG4gICAgICAgIC8vIHJlcXVpcmUgY29sb3Igb3IgdGV4dHVyZVxuICAgICAgICBpZiAoIXN0eWxlLmNvbG9yICYmICF0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNwcml0ZSA9IHN0eWxlLnNwcml0ZSA9IHJ1bGVfc3R5bGUuc3ByaXRlO1xuICAgICAgICBpZiAodHlwZW9mIHNwcml0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3ByaXRlID0gc3ByaXRlKGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlLnNwcml0ZV9kZWZhdWx0ID0gcnVsZV9zdHlsZS5zcHJpdGVfZGVmYXVsdDsgLy8gb3B0aW9uYWwgZmFsbGJhY2sgaWYgJ3Nwcml0ZScgbm90IGZvdW5kXG5cbiAgICAgICAgLy8gaWYgcG9pbnQgaGFzIHRleHR1cmUgYW5kIHNwcml0ZXMsIHJlcXVpcmUgYSB2YWxpZCBzcHJpdGUgdG8gZHJhd1xuICAgICAgICBpZiAodGhpcy50ZXh0dXJlICYmIFRleHR1cmUudGV4dHVyZXNbdGhpcy50ZXh0dXJlXSAmJiBUZXh0dXJlLnRleHR1cmVzW3RoaXMudGV4dHVyZV0uc3ByaXRlcykge1xuICAgICAgICAgICAgaWYgKCFzcHJpdGUgJiYgIXN0eWxlLnNwcml0ZV9kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIVRleHR1cmUudGV4dHVyZXNbdGhpcy50ZXh0dXJlXS5zcHJpdGVzW3Nwcml0ZV0pIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBzcHJpdGUgbm90IGZvdW5kLCBjaGVjayBmb3IgZGVmYXVsdCBzcHJpdGVcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuc3ByaXRlX2RlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlID0gc3R5bGUuc3ByaXRlX2RlZmF1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghVGV4dHVyZS50ZXh0dXJlc1t0aGlzLnRleHR1cmVdLnNwcml0ZXNbc3ByaXRlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4oYFN0eWxlOiBpbiBzdHlsZSAnJHt0aGlzLm5hbWV9JywgY291bGQgbm90IGZpbmQgZGVmYXVsdCBzcHJpdGUgJyR7c3ByaXRlfScgZm9yIHRleHR1cmUgJyR7dGhpcy50ZXh0dXJlfSdgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4oYFN0eWxlOiBpbiBzdHlsZSAnJHt0aGlzLm5hbWV9JywgY291bGQgbm90IGZpbmQgc3ByaXRlICcke3Nwcml0ZX0nIGZvciB0ZXh0dXJlICcke3RoaXMudGV4dHVyZX0nYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwb2ludHMgY2FuIGJlIHBsYWNlZCBvZmYgdGhlIGdyb3VuZFxuICAgICAgICBzdHlsZS56ID0gKHJ1bGVfc3R5bGUueiAmJiBTdHlsZVBhcnNlci5jYWNoZURpc3RhbmNlKHJ1bGVfc3R5bGUueiwgY29udGV4dCkpIHx8IFN0eWxlUGFyc2VyLmRlZmF1bHRzLno7XG5cbiAgICAgICAgLy8gcG9pbnQgc3R5bGUgb25seSBzdXBwb3J0cyBzaXplcyBpbiBwaXhlbCB1bml0cywgc28gdW5pdCBjb252ZXJzaW9uIGZsYWcgaXMgb2ZmXG4gICAgICAgIHN0eWxlLnNpemUgPSBydWxlX3N0eWxlLnNpemUgfHwgeyB2YWx1ZTogWzMyLCAzMl0gfTtcbiAgICAgICAgc3R5bGUuc2l6ZSA9IFN0eWxlUGFyc2VyLmNhY2hlRGlzdGFuY2Uoc3R5bGUuc2l6ZSwgY29udGV4dCwgJ3BpeGVscycpO1xuXG4gICAgICAgIC8vIHNjYWxlIHNpemUgdG8gMTYtYml0IHNpZ25lZCBpbnQsIHdpdGggYSBtYXggYWxsb3dlZCB3aWR0aCArIGhlaWdodCBvZiAxMjggcGl4ZWxzXG4gICAgICAgIHN0eWxlLnNpemUgPSBbXG4gICAgICAgICAgICBNYXRoLm1pbigoc3R5bGUuc2l6ZVswXSB8fCBzdHlsZS5zaXplKSwgMjU2KSxcbiAgICAgICAgICAgIE1hdGgubWluKChzdHlsZS5zaXplWzFdIHx8IHN0eWxlLnNpemUpLCAyNTYpXG4gICAgICAgIF07XG5cbiAgICAgICAgc3R5bGUuc2l6ZVswXSAqPSBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW87XG4gICAgICAgIHN0eWxlLnNpemVbMV0gKj0gVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvO1xuXG4gICAgICAgIHN0eWxlLmFuZ2xlID0gcnVsZV9zdHlsZS5hbmdsZSB8fCAwO1xuICAgICAgICBpZiAodHlwZW9mIHN0eWxlLmFuZ2xlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdHlsZS5hbmdsZSA9IHN0eWxlLmFuZ2xlKGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmFjdG9yIGJ5IHdoaWNoIHBvaW50IHNjYWxlcyBmcm9tIGN1cnJlbnQgem9vbSBsZXZlbCB0byBuZXh0IHpvb20gbGV2ZWxcbiAgICAgICAgc3R5bGUuc2NhbGUgPSBydWxlX3N0eWxlLnNjYWxlIHx8IDE7XG5cbiAgICAgICAgLy8gdG8gc3RvcmUgYmJveCBieSB0aWxlc1xuICAgICAgICBzdHlsZS50aWxlID0gdGlsZTtcblxuICAgICAgICAvLyBwb2x5Z29ucyByZW5kZXJpbmcgYXMgcG9pbnRzIHdpbGwgcmVuZGVyIGVhY2ggaW5kaXZpZHVhbCBwb2x5Z29uIHBvaW50IGJ5IGRlZmF1bHQsIGJ1dFxuICAgICAgICAvLyByZW5kZXJpbmcgYSBzaW5nbGUgcG9pbnQgYXQgdGhlIHBvbHlnb24ncyBjZW50cm9pZCBjYW4gYmUgZW5hYmxlZFxuICAgICAgICBzdHlsZS5jZW50cm9pZCA9IHJ1bGVfc3R5bGUuY2VudHJvaWQ7XG5cbiAgICAgICAgLy8gU2V0cyB0ZXhjb29yZCBzY2FsZSBpZiBuZWVkZWQgKGUuZy4gZm9yIHNwcml0ZSBzdWItYXJlYSlcbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZSAmJiBzcHJpdGUpIHtcbiAgICAgICAgICAgIHRoaXMudGV4Y29vcmRfc2NhbGUgPSBUZXh0dXJlLmdldFNwcml0ZVRleGNvb3Jkcyh0aGlzLnRleHR1cmUsIHNwcml0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRleGNvb3JkX3NjYWxlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9LFxuXG4gICAgcHJlcHJvY2VzcyAoZHJhdykge1xuICAgICAgICBkcmF3LmNvbG9yID0gZHJhdy5jb2xvciAmJiB7IHZhbHVlOiBkcmF3LmNvbG9yIH07XG4gICAgICAgIGRyYXcueiA9IGRyYXcueiAmJiB7IHZhbHVlOiBkcmF3LnogfTtcbiAgICAgICAgZHJhdy5zaXplID0gZHJhdy5zaXplICYmIHsgdmFsdWU6IGRyYXcuc2l6ZSB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIFwidGVtcGxhdGVcIiB0aGF0IHNldHMgY29uc3RhbnQgYXR0aWJ1dGVzIGZvciBlYWNoIHZlcnRleCwgd2hpY2ggaXMgdGhlbiBtb2RpZmllZCBwZXIgdmVydGV4IG9yIHBlciBmZWF0dXJlLlxuICAgICAqIEEgcGxhaW4gSlMgYXJyYXkgbWF0Y2hpbmcgdGhlIG9yZGVyIG9mIHRoZSB2ZXJ0ZXggbGF5b3V0LlxuICAgICAqL1xuICAgIG1ha2VWZXJ0ZXhUZW1wbGF0ZShzdHlsZSkge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBjb2xvciA9IHN0eWxlLmNvbG9yIHx8IFN0eWxlUGFyc2VyLmRlZmF1bHRzLmNvbG9yO1xuXG4gICAgICAgIC8vIHBvc2l0aW9uIC0geCAmIHkgY29vcmRzIHdpbGwgYmUgZmlsbGVkIGluIHBlci12ZXJ0ZXggYmVsb3dcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IDA7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gc3R5bGUueiB8fCAwO1xuXG4gICAgICAgIC8vIGxheWVyIG9yZGVyIC0gdyBjb29yZCBvZiAncG9zaXRpb24nIGF0dHJpYnV0ZSAoZm9yIHBhY2tpbmcgZWZmaWNpZW5jeSlcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLm9yZGVyIHx8IDA7XG5cbiAgICAgICAgLy8gc2NhbGluZyB2ZWN0b3IgLSAoeCwgeSkgY29tcG9uZW50cyBwZXIgcGl4ZWwsIHogPSBhbmdsZSwgdyA9IHNjYWxpbmcgZmFjdG9yXG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gMDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IDA7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSAwO1xuXG4gICAgICAgIC8vIHRleHR1cmUgY29vcmRzXG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gMDtcblxuICAgICAgICAvLyBjb2xvclxuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gY29sb3JbMF0gKiAyNTU7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBjb2xvclsxXSAqIDI1NTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IGNvbG9yWzJdICogMjU1O1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gY29sb3JbM10gKiAyNTU7XG5cbiAgICAgICAgLy8gc2VsZWN0aW9uIGNvbG9yXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLnNlbGVjdGlvbl9jb2xvclswXSAqIDI1NTtcbiAgICAgICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5zZWxlY3Rpb25fY29sb3JbMV0gKiAyNTU7XG4gICAgICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzJdICogMjU1O1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLnNlbGVjdGlvbl9jb2xvclszXSAqIDI1NTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRleF90ZW1wbGF0ZTtcbiAgICB9LFxuXG4gICAgYnVpbGRQb2ludHMgKHBvaW50cywgc3R5bGUsIHZlcnRleF9kYXRhKSB7XG4gICAgICAgIGlmICghc3R5bGUuc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZlcnRleF90ZW1wbGF0ZSA9IHRoaXMubWFrZVZlcnRleFRlbXBsYXRlKHN0eWxlKTtcblxuICAgICAgICBsZXQgc2l6ZSA9IHN0eWxlLnNpemU7XG4gICAgICAgIGxldCBhbmdsZSA9IHN0eWxlLmFuZ2xlO1xuXG4gICAgICAgIEJ1aWxkZXJzLmJ1aWxkUXVhZHNGb3JQb2ludHMoXG4gICAgICAgICAgICBwb2ludHMsXG4gICAgICAgICAgICBVdGlscy5zY2FsZUludDE2KHNpemVbMF0sIDI1NiksIFV0aWxzLnNjYWxlSW50MTYoc2l6ZVsxXSwgMjU2KSxcbiAgICAgICAgICAgIFV0aWxzLnNjYWxlSW50MTYoVXRpbHMucmFkVG9EZWcoYW5nbGUpLCAzNjApLFxuICAgICAgICAgICAgVXRpbHMuc2NhbGVJbnQxNihzdHlsZS5zY2FsZSwgMjU2KSxcbiAgICAgICAgICAgIHZlcnRleF9kYXRhLFxuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlLFxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfbGF5b3V0LmluZGV4LmFfc2hhcGUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGV4Y29vcmRfaW5kZXg6IHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX3RleGNvb3JkLFxuICAgICAgICAgICAgICAgIHRleGNvb3JkX3NjYWxlOiB0aGlzLnRleGNvb3JkX3NjYWxlLFxuICAgICAgICAgICAgICAgIHRleGNvb3JkX25vcm1hbGl6ZTogNjU1MzVcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgYnVpbGRQb2x5Z29ucyhwb2x5Z29ucywgc3R5bGUsIHZlcnRleF9kYXRhKSB7XG4gICAgICAgIC8vIFJlbmRlciBwb2x5Z29ucyBhcyBpbmRpdmlkdWFsIHBvaW50cywgb3IgY2VudHJvaWRcbiAgICAgICAgaWYgKCFzdHlsZS5jZW50cm9pZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgcG9seT0wOyBwb2x5IDwgcG9seWdvbnMubGVuZ3RoOyBwb2x5KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9seWdvbiA9IHBvbHlnb25zW3BvbHldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHI9MDsgciA8IHBvbHlnb24ubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZFBvaW50cyhwb2x5Z29uW3JdLCBzdHlsZSwgdmVydGV4X2RhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjZW50cm9pZCA9IEdlby5tdWx0aUNlbnRyb2lkKHBvbHlnb25zKTtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRQb2ludHMoW2NlbnRyb2lkXSwgc3R5bGUsIHZlcnRleF9kYXRhKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBidWlsZExpbmVzKGxpbmVzLCBzdHlsZSwgdmVydGV4X2RhdGEpIHtcbiAgICAgICAgLy8gUmVuZGVyIGxpbmVzIGFzIGluZGl2aWR1YWwgcG9pbnRzXG4gICAgICAgIGZvciAobGV0IGxuPTA7IGxuIDwgbGluZXMubGVuZ3RoOyBsbisrKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkUG9pbnRzKGxpbmVzW2xuXSwgc3R5bGUsIHZlcnRleF9kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG4iLCIvLyBQb2x5Z29uIHJlbmRlcmluZyBzdHlsZVxuXG5pbXBvcnQge1N0eWxlfSBmcm9tICcuLi9zdHlsZSc7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuLi9zdHlsZV9wYXJzZXInO1xuaW1wb3J0IGdsIGZyb20gJy4uLy4uL2dsL2NvbnN0YW50cyc7IC8vIHdlYiB3b3JrZXJzIGRvbid0IGhhdmUgYWNjZXNzIHRvIEdMIGNvbnRleHQsIHNvIGltcG9ydCBhbGwgR0wgY29uc3RhbnRzXG5pbXBvcnQgVmVydGV4TGF5b3V0IGZyb20gJy4uLy4uL2dsL3ZlcnRleF9sYXlvdXQnO1xuaW1wb3J0IEJ1aWxkZXJzIGZyb20gJy4uL2J1aWxkZXJzJztcblxuZXhwb3J0IHZhciBQb2x5Z29ucyA9IE9iamVjdC5jcmVhdGUoU3R5bGUpO1xuXG5PYmplY3QuYXNzaWduKFBvbHlnb25zLCB7XG4gICAgbmFtZTogJ3BvbHlnb25zJyxcbiAgICBidWlsdF9pbjogdHJ1ZSxcbiAgICB2ZXJ0ZXhfc2hhZGVyX2tleTogJ3N0eWxlcy9wb2x5Z29ucy9wb2x5Z29uc192ZXJ0ZXgnLFxuICAgIGZyYWdtZW50X3NoYWRlcl9rZXk6ICdzdHlsZXMvcG9seWdvbnMvcG9seWdvbnNfZnJhZ21lbnQnLFxuICAgIHNlbGVjdGlvbjogdHJ1ZSwgLy8gdHVybiBmZWF0dXJlIHNlbGVjdGlvbiBvblxuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgU3R5bGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIC8vIEJhc2ljIGF0dHJpYnV0ZXMsIG90aGVycyBjYW4gYmUgYWRkZWQgKHNlZSB0ZXh0dXJlIFVWcyBiZWxvdylcbiAgICAgICAgdmFyIGF0dHJpYnMgPSBbXG4gICAgICAgICAgICB7IG5hbWU6ICdhX3Bvc2l0aW9uJywgc2l6ZTogNCwgdHlwZTogZ2wuU0hPUlQsIG5vcm1hbGl6ZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2Ffbm9ybWFsJywgc2l6ZTogMywgdHlwZTogZ2wuQllURSwgbm9ybWFsaXplZDogdHJ1ZSB9LCAvLyBnZXRzIHBhZGRlZCB0byA0LWJ5dGVzXG4gICAgICAgICAgICB7IG5hbWU6ICdhX2NvbG9yJywgc2l6ZTogNCwgdHlwZTogZ2wuVU5TSUdORURfQllURSwgbm9ybWFsaXplZDogdHJ1ZSB9XG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gVGVsbCB0aGUgc2hhZGVyIHdlIGhhdmUgYSBub3JtYWwgYW5kIG9yZGVyIGF0dHJpYnV0ZXNcbiAgICAgICAgdGhpcy5kZWZpbmVzLlRBTkdSQU1fTk9STUFMX0FUVFJJQlVURSA9IHRydWU7XG4gICAgICAgIHRoaXMuZGVmaW5lcy5UQU5HUkFNX0xBWUVSX09SREVSID0gdHJ1ZTtcblxuICAgICAgICAvLyBPcHRpb25hbCBmZWF0dXJlIHNlbGVjdGlvblxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGF0dHJpYnMucHVzaCh7IG5hbWU6ICdhX3NlbGVjdGlvbl9jb2xvcicsIHNpemU6IDQsIHR5cGU6IGdsLlVOU0lHTkVEX0JZVEUsIG5vcm1hbGl6ZWQ6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPcHRpb25hbCB0ZXh0dXJlIFVWc1xuICAgICAgICBpZiAodGhpcy50ZXhjb29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5lcy5UQU5HUkFNX1RFWFRVUkVfQ09PUkRTID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gQWRkIHZlcnRleCBhdHRyaWJ1dGUgZm9yIFVWcyBvbmx5IHdoZW4gbmVlZGVkXG4gICAgICAgICAgICBhdHRyaWJzLnB1c2goeyBuYW1lOiAnYV90ZXhjb29yZCcsIHNpemU6IDIsIHR5cGU6IGdsLlVOU0lHTkVEX1NIT1JULCBub3JtYWxpemVkOiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52ZXJ0ZXhfbGF5b3V0ID0gbmV3IFZlcnRleExheW91dChhdHRyaWJzKTtcbiAgICB9LFxuXG4gICAgX3BhcnNlRmVhdHVyZSAoZmVhdHVyZSwgcnVsZV9zdHlsZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmZlYXR1cmVfc3R5bGU7XG5cbiAgICAgICAgc3R5bGUuY29sb3IgPSB0aGlzLnBhcnNlQ29sb3IocnVsZV9zdHlsZS5jb2xvciwgY29udGV4dCk7XG4gICAgICAgIGlmICghc3R5bGUuY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGVpZ2h0IGRlZmF1bHRzIHRvIGZlYXR1cmUgaGVpZ2h0LCBidXQgZXh0cnVkZSBzdHlsZSBjYW4gZHluYW1pY2FsbHkgYWRqdXN0IGhlaWdodCBieSByZXR1cm5pbmcgYSBudW1iZXIgb3IgYXJyYXkgKGluc3RlYWQgb2YgYSBib29sZWFuKVxuICAgICAgICBzdHlsZS56ID0gKHJ1bGVfc3R5bGUueiAmJiBTdHlsZVBhcnNlci5jYWNoZURpc3RhbmNlKHJ1bGVfc3R5bGUueiwgY29udGV4dCkpIHx8IFN0eWxlUGFyc2VyLmRlZmF1bHRzLno7XG4gICAgICAgIHN0eWxlLmhlaWdodCA9IGZlYXR1cmUucHJvcGVydGllcy5oZWlnaHQgfHwgU3R5bGVQYXJzZXIuZGVmYXVsdHMuaGVpZ2h0O1xuICAgICAgICBzdHlsZS5taW5faGVpZ2h0ID0gZmVhdHVyZS5wcm9wZXJ0aWVzLm1pbl9oZWlnaHQgfHwgU3R5bGVQYXJzZXIuZGVmYXVsdHMubWluX2hlaWdodDtcbiAgICAgICAgc3R5bGUuZXh0cnVkZSA9IHJ1bGVfc3R5bGUuZXh0cnVkZTtcbiAgICAgICAgaWYgKHN0eWxlLmV4dHJ1ZGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGUuZXh0cnVkZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHN0eWxlLmV4dHJ1ZGUgPSBzdHlsZS5leHRydWRlKGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlLmV4dHJ1ZGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gc3R5bGUuZXh0cnVkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUuZXh0cnVkZSkpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5taW5faGVpZ2h0ID0gc3R5bGUuZXh0cnVkZVswXTtcbiAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBzdHlsZS5leHRydWRlWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3R5bGUub3V0bGluZSA9IHN0eWxlLm91dGxpbmUgfHwge307XG4gICAgICAgIC8vIGlmIChydWxlX3N0eWxlLm91dGxpbmUpIHtcbiAgICAgICAgLy8gICAgIHN0eWxlLm91dGxpbmUuY29sb3IgPSBTdHlsZVBhcnNlci5wYXJzZUNvbG9yKHJ1bGVfc3R5bGUub3V0bGluZS5jb2xvciwgY29udGV4dCk7XG4gICAgICAgIC8vICAgICBzdHlsZS5vdXRsaW5lLndpZHRoID0gU3R5bGVQYXJzZXIucGFyc2VEaXN0YW5jZShydWxlX3N0eWxlLm91dGxpbmUud2lkdGgsIGNvbnRleHQpO1xuICAgICAgICAvLyAgICAgc3R5bGUub3V0bGluZS50aWxlX2VkZ2VzID0gcnVsZV9zdHlsZS5vdXRsaW5lLnRpbGVfZWRnZXM7XG4gICAgICAgIC8vICAgICBzdHlsZS5vdXRsaW5lLmNhcCA9IHJ1bGVfc3R5bGUub3V0bGluZS5jYXAgfHwgcnVsZV9zdHlsZS5jYXA7XG4gICAgICAgIC8vICAgICBzdHlsZS5vdXRsaW5lLmpvaW4gPSBydWxlX3N0eWxlLm91dGxpbmUuam9pbiB8fCBydWxlX3N0eWxlLmpvaW47XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gZWxzZSB7XG4gICAgICAgIC8vICAgICBzdHlsZS5vdXRsaW5lLmNvbG9yID0gbnVsbDtcbiAgICAgICAgLy8gICAgIHN0eWxlLm91dGxpbmUud2lkdGggPSBudWxsO1xuICAgICAgICAvLyAgICAgc3R5bGUub3V0bGluZS50aWxlX2VkZ2VzID0gZmFsc2U7XG4gICAgICAgIC8vIH1cblxuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcblxuICAgIHByZXByb2Nlc3MgKGRyYXcpIHtcbiAgICAgICAgZHJhdy5jb2xvciA9IGRyYXcuY29sb3IgJiYgeyB2YWx1ZTogZHJhdy5jb2xvciB9O1xuICAgICAgICBkcmF3LnogPSBkcmF3LnogJiYgeyB2YWx1ZTogZHJhdy56IH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgXCJ0ZW1wbGF0ZVwiIHRoYXQgc2V0cyBjb25zdGFudCBhdHRpYnV0ZXMgZm9yIGVhY2ggdmVydGV4LCB3aGljaCBpcyB0aGVuIG1vZGlmaWVkIHBlciB2ZXJ0ZXggb3IgcGVyIGZlYXR1cmUuXG4gICAgICogQSBwbGFpbiBKUyBhcnJheSBtYXRjaGluZyB0aGUgb3JkZXIgb2YgdGhlIHZlcnRleCBsYXlvdXQuXG4gICAgICovXG4gICAgbWFrZVZlcnRleFRlbXBsYXRlKHN0eWxlKSB7XG4gICAgICAgIGxldCBpID0gMDtcblxuICAgICAgICAvLyBwb3NpdGlvbiAtIHggJiB5IGNvb3JkcyB3aWxsIGJlIGZpbGxlZCBpbiBwZXItdmVydGV4IGJlbG93XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gMDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLnogfHwgMDtcblxuICAgICAgICAvLyBsYXllciBvcmRlciAtIHcgY29vcmQgb2YgJ3Bvc2l0aW9uJyBhdHRyaWJ1dGUgKGZvciBwYWNraW5nIGVmZmljaWVuY3kpXG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5vcmRlcjtcblxuICAgICAgICAvLyBub3JtYWxcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IDA7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSAwO1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gMSAqIDEyNztcblxuICAgICAgICAvLyBjb2xvclxuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gc3R5bGUuY29sb3JbMF0gKiAyNTU7XG4gICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5jb2xvclsxXSAqIDI1NTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLmNvbG9yWzJdICogMjU1O1xuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gc3R5bGUuY29sb3JbM10gKiAyNTU7XG5cbiAgICAgICAgLy8gc2VsZWN0aW9uIGNvbG9yXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLnNlbGVjdGlvbl9jb2xvclswXSAqIDI1NTtcbiAgICAgICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSBzdHlsZS5zZWxlY3Rpb25fY29sb3JbMV0gKiAyNTU7XG4gICAgICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZVtpKytdID0gc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzJdICogMjU1O1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IHN0eWxlLnNlbGVjdGlvbl9jb2xvclszXSAqIDI1NTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0ZXh0dXJlIFVWcyB0byB0ZW1wbGF0ZSBvbmx5IGlmIG5lZWRlZFxuICAgICAgICBpZiAodGhpcy50ZXhjb29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMudmVydGV4X3RlbXBsYXRlW2krK10gPSAwO1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfdGVtcGxhdGVbaSsrXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy52ZXJ0ZXhfdGVtcGxhdGU7XG4gICAgfSxcblxuICAgIGJ1aWxkUG9seWdvbnMocG9seWdvbnMsIHN0eWxlLCB2ZXJ0ZXhfZGF0YSkge1xuICAgICAgICBsZXQgdmVydGV4X3RlbXBsYXRlID0gdGhpcy5tYWtlVmVydGV4VGVtcGxhdGUoc3R5bGUpO1xuICAgICAgICBsZXQgdGV4Y29vcmRzID0ge1xuICAgICAgICAgICAgdGV4Y29vcmRfaW5kZXg6IHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX3RleGNvb3JkLFxuICAgICAgICAgICAgdGV4Y29vcmRfc2NhbGU6IHRoaXMudGV4Y29vcmRfc2NhbGUsXG4gICAgICAgICAgICB0ZXhjb29yZF9ub3JtYWxpemU6IDY1NTM1IC8vIHNjYWxlIFVWcyB0byB1bnNpZ25lZCBzaG9ydHNcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBFeHRydWRlZCBwb2x5Z29ucyAoZS5nLiAzRCBidWlsZGluZ3MpXG4gICAgICAgIGlmIChzdHlsZS5leHRydWRlICYmIHN0eWxlLmhlaWdodCkge1xuICAgICAgICAgICAgQnVpbGRlcnMuYnVpbGRFeHRydWRlZFBvbHlnb25zKFxuICAgICAgICAgICAgICAgIHBvbHlnb25zLFxuICAgICAgICAgICAgICAgIHN0eWxlLnosIHN0eWxlLmhlaWdodCwgc3R5bGUubWluX2hlaWdodCxcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfZGF0YSwgdmVydGV4X3RlbXBsYXRlLFxuICAgICAgICAgICAgICAgIHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX25vcm1hbCxcbiAgICAgICAgICAgICAgICAxMjcsIC8vIHNjYWxlIG5vcm1hbHMgdG8gc2lnbmVkIGJ5dGVzXG4gICAgICAgICAgICAgICAgdGV4Y29vcmRzXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlZ3VsYXIgcG9seWdvbnNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBCdWlsZGVycy5idWlsZFBvbHlnb25zKFxuICAgICAgICAgICAgICAgIHBvbHlnb25zLFxuICAgICAgICAgICAgICAgIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgdGV4Y29vcmRzXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcbiIsImltcG9ydCB7bWF0Y2h9IGZyb20gJ21hdGNoLWZlYXR1cmUnO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCBjb25zdCB3aGl0ZUxpc3QgPSBbJ2ZpbHRlcicsICdkcmF3JywgJ3Zpc2libGUnLCAnZGF0YScsICdwcm9wZXJ0aWVzJ107XG5cbmV4cG9ydCBsZXQgcnVsZUNhY2hlID0ge307XG5cbmZ1bmN0aW9uIGNhY2hlS2V5IChydWxlcykge1xuICAgIHZhciBrID0gcnVsZXNbMF0uaWQ7XG4gICAgZm9yICh2YXIgaT0xOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgayArPSAnLycgKyBydWxlc1tpXS5pZDtcbiAgICB9XG4gICAgcmV0dXJuIGs7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVRyZWVzKG1hdGNoaW5nVHJlZXMsIGtleSwgY29udGV4dCkge1xuICAgIHZhciBkcmF3ID0ge30sXG4gICAgICAgIGRyYXdzLFxuICAgICAgICAvLyBvcmRlciA9IFtdLFxuICAgICAgICAvLyBvcmRlcl9kcmF3cyA9IFtdLFxuICAgICAgICB0cmVlRGVwdGggPSAwLFxuICAgICAgICB4LCB0O1xuXG4gICAgLy8gVmlzaWJsZSBieSBkZWZhdWx0XG4gICAgZHJhdy52aXNpYmxlID0gdHJ1ZTtcblxuICAgIC8vIEZpbmQgZGVlcGVzdCB0cmVlXG4gICAgZm9yICh0ID0gMDsgdCA8IG1hdGNoaW5nVHJlZXMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgaWYgKG1hdGNoaW5nVHJlZXNbdF0ubGVuZ3RoID4gdHJlZURlcHRoKSB7XG4gICAgICAgICAgICB0cmVlRGVwdGggPSBtYXRjaGluZ1RyZWVzW3RdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIHJ1bGVzIHRvIHBhcnNlXG4gICAgaWYgKHRyZWVEZXB0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBJdGVyYXRlIHRyZWVzIGluIHBhcmFsbGVsXG4gICAgZm9yICh4ID0gMDsgeCA8IHRyZWVEZXB0aDsgeCsrKSB7XG4gICAgICAgIGRyYXdzID0gbWF0Y2hpbmdUcmVlcy5tYXAodHJlZSA9PiB0cmVlW3hdICYmIHRyZWVbeF1ba2V5XSk7XG4gICAgICAgIGlmIChkcmF3cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJvcGVydHktc3BlY2lmaWMgbG9naWNcbiAgICAgICAgLy8gZm9yIChpPTA7IGkgPCBkcmF3cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyAgICAgaWYgKCFkcmF3c1tpXSkge1xuICAgICAgICAvLyAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAvLyAgICAgfVxuXG4gICAgICAgIC8vICAgICAvLyBDb2xsZWN0IHVuaXF1ZSBvcmRlcnMgKGRvbid0IGFkZCB0aGUgb3JkZXIgbXVsdGlwbGUgdGltZXMgZm9yIHRoZSBzbWFlIGRyYXcgcnVsZSlcbiAgICAgICAgLy8gICAgIGlmIChkcmF3c1tpXS5vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vICAgICAgICAgaWYgKG9yZGVyX2RyYXdzLmluZGV4T2YoZHJhd3NbaV0pID09PSAtMSkge1xuICAgICAgICAvLyAgICAgICAgICAgICBvcmRlci5wdXNoKGRyYXdzW2ldLm9yZGVyKTtcbiAgICAgICAgLy8gICAgICAgICAgICAgb3JkZXJfZHJhd3MucHVzaChkcmF3c1tpXSk7XG4gICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gTWVyZ2UgcmVtYWluaW5nIGRyYXcgb2JqZWN0c1xuICAgICAgICBtZXJnZU9iamVjdHMoZHJhdywgLi4uZHJhd3MpO1xuICAgIH1cblxuICAgIC8vIFNob3J0LWNpcmN1aXQgaWYgbm90IHZpc2libGVcbiAgICBpZiAoZHJhdy52aXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTdW0gYWxsIG9yZGVyc1xuICAgIC8vIE5vdGU6IHRlbXBvcmFyaWx5IGNvbW1lbnRpbmcgb3V0LCB3aWxsIHJldmlzaXQgd2l0aCBuZXcgc2NlbmUgZmlsZSBzeW50YXhcbiAgICAvLyBpZiAob3JkZXIubGVuZ3RoID4gMCkge1xuICAgIC8vICAgICAvLyBPcmRlciBjYW4gYmUgY2FjaGVkIGlmIGl0IGlzIGFsbCBudW1lcmljXG4gICAgLy8gICAgIGlmIChvcmRlci5sZW5ndGggPT09IDEgJiYgdHlwZW9mIG9yZGVyWzBdID09PSAnbnVtYmVyJykge1xuICAgIC8vICAgICAgICAgb3JkZXIgPSBvcmRlclswXTtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBlbHNlIGlmIChvcmRlci5ldmVyeSh2ID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJykpIHtcbiAgICAvLyAgICAgICAgIG9yZGVyID0gY2FsY3VsYXRlT3JkZXIob3JkZXIsIGNvbnRleHQpOyAvLyBUT0RPOiB1c2UgU3R5bGVQYXJzZXIuY2FsY3VsYXRlT3JkZXJcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBkcmF3Lm9yZGVyID0gb3JkZXI7XG4gICAgLy8gfVxuXG4gICAgcmV0dXJuIGRyYXc7XG59XG5cblxuY2xhc3MgUnVsZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcih7bmFtZSwgcGFyZW50LCBkcmF3LCB2aXNpYmxlLCBmaWx0ZXIsIHByb3BlcnRpZXN9KSB7XG4gICAgICAgIHRoaXMuaWQgPSBSdWxlLmlkKys7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmRyYXcgPSBkcmF3O1xuICAgICAgICB0aGlzLmZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdmlzaWJsZSAhPT0gdW5kZWZpbmVkID8gdmlzaWJsZSA6ICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC52aXNpYmxlKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcyAhPT0gdW5kZWZpbmVkID8gcHJvcGVydGllcyA6ICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5wcm9wZXJ0aWVzKTtcblxuICAgICAgICAvLyBEZW5vcm1hbGl6ZSBwcm9wZXJ0aWVzIHRvIGRyYXcgZ3JvdXBzXG4gICAgICAgIGlmICh0aGlzLmRyYXcpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGdyb3VwIGluIHRoaXMuZHJhdykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdbZ3JvdXBdLnByb3BlcnRpZXMgPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5idWlsZEZpbHRlcigpO1xuICAgICAgICB0aGlzLmJ1aWxkRHJhdygpO1xuICAgIH1cblxuICAgIGJ1aWxkRHJhdygpIHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVkRHJhdyA9IGNhbGN1bGF0ZURyYXcodGhpcyk7XG4gICAgfVxuXG4gICAgYnVpbGRGaWx0ZXIoKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHRoaXMuZmlsdGVyO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyID0gbWF0Y2godGhpcy5maWx0ZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgZHJhdzogdGhpcy5kcmF3XG4gICAgICAgIH07XG4gICAgfVxuXG59XG5cblJ1bGUuaWQgPSAwO1xuXG5cbmV4cG9ydCBjbGFzcyBSdWxlTGVhZiBleHRlbmRzIFJ1bGUge1xuICAgIGNvbnN0cnVjdG9yKHtuYW1lLCBwYXJlbnQsIGRyYXcsIHZpc2libGUsIGZpbHRlciwgcHJvcGVydGllc30pIHtcbiAgICAgICAgc3VwZXIoe25hbWUsIHBhcmVudCwgZHJhdywgdmlzaWJsZSwgZmlsdGVyLCBwcm9wZXJ0aWVzfSk7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBjbGFzcyBSdWxlVHJlZSBleHRlbmRzIFJ1bGUge1xuICAgIGNvbnN0cnVjdG9yKHtuYW1lLCBwYXJlbnQsIGRyYXcsIHZpc2libGUsIHJ1bGVzLCBmaWx0ZXIsIHByb3BlcnRpZXN9KSB7XG4gICAgICAgIHN1cGVyKHtuYW1lLCBwYXJlbnQsIGRyYXcsIHZpc2libGUsIGZpbHRlciwgcHJvcGVydGllc30pO1xuICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXMgfHwgW107XG4gICAgfVxuXG4gICAgYWRkUnVsZShydWxlKSB7XG4gICAgICAgIHRoaXMucnVsZXMucHVzaChydWxlKTtcbiAgICB9XG5cbiAgICBidWlsZERyYXdHcm91cHMoY29udGV4dCkge1xuICAgICAgICBsZXQgcnVsZXMgID0gW107XG4gICAgICAgIC8vVE9ETywgc2hvdWxkIHRoaXMgZnVuY3Rpb24gdGFrZSBhIFJ1bGVUcmVlXG4gICAgICAgIG1hdGNoRmVhdHVyZShjb250ZXh0LCBbdGhpc10sIHJ1bGVzKTtcblxuICAgICAgICBpZiAocnVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IGNhY2hlX2tleSA9IGNhY2hlS2V5KHJ1bGVzKTtcblxuICAgICAgICAgICAgLy8gT25seSBldmFsdWF0ZSBlYWNoIHJ1bGUgY29tYmluYXRpb24gb25jZSAodW5kZWZpbmVkIG1lYW5zIG5vdCB5ZXQgZXZhbHVhdGVkLFxuICAgICAgICAgICAgLy8gbnVsbCBtZWFucyBldmFsdWF0ZWQgd2l0aCBubyBkcmF3IG9iamVjdClcbiAgICAgICAgICAgIGlmIChydWxlQ2FjaGVbY2FjaGVfa2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gVmlzaWJsZT9cbiAgICAgICAgICAgICAgICBpZiAocnVsZXMuc29tZSh4ID0+IHgudmlzaWJsZSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVDYWNoZVtjYWNoZV9rZXldID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgYWxsIHRoZSB1bmlxdWUgZHJhdyBibG9ja3MgZm9yIHRoaXMgcnVsZSB0cmVlXG4gICAgICAgICAgICAgICAgICAgIGxldCBkcmF3X3J1bGVzID0gcnVsZXMubWFwKHggPT4geCAmJiB4LmNhbGN1bGF0ZWREcmF3KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRyYXdfa2V5cyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHJ1bGUgb2YgZHJhd19ydWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFydWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBncm91cCBvZiBydWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdfa2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgZWFjaCBkcmF3IGdyb3VwXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGRyYXdfa2V5IGluIGRyYXdfa2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZUNhY2hlW2NhY2hlX2tleV0gPSBydWxlQ2FjaGVbY2FjaGVfa2V5XSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVDYWNoZVtjYWNoZV9rZXldW2RyYXdfa2V5XSA9IG1lcmdlVHJlZXMoZHJhd19ydWxlcywgZHJhd19rZXksIGNvbnRleHQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHNhdmUgdGhlIG9uZXMgdGhhdCB3ZXJlbid0IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcnVsZUNhY2hlW2NhY2hlX2tleV1bZHJhd19rZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJ1bGVDYWNoZVtjYWNoZV9rZXldW2RyYXdfa2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVDYWNoZVtjYWNoZV9rZXldW2RyYXdfa2V5XS5rZXkgPSBjYWNoZV9rZXkgKyAnLycgKyBkcmF3X2tleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHJ1bGVzIGV2YWx1YXRlZFxuICAgICAgICAgICAgICAgICAgICBpZiAocnVsZUNhY2hlW2NhY2hlX2tleV0gJiYgT2JqZWN0LmtleXMocnVsZUNhY2hlW2NhY2hlX2tleV0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZUNhY2hlW2NhY2hlX2tleV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVDYWNoZVtjYWNoZV9rZXldO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVMaXN0ZWQoa2V5KSB7XG4gICAgcmV0dXJuIHdoaXRlTGlzdC5pbmRleE9mKGtleSkgPiAtMTtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YWxrVXAocnVsZSwgY2IpIHtcblxuICAgIGlmIChydWxlLnBhcmVudCkge1xuICAgICAgICB3YWxrVXAocnVsZS5wYXJlbnQsIGNiKTtcbiAgICB9XG5cbiAgICBjYihydWxlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhbGtEb3duKHJ1bGUsIGNiKSB7XG5cbiAgICBpZiAocnVsZS5ydWxlcykge1xuICAgICAgICBydWxlLnJ1bGVzLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgICAgIHdhbGtEb3duKHIsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2IocnVsZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncm91cFByb3BzKG9iaikge1xuICAgIGxldCB3aGl0ZUxpc3RlZCA9IHt9LCBub25XaGl0ZUxpc3RlZCA9IHt9O1xuXG4gICAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoaXNXaGl0ZUxpc3RlZChrZXkpKSB7XG4gICAgICAgICAgICB3aGl0ZUxpc3RlZFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub25XaGl0ZUxpc3RlZFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFt3aGl0ZUxpc3RlZCwgbm9uV2hpdGVMaXN0ZWRdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRHJhdyhydWxlKSB7XG5cbiAgICBsZXQgZHJhdyAgPSBbXTtcblxuICAgIGlmIChydWxlLnBhcmVudCkge1xuICAgICAgICBsZXQgY3MgPSBydWxlLnBhcmVudC5jYWxjdWxhdGVkRHJhdyB8fCBbXTtcbiAgICAgICAgZHJhdy5wdXNoKC4uLmNzKTtcbiAgICB9XG5cbiAgICBkcmF3LnB1c2gocnVsZS5kcmF3KTtcbiAgICByZXR1cm4gZHJhdztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhuZXdPYmosIC4uLnNvdXJjZXMpIHtcblxuICAgIGZvciAobGV0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gbWVyZ2VPYmplY3RzKG5ld09ialtrZXldIHx8IHt9LCB2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cbiAgICByZXR1cm4gbmV3T2JqO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlT3JkZXIob3JkZXJzLCBjb250ZXh0ID0gbnVsbCwgZGVmYXVsdE9yZGVyID0gMCkge1xuICAgIGxldCBzdW0gPSBkZWZhdWx0T3JkZXI7XG5cbiAgICBmb3IgKGxldCBvcmRlciBvZiBvcmRlcnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3JkZXIgPSBvcmRlcihjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9yZGVyID0gcGFyc2VGbG9hdChvcmRlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9yZGVyIHx8IGlzTmFOKG9yZGVyKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3VtICs9IG9yZGVyO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJ1bGVUcmVlKG5hbWUsIHJ1bGUsIHBhcmVudCkge1xuXG4gICAgbGV0IHByb3BlcnRpZXMgPSB7bmFtZSwgcGFyZW50fTtcbiAgICBsZXQgW3doaXRlTGlzdGVkLCBub25XaGl0ZUxpc3RlZF0gPSBncm91cFByb3BzKHJ1bGUpO1xuICAgIGxldCBlbXB0eSA9IGlzRW1wdHkobm9uV2hpdGVMaXN0ZWQpO1xuICAgIGxldCBDcmVhdGU7XG5cbiAgICBpZiAoZW1wdHkgJiYgcGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgQ3JlYXRlID0gUnVsZUxlYWY7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgQ3JlYXRlID0gUnVsZVRyZWU7XG4gICAgfVxuXG4gICAgbGV0IHIgPSBuZXcgQ3JlYXRlKE9iamVjdC5hc3NpZ24ocHJvcGVydGllcywgd2hpdGVMaXN0ZWQpKTtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LmFkZFJ1bGUocik7XG4gICAgfVxuXG4gICAgaWYgKCFlbXB0eSkge1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gbm9uV2hpdGVMaXN0ZWQpIHtcbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IG5vbldoaXRlTGlzdGVkW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHBhcnNlUnVsZVRyZWUoa2V5LCBwcm9wZXJ0eSwgcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuKCdSdWxlIHByb3BlcnR5IG11c3QgYmUgYW4gb2JqZWN0OiAnLCBuYW1lLCBydWxlLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiByO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJ1bGVzKHJ1bGVzKSB7XG4gICAgbGV0IHJ1bGVUcmVlcyA9IHt9O1xuXG4gICAgZm9yIChsZXQga2V5IGluIHJ1bGVzKSB7XG4gICAgICAgIGxldCBydWxlID0gcnVsZXNba2V5XTtcbiAgICAgICAgcnVsZVRyZWVzW2tleV0gPSBwYXJzZVJ1bGVUcmVlKGtleSwgcnVsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bGVUcmVlcztcbn1cblxuXG5mdW5jdGlvbiBkb2VzTWF0Y2goZmlsdGVyLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuICgodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJyAmJiBmaWx0ZXIoY29udGV4dCkpIHx8IChmaWx0ZXIgPT0gbnVsbCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hGZWF0dXJlKGNvbnRleHQsIHJ1bGVzLCBjb2xsZWN0ZWRSdWxlcykge1xuICAgIGxldCBtYXRjaGVkID0gZmFsc2U7XG4gICAgbGV0IGNoaWxkTWF0Y2hlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHJ1bGVzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cblxuICAgIGZvciAobGV0IHI9MDsgciA8IHJ1bGVzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gcnVsZXNbcl07XG4gICAgICAgIGNvbnRleHQucHJvcGVydGllcyA9IGN1cnJlbnQucHJvcGVydGllcztcblxuICAgICAgICBpZiAoY3VycmVudCBpbnN0YW5jZW9mIFJ1bGVMZWFmKSB7XG5cbiAgICAgICAgICAgIGlmIChkb2VzTWF0Y2goY3VycmVudC5maWx0ZXIsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29sbGVjdGVkUnVsZXMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBSdWxlVHJlZSkge1xuICAgICAgICAgICAgaWYgKGRvZXNNYXRjaChjdXJyZW50LmZpbHRlciwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGNoaWxkTWF0Y2hlZCA9IG1hdGNoRmVhdHVyZShcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5ydWxlcyxcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkUnVsZXNcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZE1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkUnVsZXMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LnByb3BlcnRpZXMgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVkO1xufVxuIiwiLy8gUmVuZGVyaW5nIHN0eWxlc1xuXG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuL3N0eWxlX3BhcnNlcic7XG5pbXBvcnQgRmVhdHVyZVNlbGVjdGlvbiBmcm9tICcuLi9zZWxlY3Rpb24nO1xuaW1wb3J0IFNoYWRlclByb2dyYW0gZnJvbSAnLi4vZ2wvc2hhZGVyX3Byb2dyYW0nO1xuaW1wb3J0IFZCT01lc2ggZnJvbSAnLi4vZ2wvdmJvX21lc2gnO1xuaW1wb3J0IE1hdGVyaWFsIGZyb20gJy4uL21hdGVyaWFsJztcbmltcG9ydCBMaWdodCBmcm9tICcuLi9saWdodCc7XG5pbXBvcnQge01ldGhvZE5vdEltcGxlbWVudGVkfSBmcm9tICcuLi91dGlscy9lcnJvcnMnO1xuaW1wb3J0IHNoYWRlclNvdXJjZXMgZnJvbSAnLi4vZ2wvc2hhZGVyX3NvdXJjZXMnOyAvLyBidWlsdC1pbiBzaGFkZXJzXG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG4vLyBCYXNlIGNsYXNzXG5cbmV4cG9ydCB2YXIgU3R5bGUgPSB7XG4gICAgaW5pdCAoeyBnZW5lcmF0aW9uIH0gPSB7fSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNCdWlsdEluKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbHRfaW4gPSBmYWxzZTsgLy8gZXhwbGljaXRseSBzZXQgdG8gZmFsc2UgdG8gYXZvaWQgYW55IGNvbmZ1c2lvblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nZW5lcmF0aW9uID0gZ2VuZXJhdGlvbjsgICAgICAgICAgICAgICAvLyBzY2VuZSBnZW5lcmF0aW9uIGlkIHRoaXMgc3R5bGUgd2FzIGNyZWF0ZWQgZm9yXG4gICAgICAgIHRoaXMuZGVmaW5lcyA9ICh0aGlzLmhhc093blByb3BlcnR5KCdkZWZpbmVzJykgJiYgdGhpcy5kZWZpbmVzKSB8fCB7fTsgLy8gI2RlZmluZXMgdG8gYmUgaW5qZWN0ZWQgaW50byB0aGUgc2hhZGVyc1xuICAgICAgICB0aGlzLnNoYWRlcnMgPSAodGhpcy5oYXNPd25Qcm9wZXJ0eSgnc2hhZGVycycpICYmIHRoaXMuc2hhZGVycykgfHwge307IC8vIHNoYWRlciBjdXN0b21pemF0aW9uICh1bmlmb3JtcywgZGVmaW5lcywgYmxvY2tzLCBldGMuKVxuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uIHx8IGZhbHNlOyAgIC8vIGZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIHN0eWxlIHN1cHBvcnRzIGZlYXR1cmUgc2VsZWN0aW9uXG4gICAgICAgIHRoaXMuY29tcGlsaW5nID0gZmFsc2U7ICAgICAgICAgICAgICAgICAgICAgLy8gcHJvZ3JhbXMgYXJlIGN1cnJlbnRseSBjb21waWxpbmdcbiAgICAgICAgdGhpcy5jb21waWxlZCA9IGZhbHNlOyAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9ncmFtcyBhcmUgZmluaXNoZWQgY29tcGlsaW5nXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gR0wgcHJvZ3JhbSByZWZlcmVuY2UgKGZvciBtYWluIHJlbmRlciBwYXNzKVxuICAgICAgICB0aGlzLnNlbGVjdGlvbl9wcm9ncmFtID0gbnVsbDsgICAgICAgICAgICAgIC8vIEdMIHByb2dyYW0gcmVmZXJlbmNlIGZvciBmZWF0dXJlIHNlbGVjdGlvbiByZW5kZXIgcGFzc1xuICAgICAgICB0aGlzLmZlYXR1cmVfc3R5bGUgPSB7fTsgICAgICAgICAgICAgICAgICAgIC8vIHN0eWxlIGZvciBmZWF0dXJlIGN1cnJlbnRseSBiZWluZyBwYXJzZWQsIHNoYXJlZCB0byBsZXNzZW4gR0MvbWVtb3J5IHRocmFzaFxuICAgICAgICB0aGlzLnZlcnRleF90ZW1wbGF0ZSA9IFtdOyAgICAgICAgICAgICAgICAgIC8vIHNoYXJlZCBzaW5nbGUtdmVydGV4IHRlbXBsYXRlLCBmaWxsZWQgb3V0IGJ5IGVhY2ggc3R5bGVcbiAgICAgICAgdGhpcy50aWxlX2RhdGEgPSB7fTtcbiAgICAgICAgdGhpcy5mZWF0dXJlX29wdGlvbnMgPSB7fTtcblxuICAgICAgICAvLyBEZWZhdWx0IHdvcmxkIGNvb3JkcyB0byB3cmFwIGV2ZXJ5IDEwMCwwMDAgbWV0ZXJzLCBjYW4gdHVybiBvZmYgYnkgc2V0dGluZyB0aGlzIHRvICdmYWxzZSdcbiAgICAgICAgdGhpcy5kZWZpbmVzLlRBTkdSQU1fV09STERfUE9TSVRJT05fV1JBUCA9IDEwMDAwMDtcblxuICAgICAgICAvLyBCbGVuZGluZ1xuICAgICAgICB0aGlzLmJsZW5kID0gdGhpcy5ibGVuZCB8fCAnb3BhcXVlJzsgICAgICAgIC8vIGRlZmF1bHQ6IG9wYXF1ZSBzdHlsZXMgYXJlIGRyYXduIGZpcnN0LCB3aXRob3V0IGJsZW5kaW5nXG4gICAgICAgIHRoaXMuZGVmaW5lc1tgVEFOR1JBTV9CTEVORF8ke3RoaXMuYmxlbmQudG9VcHBlckNhc2UoKX1gXSA9IHRydWU7XG5cbiAgICAgICAgLy8gSWYgdGhlIHN0eWxlIGRlZmluZXMgaXRzIG93biBtYXRlcmlhbCwgcmVwbGFjZSB0aGUgaW5oZXJpdGVkIG1hdGVyaWFsIGluc3RhbmNlXG4gICAgICAgIGlmICghKHRoaXMubWF0ZXJpYWwgaW5zdGFuY2VvZiBNYXRlcmlhbCkpIHtcbiAgICAgICAgICAgIGlmICghTWF0ZXJpYWwuaXNWYWxpZCh0aGlzLm1hdGVyaWFsKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0ZXJpYWwgPSBTdHlsZVBhcnNlci5kZWZhdWx0cy5tYXRlcmlhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWwodGhpcy5tYXRlcmlhbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXRlcmlhbC5pbmplY3QodGhpcyk7XG5cbiAgICAgICAgLy8gU2V0IGxpZ2h0aW5nIG1vZGU6IGZyYWdtZW50LCB2ZXJ0ZXgsIG9yIG5vbmUgKHNwZWNpZmllZCBhcyAnZmFsc2UnKVxuICAgICAgICBMaWdodC5zZXRNb2RlKHRoaXMubGlnaHRpbmcsIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBkZXN0cm95ICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvZ3JhbSkge1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25fcHJvZ3JhbSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25fcHJvZ3JhbS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbl9wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIHJlc2V0ICgpIHtcbiAgICB9LFxuXG4gICAgaXNCdWlsdEluICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzT3duUHJvcGVydHkoJ2J1aWx0X2luJykgJiYgdGhpcy5idWlsdF9pbjtcbiAgICB9LFxuXG4gICAgLyoqKiBTdHlsZSBwYXJzaW5nIGFuZCBnZW9tZXRyeSBjb25zdHJ1Y3Rpb24gKioqL1xuXG4gICAgLy8gUmV0dXJucyBhbiBvYmplY3QgdG8gaG9sZCBmZWF0dXJlIGRhdGEgKGZvciBhIHRpbGUgb3Igb3RoZXIgb2JqZWN0KVxuICAgIHN0YXJ0RGF0YSAodGlsZSkge1xuICAgICAgICB0aGlzLnRpbGVfZGF0YVt0aWxlXSA9IHtcbiAgICAgICAgICAgIHZlcnRleF9kYXRhOiBudWxsLFxuICAgICAgICAgICAgdW5pZm9ybXM6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZV9kYXRhW3RpbGVdO1xuICAgIH0sXG5cbiAgICAvLyBGaW5hbGl6ZXMgYW4gb2JqZWN0IGhvbGRpbmcgZmVhdHVyZSBkYXRhIChmb3IgYSB0aWxlIG9yIG90aGVyIG9iamVjdClcbiAgICBlbmREYXRhICh0aWxlKSB7XG4gICAgICAgIHZhciB0aWxlX2RhdGEgPSB0aGlzLnRpbGVfZGF0YVt0aWxlXTtcbiAgICAgICAgaWYgKHRpbGVfZGF0YSAmJiB0aWxlX2RhdGEudmVydGV4X2RhdGEpIHtcbiAgICAgICAgICAgIC8vIE9ubHkga2VlcCBmaW5hbCBieXRlIGJ1ZmZlclxuICAgICAgICAgICAgdGlsZV9kYXRhLnZlcnRleF9kYXRhLmVuZCgpO1xuICAgICAgICAgICAgdGlsZV9kYXRhLnZlcnRleF9kYXRhID0gdGlsZV9kYXRhLnZlcnRleF9kYXRhLmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbGVfZGF0YVt0aWxlXSA9IG51bGw7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGlsZV9kYXRhKTtcbiAgICB9LFxuXG4gICAgLy8gSGFzIG1lc2ggZGF0YSBmb3IgYSBnaXZlbiB0aWxlP1xuICAgIGhhc0RhdGFGb3JUaWxlICh0aWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVfZGF0YVt0aWxlXSAhPSBudWxsO1xuICAgIH0sXG5cbiAgICBhZGRGZWF0dXJlIChmZWF0dXJlLCBydWxlLCBjb250ZXh0KSB7XG4gICAgICAgIGxldCB0aWxlID0gY29udGV4dC50aWxlO1xuICAgICAgICBpZiAodGlsZS5nZW5lcmF0aW9uICE9PSB0aGlzLmdlbmVyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy50aWxlX2RhdGFbdGlsZS5rZXldKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RGF0YSh0aWxlLmtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3R5bGUgPSB0aGlzLnBhcnNlRmVhdHVyZShmZWF0dXJlLCBydWxlLCBjb250ZXh0KTtcblxuICAgICAgICAvLyBTa2lwIGZlYXR1cmU/XG4gICAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpcnN0IGZlYXR1cmUgaW4gdGhpcyByZW5kZXIgc3R5bGU/XG4gICAgICAgIGlmICghdGhpcy50aWxlX2RhdGFbdGlsZS5rZXldLnZlcnRleF9kYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnRpbGVfZGF0YVt0aWxlLmtleV0udmVydGV4X2RhdGEgPSB0aGlzLnZlcnRleF9sYXlvdXQuY3JlYXRlVmVydGV4RGF0YSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5idWlsZEdlb21ldHJ5KGZlYXR1cmUuZ2VvbWV0cnksIHN0eWxlLCB0aGlzLnRpbGVfZGF0YVt0aWxlLmtleV0udmVydGV4X2RhdGEsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBidWlsZEdlb21ldHJ5IChnZW9tZXRyeSwgc3R5bGUsIHZlcnRleF9kYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRQb2x5Z29ucyhbZ2VvbWV0cnkuY29vcmRpbmF0ZXNdLCBzdHlsZSwgdmVydGV4X2RhdGEsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkUG9seWdvbnMoZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIHN0eWxlLCB2ZXJ0ZXhfZGF0YSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkTGluZXMoW2dlb21ldHJ5LmNvb3JkaW5hdGVzXSwgc3R5bGUsIHZlcnRleF9kYXRhLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTXVsdGlMaW5lU3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5idWlsZExpbmVzKGdlb21ldHJ5LmNvb3JkaW5hdGVzLCBzdHlsZSwgdmVydGV4X2RhdGEsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2ludCcpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRQb2ludHMoW2dlb21ldHJ5LmNvb3JkaW5hdGVzXSwgc3R5bGUsIHZlcnRleF9kYXRhLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2ludCcpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRQb2ludHMoZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIHN0eWxlLCB2ZXJ0ZXhfZGF0YSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcGFyc2VGZWF0dXJlIChmZWF0dXJlLCBydWxlX3N0eWxlLCBjb250ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmZlYXR1cmVfc3R5bGU7XG5cbiAgICAgICAgICAgIC8vIFByZXByb2Nlc3MgZmlyc3QgdGltZVxuICAgICAgICAgICAgaWYgKCFydWxlX3N0eWxlLnByZXByb2Nlc3NlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJlcHJvY2VzcyhydWxlX3N0eWxlKTtcbiAgICAgICAgICAgICAgICBydWxlX3N0eWxlLnByZXByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBvcmRlciBpZiBpdCB3YXMgbm90IGNhY2hlZFxuICAgICAgICAgICAgc3R5bGUub3JkZXIgPSB0aGlzLnBhcnNlT3JkZXIocnVsZV9zdHlsZS5vcmRlciwgY29udGV4dCk7XG5cbiAgICAgICAgICAgIC8vIEZlYXR1cmUgc2VsZWN0aW9uIChvbmx5IGlmIHN0eWxlIHN1cHBvcnRzIGl0KVxuICAgICAgICAgICAgdmFyIHNlbGVjdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHN0eWxlLmludGVyYWN0aXZlID0gcnVsZV9zdHlsZS5pbnRlcmFjdGl2ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGUuaW50ZXJhY3RpdmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0YWJsZSA9IHN0eWxlLmludGVyYWN0aXZlKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0YWJsZSA9IHN0eWxlLmludGVyYWN0aXZlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgZmVhdHVyZSBpcyBtYXJrZWQgYXMgc2VsZWN0YWJsZVxuICAgICAgICAgICAgaWYgKHNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5zZWxlY3Rpb25fY29sb3IgPSBGZWF0dXJlU2VsZWN0aW9uLm1ha2VDb2xvcihmZWF0dXJlLCBjb250ZXh0LnRpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuc2VsZWN0aW9uX2NvbG9yID0gRmVhdHVyZVNlbGVjdGlvbi5kZWZhdWx0Q29sb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN1YmNsYXNzIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICBzdHlsZSA9IHRoaXMuX3BhcnNlRmVhdHVyZShmZWF0dXJlLCBydWxlX3N0eWxlLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgICBsb2cuZXJyb3IoJ1N0eWxlLnBhcnNlRmVhdHVyZTogc3R5bGUgcGFyc2luZyBlcnJvcicsIGZlYXR1cmUsIHN0eWxlLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3BhcnNlRmVhdHVyZSAoZmVhdHVyZSwgcnVsZV9zdHlsZSwgY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgTWV0aG9kTm90SW1wbGVtZW50ZWQoJ19wYXJzZUZlYXR1cmUnKTtcbiAgICB9LFxuXG4gICAgcHJlcHJvY2VzcyAoKSB7fSxcblxuICAgIC8vIFBhcnNlIGFuIG9yZGVyIHZhbHVlXG4gICAgcGFyc2VPcmRlciAob3JkZXIsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG9yZGVyIGlmIGl0IHdhcyBub3QgY2FjaGVkXG4gICAgICAgIGlmICh0eXBlb2Ygb3JkZXIgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gU3R5bGVQYXJzZXIuY2FsY3VsYXRlT3JkZXIob3JkZXIsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmRlcjtcbiAgICB9LFxuXG4gICAgLy8gUGFyc2UgYSBjb2xvciBvZiBjaG9vc2UgYSBkZWZhdWx0IGlmIGFjY2VwdGFibGUsIHJldHVybiB1bmRlZmluZWQgaWYgY29sb3IgbWlzc2luZ1xuICAgIHBhcnNlQ29sb3IoY29sb3IsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gTmVlZCBlaXRoZXIgYSBjb2xvciwgb3IgYSBzaGFkZXIgYmxvY2sgZm9yICdjb2xvcicgb3IgJ2ZpbHRlcidcbiAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gU3R5bGVQYXJzZXIuY2FjaGVDb2xvcihjb2xvciwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zaGFkZXJzLmJsb2Nrcy5jb2xvciB8fCB0aGlzLnNoYWRlcnMuYmxvY2tzLmZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIFN0eWxlUGFyc2VyLmRlZmF1bHRzLmNvbG9yO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEJ1aWxkIGZ1bmN0aW9ucyBhcmUgbm8tb3BzIHVudGlsIG92ZXJyaWRlblxuICAgIGJ1aWxkUG9seWdvbnMgKCkge30sXG4gICAgYnVpbGRMaW5lcyAoKSB7fSxcbiAgICBidWlsZFBvaW50cyAoKSB7fSxcblxuXG4gICAgLyoqKiBHTCBzdGF0ZSBhbmQgcmVuZGVyaW5nICoqKi9cblxuICAgIHNldEdMIChnbCkge1xuICAgICAgICB0aGlzLmdsID0gZ2w7XG4gICAgfSxcblxuICAgIG1ha2VNZXNoICh2ZXJ0ZXhfZGF0YSwgeyB1bmlmb3JtcyB9ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWQk9NZXNoKHRoaXMuZ2wsIHZlcnRleF9kYXRhLCB0aGlzLnZlcnRleF9sYXlvdXQsIHsgdW5pZm9ybXMgfSk7XG4gICAgfSxcblxuICAgIGNvbXBpbGUgKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ2wpIHtcbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcihgc3R5bGUuY29tcGlsZSgpOiBza2lwcGluZyBmb3IgJHt0aGlzLm5hbWV9IGJlY2F1c2Ugbm8gR0wgY29udGV4dGApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNvbXBpbGluZykge1xuICAgICAgICAgICAgdGhyb3cobmV3IEVycm9yKGBzdHlsZS5jb21waWxlKCk6IHNraXBwaW5nIGZvciAke3RoaXMubmFtZX0gYmVjYXVzZSBzdHlsZSBpcyBhbHJlYWR5IGNvbXBpbGluZ2ApKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBpbGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuY29tcGlsZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBCdWlsZCBkZWZpbmVzICYgZm9yIHNlbGVjdGlvbiAobmVlZCB0byBjcmVhdGUgYSBuZXcgb2JqZWN0IHNpbmNlIHRoZSBmaXJzdCBpcyBzdG9yZWQgYXMgYSByZWZlcmVuY2UgYnkgdGhlIHByb2dyYW0pXG4gICAgICAgIHZhciBkZWZpbmVzID0gdGhpcy5idWlsZERlZmluZUxpc3QoKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uX2RlZmluZXMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZpbmVzKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbl9kZWZpbmVzLlRBTkdSQU1fRkVBVFVSRV9TRUxFQ1RJT04gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGFueSBjdXN0b20gY29kZSBibG9ja3MsIHVuaWZvcm0gZGVwZW5kZW5jaWVzLCBldGMuXG4gICAgICAgIHZhciBibG9ja3MgPSAodGhpcy5zaGFkZXJzICYmIHRoaXMuc2hhZGVycy5ibG9ja3MpO1xuICAgICAgICB2YXIgdW5pZm9ybXMgPSAodGhpcy5zaGFkZXJzICYmIHRoaXMuc2hhZGVycy51bmlmb3Jtcyk7XG5cbiAgICAgICAgLy8gYWNjZXB0IGEgc2luZ2xlIGV4dGVuc2lvbiwgb3IgYW4gYXJyYXkgb2YgZXh0ZW5zaW9uc1xuICAgICAgICB2YXIgZXh0ZW5zaW9ucyA9ICh0aGlzLnNoYWRlcnMgJiYgdGhpcy5zaGFkZXJzLmV4dGVuc2lvbnMpO1xuICAgICAgICBpZiAodHlwZW9mIGV4dGVuc2lvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zID0gW2V4dGVuc2lvbnNdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIHNoYWRlcnNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbSA9IG5ldyBTaGFkZXJQcm9ncmFtKFxuICAgICAgICAgICAgICAgIHRoaXMuZ2wsXG4gICAgICAgICAgICAgICAgc2hhZGVyU291cmNlc1t0aGlzLnZlcnRleF9zaGFkZXJfa2V5XSxcbiAgICAgICAgICAgICAgICBzaGFkZXJTb3VyY2VzW3RoaXMuZnJhZ21lbnRfc2hhZGVyX2tleV0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZXMsXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zLFxuICAgICAgICAgICAgICAgICAgICBibG9ja3MsXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtLmNvbXBpbGUoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25fcHJvZ3JhbSA9IG5ldyBTaGFkZXJQcm9ncmFtKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsLFxuICAgICAgICAgICAgICAgICAgICBzaGFkZXJTb3VyY2VzW3RoaXMudmVydGV4X3NoYWRlcl9rZXldLFxuICAgICAgICAgICAgICAgICAgICBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3NlbGVjdGlvbl9mcmFnbWVudCddLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAodGhpcy5uYW1lICsgJyAoc2VsZWN0aW9uKScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lczogc2VsZWN0aW9uX2RlZmluZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25fcHJvZ3JhbS5jb21waWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbl9wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5jb21waWxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY29tcGlsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcihgc3R5bGUuY29tcGlsZSgpOiBzdHlsZSAke3RoaXMubmFtZX0gZXJyb3I6YCwgZXJyb3IpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tcGlsaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcGlsZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBzaGFkZXIgYmxvY2tcbiAgICBhZGRTaGFkZXJCbG9jayAoa2V5LCAuLi5ibG9ja3MpIHtcbiAgICAgICAgdGhpcy5zaGFkZXJzLmJsb2NrcyA9IHRoaXMuc2hhZGVycy5ibG9ja3MgfHwge307XG4gICAgICAgIHRoaXMuc2hhZGVycy5ibG9ja3Nba2V5XSA9IHRoaXMuc2hhZGVycy5ibG9ja3Nba2V5XSB8fCBbXTtcbiAgICAgICAgdGhpcy5zaGFkZXJzLmJsb2Nrc1trZXldLnB1c2goLi4uYmxvY2tzKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGFsbCBzaGFkZXIgYmxvY2tzIGZvciBrZXlcbiAgICByZW1vdmVTaGFkZXJCbG9jayAoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLnNoYWRlcnMuYmxvY2tzKSB7XG4gICAgICAgICAgICB0aGlzLnNoYWRlcnMuYmxvY2tzW2tleV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlcGxhY2VTaGFkZXJCbG9jayAoa2V5LCAuLi5ibG9ja3MpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVTaGFkZXJCbG9jayhrZXkpO1xuICAgICAgICB0aGlzLmFkZFNoYWRlckJsb2NrKGtleSwgLi4uYmxvY2tzKTtcbiAgICB9LFxuXG4gICAgLyoqIFRPRE86IGNvdWxkIHByb2JhYmx5IGNvbWJpbmUgYW5kIGdlbmVyYWxpemUgdGhpcyB3aXRoIHNpbWlsYXIgbWV0aG9kIGluIFNoYWRlclByb2dyYW1cbiAgICAgKiAobGlzdCBvZiBkZWZpbmUgb2JqZWN0cyB0aGF0IGluaGVyaXQgZnJvbSBlYWNoIG90aGVyKVxuICAgICAqL1xuICAgIGJ1aWxkRGVmaW5lTGlzdCAoKSB7XG4gICAgICAgIC8vIEFkZCBhbnkgY3VzdG9tIGRlZmluZXMgdG8gYnVpbHQtaW4gc3R5bGUgZGVmaW5lc1xuICAgICAgICB2YXIgZGVmaW5lcyA9IHt9OyAvLyBjcmVhdGUgYSBuZXcgb2JqZWN0IHRvIGF2b2lkIG11dGF0aW5nIGEgcHJvdG90eXBlIHZhbHVlIHRoYXQgbWF5IGJlIHNoYXJlZCB3aXRoIG90aGVyIHN0eWxlc1xuICAgICAgICBpZiAodGhpcy5kZWZpbmVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgaW4gdGhpcy5kZWZpbmVzKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lc1tkXSA9IHRoaXMuZGVmaW5lc1tkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaGFkZXJzICE9IG51bGwgJiYgdGhpcy5zaGFkZXJzLmRlZmluZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChkIGluIHRoaXMuc2hhZGVycy5kZWZpbmVzKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lc1tkXSA9IHRoaXMuc2hhZGVycy5kZWZpbmVzW2RdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZpbmVzO1xuXG4gICAgfSxcblxuICAgIC8vIFNldHVwIGFueSBHTCBzdGF0ZSBmb3IgcmVuZGVyaW5nXG4gICAgc2V0dXAgKCkge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm1zKCk7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwuc2V0dXBQcm9ncmFtKFNoYWRlclByb2dyYW0uY3VycmVudCk7XG4gICAgfSxcblxuICAgIC8vIFNldCBzdHlsZSB1bmlmb3JtcyBvbiBjdXJyZW50bHkgYm91bmQgcHJvZ3JhbVxuICAgIHNldFVuaWZvcm1zICgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBTaGFkZXJQcm9ncmFtLmN1cnJlbnQ7XG4gICAgICAgIGlmICghcHJvZ3JhbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvZ3JhbS5zZXRVbmlmb3Jtcyh0aGlzLnNoYWRlcnMgJiYgdGhpcy5zaGFkZXJzLnVuaWZvcm1zLCB0cnVlKTsgLy8gcmVzZXQgdGV4dHVyZSB1bml0IHRvIDBcbiAgICB9LFxuXG4gICAgdXBkYXRlICgpIHtcbiAgICAgICAgLy8gU3R5bGUtc3BlY2lmaWMgYW5pbWF0aW9uXG4gICAgICAgIC8vIGlmICh0eXBlb2YgdGhpcy5hbmltYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gICAgIHRoaXMuYW5pbWF0aW9uKCk7XG4gICAgICAgIC8vIH1cbiAgICB9XG59O1xuIiwiLy8gTWFuYWdlIHJlbmRlcmluZyBzdHlsZXNcblxuaW1wb3J0IFV0aWxzIGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBTaGFkZXJQcm9ncmFtIGZyb20gJy4uL2dsL3NoYWRlcl9wcm9ncmFtJztcbmltcG9ydCBzaGFkZXJTb3VyY2VzIGZyb20gJy4uL2dsL3NoYWRlcl9zb3VyY2VzJzsgLy8gYnVpbHQtaW4gc2hhZGVyc1xuaW1wb3J0IHtTdHlsZX0gZnJvbSAnLi9zdHlsZSc7XG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG5leHBvcnQgdmFyIFN0eWxlTWFuYWdlciA9IHt9O1xuZXhwb3J0IHZhciBTdHlsZXMgPSB7fTtcbmV4cG9ydCB2YXIgQmFzZVN0eWxlcyA9IHt9O1xuXG5TdHlsZU1hbmFnZXIuc3R5bGVzID0gU3R5bGVzO1xuXG4vLyBTZXQgdGhlIGJhc2Ugb2JqZWN0IHVzZWQgdG8gaW5zdGFudGlhdGUgc3R5bGVzXG5TdHlsZU1hbmFnZXIuYmFzZVN0eWxlID0gU3R5bGU7XG5cbi8vIEdsb2JhbCBjb25maWd1cmF0aW9uIGZvciBhbGwgc3R5bGVzXG5TdHlsZU1hbmFnZXIuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoU3R5bGVNYW5hZ2VyLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBTaGFkZXJQcm9ncmFtLnJlbW92ZUJsb2NrKCdnbG9iYWwnKTtcblxuICAgIC8vIExheWVyIHJlLW9yZGVyaW5nIGZ1bmN0aW9uXG4gICAgU2hhZGVyUHJvZ3JhbS5hZGRCbG9jaygnZ2xvYmFsJywgc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9sYXllcl9vcmRlciddKTtcblxuICAgIC8vIEZlYXR1cmUgc2VsZWN0aW9uIGdsb2JhbFxuICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soJ2dsb2JhbCcsIHNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvc2VsZWN0aW9uX2dsb2JhbHMnXSk7XG5cbiAgICAvLyBXb3JsZCBwb3NpdGlvbiB3cmFwcGluZ1xuICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soJ2dsb2JhbCcsIHNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvd29ybGRfcG9zaXRpb25fd3JhcCddKTtcblxuICAgIC8vIEZlYXR1cmUgc2VsZWN0aW9uIHZlcnRleCBzaGFkZXIgc3VwcG9ydFxuICAgIFNoYWRlclByb2dyYW0ucmVwbGFjZUJsb2NrKCdmZWF0dXJlLXNlbGVjdGlvbi12ZXJ0ZXgnLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3NlbGVjdGlvbl92ZXJ0ZXgnXSk7XG5cbiAgICAvLyBhc3N1bWUgbWluIDE2LWJpdCBkZXB0aCBidWZmZXIsIGluIHByYWN0aWNlIHVzZXMgMTQtYml0cywgMSBleHRyYSBiaXQgdG8gaGFuZGxlIHZpcnR1YWwgaGFsZi1sYXllcnNcbiAgICAvLyBmb3Igb3V0bGluZXMgKGluc2VydGVkIGluIGJldHdlZW4gbGF5ZXJzKSwgYW5vdGhlciBleHRyYSBiaXQgdG8gcHJldmVudCBwcmVjaXNpb24gbG9zc1xuICAgIFNoYWRlclByb2dyYW0uZGVmaW5lcy5UQU5HUkFNX0xBWUVSX0RFTFRBID0gMSAvICgxIDw8IDE0KTtcblxuICAgIFN0eWxlTWFuYWdlci5pbml0aWFsaXplZCA9IHRydWU7XG59O1xuXG4vLyBEZXN0cm95IGFsbCBzdHlsZXMgZm9yIGEgZ2l2ZW4gR0wgY29udGV4dFxuU3R5bGVNYW5hZ2VyLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZ2wpIHtcbiAgICBPYmplY3Qua2V5cyhTdHlsZXMpLmZvckVhY2goKF9uYW1lKSA9PiB7XG4gICAgICAgIHZhciBzdHlsZSA9IFN0eWxlc1tfbmFtZV07XG4gICAgICAgIGlmIChzdHlsZS5nbCA9PT0gZ2wpIHtcbiAgICAgICAgICAgIGxvZy50cmFjZShgU3R5bGVNYW5hZ2VyLmRlc3Ryb3k6IGRlc3Ryb3lpbmcgcmVuZGVyIHN0eWxlICR7c3R5bGUubmFtZX1gKTtcblxuICAgICAgICAgICAgaWYgKCFzdHlsZS5pc0J1aWx0SW4oKSkge1xuICAgICAgICAgICAgICAgIFN0eWxlTWFuYWdlci5yZW1vdmUoc3R5bGUubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8vIFJlZ2lzdGVyIGEgc3R5bGVcblN0eWxlTWFuYWdlci5yZWdpc3RlciA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgIFN0eWxlc1tzdHlsZS5uYW1lXSA9IHN0eWxlO1xuICAgIEJhc2VTdHlsZXNbc3R5bGUubmFtZV0gPSBzdHlsZTtcbn07XG5cbi8vIFJlbW92ZSBhIHN0eWxlXG5TdHlsZU1hbmFnZXIucmVtb3ZlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBkZWxldGUgU3R5bGVzW25hbWVdO1xufTtcblxuLy8gUHJlbG9hZHMgbmV0d29yayByZXNvdXJjZXMgaW4gdGhlIHN0eWxlc2hlZXQgKHNoYWRlcnMsIHRleHR1cmVzLCBldGMuKVxuU3R5bGVNYW5hZ2VyLnByZWxvYWQgPSBmdW5jdGlvbiAoc3R5bGVzLCBiYXNlKSB7XG4gICAgLy8gRmlyc3QgbG9hZCByZW1vdGUgc3R5bGVzLCB0aGVuIGxvYWQgc2hhZGVyIGJsb2NrcyBmcm9tIHJlbW90ZSBVUkxzXG4gICAgcmV0dXJuIFN0eWxlTWFuYWdlci5sb2FkUmVtb3RlU3R5bGVzKHN0eWxlcywgYmFzZSkudGhlbihzdHlsZXMgPT4gU3R5bGVNYW5hZ2VyLmxvYWRTaGFkZXJCbG9ja3Moc3R5bGVzLCBiYXNlKSk7XG59O1xuXG4vLyBMb2FkIHN0eWxlIGRlZmluaXRpb25zIGZyb20gZXh0ZXJuYWwgVVJMc1xuU3R5bGVNYW5hZ2VyLmxvYWRSZW1vdGVTdHlsZXMgPSBmdW5jdGlvbiAoc3R5bGVzLCBiYXNlKSB7XG4gICAgLy8gQ29sbGVjdCBVUkxzIGFuZCBtb2RlcyB0byBpbXBvcnQgZnJvbSB0aGVtXG4gICAgLy8gVGhpcyBpcyBkb25lIGFzIGEgc2VwYXJhdGUgc3RlcCBiZWN1YXNlIGl0IGlzIHBvc3NpYmxlIHRvIGltcG9ydCBtdWx0aXBsZSBtb2RlcyBmcm9tIGEgc2luZ2xlXG4gICAgLy8gVVJMLCBhbmQgd2Ugd2FudCB0byBhdm9pZCBkdXBsaWNhdGUgY2FsbHMgZm9yIHRoZSBzYW1lIGZpbGUuXG4gICAgdmFyIHVybHMgPSB7fTtcbiAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xuICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZXNbbmFtZV07XG4gICAgICAgIGlmIChzdHlsZS51cmwpIHtcbiAgICAgICAgICAgIGxldCB1cmwgPSBzdHlsZS51cmw7XG4gICAgICAgICAgICBpZiAoYmFzZSkge1xuICAgICAgICAgICAgICAgIHVybCA9IFV0aWxzLmFkZEJhc2VVUkwodXJsLCBiYXNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF1cmxzW3VybF0pIHtcbiAgICAgICAgICAgICAgICB1cmxzW3VybF0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBhIGxpc3Qgb2YgdGhlIHN0eWxlcyB0byBpbXBvcnQgZm9yIHRoaXMgVVJMXG4gICAgICAgICAgICB1cmxzW3VybF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0X25hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgc291cmNlX25hbWU6IHN0eWxlLm5hbWUgfHwgbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBcyBlYWNoIFVSTCBmaW5pc2hlcyBsb2FkaW5nLCByZXBsYWNlIHRoZSB0YXJnZXQgc3R5bGUocylcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoT2JqZWN0LmtleXModXJscykubWFwKHVybCA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBVdGlscy5sb2FkUmVzb3VyY2UodXJsKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gTWl4aW4gcmVtb3RlIHN0eWxlcywgd2l0aGluIGVhY2ggcmVtb3RlIGZpbGVcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzb3VyY2Vfc3R5bGUgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBTdHlsZU1hbmFnZXIubWl4KGRhdGFbc291cmNlX3N0eWxlXSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJlbW90ZSBzdHlsZXMgdG8gbG9jYWwgc3R5bGVzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdGFyZ2V0IG9mIHVybHNbdXJsXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhW3RhcmdldC5zb3VyY2VfbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1t0YXJnZXQudGFyZ2V0X25hbWVdID0gZGF0YVt0YXJnZXQuc291cmNlX25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlc1t0YXJnZXQudGFyZ2V0X25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYFN0eWxlTWFuYWdlci5wcmVsb2FkOiBlcnJvciBpbXBvcnRpbmcgc3R5bGUgJHt0YXJnZXQudGFyZ2V0X25hbWV9LCBjb3VsZCBub3QgZmluZCBzb3VyY2Ugc3R5bGUgJHt0YXJnZXQuc291cmNlX25hbWV9IGluICR7dXJsfWApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKGBTdHlsZU1hbmFnZXIucHJlbG9hZDogZXJyb3IgaW1wb3J0aW5nIHN0eWxlKHMpICR7SlNPTi5zdHJpbmdpZnkodXJsc1t1cmxdKX0gZnJvbSAke3VybH1gLCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSkpLnRoZW4oKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHN0eWxlcykpO1xufTtcblxuLy8gUHJlbG9hZCBzaGFkZXIgYmxvY2tzIGZyb20gZXh0ZXJuYWwgVVJMc1xuU3R5bGVNYW5hZ2VyLmxvYWRTaGFkZXJCbG9ja3MgPSBmdW5jdGlvbiAoc3R5bGVzLCBiYXNlKSB7XG4gICAgdmFyIHF1ZXVlID0gW107XG4gICAgZm9yICh2YXIgc3R5bGUgb2YgVXRpbHMudmFsdWVzKHN0eWxlcykpIHtcbiAgICAgICAgaWYgKHN0eWxlLnNoYWRlcnMgJiYgc3R5bGUuc2hhZGVycy5ibG9ja3MpIHtcbiAgICAgICAgICAgIGxldCBfYmxvY2tzID0gc3R5bGUuc2hhZGVycy5ibG9ja3M7XG5cbiAgICAgICAgICAgIGZvciAobGV0IFtrZXksIGJsb2NrXSBvZiBVdGlscy5lbnRyaWVzKHN0eWxlLnNoYWRlcnMuYmxvY2tzKSkge1xuICAgICAgICAgICAgICAgIGxldCBfa2V5ID0ga2V5O1xuXG4gICAgICAgICAgICAgICAgLy8gQXJyYXkgb2YgYmxvY2tzXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYmxvY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGI9MDsgYiA8IGJsb2NrLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJsb2NrW2JdID09PSAnb2JqZWN0JyAmJiBibG9ja1tiXS51cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgX2luZGV4ID0gYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdXJsID0gYmxvY2tbYl0udXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFV0aWxzLmFkZEJhc2VVUkwodXJsLCBiYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKFV0aWxzLmlvKFV0aWxzLmNhY2hlQnVzdGVyRm9yVXJsKHVybCkpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Jsb2Nrc1tfa2V5XVtfaW5kZXhdID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmVycm9yKGBTdHlsZU1hbmFnZXIubG9hZFNoYWRlckJsb2NrczogZXJyb3IgbG9hZGluZyBzaGFkZXIgYmxvY2tgLCBfYmxvY2tzLCBfa2V5LCBfaW5kZXgsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2luZ2xlIGJsb2NrXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGJsb2NrID09PSAnb2JqZWN0JyAmJiBibG9jay51cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVybCA9IGJsb2NrLnVybDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFV0aWxzLmFkZEJhc2VVUkwodXJsLCBiYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goVXRpbHMuaW8oVXRpbHMuY2FjaGVCdXN0ZXJGb3JVcmwodXJsKSkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2Jsb2Nrc1tfa2V5XSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmVycm9yKGBTdHlsZU1hbmFnZXIubG9hZFNoYWRlckJsb2NrczogZXJyb3IgbG9hZGluZyBzaGFkZXIgYmxvY2tgLCBfYmxvY2tzLCBfa2V5LCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHF1ZXVlKS50aGVuKCgpID0+IFByb21pc2UucmVzb2x2ZShzdHlsZXMpKTsgLy8gVE9ETzogYWRkIGVycm9yXG59O1xuXG5TdHlsZU1hbmFnZXIubWl4ID0gZnVuY3Rpb24gKHN0eWxlLCBzdHlsZXMpIHtcbiAgICAvLyBFeGl0IGVhcmx5IGlmIHdlIGhhdmUgYWxyZWFkeSBhcHBsaWVkIG1peGlucyB0byB0aGlzIHN0eWxlXG4gICAgaWYgKHN0eWxlLm1peGVkKSB7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG5cbiAgICAvLyBNaXhpbiBzb3VyY2VzLCBpbiBvcmRlclxuICAgIGxldCBzb3VyY2VzID0gW107XG4gICAgaWYgKHN0eWxlLm1peCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZS5taXgpKSB7XG4gICAgICAgICAgICBzb3VyY2VzLnB1c2goLi4uc3R5bGUubWl4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZXMucHVzaChzdHlsZS5taXgpO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZXMgPSBzb3VyY2VzLm1hcCh4ID0+IHN0eWxlc1t4XSkuZmlsdGVyKHggPT4geCk7XG4gICAgfVxuICAgIHNvdXJjZXMucHVzaChzdHlsZSk7XG5cbiAgICAvLyBGbGFncyAtIE9SJ2QsIHRydWUgaWYgYW55IHN0eWxlIGhhcyBpdCBzZXRcbiAgICBzdHlsZS5hbmltYXRlZCA9IHNvdXJjZXMuc29tZSh4ID0+IHggJiYgeC5hbmltYXRlZCk7XG4gICAgc3R5bGUudGV4Y29vcmRzID0gc291cmNlcy5zb21lKHggPT4geCAmJiB4LnRleGNvb3Jkcyk7XG5cbiAgICAvLyBPdmVyd3JpdGVzIC0gbGFzdCBkZWZpbml0aW9uIHdpbnNcbiAgICBzdHlsZS5iYXNlID0gc291cmNlcy5tYXAoeCA9PiB4LmJhc2UpLmZpbHRlcih4ID0+IHgpLnBvcCgpO1xuICAgIHN0eWxlLmxpZ2h0aW5nID0gc291cmNlcy5tYXAoeCA9PiB4LmxpZ2h0aW5nKS5maWx0ZXIoeCA9PiB4ICE9IG51bGwpLnBvcCgpO1xuICAgIHN0eWxlLnRleHR1cmUgPSBzb3VyY2VzLm1hcCh4ID0+IHgudGV4dHVyZSkuZmlsdGVyKHggPT4geCkucG9wKCk7XG4gICAgaWYgKHNvdXJjZXMuc29tZSh4ID0+IHguYmxlbmQpKSB7XG4gICAgICAgIC8vIG9ubHkgbWl4IGJsZW5kIGlmIGV4cGxpY2l0bHkgc2V0LCBvdGhlcndpc2UgbGV0IGJhc2Ugc3R5bGUgY2hvb3NlIGJsZW5kaW5nIG1vZGVcbiAgICAgICAgc3R5bGUuYmxlbmQgPSBzb3VyY2VzLm1hcCh4ID0+IHguYmxlbmQpLmZpbHRlcih4ID0+IHgpLnBvcCgpO1xuICAgIH1cblxuICAgIC8vIE1lcmdlcyAtIHByb3BlcnR5LXNwZWNpZmljIHJ1bGVzIGZvciBtZXJnaW5nIHZhbHVlc1xuICAgIHN0eWxlLmRlZmluZXMgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5zb3VyY2VzLm1hcCh4ID0+IHguZGVmaW5lcykuZmlsdGVyKHggPT4geCkpO1xuICAgIHN0eWxlLm1hdGVyaWFsID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uc291cmNlcy5tYXAoeCA9PiB4Lm1hdGVyaWFsKS5maWx0ZXIoeCA9PiB4KSk7XG5cbiAgICBsZXQgbWVyZ2UgPSBzb3VyY2VzLm1hcCh4ID0+IHguc2hhZGVycykuZmlsdGVyKHggPT4geCk7XG4gICAgbGV0IHNoYWRlcnMgPSB7fTtcbiAgICBzaGFkZXJzLmRlZmluZXMgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5tZXJnZS5tYXAoeCA9PiB4LmRlZmluZXMpLmZpbHRlcih4ID0+IHgpKTtcbiAgICBzaGFkZXJzLnVuaWZvcm1zID0gT2JqZWN0LmFzc2lnbih7fSwgLi4ubWVyZ2UubWFwKHggPT4geC51bmlmb3JtcykuZmlsdGVyKHggPT4geCkpO1xuXG4gICAgLy8gQnVpbGQgYSBsaXN0IG9mIHVuaXF1ZSBleHRlbnNpb25zXG4gICAgc2hhZGVycy5leHRlbnNpb25zID0gT2JqZWN0LmtleXMobWVyZ2VcbiAgICAgICAgLm1hcCh4ID0+IHguZXh0ZW5zaW9ucylcbiAgICAgICAgLmZpbHRlcih4ID0+IHgpXG4gICAgICAgIC5yZWR1Y2UoKHByZXYsIGN1cikgPT4ge1xuICAgICAgICAgICAgLy8gc2luZ2xlIGV4dGVuc2lvblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcHJldltjdXJdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFycmF5IG9mIGV4dGVuc2lvbnNcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1ci5mb3JFYWNoKHggPT4gcHJldlt4XSA9IHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH0sIHt9KSB8fCB7fVxuICAgICk7XG5cbiAgICBtZXJnZS5tYXAoeCA9PiB4LmJsb2NrcykuZmlsdGVyKHggPT4geCkuZm9yRWFjaChibG9ja3MgPT4ge1xuICAgICAgICBzaGFkZXJzLmJsb2NrcyA9IHNoYWRlcnMuYmxvY2tzIHx8IHt9O1xuXG4gICAgICAgIGZvciAobGV0IFt0LCBibG9ja10gb2YgVXRpbHMuZW50cmllcyhibG9ja3MpKSB7XG4gICAgICAgICAgICBzaGFkZXJzLmJsb2Nrc1t0XSA9IHNoYWRlcnMuYmxvY2tzW3RdIHx8IFtdO1xuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShibG9jaykpIHtcbiAgICAgICAgICAgICAgICBzaGFkZXJzLmJsb2Nrc1t0XS5wdXNoKC4uLmJsb2NrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNoYWRlcnMuYmxvY2tzW3RdLnB1c2goYmxvY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBzdHlsZS5zaGFkZXJzID0gc2hhZGVycztcbiAgICBzdHlsZS5taXhlZCA9IHRydWU7IC8vIHRyYWNrIHRoYXQgd2UgYWxyZWFkeSBhcHBsaWVkIG1peGlucyAoYXZvaWQgZHVwZSB3b3JrIGxhdGVyKVxuXG4gICAgcmV0dXJuIHN0eWxlO1xufTtcblxuLy8gQ3JlYXRlIGEgbmV3IHN0eWxlXG4vLyBuYW1lOiBuYW1lIG9mIG5ldyBzdHlsZVxuLy8gY29uZmlnOiBwcm9wZXJ0aWVzIG9mIG5ldyBzdHlsZVxuLy8gc3R5bGVzOiB3b3JraW5nIHNldCBvZiBzdHlsZXMgYmVpbmcgYnVpbHQgKHVzZWQgZm9yIG1peGluZyBpbiBleGlzdGluZyBzdHlsZXMpXG5TdHlsZU1hbmFnZXIuY3JlYXRlID0gZnVuY3Rpb24gKG5hbWUsIGNvbmZpZywgc3R5bGVzID0ge30pIHtcbiAgICBsZXQgc3R5bGUgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcpOyAvLyBzaGFsbG93IGNvcHlcbiAgICBzdHlsZS5uYW1lID0gbmFtZTtcblxuICAgIC8vIFN0eWxlIG1peGluc1xuICAgIFN0eWxlTWFuYWdlci5taXgoc3R5bGUsIHN0eWxlcyk7XG5cbiAgICAvLyBIYXMgYmFzZSBzdHlsZT9cbiAgICAvLyBPbmx5IHJlbmRlcmFibGUgKGluc3RhbnRpYXRlZCkgc3R5bGVzIHNob3VsZCBiZSBpbmNsdWRlZCBmb3IgcnVuLXRpbWUgdXNlXG4gICAgLy8gT3RoZXJzIGFyZSBpbnRlcm1lZGlhcnkvYWJzdHJhY3QsIHVzZWQgZHVyaW5nIHN0eWxlIGNvbXBvc2l0aW9uIGJ1dCBub3QgZXhlY3V0aW9uXG4gICAgaWYgKHN0eWxlLmJhc2UgJiYgQmFzZVN0eWxlc1tzdHlsZS5iYXNlXSkge1xuICAgICAgICBTdHlsZXNbbmFtZV0gPSBzdHlsZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShCYXNlU3R5bGVzW3N0eWxlLmJhc2VdKSwgc3R5bGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbn07XG5cbi8vIENhbGxlZCB0byBjcmVhdGUgYW5kIGluaXRpYWxpemUgc3R5bGVzXG5TdHlsZU1hbmFnZXIuYnVpbGQgPSBmdW5jdGlvbiAoc3R5bGVzLCBzY2VuZSA9IHt9KSB7XG4gICAgLy8gU29ydCBzdHlsZXMgYnkgZGVwZW5kZW5jeSwgdGhlbiBidWlsZCB0aGVtXG4gICAgbGV0IHN0eWxlX2RlcHMgPSBPYmplY3Qua2V5cyhzdHlsZXMpLnNvcnQoXG4gICAgICAgIChhLCBiKSA9PiBTdHlsZU1hbmFnZXIuaW5oZXJpdGFuY2VEZXB0aChhLCBzdHlsZXMpIC0gU3R5bGVNYW5hZ2VyLmluaGVyaXRhbmNlRGVwdGgoYiwgc3R5bGVzKVxuICAgICk7XG5cbiAgICAvLyBPbmx5IGtlZXAgYnVpbHQtaW4gYmFzZSBzdHlsZXNcbiAgICBmb3IgKGxldCBzbmFtZSBpbiBTdHlsZXMpIHtcbiAgICAgICAgaWYgKCFCYXNlU3R5bGVzW3NuYW1lXSkge1xuICAgICAgICAgICAgZGVsZXRlIFN0eWxlc1tzbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBTdHlsZXNbc25hbWVdLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXb3JraW5nIHNldCBvZiBzdHlsZXMgYmVpbmcgYnVpbHRcbiAgICBsZXQgd3MgPSB7fTtcbiAgICBmb3IgKGxldCBzbmFtZSBvZiBzdHlsZV9kZXBzKSB7XG4gICAgICAgIHdzW3NuYW1lXSA9IFN0eWxlTWFuYWdlci5jcmVhdGUoc25hbWUsIHN0eWxlc1tzbmFtZV0sIHdzKTtcbiAgICB9XG5cbiAgICBTdHlsZU1hbmFnZXIuaW5pdFN0eWxlcyhzY2VuZSk7XG4gICAgcmV0dXJuIFN0eWxlcztcbn07XG5cbi8vIEluaXRpYWxpemUgYWxsIHN0eWxlc1xuU3R5bGVNYW5hZ2VyLmluaXRTdHlsZXMgPSBmdW5jdGlvbiAoc2NlbmUpIHtcbiAgICAvLyBJbml0aWFsaXplIGFsbFxuICAgIGZvciAobGV0IHNuYW1lIGluIFN0eWxlcykge1xuICAgICAgICBTdHlsZXNbc25hbWVdLmluaXQoc2NlbmUpO1xuICAgIH1cbn07XG5cbi8vIEdpdmVuIGEgc3R5bGUga2V5IGluIGEgc2V0IG9mIHN0eWxlcyB0byBhZGQsIGNvdW50IHRoZSBsZW5ndGggb2YgdGhlIGluaGVyaXRhbmNlIGNoYWluXG4vLyBUT0RPOiByZW1vdmUgY3VycmVudCAoU3R5bGVzKSBhbmQgZnV0dXJlIChzdHlsZXMpIGR1cGxpY2F0aW9uLCBjb25mdXNpbmdcblN0eWxlTWFuYWdlci5pbmhlcml0YW5jZURlcHRoID0gZnVuY3Rpb24gKGtleSwgc3R5bGVzKSB7XG4gICAgbGV0IHBhcmVudHMgPSAwO1xuXG4gICAgd2hpbGUodHJ1ZSkge1xuICAgICAgICBsZXQgc3R5bGUgPSBzdHlsZXNba2V5XTtcbiAgICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHNjZW5lIGRlZiBlcnJvciwgdHJ5aW5nIHRvIGV4dGVuZCBhIHN0eWxlIHRoYXQgZG9lc24ndCBleGlzdFxuICAgICAgICAgICAgLy8gVE9ETzogd2Fybi90aHJvdz9cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVwZW5kZW5jeSBjaGFpbiBlbmRzIHdoZW4gdGhpcyBzdHlsZSBpc24ndCBtaXhpbmcgaW4gYW55IG90aGVyc1xuICAgICAgICBpZiAoIXN0eWxlLm1peCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmF2ZXJzZSBuZXh0IHBhcmVudCBzdHlsZVxuICAgICAgICBwYXJlbnRzKys7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUubWl4KSkge1xuICAgICAgICAgICAgLy8gSWYgbXVsdGlwbGUgbWl4aW5zLCBmaW5kIHRoZSBkZWVwZXN0IG9uZVxuICAgICAgICAgICAgcGFyZW50cyArPSBNYXRoLm1heCguLi5zdHlsZS5taXgubWFwKHMgPT4gU3R5bGVNYW5hZ2VyLmluaGVyaXRhbmNlRGVwdGgocywgc3R5bGVzKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBzaW5nbGUgbWl4aW4sIGNvbnRpbnVlIGxvb3AgdXAgdGhlIHRyZWVcbiAgICAgICAgICAgIGtleSA9IHN0eWxlLm1peDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyZW50cztcbn07XG5cbi8vIENvbXBpbGUgYWxsIHN0eWxlc1xuU3R5bGVNYW5hZ2VyLmNvbXBpbGUgPSBmdW5jdGlvbiAoa2V5cywgc2NlbmUpIHtcbiAgICBrZXlzID0ga2V5cyB8fCBPYmplY3Qua2V5cyhTdHlsZXMpO1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGxldCBzdHlsZSA9IFN0eWxlc1trZXldO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3R5bGUuY29tcGlsZSgpO1xuICAgICAgICAgICAgbG9nLnRyYWNlKGBTdHlsZU1hbmFnZXIuY29tcGlsZSgpOiBjb21waWxlZCBzdHlsZSAke2tleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgbG9nLmVycm9yKGBTdHlsZU1hbmFnZXIuY29tcGlsZSgpOiBlcnJvciBjb21waWxpbmcgc3R5bGUgJHtrZXl9OmAsIGVycm9yKTtcblxuICAgICAgICAgICAgc2NlbmUudHJpZ2dlcignd2FybmluZycsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3R5bGVzJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRXJyb3IgY29tcGlsaW5nIHN0eWxlICR7a2V5fWAsXG4gICAgICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICAgICAgc2hhZGVyX2Vycm9yczogc3R5bGUucHJvZ3JhbSAmJiBzdHlsZS5wcm9ncmFtLnNoYWRlcl9lcnJvcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9nLmRlYnVnKGBTdHlsZU1hbmFnZXIuY29tcGlsZSgpOiBjb21waWxlZCBhbGwgc3R5bGVzYCk7XG59O1xuXG4vLyBHZXQgYWxsIHN0eWxlcyB3aXRoIG1lc2ggZGF0YSBmb3IgYSBnaXZlbiB0aWxlXG5TdHlsZU1hbmFnZXIuc3R5bGVzRm9yVGlsZSA9IGZ1bmN0aW9uICh0aWxlKSB7XG4gICAgbGV0IHN0eWxlcyA9IFtdO1xuICAgIGZvciAobGV0IHMgaW4gU3R5bGVzKSB7XG4gICAgICAgIGlmIChTdHlsZXNbc10uaGFzRGF0YUZvclRpbGUodGlsZSkpIHtcbiAgICAgICAgICAgIHN0eWxlcy5wdXNoKHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXM7XG59O1xuIiwiaW1wb3J0IFV0aWxzIGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBHZW8gZnJvbSAnLi4vZ2VvJztcblxuaW1wb3J0IHBhcnNlQ1NTQ29sb3IgZnJvbSAnY3NzY29sb3JwYXJzZXInO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCB2YXIgU3R5bGVQYXJzZXIgPSB7fTtcblxuLy8gU3R5bGUgbWFjcm9zXG5cblN0eWxlUGFyc2VyLmV4cGFuZE1hY3JvcyA9IGZ1bmN0aW9uIGV4cGFuZE1hY3JvcyAob2JqKSB7XG4gICAgZm9yICh2YXIgcCBpbiBvYmopIHtcbiAgICAgICAgdmFyIHZhbCA9IG9ialtwXTtcblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBvYmpbcF0gPSBleHBhbmRNYWNyb3ModmFsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0IHN0cmluZ3MgYmFjayBpbnRvIGZ1bmN0aW9uc1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZm9yICh2YXIgbSBpbiBTdHlsZVBhcnNlci5tYWNyb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsLm1hdGNoKFN0eWxlUGFyc2VyLm1hY3Jvc1ttXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGY7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKmpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWwoJ2YgPSAnICsgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qanNoaW50IGlnbm9yZTplbmQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwXSA9IGY7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cudHJhY2UoYGV4cGFuZGVkIG1hY3JvICR7dmFsfSB0byAke2Z9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFsbC1iYWNrIHRvIG9yaWdpbmFsIHZhbHVlIGlmIHBhcnNpbmcgZmFpbGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cudHJhY2UoYGZhaWxlZCB0byBleHBhbmQgbWFjcm8gJHt2YWx9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuLy8gTGlzdCBvZiBtYWNyb3NcblN0eWxlUGFyc2VyLm1hY3JvcyA9IFtcbiAgICAnU3R5bGUuY29sb3IucHNldWRvUmFuZG9tQ29sb3InLFxuICAgICdTdHlsZS5jb2xvci5yYW5kb21Db2xvcidcbl07XG5cblxuXG52YXIgU3R5bGUgPSB7fTtcblxuU3R5bGUuY29sb3IgPSB7XG4gICAgLy8gcHNldWRvLXJhbmRvbSBncmF5c2NhbGUgYnkgZ2VvbWV0cnkgaWRcbiAgICBwc2V1ZG9SYW5kb21HcmF5c2NhbGUoKSB7XG4gICAgICAgIHZhciBmdW5jID0gYGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGMgPSBNYXRoLm1heCgocGFyc2VJbnQoZmVhdHVyZS5pZCwgMTYpICUgMTAwKSAvIDEwMCwgMC40KTtcbiAgICAgICAgICAgIHJldHVybiBbMC43ICogYywgMC43ICogYywgMC43ICogY107XG4gICAgICAgIH1gO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICB9LFxuXG4gICAgLy8gcHNldWRvLXJhbmRvbSBjb2xvciBieSBnZW9tZXRyeSBpZFxuICAgIHBzZXVkb1JhbmRvbUNvbG9yKCkge1xuICAgICAgICB2YXIgZnVuYyA9IGBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgMC43ICogKHBhcnNlSW50KGZlYXR1cmUuaWQsIDE2KSAvIDEwMCAlIDEpLFxuICAgICAgICAgICAgICAgIDAuNyAqIChwYXJzZUludChmZWF0dXJlLmlkLCAxNikgLyAxMDAwMCAlIDEpLFxuICAgICAgICAgICAgICAgIDAuNyAqIChwYXJzZUludChmZWF0dXJlLmlkLCAxNikgLyAxMDAwMDAwICUgMSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1gO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgICAgLy8gcmV0dXJuIGBmdW5jdGlvbigpIHsgcmV0dXJuIFswLjcgKiAocGFyc2VJbnQoZmVhdHVyZS5pZCwgMTYpIC8gMTAwICUgMSksIDAuNyAqIChwYXJzZUludChmZWF0dXJlLmlkLCAxNikgLyAxMDAwMCAlIDEpLCAwLjcgKiAocGFyc2VJbnQoZmVhdHVyZS5pZCwgMTYpIC8gMTAwMDAwMCAlIDEpXTsgfWA7XG4gICAgfSxcblxuICAgIC8vIHJhbmRvbSBjb2xvclxuICAgIHJhbmRvbUNvbG9yKCkge1xuICAgICAgICB2YXIgZnVuYyA9IGBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBbMC43ICogTWF0aC5yYW5kb20oKSwgMC43ICogTWF0aC5yYW5kb20oKSwgMC43ICogTWF0aC5yYW5kb20oKV07XG4gICAgICAgIH1gO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICB9XG59O1xuXG4vLyBXcmFwcyBzdHlsZSBmdW5jdGlvbnMgYW5kIHByb3ZpZGVzIGEgc2NvcGUgb2YgY29tbW9ubHkgYWNjZXNzaWJsZSBkYXRhOlxuLy8gLSBmZWF0dXJlOiB0aGUgJ3Byb3BlcnRpZXMnIG9mIHRoZSBmZWF0dXJlLCBlLmcuIGFjY2Vzc2VkIGFzICdmZWF0dXJlLm5hbWUnXG4vLyAtICR6b29tOiB0aGUgY3VycmVudCBtYXAgem9vbSBsZXZlbFxuLy8gLSAkZ2VvbWV0cnk6IHRoZSB0eXBlIG9mIGdlb21ldHJ5LCAncG9pbnQnLCAnbGluZScsIG9yICdwb2x5Z29uJ1xuLy8gLSAkbWV0ZXJzX3Blcl9waXhlbDogY29udmVyc2lvbiBmb3IgbWV0ZXJzL3BpeGVscyBhdCBjdXJyZW50IG1hcCB6b29tXG4vLyAtIHByb3BlcnRpZXM6IHVzZXItZGVmaW5lZCBwcm9wZXJ0aWVzIG9uIHRoZSBzdHlsZS1ydWxlIG9iamVjdCBpbiB0aGUgc3R5bGVzaGVldFxuU3R5bGVQYXJzZXIud3JhcEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICB2YXIgZiA9IGBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBjb250ZXh0LmZlYXR1cmUucHJvcGVydGllcztcbiAgICAgICAgICAgICAgICB2YXIgJHpvb20gPSBjb250ZXh0Lnpvb207XG4gICAgICAgICAgICAgICAgdmFyICRnZW9tZXRyeSA9IGNvbnRleHQuZ2VvbWV0cnk7XG4gICAgICAgICAgICAgICAgdmFyICRtZXRlcnNfcGVyX3BpeGVsID0gY29udGV4dC5tZXRlcnNfcGVyX3BpeGVsO1xuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gY29udGV4dC5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgICAgIHJldHVybiAoJHtmdW5jfSgpKTtcbiAgICAgICAgICAgIH1gO1xuICAgIHJldHVybiBmO1xufTtcblxuXG4vLyBTdHlsZSBwYXJzaW5nXG5cbi8vIFN0eWxlIGRlZmF1bHRzXG5TdHlsZVBhcnNlci5kZWZhdWx0cyA9IHtcbiAgICBjb2xvcjogWzEsIDEsIDEsIDFdLFxuICAgIHdpZHRoOiAxLFxuICAgIHNpemU6IDEsXG4gICAgZXh0cnVkZTogZmFsc2UsXG4gICAgaGVpZ2h0OiAyMCxcbiAgICBtaW5faGVpZ2h0OiAwLFxuICAgIG9yZGVyOiAwLFxuICAgIHo6IDAsXG4gICAgbWF0ZXJpYWw6IHtcbiAgICAgICAgYW1iaWVudDogMSxcbiAgICAgICAgZGlmZnVzZTogMVxuICAgIH1cbn07XG5cblxuLy8gQSBjb250ZXh0IG9iamVjdCB0aGF0IGlzIHBhc3NlZCB0byBzdHlsZSBwYXJzaW5nIGZ1bmN0aW9ucyB0byBwcm92aWRlIGEgc2NvcGUgb2YgY29tbW9ubHkgdXNlZCB2YWx1ZXNcblN0eWxlUGFyc2VyLmdldEZlYXR1cmVQYXJzZUNvbnRleHQgPSBmdW5jdGlvbiAoZmVhdHVyZSwgdGlsZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZlYXR1cmUsXG4gICAgICAgIHRpbGUsXG4gICAgICAgIHpvb206IHRpbGUuc3R5bGVfem9vbSxcbiAgICAgICAgZ2VvbWV0cnk6IEdlby5nZW9tZXRyeVR5cGUoZmVhdHVyZS5nZW9tZXRyeS50eXBlKSxcbiAgICAgICAgbWV0ZXJzX3Blcl9waXhlbDogR2VvLm1ldGVyc1BlclBpeGVsKHRpbGUuY29vcmRzLnopLFxuICAgICAgICB1bml0c19wZXJfbWV0ZXI6IEdlby51bml0c19wZXJfbWV0ZXJbdGlsZS5jb29yZHMuel1cbiAgICB9O1xufTtcblxuU3R5bGVQYXJzZXIuY29udmVydFVuaXRzID0gZnVuY3Rpb24odmFsLCBjb250ZXh0LCBjb252ZXJ0ID0gJ21ldGVycycpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHVuaXRzID0gdmFsLm1hdGNoKC8oWzAtOS4tXSspKFthLXpdKykvKTtcbiAgICAgICAgaWYgKHVuaXRzICYmIHVuaXRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdCh1bml0c1sxXSk7XG4gICAgICAgICAgICB1bml0cyA9IHVuaXRzWzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udmVydCB0byBtZXRlcnNcbiAgICAgICAgaWYgKGNvbnZlcnQgPT09ICdtZXRlcnMnKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGZyb20gcGl4ZWxzXG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICdweCcpIHtcbiAgICAgICAgICAgICAgICB2YWwgKj0gR2VvLm1ldGVyc1BlclBpeGVsKGNvbnRleHQuem9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGZyb20ga2lsb21ldGVyc1xuICAgICAgICAgICAgZWxzZSBpZiAodW5pdHMgPT09ICdrbScpIHtcbiAgICAgICAgICAgICAgICB2YWwgKj0gMTAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgLy8gQXJyYXkgb2YgYXJyYXlzLCBlLmcuIHpvb20taW50ZXJwb2xhdGVkIHN0b3BzXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbFswXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwubWFwKHYgPT4geyByZXR1cm4gW3ZbMF0sIFN0eWxlUGFyc2VyLmNvbnZlcnRVbml0cyh2WzFdLCBjb250ZXh0LCBjb252ZXJ0KV07IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5IG9mIHZhbHVlc1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwubWFwKHYgPT4geyByZXR1cm4gU3R5bGVQYXJzZXIuY29udmVydFVuaXRzKHYsIGNvbnRleHQsIGNvbnZlcnQpOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufTtcblxuLy8gVGFrZXMgYSBkaXN0YW5jZSBjYWNoZSBvYmplY3QgYW5kIHJldHVybnMgYSBkaXN0YW5jZSB2YWx1ZSBmb3IgdGhpcyB6b29tXG4vLyAoY2FjaGluZyB0aGUgcmVzdWx0IGZvciBmdXR1cmUgdXNlKVxuLy8geyB2YWx1ZTogb3JpZ2luYWwsIHpvb206IHsgejogbWV0ZXJzIH0sIGR5bmFtaWM6IGZ1bmN0aW9uKCl7Li4ufSB9XG5TdHlsZVBhcnNlci5jYWNoZURpc3RhbmNlID0gZnVuY3Rpb24odmFsLCBjb250ZXh0LCBjb252ZXJ0ID0gJ21ldGVycycpIHtcbiAgICBpZiAodmFsLmR5bmFtaWMpIHtcbiAgICAgICAgbGV0IHYgPSB2YWwuZHluYW1pYyhjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbC56b29tICYmIHZhbC56b29tW2NvbnZlcnRdICYmIHZhbC56b29tW2NvbnZlcnRdW2NvbnRleHQuem9vbV0pIHtcbiAgICAgICAgcmV0dXJuIHZhbC56b29tW2NvbnZlcnRdW2NvbnRleHQuem9vbV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBEeW5hbWljIGZ1bmN0aW9uLWJhc2VkXG4gICAgICAgIGlmICh0eXBlb2YgdmFsLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWwuZHluYW1pYyA9IHZhbC52YWx1ZTtcbiAgICAgICAgICAgIGxldCB2ID0gdmFsLmR5bmFtaWMoY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheSBvZiB6b29tLWludGVycG9sYXRlZCBzdG9wcywgZS5nLiBbem9vbSwgdmFsdWVdIHBhaXJzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHZhbHVlIGZvciBjdXJyZW50IHpvb21cbiAgICAgICAgICAgIHZhbC56b29tID0gdmFsLnpvb20gfHwge307XG4gICAgICAgICAgICBsZXQgenVuaXRzID0gdmFsLnpvb21bY29udmVydF0gPSB2YWwuem9vbVtjb252ZXJ0XSB8fCB7fTtcblxuICAgICAgICAgICAgenVuaXRzW2NvbnRleHQuem9vbV0gPSBTdHlsZVBhcnNlci5jb252ZXJ0VW5pdHModmFsLnZhbHVlLCBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGNvbnZlcnQgPT09ICdtZXRlcnMnICYmICdtZXRlcnMnKTsgLy8gY29udmVydCB0byBtZXRlcnNcbiAgICAgICAgICAgIHp1bml0c1tjb250ZXh0Lnpvb21dID0gVXRpbHMuaW50ZXJwb2xhdGUoY29udGV4dC56b29tLCB6dW5pdHNbY29udGV4dC56b29tXSk7XG5cbiAgICAgICAgICAgIHJldHVybiB6dW5pdHNbY29udGV4dC56b29tXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIENhY2hlIHByZXZpb3VzbHkgcGFyc2VkIGNvbG9yIHN0cmluZ3NcblN0eWxlUGFyc2VyLnN0cmluZ19jb2xvcnMgPSB7fTtcblN0eWxlUGFyc2VyLmNvbG9yRm9yU3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgLy8gQ2FjaGVkXG4gICAgaWYgKFN0eWxlUGFyc2VyLnN0cmluZ19jb2xvcnNbc3RyaW5nXSkge1xuICAgICAgICByZXR1cm4gU3R5bGVQYXJzZXIuc3RyaW5nX2NvbG9yc1tzdHJpbmddO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBhbmQgY2FjaGVcbiAgICBsZXQgY29sb3IgPSBwYXJzZUNTU0NvbG9yLnBhcnNlQ1NTQ29sb3Ioc3RyaW5nKTtcbiAgICBpZiAoY29sb3IgJiYgY29sb3IubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIGNvbG9yWzBdIC89IDI1NTtcbiAgICAgICAgY29sb3JbMV0gLz0gMjU1O1xuICAgICAgICBjb2xvclsyXSAvPSAyNTU7XG4gICAgICAgIGNvbG9yWzNdID0gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbG9yID0gU3R5bGVQYXJzZXIuZGVmYXVsdHMuY29sb3I7XG4gICAgfVxuICAgIFN0eWxlUGFyc2VyLnN0cmluZ19jb2xvcnNbc3RyaW5nXSA9IGNvbG9yO1xuICAgIHJldHVybiBjb2xvcjtcbn07XG5cbi8vIFRha2VzIGEgY29sb3IgY2FjaGUgb2JqZWN0IGFuZCByZXR1cm5zIGEgY29sb3IgdmFsdWUgZm9yIHRoaXMgem9vbVxuLy8gKGNhY2hpbmcgdGhlIHJlc3VsdCBmb3IgZnV0dXJlIHVzZSlcbi8vIHsgdmFsdWU6IG9yaWdpbmFsLCBzdGF0aWM6IFtyLGcsYixhXSwgem9vbTogeyB6OiBbcixnLGIsYV0gfSwgZHluYW1pYzogZnVuY3Rpb24oKXsuLi59IH1cblN0eWxlUGFyc2VyLmNhY2hlQ29sb3IgPSBmdW5jdGlvbih2YWwsIGNvbnRleHQgPSB7fSkge1xuICAgIGlmICh2YWwuZHluYW1pYykge1xuICAgICAgICBsZXQgdiA9IHZhbC5keW5hbWljKGNvbnRleHQpO1xuICAgICAgICB2WzNdID0gdlszXSB8fCAxOyAvLyBkZWZhdWx0IGFscGhhXG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWwuc3RhdGljKSB7XG4gICAgICAgIHJldHVybiB2YWwuc3RhdGljO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWwuem9vbSAmJiB2YWwuem9vbVtjb250ZXh0Lnpvb21dKSB7XG4gICAgICAgIHJldHVybiB2YWwuem9vbVtjb250ZXh0Lnpvb21dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gRHluYW1pYyBmdW5jdGlvbi1iYXNlZCBjb2xvclxuICAgICAgICBpZiAodHlwZW9mIHZhbC52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsLmR5bmFtaWMgPSB2YWwudmFsdWU7XG4gICAgICAgICAgICBsZXQgdiA9IHZhbC5keW5hbWljKGNvbnRleHQpO1xuICAgICAgICAgICAgdlszXSA9IHZbM10gfHwgMTsgLy8gZGVmYXVsdCBhbHBoYVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luZ2xlIHN0cmluZyBjb2xvclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsLnZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsLnN0YXRpYyA9IFN0eWxlUGFyc2VyLmNvbG9yRm9yU3RyaW5nKHZhbC52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsLnN0YXRpYztcbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheSBvZiB6b29tLWludGVycG9sYXRlZCBzdG9wcywgZS5nLiBbem9vbSwgY29sb3JdIHBhaXJzXG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsLnZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHZhbC52YWx1ZVswXSkpIHtcbiAgICAgICAgICAgIGlmICghdmFsLnpvb20pIHtcbiAgICAgICAgICAgICAgICB2YWwuem9vbSA9IHt9O1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFueSBzdHJpbmcgY29sb3JzIGluc2lkZSBzdG9wc1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaSA8IHZhbC52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdiA9IHZhbC52YWx1ZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2WzFdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdlsxXSA9IFN0eWxlUGFyc2VyLmNvbG9yRm9yU3RyaW5nKHZbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgY29sb3IgZm9yIGN1cnJlbnQgem9vbVxuICAgICAgICAgICAgdmFsLnpvb21bY29udGV4dC56b29tXSA9IFV0aWxzLmludGVycG9sYXRlKGNvbnRleHQuem9vbSwgdmFsLnZhbHVlKTtcbiAgICAgICAgICAgIHZhbC56b29tW2NvbnRleHQuem9vbV1bM10gPSB2YWwuem9vbVtjb250ZXh0Lnpvb21dWzNdIHx8IDE7IC8vIGRlZmF1bHQgYWxwaGFcbiAgICAgICAgICAgIHJldHVybiB2YWwuem9vbVtjb250ZXh0Lnpvb21dO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmdsZSBhcnJheSBjb2xvclxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbC5zdGF0aWMgPSB2YWwudmFsdWU7XG4gICAgICAgICAgICB2YWwuc3RhdGljWzNdID0gdmFsLnN0YXRpY1szXSB8fCAxOyAvLyBkZWZhdWx0IGFscGhhXG4gICAgICAgICAgICByZXR1cm4gdmFsLnN0YXRpYztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblN0eWxlUGFyc2VyLnBhcnNlQ29sb3IgPSBmdW5jdGlvbih2YWwsIGNvbnRleHQgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbCA9IHZhbChjb250ZXh0KTtcbiAgICB9XG5cbiAgICAvLyBQYXJzZSBDU1Mtc3R5bGUgY29sb3JzXG4gICAgLy8gVE9ETzogY2hhbmdlIGFsbCBjb2xvcnMgdG8gdXNlIDAtMjU1IHJhbmdlIGludGVybmFsbHkgdG8gYXZvaWQgZGl2aWRpbmcgYW5kIHRoZW4gcmUtbXVsdGlwbHlpbmcgaW4gZ2VvbSBidWlsZGVyXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbCA9IHBhcnNlQ1NTQ29sb3IucGFyc2VDU1NDb2xvcih2YWwpO1xuICAgICAgICBpZiAodmFsICYmIHZhbC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIHZhbFswXSAvPSAyNTU7XG4gICAgICAgICAgICB2YWxbMV0gLz0gMjU1O1xuICAgICAgICAgICAgdmFsWzJdIC89IDI1NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpICYmIEFycmF5LmlzQXJyYXkodmFsWzBdKSkge1xuICAgICAgICAvLyBBcnJheSBvZiB6b29tLWludGVycG9sYXRlZCBzdG9wcywgZS5nLiBbem9vbSwgY29sb3JdIHBhaXJzXG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHYgPSB2YWxbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZbMV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZjID0gcGFyc2VDU1NDb2xvci5wYXJzZUNTU0NvbG9yKHZbMV0pO1xuICAgICAgICAgICAgICAgIGlmICh2YyAmJiB2Yy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmNbMF0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICB2Y1sxXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgIHZjWzJdIC89IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgdlsxXSA9IHZjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb250ZXh0Lnpvb20pIHtcbiAgICAgICAgdmFsID0gVXRpbHMuaW50ZXJwb2xhdGUoY29udGV4dC56b29tLCB2YWwpO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHRzXG4gICAgaWYgKHZhbCkge1xuICAgICAgICAvLyBhbHBoYVxuICAgICAgICBpZiAoIXZhbFszXSkge1xuICAgICAgICAgICAgdmFsWzNdID0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsID0gWzAsIDAsIDAsIDFdO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG59O1xuXG4vLyBPcmRlciBpcyBzdW1tZWQgZnJvbSB0b3AgdG8gYm90dG9tIGluIHRoZSBzdHlsZSBoaWVyYXJjaHk6XG4vLyBlYWNoIGNoaWxkIG9yZGVyIHZhbHVlIGlzIGFkZGVkIHRvIHRoZSBwYXJlbnQgb3JkZXIgdmFsdWVcblN0eWxlUGFyc2VyLmNhbGN1bGF0ZU9yZGVyID0gZnVuY3Rpb24ob3JkZXIsIGNvbnRleHQpIHtcbiAgICBpZiAodHlwZW9mIG9yZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9yZGVyID0gb3JkZXIoY29udGV4dCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3JkZXIpKSB7XG4gICAgICAgIG9yZGVyID0gb3JkZXIucmVkdWNlKChzdW0sIG9yZGVyKSA9PiB7XG4gICAgICAgICAgICBvcmRlciA9IG9yZGVyIHx8IFN0eWxlUGFyc2VyLmRlZmF1bHRzLm9yZGVyO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG9yZGVyID0gb3JkZXIoY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3JkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgb3JkZXIgPSBjb250ZXh0LmZlYXR1cmUucHJvcGVydGllc1tvcmRlcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcmRlciA9IHBhcnNlRmxvYXQob3JkZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9yZGVyIHx8IGlzTmFOKG9yZGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3VtICsgb3JkZXI7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb3JkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChjb250ZXh0LmZlYXR1cmUucHJvcGVydGllc1tvcmRlcl0pIHtcbiAgICAgICAgICAgIG9yZGVyID0gY29udGV4dC5mZWF0dXJlLnByb3BlcnRpZXNbb3JkZXJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3JkZXIgPSBwYXJzZUZsb2F0KG9yZGVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcmRlcjtcbn07XG4iLCIvKmdsb2JhbCBMYWJlbCAqL1xuXG5pbXBvcnQgYm94SW50ZXJzZWN0IGZyb20gJ2JveC1pbnRlcnNlY3QnO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBHZW8gZnJvbSAnLi4vLi4vZ2VvJztcbmltcG9ydCBPQkIgZnJvbSAnLi4vLi4vdXRpbHMvb2JiJztcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vLi4vdmVjdG9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGFiZWwge1xuICAgIGNvbnN0cnVjdG9yICh0ZXh0LCBzaXplLCB7IG1vdmVfaW5fdGlsZSwga2VlcF9pbl90aWxlIH0pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7XG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBbXSxcbiAgICAgICAgICAgIGFhYmI6IFtdLFxuICAgICAgICAgICAgbW92ZV9pbl90aWxlLFxuICAgICAgICAgICAga2VlcF9pbl90aWxlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuaWQgPSBMYWJlbC5pZCsrO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyIHx8IDI7IC8vIFRPRE86IG1ha2UgY29uZmlndXJhYmxlXG4gICAgICAgIHRoaXMuYnVmZmVyICo9IEdlby51bml0c19wZXJfcGl4ZWw7XG4gICAgICAgIHRoaXMua2VlcF9taW5fZGlzdGFuY2UgPSB0cnVlO1xuICAgIH1cblxuICAgIGlzQ29tcG9zaXRlICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG9jY2x1ZGVkIChhYWJicykge1xuICAgICAgICBsZXQgaW50ZXJzZWN0ID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQnJvYWRwaGFzZVxuICAgICAgICBpZiAoYWFiYnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYm94SW50ZXJzZWN0KFt0aGlzLmFhYmJdLCBhYWJicywgKGksIGopID0+IHtcbiAgICAgICAgICAgICAgICAvLyBOYXJyb3cgcGhhc2VcbiAgICAgICAgICAgICAgICBpZiAoT0JCLmludGVyc2VjdCh0aGlzLmFhYmIub2JiLCBhYWJic1tqXS5vYmIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm8gY29sbGlzaW9uIG9uIGFhYmJcbiAgICAgICAgaWYgKCFpbnRlcnNlY3QpIHtcbiAgICAgICAgICAgIGFhYmJzLnB1c2godGhpcy5hYWJiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnRlcnNlY3Q7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIG1pbmltYWwgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbGFiZWxzXG4gICAgY2hlY2tNaW5EaXN0YW5jZSAoYWFiYnMpIHtcbiAgICAgICAgbGV0IG9iYjEgPSB0aGlzLmFhYmIub2JiO1xuICAgICAgICBsZXQgdzEgPSBNYXRoLmFicyhvYmIxLnF1YWRbMV1bMF0gLSBvYmIxLnF1YWRbMF1bMF0pO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWFiYnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBhYWJiID0gYWFiYnNbaV07XG4gICAgICAgICAgICBsZXQgb2JiMCA9IGFhYmIub2JiO1xuXG4gICAgICAgICAgICBsZXQgZEhhbGYgPSBWZWN0b3IubGVuZ3RoKFZlY3Rvci5tdWx0KFZlY3Rvci5zdWIob2JiMC5jZW50cm9pZCwgb2JiMS5jZW50cm9pZCksIDAuNSkpO1xuICAgICAgICAgICAgbGV0IHcwID0gTWF0aC5hYnMob2JiMC5xdWFkWzFdWzBdIC0gb2JiMC5xdWFkWzBdWzBdKTtcblxuICAgICAgICAgICAgLy8gc2tpcCBvYmJzIHdpdGggaGFsZiBkaXN0YW5jZSBsZXNzIHRoYW4gYW4gb2JiIHdpZHRoXG4gICAgICAgICAgICBpZiAoZEhhbGYgPiB3MCArIHRoaXMuYnVmZmVyICYmIGRIYWxmID4gdzEgKyB0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG9iYjAucXVhZC5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGxldCB2MCA9IG9iYjAucXVhZFtqXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG9iYjEucXVhZC5sZW5ndGg7ICsraykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdjEgPSBvYmIxLnF1YWRba107XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gVmVjdG9yLmxlbmd0aChWZWN0b3Iuc3ViKHYwLCB2MSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkIDwgdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGNoZWNrcyB3aGV0aGVyIHRoZSBsYWJlbCBpcyB3aXRoaW4gdGhlIHRpbGUgYm91bmRhcmllc1xuICAgIGluVGlsZUJvdW5kcyAoKSB7XG4gICAgICAgIGxldCBtaW4gPSBbIHRoaXMuYWFiYlswXSwgdGhpcy5hYWJiWzFdIF07XG4gICAgICAgIGxldCBtYXggPSBbIHRoaXMuYWFiYlsyXSwgdGhpcy5hYWJiWzNdIF07XG5cbiAgICAgICAgaWYgKCFVdGlscy5wb2ludEluVGlsZShtaW4pIHx8ICFVdGlscy5wb2ludEluVGlsZShtYXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyB3aGV0aGVyIHRoZSBsYWJlbCBzaG91bGQgYmUgZGlzY2FyZGVkXG4gICAgLy8gMS4gdHJ5IHRvIGtlZXAgdGhlIGxhYmVsIGluIHRpbGUgaWYgdGhlIGxhYmVsICh0byBhdm9pZCBjb2xsaXNpb24gb3ZlciB0aWxlIGZvciBub3cpXG4gICAgLy8gMi4gaWYgMS4gLT4ga2VlcCBhIG1pbmltYWwgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbGFiZWxcbiAgICAvLyAzLiBpZiAyLiAtPiBwZXJmb20gb2NjbHVzaW9uXG4gICAgZGlzY2FyZCAoYWFiYnMpIHtcbiAgICAgICAgbGV0IGRpc2NhcmQgPSBmYWxzZTtcblxuICAgICAgICAvLyBwZXJmb3JtIHNwZWNpZmljIHN0eWxpbmcgcnVsZSwgc2hvdWxkIHdlIGtlZXAgdGhlIGxhYmVsIGluIHRpbGUgYm91bmRzP1xuICAgICAgICBpZiAodGhpcy5rZWVwX2luX3RpbGUpIHtcbiAgICAgICAgICAgIGxldCBpbl90aWxlID0gdGhpcy5pblRpbGVCb3VuZHMoKTtcblxuICAgICAgICAgICAgaWYgKCFpbl90aWxlICYmIHRoaXMubW92ZV9pbl90aWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FuIHdlIG1vdmU/XG4gICAgICAgICAgICAgICAgZGlzY2FyZCA9IHRoaXMubW92ZUluVGlsZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghaW5fdGlsZSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGRpZG4ndCB3YW50IHRvIG1vdmUgYXQgYWxsLFxuICAgICAgICAgICAgICAgIC8vIGp1c3QgZGlzY2FyZCBzaW5jZSB3ZSdyZSBvdXQgb2YgdGlsZSBib3VuZHNcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmtlZXBfbWluX2Rpc3RhbmNlKSB7XG4gICAgICAgICAgICBkaXNjYXJkIHw9IHRoaXMuY2hlY2tNaW5EaXN0YW5jZShhYWJicyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaG91bGQgd2UgZGlzY2FyZD8gaWYgbm90LCBqdXN0IG1ha2Ugb2NjbHVzaW9uIHRlc3RcbiAgICAgICAgcmV0dXJuIGRpc2NhcmQgfHwgdGhpcy5vY2NsdWRlZChhYWJicyk7XG4gICAgfVxufVxuXG5MYWJlbC5pZCA9IDA7XG5cbiIsImltcG9ydCBMYWJlbFBvaW50IGZyb20gJy4vbGFiZWxfcG9pbnQnO1xuaW1wb3J0IExhYmVsTGluZSBmcm9tICcuL2xhYmVsX2xpbmUnO1xuaW1wb3J0IEdlbyBmcm9tICcuLi8uLi9nZW8nO1xuXG52YXIgTGFiZWxCdWlsZGVyO1xuZXhwb3J0IGRlZmF1bHQgTGFiZWxCdWlsZGVyID0ge307XG5cbkxhYmVsQnVpbGRlci5sYWJlbHNGcm9tR2VvbWV0cnkgPSBmdW5jdGlvbiAoZ2VvbWV0cnksIHsgdGV4dCwgc2l6ZSB9LCBsYWJlbF9zdHlsZSkge1xuICAgIGxldCBsYWJlbHMgPSBbXTtcblxuICAgIGlmIChnZW9tZXRyeS50eXBlID09PSBcIkxpbmVTdHJpbmdcIikge1xuICAgICAgICBsZXQgbGluZXMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcblxuICAgICAgICBsYWJlbHMucHVzaChuZXcgTGFiZWxMaW5lKHRleHQsIHNpemUsIGxpbmVzLCBsYWJlbF9zdHlsZS5saW5lcywgeyBtb3ZlX2luX3RpbGU6IHRydWUsIGtlZXBfaW5fdGlsZTogdHJ1ZSB9KSk7XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSBcIk11bHRpTGluZVN0cmluZ1wiKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gbGluZXNbaV07XG5cbiAgICAgICAgICAgIGxhYmVscy5wdXNoKG5ldyBMYWJlbExpbmUodGV4dCwgc2l6ZSwgbGluZSwgbGFiZWxfc3R5bGUubGluZXMsIHsgbW92ZV9pbl90aWxlOiB0cnVlLCBrZWVwX2luX3RpbGU6IHRydWUgfSkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSBcIlBvaW50XCIpIHtcbiAgICAgICAgbGV0IHdpZHRoID0gbGFiZWxfc3R5bGUucG9pbnRzLm1heF93aWR0aDtcblxuICAgICAgICAvLyBpZiAod2lkdGggJiYgc2l6ZS50ZXh0X3NpemVbMF0gPiB3aWR0aCkge1xuICAgICAgICAvLyAgICAgbGV0IGxpbmVfaGVpZ2h0ID0gKHNpemUucHhfbG9naWNhbF9zaXplIC8gMTAwKSAqIGxhYmVsX3N0eWxlLnBvaW50cy5saW5lX2hlaWdodDtcbiAgICAgICAgLy8gICAgIGxpbmVfaGVpZ2h0ID0gVXRpbHMucGl4ZWxUb01lcmNhdG9yKGxpbmVfaGVpZ2h0KTtcbiAgICAgICAgLy8gICAgIGxldCBsYWJlbCA9IExhYmVsUG9pbnQuZXhwbG9kZSh0ZXh0LCBnZW9tZXRyeS5jb29yZGluYXRlcywgc2l6ZSwgd2lkdGgsIGxpbmVfaGVpZ2h0LCB7IG1vdmVfaW5fdGlsZTogdHJ1ZSwga2VlcF9pbl90aWxlOiB0cnVlIH0pO1xuXG4gICAgICAgIC8vICAgICBsYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIGlmICghKHdpZHRoICYmIHNpemUudGV4dF9zaXplWzBdID4gd2lkdGgpKSB7XG4gICAgICAgICAgICBsYWJlbHMucHVzaChuZXcgTGFiZWxQb2ludCh0ZXh0LCBnZW9tZXRyeS5jb29yZGluYXRlcywgc2l6ZSwgbnVsbCwgeyBtb3ZlX2luX3RpbGU6IHRydWUsIGtlZXBfaW5fdGlsZTogdHJ1ZSB9KSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09IFwiTXVsdGlQb2ludFwiKSB7XG4gICAgICAgIGxldCBwb2ludHMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgbGFiZWxzLnB1c2gobmV3IExhYmVsUG9pbnQodGV4dCwgcG9pbnQsIHNpemUsIG51bGwsIHsgbW92ZV9pbl90aWxlOiB0cnVlLCBrZWVwX2luX3RpbGU6IHRydWUgfSkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSBcIlBvbHlnb25cIikge1xuICAgICAgICBsZXQgY2VudHJvaWQgPSBHZW8uY2VudHJvaWQoZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0pO1xuICAgICAgICBsZXQgYXJlYSA9IEdlby5wb2x5Z29uQXJlYShnZW9tZXRyeS5jb29yZGluYXRlc1swXSk7XG5cbiAgICAgICAgbGFiZWxzLnB1c2gobmV3IExhYmVsUG9pbnQodGV4dCwgY2VudHJvaWQsIHNpemUsIGFyZWEsIHsgbW92ZV9pbl90aWxlOiB0cnVlLCBrZWVwX2luX3RpbGU6IHRydWUgfSkpO1xuICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gXCJNdWx0aVBvbHlnb25cIikge1xuICAgICAgICBsZXQgY2VudHJvaWQgPSBHZW8ubXVsdGlDZW50cm9pZChnZW9tZXRyeS5jb29yZGluYXRlcyk7XG4gICAgICAgIGxldCBhcmVhID0gR2VvLm11bHRpUG9seWdvbkFyZWEoZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xuXG4gICAgICAgIGxhYmVscy5wdXNoKG5ldyBMYWJlbFBvaW50KHRleHQsIGNlbnRyb2lkLCBzaXplLCBhcmVhLCB7IG1vdmVfaW5fdGlsZTogdHJ1ZSwga2VlcF9pbl90aWxlOiB0cnVlIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGFiZWxzO1xufTtcblxuXG4iLCJpbXBvcnQgVmVjdG9yIGZyb20gJy4uLy4uL3ZlY3Rvcic7XG5pbXBvcnQgR2VvIGZyb20gJy4uLy4uL2dlbyc7XG5pbXBvcnQgTGFiZWwgZnJvbSAnLi9sYWJlbCc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IE9CQiBmcm9tICcuLi8uLi91dGlscy9vYmInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYWJlbExpbmUgZXh0ZW5kcyBMYWJlbCB7XG4gICAgY29uc3RydWN0b3IgKHRleHQsIHNpemUsIGxpbmVzLCBzdHlsZSwgeyBtb3ZlX2luX3RpbGUsIGtlZXBfaW5fdGlsZSB9KSB7XG4gICAgICAgIHN1cGVyKHRleHQsIHNpemUsIHsgbW92ZV9pbl90aWxlLCBrZWVwX2luX3RpbGUgfSk7XG5cbiAgICAgICAgdGhpcy5zZWdtZW50X2luZGV4ID0gMDtcbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgICAgICB0aGlzLmV4Y2VlZF9oZXVyaXN0aWMgPSBzdHlsZS5leGNlZWQ7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gc3R5bGUub2Zmc2V0O1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIG1pZGRsZVNlZ21lbnQgKHNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIChzZWdtZW50WzBdWzBdICsgc2VnbWVudFsxXVswXSkgLyAyLFxuICAgICAgICAgICAgKHNlZ21lbnRbMF1bMV0gKyBzZWdtZW50WzFdWzFdKSAvIDIsXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgdXBkYXRlICgpIHtcbiAgICAgICAgbGV0IHNlZ21lbnQgPSB0aGlzLmN1cnJlbnRTZWdtZW50KCk7XG5cbiAgICAgICAgdGhpcy5hbmdsZSA9IHRoaXMuY29tcHV0ZUFuZ2xlKCk7XG5cbiAgICAgICAgbGV0IHBlcnAgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5wZXJwKHNlZ21lbnRbMF0sIHNlZ21lbnRbMV0pKTtcbiAgICAgICAgbGV0IGRvdCA9IFZlY3Rvci5kb3QocGVycCwgWzAsIDFdKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IFZlY3Rvci5tdWx0KHBlcnAsIFV0aWxzLnBpeGVsVG9NZXJjYXRvcih0aGlzLm9mZnNldCAqIE1hdGguc2lnbihkb3QpKSk7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFZlY3Rvci5hZGQodGhpcy5taWRkbGVTZWdtZW50KHNlZ21lbnQpLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLmFhYmIgPSB0aGlzLmNvbXB1dGVBQUJCKCk7XG4gICAgfVxuXG4gICAgbW92ZU5leHRTZWdtZW50ICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VnbWVudF9pbmRleCArIDEgPj0gdGhpcy5saW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlZ21lbnRfaW5kZXgrKztcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb21wdXRlQW5nbGUgKCkge1xuICAgICAgICBsZXQgc2VnbWVudCA9IHRoaXMuY3VycmVudFNlZ21lbnQoKTtcbiAgICAgICAgbGV0IHAwcDEgPSBWZWN0b3Iuc3ViKHNlZ21lbnRbMF0sIHNlZ21lbnRbMV0pO1xuXG4gICAgICAgIHAwcDEgPSBWZWN0b3Iubm9ybWFsaXplKHAwcDEpO1xuXG4gICAgICAgIGxldCBQSV8yID0gTWF0aC5QSSAvIDI7XG4gICAgICAgIGxldCB0aGV0YSA9IE1hdGguYXRhbjIocDBwMVswXSwgcDBwMVsxXSkgKyBQSV8yO1xuXG4gICAgICAgIGlmICh0aGV0YSA+IFBJXzIgfHwgdGhldGEgPCAtUElfMikge1xuICAgICAgICAgICAgdGhldGEgKz0gTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgICB0aGV0YSAlPSBNYXRoLlBJICogMjtcblxuICAgICAgICByZXR1cm4gdGhldGE7XG4gICAgfVxuXG4gICAgZml0VG9TZWdtZW50IChzaG91bGRfZml0ID0gdHJ1ZSkge1xuICAgICAgICBpZiAoIXNob3VsZF9maXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNlZ21lbnQgPSB0aGlzLmN1cnJlbnRTZWdtZW50KCk7XG4gICAgICAgIGxldCBwMHAxID0gVmVjdG9yLnN1YihzZWdtZW50WzBdLCBzZWdtZW50WzFdKTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IFZlY3Rvci5sZW5ndGgocDBwMSk7XG5cbiAgICAgICAgbGV0IGxhYmVsX2xlbmd0aCA9IFV0aWxzLnBpeGVsVG9NZXJjYXRvcih0aGlzLnNpemUudGV4dF9zaXplWzBdKTtcblxuICAgICAgICBpZiAobGFiZWxfbGVuZ3RoID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBhbiBleGNlZWQgaGV1cmVzdGljIG9mIDEwMCUgd291bGQgbGV0IHRoZSBsYWJlbCBmaXQgaW4gYW55IGNhc2VzXG4gICAgICAgICAgICBsZXQgZXhjZWVkID0gKDEgLSAobGVuZ3RoIC8gbGFiZWxfbGVuZ3RoKSkgKiAxMDA7XG4gICAgICAgICAgICByZXR1cm4gZXhjZWVkIDwgdGhpcy5leGNlZWRfaGV1cmlzdGljO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsX2xlbmd0aCA8IGxlbmd0aDtcbiAgICB9XG5cbiAgICBjdXJyZW50U2VnbWVudCAoKSB7XG4gICAgICAgIGxldCBwMSA9IHRoaXMubGluZXNbdGhpcy5zZWdtZW50X2luZGV4XTtcbiAgICAgICAgbGV0IHAyID0gdGhpcy5saW5lc1t0aGlzLnNlZ21lbnRfaW5kZXggKyAxXTtcblxuICAgICAgICByZXR1cm4gWyBwMSwgcDIgXTtcbiAgICB9XG5cbiAgICBjb21wdXRlQUFCQiAoc2l6ZSkge1xuICAgICAgICBsZXQgdXBwID0gR2VvLnVuaXRzX3Blcl9waXhlbDtcblxuICAgICAgICBsZXQgbWVyY193aWR0aCA9IHRoaXMuc2l6ZS50ZXh0X3NpemVbMF0gKiB1cHA7XG4gICAgICAgIGxldCBtZXJjX2hlaWdodCA9IHRoaXMuc2l6ZS50ZXh0X3NpemVbMV0gKiB1cHA7XG5cbiAgICAgICAgLy8gdGhlIGFuZ2xlIG9mIHRoZSBvYmIgaXMgbmVnYXRpdmUgc2luY2UgaXQncyB0aGUgdGlsZSBzeXN0ZW0geSBheGlzIGlzIHBvaW50aW5nIGRvd25cbiAgICAgICAgbGV0IG9iYiA9IG5ldyBPQkIodGhpcy5wb3NpdGlvblswXSwgdGhpcy5wb3NpdGlvblsxXSwgLXRoaXMuYW5nbGUsIG1lcmNfd2lkdGgsIG1lcmNfaGVpZ2h0KTtcbiAgICAgICAgbGV0IGFhYmIgPSBvYmIuZ2V0RXh0ZW50KCk7XG4gICAgICAgIGFhYmIub2JiID0gb2JiO1xuXG4gICAgICAgIHJldHVybiBhYWJiO1xuICAgIH1cblxuICAgIG1vdmVJblRpbGUgKCkge1xuICAgICAgICBsZXQgaW5fdGlsZSA9IGZhbHNlO1xuICAgICAgICBsZXQgZml0c190b19zZWdtZW50ID0gdGhpcy5maXRUb1NlZ21lbnQoKTtcblxuICAgICAgICAvLyBtb3ZlIHRoaXMgbGFiZWwgdW50aWwgd2UgZm91bmQgYSBsaW5lIHdlIGNhbiBmaXQgaW5cbiAgICAgICAgd2hpbGUgKCFpbl90aWxlICYmICFmaXRzX3RvX3NlZ21lbnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5tb3ZlTmV4dFNlZ21lbnQoKSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGNhbid0IG1vdmUgZnVydGhlciBpbiB0aGlzIGxpbmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5fdGlsZSA9IHRoaXMuaW5UaWxlQm91bmRzKCk7XG4gICAgICAgICAgICBmaXRzX3RvX3NlZ21lbnQgPSB0aGlzLmZpdFRvU2VnbWVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICFpbl90aWxlIHx8wqAhZml0c190b19zZWdtZW50O1xuICAgIH1cblxuICAgIGRpc2NhcmQgKGFhYmJzKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVzICYmICF0aGlzLmZpdFRvU2VnbWVudCgpKSB7XG4gICAgICAgICAgICB3aGlsZSAoIXRoaXMuZml0VG9TZWdtZW50KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubW92ZU5leHRTZWdtZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLmRpc2NhcmQoYWFiYnMpO1xuICAgIH1cbn1cblxuIiwiaW1wb3J0IExhYmVsIGZyb20gJy4vbGFiZWwnO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBHZW8gZnJvbSAnLi4vLi4vZ2VvJztcbmltcG9ydCBPQkIgZnJvbSAnLi4vLi4vdXRpbHMvb2JiJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGFiZWxQb2ludCBleHRlbmRzIExhYmVsIHtcbiAgICBjb25zdHJ1Y3RvciAodGV4dCwgcG9zaXRpb24sIHNpemUsIGFyZWEsIHsgbW92ZV9pbl90aWxlLCBrZWVwX2luX3RpbGUgfSkge1xuICAgICAgICBzdXBlcih0ZXh0LCBzaXplLCB7IG1vdmVfaW5fdGlsZSwga2VlcF9pbl90aWxlIH0pO1xuXG4gICAgICAgIHRoaXMuYXJlYSA9IGFyZWE7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hYWJiID0gdGhpcy5jb21wdXRlQUFCQigpO1xuICAgIH1cblxuICAgIGNvbXB1dGVBQUJCICgpIHtcbiAgICAgICAgbGV0IG1lcmNfd2lkdGggPSBVdGlscy5waXhlbFRvTWVyY2F0b3IodGhpcy5zaXplLnRleHRfc2l6ZVswXSk7XG4gICAgICAgIGxldCBtZXJjX2hlaWdodCA9IFV0aWxzLnBpeGVsVG9NZXJjYXRvcih0aGlzLnNpemUudGV4dF9zaXplWzFdKTtcblxuICAgICAgICBsZXQgb2JiID0gbmV3IE9CQih0aGlzLnBvc2l0aW9uWzBdLCB0aGlzLnBvc2l0aW9uWzFdLCAwLjAsIG1lcmNfd2lkdGgsIG1lcmNfaGVpZ2h0KTtcbiAgICAgICAgbGV0IGFhYmIgPSBvYmIuZ2V0RXh0ZW50KCk7XG4gICAgICAgIGFhYmIub2JiID0gb2JiO1xuXG4gICAgICAgIHJldHVybiBhYWJiO1xuICAgIH1cblxuICAgIG1vdmVJblRpbGUgKGluX3RpbGUpIHtcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy5hYWJiWzJdIC0gdGhpcy5hYWJiWzBdO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gLXRoaXMuYWFiYlszXSAtICgtdGhpcy5hYWJiWzFdKTtcblxuICAgICAgICAvLyBNb3ZlIHBvaW50IGxhYmVscyB0byB0aWxlIGVkZ2VzXG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uWzBdIC0gd2lkdGgvMiA8IDApIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMF0gPSB3aWR0aC8yICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBvc2l0aW9uWzBdICsgd2lkdGgvMiA+IEdlby50aWxlX3NjYWxlKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzBdID0gR2VvLnRpbGVfc2NhbGUgLSAod2lkdGgvMiArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvblsxXSAqPSAtMTsgLy8ganVzdCBkb2luZyB0aGlzIHNvIFkgY29vcmQgaXMgcG9zaXRpdmVcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb25bMV0gLSBoZWlnaHQvMiA8IDApIHsgLy8gJiYgdGhpcy5wb3NpdGlvblsxXSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMV0gPSBoZWlnaHQvMiArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wb3NpdGlvblsxXSArIGhlaWdodC8yID4gR2VvLnRpbGVfc2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMV0gPSBHZW8udGlsZV9zY2FsZSAtIChoZWlnaHQvMiArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zaXRpb25bMV0gKj0gLTE7XG5cbiAgICAgICAgdGhpcy5hYWJiID0gdGhpcy5jb21wdXRlQUFCQigpO1xuICAgICAgICByZXR1cm4gIXRoaXMuaW5UaWxlQm91bmRzKCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGV4cGxvZGUgKHRleHQsIHBvc2l0aW9uLCBzaXplLCBtYXhfd2lkdGgsIHBhZGRpbmcsIG1vdmVfaW5fdGlsZSwga2VlcF9pbl90aWxlKSB7XG4gICAgICAgIGxldCBzcGxpdF90ZXh0ID0gdGV4dC5zcGxpdCgnICcpO1xuXG4gICAgICAgIGlmIChzcGxpdF90ZXh0Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGFiZWxQb2ludCh0ZXh0LCBwb3NpdGlvbiwgc2l6ZSwgbnVsbCwgbW92ZV9pbl90aWxlLCBrZWVwX2luX3RpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxpbmUgPSBuZXcgVGV4dExpbmUodGV4dCwgc2l6ZS50ZXh0X3NpemVbMF0sIHNwbGl0X3RleHQsIHNpemUuc3BsaXRfc2l6ZSk7XG4gICAgICAgIGxldCBsaW5lcyA9IGxpbmUuZXhwbG9kZShtYXhfd2lkdGgpO1xuICAgICAgICBsZXQgbGFiZWxzID0gW107XG5cbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMYWJlbFBvaW50KHRleHQsIHBvc2l0aW9uLCBzaXplLCBudWxsLCBtb3ZlX2luX3RpbGUsIGtlZXBfaW5fdGlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpIGluIGxpbmVzKSB7XG4gICAgICAgICAgICBsZXQgbCA9IGxpbmVzW2ldO1xuICAgICAgICAgICAgbGV0IHBvcyA9IFtwb3NpdGlvblswXSwgcG9zaXRpb25bMV0gLSBNYXRoLmFicyhwYWRkaW5nKSAqIGldO1xuICAgICAgICAgICAgbGFiZWxzLnB1c2gobmV3IExhYmVsUG9pbnQobC50ZXh0LCBwb3MsIHNpemUsIG51bGwsIG1vdmVfaW5fdGlsZSwga2VlcF9pbl90aWxlKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IExhYmVsQ29tcG9zaXRlKHRleHQsIHBvc2l0aW9uLCBzaXplLCBsYWJlbHMsIG1vdmVfaW5fdGlsZSwga2VlcF9pbl90aWxlKTtcbiAgICB9XG59XG5cbmNsYXNzIExhYmVsQ29tcG9zaXRlIGV4dGVuZHMgTGFiZWwge1xuICAgIGNvbnN0cnVjdG9yICh0ZXh0LCBwb3NpdGlvbiwgc2l6ZSwgbGFiZWxzLCBtb3ZlX2luX3RpbGUsIGtlZXBfaW5fdGlsZSkge1xuICAgICAgICBzdXBlcih0ZXh0LCBzaXplLCBtb3ZlX2luX3RpbGUsIGtlZXBfaW5fdGlsZSk7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICB0aGlzLmxhYmVscyA9IGxhYmVscztcbiAgICAgICAgdGhpcy5hYWJiID0gdGhpcy5jb21wdXRlQUFCQigpO1xuICAgIH1cblxuICAgIGlzQ29tcG9zaXRlICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgbW92ZUluVGlsZSAoaW5fdGlsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29tcHV0ZUFBQkIgKCkge1xuICAgICAgICBsZXQgYWFiYiA9IFsgSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eSBdO1xuXG4gICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5sYWJlbHMpIHtcbiAgICAgICAgICAgIGxldCBiID0gdGhpcy5sYWJlbHNbaV0uYWFiYjtcblxuICAgICAgICAgICAgYWFiYlswXSA9IE1hdGgubWluKGJbMF0sIGFhYmJbMF0pO1xuICAgICAgICAgICAgYWFiYlsxXSA9IE1hdGgubWluKGJbMV0sIGFhYmJbMV0pO1xuICAgICAgICAgICAgYWFiYlsyXSA9IE1hdGgubWF4KGJbMl0sIGFhYmJbMl0pO1xuICAgICAgICAgICAgYWFiYlszXSA9IE1hdGgubWF4KGJbM10sIGFhYmJbM10pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFhYmI7XG4gICAgfVxufVxuXG5jbGFzcyBUZXh0TGluZSB7XG4gICAgY29uc3RydWN0b3IgKHRleHQsIGxpbmVfbGVuZ3RoLCB3b3Jkcywgc2l6ZV9pbmZvKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMubGluZV9sZW5ndGggPSBsaW5lX2xlbmd0aDtcbiAgICAgICAgdGhpcy5zaXplX2luZm8gPSBzaXplX2luZm87XG4gICAgICAgIHRoaXMud29yZHMgPSB0aGlzLnBvc2l0aW9ucyh3b3Jkcyk7XG4gICAgfVxuXG4gICAgcG9zaXRpb25zICh3b3Jkcywgc2l6ZV9pbmZvKSB7XG4gICAgICAgIGxldCB3b3JkX2luZm9zID0gW107XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBsZXQgc3BhY2Vfb2Zmc2V0ID0gdGhpcy5zaXplX2luZm9bJyAnXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgd29yZCA9IHdvcmRzW2ldO1xuICAgICAgICAgICAgbGV0IHdvcmRfbGVuZ3RoID0gdGhpcy5zaXplX2luZm9bd29yZF07XG5cbiAgICAgICAgICAgIHdvcmRfaW5mb3MucHVzaCh7XG4gICAgICAgICAgICAgICAgd29yZDogd29yZCxcbiAgICAgICAgICAgICAgICBzdGFydDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgIGVuZDogb2Zmc2V0ICsgd29yZF9sZW5ndGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHdvcmRfbGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoaSAhPT0gd29yZHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHdvcmRfaW5mb3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHdvcmQ6ICcgJyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBvZmZzZXQgKyBzcGFjZV9vZmZzZXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gc3BhY2Vfb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHdvcmRfaW5mb3M7XG4gICAgfVxuXG4gICAgZXhwbG9kZSAobWF4X3dpZHRoLCBleHBsb2RlZF9saW5lcyA9IFtdKSB7XG4gICAgICAgIGlmIChtYXhfd2lkdGggPiB0aGlzLmxpbmVfbGVuZ3RoKSB7XG4gICAgICAgICAgICBleHBsb2RlZF9saW5lcy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGV4cGxvZGVkX2xpbmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy53b3JkSW5mb0luZGV4KG1heF93aWR0aCk7XG5cbiAgICAgICAgaWYgKHRoaXMud29yZHNbaW5kZXhdLndvcmQgPT09ICcgJykge1xuICAgICAgICAgICAgaW5kZXggLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA8IDEpIHtcbiAgICAgICAgICAgIGV4cGxvZGVkX2xpbmVzLnB1c2godGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gZXhwbG9kZWRfbGluZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPCB0aGlzLndvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5leHRfbGluZV9sZW5ndGggPSAwLCBwcmV2aW91c19saW5lX2xlbmd0aCA9IDA7XG4gICAgICAgICAgICBsZXQgbmV4dF9saW5lX3dvcmRzID0gJycsIHByZXZpb3VzX2xpbmVfd29yZHMgPSAnJztcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4OyBpIDwgdGhpcy53b3Jkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIG5leHRfbGluZV93b3JkcyArPSB0aGlzLndvcmRzW2ldLndvcmQ7XG4gICAgICAgICAgICAgICAgbmV4dF9saW5lX2xlbmd0aCArPSB0aGlzLnNpemVfaW5mb1t0aGlzLndvcmRzW2ldLndvcmRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaW5kZXggLSAxICYmIHRoaXMud29yZHNbaV0gIT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c19saW5lX3dvcmRzICs9IHRoaXMud29yZHNbaV0ud29yZDtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNfbGluZV9sZW5ndGggKz0gdGhpcy5zaXplX2luZm9bdGhpcy53b3Jkc1tpXS53b3JkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cGxvZGVkX2xpbmVzLnB1c2gobmV3IFRleHRMaW5lKFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c19saW5lX3dvcmRzLFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c19saW5lX2xlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNfbGluZV93b3Jkcy5zcGxpdCgnICcpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemVfaW5mb1xuICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIGxldCBuZXh0X2xpbmUgPSBuZXcgVGV4dExpbmUobmV4dF9saW5lX3dvcmRzLFxuICAgICAgICAgICAgICAgICAgICBuZXh0X2xpbmVfbGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBuZXh0X2xpbmVfd29yZHMuc3BsaXQoJyAnKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplX2luZm9cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXh0X2xpbmUuZXhwbG9kZShtYXhfd2lkdGgsIGV4cGxvZGVkX2xpbmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGxvZGVkX2xpbmVzLnB1c2godGhpcyk7XG4gICAgICAgIHJldHVybiBleHBsb2RlZF9saW5lcztcbiAgICB9XG5cbiAgICB3b3JkSW5mb0luZGV4IChwb3NpdGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb24gPiB0aGlzLmxpbmVfbGVuZ3RoIHx8IHRoaXMud29yZHNbdGhpcy53b3Jkcy5sZW5ndGggLSAxXS5lbmQgPCBwb3NpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud29yZHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGQgPSB0aGlzLndvcmRzLmxlbmd0aCAvIDI7XG4gICAgICAgIGxldCBpID0gTWF0aC5jZWlsKGQpO1xuICAgICAgICBpID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgaSksIHRoaXMud29yZHMubGVuZ3RoIC0gMSk7XG4gICAgICAgIGxldCB3b3JkX2luZm8gPSB0aGlzLndvcmRzW2ldO1xuXG4gICAgICAgIC8vIGRpY2hvdG9taWMgc2VhcmNoXG4gICAgICAgIHdoaWxlICh3b3JkX2luZm8uc3RhcnQgPiBwb3NpdGlvbiB8fCB3b3JkX2luZm8uZW5kIDwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIGQgLz0gMjtcbiAgICAgICAgICAgIGkgKz0gd29yZF9pbmZvLmVuZCA8IHBvc2l0aW9uID8gTWF0aC5jZWlsKGQpIDogLU1hdGguY2VpbChkKTtcbiAgICAgICAgICAgIGkgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBpKSwgdGhpcy53b3Jkcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHdvcmRfaW5mbyA9IHRoaXMud29yZHNbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG59XG5cbiIsIi8vIFRleHQgcmVuZGVyaW5nIHN0eWxlXG5cbmltcG9ydCBCdWlsZGVycyBmcm9tICcuLi9idWlsZGVycyc7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuLi9zdHlsZV9wYXJzZXInO1xuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi4vLi4vZ2wvdGV4dHVyZSc7XG5pbXBvcnQgV29ya2VyQnJva2VyIGZyb20gJy4uLy4uL3V0aWxzL3dvcmtlcl9icm9rZXInO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCB7UG9pbnRzfSBmcm9tICcuLi9wb2ludHMvcG9pbnRzJztcbmltcG9ydCBMYWJlbEJ1aWxkZXIgZnJvbSAnLi9sYWJlbF9idWlsZGVyJztcblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCBsZXQgVGV4dFN0eWxlID0gT2JqZWN0LmNyZWF0ZShQb2ludHMpO1xuXG5PYmplY3QuYXNzaWduKFRleHRTdHlsZSwge1xuICAgIG5hbWU6ICd0ZXh0JyxcbiAgICBzdXBlcjogUG9pbnRzLFxuICAgIGJ1aWx0X2luOiB0cnVlLFxuICAgIHNlbGVjdGlvbjogZmFsc2UsIC8vIG5vIGZlYXR1cmUgc2VsZWN0aW9uIGZvciB0ZXh0IGJ5IGRlZmF1bHRcblxuICAgIGluaXQoKSB7XG5cbiAgICAgICAgdGhpcy5zdXBlci5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHRoaXMgb2JqZWN0IHRvIGJlIGNhbGxlZCBmcm9tIHdvcmtlciB0aHJlYWRzXG4gICAgICAgIHRoaXMubWFpbl90aHJlYWRfdGFyZ2V0ID0gJ1RleHRTdHlsZS0nICsgdGhpcy5uYW1lO1xuICAgICAgICBpZiAoVXRpbHMuaXNNYWluVGhyZWFkKSB7XG4gICAgICAgICAgICBXb3JrZXJCcm9rZXIuYWRkVGFyZ2V0KHRoaXMubWFpbl90aHJlYWRfdGFyZ2V0LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBvaW50IHN0eWxlIChwYXJlbnQgY2xhc3MpIHJlcXVpcmVzIHRleHR1cmluZyB0byBiZSB0dXJuZWQgb25cbiAgICAgICAgLy8gKGxhYmVscyBhcmUgYWx3YXlzIGRyYXduIHdpdGggdGV4dHVyZXMpXG4gICAgICAgIHRoaXMuZGVmaW5lcy5UQU5HUkFNX1BPSU5UX1RFWFRVUkUgPSB0cnVlO1xuXG4gICAgICAgIC8vIE1hbnVhbGx5IHVuLW11bHRpcGx5IGFscGhhLCBiZWNhdXNlIENhbnZhcyB0ZXh0IHJhc3Rlcml6YXRpb24gaXMgcHJlLW11bHRpcGxpZWRcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90YW5ncmFtcy90YW5ncmFtL2lzc3Vlcy8xNzlcbiAgICAgICAgdGhpcy5kZWZpbmVzLlRBTkdSQU1fVU5NVUxUSVBMWV9BTFBIQSA9IHRydWU7XG5cbiAgICAgICAgLy8gZGVmYXVsdCBmb250IHN0eWxlXG4gICAgICAgIHRoaXMuZm9udF9zdHlsZSA9IHtcbiAgICAgICAgICAgIHR5cGVmYWNlOiAnSGVsdmV0aWNhIDEycHgnLFxuICAgICAgICAgICAgZmlsbDogJ3doaXRlJyxcbiAgICAgICAgICAgIGNhcGl0YWxpemVkOiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRlZmF1bHQgbGFiZWwgc3R5bGVcbiAgICAgICAgdGhpcy5sYWJlbF9zdHlsZSA9IHtcbiAgICAgICAgICAgIGxpbmVzOiB7XG4gICAgICAgICAgICAgICAgZXhjZWVkOiA4MCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb2ludHM6IHtcbiAgICAgICAgICAgICAgICBtYXhfd2lkdGg6IDE1MCxcbiAgICAgICAgICAgICAgICBsaW5lX2hlaWdodDogMTAwIC8vIHBlcmNlbnRhZ2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfSxcblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnN1cGVyLnJlc2V0LmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dHMgPSB7fTsgLy8gdW5pcXVlIHRleHRzLCBrZXllZCBieSB0aWxlXG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSB7fTtcbiAgICAgICAgdGhpcy5jYW52YXMgPSB7fTtcbiAgICAgICAgdGhpcy5hYWJicyA9IHt9O1xuICAgICAgICB0aGlzLmZlYXR1cmVzID0ge307XG4gICAgICAgIHRoaXMuZmVhdHVyZV9sYWJlbHMgPSB7fTtcbiAgICAgICAgdGhpcy5mZWF0dXJlX3N0eWxlX2tleSA9IHt9O1xuICAgIH0sXG5cbiAgICAvLyBDYWxsZWQgb24gbWFpbiB0aHJlYWQgdG8gcmVsZWFzZSB0aWxlLXNwZWNpZmljIHJlc291cmNlc1xuICAgIGZyZWVUaWxlICh0aWxlKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRleHRzW3RpbGVdO1xuICAgICAgICBkZWxldGUgdGhpcy50ZXh0dXJlc1t0aWxlXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FudmFzW3RpbGVdO1xuICAgICAgICBkZWxldGUgdGhpcy5hYWJic1t0aWxlXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZmVhdHVyZXNbdGlsZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmZlYXR1cmVfbGFiZWxzW3RpbGVdO1xuICAgICAgICBkZWxldGUgdGhpcy5mZWF0dXJlX3N0eWxlX2tleVt0aWxlXTtcbiAgICB9LFxuXG5cbiAgICAvLyBTZXQgZm9udCBzdHlsZSBwYXJhbXMgZm9yIGNhbnZhcyBkcmF3aW5nXG4gICAgc2V0Rm9udCAodGlsZSwgeyBmb250LCBmaWxsLCBzdHJva2UsIHN0cm9rZV93aWR0aCwgcHhfc2l6ZSwgcHhfbG9naWNhbF9zaXplIH0pIHtcbiAgICAgICAgdGhpcy5weF9zaXplID0gcGFyc2VJbnQocHhfc2l6ZSk7XG4gICAgICAgIHRoaXMucHhfbG9naWNhbF9zaXplID0gcGFyc2VJbnQocHhfbG9naWNhbF9zaXplKTtcbiAgICAgICAgdGhpcy50ZXh0X2J1ZmZlciA9IDY7IC8vIHBpeGVsIHBhZGRpbmcgYXJvdW5kIHRleHRcbiAgICAgICAgbGV0IGN0eCA9IHRoaXMuY2FudmFzW3RpbGVdLmNvbnRleHQ7XG5cbiAgICAgICAgY3R4LmZvbnQgPSBmb250O1xuICAgICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2U7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gc3Ryb2tlX3dpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbnVsbDtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsO1xuICAgICAgICBjdHgubWl0ZXJMaW1pdCA9IDI7XG4gICAgfSxcblxuICAgIC8vIFdpZHRoIGFuZCBoZWlnaHQgb2YgdGV4dCBiYXNlZCBvbiBjdXJyZW50IGZvbnQgc3R5bGVcbiAgICB0ZXh0U2l6ZSAodGV4dCwgdGlsZSwgY2FwaXRhbGl6ZWQpIHtcbiAgICAgICAgbGV0IHN0ciA9IGNhcGl0YWxpemVkID8gdGV4dC50b1VwcGVyQ2FzZSgpIDogdGV4dDtcbiAgICAgICAgbGV0IGN0eCA9IHRoaXMuY2FudmFzW3RpbGVdLmNvbnRleHQ7XG4gICAgICAgIGxldCBzcGxpdCA9IHN0ci5zcGxpdCgnICcpO1xuICAgICAgICBsZXQgcHhfc2l6ZSA9IHRoaXMucHhfc2l6ZTtcbiAgICAgICAgbGV0IHB4X2xvZ2ljYWxfc2l6ZSA9IHRoaXMucHhfbG9naWNhbF9zaXplO1xuICAgICAgICBsZXQgYnVmZmVyID0gdGhpcy50ZXh0X2J1ZmZlciAqIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbztcbiAgICAgICAgbGV0IHNwbGl0X3NpemUgPSB7XG4gICAgICAgICAgICBcIiBcIjogdGhpcy5jYW52YXNbdGlsZV0uY29udGV4dC5tZWFzdXJlVGV4dChcIiBcIikud2lkdGggLyBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW9cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGxldCBpIGluIHNwbGl0KSB7XG4gICAgICAgICAgICBsZXQgd29yZCA9IHNwbGl0W2ldO1xuICAgICAgICAgICAgc3BsaXRfc2l6ZVt3b3JkXSA9IGN0eC5tZWFzdXJlVGV4dCh3b3JkKS53aWR0aCAvIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdHJfd2lkdGggPSBjdHgubWVhc3VyZVRleHQoc3RyKS53aWR0aDtcbiAgICAgICAgbGV0IHRleHRfc2l6ZSA9IFtcbiAgICAgICAgICAgIHN0cl93aWR0aCAvIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbyxcbiAgICAgICAgICAgIHRoaXMucHhfc2l6ZSAvIFV0aWxzLmRldmljZV9waXhlbF9yYXRpb1xuICAgICAgICBdO1xuXG4gICAgICAgIGxldCB0ZXh0dXJlX3RleHRfc2l6ZSA9IFtcbiAgICAgICAgICAgIE1hdGguY2VpbChzdHJfd2lkdGgpICsgYnVmZmVyICogMixcbiAgICAgICAgICAgIHRoaXMucHhfc2l6ZSArIGJ1ZmZlciAqIDJcbiAgICAgICAgXTtcblxuICAgICAgICByZXR1cm4geyBzcGxpdF9zaXplLCB0ZXh0X3NpemUsIHRleHR1cmVfdGV4dF9zaXplLCBweF9zaXplLCBweF9sb2dpY2FsX3NpemUgfTtcbiAgICB9LFxuXG4gICAgLy8gRHJhdyB0ZXh0IGF0IHNwZWNpZmllZCBsb2NhdGlvbiwgYWRqdXN0aW5nIGZvciBidWZmZXIgYW5kIGJhc2VsaW5lXG4gICAgZHJhd1RleHQgKHRleHQsIFt4LCB5XSwgdGlsZSwgc3Ryb2tlLCBjYXBpdGFsaXplZCkge1xuICAgICAgICBsZXQgc3RyID0gY2FwaXRhbGl6ZWQgPyB0ZXh0LnRvVXBwZXJDYXNlKCkgOiB0ZXh0O1xuICAgICAgICBsZXQgYnVmZmVyID0gdGhpcy50ZXh0X2J1ZmZlciAqIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbztcbiAgICAgICAgaWYgKHN0cm9rZSkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXNbdGlsZV0uY29udGV4dC5zdHJva2VUZXh0KHN0ciwgeCArIGJ1ZmZlciwgeSArIGJ1ZmZlciArIHRoaXMucHhfc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW52YXNbdGlsZV0uY29udGV4dC5maWxsVGV4dChzdHIsIHggKyBidWZmZXIsIHkgKyBidWZmZXIgKyB0aGlzLnB4X3NpemUpO1xuICAgIH0sXG5cbiAgICBzZXRUZXh0dXJlVGV4dFBvc2l0aW9ucyAodGV4dHMpIHtcbiAgICAgICAgLy8gRmluZCB3aWRlc3QgbGFiZWwgYW5kIHN1bSBvZiBhbGwgbGFiZWwgaGVpZ2h0c1xuICAgICAgICBsZXQgd2lkZXN0ID0gMCwgaGVpZ2h0ID0gMDtcblxuICAgICAgICBmb3IgKGxldCBzdHlsZSBpbiB0ZXh0cykge1xuICAgICAgICAgICAgbGV0IHRleHRfaW5mb3MgPSB0ZXh0c1tzdHlsZV07XG5cbiAgICAgICAgICAgIGZvciAobGV0IHRleHQgaW4gdGV4dF9pbmZvcykge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0X2luZm8gPSB0ZXh0X2luZm9zW3RleHRdO1xuICAgICAgICAgICAgICAgIGxldCBzaXplID0gdGV4dF9pbmZvLnNpemUudGV4dHVyZV90ZXh0X3NpemU7XG5cbiAgICAgICAgICAgICAgICB0ZXh0X2luZm8ucG9zaXRpb24gPSBbMCwgaGVpZ2h0XTtcblxuICAgICAgICAgICAgICAgIGlmIChzaXplWzBdID4gd2lkZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZGVzdCA9IHNpemVbMF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaGVpZ2h0ICs9IHNpemVbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gWyB3aWRlc3QsIGhlaWdodCBdO1xuICAgIH0sXG5cbiAgICBnZXRUZXh0U2l6ZXMgKHRpbGUsIHRleHRzKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIGNhbnZhc1xuICAgICAgICBpZighdGhpcy5jYW52YXNbdGlsZV0pIHtcbiAgICAgICAgICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzW3RpbGVdID0ge1xuICAgICAgICAgICAgICAgIGNhbnZhczogY2FudmFzLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgc3R5bGUgaW4gdGV4dHMpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0X2luZm9zID0gdGV4dHNbc3R5bGVdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCB0ZXh0IGluIHRleHRfaW5mb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dF9zdHlsZSA9IHRleHRfaW5mb3NbdGV4dF0udGV4dF9zdHlsZTtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGV4dCBzaXplc1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Rm9udCh0aWxlLCB0ZXh0X3N0eWxlKTtcbiAgICAgICAgICAgICAgICB0ZXh0X2luZm9zW3RleHRdLnNpemUgPSB0aGlzLnRleHRTaXplKHRleHQsIHRpbGUsIHRleHRfc3R5bGUuY2FwaXRhbGl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0ZXh0cyk7XG4gICAgfSxcblxuICAgIHJhc3Rlcml6ZSAodGlsZSwgdGV4dHMsIHRleHR1cmVfc2l6ZSkge1xuICAgICAgICBsZXQgcGl4ZWxfc2NhbGUgPSBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW87XG5cbiAgICAgICAgZm9yIChsZXQgc3R5bGUgaW4gdGV4dHMpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0X2luZm9zID0gdGV4dHNbc3R5bGVdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCB0ZXh0IGluIHRleHRfaW5mb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5mbyA9IHRleHRfaW5mb3NbdGV4dF07XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNldEZvbnQodGlsZSwgaW5mby50ZXh0X3N0eWxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdUZXh0KHRleHQsIGluZm8ucG9zaXRpb24sIHRpbGUsIGluZm8udGV4dF9zdHlsZS5zdHJva2UsIGluZm8udGV4dF9zdHlsZS5jYXBpdGFsaXplZCk7XG5cbiAgICAgICAgICAgICAgICBpbmZvLnRleGNvb3JkcyA9IEJ1aWxkZXJzLmdldFRleGNvb3Jkc0ZvclNwcml0ZShcbiAgICAgICAgICAgICAgICAgICAgaW5mby5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgaW5mby5zaXplLnRleHR1cmVfdGV4dF9zaXplLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlX3NpemVcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpbmZvLnN1Yl90ZXh0cykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnRleHRfYnVmZmVyO1xuICAgICAgICAgICAgICAgIGxldCBkaXN0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBzcGFjZV9zaXplID0gaW5mby5zaXplLnNwbGl0X3NpemVbJyAnXTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5mby5zdWJfdGV4dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1Yl90ZXh0ID0gaW5mby5zdWJfdGV4dHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGxpdCA9IHN1Yl90ZXh0LnNwbGl0KCcgJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGlzdHNbaV0gPSB3aWR0aCAqIHBpeGVsX3NjYWxlO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3BsaXQubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3b3JkID0gc3BsaXRbal07XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCArPSBpbmZvLnNpemUuc3BsaXRfc2l6ZVt3b3JkXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogIT09IHNwbGl0Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCArPSBzcGFjZV9zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IGluZm8uc3ViX3RleHRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoICs9IHNwYWNlX3NpemUgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc3ViLXRleHRzIHV2IG1hcHBpbmdcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZm8uc3ViX3RleHRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdWJfdGV4dCA9IGluZm8uc3ViX3RleHRzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5mby5zdWJ0ZXhjb29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uc3VidGV4Y29vcmRzID0ge307XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGluZm8uc3ViX3RleHRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGluZm8uc2l6ZS50ZXh0dXJlX3RleHRfc2l6ZVswXSAtIGRpc3RzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8ucG9zaXRpb25bMF0gKyBkaXN0c1tpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8ucG9zaXRpb25bMV1cbiAgICAgICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIChpbmZvLnNpemUudGV4dHVyZV90ZXh0X3NpemVbMF0gLSBvZmZzZXQpIC0gZGlzdHNbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvLnNpemUudGV4dHVyZV90ZXh0X3NpemVbMV1cbiAgICAgICAgICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWluZm8uc3VidGV4dF9zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvLnN1YnRleHRfc2l6ZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluZm8uc3VidGV4dF9zaXplW3N1Yl90ZXh0XSA9IHNpemU7XG5cbiAgICAgICAgICAgICAgICAgICAgaW5mby5zdWJ0ZXhjb29yZHNbc3ViX3RleHRdID0gQnVpbGRlcnMuZ2V0VGV4Y29vcmRzRm9yU3ByaXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24sIHNpemUsIHRleHR1cmVfc2l6ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBDYWxsZWQgb24gbWFpbiB0aHJlYWQgZnJvbSB3b3JrZXIsIHRvIGNyZWF0ZSBhdGxhcyBvZiBsYWJlbHMgZm9yIGEgdGlsZVxuICAgIGFkZFRleHRzICh0aWxlLCB0ZXh0cykge1xuICAgICAgICBpZiAoIXRoaXMuY2FudmFzW3RpbGVdKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0ZXh0dXJlX3NpemUgPSB0aGlzLnNldFRleHR1cmVUZXh0UG9zaXRpb25zKHRleHRzKTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSB0aGlzLmNhbnZhc1t0aWxlXS5jb250ZXh0O1xuXG4gICAgICAgIGxvZy50cmFjZShgdGV4dCBzdW1tYXJ5IGZvciB0aWxlICR7dGlsZX06IGZpdHMgaW4gJHt0ZXh0dXJlX3NpemVbMF19eCR7dGV4dHVyZV9zaXplWzFdfXB4YCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBjYW52YXMgXCJjb250ZXh0XCJcbiAgICAgICAgdGhpcy5jYW52YXNbdGlsZV0uY2FudmFzLndpZHRoID0gdGV4dHVyZV9zaXplWzBdO1xuICAgICAgICB0aGlzLmNhbnZhc1t0aWxlXS5jYW52YXMuaGVpZ2h0ID0gdGV4dHVyZV9zaXplWzFdO1xuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0ZXh0dXJlX3NpemVbMF0sIHRleHR1cmVfc2l6ZVsxXSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgdGV4dHVyZVxuICAgICAgICBsZXQgdGV4dHVyZSA9ICdsYWJlbHMtJyArIHRpbGUgKyAnLScgKyAoVGV4dFN0eWxlLnRleHR1cmVfaWQrKyk7XG4gICAgICAgIHRoaXMudGV4dHVyZXNbdGlsZV0gPSBuZXcgVGV4dHVyZSh0aGlzLmdsLCB0ZXh0dXJlLCB7IGZpbHRlcmluZzogJ2xpbmVhcicgfSk7XG4gICAgICAgIC8vIHRoaXMudGV4dHVyZXNbdGlsZV0ub3duZXIgPSB7IHRpbGUgfTtcblxuICAgICAgICAvLyBhc2sgZm9yIHJhc3Rlcml6YXRpb24gZm9yIHRoZSB0ZXh0IHNldFxuICAgICAgICB0aGlzLnJhc3Rlcml6ZSh0aWxlLCB0ZXh0cywgdGV4dHVyZV9zaXplKTtcblxuICAgICAgICB0aGlzLnRleHR1cmVzW3RpbGVdLnNldENhbnZhcyh0aGlzLmNhbnZhc1t0aWxlXS5jYW52YXMpO1xuXG4gICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdGlsZSBjYW52YXMvdGV4dHVyZSBvbmNlIGl0IGhhcyBiZWVuIGNvcGllZCB0byB0byBHUFVcbiAgICAgICAgZGVsZXRlIHRoaXMudGV4dHVyZXNbdGlsZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbnZhc1t0aWxlXTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgdGV4dHMsIHRleHR1cmUgfSk7XG4gICAgfSxcblxuICAgIC8vIE92ZXJyaWRlXG4gICAgc3RhcnREYXRhICh0aWxlKSB7XG4gICAgICAgIGxldCB0aWxlX2RhdGEgPSB0aGlzLnN1cGVyLnN0YXJ0RGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aWxlX2RhdGEucXVldWUgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRpbGVfZGF0YTtcbiAgICB9LFxuXG4gICAgc3ViVGV4dEluZm9zIChsYWJlbF9jb21wb3NpdGUsIHRleHRfaW5mbykge1xuICAgICAgICBpZiAoIXRleHRfaW5mby5zdWJfdGV4dHMpIHtcbiAgICAgICAgICAgIHRleHRfaW5mby5zdWJfdGV4dHMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgaW4gbGFiZWxfY29tcG9zaXRlLmxhYmVscykge1xuICAgICAgICAgICAgbGV0IGxhYmVsID0gbGFiZWxfY29tcG9zaXRlLmxhYmVsc1tpXTtcbiAgICAgICAgICAgIHRleHRfaW5mby5zdWJfdGV4dHMucHVzaChsYWJlbC50ZXh0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjcmVhdGVMYWJlbHMgKHRpbGUsIHRleHRzKSB7XG4gICAgICAgIGxldCBsYWJlbHNfcHJpb3JpdGllcyA9IHt9O1xuXG4gICAgICAgIGlmICghdGhpcy5mZWF0dXJlc1t0aWxlXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgc3R5bGUgaW4gdGV4dHMpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0X2luZm9zID0gdGV4dHNbc3R5bGVdO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuZmVhdHVyZXNbdGlsZV1bc3R5bGVdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCB0ZXh0IGluIHRleHRfaW5mb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dF9pbmZvID0gdGV4dF9pbmZvc1t0ZXh0XTtcbiAgICAgICAgICAgICAgICB0ZXh0X2luZm8ucmVmID0gMDtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5mZWF0dXJlc1t0aWxlXVtzdHlsZV1bdGV4dF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGYgPSAwOyBmIDwgdGhpcy5mZWF0dXJlc1t0aWxlXVtzdHlsZV1bdGV4dF0ubGVuZ3RoOyBmKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZlYXR1cmUgPSB0aGlzLmZlYXR1cmVzW3RpbGVdW3N0eWxlXVt0ZXh0XVtmXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVscyA9IExhYmVsQnVpbGRlci5sYWJlbHNGcm9tR2VvbWV0cnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5nZW9tZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHRleHQsIHNpemU6IHRleHRfaW5mby5zaXplIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYWJlbF9zdHlsZVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSBsYWJlbHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXJlYSA9IGxhYmVsLmFyZWE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsc19wcmlvcml0aWVzW3RleHRfaW5mby5wcmlvcml0eV0gPSBsYWJlbHNfcHJpb3JpdGllc1t0ZXh0X2luZm8ucHJpb3JpdHldIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxzX3ByaW9yaXRpZXNbdGV4dF9pbmZvLnByaW9yaXR5XS5wdXNoKHsgc3R5bGUsIGZlYXR1cmUsIGxhYmVsLCBhcmVhIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWwuaXNDb21wb3NpdGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ViVGV4dEluZm9zKGxhYmVsLCB0ZXh0X2luZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc29ydCBieSBhcmVhIHNpemUgaWYgZGVmaW5lZFxuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGxhYmVsc19wcmlvcml0aWVzLmxlbmd0aDsgKytwKSB7XG4gICAgICAgICAgICBpZiAoIWxhYmVsc19wcmlvcml0aWVzW3BdKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhYmVsc19wcmlvcml0aWVzW3BdLnNvcnQoKGUxLCBlMikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlMS5hcmVhICYmIGUyLmFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUxLmFyZWEgPCBlMi5hcmVhO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYWJlbHNfcHJpb3JpdGllcztcbiAgICB9LFxuXG4gICAgZGlzY2FyZExhYmVscyAodGlsZSwgbGFiZWxzLCB0ZXh0cykge1xuICAgICAgICB0aGlzLmFhYmJzW3RpbGVdID0gW107XG4gICAgICAgIHRoaXMuZmVhdHVyZV9sYWJlbHNbdGlsZV0gPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgLy8gUHJvY2VzcyBsYWJlbHMgYnkgcHJpb3JpdHlcbiAgICAgICAgbGV0IHByaW9yaXRpZXMgPSBPYmplY3Qua2V5cyhsYWJlbHMpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgZm9yIChsZXQgcHJpb3JpdHkgb2YgcHJpb3JpdGllcykge1xuICAgICAgICAgICAgaWYgKCFsYWJlbHNbcHJpb3JpdHldKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFiZWxzW3ByaW9yaXR5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB7IHN0eWxlLCBmZWF0dXJlLCBsYWJlbCB9ID0gbGFiZWxzW3ByaW9yaXR5XVtpXTtcblxuICAgICAgICAgICAgICAgIGlmICghbGFiZWwuZGlzY2FyZCh0aGlzLmFhYmJzW3RpbGVdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZmVhdHVyZV9sYWJlbHNbdGlsZV0uaGFzKGZlYXR1cmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmVfbGFiZWxzW3RpbGVdLnNldChmZWF0dXJlLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mZWF0dXJlX2xhYmVsc1t0aWxlXS5nZXQoZmVhdHVyZSkucHVzaChsYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgIHRleHRzW3N0eWxlXVtsYWJlbC50ZXh0XS5yZWYrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBzdHlsZSBpbiB0ZXh0cykge1xuICAgICAgICAgICAgZm9yIChsZXQgdGV4dCBpbiB0ZXh0c1tzdHlsZV0pIHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dHNbc3R5bGVdW3RleHRdLnJlZiA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRleHRzW3N0eWxlXVt0ZXh0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBzdHlsZSBpbiB0ZXh0cykge1xuICAgICAgICAgICAgbGV0IHRleHRfaW5mb3MgPSB0ZXh0c1tzdHlsZV07XG4gICAgICAgICAgICAvLyBObyBsYWJlbHMgZm9yIHRoaXMgc3R5bGVcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0ZXh0X2luZm9zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGV4dHNbc3R5bGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIE92ZXJyaWRlXG4gICAgZW5kRGF0YSAodGlsZSkge1xuICAgICAgICAvLyBDb3VudCBjb2xsZWN0ZWQgdGV4dFxuICAgICAgICBsZXQgY291bnQ7XG4gICAgICAgIGxldCB0aWxlX2RhdGEgPSB0aGlzLnRpbGVfZGF0YVt0aWxlXTtcblxuICAgICAgICBpZiAodGlsZV9kYXRhLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvdW50ID0gT2JqZWN0LmtleXModGhpcy50ZXh0c1t0aWxlXXx8e30pLmxlbmd0aDtcbiAgICAgICAgICAgIGxvZy50cmFjZShgIyB0ZXh0cyBmb3IgdGlsZSAke3RpbGV9OiAke2NvdW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpcnN0IGNhbGwgdG8gbWFpbiB0aHJlYWQsIGFzayBmb3IgdGV4dCBwaXhlbCBzaXplc1xuICAgICAgICByZXR1cm4gV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHRoaXMubWFpbl90aHJlYWRfdGFyZ2V0LCAnZ2V0VGV4dFNpemVzJywgdGlsZSwgdGhpcy50ZXh0c1t0aWxlXSkudGhlbih0ZXh0cyA9PiB7XG4gICAgICAgICAgICBpZiAoIXRleHRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmVlVGlsZSh0aWxlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5lbmREYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBsYWJlbHMgPSB0aGlzLmNyZWF0ZUxhYmVscyh0aWxlLCB0ZXh0cyk7XG4gICAgICAgICAgICBpZiAoIWxhYmVscykge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJlZVRpbGUodGlsZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIuZW5kRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRpc2NhcmRMYWJlbHModGlsZSwgbGFiZWxzLCB0ZXh0cyk7XG5cbiAgICAgICAgICAgIC8vIE5vIGxhYmVscyBmb3IgdGhpcyB0aWxlXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModGV4dHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJlZVRpbGUodGlsZSk7XG4gICAgICAgICAgICAgICAgV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHRoaXMubWFpbl90aHJlYWRfdGFyZ2V0LCAnZnJlZVRpbGUnLCB0aWxlKTtcbiAgICAgICAgICAgICAgICAvLyBlYXJseSBleGl0XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZWNvbmQgY2FsbCB0byBtYWluIHRocmVhZCwgZm9yIHJhc3Rlcml6aW5nIHRoZSBzZXQgb2YgdGV4dHNcbiAgICAgICAgICAgIHJldHVybiBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UodGhpcy5tYWluX3RocmVhZF90YXJnZXQsICdhZGRUZXh0cycsIHRpbGUsIHRleHRzKS50aGVuKCh7IHRleHRzLCB0ZXh0dXJlIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0c1t0aWxlXSA9IHRleHRzO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dGFjaCB0aWxlLXNwZWNpZmljIGxhYmVsIGF0bGFzIHRvIG1lc2ggYXMgYSB0ZXh0dXJlIHVuaWZvcm1cbiAgICAgICAgICAgICAgICAgICAgdGlsZV9kYXRhLnVuaWZvcm1zID0geyB1X3RleHR1cmU6IHRleHR1cmUgfTtcbiAgICAgICAgICAgICAgICAgICAgdGlsZV9kYXRhLnRleHR1cmVzID0gW3RleHR1cmVdOyAvLyBhc3NpZ24gdGV4dHVyZSBvd25lcnNoaXAgdG8gdGlsZSAtIFRPRE86IGltcGxlbWVudCBpbiBWQk9NZXNoXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQnVpbGQgcXVldWVkIGZlYXR1cmVzXG4gICAgICAgICAgICAgICAgICAgIHRpbGVfZGF0YS5xdWV1ZS5mb3JFYWNoKHEgPT4gdGhpcy5zdXBlci5hZGRGZWF0dXJlLmFwcGx5KHRoaXMsIHEpKTtcbiAgICAgICAgICAgICAgICAgICAgdGlsZV9kYXRhLnF1ZXVlID0gW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5mcmVlVGlsZSh0aWxlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5lbmREYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIE92ZXJyaWRlIHRvIHF1ZXVlIGZlYXR1cmVzIGluc3RlYWQgb2YgcHJvY2Vzc2luZyBpbW1lZGlhdGVseVxuICAgIGFkZEZlYXR1cmUgKGZlYXR1cmUsIHJ1bGUsIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHRpbGUgPSBjb250ZXh0LnRpbGU7XG4gICAgICAgIGlmICh0aWxlLmdlbmVyYXRpb24gIT09IHRoaXMuZ2VuZXJhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29sbGVjdCB0ZXh0XG4gICAgICAgIGxldCB0ZXh0O1xuICAgICAgICBsZXQgc291cmNlID0gcnVsZS50ZXh0X3NvdXJjZSB8fCAnbmFtZSc7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0ZXh0ID0gZmVhdHVyZS5wcm9wZXJ0aWVzW3NvdXJjZV07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGV4dCA9IHNvdXJjZShjb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICBmZWF0dXJlLnRleHQgPSB0ZXh0O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMudGV4dHNbdGlsZS5rZXldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0c1t0aWxlLmtleV0gPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHN0eWxlID0gdGhpcy5jb25zdHJ1Y3RGb250U3R5bGUocnVsZSwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgc3R5bGVfa2V5ID0gdGhpcy5jb25zdHJ1Y3RTdHlsZUtleShzdHlsZSk7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVfc3R5bGVfa2V5W3RpbGUua2V5XSA9IHRoaXMuZmVhdHVyZV9zdHlsZV9rZXlbdGlsZS5rZXldIHx8IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZV9zdHlsZV9rZXlbdGlsZS5rZXldLnNldChmZWF0dXJlLCBzdHlsZV9rZXkpO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMudGV4dHNbdGlsZS5rZXldW3N0eWxlX2tleV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRzW3RpbGUua2V5XVtzdHlsZV9rZXldID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBwcmlvcml0eSA9IChydWxlLnByaW9yaXR5ICE9PSB1bmRlZmluZWQpID8gcGFyc2VGbG9hdChydWxlLnByaW9yaXR5KSA6IC0xID4+PiAwO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMudGV4dHNbdGlsZS5rZXldW3N0eWxlX2tleV1bdGV4dF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRzW3RpbGUua2V5XVtzdHlsZV9rZXldW3RleHRdID0ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0X3N0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LFxuICAgICAgICAgICAgICAgICAgICByZWY6IDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVzID0gdGhpcy5mZWF0dXJlcyB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXNbdGlsZS5rZXldID0gdGhpcy5mZWF0dXJlc1t0aWxlLmtleV0gfHzCoHt9O1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlc1t0aWxlLmtleV1bc3R5bGVfa2V5XSA9IHRoaXMuZmVhdHVyZXNbdGlsZS5rZXldW3N0eWxlX2tleV0gfHwge307XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVzW3RpbGUua2V5XVtzdHlsZV9rZXldW3RleHRdID0gdGhpcy5mZWF0dXJlc1t0aWxlLmtleV1bc3R5bGVfa2V5XVt0ZXh0XSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXNbdGlsZS5rZXldW3N0eWxlX2tleV1bdGV4dF0ucHVzaChmZWF0dXJlKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnRpbGVfZGF0YVt0aWxlLmtleV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RGF0YSh0aWxlLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRpbGVfZGF0YVt0aWxlLmtleV0ucXVldWUucHVzaChbZmVhdHVyZSwgcnVsZSwgY29udGV4dF0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbnN0cnVjdEZvbnRTdHlsZSAocnVsZSwgY29udGV4dCkge1xuICAgICAgICBsZXQgc3R5bGU7XG5cbiAgICAgICAgaWYgKHJ1bGUuZm9udCkge1xuICAgICAgICAgICAgc3R5bGUgPSB7fTtcblxuICAgICAgICAgICAgLy8gVXNlIGZpbGwgaWYgc3BlY2lmaWVkLCBvciBkZWZhdWx0XG4gICAgICAgICAgICBzdHlsZS5maWxsID0gKHJ1bGUuZm9udC5maWxsICYmIFV0aWxzLnRvQ2FudmFzQ29sb3IoU3R5bGVQYXJzZXIucGFyc2VDb2xvcihydWxlLmZvbnQuZmlsbCwgY29udGV4dCkpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9udF9zdHlsZS5maWxsO1xuXG4gICAgICAgICAgICAvLyBVc2Ugc3Ryb2tlIGlmIHNwZWNpZmllZFxuICAgICAgICAgICAgaWYgKHJ1bGUuZm9udC5zdHJva2UgJiYgcnVsZS5mb250LnN0cm9rZS5jb2xvcikge1xuICAgICAgICAgICAgICAgIHN0eWxlLnN0cm9rZSA9IFV0aWxzLnRvQ2FudmFzQ29sb3IoU3R5bGVQYXJzZXIucGFyc2VDb2xvcihydWxlLmZvbnQuc3Ryb2tlLmNvbG9yKSk7XG4gICAgICAgICAgICAgICAgc3R5bGUuc3Ryb2tlX3dpZHRoID0gcnVsZS5mb250LnN0cm9rZS53aWR0aCB8fCB0aGlzLmZvbnRfc3R5bGUuc3Ryb2tlLndpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgZGVmYXVsdCB0eXBlZmFjZVxuICAgICAgICAgICAgc3R5bGUuZm9udCA9IHJ1bGUuZm9udC50eXBlZmFjZSB8fMKgdGhpcy5mb250X3N0eWxlLnR5cGVmYWNlO1xuICAgICAgICAgICAgc3R5bGUuY2FwaXRhbGl6ZWQgPSBydWxlLmZvbnQuY2FwaXRhbGl6ZWQgfHwgdGhpcy5mb250X3N0eWxlLmNhcGl0YWxpemVkO1xuXG4gICAgICAgICAgICBsZXQgc2l6ZV9yZWdleCA9IC8oWzAtOV0qXFwuKT9bMC05XSsocHh8cHR8ZW18JSkvZztcbiAgICAgICAgICAgIGxldCBmdF9zaXplID0gc3R5bGUuZm9udC5tYXRjaChzaXplX3JlZ2V4KVswXTtcbiAgICAgICAgICAgIGxldCBzaXplX2tpbmQgPSBmdF9zaXplLnJlcGxhY2UoLyhbMC05XSpcXC4pP1swLTldKy9nLCAnJyk7XG5cbiAgICAgICAgICAgIHN0eWxlLnB4X2xvZ2ljYWxfc2l6ZSA9IFV0aWxzLnRvUGl4ZWxTaXplKGZ0X3NpemUucmVwbGFjZSgvKFthLXpdfCUpL2csICcnKSwgc2l6ZV9raW5kKTtcbiAgICAgICAgICAgIHN0eWxlLnB4X3NpemUgPSBzdHlsZS5weF9sb2dpY2FsX3NpemUgKiBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW87XG4gICAgICAgICAgICBzdHlsZS5zdHJva2Vfd2lkdGggKj0gVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvO1xuICAgICAgICAgICAgc3R5bGUuZm9udCA9IHN0eWxlLmZvbnQucmVwbGFjZShzaXplX3JlZ2V4LCBzdHlsZS5weF9zaXplICsgXCJweFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9LFxuXG4gICAgY29uc3RydWN0U3R5bGVLZXkgKHsgZm9udCwgZmlsbCwgc3Ryb2tlLCBzdHJva2Vfd2lkdGggfSkge1xuICAgICAgICByZXR1cm4gYCR7Zm9udH0vJHtmaWxsfS8ke3N0cm9rZX0vJHtzdHJva2Vfd2lkdGh9YDtcbiAgICB9LFxuXG4gICAgYnVpbGRMYWJlbCAobGFiZWwsIHNpemUsIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsIHRleGNvb3JkX3NjYWxlKSB7XG4gICAgICAgIGxldCBhbmdsZSA9IGxhYmVsLmFuZ2xlIHx8IDA7XG4gICAgICAgIEJ1aWxkZXJzLmJ1aWxkUXVhZHNGb3JQb2ludHMoXG4gICAgICAgICAgICBbIGxhYmVsLnBvc2l0aW9uIF0sXG4gICAgICAgICAgICBVdGlscy5zY2FsZUludDE2KHNpemVbMF0sIDI1NiksXG4gICAgICAgICAgICBVdGlscy5zY2FsZUludDE2KHNpemVbMV0sIDI1NiksXG4gICAgICAgICAgICBVdGlscy5zY2FsZUludDE2KFV0aWxzLnJhZFRvRGVnKGFuZ2xlKSwgMzYwKSxcbiAgICAgICAgICAgIFV0aWxzLnNjYWxlSW50MTYoMSwgMjU2KSxcbiAgICAgICAgICAgIHZlcnRleF9kYXRhLFxuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlLFxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfbGF5b3V0LmluZGV4LmFfc2hhcGUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGV4Y29vcmRfaW5kZXg6IHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX3RleGNvb3JkLFxuICAgICAgICAgICAgICAgIHRleGNvb3JkX3NjYWxlOiB0ZXhjb29yZF9zY2FsZSxcbiAgICAgICAgICAgICAgICB0ZXhjb29yZF9ub3JtYWxpemU6IDY1NTM1XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGJ1aWxkIChzdHlsZSwgdmVydGV4X2RhdGEpIHtcbiAgICAgICAgbGV0IHZlcnRleF90ZW1wbGF0ZSA9IHRoaXMubWFrZVZlcnRleFRlbXBsYXRlKHN0eWxlKTtcblxuICAgICAgICBmb3IgKGxldCBpIGluIHN0eWxlLmxhYmVscykge1xuICAgICAgICAgICAgbGV0IGxhYmVsID0gc3R5bGUubGFiZWxzW2ldO1xuXG4gICAgICAgICAgICBpZiAobGFiZWwuaXNDb21wb3NpdGUoKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogaW4gbGFiZWwubGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsID0gbGFiZWwubGFiZWxzW2pdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3VidGV4Y29vcmRfc2NhbGUgPSB0aGlzLnN1YnRleGNvb3JkX3NjYWxlW2wudGV4dF07XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gdGhpcy5zdWJ0ZXh0X3NpemVbbC50ZXh0XTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZExhYmVsKGwsIHNpemUsIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsIHN1YnRleGNvb3JkX3NjYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRMYWJlbChsYWJlbCwgbGFiZWwuc2l6ZS50ZXh0dXJlX3RleHRfc2l6ZSwgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSwgdGhpcy50ZXhjb29yZF9zY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYnVpbGRMaW5lcyAobGluZXMsIHN0eWxlLCB2ZXJ0ZXhfZGF0YSkge1xuICAgICAgICB0aGlzLmJ1aWxkKHN0eWxlLCB2ZXJ0ZXhfZGF0YSk7XG4gICAgfSxcblxuICAgIGJ1aWxkUG9pbnRzIChwb2ludHMsIHN0eWxlLCB2ZXJ0ZXhfZGF0YSkge1xuICAgICAgICB0aGlzLmJ1aWxkKHN0eWxlLCB2ZXJ0ZXhfZGF0YSk7XG4gICAgfSxcblxuICAgIGJ1aWxkUG9seWdvbnMgKHBvaW50cywgc3R5bGUsIHZlcnRleF9kYXRhKSB7XG4gICAgICAgIHRoaXMuYnVpbGQoc3R5bGUsIHZlcnRleF9kYXRhKTtcbiAgICB9LFxuXG4gICAgX3BhcnNlRmVhdHVyZSAoZmVhdHVyZSwgcnVsZV9zdHlsZSwgY29udGV4dCkge1xuICAgICAgICBsZXQgdGV4dCA9IGZlYXR1cmUudGV4dDtcblxuICAgICAgICBsZXQgc3R5bGUgPSB0aGlzLmZlYXR1cmVfc3R5bGU7XG4gICAgICAgIGxldCB0aWxlID0gY29udGV4dC50aWxlLmtleTtcbiAgICAgICAgbGV0IHN0eWxlX2tleSA9IHRoaXMuZmVhdHVyZV9zdHlsZV9rZXlbdGlsZV0uZ2V0KGZlYXR1cmUpO1xuICAgICAgICBsZXQgdGV4dF9pbmZvID0gdGhpcy50ZXh0c1t0aWxlXSAmJiB0aGlzLnRleHRzW3RpbGVdW3N0eWxlX2tleV0gJiYgdGhpcy50ZXh0c1t0aWxlXVtzdHlsZV9rZXldW3RleHRdO1xuXG4gICAgICAgIGlmICghdGV4dF9pbmZvIHx8ICF0aGlzLmZlYXR1cmVfbGFiZWxzW3RpbGVdLmhhcyhmZWF0dXJlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50ZXhjb29yZF9zY2FsZSA9IHRleHRfaW5mby50ZXhjb29yZHM7XG4gICAgICAgIHRoaXMuc3VidGV4Y29vcmRfc2NhbGUgPSB0ZXh0X2luZm8uc3VidGV4Y29vcmRzO1xuICAgICAgICB0aGlzLnN1YnRleHRfc2l6ZSA9IHRleHRfaW5mby5zdWJ0ZXh0X3NpemU7XG4gICAgICAgIHN0eWxlLnRleHQgPSB0ZXh0O1xuICAgICAgICBzdHlsZS5sYWJlbHMgPSB0aGlzLmZlYXR1cmVfbGFiZWxzW3RpbGVdLmdldChmZWF0dXJlKTtcblxuICAgICAgICAvLyBUT0RPOiBwb2ludCBzdHlsZSAocGFyZW50IGNsYXNzKSByZXF1aXJlcyBhIGNvbG9yLCBzZXR0aW5nIGl0IHRvIHdoaXRlIGZvciBub3csXG4gICAgICAgIC8vIGJ1dCBjb3VsZCBiZSBtYWRlIGNvbmRpdGlvbmFsIGluIHRoZSB2ZXJ0ZXggbGF5b3V0IHRvIHNhdmUgc3BhY2VcbiAgICAgICAgc3R5bGUuY29sb3IgPSBUZXh0U3R5bGUud2hpdGU7XG5cbiAgICAgICAgLy8gdGVsbCB0aGUgcG9pbnQgc3R5bGUgKGJhc2UgY2xhc3MpIHRoYXQgd2Ugd2FudCB0byByZW5kZXIgcG9seWdvbiBsYWJlbHMgYXQgdGhlIHBvbHlnb24ncyBjZW50cm9pZFxuICAgICAgICBzdHlsZS5jZW50cm9pZCA9IHRydWU7XG5cbiAgICAgICAgLy8gcG9pbnRzIGNhbiBiZSBwbGFjZWQgb2ZmIHRoZSBncm91bmRcbiAgICAgICAgc3R5bGUueiA9IChydWxlX3N0eWxlLnogJiYgU3R5bGVQYXJzZXIuY2FjaGVEaXN0YW5jZShydWxlX3N0eWxlLnosIGNvbnRleHQpKSB8fCBTdHlsZVBhcnNlci5kZWZhdWx0cy56O1xuXG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG5cbn0pO1xuXG5UZXh0U3R5bGUudGV4dHVyZV9pZCA9IDA7XG5UZXh0U3R5bGUud2hpdGUgPSBbMSwgMSwgMSwgMV07XG4iLCIvKmdsb2JhbCBUaWxlICovXG5pbXBvcnQgR2VvIGZyb20gJy4vZ2VvJztcbmltcG9ydCB7U3R5bGVQYXJzZXJ9IGZyb20gJy4vc3R5bGVzL3N0eWxlX3BhcnNlcic7XG5pbXBvcnQge1N0eWxlTWFuYWdlcn0gZnJvbSAnLi9zdHlsZXMvc3R5bGVfbWFuYWdlcic7XG5pbXBvcnQgV29ya2VyQnJva2VyIGZyb20gJy4vdXRpbHMvd29ya2VyX2Jyb2tlcic7XG5pbXBvcnQgVGV4dHVyZSBmcm9tICcuL2dsL3RleHR1cmUnO1xuXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlsZSB7XG5cbiAgICAvKipcbiAgICAgICAgVGlsZVxuICAgICAgICBAY29uc3RydWN0b3JcbiAgICAgICAgUmVxdWlyZWQgcHJvcGVydGllczpcbiAgICAgICAgY29vcmRzOiBvYmplY3Qgd2l0aCB7eCwgeSwgen0gcHJvcGVydGllcyBpZGVudGlmeWluZyB0aWxlIGNvb3JkaW5hdGUgbG9jYXRpb25cbiAgICAgICAgd29ya2VyOiB3ZWIgd29ya2VyIHRvIGhhbmRsZSB0aWxlIGNvbnN0cnVjdGlvblxuICAgICovXG4gICAgY29uc3RydWN0b3IoeyBjb29yZHMsIHNvdXJjZSwgd29ya2VyLCBzdHlsZV96b29tIH0pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7XG4gICAgICAgICAgICBjb29yZHM6IHtcbiAgICAgICAgICAgICAgICB4OiBudWxsLFxuICAgICAgICAgICAgICAgIHk6IG51bGwsXG4gICAgICAgICAgICAgICAgejogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlYnVnOiB7fSxcbiAgICAgICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgbG9hZGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgd29ya2VyOiBudWxsLFxuICAgICAgICAgICAgZ2VuZXJhdGlvbjogbnVsbCxcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgY2VudGVyX2Rpc3Q6IDBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy53b3JrZXIgPSB3b3JrZXI7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnN0eWxlX3pvb20gPSBzdHlsZV96b29tOyAvLyB6b29tIGxldmVsIHRvIGJlIHVzZWQgZm9yIHN0eWxpbmdcblxuICAgICAgICB0aGlzLmNvb3JkcyA9IGNvb3JkcztcbiAgICAgICAgdGhpcy5jb29yZHMgPSBUaWxlLm92ZXJab29tZWRDb29yZGluYXRlKHRoaXMuY29vcmRzLCB0aGlzLnNvdXJjZS5tYXhfem9vbSk7XG4gICAgICAgIHRoaXMuY29vcmRfa2V5ID0gVGlsZS5jb29yZEtleSh0aGlzLmNvb3Jkcyk7XG4gICAgICAgIHRoaXMua2V5ID0gVGlsZS5rZXkodGhpcy5jb29yZHMsIHRoaXMuc291cmNlLCB0aGlzLnN0eWxlX3pvb20pO1xuICAgICAgICB0aGlzLm1pbiA9IEdlby5tZXRlcnNGb3JUaWxlKHRoaXMuY29vcmRzKTtcbiAgICAgICAgdGhpcy5tYXggPSBHZW8ubWV0ZXJzRm9yVGlsZSh7eDogdGhpcy5jb29yZHMueCArIDEsIHk6IHRoaXMuY29vcmRzLnkgKyAxLCB6OiB0aGlzLmNvb3Jkcy56IH0pLFxuICAgICAgICB0aGlzLnNwYW4gPSB7IHg6ICh0aGlzLm1heC54IC0gdGhpcy5taW4ueCksIHk6ICh0aGlzLm1heC55IC0gdGhpcy5taW4ueSkgfTtcbiAgICAgICAgdGhpcy5ib3VuZHMgPSB7IHN3OiB7IHg6IHRoaXMubWluLngsIHk6IHRoaXMubWF4LnkgfSwgbmU6IHsgeDogdGhpcy5tYXgueCwgeTogdGhpcy5taW4ueSB9IH07XG5cbiAgICAgICAgdGhpcy5tZXNoZXMgPSB7fTsgLy8gcmVuZGVyYWJsZSBWQk8gbWVzaGVzIGtleWVkIGJ5IHN0eWxlXG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSBbXTsgLy8gdGV4dHVyZXMgdGhhdCB0aGUgdGlsZSBvd25zIChsYWJlbHMsIGV0Yy4pXG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGlsZShzcGVjKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY29vcmRLZXkoe3gsIHksIHp9KSB7XG4gICAgICAgIHJldHVybiBbeCwgeSwgel0uam9pbignLycpO1xuICAgIH1cblxuICAgIHN0YXRpYyBrZXkgKGNvb3Jkcywgc291cmNlLCBzdHlsZV96b29tKSB7XG4gICAgICAgIGNvb3JkcyA9IFRpbGUub3Zlclpvb21lZENvb3JkaW5hdGUoY29vcmRzLCBzb3VyY2UubWF4X3pvb20pO1xuICAgICAgICByZXR1cm4gW3NvdXJjZS5uYW1lLCBzdHlsZV96b29tLCBjb29yZHMueCwgY29vcmRzLnksIGNvb3Jkcy56XS5qb2luKCcvJyk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNvb3JkaW5hdGVBdFpvb20oe3gsIHksIHp9LCB6b29tKSB7XG4gICAgICAgIGlmICh6ICE9PSB6b29tKSB7XG4gICAgICAgICAgICBsZXQgenNjYWxlID0gTWF0aC5wb3coMiwgeiAtIHpvb20pO1xuICAgICAgICAgICAgeCA9IE1hdGguZmxvb3IoeCAvIHpzY2FsZSk7XG4gICAgICAgICAgICB5ID0gTWF0aC5mbG9vcih5IC8genNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge3gsIHksIHo6IHpvb219O1xuICAgIH1cblxuICAgIHN0YXRpYyBpc0NoaWxkKHBhcmVudCwgY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkLnogPiBwYXJlbnQueikge1xuICAgICAgICAgICAgbGV0IHt4LCB5fSA9IFRpbGUuY29vcmRpbmF0ZUF0Wm9vbShjaGlsZCwgcGFyZW50LnopO1xuICAgICAgICAgICAgcmV0dXJuIChwYXJlbnQueCA9PT0geCAmJiBwYXJlbnQueSA9PT0geSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN0YXRpYyBvdmVyWm9vbWVkQ29vcmRpbmF0ZSh7eCwgeSwgen0sIG1heF96b29tKSB7XG4gICAgICAgIGlmIChtYXhfem9vbSAhPT0gdW5kZWZpbmVkICYmIHogPiBtYXhfem9vbSkge1xuICAgICAgICAgICAgcmV0dXJuIFRpbGUuY29vcmRpbmF0ZUF0Wm9vbSh7eCwgeSwgen0sIG1heF96b29tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge3gsIHksIHp9O1xuICAgIH1cblxuICAgIC8vIFNvcnQgYSBzZXQgb2YgdGlsZSBpbnN0YW5jZXMgKHdoaWNoIGFscmVhZHkgaGF2ZSBhIGRpc3RhbmNlIGZyb20gY2VudGVyIHRpbGUgY29tcHV0ZWQpXG4gICAgc3RhdGljIHNvcnQodGlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRpbGVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGxldCBhZCA9IGEuY2VudGVyX2Rpc3Q7XG4gICAgICAgICAgICBsZXQgYmQgPSBiLmNlbnRlcl9kaXN0O1xuICAgICAgICAgICAgcmV0dXJuIChiZCA+IGFkID8gLTEgOiAoYmQgPT09IGFkID8gMCA6IDEpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnJlZVJlc291cmNlcygpIHtcbiAgICAgICAgaWYgKHRoaXMubWVzaGVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBtIGluIHRoaXMubWVzaGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNoZXNbbV0uZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50ZXh0dXJlcykge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0dXJlID0gVGV4dHVyZS50ZXh0dXJlc1t0XTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1lc2hlcyA9IHt9O1xuICAgICAgICB0aGlzLnRleHR1cmVzID0gW107XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy53b3JrZXJNZXNzYWdlKCdyZW1vdmVUaWxlJywgdGhpcy5rZXkpO1xuICAgICAgICB0aGlzLmZyZWVSZXNvdXJjZXMoKTtcbiAgICAgICAgdGhpcy53b3JrZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGJ1aWxkQXNNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgIGNvb3JkX2tleTogdGhpcy5jb29yZF9rZXksXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLm5hbWUsXG4gICAgICAgICAgICBjb29yZHM6IHRoaXMuY29vcmRzLFxuICAgICAgICAgICAgbWluOiB0aGlzLm1pbixcbiAgICAgICAgICAgIG1heDogdGhpcy5tYXgsXG4gICAgICAgICAgICBzdHlsZV96b29tOiB0aGlzLnN0eWxlX3pvb20sXG4gICAgICAgICAgICBnZW5lcmF0aW9uOiB0aGlzLmdlbmVyYXRpb24sXG4gICAgICAgICAgICBkZWJ1ZzogdGhpcy5kZWJ1Z1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHdvcmtlck1lc3NhZ2UgKC4uLm1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSh0aGlzLndvcmtlciwgLi4ubWVzc2FnZSk7XG4gICAgfVxuXG4gICAgYnVpbGQoZ2VuZXJhdGlvbikge1xuICAgICAgICB0aGlzLmdlbmVyYXRpb24gPSBnZW5lcmF0aW9uO1xuICAgICAgICBpZiAoIXRoaXMubG9hZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndvcmtlck1lc3NhZ2UoJ2J1aWxkVGlsZScsIHsgdGlsZTogdGhpcy5idWlsZEFzTWVzc2FnZSgpIH0pLmNhdGNoKGUgPT4geyB0aHJvdyBlOyB9KTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGdlb21ldHJ5IGZvciB0aWxlIC0gY2FsbGVkIGJ5IHdlYiB3b3JrZXJcbiAgICAvLyBSZXR1cm5zIGEgc2V0IG9mIHRpbGUga2V5cyB0aGF0IHNob3VsZCBiZSBzZW50IHRvIHRoZSBtYWluIHRocmVhZCAoc28gdGhhdCB3ZSBjYW4gbWluaW1pemUgZGF0YSBleGNoYW5nZSBiZXR3ZWVuIHdvcmtlciBhbmQgbWFpbiB0aHJlYWQpXG4gICAgc3RhdGljIGJ1aWxkR2VvbWV0cnkgKHRpbGUsIGxheWVycywgcnVsZXMsIHN0eWxlcykge1xuICAgICAgICB0aWxlLmRlYnVnLnJlbmRlcmluZyA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICB0aWxlLmRlYnVnLmZlYXR1cmVzID0gMDtcblxuICAgICAgICBsZXQgZGF0YSA9IHRpbGUuc291cmNlX2RhdGE7XG5cbiAgICAgICAgLy8gVHJlYXQgdG9wLWxldmVsIHN0eWxlIHJ1bGVzIGFzICdsYXllcnMnXG4gICAgICAgIGZvciAobGV0IGxheWVyX25hbWUgaW4gbGF5ZXJzKSB7XG4gICAgICAgICAgICBsZXQgbGF5ZXIgPSBsYXllcnNbbGF5ZXJfbmFtZV07XG4gICAgICAgICAgICAvLyBTa2lwIGxheWVycyB3aXRoIG5vIGRhdGEgc291cmNlIGRlZmluZWRcbiAgICAgICAgICAgIGlmICghbGF5ZXIuZGF0YSkge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuKGBMYXllciAke2xheWVyfSB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2VvbWV0cnkgZGF0YSBzb3VyY2UgYW5kIHdpbGwgbm90IGJlIHJlbmRlcmVkLmApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTb3VyY2UgbmFtZXMgZG9uJ3QgbWF0Y2hcbiAgICAgICAgICAgIGlmIChsYXllci5kYXRhLnNvdXJjZSAhPT0gdGlsZS5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGdlb20gPSBUaWxlLmdldERhdGFGb3JTb3VyY2UoZGF0YSwgbGF5ZXIuZGF0YSwgbGF5ZXJfbmFtZSk7XG4gICAgICAgICAgICBpZiAoIWdlb20pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVuZGVyIGZlYXR1cmVzIGluIGxheWVyXG4gICAgICAgICAgICBsZXQgbnVtX2ZlYXR1cmVzID0gZ2VvbS5mZWF0dXJlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBmID0gbnVtX2ZlYXR1cmVzLTE7IGYgPj0gMDsgZi0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZlYXR1cmUgPSBnZW9tLmZlYXR1cmVzW2ZdO1xuICAgICAgICAgICAgICAgIGxldCBjb250ZXh0ID0gU3R5bGVQYXJzZXIuZ2V0RmVhdHVyZVBhcnNlQ29udGV4dChmZWF0dXJlLCB0aWxlKTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBkcmF3IGdyb3VwcyBmb3IgdGhpcyBmZWF0dXJlXG4gICAgICAgICAgICAgICAgbGV0IGxheWVyX3J1bGVzID0gcnVsZXNbbGF5ZXJfbmFtZV07XG4gICAgICAgICAgICAgICAgbGV0IGRyYXdfZ3JvdXBzID0gbGF5ZXJfcnVsZXMuYnVpbGREcmF3R3JvdXBzKGNvbnRleHQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghZHJhd19ncm91cHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmVuZGVyIGRyYXcgZ3JvdXBzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXBfbmFtZSBpbiBkcmF3X2dyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZ3JvdXAgPSBkcmF3X2dyb3Vwc1tncm91cF9uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFncm91cC52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0byBzdHlsZVxuICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGVfbmFtZSA9IGdyb3VwLnN0eWxlIHx8IGdyb3VwX25hbWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdHlsZSA9IHN0eWxlc1tzdHlsZV9uYW1lXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cud2FybihgU3R5bGUgJyR7c3R5bGVfbmFtZX0nIG5vdCBmb3VuZCBmb3IgcnVsZSBpbiBsYXllciAnJHtsYXllcl9uYW1lfSc6YCwgZ3JvdXAsIGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnByb3BlcnRpZXMgPSBncm91cC5wcm9wZXJ0aWVzOyAvLyBhZGQgcnVsZS1zcGVjaWZpYyBwcm9wZXJ0aWVzIHRvIGNvbnRleHRcblxuICAgICAgICAgICAgICAgICAgICBzdHlsZS5hZGRGZWF0dXJlKGZlYXR1cmUsIGdyb3VwLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnByb3BlcnRpZXMgPSBudWxsOyAvLyBjbGVhciBncm91cC1zcGVjaWZpYyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGlsZS5kZWJ1Zy5mZWF0dXJlcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRpbGUuZGVidWcucmVuZGVyaW5nID0gK25ldyBEYXRlKCkgLSB0aWxlLmRlYnVnLnJlbmRlcmluZztcblxuICAgICAgICAvLyBGaW5hbGl6ZSBhcnJheSBidWZmZXIgZm9yIGVhY2ggcmVuZGVyIHN0eWxlXG4gICAgICAgIGxldCB0aWxlX3N0eWxlcyA9IFN0eWxlTWFuYWdlci5zdHlsZXNGb3JUaWxlKHRpbGUua2V5KTtcbiAgICAgICAgdGlsZS5tZXNoX2RhdGEgPSB7fTtcbiAgICAgICAgbGV0IHF1ZXVlID0gW107XG4gICAgICAgIGZvciAobGV0IHN0eWxlX25hbWUgb2YgdGlsZV9zdHlsZXMpIHtcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IHN0eWxlc1tzdHlsZV9uYW1lXTtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goc3R5bGUuZW5kRGF0YSh0aWxlLmtleSkudGhlbigoc3R5bGVfZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZV9kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbGUubWVzaF9kYXRhW3N0eWxlX25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4X2RhdGE6IHN0eWxlX2RhdGEudmVydGV4X2RhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3Jtczogc3R5bGVfZGF0YS51bmlmb3JtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVzOiBzdHlsZV9kYXRhLnRleHR1cmVzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHF1ZXVlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFJldHVybiBrZXlzIHRvIGJlIHRyYW5zZmVyZWQgdG8gbWFpbiB0aHJlYWRcbiAgICAgICAgICAgIHJldHVybiBbJ21lc2hfZGF0YSddO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAgUmV0cmlldmVzIGdlb21ldHJ5IGZyb20gYSB0aWxlIGFjY29yZGluZyB0byBhIGRhdGEgc291cmNlIGRlZmluaXRpb25cbiAgICAqL1xuICAgIHN0YXRpYyBnZXREYXRhRm9yU291cmNlIChzb3VyY2VfZGF0YSwgc291cmNlX2NvbmZpZywgZGVmYXVsdF9sYXllciA9IG51bGwpIHtcbiAgICAgICAgdmFyIGdlb207XG5cbiAgICAgICAgaWYgKHNvdXJjZV9jb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgbm8gbGF5ZXIgc3BlY2lmaWVkLCBhbmQgYSBkZWZhdWx0IHNvdXJjZSBsYXllciBleGlzdHNcbiAgICAgICAgICAgIGlmICghc291cmNlX2NvbmZpZy5sYXllciAmJiBzb3VyY2VfZGF0YS5sYXllcnMuX2RlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBnZW9tID0gc291cmNlX2RhdGEubGF5ZXJzLl9kZWZhdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgbm8gbGF5ZXIgc3BlY2lmaWVkLCBhbmQgYSBkZWZhdWx0IHJlcXVlc3RlZCBsYXllciBleGlzdHNcbiAgICAgICAgICAgIGVsc2UgaWYgKCFzb3VyY2VfY29uZmlnLmxheWVyICYmIGRlZmF1bHRfbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBnZW9tID0gc291cmNlX2RhdGEubGF5ZXJzW2RlZmF1bHRfbGF5ZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYSBsYXllciBpcyBzcGVjaWZpZWQgYnkgbmFtZSwgdXNlIGl0XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc291cmNlX2NvbmZpZy5sYXllciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBnZW9tID0gc291cmNlX2RhdGEubGF5ZXJzW3NvdXJjZV9jb25maWcubGF5ZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgbXVsdGlwbGUgbGF5ZXJzIGFyZSBzcGVjaWZpZWQgYnkgbmFtZSwgY29tYmluZSB0aGVtXG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZV9jb25maWcubGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgZ2VvbSA9IHsgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJywgZmVhdHVyZXM6IFtdIH07XG4gICAgICAgICAgICAgICAgc291cmNlX2NvbmZpZy5sYXllci5mb3JFYWNoKGxheWVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZV9kYXRhLmxheWVyc1tsYXllcl0gJiYgc291cmNlX2RhdGEubGF5ZXJzW2xheWVyXS5mZWF0dXJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbS5mZWF0dXJlcy5wdXNoKC4uLnNvdXJjZV9kYXRhLmxheWVyc1tsYXllcl0uZmVhdHVyZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBc3NlbWJsZSBhIGN1c3RvbSBsYXllciB2aWEgYSBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkIHdpdGggYWxsIHNvdXJjZSBsYXllcnNcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2VfY29uZmlnLmxheWVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZ2VvbSA9IHNvdXJjZV9jb25maWcubGF5ZXIoc291cmNlX2RhdGEubGF5ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZW9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgIENhbGxlZCBvbiBtYWluIHRocmVhZCB3aGVuIGEgd2ViIHdvcmtlciBjb21wbGV0ZXMgcHJvY2Vzc2luZ1xuICAgICAgIGZvciBhIHNpbmdsZSB0aWxlLlxuICAgICovXG4gICAgYnVpbGRNZXNoZXMoc3R5bGVzKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGVhbnVwIGV4aXN0aW5nIFZCT3NcbiAgICAgICAgdGhpcy5mcmVlUmVzb3VyY2VzKCk7XG5cbiAgICAgICAgLy8gRGVidWdcbiAgICAgICAgdGhpcy5kZWJ1Zy5nZW9tZXRyaWVzID0gMDtcbiAgICAgICAgdGhpcy5kZWJ1Zy5idWZmZXJfc2l6ZSA9IDA7XG5cbiAgICAgICAgLy8gQ3JlYXRlIFZCT3NcbiAgICAgICAgbGV0IG1lc2hfZGF0YSA9IHRoaXMubWVzaF9kYXRhO1xuICAgICAgICBpZiAobWVzaF9kYXRhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBzIGluIG1lc2hfZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChtZXNoX2RhdGFbc10udmVydGV4X2RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Zy5idWZmZXJfc2l6ZSArPSBtZXNoX2RhdGFbc10udmVydGV4X2RhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdHlsZXNbc10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKGBDb3VsZCBub3QgY3JlYXRlIG1lc2ggYmVjYXVzZSBzdHlsZSAnJHtzfScgbm90IGZvdW5kLCBmb3IgdGlsZSAke3RoaXMua2V5fSwgYWJvcnRpbmcgdGlsZWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNoZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzaGVzW3NdID0gc3R5bGVzW3NdLm1ha2VNZXNoKG1lc2hfZGF0YVtzXS52ZXJ0ZXhfZGF0YSwgbWVzaF9kYXRhW3NdKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Zy5nZW9tZXRyaWVzICs9IHRoaXMubWVzaGVzW3NdLmdlb21ldHJ5X2NvdW50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFzc2lnbiBvd25lcnNoaXAgdG8gdGV4dHVyZXMgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKG1lc2hfZGF0YVtzXS50ZXh0dXJlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmVzLnB1c2goLi4ubWVzaF9kYXRhW3NdLnRleHR1cmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRlYnVnLmdlb21fcmF0aW8gPSAodGhpcy5kZWJ1Zy5nZW9tZXRyaWVzIC8gdGhpcy5kZWJ1Zy5mZWF0dXJlcykudG9GaXhlZCgxKTtcbiAgICAgICAgdGhpcy5tZXNoX2RhdGEgPSBudWxsOyAvLyBUT0RPOiBtaWdodCB3YW50IHRvIHByZXNlcnZlIHRoaXMgZm9yIHJlYnVpbGRpbmcgZ2VvbWV0cmllcyB3aGVuIHN0eWxlcy9ldGMuIGNoYW5nZT9cbiAgICAgICAgdGhpcy5wcmludERlYnVnKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgIENhbGxlZCBvbiBtYWluIHRocmVhZCB3aGVuIHdlYiB3b3JrZXIgY29tcGxldGVzIHByb2Nlc3NpbmcsIGJ1dCB0aWxlIGhhcyBzaW5jZSBiZWVuIGRpc2NhcmRlZFxuICAgICAgICBGcmVlcyByZXNvdXJjZXMgdGhhdCB3b3VsZCBoYXZlIGJlZW4gdHJhbnNmZXJyZWQgdG8gdGhlIHRpbGUgb2JqZWN0LlxuICAgICAgICBTdGF0aWMgbWV0aG9kIGJlY2F1c2UgdGhlIHRpbGUgb2JqZWN0IG5vIGxvbmdlciBleGlzdHMgKHRoZSB0aWxlIGRhdGEgcmV0dXJuZWQgYnkgdGhlIHdvcmtlciBpcyBwYXNzZWQgaW5zdGVhZCkuXG4gICAgKi9cbiAgICBzdGF0aWMgYWJvcnRCdWlsZCAodGlsZSkge1xuICAgICAgICBpZiAodGlsZS5tZXNoX2RhdGEpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHMgaW4gdGlsZS5tZXNoX2RhdGEpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dHVyZXMgPSB0aWxlLm1lc2hfZGF0YVtzXS50ZXh0dXJlcztcbiAgICAgICAgICAgICAgICBpZiAodGV4dHVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0ZXh0dXJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRleHR1cmUgPSBUZXh0dXJlLnRleHR1cmVzW3RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cudHJhY2UoYGRlc3Ryb3lpbmcgdGV4dHVyZSAke3R9IGZvciB0aWxlICR7dGlsZS5rZXl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcmludERlYnVnICgpIHtcbiAgICAgICAgbG9nLmRlYnVnKGBUaWxlOiBkZWJ1ZyBmb3IgJHt0aGlzLmtleX06IFsgICR7SlNPTi5zdHJpbmdpZnkodGhpcy5kZWJ1Zyl9IF1gKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoc2NlbmUpIHtcbiAgICAgICAgbGV0IGNvb3JkcyA9IHRoaXMuY29vcmRzO1xuICAgICAgICBpZiAoY29vcmRzLnogIT09IHNjZW5lLmNlbnRlcl90aWxlLnopIHtcbiAgICAgICAgICAgIGNvb3JkcyA9IFRpbGUuY29vcmRpbmF0ZUF0Wm9vbShjb29yZHMsIHNjZW5lLmNlbnRlcl90aWxlLnopO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2VudGVyX2Rpc3QgPSBNYXRoLmFicyhzY2VuZS5jZW50ZXJfdGlsZS54IC0gY29vcmRzLngpICsgTWF0aC5hYnMoc2NlbmUuY2VudGVyX3RpbGUueSAtIGNvb3Jkcy55KTtcbiAgICB9XG5cbiAgICAvLyBTbGljZSBhIHN1YnNldCBvZiBrZXlzIG91dCBvZiBhIHRpbGVcbiAgICAvLyBJbmNsdWRlcyBhIG1pbmltdW0gc2V0IG9mIHByZS1kZWZpbmVkIGtleXMgZm9yIGxvYWQgc3RhdGUsIGRlYnVnLiBldGMuXG4gICAgLy8gV2UgdXNlIHRoaXMgdG8gc2VuZCBhIHN1YnNldCBvZiB0aGUgdGlsZSBiYWNrIHRvIHRoZSBtYWluIHRocmVhZCwgdG8gbWluaW1pemUgdW5uZWNlc3NhcnkgZGF0YSB0cmFuc2ZlclxuICAgIC8vIChlLmcuIHZlcnkgbGFyZ2UgaXRlbXMgbGlrZSBmZWF0dXJlIGdlb21ldHJ5IGFyZSBub3QgbmVlZGVkIG9uIHRoZSBtYWluIHRocmVhZClcbiAgICBzdGF0aWMgc2xpY2UgKHRpbGUsIGtleXMpIHtcbiAgICAgICAgbGV0IGtlZXAgPSBbXG4gICAgICAgICAgICAna2V5JyxcbiAgICAgICAgICAgICdsb2FkaW5nJyxcbiAgICAgICAgICAgICdsb2FkZWQnLFxuICAgICAgICAgICAgJ2dlbmVyYXRpb24nLFxuICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICdkZWJ1ZydcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgICAgIGtlZXAucHVzaCguLi5rZXlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ1aWxkIHRoZSB0aWxlIHN1YnNldFxuICAgICAgICB2YXIgdGlsZV9zdWJzZXQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIGtlZXApIHtcbiAgICAgICAgICAgIHRpbGVfc3Vic2V0W2tleV0gPSB0aWxlW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGlsZV9zdWJzZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgIENhbGxlZCBvbiB3b3JrZXIgdG8gY2FuY2VsIGxvYWRpbmdcbiAgICAgICAgU3RhdGljIG1ldGhvZCBiZWNhdXNlIHRoZSB3b3JrZXIgb25seSBoYXMgb2JqZWN0IHJlcHJlc2VudGF0aW9ucyBvZiB0aWxlIGRhdGEsIHRoZXJlIGlzIG5vXG4gICAgICAgIHRpbGUgaW5zdGFuY2UgY3JlYXRlZCB5ZXQuXG4gICAgKi9cbiAgICBzdGF0aWMgY2FuY2VsKHRpbGUpIHtcbiAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICAgIGlmICh0aWxlLnNvdXJjZV9kYXRhICYmIHRpbGUuc291cmNlX2RhdGEucmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHRpbGUuc291cmNlX2RhdGEucmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVGlsZS5hYm9ydEJ1aWxkKHRpbGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG90aGVyKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAna2V5Jykge1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IG90aGVyW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgVGlsZSBmcm9tICcuL3RpbGUnO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMvdXRpbHMnO1xuXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcblxudmFyIFRpbGVNYW5hZ2VyO1xuXG5leHBvcnQgZGVmYXVsdCBUaWxlTWFuYWdlciA9IHtcblxuICAgIGluaXQoc2NlbmUpIHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgICB0aGlzLnRpbGVzID0ge307XG4gICAgICAgIHRoaXMudmlzaWJsZV9jb29yZHMgPSB7fTtcbiAgICAgICAgdGhpcy5xdWV1ZWRfY29vcmRzID0gW107XG4gICAgICAgIHRoaXMuYnVpbGRpbmdfdGlsZXMgPSBudWxsO1xuICAgIH0sXG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmZvckVhY2hUaWxlKHRpbGUgPT4gdGlsZS5kZXN0cm95KCkpO1xuICAgICAgICB0aGlzLnRpbGVzID0ge307XG4gICAgICAgIHRoaXMudmlzaWJsZV9jb29yZHMgPSB7fTtcbiAgICAgICAgdGhpcy5xdWV1ZWRfY29vcmRzID0gW107XG4gICAgICAgIHRoaXMuc2NlbmUgPSBudWxsO1xuICAgIH0sXG5cbiAgICBrZWVwVGlsZSh0aWxlKSB7XG4gICAgICAgIHRoaXMudGlsZXNbdGlsZS5rZXldID0gdGlsZTtcbiAgICB9LFxuXG4gICAgaGFzVGlsZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZXNba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICBmb3JnZXRUaWxlKGtleSkge1xuICAgICAgICBkZWxldGUgdGhpcy50aWxlc1trZXldO1xuICAgICAgICB0aGlzLnRpbGVCdWlsZFN0b3Aoa2V5KTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgc2luZ2xlIHRpbGVcbiAgICByZW1vdmVUaWxlKGtleSkge1xuICAgICAgICBsb2cudHJhY2UoYHRpbGUgdW5sb2FkIGZvciAke2tleX1gKTtcblxuICAgICAgICB2YXIgdGlsZSA9IHRoaXMudGlsZXNba2V5XTtcblxuICAgICAgICBpZiAodGlsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aWxlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZm9yZ2V0VGlsZSh0aWxlLmtleSk7XG4gICAgICAgIHRoaXMuc2NlbmUucmVxdWVzdFJlZHJhdygpO1xuICAgIH0sXG5cbiAgICAvLyBSdW4gYSBmdW5jdGlvbiBvbiBlYWNoIHRpbGVcbiAgICBmb3JFYWNoVGlsZShmdW5jKSB7XG4gICAgICAgIGZvciAobGV0IHQgaW4gdGhpcy50aWxlcykge1xuICAgICAgICAgICAgZnVuYyh0aGlzLnRpbGVzW3RdKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgdGlsZXMgdGhhdCBwYXNzIGEgZmlsdGVyIGNvbmRpdGlvblxuICAgIHJlbW92ZVRpbGVzKGZpbHRlcikge1xuICAgICAgICBsZXQgcmVtb3ZlX3RpbGVzID0gW107XG4gICAgICAgIGZvciAobGV0IHQgaW4gdGhpcy50aWxlcykge1xuICAgICAgICAgICAgbGV0IHRpbGUgPSB0aGlzLnRpbGVzW3RdO1xuICAgICAgICAgICAgaWYgKGZpbHRlcih0aWxlKSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZV90aWxlcy5wdXNoKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHI9MDsgciA8IHJlbW92ZV90aWxlcy5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgbGV0IGtleSA9IHJlbW92ZV90aWxlc1tyXTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVGlsZShrZXkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZVRpbGVzRm9yVmlldygpIHtcbiAgICAgICAgLy8gRmluZCB2aXNpYmxlIHRpbGVzIGFuZCBsb2FkIG5ldyBvbmVzXG4gICAgICAgIHRoaXMudmlzaWJsZV9jb29yZHMgPSB7fTtcbiAgICAgICAgbGV0IHRpbGVfY29vcmRzID0gdGhpcy5zY2VuZS5maW5kVmlzaWJsZVRpbGVDb29yZGluYXRlcygpO1xuICAgICAgICBmb3IgKGxldCBjb29yZHMgb2YgdGlsZV9jb29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMucXVldWVDb29yZGluYXRlKGNvb3Jkcyk7XG4gICAgICAgICAgICB0aGlzLnZpc2libGVfY29vcmRzW1RpbGUuY29vcmRLZXkoY29vcmRzKV0gPSBjb29yZHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgdGlsZXMgdG9vIGZhciBvdXRzaWRlIG9mIHZpZXdcbiAgICAgICAgdGhpcy5zY2VuZS5wcnVuZVRpbGVDb29yZGluYXRlc0ZvclZpZXcoKTsgLy8gVE9ETzogcmV0dXJuIGxpc3QgdG8gcHJ1bmU/XG5cbiAgICAgICAgdGhpcy5mb3JFYWNoVGlsZSh0aWxlID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSh0aWxlKTtcbiAgICAgICAgICAgIHRpbGUudXBkYXRlKHRoaXMuc2NlbmUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgdXBkYXRlVmlzaWJpbGl0eSh0aWxlKSB7XG4gICAgICAgIGlmICh0aWxlLnN0eWxlX3pvb20gIT09IHRoaXMuc2NlbmUudGlsZV96b29tKSB7XG4gICAgICAgICAgICB0aWxlLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnZpc2libGVfY29vcmRzW3RpbGUuY29vcmRfa2V5XSkge1xuICAgICAgICAgICAgdGlsZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJydXRlIGZvcmNlXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy52aXNpYmxlX2Nvb3Jkcykge1xuICAgICAgICAgICAgICAgIGlmIChUaWxlLmlzQ2hpbGQodGlsZS5jb29yZHMsIHRoaXMudmlzaWJsZV9jb29yZHNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGlsZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGlsZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0UmVuZGVyYWJsZVRpbGVzKCkge1xuICAgICAgICBsZXQgdGlsZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgdCBpbiB0aGlzLnRpbGVzKSB7XG4gICAgICAgICAgICBsZXQgdGlsZSA9IHRoaXMudGlsZXNbdF07XG4gICAgICAgICAgICBpZiAodGlsZS52aXNpYmxlICYmIHRpbGUubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgdGlsZXMucHVzaCh0aWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGlsZXM7XG4gICAgfSxcblxuICAgIC8vIFF1ZXVlIGEgdGlsZSBmb3IgbG9hZFxuICAgIHF1ZXVlQ29vcmRpbmF0ZShjb29yZHMpIHtcbiAgICAgICAgdGhpcy5xdWV1ZWRfY29vcmRzW3RoaXMucXVldWVkX2Nvb3Jkcy5sZW5ndGhdID0gY29vcmRzO1xuICAgIH0sXG5cbiAgICAvLyBMb2FkIGFsbCBxdWV1ZWQgdGlsZXNcbiAgICBsb2FkUXVldWVkQ29vcmRpbmF0ZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnF1ZXVlZF9jb29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb3J0IHF1ZXVlZCB0aWxlcyBmcm9tIGNlbnRlciB0aWxlXG4gICAgICAgIHRoaXMucXVldWVkX2Nvb3Jkcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBsZXQgYWQgPSBNYXRoLmFicyh0aGlzLnNjZW5lLmNlbnRlcl90aWxlLnggLSBhLngpICsgTWF0aC5hYnModGhpcy5zY2VuZS5jZW50ZXJfdGlsZS55IC0gYS55KTtcbiAgICAgICAgICAgIGxldCBiZCA9IE1hdGguYWJzKHRoaXMuc2NlbmUuY2VudGVyX3RpbGUueCAtIGIueCkgKyBNYXRoLmFicyh0aGlzLnNjZW5lLmNlbnRlcl90aWxlLnkgLSBiLnkpO1xuICAgICAgICAgICAgcmV0dXJuIChiZCA+IGFkID8gLTEgOiAoYmQgPT09IGFkID8gMCA6IDEpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVldWVkX2Nvb3Jkcy5mb3JFYWNoKGNvb3JkcyA9PiB0aGlzLmxvYWRDb29yZGluYXRlKGNvb3JkcykpO1xuICAgICAgICB0aGlzLnF1ZXVlZF9jb29yZHMgPSBbXTtcbiAgICB9LFxuXG4gICAgLy8gTG9hZCBhbGwgdGlsZXMgdG8gY292ZXIgYSBnaXZlbiBsb2dpY2FsIHRpbGUgY29vcmRpbmF0ZVxuICAgIGxvYWRDb29yZGluYXRlKGNvb3Jkcykge1xuICAgICAgICAvLyBTa2lwIGlmIG5vdCBhdCBjdXJyZW50IHNjZW5lIHpvb21cbiAgICAgICAgaWYgKGNvb3Jkcy56ICE9PSB0aGlzLnNjZW5lLmNlbnRlcl90aWxlLnopIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSBuZWNlc3NhcnkgdGlsZXMgZm9yIGVhY2ggc291cmNlXG4gICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiBVdGlscy52YWx1ZXModGhpcy5zY2VuZS5zb3VyY2VzKSkge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UudGlsZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGtleSA9IFRpbGUua2V5KGNvb3Jkcywgc291cmNlLCB0aGlzLnNjZW5lLnRpbGVfem9vbSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzVGlsZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRpbGUgPSBUaWxlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzLFxuICAgICAgICAgICAgICAgICAgICAvLyBtYXhfem9vbTogdGhpcy5zY2VuZS5maW5kTWF4Wm9vbSgpLCAvLyBUT0RPOiByZXBsYWNlIHdpdGggYmV0dGVyIG1heCB6b29tIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcjogdGhpcy5zY2VuZS5uZXh0V29ya2VyKCksXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlX3pvb206IHRoaXMuc2NlbmUuc3R5bGVab29tKGNvb3Jkcy56KSAvLyBUT0RPOiByZXBsYWNlP1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5rZWVwVGlsZSh0aWxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkVGlsZSh0aWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBTb3J0IGFuZCBidWlsZCBhIGxpc3Qgb2YgdGlsZXNcbiAgICBidWlsZFRpbGVzKHRpbGVzKSB7XG4gICAgICAgIFRpbGUuc29ydCh0aWxlcykuZm9yRWFjaCh0aWxlID0+IHRoaXMuYnVpbGRUaWxlKHRpbGUpKTtcbiAgICAgICAgdGhpcy5jaGVja0J1aWxkUXVldWUoKTtcbiAgICB9LFxuXG4gICAgYnVpbGRUaWxlKHRpbGUpIHtcbiAgICAgICAgdGhpcy50aWxlQnVpbGRTdGFydCh0aWxlLmtleSk7XG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSh0aWxlKTtcbiAgICAgICAgdGlsZS51cGRhdGUodGhpcy5zY2VuZSk7XG4gICAgICAgIHRpbGUuYnVpbGQodGhpcy5zY2VuZS5nZW5lcmF0aW9uKVxuICAgICAgICAgICAgLnRoZW4obWVzc2FnZSA9PiB0aGlzLmJ1aWxkVGlsZUNvbXBsZXRlZChtZXNzYWdlKSlcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JnZXRUaWxlKHRpbGUua2V5KTtcbiAgICAgICAgICAgICAgICBUaWxlLmFib3J0QnVpbGQodGlsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gQ2FsbGVkIG9uIG1haW4gdGhyZWFkIHdoZW4gYSB3ZWIgd29ya2VyIGNvbXBsZXRlcyBwcm9jZXNzaW5nIGZvciBhIHNpbmdsZSB0aWxlIChpbml0aWFsIGxvYWQsIG9yIHJlYnVpbGQpXG4gICAgYnVpbGRUaWxlQ29tcGxldGVkKHsgdGlsZSB9KSB7XG4gICAgICAgIC8vIFJlbW92ZWQgdGhpcyB0aWxlIGR1cmluZyBsb2FkP1xuICAgICAgICBpZiAodGhpcy50aWxlc1t0aWxlLmtleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nLnRyYWNlKGBkaXNjYXJkZWQgdGlsZSAke3RpbGUua2V5fSBpbiBUaWxlTWFuYWdlci5idWlsZFRpbGVDb21wbGV0ZWQgYmVjYXVzZSBwcmV2aW91c2x5IHJlbW92ZWRgKTtcbiAgICAgICAgICAgIFRpbGUuYWJvcnRCdWlsZCh0aWxlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsdCB3aXRoIGFuIG91dGRhdGVkIHNjZW5lIGNvbmZpZ3VyYXRpb24/XG4gICAgICAgIGVsc2UgaWYgKHRpbGUuZ2VuZXJhdGlvbiAhPT0gdGhpcy5zY2VuZS5nZW5lcmF0aW9uKSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoYGRpc2NhcmRlZCB0aWxlICR7dGlsZS5rZXl9IGluIFRpbGVNYW5hZ2VyLmJ1aWxkVGlsZUNvbXBsZXRlZCBiZWNhdXNlIGJ1aWx0IHdpdGggYCArXG4gICAgICAgICAgICAgICAgYHNjZW5lIGNvbmZpZyBnZW4gJHt0aWxlLmdlbmVyYXRpb259LCBjdXJyZW50ICR7dGhpcy5zY2VuZS5nZW5lcmF0aW9ufWApO1xuICAgICAgICAgICAgdGhpcy5mb3JnZXRUaWxlKHRpbGUua2V5KTtcbiAgICAgICAgICAgIFRpbGUuYWJvcnRCdWlsZCh0aWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aWxlIHdpdGggcHJvcGVydGllcyBmcm9tIHdvcmtlclxuICAgICAgICAgICAgaWYgKHRoaXMudGlsZXNbdGlsZS5rZXldKSB7XG4gICAgICAgICAgICAgICAgdGlsZSA9IHRoaXMudGlsZXNbdGlsZS5rZXldLm1lcmdlKHRpbGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkodGlsZSk7XG4gICAgICAgICAgICB0aWxlLnVwZGF0ZSh0aGlzLnNjZW5lKTtcbiAgICAgICAgICAgIHRpbGUuYnVpbGRNZXNoZXModGhpcy5zY2VuZS5zdHlsZXMpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5yZXF1ZXN0UmVkcmF3KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRpbGVCdWlsZFN0b3AodGlsZS5rZXkpO1xuICAgIH0sXG5cbiAgICAvLyBUcmFjayB0aWxlIGJ1aWxkIHN0YXRlXG4gICAgdGlsZUJ1aWxkU3RhcnQoa2V5KSB7XG4gICAgICAgIHRoaXMuYnVpbGRpbmdfdGlsZXMgPSB0aGlzLmJ1aWxkaW5nX3RpbGVzIHx8IHt9O1xuICAgICAgICB0aGlzLmJ1aWxkaW5nX3RpbGVzW2tleV0gPSB0cnVlO1xuICAgICAgICBsb2cudHJhY2UoYHRpbGVCdWlsZFN0YXJ0IGZvciAke2tleX06ICR7T2JqZWN0LmtleXModGhpcy5idWlsZGluZ190aWxlcykubGVuZ3RofWApO1xuICAgIH0sXG5cbiAgICB0aWxlQnVpbGRTdG9wKGtleSkge1xuICAgICAgICAvLyBEb25lIGJ1aWxkaW5nP1xuICAgICAgICBpZiAodGhpcy5idWlsZGluZ190aWxlcykge1xuICAgICAgICAgICAgbG9nLnRyYWNlKGB0aWxlQnVpbGRTdG9wIGZvciAke2tleX06ICR7T2JqZWN0LmtleXModGhpcy5idWlsZGluZ190aWxlcykubGVuZ3RofWApO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYnVpbGRpbmdfdGlsZXNba2V5XTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tCdWlsZFF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQ2hlY2sgc3RhdHVzIG9mIHRpbGUgYnVpbGRpbmcgcXVldWUgYW5kIG5vdGlmeSBzY2VuZSB3aGVuIHdlJ3JlIGRvbmVcbiAgICBjaGVja0J1aWxkUXVldWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWlsZGluZ190aWxlcyB8fCBPYmplY3Qua2V5cyh0aGlzLmJ1aWxkaW5nX3RpbGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRpbmdfdGlsZXMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zY2VuZS50aWxlTWFuYWdlckJ1aWxkRG9uZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIFN1bSBvZiBhIGRlYnVnIHByb3BlcnR5IGFjcm9zcyB0aWxlc1xuICAgIGdldERlYnVnU3VtKHByb3AsIGZpbHRlcikge1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLnRpbGVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50aWxlc1t0XS5kZWJ1Z1twcm9wXSAhPSBudWxsICYmICh0eXBlb2YgZmlsdGVyICE9PSAnZnVuY3Rpb24nIHx8IGZpbHRlcih0aGlzLnRpbGVzW3RdKSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gdGhpcy50aWxlc1t0XS5kZWJ1Z1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH0sXG5cbiAgICAvLyBBdmVyYWdlIG9mIGEgZGVidWcgcHJvcGVydHkgYWNyb3NzIHRpbGVzXG4gICAgZ2V0RGVidWdBdmVyYWdlKHByb3AsIGZpbHRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREZWJ1Z1N1bShwcm9wLCBmaWx0ZXIpIC8gT2JqZWN0LmtleXModGhpcy50aWxlcykubGVuZ3RoO1xuICAgIH1cblxufTtcbiIsIlxuXG5leHBvcnQgY2xhc3MgTWV0aG9kTm90SW1wbGVtZW50ZWQgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kTmFtZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgICAgPSAnTWV0aG9kTm90SW1wbGVtZW50ZWQnO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSAnTWV0aG9kICcgKyBtZXRob2ROYW1lICsgJyBtdXN0IGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzJztcbiAgICB9XG59XG4iLCJpbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9CQiB7XG5cbiAgICBjb25zdHJ1Y3RvciAoeCwgeSwgYSwgdywgaCkge1xuICAgICAgICB0aGlzLmRpbWVuc2lvbiA9IFt3LCBoXTtcbiAgICAgICAgdGhpcy5hbmdsZSA9IGE7XG4gICAgICAgIHRoaXMuY2VudHJvaWQgPSBbeCwgeV07XG4gICAgICAgIHRoaXMucXVhZCA9IFtdO1xuICAgICAgICB0aGlzLmF4ZXMgPSBbXTtcblxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIG1vdmUgKHB4LCBweSkge1xuICAgIFx0dGhpcy5jZW50cm9pZCA9IFtweCwgcHldO1xuXG4gICAgXHR0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGdldEV4dGVudCAoKSB7XG4gICAgXHRsZXQgaW5mID0gMWU2O1xuICAgIFx0bGV0IGFhYmIgPSBbaW5mLCBpbmYsIC1pbmYsIC1pbmZdO1xuXG4gICAgXHRmb3IgKGxldCBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgICAgYWFiYlswXSA9IE1hdGgubWluKHRoaXMucXVhZFtpXVswXSwgYWFiYlswXSk7XG4gICAgICAgICAgICBhYWJiWzFdID0gTWF0aC5taW4odGhpcy5xdWFkW2ldWzFdLCBhYWJiWzFdKTtcbiAgICAgICAgICAgIGFhYmJbMl0gPSBNYXRoLm1heCh0aGlzLnF1YWRbaV1bMF0sIGFhYmJbMl0pO1xuICAgICAgICAgICAgYWFiYlszXSA9IE1hdGgubWF4KHRoaXMucXVhZFtpXVsxXSwgYWFiYlszXSk7XG4gICAgXHR9XG5cbiAgICBcdHJldHVybiBhYWJiO1xuICAgIH1cblxuICAgIHBlcnBBeGVzICgpIHtcbiAgICBcdHRoaXMuYXhlc1swXSA9IFZlY3Rvci5ub3JtYWxpemUoVmVjdG9yLnN1Yih0aGlzLnF1YWRbMl0sIHRoaXMucXVhZFszXSkpO1xuICAgIFx0dGhpcy5heGVzWzFdID0gVmVjdG9yLm5vcm1hbGl6ZShWZWN0b3Iuc3ViKHRoaXMucXVhZFsyXSwgdGhpcy5xdWFkWzFdKSk7XG4gICAgfVxuXG4gICAgdXBkYXRlICgpIHtcbiAgICBcdGxldCB4ID0gWyBNYXRoLmNvcyh0aGlzLmFuZ2xlKSwgTWF0aC5zaW4odGhpcy5hbmdsZSldO1xuICAgIFx0bGV0IHkgPSBbLU1hdGguc2luKHRoaXMuYW5nbGUpLCBNYXRoLmNvcyh0aGlzLmFuZ2xlKV07XG5cbiAgICBcdHggPSBWZWN0b3IubXVsdCh4LCB0aGlzLmRpbWVuc2lvblswXSAvIDIuMCk7XG4gICAgXHR5ID0gVmVjdG9yLm11bHQoeSwgdGhpcy5kaW1lbnNpb25bMV0gLyAyLjApO1xuXG4gICAgXHR0aGlzLnF1YWRbMF0gPSBWZWN0b3Iuc3ViKFZlY3Rvci5zdWIodGhpcy5jZW50cm9pZCwgeCksIHkpOyAvLyBsb3dlci1sZWZ0XG4gICAgXHR0aGlzLnF1YWRbMV0gPSBWZWN0b3Iuc3ViKFZlY3Rvci5hZGQodGhpcy5jZW50cm9pZCwgeCksIHkpOyAvLyBsb3dlci1yaWdodFxuICAgIFx0dGhpcy5xdWFkWzJdID0gVmVjdG9yLmFkZChWZWN0b3IuYWRkKHRoaXMuY2VudHJvaWQsIHgpLCB5KTsgLy8gdXBlci1yaWdodFxuICAgIFx0dGhpcy5xdWFkWzNdID0gVmVjdG9yLmFkZChWZWN0b3Iuc3ViKHRoaXMuY2VudHJvaWQsIHgpLCB5KTsgLy8gdXBlci1sZWZ0XG5cbiAgICBcdHRoaXMucGVycEF4ZXMoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcHJvamVjdFRvQXhpcyAob2JiLCBheGlzKSB7XG4gICAgXHRsZXQgaW5mID0gMWU2O1xuICAgIFx0bGV0IG1pbiA9IGluZjtcbiAgICBcdGxldCBtYXggPSAtaW5mO1xuXG4gICAgXHRsZXQgcXVhZCA9IG9iYi5xdWFkO1xuXG4gICAgXHQvLyBmb3IgZWFjaCBheGlzLCBwcm9qZWN0IG9iYiBxdWFkIHRvIGl0IGFuZCBmaW5kIG1pbiBhbmQgbWF4IHZhbHVlc1xuICAgIFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgICAgIGxldCBkID0gIFZlY3Rvci5kb3QocXVhZFtpXSwgYXhpcyk7XG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGQpO1xuICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkKTtcbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIFttaW4sIG1heF07XG4gICAgfVxuXG4gICAgc3RhdGljIGF4aXNDb2xsaWRlIChvYmJfYSwgb2JiX2IsIGF4ZXMpIHtcbiAgICBcdGZvciAobGV0IGkgPSAwOyBpIDwgMjsgKytpKSB7XG4gICAgXHRcdGxldCBhX3Byb2ogPSBPQkIucHJvamVjdFRvQXhpcyhvYmJfYSwgYXhlc1tpXSk7XG4gICAgXHRcdGxldCBiX3Byb2ogPSBPQkIucHJvamVjdFRvQXhpcyhvYmJfYiwgYXhlc1tpXSk7XG5cbiAgICBcdFx0aWYgKGJfcHJvalswXSA+IGFfcHJvalsxXSB8fCBiX3Byb2pbMV0gPCBhX3Byb2pbMF0pIHtcbiAgICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gICAgXHRcdH1cbiAgICBcdH1cbiAgICBcdHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHN0YXRpYyBpbnRlcnNlY3Qob2JiX2EsIG9iYl9iKSB7XG4gICAgXHRyZXR1cm4gT0JCLmF4aXNDb2xsaWRlKG9iYl9hLCBvYmJfYiwgb2JiX2EuYXhlcykgJiYgT0JCLmF4aXNDb2xsaWRlKG9iYl9hLCBvYmJfYiwgb2JiX2IuYXhlcyk7XG4gICAgfVxuXG59XG5cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN1YnNjcmliZU1peGluICh0YXJnZXQpIHtcblxuICAgIHZhciBsaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgLy8gdmFyIGxpc3RlbmVycyA9IFtdO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB7XG5cbiAgICAgICAgc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIC8vIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1bnN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICAgICAgICAvLyB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgICAgICAvLyBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgLy8gICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVuc3Vic2NyaWJlQWxsKCkge1xuICAgICAgICAgICAgbGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgICAgICAgICAvLyBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmlnZ2VyKGV2ZW50LCAuLi5kYXRhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyW2V2ZW50XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcltldmVudF0oLi4uZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9KTtcblxufVxuIiwiLy8gTWlzY2VsbGFuZW91cyB1dGlsaXRpZXNcbi8qanNoaW50IHdvcmtlcjogdHJ1ZSovXG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHlhbWwgZnJvbSAnanMteWFtbCc7XG5pbXBvcnQgR2VvIGZyb20gJy4uL2dlbyc7XG5cbnZhciBVdGlscztcbmV4cG9ydCBkZWZhdWx0IFV0aWxzID0ge307XG5cbi8vIEFkZCBhIGJhc2UgVVJMIGZvciBzY2hlbWVsZXNzIG9yIHByb3RvY29sLWxlc3MgVVJMc1xuLy8gRGVmYXVsdHMgdG8gYWRkaW5nIGN1cnJlbnQgd2luZG93IHByb3RvY29sIGFuZCBiYXNlLCBvciBhZGRzIGEgY3VzdG9tIGJhc2UgaWYgc3BlY2lmaWVkXG4vLyBNYXliZSB1c2UgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9VUkkuanMgaWYgbW9yZSByb2J1c3QgZnVuY3Rpb25hbGl0eSBpcyBuZWVkZWRcblV0aWxzLmFkZEJhc2VVUkwgPSBmdW5jdGlvbiAodXJsLCBiYXNlKSB7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNjaGVtZWxlc3MsIGFkZCBwcm90b2NvbFxuICAgIGlmICh1cmwuc3Vic3RyKDAsIDIpID09PSAnLy8nKSB7XG4gICAgICAgIHVybCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIHVybDtcbiAgICB9XG4gICAgLy8gTm8gaHR0cChzKSBvciBkYXRhLCBhZGQgYmFzZVxuICAgIGVsc2UgaWYgKHVybC5zZWFyY2goL14oaHR0cHxodHRwc3xkYXRhfGJsb2IpOi8pIDwgMCkge1xuICAgICAgICB2YXIgcmVsYXRpdmUgPSAodXJsWzBdICE9PSAnLycpO1xuICAgICAgICB2YXIgYmFzZV9pbmZvO1xuICAgICAgICBpZiAoYmFzZSkge1xuICAgICAgICAgICAgYmFzZV9pbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpOyAvLyB1c2UgYSB0ZW1wb3JhcnkgZWxlbWVudCB0byBwYXJzZSBVUkxcbiAgICAgICAgICAgIGJhc2VfaW5mby5ocmVmID0gYmFzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VfaW5mbyA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAgICAgbGV0IHBhdGggPSBiYXNlX2luZm8uaHJlZi5tYXRjaCgvKFteXFwjXSspLyk7IC8vIHN0cmlwIGhhc2hcbiAgICAgICAgICAgIHBhdGggPSAocGF0aCAmJiBwYXRoLmxlbmd0aCA+IDEpID8gcGF0aFswXSA6ICcnO1xuICAgICAgICAgICAgdXJsID0gcGF0aCArIHVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEVhc3kgd2F5XG4gICAgICAgICAgICBpZiAoYmFzZV9pbmZvLm9yaWdpbikge1xuICAgICAgICAgICAgICAgIHVybCA9IGJhc2VfaW5mby5vcmlnaW4gKyAnLycgKyB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYXJkIHdheSAoSUUxMSlcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSB1cmwubWF0Y2goL14oKGh0dHB8aHR0cHN8ZGF0YXxibG9iKTpcXC9cXC9bXlxcL10qXFwvKS8pO1xuICAgICAgICAgICAgICAgIG9yaWdpbiA9IChvcmlnaW4gJiYgb3JpZ2luLmxlbmd0aCA+IDEpID8gb3JpZ2luWzBdIDogJyc7XG4gICAgICAgICAgICAgICAgdXJsID0gb3JpZ2luICsgdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG59O1xuXG5VdGlscy5wYXRoRm9yVVJMID0gZnVuY3Rpb24gKHVybCkge1xuICAgIGlmICh1cmwuc2VhcmNoKC9eKGRhdGF8YmxvYik6LykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB1cmwuc3Vic3RyKDAsIHVybC5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn07XG5cblV0aWxzLmNhY2hlQnVzdGVyRm9yVXJsID0gZnVuY3Rpb24gKHVybCkge1xuICAgIGlmICh1cmwuc2VhcmNoKC9eKGRhdGF8YmxvYik6LykgPiAtMSkge1xuICAgICAgICByZXR1cm4gdXJsOyAvLyBubyBjYWNoZS1idXN0aW5nIG9uIG9iamVjdCBvciBkYXRhIFVSTHNcbiAgICB9XG4gICAgcmV0dXJuIHVybCArICc/JyArICgrbmV3IERhdGUoKSk7XG59O1xuXG4vLyBQb2x5ZmlsbCAoZm9yIFNhZmFyaSBjb21wYXRpYmlsaXR5KVxuVXRpbHMuX2NyZWF0ZU9iamVjdFVSTCA9IHVuZGVmaW5lZDtcblV0aWxzLmNyZWF0ZU9iamVjdFVSTCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICBpZiAoVXRpbHMuX2NyZWF0ZU9iamVjdFVSTCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIFV0aWxzLl9jcmVhdGVPYmplY3RVUkwgPSAod2luZG93LlVSTCAmJiB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTCkgfHwgKHdpbmRvdy53ZWJraXRVUkwgJiYgd2luZG93LndlYmtpdFVSTC5jcmVhdGVPYmplY3RVUkwpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgVXRpbHMuX2NyZWF0ZU9iamVjdFVSTCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgVXRpbHMuX2NyZWF0ZU9iamVjdFVSTCA9IG51bGw7XG4gICAgICAgICAgICBsb2cud2Fybihgd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwgKG9yIHZlbmRvciBwcmVmaXgpIG5vdCBmb3VuZCwgdW5hYmxlIHRvIGNyZWF0ZSBsb2NhbCBibG9iIFVSTHNgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChVdGlscy5fY3JlYXRlT2JqZWN0VVJMKSB7XG4gICAgICAgIHJldHVybiBVdGlscy5fY3JlYXRlT2JqZWN0VVJMKHVybCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbn07XG5cblV0aWxzLmlvID0gZnVuY3Rpb24gKHVybCwgdGltZW91dCA9IDYwMDAwLCByZXNwb25zZVR5cGUgPSAndGV4dCcsIG1ldGhvZCA9ICdHRVQnLCBoZWFkZXJzID0ge30pIHtcbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICByZXF1ZXN0Lm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgICAgICByZXF1ZXN0LnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIGlmIChbJ3RleHQnLCAnanNvbiddLmluZGV4T2YocmVxdWVzdC5yZXNwb25zZVR5cGUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KEVycm9yKCdSZXF1ZXN0IGVycm9yIHdpdGggYSBzdGF0dXMgb2YgJyArIHJlcXVlc3Quc3RhdHVzVGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICByZWplY3QoRXJyb3IoJ1RoZXJlIHdhcyBhIG5ldHdvcmsgZXJyb3InICsgZXZ0LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICByZWplY3QoRXJyb3IoJ3RpbWVvdXQgJysgZXZ0LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgJ3JlcXVlc3QnLCB7XG4gICAgICAgIHZhbHVlOiByZXF1ZXN0XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5cblV0aWxzLnBhcnNlUmVzb3VyY2UgPSBmdW5jdGlvbiAoYm9keSkge1xuICAgIHZhciBkYXRhO1xuICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSB5YW1sLnNhZmVMb2FkKGJvZHkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59O1xuXG5VdGlscy5sb2FkUmVzb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBVdGlscy5pbyhVdGlscy5jYWNoZUJ1c3RlckZvclVybChzb3VyY2UpKS50aGVuKChib2R5KSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBVdGlscy5wYXJzZVJlc291cmNlKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vLyBOZWVkZWQgZm9yIG9sZGVyIGJyb3dzZXJzIHRoYXQgc3RpbGwgc3VwcG9ydCBXZWJHTCAoU2FmYXJpIDYgZXRjLilcblV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZVBvbHlmaWxsID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID1cbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgfHxcbiAgICAgICAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIDEwMDAgLzYwKTtcbiAgICAgICAgICAgIH07XG4gICAgfVxufTtcblxuLy8gU3RyaW5naWZ5IGFuIG9iamVjdCBpbnRvIEpTT04sIGJ1dCBjb252ZXJ0IGZ1bmN0aW9ucyB0byBzdHJpbmdzXG5VdGlscy5zZXJpYWxpemVXaXRoRnVuY3Rpb25zID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBzZXJpYWxpemVkID0gSlNPTi5zdHJpbmdpZnkob2JqLCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgIC8vIENvbnZlcnQgZnVuY3Rpb25zIHRvIHN0cmluZ3NcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdi50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59O1xuXG4vLyBQYXJzZSBhIEpTT04gc3RyaW5nLCBidXQgY29udmVydCBmdW5jdGlvbi1saWtlIHN0cmluZ3MgYmFjayBpbnRvIGZ1bmN0aW9uc1xuVXRpbHMuZGVzZXJpYWxpemVXaXRoRnVuY3Rpb25zID0gZnVuY3Rpb24oc2VyaWFsaXplZCwgd3JhcCkge1xuICAgIHZhciBvYmogPSBKU09OLnBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgIG9iaiA9IFV0aWxzLnN0cmluZ3NUb0Z1bmN0aW9ucyhvYmosIHdyYXApO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG4vLyBSZWN1cnNpdmVseSBwYXJzZSBhbiBvYmplY3QsIGF0dGVtcHRpbmcgdG8gY29udmVydCBzdHJpbmcgcHJvcGVydGllcyB0aGF0IGxvb2sgbGlrZSBmdW5jdGlvbnMgYmFjayBpbnRvIGZ1bmN0aW9uc1xuVXRpbHMuc3RyaW5nc1RvRnVuY3Rpb25zID0gZnVuY3Rpb24ob2JqLCB3cmFwKSB7XG4gICAgLy8gQ29udmVydCBzdHJpbmdcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2JqID0gVXRpbHMuc3RyaW5nVG9GdW5jdGlvbihvYmosIHdyYXApO1xuICAgIH1cbiAgICAvLyBMb29wIHRocm91Z2ggb2JqZWN0IHByb3BlcnRpZXNcbiAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKGxldCBwIGluIG9iaikge1xuICAgICAgICAgICAgb2JqW3BdID0gVXRpbHMuc3RyaW5nc1RvRnVuY3Rpb25zKG9ialtwXSwgd3JhcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbi8vIENvbnZlcnQgc3RyaW5nIGJhY2sgaW50byBhIGZ1bmN0aW9uXG4vLyBUT0RPOiBtYWtlIGZ1bmN0aW9uIG1hdGNoaW5nIHRvbGVyYW50IG9mIHdoaXRlc3BhY2UgYW5kIG11bHRpbGluZXNcblV0aWxzLnN0cmluZ1RvRnVuY3Rpb24gPSBmdW5jdGlvbih2YWwsIHdyYXApIHtcbiAgICAvLyBDb252ZXJ0IHN0cmluZ3MgYmFjayBpbnRvIGZ1bmN0aW9uc1xuICAgIGlmICh2YWwubWF0Y2goL15cXHMqZnVuY3Rpb25cXHMqXFx3KlxccypcXChbXFxzXFxTXSpcXClcXHMqXFx7W1xcc1xcU10qXFx9L20pICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdyYXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBldmFsKCdmID0gJyArIHdyYXAodmFsKSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZhbCgnZiA9ICcgKyB2YWwpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBmYWxsLWJhY2sgdG8gb3JpZ2luYWwgdmFsdWUgaWYgcGFyc2luZyBmYWlsZWRcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn07XG5cbi8vIExvZyB3cmFwcGVyLCBzZW5kcyBtZXNzYWdlIHRvIG1haW4gdGhyZWFkIGZvciBkaXNwbGF5LCBhbmQgaW5jbHVkZXMgd29ya2VyIGlkICNcblV0aWxzLmxvZyA9IGZ1bmN0aW9uIChsZXZlbCwgLi4ubXNnKSB7XG4gICAgbGV2ZWwgPSBsZXZlbCB8fCAnaW5mbyc7XG4gICAgaWYgKFV0aWxzLmlzV29ya2VyVGhyZWFkKSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2xvZycsXG4gICAgICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICB3b3JrZXJfaWQ6IHNlbGYuX3dvcmtlcl9pZCxcbiAgICAgICAgICAgIG1zZzogbXNnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbG9nW2xldmVsXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsb2dbbGV2ZWxdKC4uLm1zZyk7XG4gICAgfVxufTtcblxuLy8gRGVmYXVsdCB0byBhbGxvd2luZyBoaWdoIHBpeGVsIGRlbnNpdHlcblV0aWxzLnVzZV9oaWdoX2RlbnNpdHlfZGlzcGxheSA9IHRydWU7XG5VdGlscy51cGRhdGVEZXZpY2VQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCkge1xuICAgIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbyA9IChVdGlscy51c2VfaGlnaF9kZW5zaXR5X2Rpc3BsYXkgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHx8IDE7XG59O1xuXG4vLyBNYXJrIHRocmVhZCBhcyBtYWluIG9yIHdvcmtlclxuKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh3aW5kb3cuZG9jdW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgVXRpbHMuaXNXb3JrZXJUaHJlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIFV0aWxzLmlzTWFpblRocmVhZCAgID0gdHJ1ZTtcbiAgICAgICAgICAgIFV0aWxzLnVwZGF0ZURldmljZVBpeGVsUmF0aW8oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoc2VsZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBVdGlscy5pc1dvcmtlclRocmVhZCA9IHRydWU7XG4gICAgICAgICAgICBVdGlscy5pc01haW5UaHJlYWQgICA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufSkoKTtcblxuLy8gR2V0IFVSTCB0aGF0IHRoZSBjdXJyZW50IHNjcmlwdCB3YXMgbG9hZGVkIGZyb21cbi8vIElmIGN1cnJlbnRTY3JpcHQgaXMgbm90IGF2YWlsYWJsZSwgbG9vcHMgdGhyb3VnaCA8c2NyaXB0PiBlbGVtZW50cyBzZWFyY2hpbmcgZm9yIGEgbGlzdCBvZiBwcm92aWRlZCBwYXRoc1xuLy8gZS5nLiBVdGlscy5maW5kQ3VycmVudFVSTCgndGFuZ3JhbS5kZWJ1Zy5qcycsICd0YW5ncmFtLm1pbi5qcycpO1xuVXRpbHMuZmluZEN1cnJlbnRVUkwgPSBmdW5jdGlvbiAoLi4ucGF0aHMpIHtcbiAgICAvLyBGaW5kIGN1cnJlbnRseSBleGVjdXRpbmcgc2NyaXB0XG4gICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQ7XG4gICAgaWYgKHNjcmlwdCkge1xuICAgICAgICByZXR1cm4gc2NyaXB0LnNyYztcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXRocykpIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgb24gbG9vcGluZyB0aHJvdWdoIDxzY3JpcHQ+IGVsZW1lbnRzIGlmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgICB2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgICAgICAgZm9yICh2YXIgcz0wOyBzIDwgc2NyaXB0cy5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgcGF0aCBvZiBwYXRocykge1xuICAgICAgICAgICAgICAgIGlmIChzY3JpcHRzW3NdLnNyYy5pbmRleE9mKHBhdGgpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NyaXB0c1tzXS5zcmM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gVXNlZCBmb3IgZGlmZmVyZW50aWF0aW5nIGJldHdlZW4gcG93ZXItb2YtMiBhbmQgbm9uLXBvd2VyLW9mLTIgdGV4dHVyZXNcbi8vIFZpYTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xOTcyMjI0Ny93ZWJnbC13YWl0LWZvci10ZXh0dXJlLXRvLWxvYWRcblV0aWxzLmlzUG93ZXJPZjIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiAodmFsdWUgLSAxKSkgPT09IDA7XG59O1xuXG5VdGlscy5uZXh0UG93ZXJPZjIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2cyKHZhbHVlKSkpO1xufTtcblxuLy8gSW50ZXJwb2xhdGUgJ3gnIGFsb25nIGEgc2VyaWVzIG9mIGNvbnRyb2wgcG9pbnRzXG4vLyAncG9pbnRzJyBpcyBhbiBhcnJheSBvZiBjb250cm9sIHBvaW50cyBpbiB0aGUgZm9ybSBbeCwgeV1cbi8vXG4vLyBFeGFtcGxlOlxuLy8gICAgIENvbnRyb2wgcG9pbnRzOlxuLy8gICAgICAgICBbMCwgNV06ICB3aGVuIHg9MCwgeT01XG4vLyAgICAgICAgIFs0LCAxMF06IHdoZW4geD00LCB5PTEwXG4vL1xuLy8gICAgIFV0aWxzLmludGVycG9sYXRlKDIsIFtbMCwgNV0sIFs0LCAxMF1dKTtcbi8vICAgICAtPiBjb21wdXRlcyB4PTIsIGhhbGZ3YXkgYmV0d2VlbiB4PTAgYW5kIHg9NDogKDEwIC0gNSkgLyAyICs1XG4vLyAgICAgLT4gcmV0dXJucyA3LjVcbi8vXG4vLyBUT0RPOiBhZGQgb3RoZXIgaW50ZXJwb2xhdGlvbiBtZXRob2RzIGJlc2lkZXMgbGluZWFyXG4vL1xuVXRpbHMuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbih4LCBwb2ludHMpIHtcbiAgICAvLyBJZiB0aGlzIGRvZXNuJ3QgcmVzZW1ibGUgYSBsaXN0IG9mIGNvbnRyb2wgcG9pbnRzLCBqdXN0IHJldHVybiB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSB8fCAhQXJyYXkuaXNBcnJheShwb2ludHNbMF0pKSB7XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBvaW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuXG4gICAgdmFyIHgxLCB4MiwgZCwgeTtcblxuICAgIC8vIE1pbiBib3VuZHNcbiAgICBpZiAoeCA8PSBwb2ludHNbMF1bMF0pIHtcbiAgICAgICAgeSA9IHBvaW50c1swXVsxXTtcbiAgICB9XG4gICAgLy8gTWF4IGJvdW5kc1xuICAgIGVsc2UgaWYgKHggPj0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMV1bMF0pIHtcbiAgICAgICAgeSA9IHBvaW50c1twb2ludHMubGVuZ3RoLTFdWzFdO1xuICAgIH1cbiAgICAvLyBGaW5kIHdoaWNoIGNvbnRyb2wgcG9pbnRzIHggaXMgYmV0d2VlblxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoeCA+PSBwb2ludHNbaV1bMF0gJiYgeCA8IHBvaW50c1tpKzFdWzBdKSB7XG4gICAgICAgICAgICAgICAgLy8gTGluZWFyIGludGVycG9sYXRpb25cbiAgICAgICAgICAgICAgICB4MSA9IHBvaW50c1tpXVswXTtcbiAgICAgICAgICAgICAgICB4MiA9IHBvaW50c1tpKzFdWzBdO1xuXG4gICAgICAgICAgICAgICAgLy8gTXVsdGlwbGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9pbnRzW2ldWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGM9MDsgYyA8IHBvaW50c1tpXVsxXS5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHBvaW50c1tpKzFdWzFdW2NdIC0gcG9pbnRzW2ldWzFdW2NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeVtjXSA9IGQgKiAoeCAtIHgxKSAvICh4MiAtIHgxKSArIHBvaW50c1tpXVsxXVtjXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTaW5nbGUgdmFsdWVcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IHBvaW50c1tpKzFdWzFdIC0gcG9pbnRzW2ldWzFdO1xuICAgICAgICAgICAgICAgICAgICB5ID0gZCAqICh4IC0geDEpIC8gKHgyIC0geDEpICsgcG9pbnRzW2ldWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geTtcbn07XG5cbi8vIEl0ZXJhdG9ycyAoRVM2IGdlbmVyYXRvcnMpXG5cbi8vIEl0ZXJhdG9yIGZvciBrZXkvdmFsdWUgcGFpcnMgb2YgYW4gb2JqZWN0XG5VdGlscy5lbnRyaWVzID0gZnVuY3Rpb24qIChvYmopIHtcbiAgICBmb3IgKHZhciBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgICB5aWVsZCBba2V5LCBvYmpba2V5XV07XG4gICAgfVxufTtcblxuLy8gSXRlcmF0b3IgZm9yIHZhbHVlcyBvZiBhbiBvYmplY3RcblV0aWxzLnZhbHVlcyA9IGZ1bmN0aW9uKiAob2JqKSB7XG4gICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgeWllbGQgb2JqW2tleV07XG4gICAgfVxufTtcblxuLy8gUmVjdXJzaXZlIGl0ZXJhdG9ycyBmb3IgYWxsIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LCBubyBtYXR0ZXIgaG93IGRlZXBseSBuZXN0ZWRcbi8vIFRPRE86IGZpeCBmb3IgY2lyY3VsYXIgc3RydWN0dXJlc1xuVXRpbHMucmVjdXJzZUVudHJpZXMgPSBmdW5jdGlvbiogKG9iaikge1xuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgaWYgKG9ialtrZXldKSB7XG4gICAgICAgICAgICB5aWVsZCBba2V5LCBvYmpba2V5XSwgb2JqXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIFV0aWxzLnJlY3Vyc2VFbnRyaWVzKG9ialtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblV0aWxzLnJlY3Vyc2VWYWx1ZXMgPSBmdW5jdGlvbiogKG9iaikge1xuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgaWYgKG9ialtrZXldKSB7XG4gICAgICAgICAgICB5aWVsZCBvYmpba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIFV0aWxzLnJlY3Vyc2VWYWx1ZXMob2JqW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gU2NhbGUgYSAqc2lnbmVkKiBzaG9ydCBmb3IgdXNlIGluIGEgR0wgVkJPXG4vLyBgdW5pdGAgaXMgYW4gb3B0aW9uYWwgc2NhbGluZyBmYWN0b3IgdG8gbWltaWMgZml4ZWQgcG9pbnQsIHNpbmNlIHRoZXNlIHZhbHVlcyB3aWxsIGJlXG4vLyBub3JtYWxpemVkIHRvIDAtMSwgZS5nLiBkaXZpZGUgaW5wdXQgYnkgdW5pdCBvbiB0aGUgd2F5IGluLCBtdWx0aXBseSBpdCBiYWNrIGluIHRoZSBzaGFkZXJcblV0aWxzLnNjYWxlSW50MTYgPSBmdW5jdGlvbiAodmFsLCB1bml0KSB7XG4gICAgcmV0dXJuICh2YWwgLyB1bml0KSAqIDMyNzY3O1xufTtcblxuVXRpbHMuZGVnVG9SYWQgPSBmdW5jdGlvbiAoZGVncmVlcykge1xuICAgIHJldHVybiBkZWdyZWVzICogTWF0aC5QSSAvIDE4MDtcbn07XG5cblV0aWxzLnJhZFRvRGVnID0gZnVuY3Rpb24gKHJhZGlhbnMpIHtcbiAgICByZXR1cm4gcmFkaWFucyAqIDE4MCAvIE1hdGguUEk7XG59O1xuXG5VdGlscy50b0NhbnZhc0NvbG9yID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgcmV0dXJuICdyZ2IoJyArICBNYXRoLnJvdW5kKGNvbG9yWzBdICogMjU1KSArICcsJyArIE1hdGgucm91bmQoY29sb3JbMV0gICogMjU1KSArICcsJyArIE1hdGgucm91bmQoY29sb3JbMl0gKiAyNTUpICsgJyknO1xufTtcblxuVXRpbHMudG9QaXhlbFNpemUgPSBmdW5jdGlvbiAoc2l6ZSwga2luZCkge1xuICAgIGlmIChraW5kID09PSBcInB4XCIpIHtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBcImVtXCIpIHtcbiAgICAgICAgcmV0dXJuIDE2ICogc2l6ZTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IFwicHRcIikge1xuICAgICAgICByZXR1cm4gc2l6ZSAvIDAuNzU7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBcIiVcIikge1xuICAgICAgICByZXR1cm4gc2l6ZSAvIDYuMjU7XG4gICAgfVxufTtcblxuVXRpbHMucG9pbnRJblRpbGUgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICByZXR1cm4gcG9pbnRbMF0gPiAwICYmwqBwb2ludFsxXSA+IC1HZW8udGlsZV9zY2FsZSAmJiBwb2ludFswXSA8IEdlby50aWxlX3NjYWxlICYmIHBvaW50WzFdIDwgMDtcbn07XG5cblV0aWxzLnBpeGVsVG9NZXJjYXRvciA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgcmV0dXJuIHNpemUgKiBHZW8udW5pdHNfcGVyX3BpeGVsO1xufTtcblxuIiwidmFyIHZlcnNpb247XG5leHBvcnQgZGVmYXVsdCB2ZXJzaW9uID0ge1xuICAgIHN0cmluZzogJ3YwLjIuMScsXG4gICAgbWFqb3I6IDAsXG4gICAgbWlub3I6IDIsXG4gICAgcGF0Y2g6IDEsXG4gICAgcHJlOiBmYWxzZVxufTtcbiIsIi8qanNoaW50IHdvcmtlcjogdHJ1ZSovXG5cbi8vIFdvcmtlckJyb2tlciByb3V0ZXMgbWVzc2FnZXMgYmV0d2VlbiB3ZWIgd29ya2VycyBhbmQgdGhlIG1haW4gdGhyZWFkLCBhbGxvd2luZyBmb3Igc2ltcGxlclxuLy8gYXN5bmMgY29kZSB2aWEgcHJvbWlzZXMuIEV4YW1wbGUgdXNhZ2U6XG4vL1xuLy8gSW4gd2ViIHdvcmtlciwgZGVmaW5lIGEgbWV0aG9kOlxuLy9cbi8vICAgICBzZWxmLnNxdWFyZSA9IGZ1bmN0aW9uICh4KSB7XG4vLyAgICAgICAgIHJldHVybiB4ICogeDtcbi8vICAgICB9O1xuLy9cbi8vIEluIG1haW4gdGhyZWFkLCBpbnZva2UgdGhhdCBtZXRob2QgYW5kIHJlY2VpdmUgdGhlIHJlc3VsdCAoaWYgYW55KSBhcyBhIHByb21pc2U6XG4vL1xuLy8gICAgIHdvcmtlciA9IG5ldyBXb3JrZXIoLi4uKTtcbi8vICAgICBXb3JrZXJCcm9rZXIuYWRkV29ya2VyKHdvcmtlcik7XG4vL1xuLy8gICAgIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSh3b3JrZXIsICdzcXVhcmUnLCA1KS50aGVuKGZ1bmN0aW9uKHkpIHtcbi8vICAgICAgICAgY29uc29sZS5sb2coeSk7XG4vLyAgICAgfSk7XG4vL1xuLy8gICAgIC0+IHByaW50cyAyNVxuLy9cbi8vIEFzeW5jIGNvZGU6XG4vL1xuLy8gRm9yIHN5bmNocm9ub3VzIGNvZGUgdGhhdCBtdXN0IHBhc3MgYSByZXR1cm4gdmFsdWUgdG8gdGhlIG1haW4gdGhyZWFkLCB0aGUgZnVuY3Rpb24gY2FuIHNpbXBseVxuLy8gcmV0dXJuIGFuIGltbWVkaWF0ZSB2YWx1ZSAoc2VlIGV4YW1wbGUgYWJvdmUpLiBGb3IgY2FzZXMgd2hlcmUgdGhlIHdvcmtlciBtZXRob2QgbmVlZHMgdG8gcnVuXG4vLyBhc3luY2hyb25vdXMgY29kZSwgdGhlIGZ1bmN0aW9uIGNhbiByZXR1cm4gYSBwcm9taXNlLCBhbmQgdGhlIHJlc29sdmVkIG9yIHJlamVjdGVkIHZhbHVlIHdpbGxcbi8vIGJlIHNlbnQgYmFjayB0byB0aGUgbWFpbiB0aHJlYWQgd2hlbiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQuXG4vL1xuLy8gRXJyb3IgaGFuZGxpbmc6XG4vL1xuLy8gSWYgdGhlIHdvcmtlciBtZXRob2QgZWl0aGVyIHRocm93cyBhbiBlcnJvciwgb3IgcmV0dXJucyBhIHByb21pc2UgdGhhdCBpcyByZWplY3RlZCwgaXQgd2lsbCBiZVxuLy8gc2VudCBiYWNrIHRvIHRoZSBtYWluIHRocmVhZCBhcyBhIHByb21pc2UgcmVqZWN0aW9uLiBUaGVzZSB0d28gZXhhbXBsZXMgYXJlIGVxdWl2YWxlbnQ6XG4vL1xuLy8gICAgIEluIHdvcmtlciwgdGhyb3dpbmcgYW4gZXJyb3I6XG4vL1xuLy8gICAgICAgICBzZWxmLmJyb2tlbiA9IGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXJyb3IgaW4gd29ya2VyIScpO1xuLy8gICAgICAgICB9O1xuLy9cbi8vICAgICBJbiB3b3JrZXIsIHJldHVybmluZyBhIHJlamVjdGVkIHByb21pc2U6XG4vL1xuLy8gICAgICAgICBzZWxmLmJyb2tlbiA9IGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2Vycm9yIGluIHdvcmtlciEnKSk7XG4vLyAgICAgICAgIH07XG4vL1xuLy8gICAgIEluIG1haW4gdGhyZWFkLCBib3RoIGVycm9ycyBhcmUgcmVjZWl2ZWQgYXMgYSBwcm9taXNlIHJlamVjdGlvbjpcbi8vXG4vLyAgICAgICAgIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSh3b3JrZXIsICdicm9rZW4nKS50aGVuKFxuLy8gICAgICAgICAgICAgLy8gUHJvbWlzZSByZXNvbHZlZFxuLy8gICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3N1Y2Nlc3MhJyk7XG4vLyAgICAgICAgICAgICB9LFxuLy8gICAgICAgICAgICAgLy8gUHJvbWlzZSByZWplY3RlZFxuLy8gICAgICAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbi8vICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZXJyb3IhJywgZXJyb3IpO1xuLy8gICAgICAgICAgICAgfSk7XG4vL1xuLy8gICAgICAgICAtPiBwcmludHMgJ2Vycm9yISBlcnJvciBpbiB3b3JrZXInXG4vL1xuLy8gVE9ETzogYWRkIGRvY3VtZW50YXRpb24gZm9yIGludm9raW5nIG1haW4gdGhyZWFkIG1ldGhvZHMgZnJvbSBhIHdvcmtlciAoYmFzaWNhbGx5IHNhbWUgQVBJLCBidXQgaW4gcmV2ZXJzZSlcbmltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzJztcblxudmFyIFdvcmtlckJyb2tlcjtcbmV4cG9ydCBkZWZhdWx0IFdvcmtlckJyb2tlciA9IHt9O1xuXG4vLyBHbG9iYWwgbGlzdCBvZiBhbGwgd29ya2VyIG1lc3NhZ2VzXG4vLyBVbmlxdWVseSB0cmFja3MgZXZlcnkgY2FsbCBtYWRlIGJldHdlZW4gbWFpbiB0aHJlYWQgYW5kIGEgd29ya2VyXG52YXIgbWVzc2FnZV9pZCA9IDA7XG52YXIgbWVzc2FnZXMgPSB7fTtcblxuLy8gTWFpbiB0aHJlYWQ6XG4vLyAtIFNlbmQgbWVzc2FnZXMgdG8gd29ya2VycywgYW5kIG9wdGlvbmFsbHkgcmVjZWl2ZSBhbiBhc3luYyByZXNwb25zZSBhcyBhIHByb21pc2Vcbi8vIC0gUmVjZWl2ZSBtZXNzYWdlcyBmcm9tIHdvcmtlcnMsIGFuZCBvcHRpb25hbGx5IHNlbmQgYW4gYXN5bmMgcmVzcG9uc2UgYmFjayBhcyBhIHByb21pc2VcbmZ1bmN0aW9uIHNldHVwTWFpblRocmVhZCAoKSB7XG5cbiAgICAvLyBTZW5kIGEgbWVzc2FnZSB0byBhIHdvcmtlciwgYW5kIG9wdGlvbmFsbHkgZ2V0IGFuIGFzeW5jIHJlc3BvbnNlXG4gICAgLy8gQXJndW1lbnRzOlxuICAgIC8vICAgLSB3b3JrZXI6IHRoZSB3ZWIgd29ya2VyIGluc3RhbmNlXG4gICAgLy8gICAtIG1ldGhvZDogdGhlIG1ldGhvZCB3aXRoIHRoaXMgbmFtZSB3aWxsIGJlIGludm9rZWQgaW4gdGhlIHdvcmtlclxuICAgIC8vICAgLSBtZXNzYWdlOiB3aWxsIGJlIHBhc3NlZCB0byB0aGUgbWV0aG9kIGNhbGwgaW4gdGhlIHdvcmtlclxuICAgIC8vIFJldHVybnM6XG4gICAgLy8gICAtIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIGlmIHRoZSB3b3JrZXIgbWV0aG9kIHJldHVybnMgYSB2YWx1ZSAoY291bGQgYmUgaW1tZWRpYXRlbHksIG9yIGFzeW5jKVxuICAgIC8vXG4gICAgV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24gKHdvcmtlciwgbWV0aG9kLCAuLi5tZXNzYWdlKSB7XG4gICAgICAgIC8vIFRyYWNrIHN0YXRlIG9mIHRoaXMgbWVzc2FnZVxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIG1lc3NhZ2VzW21lc3NhZ2VfaWRdID0geyBtZXRob2QsIG1lc3NhZ2UsIHJlc29sdmUsIHJlamVjdCB9O1xuICAgICAgICB9KTtcblxuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ21haW5fc2VuZCcsICAgICAgLy8gbWFyayBtZXNzYWdlIGFzIG1ldGhvZCBpbnZvY2F0aW9uIGZyb20gbWFpbiB0aHJlYWRcbiAgICAgICAgICAgIG1lc3NhZ2VfaWQsICAgICAgICAgICAgIC8vIHVuaXF1ZSBpZCBmb3IgdGhpcyBtZXNzYWdlLCBmb3IgbGlmZSBvZiBwcm9ncmFtXG4gICAgICAgICAgICBtZXRob2QsICAgICAgICAgICAgICAgICAvLyB3aWxsIGRpc3BhdGNoIHRvIGEgZnVuY3Rpb24gb2YgdGhpcyBuYW1lIHdpdGhpbiB0aGUgd29ya2VyXG4gICAgICAgICAgICBtZXNzYWdlICAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIHBheWxvYWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWVzc2FnZV9pZCsrO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGEgd29ya2VyIHRvIGNvbW11bmljYXRlIHdpdGggLSBlYWNoIHdvcmtlciBtdXN0IGJlIHJlZ2lzdGVyZWQgZnJvbSB0aGUgbWFpbiB0aHJlYWRcbiAgICB2YXIgd29ya2VyX2lkID0gMDtcbiAgICB2YXIgd29ya2VycyA9IHt9O1xuXG4gICAgV29ya2VyQnJva2VyLmFkZFdvcmtlciA9IGZ1bmN0aW9uICh3b3JrZXIpIHtcblxuICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIGFsbCByZWdpc3RlcmVkIHdvcmtlcnNcbiAgICAgICAgLy8gVE9ETzogYWRkaW5nIGEgcHJvcGVydHkgZGlyZWN0bHkgdG8gdGhlIHdvcmtlciwgd291bGQgYmUgYmV0dGVyIHRvIHRyYWNrIG5vbi1pbnN0cnVzaXZlbHksXG4gICAgICAgIC8vIG1heWJlIHdpdGggYW4gRVM2IE1hcFxuICAgICAgICB3b3JrZXIuX3dvcmtlcl9icm9rZXJfaWQgPSB3b3JrZXJfaWQrKztcbiAgICAgICAgd29ya2Vyc1t3b3JrZXIuX3dvcmtlcl9icm9rZXJfaWRdID0gd29ya2VyO1xuXG4gICAgICAgIC8vIExpc3RlbiBmb3IgbWVzc2FnZXMgY29taW5nIGJhY2sgZnJvbSB0aGUgd29ya2VyLCBhbmQgZnVsZmlsbCB0aGF0IG1lc3NhZ2UncyBwcm9taXNlXG4gICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuZGF0YS50eXBlICE9PSAnd29ya2VyX3JlcGx5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUGFzcyB0aGUgcmVzdWx0IHRvIHRoZSBwcm9taXNlXG4gICAgICAgICAgICB2YXIgaWQgPSBldmVudC5kYXRhLm1lc3NhZ2VfaWQ7XG4gICAgICAgICAgICBpZiAobWVzc2FnZXNbaWRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNbaWRdLnJlamVjdChldmVudC5kYXRhLmVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzW2lkXS5yZXNvbHZlKGV2ZW50LmRhdGEubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBtZXNzYWdlc1tpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIExpc3RlbiBmb3IgbWVzc2FnZXMgaW5pdGlhdGluZyBhIGNhbGwgZnJvbSB0aGUgd29ya2VyLCBkaXNwYXRjaCB0aGVtLFxuICAgICAgICAvLyBhbmQgc2VuZCBhbnkgcmV0dXJuIHZhbHVlIGJhY2sgdG8gdGhlIHdvcmtlclxuICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gVW5pcXVlIGlkIGZvciB0aGlzIG1lc3NhZ2UgJiByZXR1cm4gY2FsbCB0byBtYWluIHRocmVhZFxuICAgICAgICAgICAgdmFyIGlkID0gZXZlbnQuZGF0YS5tZXNzYWdlX2lkO1xuICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSAhPT0gJ3dvcmtlcl9zZW5kJyB8fCBpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxsIHRoZSByZXF1ZXN0ZWQgbWV0aG9kIGFuZCBzYXZlIHRoZSByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0YXJnZXRzW2V2ZW50LmRhdGEudGFyZ2V0XTtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFdvcmtlciBicm9rZXIgY291bGQgbm90IGRpc3BhdGNoIG1lc3NhZ2UgdHlwZSAke2V2ZW50LmRhdGEubWV0aG9kfSBvbiB0YXJnZXQgJHtldmVudC5kYXRhLnRhcmdldH0gYmVjYXVzZSBubyBvYmplY3Qgd2l0aCB0aGF0IG5hbWUgaXMgcmVnaXN0ZXJlZCBvbiBtYWluIHRocmVhZGApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gKHR5cGVvZiB0YXJnZXRbZXZlbnQuZGF0YS5tZXRob2RdID09PSAnZnVuY3Rpb24nKSAmJiB0YXJnZXRbZXZlbnQuZGF0YS5tZXRob2RdO1xuICAgICAgICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgV29ya2VyIGJyb2tlciBjb3VsZCBub3QgZGlzcGF0Y2ggbWVzc2FnZSB0eXBlICR7ZXZlbnQuZGF0YS5tZXRob2R9IG9uIHRhcmdldCAke2V2ZW50LmRhdGEudGFyZ2V0fSBiZWNhdXNlIG9iamVjdCBoYXMgbm8gbWV0aG9kIHdpdGggdGhhdCBuYW1lYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQsIGVycm9yO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkodGFyZ2V0LCBldmVudC5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIC8vIFRocm93biBlcnJvcnMgd2lsbCBiZSBwYXNzZWQgYmFjayAoaW4gc3RyaW5nIGZvcm0pIHRvIHdvcmtlclxuICAgICAgICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2VuZCByZXR1cm4gdmFsdWUgdG8gd29ya2VyXG4gICAgICAgICAgICAvLyBBc3luYyByZXN1bHRcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbWFpbl9yZXBseScsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ21haW5fcmVwbHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZV9pZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBgJHtlcnJvci5tZXNzYWdlfTogJHtlcnJvci5zdGFja31gIDogZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW1tZWRpYXRlIHJlc3VsdFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ21haW5fcmVwbHknLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBgJHtlcnJvci5tZXNzYWdlfTogJHtlcnJvci5zdGFja31gIDogZXJyb3IpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfTtcblxuICAgIC8vIFJlZ2lzdGVyIGFuIG9iamVjdCB0byByZWNlaXZlIGNhbGxzIGZyb20gdGhlIHdvcmtlclxuICAgIHZhciB0YXJnZXRzID0ge307XG4gICAgV29ya2VyQnJva2VyLmFkZFRhcmdldCA9IGZ1bmN0aW9uIChuYW1lLCB0YXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0c1tuYW1lXSA9IHRhcmdldDtcbiAgICB9O1xuXG4gICAgLy8gRXhwb3NlIGZvciBkZWJ1Z2dpbmdcbiAgICBXb3JrZXJCcm9rZXIuZ2V0TWVzc2FnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICB9O1xuXG4gICAgV29ya2VyQnJva2VyLmdldE1lc3NhZ2VJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VfaWQ7XG4gICAgfTtcblxufVxuXG4vLyBXb3JrZXIgdGhyZWFkczpcbi8vIC0gUmVjZWl2ZSBtZXNzYWdlcyBmcm9tIG1haW4gdGhyZWFkLCBhbmQgb3B0aW9uYWxseSBzZW5kIGFuIGFzeW5jIHJlc3BvbnNlIGJhY2sgYXMgYSBwcm9taXNlXG4vLyAtIFNlbmQgbWVzc2FnZXMgdG8gbWFpbiB0aHJlYWQsIGFuZCBvcHRpb25hbGx5IHJlY2VpdmUgYW4gYXN5bmMgcmVzcG9uc2UgYXMgYSBwcm9taXNlXG5mdW5jdGlvbiBzZXR1cFdvcmtlclRocmVhZCAoKSB7XG5cbiAgICAvLyBTZW5kIGEgbWVzc2FnZSB0byB0aGUgbWFpbiB0aHJlYWQsIGFuZCBvcHRpb25hbGx5IGdldCBhbiBhc3luYyByZXNwb25zZSBhcyBhIHByb21pc2VcbiAgICAvLyBBcmd1bWVudHM6XG4gICAgLy8gICAtIHRhcmdldDogdGhlIG5hbWUgb2YgdGhlIG9iamVjdCBpbiB0aGUgbWFpbiB0aHJlYWQgdG8gYmUgY2FsbGVkXG4gICAgLy8gICAtIG1ldGhvZDogdGhlIG1ldGhvZCB3aXRoIHRoaXMgbmFtZSB3aWxsIGJlIGludm9rZWQgb24gdGhlIG1haW4gdGhyZWFkIHRhcmdldCBvYmplY3RcbiAgICAvLyAgIC0gbWVzc2FnZTogd2lsbCBiZSBwYXNzZWQgdG8gdGhlIG1ldGhvZCBjYWxsIGluIHRoZSBtYWluIHRocmVhZFxuICAgIC8vIFJldHVybnM6XG4gICAgLy8gICAtIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIGlmIHRoZSBtYWluIHRocmVhZCBtZXRob2QgcmV0dXJucyBhIHZhbHVlIChjb3VsZCBiZSBpbW1lZGlhdGVseSwgb3IgYXN5bmMpXG4gICAgLy9cbiAgICBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBtZXRob2QsIC4uLm1lc3NhZ2UpIHtcbiAgICAgICAgLy8gVHJhY2sgc3RhdGUgb2YgdGhpcyBtZXNzYWdlXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbWVzc2FnZXNbbWVzc2FnZV9pZF0gPSB7IHRhcmdldCwgbWV0aG9kLCBtZXNzYWdlLCByZXNvbHZlLCByZWplY3QgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICB0eXBlOiAnd29ya2VyX3NlbmQnLCAgICAvLyBtYXJrIG1lc3NhZ2UgYXMgbWV0aG9kIGludm9jYXRpb24gZnJvbSB3b3JrZXJcbiAgICAgICAgICAgIG1lc3NhZ2VfaWQsICAgICAgICAgICAgIC8vIHVuaXF1ZSBpZCBmb3IgdGhpcyBtZXNzYWdlLCBmb3IgbGlmZSBvZiBwcm9ncmFtXG4gICAgICAgICAgICB0YXJnZXQsICAgICAgICAgICAgICAgICAvLyBuYW1lIG9mIHRoZSBvYmplY3QgdG8gYmUgY2FsbGVkIG9uIG1haW4gdGhyZWFkXG4gICAgICAgICAgICBtZXRob2QsICAgICAgICAgICAgICAgICAvLyB3aWxsIGRpc3BhdGNoIHRvIGEgbWV0aG9kIG9mIHRoaXMgbmFtZSBvbiB0aGUgbWFpbiB0aHJlYWRcbiAgICAgICAgICAgIG1lc3NhZ2UgICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UgcGF5bG9hZFxuICAgICAgICB9KTtcblxuICAgICAgICBtZXNzYWdlX2lkKys7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICAvLyBMaXN0ZW4gZm9yIG1lc3NhZ2VzIGNvbWluZyBiYWNrIGZyb20gdGhlIG1haW4gdGhyZWFkLCBhbmQgZnVsZmlsbCB0aGF0IG1lc3NhZ2UncyBwcm9taXNlXG4gICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5kYXRhLnR5cGUgIT09ICdtYWluX3JlcGx5Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGFzcyB0aGUgcmVzdWx0IHRvIHRoZSBwcm9taXNlXG4gICAgICAgIHZhciBpZCA9IGV2ZW50LmRhdGEubWVzc2FnZV9pZDtcbiAgICAgICAgaWYgKG1lc3NhZ2VzW2lkXSkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlc1tpZF0ucmVqZWN0KGV2ZW50LmRhdGEuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZXNbaWRdLnJlc29sdmUoZXZlbnQuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBtZXNzYWdlc1tpZF07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFJlY2VpdmUgbWVzc2FnZXMgZnJvbSBtYWluIHRocmVhZCwgZGlzcGF0Y2ggdGhlbSwgYW5kIHNlbmQgYmFjayBhIHJlcGx5XG4gICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIC8vIFVuaXF1ZSBpZCBmb3IgdGhpcyBtZXNzYWdlICYgcmV0dXJuIGNhbGwgdG8gbWFpbiB0aHJlYWRcbiAgICAgICAgdmFyIGlkID0gZXZlbnQuZGF0YS5tZXNzYWdlX2lkO1xuICAgICAgICBpZiAoZXZlbnQuZGF0YS50eXBlICE9PSAnbWFpbl9zZW5kJyB8fCBpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxsIHRoZSByZXF1ZXN0ZWQgd29ya2VyIG1ldGhvZCBhbmQgc2F2ZSB0aGUgcmV0dXJuIHZhbHVlXG4gICAgICAgIHZhciBtZXRob2RfbmFtZSA9IGV2ZW50LmRhdGEubWV0aG9kO1xuICAgICAgICB2YXIgbWV0aG9kID0gKHR5cGVvZiBzZWxmW21ldGhvZF9uYW1lXSA9PT0gJ2Z1bmN0aW9uJykgJiYgc2VsZlttZXRob2RfbmFtZV07XG4gICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgV29ya2VyIGJyb2tlciBjb3VsZCBub3QgZGlzcGF0Y2ggbWVzc2FnZSB0eXBlICR7bWV0aG9kX25hbWV9IGJlY2F1c2Ugd29ya2VyIGhhcyBubyBtZXRob2Qgd2l0aCB0aGF0IG5hbWVgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQsIGVycm9yO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KHNlbGYsIGV2ZW50LmRhdGEubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgLy8gVGhyb3duIGVycm9ycyB3aWxsIGJlIHBhc3NlZCBiYWNrIChpbiBzdHJpbmcgZm9ybSkgdG8gbWFpbiB0aHJlYWRcbiAgICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbmQgcmV0dXJuIHZhbHVlIHRvIG1haW4gdGhyZWFkXG4gICAgICAgIGxldCB0cmFuc2ZlcmFibGVzO1xuICAgICAgICAvLyBBc3luYyByZXN1bHRcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdC50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMgPSBmaW5kVHJhbnNmZXJhYmxlcyh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3dvcmtlcl9yZXBseScsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VfaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZmVyYWJsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBVdGlscy5sb2coJ3RyYWNlJywgYCcke21ldGhvZF9uYW1lfScgdHJhbnNmZXJyZWQgJHt0cmFuc2ZlcmFibGVzLmxlbmd0aH0gb2JqZWN0cyB0byBtYWluIHRocmVhZGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnd29ya2VyX3JlcGx5JyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZV9pZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGAke2Vycm9yLm1lc3NhZ2V9OiAke2Vycm9yLnN0YWNrfWAgOiBlcnJvcilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEltbWVkaWF0ZSByZXN1bHRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cmFuc2ZlcmFibGVzID0gZmluZFRyYW5zZmVyYWJsZXMocmVzdWx0KTtcblxuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3dvcmtlcl9yZXBseScsXG4gICAgICAgICAgICAgICAgbWVzc2FnZV9pZDogaWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgIGVycm9yOiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGAke2Vycm9yLm1lc3NhZ2V9OiAke2Vycm9yLnN0YWNrfWAgOiBlcnJvcilcbiAgICAgICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpO1xuXG4gICAgICAgICAgICBpZiAodHJhbnNmZXJhYmxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgVXRpbHMubG9nKCd0cmFjZScsIGAnJHttZXRob2RfbmFtZX0nIHRyYW5zZmVycmVkICR7dHJhbnNmZXJhYmxlcy5sZW5ndGh9IG9iamVjdHMgdG8gbWFpbiB0aHJlYWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG59XG5cbi8vIEJ1aWxkIGEgbGlzdCBvZiB0cmFuc2ZlcmFibGUgb2JqZWN0cyBmcm9tIGEgc291cmNlIG9iamVjdFxuLy8gVE9ETzogYWRkIG9wdGlvbiBpbiBjYXNlIHlvdSBET04nVCB3YW50IHRvIHRyYW5zZmVyIG9iamVjdHNcbmZ1bmN0aW9uIGZpbmRUcmFuc2ZlcmFibGVzKHNvdXJjZSwgbGlzdCA9IFtdKSB7XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgLy8gQ2hlY2sgZWFjaCBhcnJheSBlbGVtZW50XG4gICAgICAgIHNvdXJjZS5mb3JFYWNoKHggPT4gZmluZFRyYW5zZmVyYWJsZXMoeCwgbGlzdCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBJcyB0aGUgb2JqZWN0IGEgdHJhbnNmZXJhYmxlIGFycmF5IGJ1ZmZlcj9cbiAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICBsaXN0LnB1c2goc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPciBsb29rcyBsaWtlIGEgdHlwZWQgYXJyYXkgKGhhcyBhbiBhcnJheSBidWZmZXIgcHJvcGVydHkpP1xuICAgICAgICBlbHNlIGlmIChzb3VyY2UuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIGxpc3QucHVzaChzb3VyY2UuYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UgY2hlY2sgZWFjaCBwcm9wZXJ0eVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IHAgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgZmluZFRyYW5zZmVyYWJsZXMoc291cmNlW3BdLCBsaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn1cblxuLy8gU2V0dXAgdGhpcyB0aHJlYWQgYXMgYXBwcm9wcmlhdGVcbmlmIChVdGlscy5pc01haW5UaHJlYWQpIHtcbiAgICBzZXR1cE1haW5UaHJlYWQoKTtcbn1cblxuaWYgKFV0aWxzLmlzV29ya2VyVGhyZWFkKSB7XG4gICAgc2V0dXBXb3JrZXJUaHJlYWQoKTtcbn1cbiIsIi8qKiogVmVjdG9yIGZ1bmN0aW9ucyAtIHZlY3RvcnMgcHJvdmlkZWQgYXMgW3gsIHksIHpdIGFycmF5cyAqKiovXG5cbnZhciBWZWN0b3I7XG5leHBvcnQgZGVmYXVsdCBWZWN0b3IgPSB7fTtcblxuVmVjdG9yLnNldCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIFYgPSBbXTtcbiAgICB2YXIgbGltID0gdi5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW07IGkrKykge1xuICAgICAgICBWW2ldID0gdltpXTtcbiAgICB9XG4gICAgcmV0dXJuIFY7XG59O1xuXG5WZWN0b3IubmVnID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgViA9IFtdO1xuICAgIHZhciBsaW0gPSB2Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbTsgaSsrKSB7XG4gICAgICAgIFZbaV0gPSB2W2ldICogLTE7XG4gICAgfVxuICAgIHJldHVybiBWO1xufTtcblxuLy8gQWRkaXRpb24gb2YgdHdvIHZlY3RvcnNcblZlY3Rvci5hZGQgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgdmFyIHYgPSBbXTtcbiAgICB2YXIgbGltID0gTWF0aC5taW4odjEubGVuZ3RoLHYyLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW07IGkrKykge1xuICAgICAgICB2W2ldID0gdjFbaV0gKyB2MltpXTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59O1xuXG4vLyBTdWJzdHJhY3Rpb24gb2YgdHdvIHZlY3RvcnNcblZlY3Rvci5zdWIgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgdmFyIHYgPSBbXTtcbiAgICB2YXIgbGltID0gTWF0aC5taW4odjEubGVuZ3RoLHYyLmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbTsgaSsrKSB7XG4gICAgICAgIHZbaV0gPSB2MVtpXSAtIHYyW2ldO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn07XG5cblZlY3Rvci5zaWduZWRfYXJlYSA9IGZ1bmN0aW9uICh2MSwgdjIsIHYzKSB7XG4gICAgcmV0dXJuICh2MlswXS12MVswXSkqKHYzWzFdLXYxWzFdKSAtICh2M1swXS12MVswXSkqKHYyWzFdLXYxWzFdKTtcbn07XG5cbi8vIE11bHRpcGxpY2F0aW9uIG9mIHR3byB2ZWN0b3JzXG5WZWN0b3IubXVsdCA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICB2YXIgdiA9IFtdLFxuICAgICAgICBsZW4gPSB2MS5sZW5ndGgsXG4gICAgICAgIGk7XG5cbiAgICBpZiAodHlwZW9mIHYyID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBNdWxpdHBseSBieSBzY2FsYXJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2W2ldID0gdjFbaV0gKiB2MjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTXVsdGlwbHkgdHdvIHZlY3RvcnNcbiAgICAgICAgbGVuID0gTWF0aC5taW4odjEubGVuZ3RoLHYyLmxlbmd0aCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdltpXSA9IHYxW2ldICogdjJbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHY7XG59O1xuXG4vLyBEaXZpc2lvbiBvZiB0d28gdmVjdG9yc1xuVmVjdG9yLmRpdiA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICB2YXIgdiA9IFtdLFxuICAgICAgICBpO1xuICAgIGlmKHR5cGVvZiB2MiA9PT0gJ251bWJlcicpe1xuICAgICAgICAvLyBEaXZpZGUgYnkgc2NhbGFyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2MS5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2W2ldID0gdjFbaV0gLyB2MjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERpdmlkZSB0byB2ZWN0b3JzXG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbih2MS5sZW5ndGgsdjIubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2W2ldID0gdjFbaV0gLyB2MltpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbn07XG5cbi8vIEdldCAyRCBwZXJwZW5kaWN1bGFyXG5WZWN0b3IucGVycCA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICByZXR1cm4gWyB2MlsxXSAtIHYxWzFdLFxuICAgICAgICAgICAgIHYxWzBdIC0gdjJbMF0gXTtcbn07XG5cbi8vIEdldCAyRCB2ZWN0b3Igcm90YXRlZFxuVmVjdG9yLnJvdCA9IGZ1bmN0aW9uICh2LCBhKSB7XG4gICAgdmFyIHZyID0gVmVjdG9yLmxlbmd0aCh2KTtcbiAgICB2YXIgdmEgPSBWZWN0b3IuYW5nbGUodik7XG4gICAgcmV0dXJuIFt2ciAqIE1hdGguY29zKHZhK2EpLFxuICAgICAgICAgICAgdnIgKiBNYXRoLnNpbih2YSthKV07XG59O1xuXG4vLyBHZXQgMkQgaGVhZGluZyBhbmdsZVxuVmVjdG9yLmFuZ2xlID0gZnVuY3Rpb24gKFt4LCB5XSkge1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHkseCk7XG59O1xuXG4vLyBDb21wYXJlIHR3byBwb2ludHNcblZlY3Rvci5pc0VxdWFsID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgIHZhciBsZW4gPSB2MS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAodjFbaV0gIT09IHYyW2ldKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIFZlY3RvciBsZW5ndGggc3F1YXJlZFxuVmVjdG9yLmxlbmd0aFNxID0gZnVuY3Rpb24gKHYpXG57XG4gICAgaWYgKHYubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiAodlswXSp2WzBdICsgdlsxXSp2WzFdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAodlswXSp2WzBdICsgdlsxXSp2WzFdICsgdlsyXSp2WzJdKTtcbiAgICB9XG59O1xuXG4vLyBWZWN0b3IgbGVuZ3RoXG5WZWN0b3IubGVuZ3RoID0gZnVuY3Rpb24gKHYpXG57XG4gICAgcmV0dXJuIE1hdGguc3FydChWZWN0b3IubGVuZ3RoU3EodikpO1xufTtcblxuLy8gTm9ybWFsaXplIGEgdmVjdG9yXG5WZWN0b3Iubm9ybWFsaXplID0gZnVuY3Rpb24gKHYpXG57XG4gICAgdmFyIGQ7XG4gICAgaWYgKHYubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGQgPSB2WzBdKnZbMF0gKyB2WzFdKnZbMV07XG4gICAgICAgIGQgPSBNYXRoLnNxcnQoZCk7XG5cbiAgICAgICAgaWYgKGQgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbdlswXSAvIGQsIHZbMV0gLyBkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGQgPSB2WzBdKnZbMF0gKyB2WzFdKnZbMV0gKyB2WzJdKnZbMl07XG4gICAgICAgIGQgPSBNYXRoLnNxcnQoZCk7XG5cbiAgICAgICAgaWYgKGQgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbdlswXSAvIGQsIHZbMV0gLyBkLCB2WzJdIC8gZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgICB9XG59O1xuXG4vLyBDcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzXG5WZWN0b3IuY3Jvc3MgID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgIHJldHVybiBbXG4gICAgICAgICh2MVsxXSAqIHYyWzJdKSAtICh2MVsyXSAqIHYyWzFdKSxcbiAgICAgICAgKHYxWzJdICogdjJbMF0pIC0gKHYxWzBdICogdjJbMl0pLFxuICAgICAgICAodjFbMF0gKiB2MlsxXSkgLSAodjFbMV0gKiB2MlswXSlcbiAgICBdO1xufTtcblxuLy8gRG90IHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcblZlY3Rvci5kb3QgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgdmFyIG4gPSAwO1xuICAgIHZhciBsaW0gPSBNYXRoLm1pbih2MS5sZW5ndGgsIHYyLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW07IGkrKykge1xuICAgICAgICBuICs9IHYxW2ldICogdjJbaV07XG4gICAgfVxuICAgIHJldHVybiBuO1xufTtcblxuLy8gRmluZCB0aGUgaW50ZXJzZWN0aW9uIG9mIHR3byBsaW5lcyBzcGVjaWZpZWQgYXMgc2VnbWVudHMgZnJvbSBwb2ludHMgKHAxLCBwMikgYW5kIChwMywgcDQpXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmUtbGluZV9pbnRlcnNlY3Rpb25cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3JhbWVyJ3NfcnVsZVxuVmVjdG9yLmxpbmVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAocDEsIHAyLCBwMywgcDQsIHBhcmFsbGVsX3RvbGVyYW5jZSkge1xuICAgIHBhcmFsbGVsX3RvbGVyYW5jZSA9IHBhcmFsbGVsX3RvbGVyYW5jZSB8fCAwLjAxO1xuXG4gICAgLy8gYTEqeCArIGIxKnkgPSBjMSBmb3IgbGluZSAoeDEsIHkxKSB0byAoeDIsIHkyKVxuICAgIC8vIGEyKnggKyBiMip5ID0gYzIgZm9yIGxpbmUgKHgzLCB5MykgdG8gKHg0LCB5NClcbiAgICB2YXIgYTEgPSBwMVsxXSAtIHAyWzFdOyAvLyB5MSAtIHkyXG4gICAgdmFyIGIxID0gcDFbMF0gLSBwMlswXTsgLy8geDEgLSB4MlxuICAgIHZhciBhMiA9IHAzWzFdIC0gcDRbMV07IC8vIHkzIC0geTRcbiAgICB2YXIgYjIgPSBwM1swXSAtIHA0WzBdOyAvLyB4MyAtIHg0XG4gICAgdmFyIGMxID0gKHAxWzBdICogcDJbMV0pIC0gKHAxWzFdICogcDJbMF0pOyAvLyB4MSp5MiAtIHkxKngyXG4gICAgdmFyIGMyID0gKHAzWzBdICogcDRbMV0pIC0gKHAzWzFdICogcDRbMF0pOyAvLyB4Myp5NCAtIHkzKng0XG4gICAgdmFyIGRlbm9tID0gKGIxICogYTIpIC0gKGExICogYjIpO1xuXG4gICAgaWYgKE1hdGguYWJzKGRlbm9tKSA+IHBhcmFsbGVsX3RvbGVyYW5jZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgKChjMSAqIGIyKSAtIChiMSAqIGMyKSkgLyBkZW5vbSxcbiAgICAgICAgICAgICgoYzEgKiBhMikgLSAoYTEgKiBjMikpIC8gZGVub21cbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7IC8vIHJldHVybiBudWxsIGlmIGxpbmVzIGFyZSAoY2xvc2UgdG8pIHBhcmFsbGVsXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvYmFiZWwvcG9seWZpbGxcIik7XG4iXX0=
