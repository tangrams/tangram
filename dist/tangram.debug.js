(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict'

module.exports = boxIntersectWrapper

var pool = require('typedarray-pool')
var sweep = require('./lib/sweep')
var boxIntersectIter = require('./lib/intersect')

function boxEmpty(d, box) {
  for(var j=0; j<d; ++j) {
    if(!(box[j] <= box[j+d])) {
      return true
    }
  }
  return false
}

//Unpack boxes into a flat typed array, remove empty boxes
function convertBoxes(boxes, d, data, ids) {
  var ptr = 0
  var count = 0
  for(var i=0, n=boxes.length; i<n; ++i) {
    var b = boxes[i]
    if(boxEmpty(d, b)) {
      continue
    }
    for(var j=0; j<2*d; ++j) {
      data[ptr++] = b[j]
    }
    ids[count++] = i
  }
  return count
}

//Perform type conversions, check bounds
function boxIntersect(red, blue, visit, full) {
  var n = red.length
  var m = blue.length

  //If either array is empty, then we can skip this whole thing
  if(n <= 0 || m <= 0) {
    return
  }

  //Compute dimension, if it is 0 then we skip
  var d = (red[0].length)>>>1
  if(d <= 0) {
    return
  }

  var retval

  //Convert red boxes
  var redList  = pool.mallocDouble(2*d*n)
  var redIds   = pool.mallocInt32(n)
  n = convertBoxes(red, d, redList, redIds)

  if(n > 0) {
    if(d === 1 && full) {
      //Special case: 1d complete
      sweep.init(n)
      retval = sweep.sweepComplete(
        d, visit, 
        0, n, redList, redIds,
        0, n, redList, redIds)
    } else {

      //Convert blue boxes
      var blueList = pool.mallocDouble(2*d*m)
      var blueIds  = pool.mallocInt32(m)
      m = convertBoxes(blue, d, blueList, blueIds)

      if(m > 0) {
        sweep.init(n+m)

        if(d === 1) {
          //Special case: 1d bipartite
          retval = sweep.sweepBipartite(
            d, visit, 
            0, n, redList,  redIds,
            0, m, blueList, blueIds)
        } else {
          //General case:  d>1
          retval = boxIntersectIter(
            d, visit,    full,
            n, redList,  redIds,
            m, blueList, blueIds)
        }

        pool.free(blueList)
        pool.free(blueIds)
      }
    }

    pool.free(redList)
    pool.free(redIds)
  }

  return retval
}


var RESULT

function appendItem(i,j) {
  RESULT.push([i,j])
}

function intersectFullArray(x) {
  RESULT = []
  boxIntersect(x, x, appendItem, true)
  return RESULT
}

function intersectBipartiteArray(x, y) {
  RESULT = []
  boxIntersect(x, y, appendItem, false)
  return RESULT
}

//User-friendly wrapper, handle full input and no-visitor cases
function boxIntersectWrapper(arg0, arg1, arg2) {
  var result
  switch(arguments.length) {
    case 1:
      return intersectFullArray(arg0)
    case 2:
      if(typeof arg1 === 'function') {
        return boxIntersect(arg0, arg0, arg1, true)
      } else {
        return intersectBipartiteArray(arg0, arg1)
      }
    case 3:
      return boxIntersect(arg0, arg1, arg2, false)
    default:
      throw new Error('box-intersect: Invalid arguments')
  }
}
},{"./lib/intersect":3,"./lib/sweep":7,"typedarray-pool":10}],2:[function(require,module,exports){
'use strict'

var DIMENSION   = 'd'
var AXIS        = 'ax'
var VISIT       = 'vv'
var FLIP        = 'fp'

var ELEM_SIZE   = 'es'

var RED_START   = 'rs'
var RED_END     = 're'
var RED_BOXES   = 'rb'
var RED_INDEX   = 'ri'
var RED_PTR     = 'rp'

var BLUE_START  = 'bs'
var BLUE_END    = 'be'
var BLUE_BOXES  = 'bb'
var BLUE_INDEX  = 'bi'
var BLUE_PTR    = 'bp'

var RETVAL      = 'rv'

var INNER_LABEL = 'Q'

var ARGS = [
  DIMENSION,
  AXIS,
  VISIT,
  RED_START,
  RED_END,
  RED_BOXES,
  RED_INDEX,
  BLUE_START,
  BLUE_END,
  BLUE_BOXES,
  BLUE_INDEX
]

function generateBruteForce(redMajor, flip, full) {
  var funcName = 'bruteForce' + 
    (redMajor ? 'Red' : 'Blue') + 
    (flip ? 'Flip' : '') +
    (full ? 'Full' : '')

  var code = ['function ', funcName, '(', ARGS.join(), '){',
    'var ', ELEM_SIZE, '=2*', DIMENSION, ';']

  var redLoop = 
    'for(var i=' + RED_START + ',' + RED_PTR + '=' + ELEM_SIZE + '*' + RED_START + ';' +
        'i<' + RED_END +';' +
        '++i,' + RED_PTR + '+=' + ELEM_SIZE + '){' +
        'var x0=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '],' +
            'x1=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '+' + DIMENSION + '],' +
            'xi=' + RED_INDEX + '[i];'

  var blueLoop = 
    'for(var j=' + BLUE_START + ',' + BLUE_PTR + '=' + ELEM_SIZE + '*' + BLUE_START + ';' +
        'j<' + BLUE_END + ';' +
        '++j,' + BLUE_PTR + '+=' + ELEM_SIZE + '){' +
        'var y0=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '],' +
            (full ? 'y1=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '+' + DIMENSION + '],' : '') +
            'yi=' + BLUE_INDEX + '[j];'

  if(redMajor) {
    code.push(redLoop, INNER_LABEL, ':', blueLoop)
  } else {
    code.push(blueLoop, INNER_LABEL, ':', redLoop)
  }

  if(full) {
    code.push('if(y1<x0||x1<y0)continue;')
  } else if(flip) {
    code.push('if(y0<=x0||x1<y0)continue;')
  } else {
    code.push('if(y0<x0||x1<y0)continue;')
  }

  code.push('for(var k='+AXIS+'+1;k<'+DIMENSION+';++k){'+
    'var r0='+RED_BOXES+'[k+'+RED_PTR+'],'+
        'r1='+RED_BOXES+'[k+'+DIMENSION+'+'+RED_PTR+'],'+
        'b0='+BLUE_BOXES+'[k+'+BLUE_PTR+'],'+
        'b1='+BLUE_BOXES+'[k+'+DIMENSION+'+'+BLUE_PTR+'];'+
      'if(r1<b0||b1<r0)continue ' + INNER_LABEL + ';}' +
      'var ' + RETVAL + '=' + VISIT + '(')

  if(flip) {
    code.push('yi,xi')
  } else {
    code.push('xi,yi')
  }

  code.push(');if(' + RETVAL + '!==void 0)return ' + RETVAL + ';}}}')

  return {
    name: funcName, 
    code: code.join('')
  }
}

function bruteForcePlanner(full) {
  var funcName = 'bruteForce' + (full ? 'Full' : 'Partial')
  var prefix = []
  var fargs = ARGS.slice()
  if(!full) {
    fargs.splice(3, 0, FLIP)
  }

  var code = ['function ' + funcName + '(' + fargs.join() + '){']

  function invoke(redMajor, flip) {
    var res = generateBruteForce(redMajor, flip, full)
    prefix.push(res.code)
    code.push('return ' + res.name + '(' + ARGS.join() + ');')
  }

  code.push('if(' + RED_END + '-' + RED_START + '>' +
                    BLUE_END + '-' + BLUE_START + '){')

  if(full) {
    invoke(true, false)
    code.push('}else{')
    invoke(false, false)
  } else {
    code.push('if(' + FLIP + '){')
    invoke(true, true)
    code.push('}else{')
    invoke(true, false)
    code.push('}}else{if(' + FLIP + '){')
    invoke(false, true)
    code.push('}else{')
    invoke(false, false)
    code.push('}')
  }
  code.push('}}return ' + funcName)

  var codeStr = prefix.join('') + code.join('')
  var proc = new Function(codeStr)
  return proc()
}


exports.partial = bruteForcePlanner(false)
exports.full    = bruteForcePlanner(true)
},{}],3:[function(require,module,exports){
'use strict'

module.exports = boxIntersectIter

var pool = require('typedarray-pool')
var bits = require('bit-twiddle')
var bruteForce = require('./brute')
var bruteForcePartial = bruteForce.partial
var bruteForceFull = bruteForce.full
var sweep = require('./sweep')
var findMedian = require('./median')
var genPartition = require('./partition')

//Twiddle parameters
var BRUTE_FORCE_CUTOFF    = 128       //Cut off for brute force search
var SCAN_CUTOFF           = (1<<22)   //Cut off for two way scan
var SCAN_COMPLETE_CUTOFF  = (1<<22)  

//Partition functions
var partitionInteriorContainsInterval = genPartition(
  '!(lo>=p0)&&!(p1>=hi)', 
  ['p0', 'p1'])

var partitionStartEqual = genPartition(
  'lo===p0',
  ['p0'])

var partitionStartLessThan = genPartition(
  'lo<p0',
  ['p0'])

var partitionEndLessThanEqual = genPartition(
  'hi<=p0',
  ['p0'])

var partitionContainsPoint = genPartition(
  'lo<=p0&&p0<=hi',
  ['p0'])

var partitionContainsPointProper = genPartition(
  'lo<p0&&p0<=hi',
  ['p0'])

//Frame size for iterative loop
var IFRAME_SIZE = 6
var DFRAME_SIZE = 2

//Data for box statck
var INIT_CAPACITY = 1024
var BOX_ISTACK  = pool.mallocInt32(INIT_CAPACITY)
var BOX_DSTACK  = pool.mallocDouble(INIT_CAPACITY)

//Initialize iterative loop queue
function iterInit(d, count) {
  var levels = (8 * bits.log2(count+1) * (d+1))|0
  var maxInts = bits.nextPow2(IFRAME_SIZE*levels)
  if(BOX_ISTACK.length < maxInts) {
    pool.free(BOX_ISTACK)
    BOX_ISTACK = pool.mallocInt32(maxInts)
  }
  var maxDoubles = bits.nextPow2(DFRAME_SIZE*levels)
  if(BOX_DSTACK < maxDoubles) {
    pool.free(BOX_DSTACK)
    BOX_DSTACK = pool.mallocDouble(maxDoubles)
  }
}

//Append item to queue
function iterPush(ptr,
  axis, 
  redStart, redEnd, 
  blueStart, blueEnd, 
  state, 
  lo, hi) {

  var iptr = IFRAME_SIZE * ptr
  BOX_ISTACK[iptr]   = axis
  BOX_ISTACK[iptr+1] = redStart
  BOX_ISTACK[iptr+2] = redEnd
  BOX_ISTACK[iptr+3] = blueStart
  BOX_ISTACK[iptr+4] = blueEnd
  BOX_ISTACK[iptr+5] = state

  var dptr = DFRAME_SIZE * ptr
  BOX_DSTACK[dptr]   = lo
  BOX_DSTACK[dptr+1] = hi
}

//Special case:  Intersect single point with list of intervals
function onePointPartial(
  d, axis, visit, flip,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    if(flip && blueX === r0) {
      continue
    }
    var redId = redIndex[i]
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval
    if(flip) {
      retval = visit(blueId, redId)
    } else {
      retval = visit(redId, blueId)
    }
    if(retval !== void 0) {
      return retval
    }
  }
}

//Special case:  Intersect one point with list of intervals
function onePointFull(
  d, axis, visit,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var redId = redIndex[i]
    if(redId === blueId) {
      continue
    }
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval = visit(redId, blueId)
    if(retval !== void 0) {
      return retval
    }
  }
}

//The main box intersection routine
function boxIntersectIter(
  d, visit, initFull,
  xSize, xBoxes, xIndex,
  ySize, yBoxes, yIndex) {

  //Reserve memory for stack
  iterInit(d, xSize + ySize)

  var top  = 0
  var elemSize = 2 * d
  var retval

  iterPush(top++,
      0,
      0, xSize,
      0, ySize,
      initFull ? 16 : 0, 
      -Infinity, Infinity)
  if(!initFull) {
    iterPush(top++,
      0,
      0, ySize,
      0, xSize,
      1, 
      -Infinity, Infinity)
  }

  while(top > 0) {
    top  -= 1

    var iptr = top * IFRAME_SIZE
    var axis      = BOX_ISTACK[iptr]
    var redStart  = BOX_ISTACK[iptr+1]
    var redEnd    = BOX_ISTACK[iptr+2]
    var blueStart = BOX_ISTACK[iptr+3]
    var blueEnd   = BOX_ISTACK[iptr+4]
    var state     = BOX_ISTACK[iptr+5]

    var dptr = top * DFRAME_SIZE
    var lo        = BOX_DSTACK[dptr]
    var hi        = BOX_DSTACK[dptr+1]

    //Unpack state info
    var flip      = (state & 1)
    var full      = !!(state & 16)

    //Unpack indices
    var red       = xBoxes
    var redIndex  = xIndex
    var blue      = yBoxes
    var blueIndex = yIndex
    if(flip) {
      red         = yBoxes
      redIndex    = yIndex
      blue        = xBoxes
      blueIndex   = xIndex
    }

    if(state & 2) {
      redEnd = partitionStartLessThan(
        d, axis,
        redStart, redEnd, red, redIndex,
        hi)
      if(redStart >= redEnd) {
        continue
      }
    }
    if(state & 4) {
      redStart = partitionEndLessThanEqual(
        d, axis,
        redStart, redEnd, red, redIndex,
        lo)
      if(redStart >= redEnd) {
        continue
      }
    }
    
    var redCount  = redEnd  - redStart
    var blueCount = blueEnd - blueStart

    if(full) {
      if(d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {
        retval = sweep.scanComplete(
          d, axis, visit, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    } else {
      if(d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {
        //If input small, then use brute force
        retval = bruteForcePartial(
            d, axis, visit, flip,
            redStart,  redEnd,  red,  redIndex,
            blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      } else if(d * redCount * blueCount < SCAN_CUTOFF) {
        //If input medium sized, then use sweep and prune
        retval = sweep.scanBipartite(
          d, axis, visit, flip, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    }
    
    //First, find all red intervals whose interior contains (lo,hi)
    var red0 = partitionInteriorContainsInterval(
      d, axis, 
      redStart, redEnd, red, redIndex,
      lo, hi)

    //Lower dimensional case
    if(redStart < red0) {

      if(d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {
        //Special case for small inputs: use brute force
        retval = bruteForceFull(
          d, axis+1, visit,
          redStart, red0, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
      } else if(axis === d-2) {
        if(flip) {
          retval = sweep.sweepBipartite(
            d, visit,
            blueStart, blueEnd, blue, blueIndex,
            redStart, red0, red, redIndex)
        } else {
          retval = sweep.sweepBipartite(
            d, visit,
            redStart, red0, red, redIndex,
            blueStart, blueEnd, blue, blueIndex)
        }
        if(retval !== void 0) {
          return retval
        }
      } else {
        iterPush(top++,
          axis+1,
          redStart, red0,
          blueStart, blueEnd,
          flip,
          -Infinity, Infinity)
        iterPush(top++,
          axis+1,
          blueStart, blueEnd,
          redStart, red0,
          flip^1,
          -Infinity, Infinity)
      }
    }

    //Divide and conquer phase
    if(red0 < redEnd) {

      //Cut blue into 3 parts:
      //
      //  Points < mid point
      //  Points = mid point
      //  Points > mid point
      //
      var blue0 = findMedian(
        d, axis, 
        blueStart, blueEnd, blue, blueIndex)
      var mid = blue[elemSize * blue0 + axis]
      var blue1 = partitionStartEqual(
        d, axis,
        blue0, blueEnd, blue, blueIndex,
        mid)

      //Right case
      if(blue1 < blueEnd) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blue1, blueEnd,
          (flip|4) + (full ? 16 : 0),
          mid, hi)
      }

      //Left case
      if(blueStart < blue0) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blueStart, blue0,
          (flip|2) + (full ? 16 : 0),
          lo, mid)
      }

      //Center case (the hard part)
      if(blue0 + 1 === blue1) {
        //Optimization: Range with exactly 1 point, use a brute force scan
        if(full) {
          retval = onePointFull(
            d, axis, visit,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        } else {
          retval = onePointPartial(
            d, axis, visit, flip,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        }
        if(retval !== void 0) {
          return retval
        }
      } else if(blue0 < blue1) {
        var red1
        if(full) {
          //If full intersection, need to handle special case
          red1 = partitionContainsPoint(
            d, axis,
            red0, redEnd, red, redIndex,
            mid)
          if(red0 < red1) {
            var redX = partitionStartEqual(
              d, axis,
              red0, red1, red, redIndex,
              mid)
            if(axis === d-2) {
              //Degenerate sweep intersection:
              //  [red0, redX] with [blue0, blue1]
              if(red0 < redX) {
                retval = sweep.sweepComplete(
                  d, visit,
                  red0, redX, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }

              //Normal sweep intersection:
              //  [redX, red1] with [blue0, blue1]
              if(redX < red1) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  redX, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }
            } else {
              if(red0 < redX) {
                iterPush(top++,
                  axis+1,
                  red0, redX,
                  blue0, blue1,
                  16,
                  -Infinity, Infinity)
              }
              if(redX < red1) {
                iterPush(top++,
                  axis+1,
                  redX, red1,
                  blue0, blue1,
                  0,
                  -Infinity, Infinity)
                iterPush(top++,
                  axis+1,
                  blue0, blue1,
                  redX, red1,
                  1,
                  -Infinity, Infinity)
              }
            }
          }
        } else {
          if(flip) {
            red1 = partitionContainsPointProper(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          } else {
            red1 = partitionContainsPoint(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          }
          if(red0 < red1) {
            if(axis === d-2) {
              if(flip) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  blue0, blue1, blue, blueIndex,
                  red0, red1, red, redIndex)
              } else {
                retval = sweep.sweepBipartite(
                  d, visit,
                  red0, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
              }
            } else {
              iterPush(top++,
                axis+1,
                red0, red1,
                blue0, blue1,
                flip,
                -Infinity, Infinity)
              iterPush(top++,
                axis+1,
                blue0, blue1,
                red0, red1,
                flip^1,
                -Infinity, Infinity)
            }
          }
        }
      }
    }
  }
}
},{"./brute":2,"./median":4,"./partition":5,"./sweep":7,"bit-twiddle":8,"typedarray-pool":10}],4:[function(require,module,exports){
'use strict'

module.exports = findMedian

var genPartition = require('./partition')

var partitionStartLessThan = genPartition('lo<p0', ['p0'])

var PARTITION_THRESHOLD = 8   //Cut off for using insertion sort in findMedian

//Base case for median finding:  Use insertion sort
function insertionSort(d, axis, start, end, boxes, ids) {
  var elemSize = 2 * d
  var boxPtr = elemSize * (start+1) + axis
  for(var i=start+1; i<end; ++i, boxPtr+=elemSize) {
    var x = boxes[boxPtr]
    for(var j=i, ptr=elemSize*(i-1); 
        j>start && boxes[ptr+axis] > x; 
        --j, ptr-=elemSize) {
      //Swap
      var aPtr = ptr
      var bPtr = ptr+elemSize
      for(var k=0; k<elemSize; ++k, ++aPtr, ++bPtr) {
        var y = boxes[aPtr]
        boxes[aPtr] = boxes[bPtr]
        boxes[bPtr] = y
      }
      var tmp = ids[j]
      ids[j] = ids[j-1]
      ids[j-1] = tmp
    }
  }
}

//Find median using quick select algorithm
//  takes O(n) time with high probability
function findMedian(d, axis, start, end, boxes, ids) {
  if(end <= start+1) {
    return start
  }

  var lo       = start
  var hi       = end
  var mid      = ((end + start) >>> 1)
  var elemSize = 2*d
  var pivot    = mid
  var value    = boxes[elemSize*mid+axis]
  
  while(lo < hi) {
    if(hi - lo < PARTITION_THRESHOLD) {
      insertionSort(d, axis, lo, hi, boxes, ids)
      value = boxes[elemSize*mid+axis]
      break
    }
    
    //Select pivot using median-of-3
    var count  = hi - lo
    var pivot0 = (Math.random()*count+lo)|0
    var value0 = boxes[elemSize*pivot0 + axis]
    var pivot1 = (Math.random()*count+lo)|0
    var value1 = boxes[elemSize*pivot1 + axis]
    var pivot2 = (Math.random()*count+lo)|0
    var value2 = boxes[elemSize*pivot2 + axis]
    if(value0 <= value1) {
      if(value2 >= value1) {
        pivot = pivot1
        value = value1
      } else if(value0 >= value2) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    } else {
      if(value1 >= value2) {
        pivot = pivot1
        value = value1
      } else if(value2 >= value0) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    }

    //Swap pivot to end of array
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Partition using pivot
    pivot = partitionStartLessThan(
      d, axis, 
      lo, hi-1, boxes, ids,
      value)

    //Swap pivot back
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Swap pivot to last pivot
    if(mid < pivot) {
      hi = pivot-1
      while(lo < hi && 
        boxes[elemSize*(hi-1)+axis] === value) {
        hi -= 1
      }
      hi += 1
    } else if(pivot < mid) {
      lo = pivot + 1
      while(lo < hi &&
        boxes[elemSize*lo+axis] === value) {
        lo += 1
      }
    } else {
      break
    }
  }

  //Make sure pivot is at start
  return partitionStartLessThan(
    d, axis, 
    start, mid, boxes, ids,
    boxes[elemSize*mid+axis])
}
},{"./partition":5}],5:[function(require,module,exports){
'use strict'

module.exports = genPartition

var code = 'for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var _;if($)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t}var u=f[p];f[p]=f[m],f[m++]=u}}return m'

function genPartition(predicate, args) {
  var fargs ='abcdef'.split('').concat(args)
  var reads = []
  if(predicate.indexOf('lo') >= 0) {
    reads.push('lo=e[k+n]')
  }
  if(predicate.indexOf('hi') >= 0) {
    reads.push('hi=e[k+o]')
  }
  fargs.push(
    code.replace('_', reads.join())
        .replace('$', predicate))
  return Function.apply(void 0, fargs)
}
},{}],6:[function(require,module,exports){
'use strict';

//This code is extracted from ndarray-sort
//It is inlined here as a temporary workaround

module.exports = wrapper;

var INSERT_SORT_CUTOFF = 32

function wrapper(data, n0) {
  if (n0 <= 4*INSERT_SORT_CUTOFF) {
    insertionSort(0, n0 - 1, data);
  } else {
    quickSort(0, n0 - 1, data);
  }
}

function insertionSort(left, right, data) {
  var ptr = 2*(left+1)
  for(var i=left+1; i<=right; ++i) {
    var a = data[ptr++]
    var b = data[ptr++]
    var j = i
    var jptr = ptr-2
    while(j-- > left) {
      var x = data[jptr-2]
      var y = data[jptr-1]
      if(x < a) {
        break
      } else if(x === a && y < b) {
        break
      }
      data[jptr]   = x
      data[jptr+1] = y
      jptr -= 2
    }
    data[jptr]   = a
    data[jptr+1] = b
  }
}

function swap(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = x
  data[j+1] = y
}

function move(i, j, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[i+1] = data[j+1]
}

function rotate(i, j, k, data) {
  i *= 2
  j *= 2
  k *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = data[k]
  data[j+1] = data[k+1]
  data[k] = x
  data[k+1] = y
}

function shufflePivot(i, j, px, py, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[j] = px
  data[i+1] = data[j+1]
  data[j+1] = py
}

function compare(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i],
      y = data[j]
  if(x < y) {
    return false
  } else if(x === y) {
    return data[i+1] > data[j+1]
  }
  return true
}

function comparePivot(i, y, b, data) {
  i *= 2
  var x = data[i]
  if(x < y) {
    return true
  } else if(x === y) {
    return data[i+1] < b
  }
  return false
}

function quickSort(left, right, data) {
  var sixth = (right - left + 1) / 6 | 0, 
      index1 = left + sixth, 
      index5 = right - sixth, 
      index3 = left + right >> 1, 
      index2 = index3 - sixth, 
      index4 = index3 + sixth, 
      el1 = index1, 
      el2 = index2, 
      el3 = index3, 
      el4 = index4, 
      el5 = index5, 
      less = left + 1, 
      great = right - 1, 
      tmp = 0
  if(compare(el1, el2, data)) {
    tmp = el1
    el1 = el2
    el2 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }
  if(compare(el1, el3, data)) {
    tmp = el1
    el1 = el3
    el3 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el1, el4, data)) {
    tmp = el1
    el1 = el4
    el4 = tmp
  }
  if(compare(el3, el4, data)) {
    tmp = el3
    el3 = el4
    el4 = tmp
  }
  if(compare(el2, el5, data)) {
    tmp = el2
    el2 = el5
    el5 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }

  var pivot1X = data[2*el2]
  var pivot1Y = data[2*el2+1]
  var pivot2X = data[2*el4]
  var pivot2Y = data[2*el4+1]

  var ptr0 = 2 * el1;
  var ptr2 = 2 * el3;
  var ptr4 = 2 * el5;
  var ptr5 = 2 * index1;
  var ptr6 = 2 * index3;
  var ptr7 = 2 * index5;
  for (var i1 = 0; i1 < 2; ++i1) {
    var x = data[ptr0+i1];
    var y = data[ptr2+i1];
    var z = data[ptr4+i1];
    data[ptr5+i1] = x;
    data[ptr6+i1] = y;
    data[ptr7+i1] = z;
  }

  move(index2, left, data)
  move(index4, right, data)
  for (var k = less; k <= great; ++k) {
    if (comparePivot(k, pivot1X, pivot1Y, data)) {
      if (k !== less) {
        swap(k, less, data)
      }
      ++less;
    } else {
      if (!comparePivot(k, pivot2X, pivot2Y, data)) {
        while (true) {
          if (!comparePivot(great, pivot2X, pivot2Y, data)) {
            if (--great < k) {
              break;
            }
            continue;
          } else {
            if (comparePivot(great, pivot1X, pivot1Y, data)) {
              rotate(k, less, great, data)
              ++less;
              --great;
            } else {
              swap(k, great, data)
              --great;
            }
            break;
          }
        }
      }
    }
  }
  shufflePivot(left, less-1, pivot1X, pivot1Y, data)
  shufflePivot(right, great+1, pivot2X, pivot2Y, data)
  if (less - 2 - left <= INSERT_SORT_CUTOFF) {
    insertionSort(left, less - 2, data);
  } else {
    quickSort(left, less - 2, data);
  }
  if (right - (great + 2) <= INSERT_SORT_CUTOFF) {
    insertionSort(great + 2, right, data);
  } else {
    quickSort(great + 2, right, data);
  }
  if (great - less <= INSERT_SORT_CUTOFF) {
    insertionSort(less, great, data);
  } else {
    quickSort(less, great, data);
  }
}
},{}],7:[function(require,module,exports){
'use strict'

module.exports = {
  init:           sqInit,
  sweepBipartite: sweepBipartite,
  sweepComplete:  sweepComplete,
  scanBipartite:  scanBipartite,
  scanComplete:   scanComplete
}

var pool  = require('typedarray-pool')
var bits  = require('bit-twiddle')
var isort = require('./sort')

//Flag for blue
var BLUE_FLAG = (1<<28)

//1D sweep event queue stuff (use pool to save space)
var INIT_CAPACITY      = 1024
var RED_SWEEP_QUEUE    = pool.mallocInt32(INIT_CAPACITY)
var RED_SWEEP_INDEX    = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_QUEUE   = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_INDEX   = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY)
var SWEEP_EVENTS       = pool.mallocDouble(INIT_CAPACITY * 8)

//Reserves memory for the 1D sweep data structures
function sqInit(count) {
  var rcount = bits.nextPow2(count)
  if(RED_SWEEP_QUEUE.length < rcount) {
    pool.free(RED_SWEEP_QUEUE)
    RED_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(RED_SWEEP_INDEX.length < rcount) {
    pool.free(RED_SWEEP_INDEX)
    RED_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_QUEUE.length < rcount) {
    pool.free(BLUE_SWEEP_QUEUE)
    BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_INDEX.length < rcount) {
    pool.free(BLUE_SWEEP_INDEX)
    BLUE_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_QUEUE.length < rcount) {
    pool.free(COMMON_SWEEP_QUEUE)
    COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_INDEX.length < rcount) {
    pool.free(COMMON_SWEEP_INDEX)
    COMMON_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  var eventLength = 8 * rcount
  if(SWEEP_EVENTS.length < eventLength) {
    pool.free(SWEEP_EVENTS)
    SWEEP_EVENTS = pool.mallocDouble(eventLength)
  }
}

//Remove an item from the active queue in O(1)
function sqPop(queue, index, count, item) {
  var idx = index[item]
  var top = queue[count-1]
  queue[idx] = top
  index[top] = idx
}

//Insert an item into the active queue in O(1)
function sqPush(queue, index, count, item) {
  queue[count] = item
  index[item]  = count
}

//Recursion base case: use 1D sweep algorithm
function sweepBipartite(
    d, visit,
    redStart,  redEnd, red, redIndex,
    blueStart, blueEnd, blue, blueIndex) {

  //store events as pairs [coordinate, idx]
  //
  //  red create:  -(idx+1)
  //  red destroy: idx
  //  blue create: -(idx+BLUE_FLAG)
  //  blue destroy: idx+BLUE_FLAG
  //
  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = redIndex[i]
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -(idx+1)
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = blueIndex[i]+BLUE_FLAG
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive  = 0
  var blueActive = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e >= BLUE_FLAG) {
      //blue destroy event
      e = (e-BLUE_FLAG)|0
      sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e)
    } else if(e >= 0) {
      //red destroy event
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e)
    } else if(e <= -BLUE_FLAG) {
      //blue create event
      e = (-e-BLUE_FLAG)|0
      for(var j=0; j<redActive; ++j) {
        var retval = visit(RED_SWEEP_QUEUE[j], e)
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e)
    } else {
      //red create event
      e = (-e-1)|0
      for(var j=0; j<blueActive; ++j) {
        var retval = visit(e, BLUE_SWEEP_QUEUE[j])
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e)
    }
  }
}

//Complete sweep
function sweepComplete(d, visit, 
  redStart, redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = (redIndex[i]+1)<<1
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = (blueIndex[i]+1)<<1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = (-idx)|1
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx|1
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  var blueActive   = 0
  var commonActive = 0
  for(var i=0; i<n; ++i) {
    var e     = SWEEP_EVENTS[2*i+1]|0
    var color = e&1
    if(i < n-1 && (e>>1) === (SWEEP_EVENTS[2*i+3]>>1)) {
      color = 2
      i += 1
    }
    
    if(e < 0) {
      //Create event
      var id = -(e>>1) - 1

      //Intersect with common
      for(var j=0; j<commonActive; ++j) {
        var retval = visit(COMMON_SWEEP_QUEUE[j], id)
        if(retval !== void 0) {
          return retval
        }
      }

      if(color !== 0) {
        //Intersect with red
        for(var j=0; j<redActive; ++j) {
          var retval = visit(RED_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color !== 1) {
        //Intersect with blue
        for(var j=0; j<blueActive; ++j) {
          var retval = visit(BLUE_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color === 0) {
        //Red
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id)
      } else if(color === 1) {
        //Blue
        sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id)
      } else if(color === 2) {
        //Both
        sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id)
      }
    } else {
      //Destroy event
      var id = (e>>1) - 1
      if(color === 0) {
        //Red
        sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id)
      } else if(color === 1) {
        //Blue
        sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id)
      } else if(color === 2) {
        //Both
        sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id)
      }
    }
  }
}

//Sweep and prune/scanline algorithm:
//  Scan along axis, detect intersections
//  Brute force all boxes along axis
function scanBipartite(
  d, axis, visit, flip,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {
  
  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  var redShift  = 1
  var blueShift = 1
  if(flip) {
    blueShift = BLUE_FLAG
  } else {
    redShift  = BLUE_FLAG
  }

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + redShift
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + blueShift
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      var isRed = false
      if(idx >= BLUE_FLAG) {
        isRed = !flip
        idx -= BLUE_FLAG 
      } else {
        isRed = !!flip
        idx -= 1
      }
      if(isRed) {
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx)
      } else {
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx
        
        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redPtr = elemSize * oidx

          if(b1 < red[redPtr+axis+1] || 
             red[redPtr+axis+1+d] < b0) {
            continue
          }

          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d] < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var redId  = redIndex[oidx]
          var retval
          if(flip) {
            retval = visit(blueId, redId)
          } else {
            retval = visit(redId, blueId)
          }
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift)
    }
  }
}

function scanComplete(
  d, axis, visit,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + BLUE_FLAG
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + 1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      if(idx >= BLUE_FLAG) {
        RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG
      } else {
        idx -= 1
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx

        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redId  = redIndex[oidx]

          if(redId === blueId) {
            break
          }

          var redPtr = elemSize * oidx
          if(b1 < red[redPtr+axis+1] || 
            red[redPtr+axis+1+d] < b0) {
            continue
          }
          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d]   < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var retval = visit(redId, blueId)
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      var idx = e - BLUE_FLAG
      for(var j=redActive-1; j>=0; --j) {
        if(RED_SWEEP_QUEUE[j] === idx) {
          for(var k=j+1; k<redActive; ++k) {
            RED_SWEEP_QUEUE[k-1] = RED_SWEEP_QUEUE[k]
          }
          break
        }
      }
      --redActive
    }
  }
}
},{"./sort":6,"bit-twiddle":8,"typedarray-pool":10}],8:[function(require,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict"; "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}


},{}],9:[function(require,module,exports){
"use strict"

function dupe_array(count, value, i) {
  var c = count[i]|0
  if(c <= 0) {
    return []
  }
  var result = new Array(c), j
  if(i === count.length-1) {
    for(j=0; j<c; ++j) {
      result[j] = value
    }
  } else {
    for(j=0; j<c; ++j) {
      result[j] = dupe_array(count, value, i+1)
    }
  }
  return result
}

function dupe_number(count, value) {
  var result, i
  result = new Array(count)
  for(i=0; i<count; ++i) {
    result[i] = value
  }
  return result
}

function dupe(count, value) {
  if(typeof value === "undefined") {
    value = 0
  }
  switch(typeof count) {
    case "number":
      if(count > 0) {
        return dupe_number(count|0, value)
      }
    break
    case "object":
      if(typeof (count.length) === "number") {
        return dupe_array(count, value, 0)
      }
    break
  }
  return []
}

module.exports = dupe
},{}],10:[function(require,module,exports){
(function (global,Buffer){
'use strict'

var bits = require('bit-twiddle')
var dup = require('dup')

//Legacy pool support
if(!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
      UINT8   : dup([32, 0])
    , UINT16  : dup([32, 0])
    , UINT32  : dup([32, 0])
    , INT8    : dup([32, 0])
    , INT16   : dup([32, 0])
    , INT32   : dup([32, 0])
    , FLOAT   : dup([32, 0])
    , DOUBLE  : dup([32, 0])
    , DATA    : dup([32, 0])
    , UINT8C  : dup([32, 0])
    , BUFFER  : dup([32, 0])
  }
}

var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'
var POOL = global.__TYPEDARRAY_POOL

//Upgrade pool
if(!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0])
}
if(!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0])
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA    = POOL.DATA
  , BUFFER  = POOL.BUFFER

exports.free = function free(array) {
  if(Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array)
  } else {
    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer
    }
    if(!array) {
      return
    }
    var n = array.length || array.byteLength
    var log_n = bits.log2(n)|0
    DATA[log_n].push(array)
  }
}

function freeArrayBuffer(buffer) {
  if(!buffer) {
    return
  }
  var n = buffer.length || buffer.byteLength
  var log_n = bits.log2(n)
  DATA[log_n].push(buffer)
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer)
}

exports.freeUint8 =
exports.freeUint16 =
exports.freeUint32 =
exports.freeInt8 =
exports.freeInt16 =
exports.freeInt32 =
exports.freeFloat32 = 
exports.freeFloat =
exports.freeFloat64 = 
exports.freeDouble = 
exports.freeUint8Clamped = 
exports.freeDataView = freeTypedArray

exports.freeArrayBuffer = freeArrayBuffer

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array)
}

exports.malloc = function malloc(n, dtype) {
  if(dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n)
  } else {
    switch(dtype) {
      case 'uint8':
        return mallocUint8(n)
      case 'uint16':
        return mallocUint16(n)
      case 'uint32':
        return mallocUint32(n)
      case 'int8':
        return mallocInt8(n)
      case 'int16':
        return mallocInt16(n)
      case 'int32':
        return mallocInt32(n)
      case 'float':
      case 'float32':
        return mallocFloat(n)
      case 'double':
      case 'float64':
        return mallocDouble(n)
      case 'uint8_clamped':
        return mallocUint8Clamped(n)
      case 'buffer':
        return mallocBuffer(n)
      case 'data':
      case 'dataview':
        return mallocDataView(n)

      default:
        return null
    }
  }
  return null
}

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var d = DATA[log_n]
  if(d.length > 0) {
    return d.pop()
  }
  return new ArrayBuffer(n)
}
exports.mallocArrayBuffer = mallocArrayBuffer

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocUint8 = mallocUint8

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocUint16 = mallocUint16

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocUint32 = mallocUint32

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocInt8 = mallocInt8

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocInt16 = mallocInt16

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocInt32 = mallocInt32

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8*n), 0, n)
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble

function mallocUint8Clamped(n) {
  if(hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
  } else {
    return mallocUint8(n)
  }
}
exports.mallocUint8Clamped = mallocUint8Clamped

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n)
}
exports.mallocDataView = mallocDataView

function mallocBuffer(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = BUFFER[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Buffer(n)
}
exports.mallocBuffer = mallocBuffer

exports.clearCache = function clearCache() {
  for(var i=0; i<32; ++i) {
    POOL.UINT8[i].length = 0
    POOL.UINT16[i].length = 0
    POOL.UINT32[i].length = 0
    POOL.INT8[i].length = 0
    POOL.INT16[i].length = 0
    POOL.INT32[i].length = 0
    POOL.FLOAT[i].length = 0
    POOL.DOUBLE[i].length = 0
    POOL.UINT8C[i].length = 0
    DATA[i].length = 0
    BUFFER[i].length = 0
  }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"bit-twiddle":8,"buffer":12,"dup":9}],11:[function(require,module,exports){

},{}],12:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length, 2)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length, unitSize) {
  if (unitSize) length -= length % unitSize;
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":13,"ieee754":14,"is-array":15}],13:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],14:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],15:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],16:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":17}],17:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canMutationObserver = typeof window !== 'undefined'
    && window.MutationObserver;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    var queue = [];

    if (canMutationObserver) {
        var hiddenDiv = document.createElement("div");
        var observer = new MutationObserver(function () {
            var queueList = queue.slice();
            queue.length = 0;
            queueList.forEach(function (fn) {
                fn();
            });
        });

        observer.observe(hiddenDiv, { attributes: true });

        return function nextTick(fn) {
            if (!queue.length) {
                hiddenDiv.setAttribute('yes', 'no');
            }
            queue.push(fn);
        };
    }

    if (canPost) {
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],18:[function(require,module,exports){
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
  "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
  "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
  "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
  "beige": [245,245,220,1], "bisque": [255,228,196,1],
  "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
  "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
  "brown": [165,42,42,1], "burlywood": [222,184,135,1],
  "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
  "chocolate": [210,105,30,1], "coral": [255,127,80,1],
  "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
  "crimson": [220,20,60,1], "cyan": [0,255,255,1],
  "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
  "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
  "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
  "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
  "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
  "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
  "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
  "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
  "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
  "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
  "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
  "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
  "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
  "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
  "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
  "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
  "gray": [128,128,128,1], "green": [0,128,0,1],
  "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
  "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
  "indianred": [205,92,92,1], "indigo": [75,0,130,1],
  "ivory": [255,255,240,1], "khaki": [240,230,140,1],
  "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
  "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
  "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
  "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
  "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
  "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
  "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
  "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
  "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
  "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
  "limegreen": [50,205,50,1], "linen": [250,240,230,1],
  "magenta": [255,0,255,1], "maroon": [128,0,0,1],
  "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
  "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
  "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
  "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
  "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
  "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
  "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
  "navy": [0,0,128,1], "oldlace": [253,245,230,1],
  "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
  "orange": [255,165,0,1], "orangered": [255,69,0,1],
  "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
  "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
  "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
  "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
  "pink": [255,192,203,1], "plum": [221,160,221,1],
  "powderblue": [176,224,230,1], "purple": [128,0,128,1],
  "red": [255,0,0,1], "rosybrown": [188,143,143,1],
  "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
  "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
  "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
  "sienna": [160,82,45,1], "silver": [192,192,192,1],
  "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
  "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
  "snow": [255,250,250,1], "springgreen": [0,255,127,1],
  "steelblue": [70,130,180,1], "tan": [210,180,140,1],
  "teal": [0,128,128,1], "thistle": [216,191,216,1],
  "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
  "violet": [238,130,238,1], "wheat": [245,222,179,1],
  "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
  "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]}

function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parse_css_int(str) {  // int or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_byte(parseFloat(str) / 100 * 255);
  return clamp_css_byte(parseInt(str));
}

function parse_css_float(str) {  // float or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_float(parseFloat(str) / 100);
  return clamp_css_float(parseFloat(str));
}

function css_hue_to_rgb(m1, m2, h) {
  if (h < 0) h += 1;
  else if (h > 1) h -= 1;

  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
  if (h * 2 < 1) return m2;
  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
  return m1;
}

function parseCSSColor(css_str) {
  // Remove all whitespace, not compliant, but should just be more accepting.
  var str = css_str.replace(/ /g, '').toLowerCase();

  // Color keywords (and transparent) lookup.
  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

  // #abc and #abc123 syntax.
  if (str[0] === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
              (iv & 0xf0) | ((iv & 0xf0) >> 4),
              (iv & 0xf) | ((iv & 0xf) << 4),
              1];
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
      return [(iv & 0xff0000) >> 16,
              (iv & 0xff00) >> 8,
              iv & 0xff,
              1];
    }

    return null;
  }

  var op = str.indexOf('('), ep = str.indexOf(')');
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op+1, ep-(op+1)).split(',');
    var alpha = 1;  // To allow case fallthrough.
    switch (fname) {
      case 'rgba':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'rgb':
        if (params.length !== 3) return null;
        return [parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha];
      case 'hsla':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'hsl':
        if (params.length !== 3) return null;
        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
        // NOTE(deanm): According to the CSS spec s/l should only be
        // percentages, but we don't bother and let float or percentage.
        var s = parse_css_float(params[1]);
        var l = parse_css_float(params[2]);
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var m1 = l * 2 - m2;
        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                alpha];
      default:
        return null;
    }
  }

  return null;
}

try { exports.parseCSSColor = parseCSSColor } catch(e) { }

},{}],19:[function(require,module,exports){
'use strict';

module.exports = earcut;

function earcut(points) {

    var outerNode = linkedList(points[0], true),
        node, minX, minY, maxX, maxY, x, y, size,
        len = 0,
        threshold = 80;

    for (var i = 0; len < threshold && i < points.length; i++) len += points[i].length;

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (len >= threshold) {
        node = outerNode.next;
        minX = maxX = node.p[0];
        minY = maxY = node.p[1];
        do {
            x = node.p[0];
            y = node.p[1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            node = node.next;
        } while (node !== outerNode);

        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }

    if (points.length > 1) outerNode = eliminateHoles(points, outerNode);

    var triangles = [];
    if (outerNode) earcutLinked(outerNode, triangles, minX, minY, size);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(points, clockwise) {
    var sum = 0,
        len = points.length,
        i, j, last;

    // calculate original winding order of a polygon ring
    for (i = 0, j = len - 1; i < len; j = i++) {
        var p1 = points[i],
            p2 = points[j];
        sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);
    }

    // link points into circular doubly-linked list in the specified winding order
    if (clockwise === (sum > 0)) {
        for (i = 0; i < len; i++) last = insertNode(points[i], last);
    } else {
        for (i = len - 1; i >= 0; i--) last = insertNode(points[i], last);
    }

    return last;
}

function filterPoints(start) {
    // eliminate colinear or duplicate points
    var node = start,
        again;
    do {
        again = false;

        if (equals(node.p, node.next.p) || orient(node.prev.p, node.p, node.next.p) === 0) {

            node.prev.next = node.next;
            node.next.prev = node.prev;

            if (node.prevZ) node.prevZ.nextZ = node.nextZ;
            if (node.nextZ) node.nextZ.prevZ = node.prevZ;

            node = start = node.prev;

            if (node === node.next) return null;
            again = true;

        } else {
            node = node.next;
        }
    } while (again || node !== start);

    return start;
}

function earcutLinked(ear, triangles, minX, minY, size, secondPass) {
    ear = filterPoints(ear);
    if (!ear) return;

    if (!secondPass && minX !== undefined) indexCurve(ear, minX, minY, size);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (isEar(ear, minX, minY, size)) {
            triangles.push(prev.p, ear.p, next.p);

            next.prev = prev;
            prev.next = next;

            if (ear.prevZ) ear.prevZ.nextZ = ear.nextZ;
            if (ear.nextZ) ear.nextZ.prevZ = ear.prevZ;

            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        if (ear === stop) {
            // if we can't find any more ears, try filtering points and cutting again
            if (!secondPass) earcutLinked(ear, triangles, minX, minY, size, true);
            // if this didn't work, try splitting the remaining polygon into two
            else splitEarcut(ear, triangles, minX, minY, size);
            break;
        }
    }
}

function isEar(ear, minX, minY, size) {

    var a = ear.prev.p,
        b = ear.p,
        c = ear.next.p,

        ax = a[0], bx = b[0], cx = c[0],
        ay = a[1], by = b[1], cy = c[1],

        abd = ax * by - ay * bx,
        acd = ax * cy - ay * cx,
        cbd = cx * by - cy * bx,
        A = abd - acd - cbd;

    if (A <= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear

    var cay = cy - ay,
        acx = ax - cx,
        aby = ay - by,
        bax = bx - ax,
        p, px, py, s, t, k, node;

    // if we use z-order curve hashing, iterate through the curve
    if (minX !== undefined) {

        // triangle bbox; min & max are calculated like this for speed
        var minTX = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
            minTY = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
            maxTX = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
            maxTY = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy),

            // z-order range for the current triangle bbox;
            minZ = zOrder(minTX, minTY, minX, minY, size),
            maxZ = zOrder(maxTX, maxTY, minX, minY, size);

        // first look for points inside the triangle in increasing z-order
        node = ear.nextZ;

        while (node && node.z <= maxZ) {
            p = node.p;
            node = node.nextZ;
            if (p === a || p === c) continue;

            px = p[0];
            py = p[1];

            s = cay * px + acx * py - acd;
            if (s >= 0) {
                t = aby * px + bax * py + abd;
                if (t >= 0) {
                    k = A - s - t;
                    if ((k >= 0) && ((s && t) || (s && k) || (t && k))) return false;
                }
            }
        }

        // then look for points in decreasing z-order
        node = ear.prevZ;

        while (node && node.z >= minZ) {
            p = node.p;
            node = node.prevZ;
            if (p === a || p === c) continue;

            px = p[0];
            py = p[1];

            s = cay * px + acx * py - acd;
            if (s >= 0) {
                t = aby * px + bax * py + abd;
                if (t >= 0) {
                    k = A - s - t;
                    if ((k >= 0) && ((s && t) || (s && k) || (t && k))) return false;
                }
            }
        }

    // if we don't use z-order curve hash, simply iterate through all other points
    } else {
        node = ear.next.next;

        while (node !== ear.prev) {
            p = node.p;
            node = node.next;

            px = p[0];
            py = p[1];

            s = cay * px + acx * py - acd;
            if (s >= 0) {
                t = aby * px + bax * py + abd;
                if (t >= 0) {
                    k = A - s - t;
                    if ((k >= 0) && ((s && t) || (s && k) || (t && k))) return false;
                }
            }
        }
    }

    return true;
}

function splitEarcut(start, triangles, minX, minY, size) {
    // find a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // run earcut on each half
                earcutLinked(a, triangles, minX, minY, size);
                earcutLinked(c, triangles, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

function eliminateHoles(points, outerNode) {
    var len = points.length;

    var queue = [];
    for (var i = 1; i < len; i++) {
        var list = filterPoints(linkedList(points[i], false));
        if (list) queue.push(getLeftmost(list));
    }
    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode);
    }

    return outerNode;
}

function eliminateHole(holeNode, outerNode) {
    outerNode = findHoleBridge(holeNode, outerNode);
    if (outerNode) splitPolygon(holeNode, outerNode);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(holeNode, outerNode) {
    var node = outerNode,
        p = holeNode.p,
        px = p[0],
        py = p[1],
        qMax = -Infinity,
        mNode, a, b;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        a = node.p;
        b = node.next.p;

        if (py <= a[1] && py >= b[1]) {
            var qx = a[0] + (py - a[1]) * (b[0] - a[0]) / (b[1] - a[1]);
            if (qx <= px && qx > qMax) {
                qMax = qx;
                mNode = a[0] < b[0] ? node : node.next;
            }
        }
        node = node.next;
    } while (node !== outerNode);

    if (!mNode) return null;

    // look for points strictly inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var bx = mNode.p[0],
        by = mNode.p[1],
        pbd = px * by - py * bx,
        pcd = px * py - py * qMax,
        cpy = py - py,
        pcx = px - qMax,
        pby = py - by,
        bpx = bx - px,
        A = pbd - pcd - (qMax * by - py * bx),
        sign = A <= 0 ? -1 : 1,
        stop = mNode,
        tanMin = Infinity,
        mx, my, amx, s, t, tan;

    node = mNode.next;

    while (node !== stop) {

        mx = node.p[0];
        my = node.p[1];
        amx = px - mx;

        if (amx >= 0 && mx >= bx) {
            s = (cpy * mx + pcx * my - pcd) * sign;
            if (s >= 0) {
                t = (pby * mx + bpx * my + pbd) * sign;

                if (t >= 0 && A * sign - s - t >= 0) {
                    tan = Math.abs(py - my) / amx; // tangential
                    if (tan < tanMin && locallyInside(node, holeNode)) {
                        mNode = node;
                        tanMin = tan;
                    }
                }
            }
        }

        node = node.next;
    }

    return mNode;
}

function indexCurve(start, minX, minY, size) {
    var node = start;

    do {
        node.z = node.z || zOrder(node.p[0], node.p[1], minX, minY, size);
        node.prevZ = node.prev;
        node.nextZ = node.next;
        node = node.next;
    } while (node !== start);

    node.prevZ.nextZ = null;
    node.prevZ = null;

    sortLinked(node);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    while (true) {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }

            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize === 0) {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                } else if (qSize === 0 || !q) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else if (p.z <= q.z) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;

        if (numMerges <= 1) return list;

        inSize *= 2;
    }
}

// z-order of a point given coords and bbox
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into (0..1000) integer range
    x = 1000 * (x - minX) / size;
    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = 1000 * (y - minY) / size;
    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

function getLeftmost(start) {
    var node = start,
        leftmost = start;
    do {
        if (node.p[0] < leftmost.p[0]) leftmost = node;
        node = node.next;
    } while (node !== start);

    return leftmost;
}

function isValidDiagonal(a, b) {
    return !intersectsPolygon(a, a.p, b.p) &&
           locallyInside(a, b) && locallyInside(b, a) &&
           middleInside(a, a.p, b.p);
}

// winding order of triangle formed by 3 given points
function orient(p, q, r) {
    var o = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
    return o > 0 ? 1 :
           o < 0 ? -1 : 0;
}

function equals(p1, p2) {
    return p1[0] === p2[0] && p1[1] === p2[1];
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    return orient(p1, q1, p2) !== orient(p1, q1, q2) &&
           orient(p2, q2, p1) !== orient(p2, q2, q1);
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(start, a, b) {
    var node = start;
    do {
        var p1 = node.p,
            p2 = node.next.p;

        if (p1 !== a && p2 !== a && p1 !== b && p2 !== b && intersects(p1, p2, a, b)) return true;

        node = node.next;
    } while (node !== start);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return orient(a.prev.p, a.p, a.next.p) === -1 ?
        orient(a.p, b.p, a.next.p) !== -1 && orient(a.p, a.prev.p, b.p) !== -1 :
        orient(a.p, b.p, a.prev.p) === -1 || orient(a.p, a.next.p, b.p) === -1;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(start, a, b) {
    var node = start,
        inside = false,
        px = (a[0] + b[0]) / 2,
        py = (a[1] + b[1]) / 2;
    do {
        var p1 = node.p,
            p2 = node.next.p;

        if (((p1[1] > py) !== (p2[1] > py)) &&
            (px < (p2[0] - p1[0]) * (py - p1[1]) / (p2[1] - p1[1]) + p1[0])) inside = !inside;

        node = node.next;
    } while (node !== start);

    return inside;
}

function compareX(a, b) {
    return a.p[0] - b.p[0];
}

// split the polygon vertices circular doubly-linked linked list into two
function splitPolygon(a, b) {
    var a2 = new Node(a.p),
        b2 = new Node(b.p),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return a2;
}

function insertNode(point, last) {
    var node = new Node(point);

    if (!last) {
        node.prev = node;
        node.next = node;

    } else {
        node.next = last.next;
        node.prev = last;
        last.next.prev = node;
        last.next = node;
    }
    return node;
}

function Node(p) {
    this.p = p;
    this.prev = null;
    this.next = null;

    this.z = null;
    this.prevZ = null;
    this.nextZ = null;
}

},{}],20:[function(require,module,exports){
(function (process,global){
(function(global) {
  'use strict';
  if (global.$traceurRuntime) {
    return;
  }
  var $Object = Object;
  var $TypeError = TypeError;
  var $create = $Object.create;
  var $defineProperties = $Object.defineProperties;
  var $defineProperty = $Object.defineProperty;
  var $freeze = $Object.freeze;
  var $getOwnPropertyDescriptor = $Object.getOwnPropertyDescriptor;
  var $getOwnPropertyNames = $Object.getOwnPropertyNames;
  var $keys = $Object.keys;
  var $hasOwnProperty = $Object.prototype.hasOwnProperty;
  var $toString = $Object.prototype.toString;
  var $preventExtensions = Object.preventExtensions;
  var $seal = Object.seal;
  var $isExtensible = Object.isExtensible;
  function nonEnum(value) {
    return {
      configurable: true,
      enumerable: false,
      value: value,
      writable: true
    };
  }
  var method = nonEnum;
  var counter = 0;
  function newUniqueString() {
    return '__$' + Math.floor(Math.random() * 1e9) + '$' + ++counter + '$__';
  }
  var symbolInternalProperty = newUniqueString();
  var symbolDescriptionProperty = newUniqueString();
  var symbolDataProperty = newUniqueString();
  var symbolValues = $create(null);
  var privateNames = $create(null);
  function isPrivateName(s) {
    return privateNames[s];
  }
  function createPrivateName() {
    var s = newUniqueString();
    privateNames[s] = true;
    return s;
  }
  function isShimSymbol(symbol) {
    return typeof symbol === 'object' && symbol instanceof SymbolValue;
  }
  function typeOf(v) {
    if (isShimSymbol(v))
      return 'symbol';
    return typeof v;
  }
  function Symbol(description) {
    var value = new SymbolValue(description);
    if (!(this instanceof Symbol))
      return value;
    throw new TypeError('Symbol cannot be new\'ed');
  }
  $defineProperty(Symbol.prototype, 'constructor', nonEnum(Symbol));
  $defineProperty(Symbol.prototype, 'toString', method(function() {
    var symbolValue = this[symbolDataProperty];
    if (!getOption('symbols'))
      return symbolValue[symbolInternalProperty];
    if (!symbolValue)
      throw TypeError('Conversion from symbol to string');
    var desc = symbolValue[symbolDescriptionProperty];
    if (desc === undefined)
      desc = '';
    return 'Symbol(' + desc + ')';
  }));
  $defineProperty(Symbol.prototype, 'valueOf', method(function() {
    var symbolValue = this[symbolDataProperty];
    if (!symbolValue)
      throw TypeError('Conversion from symbol to string');
    if (!getOption('symbols'))
      return symbolValue[symbolInternalProperty];
    return symbolValue;
  }));
  function SymbolValue(description) {
    var key = newUniqueString();
    $defineProperty(this, symbolDataProperty, {value: this});
    $defineProperty(this, symbolInternalProperty, {value: key});
    $defineProperty(this, symbolDescriptionProperty, {value: description});
    freeze(this);
    symbolValues[key] = this;
  }
  $defineProperty(SymbolValue.prototype, 'constructor', nonEnum(Symbol));
  $defineProperty(SymbolValue.prototype, 'toString', {
    value: Symbol.prototype.toString,
    enumerable: false
  });
  $defineProperty(SymbolValue.prototype, 'valueOf', {
    value: Symbol.prototype.valueOf,
    enumerable: false
  });
  var hashProperty = createPrivateName();
  var hashPropertyDescriptor = {value: undefined};
  var hashObjectProperties = {
    hash: {value: undefined},
    self: {value: undefined}
  };
  var hashCounter = 0;
  function getOwnHashObject(object) {
    var hashObject = object[hashProperty];
    if (hashObject && hashObject.self === object)
      return hashObject;
    if ($isExtensible(object)) {
      hashObjectProperties.hash.value = hashCounter++;
      hashObjectProperties.self.value = object;
      hashPropertyDescriptor.value = $create(null, hashObjectProperties);
      $defineProperty(object, hashProperty, hashPropertyDescriptor);
      return hashPropertyDescriptor.value;
    }
    return undefined;
  }
  function freeze(object) {
    getOwnHashObject(object);
    return $freeze.apply(this, arguments);
  }
  function preventExtensions(object) {
    getOwnHashObject(object);
    return $preventExtensions.apply(this, arguments);
  }
  function seal(object) {
    getOwnHashObject(object);
    return $seal.apply(this, arguments);
  }
  freeze(SymbolValue.prototype);
  function isSymbolString(s) {
    return symbolValues[s] || privateNames[s];
  }
  function toProperty(name) {
    if (isShimSymbol(name))
      return name[symbolInternalProperty];
    return name;
  }
  function removeSymbolKeys(array) {
    var rv = [];
    for (var i = 0; i < array.length; i++) {
      if (!isSymbolString(array[i])) {
        rv.push(array[i]);
      }
    }
    return rv;
  }
  function getOwnPropertyNames(object) {
    return removeSymbolKeys($getOwnPropertyNames(object));
  }
  function keys(object) {
    return removeSymbolKeys($keys(object));
  }
  function getOwnPropertySymbols(object) {
    var rv = [];
    var names = $getOwnPropertyNames(object);
    for (var i = 0; i < names.length; i++) {
      var symbol = symbolValues[names[i]];
      if (symbol) {
        rv.push(symbol);
      }
    }
    return rv;
  }
  function getOwnPropertyDescriptor(object, name) {
    return $getOwnPropertyDescriptor(object, toProperty(name));
  }
  function hasOwnProperty(name) {
    return $hasOwnProperty.call(this, toProperty(name));
  }
  function getOption(name) {
    return global.traceur && global.traceur.options[name];
  }
  function defineProperty(object, name, descriptor) {
    if (isShimSymbol(name)) {
      name = name[symbolInternalProperty];
    }
    $defineProperty(object, name, descriptor);
    return object;
  }
  function polyfillObject(Object) {
    $defineProperty(Object, 'defineProperty', {value: defineProperty});
    $defineProperty(Object, 'getOwnPropertyNames', {value: getOwnPropertyNames});
    $defineProperty(Object, 'getOwnPropertyDescriptor', {value: getOwnPropertyDescriptor});
    $defineProperty(Object.prototype, 'hasOwnProperty', {value: hasOwnProperty});
    $defineProperty(Object, 'freeze', {value: freeze});
    $defineProperty(Object, 'preventExtensions', {value: preventExtensions});
    $defineProperty(Object, 'seal', {value: seal});
    $defineProperty(Object, 'keys', {value: keys});
  }
  function exportStar(object) {
    for (var i = 1; i < arguments.length; i++) {
      var names = $getOwnPropertyNames(arguments[i]);
      for (var j = 0; j < names.length; j++) {
        var name = names[j];
        if (isSymbolString(name))
          continue;
        (function(mod, name) {
          $defineProperty(object, name, {
            get: function() {
              return mod[name];
            },
            enumerable: true
          });
        })(arguments[i], names[j]);
      }
    }
    return object;
  }
  function isObject(x) {
    return x != null && (typeof x === 'object' || typeof x === 'function');
  }
  function toObject(x) {
    if (x == null)
      throw $TypeError();
    return $Object(x);
  }
  function checkObjectCoercible(argument) {
    if (argument == null) {
      throw new TypeError('Value cannot be converted to an Object');
    }
    return argument;
  }
  function polyfillSymbol(global, Symbol) {
    if (!global.Symbol) {
      global.Symbol = Symbol;
      Object.getOwnPropertySymbols = getOwnPropertySymbols;
    }
    if (!global.Symbol.iterator) {
      global.Symbol.iterator = Symbol('Symbol.iterator');
    }
  }
  function setupGlobals(global) {
    polyfillSymbol(global, Symbol);
    global.Reflect = global.Reflect || {};
    global.Reflect.global = global.Reflect.global || global;
    polyfillObject(global.Object);
  }
  setupGlobals(global);
  global.$traceurRuntime = {
    checkObjectCoercible: checkObjectCoercible,
    createPrivateName: createPrivateName,
    defineProperties: $defineProperties,
    defineProperty: $defineProperty,
    exportStar: exportStar,
    getOwnHashObject: getOwnHashObject,
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    getOwnPropertyNames: $getOwnPropertyNames,
    isObject: isObject,
    isPrivateName: isPrivateName,
    isSymbolString: isSymbolString,
    keys: $keys,
    setupGlobals: setupGlobals,
    toObject: toObject,
    toProperty: toProperty,
    typeof: typeOf
  };
})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this);
(function() {
  'use strict';
  var path;
  function relativeRequire(callerPath, requiredPath) {
    path = path || typeof require !== 'undefined' && require('path');
    function isDirectory(path) {
      return path.slice(-1) === '/';
    }
    function isAbsolute(path) {
      return path[0] === '/';
    }
    function isRelative(path) {
      return path[0] === '.';
    }
    if (isDirectory(requiredPath) || isAbsolute(requiredPath))
      return;
    return isRelative(requiredPath) ? require(path.resolve(path.dirname(callerPath), requiredPath)) : require(requiredPath);
  }
  $traceurRuntime.require = relativeRequire;
})();
(function() {
  'use strict';
  function spread() {
    var rv = [],
        j = 0,
        iterResult;
    for (var i = 0; i < arguments.length; i++) {
      var valueToSpread = $traceurRuntime.checkObjectCoercible(arguments[i]);
      if (typeof valueToSpread[$traceurRuntime.toProperty(Symbol.iterator)] !== 'function') {
        throw new TypeError('Cannot spread non-iterable object.');
      }
      var iter = valueToSpread[$traceurRuntime.toProperty(Symbol.iterator)]();
      while (!(iterResult = iter.next()).done) {
        rv[j++] = iterResult.value;
      }
    }
    return rv;
  }
  $traceurRuntime.spread = spread;
})();
(function() {
  'use strict';
  var $Object = Object;
  var $TypeError = TypeError;
  var $create = $Object.create;
  var $defineProperties = $traceurRuntime.defineProperties;
  var $defineProperty = $traceurRuntime.defineProperty;
  var $getOwnPropertyDescriptor = $traceurRuntime.getOwnPropertyDescriptor;
  var $getOwnPropertyNames = $traceurRuntime.getOwnPropertyNames;
  var $getPrototypeOf = Object.getPrototypeOf;
  var $__0 = Object,
      getOwnPropertyNames = $__0.getOwnPropertyNames,
      getOwnPropertySymbols = $__0.getOwnPropertySymbols;
  function superDescriptor(homeObject, name) {
    var proto = $getPrototypeOf(homeObject);
    do {
      var result = $getOwnPropertyDescriptor(proto, name);
      if (result)
        return result;
      proto = $getPrototypeOf(proto);
    } while (proto);
    return undefined;
  }
  function superConstructor(ctor) {
    return ctor.__proto__;
  }
  function superCall(self, homeObject, name, args) {
    return superGet(self, homeObject, name).apply(self, args);
  }
  function superGet(self, homeObject, name) {
    var descriptor = superDescriptor(homeObject, name);
    if (descriptor) {
      if (!descriptor.get)
        return descriptor.value;
      return descriptor.get.call(self);
    }
    return undefined;
  }
  function superSet(self, homeObject, name, value) {
    var descriptor = superDescriptor(homeObject, name);
    if (descriptor && descriptor.set) {
      descriptor.set.call(self, value);
      return value;
    }
    throw $TypeError(("super has no setter '" + name + "'."));
  }
  function getDescriptors(object) {
    var descriptors = {};
    var names = getOwnPropertyNames(object);
    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      descriptors[name] = $getOwnPropertyDescriptor(object, name);
    }
    var symbols = getOwnPropertySymbols(object);
    for (var i = 0; i < symbols.length; i++) {
      var symbol = symbols[i];
      descriptors[$traceurRuntime.toProperty(symbol)] = $getOwnPropertyDescriptor(object, $traceurRuntime.toProperty(symbol));
    }
    return descriptors;
  }
  function createClass(ctor, object, staticObject, superClass) {
    $defineProperty(object, 'constructor', {
      value: ctor,
      configurable: true,
      enumerable: false,
      writable: true
    });
    if (arguments.length > 3) {
      if (typeof superClass === 'function')
        ctor.__proto__ = superClass;
      ctor.prototype = $create(getProtoParent(superClass), getDescriptors(object));
    } else {
      ctor.prototype = object;
    }
    $defineProperty(ctor, 'prototype', {
      configurable: false,
      writable: false
    });
    return $defineProperties(ctor, getDescriptors(staticObject));
  }
  function getProtoParent(superClass) {
    if (typeof superClass === 'function') {
      var prototype = superClass.prototype;
      if ($Object(prototype) === prototype || prototype === null)
        return superClass.prototype;
      throw new $TypeError('super prototype must be an Object or null');
    }
    if (superClass === null)
      return null;
    throw new $TypeError(("Super expression must either be null or a function, not " + typeof superClass + "."));
  }
  function defaultSuperCall(self, homeObject, args) {
    if ($getPrototypeOf(homeObject) !== null)
      superCall(self, homeObject, 'constructor', args);
  }
  $traceurRuntime.createClass = createClass;
  $traceurRuntime.defaultSuperCall = defaultSuperCall;
  $traceurRuntime.superCall = superCall;
  $traceurRuntime.superConstructor = superConstructor;
  $traceurRuntime.superGet = superGet;
  $traceurRuntime.superSet = superSet;
})();
(function() {
  'use strict';
  if (typeof $traceurRuntime !== 'object') {
    throw new Error('traceur runtime not found.');
  }
  var createPrivateName = $traceurRuntime.createPrivateName;
  var $defineProperties = $traceurRuntime.defineProperties;
  var $defineProperty = $traceurRuntime.defineProperty;
  var $create = Object.create;
  var $TypeError = TypeError;
  function nonEnum(value) {
    return {
      configurable: true,
      enumerable: false,
      value: value,
      writable: true
    };
  }
  var ST_NEWBORN = 0;
  var ST_EXECUTING = 1;
  var ST_SUSPENDED = 2;
  var ST_CLOSED = 3;
  var END_STATE = -2;
  var RETHROW_STATE = -3;
  function getInternalError(state) {
    return new Error('Traceur compiler bug: invalid state in state machine: ' + state);
  }
  function GeneratorContext() {
    this.state = 0;
    this.GState = ST_NEWBORN;
    this.storedException = undefined;
    this.finallyFallThrough = undefined;
    this.sent_ = undefined;
    this.returnValue = undefined;
    this.tryStack_ = [];
  }
  GeneratorContext.prototype = {
    pushTry: function(catchState, finallyState) {
      if (finallyState !== null) {
        var finallyFallThrough = null;
        for (var i = this.tryStack_.length - 1; i >= 0; i--) {
          if (this.tryStack_[i].catch !== undefined) {
            finallyFallThrough = this.tryStack_[i].catch;
            break;
          }
        }
        if (finallyFallThrough === null)
          finallyFallThrough = RETHROW_STATE;
        this.tryStack_.push({
          finally: finallyState,
          finallyFallThrough: finallyFallThrough
        });
      }
      if (catchState !== null) {
        this.tryStack_.push({catch: catchState});
      }
    },
    popTry: function() {
      this.tryStack_.pop();
    },
    get sent() {
      this.maybeThrow();
      return this.sent_;
    },
    set sent(v) {
      this.sent_ = v;
    },
    get sentIgnoreThrow() {
      return this.sent_;
    },
    maybeThrow: function() {
      if (this.action === 'throw') {
        this.action = 'next';
        throw this.sent_;
      }
    },
    end: function() {
      switch (this.state) {
        case END_STATE:
          return this;
        case RETHROW_STATE:
          throw this.storedException;
        default:
          throw getInternalError(this.state);
      }
    },
    handleException: function(ex) {
      this.GState = ST_CLOSED;
      this.state = END_STATE;
      throw ex;
    }
  };
  function nextOrThrow(ctx, moveNext, action, x) {
    switch (ctx.GState) {
      case ST_EXECUTING:
        throw new Error(("\"" + action + "\" on executing generator"));
      case ST_CLOSED:
        if (action == 'next') {
          return {
            value: undefined,
            done: true
          };
        }
        throw x;
      case ST_NEWBORN:
        if (action === 'throw') {
          ctx.GState = ST_CLOSED;
          throw x;
        }
        if (x !== undefined)
          throw $TypeError('Sent value to newborn generator');
      case ST_SUSPENDED:
        ctx.GState = ST_EXECUTING;
        ctx.action = action;
        ctx.sent = x;
        var value = moveNext(ctx);
        var done = value === ctx;
        if (done)
          value = ctx.returnValue;
        ctx.GState = done ? ST_CLOSED : ST_SUSPENDED;
        return {
          value: value,
          done: done
        };
    }
  }
  var ctxName = createPrivateName();
  var moveNextName = createPrivateName();
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  $defineProperty(GeneratorFunctionPrototype, 'constructor', nonEnum(GeneratorFunction));
  GeneratorFunctionPrototype.prototype = {
    constructor: GeneratorFunctionPrototype,
    next: function(v) {
      return nextOrThrow(this[ctxName], this[moveNextName], 'next', v);
    },
    throw: function(v) {
      return nextOrThrow(this[ctxName], this[moveNextName], 'throw', v);
    }
  };
  $defineProperties(GeneratorFunctionPrototype.prototype, {
    constructor: {enumerable: false},
    next: {enumerable: false},
    throw: {enumerable: false}
  });
  Object.defineProperty(GeneratorFunctionPrototype.prototype, Symbol.iterator, nonEnum(function() {
    return this;
  }));
  function createGeneratorInstance(innerFunction, functionObject, self) {
    var moveNext = getMoveNext(innerFunction, self);
    var ctx = new GeneratorContext();
    var object = $create(functionObject.prototype);
    object[ctxName] = ctx;
    object[moveNextName] = moveNext;
    return object;
  }
  function initGeneratorFunction(functionObject) {
    functionObject.prototype = $create(GeneratorFunctionPrototype.prototype);
    functionObject.__proto__ = GeneratorFunctionPrototype;
    return functionObject;
  }
  function AsyncFunctionContext() {
    GeneratorContext.call(this);
    this.err = undefined;
    var ctx = this;
    ctx.result = new Promise(function(resolve, reject) {
      ctx.resolve = resolve;
      ctx.reject = reject;
    });
  }
  AsyncFunctionContext.prototype = $create(GeneratorContext.prototype);
  AsyncFunctionContext.prototype.end = function() {
    switch (this.state) {
      case END_STATE:
        this.resolve(this.returnValue);
        break;
      case RETHROW_STATE:
        this.reject(this.storedException);
        break;
      default:
        this.reject(getInternalError(this.state));
    }
  };
  AsyncFunctionContext.prototype.handleException = function() {
    this.state = RETHROW_STATE;
  };
  function asyncWrap(innerFunction, self) {
    var moveNext = getMoveNext(innerFunction, self);
    var ctx = new AsyncFunctionContext();
    ctx.createCallback = function(newState) {
      return function(value) {
        ctx.state = newState;
        ctx.value = value;
        moveNext(ctx);
      };
    };
    ctx.errback = function(err) {
      handleCatch(ctx, err);
      moveNext(ctx);
    };
    moveNext(ctx);
    return ctx.result;
  }
  function getMoveNext(innerFunction, self) {
    return function(ctx) {
      while (true) {
        try {
          return innerFunction.call(self, ctx);
        } catch (ex) {
          handleCatch(ctx, ex);
        }
      }
    };
  }
  function handleCatch(ctx, ex) {
    ctx.storedException = ex;
    var last = ctx.tryStack_[ctx.tryStack_.length - 1];
    if (!last) {
      ctx.handleException(ex);
      return;
    }
    ctx.state = last.catch !== undefined ? last.catch : last.finally;
    if (last.finallyFallThrough !== undefined)
      ctx.finallyFallThrough = last.finallyFallThrough;
  }
  $traceurRuntime.asyncWrap = asyncWrap;
  $traceurRuntime.initGeneratorFunction = initGeneratorFunction;
  $traceurRuntime.createGeneratorInstance = createGeneratorInstance;
})();
(function() {
  function buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
    var out = [];
    if (opt_scheme) {
      out.push(opt_scheme, ':');
    }
    if (opt_domain) {
      out.push('//');
      if (opt_userInfo) {
        out.push(opt_userInfo, '@');
      }
      out.push(opt_domain);
      if (opt_port) {
        out.push(':', opt_port);
      }
    }
    if (opt_path) {
      out.push(opt_path);
    }
    if (opt_queryData) {
      out.push('?', opt_queryData);
    }
    if (opt_fragment) {
      out.push('#', opt_fragment);
    }
    return out.join('');
  }
  ;
  var splitRe = new RegExp('^' + '(?:' + '([^:/?#.]+)' + ':)?' + '(?://' + '(?:([^/?#]*)@)?' + '([\\w\\d\\-\\u0100-\\uffff.%]*)' + '(?::([0-9]+))?' + ')?' + '([^?#]+)?' + '(?:\\?([^#]*))?' + '(?:#(.*))?' + '$');
  var ComponentIndex = {
    SCHEME: 1,
    USER_INFO: 2,
    DOMAIN: 3,
    PORT: 4,
    PATH: 5,
    QUERY_DATA: 6,
    FRAGMENT: 7
  };
  function split(uri) {
    return (uri.match(splitRe));
  }
  function removeDotSegments(path) {
    if (path === '/')
      return '/';
    var leadingSlash = path[0] === '/' ? '/' : '';
    var trailingSlash = path.slice(-1) === '/' ? '/' : '';
    var segments = path.split('/');
    var out = [];
    var up = 0;
    for (var pos = 0; pos < segments.length; pos++) {
      var segment = segments[pos];
      switch (segment) {
        case '':
        case '.':
          break;
        case '..':
          if (out.length)
            out.pop();
          else
            up++;
          break;
        default:
          out.push(segment);
      }
    }
    if (!leadingSlash) {
      while (up-- > 0) {
        out.unshift('..');
      }
      if (out.length === 0)
        out.push('.');
    }
    return leadingSlash + out.join('/') + trailingSlash;
  }
  function joinAndCanonicalizePath(parts) {
    var path = parts[ComponentIndex.PATH] || '';
    path = removeDotSegments(path);
    parts[ComponentIndex.PATH] = path;
    return buildFromEncodedParts(parts[ComponentIndex.SCHEME], parts[ComponentIndex.USER_INFO], parts[ComponentIndex.DOMAIN], parts[ComponentIndex.PORT], parts[ComponentIndex.PATH], parts[ComponentIndex.QUERY_DATA], parts[ComponentIndex.FRAGMENT]);
  }
  function canonicalizeUrl(url) {
    var parts = split(url);
    return joinAndCanonicalizePath(parts);
  }
  function resolveUrl(base, url) {
    var parts = split(url);
    var baseParts = split(base);
    if (parts[ComponentIndex.SCHEME]) {
      return joinAndCanonicalizePath(parts);
    } else {
      parts[ComponentIndex.SCHEME] = baseParts[ComponentIndex.SCHEME];
    }
    for (var i = ComponentIndex.SCHEME; i <= ComponentIndex.PORT; i++) {
      if (!parts[i]) {
        parts[i] = baseParts[i];
      }
    }
    if (parts[ComponentIndex.PATH][0] == '/') {
      return joinAndCanonicalizePath(parts);
    }
    var path = baseParts[ComponentIndex.PATH];
    var index = path.lastIndexOf('/');
    path = path.slice(0, index + 1) + parts[ComponentIndex.PATH];
    parts[ComponentIndex.PATH] = path;
    return joinAndCanonicalizePath(parts);
  }
  function isAbsolute(name) {
    if (!name)
      return false;
    if (name[0] === '/')
      return true;
    var parts = split(name);
    if (parts[ComponentIndex.SCHEME])
      return true;
    return false;
  }
  $traceurRuntime.canonicalizeUrl = canonicalizeUrl;
  $traceurRuntime.isAbsolute = isAbsolute;
  $traceurRuntime.removeDotSegments = removeDotSegments;
  $traceurRuntime.resolveUrl = resolveUrl;
})();
(function() {
  'use strict';
  var types = {
    any: {name: 'any'},
    boolean: {name: 'boolean'},
    number: {name: 'number'},
    string: {name: 'string'},
    symbol: {name: 'symbol'},
    void: {name: 'void'}
  };
  var GenericType = function GenericType(type, argumentTypes) {
    this.type = type;
    this.argumentTypes = argumentTypes;
  };
  ($traceurRuntime.createClass)(GenericType, {}, {});
  var typeRegister = Object.create(null);
  function genericType(type) {
    for (var argumentTypes = [],
        $__1 = 1; $__1 < arguments.length; $__1++)
      argumentTypes[$__1 - 1] = arguments[$__1];
    var typeMap = typeRegister;
    var key = $traceurRuntime.getOwnHashObject(type).hash;
    if (!typeMap[key]) {
      typeMap[key] = Object.create(null);
    }
    typeMap = typeMap[key];
    for (var i = 0; i < argumentTypes.length - 1; i++) {
      key = $traceurRuntime.getOwnHashObject(argumentTypes[i]).hash;
      if (!typeMap[key]) {
        typeMap[key] = Object.create(null);
      }
      typeMap = typeMap[key];
    }
    var tail = argumentTypes[argumentTypes.length - 1];
    key = $traceurRuntime.getOwnHashObject(tail).hash;
    if (!typeMap[key]) {
      typeMap[key] = new GenericType(type, argumentTypes);
    }
    return typeMap[key];
  }
  $traceurRuntime.GenericType = GenericType;
  $traceurRuntime.genericType = genericType;
  $traceurRuntime.type = types;
})();
(function(global) {
  'use strict';
  var $__2 = $traceurRuntime,
      canonicalizeUrl = $__2.canonicalizeUrl,
      resolveUrl = $__2.resolveUrl,
      isAbsolute = $__2.isAbsolute;
  var moduleInstantiators = Object.create(null);
  var baseURL;
  if (global.location && global.location.href)
    baseURL = resolveUrl(global.location.href, './');
  else
    baseURL = '';
  var UncoatedModuleEntry = function UncoatedModuleEntry(url, uncoatedModule) {
    this.url = url;
    this.value_ = uncoatedModule;
  };
  ($traceurRuntime.createClass)(UncoatedModuleEntry, {}, {});
  var ModuleEvaluationError = function ModuleEvaluationError(erroneousModuleName, cause) {
    this.message = this.constructor.name + ': ' + this.stripCause(cause) + ' in ' + erroneousModuleName;
    if (!(cause instanceof $ModuleEvaluationError) && cause.stack)
      this.stack = this.stripStack(cause.stack);
    else
      this.stack = '';
  };
  var $ModuleEvaluationError = ModuleEvaluationError;
  ($traceurRuntime.createClass)(ModuleEvaluationError, {
    stripError: function(message) {
      return message.replace(/.*Error:/, this.constructor.name + ':');
    },
    stripCause: function(cause) {
      if (!cause)
        return '';
      if (!cause.message)
        return cause + '';
      return this.stripError(cause.message);
    },
    loadedBy: function(moduleName) {
      this.stack += '\n loaded by ' + moduleName;
    },
    stripStack: function(causeStack) {
      var stack = [];
      causeStack.split('\n').some((function(frame) {
        if (/UncoatedModuleInstantiator/.test(frame))
          return true;
        stack.push(frame);
      }));
      stack[0] = this.stripError(stack[0]);
      return stack.join('\n');
    }
  }, {}, Error);
  function beforeLines(lines, number) {
    var result = [];
    var first = number - 3;
    if (first < 0)
      first = 0;
    for (var i = first; i < number; i++) {
      result.push(lines[i]);
    }
    return result;
  }
  function afterLines(lines, number) {
    var last = number + 1;
    if (last > lines.length - 1)
      last = lines.length - 1;
    var result = [];
    for (var i = number; i <= last; i++) {
      result.push(lines[i]);
    }
    return result;
  }
  function columnSpacing(columns) {
    var result = '';
    for (var i = 0; i < columns - 1; i++) {
      result += '-';
    }
    return result;
  }
  var UncoatedModuleInstantiator = function UncoatedModuleInstantiator(url, func) {
    $traceurRuntime.superConstructor($UncoatedModuleInstantiator).call(this, url, null);
    this.func = func;
  };
  var $UncoatedModuleInstantiator = UncoatedModuleInstantiator;
  ($traceurRuntime.createClass)(UncoatedModuleInstantiator, {getUncoatedModule: function() {
      if (this.value_)
        return this.value_;
      try {
        var relativeRequire;
        if (typeof $traceurRuntime !== undefined) {
          relativeRequire = $traceurRuntime.require.bind(null, this.url);
        }
        return this.value_ = this.func.call(global, relativeRequire);
      } catch (ex) {
        if (ex instanceof ModuleEvaluationError) {
          ex.loadedBy(this.url);
          throw ex;
        }
        if (ex.stack) {
          var lines = this.func.toString().split('\n');
          var evaled = [];
          ex.stack.split('\n').some(function(frame) {
            if (frame.indexOf('UncoatedModuleInstantiator.getUncoatedModule') > 0)
              return true;
            var m = /(at\s[^\s]*\s).*>:(\d*):(\d*)\)/.exec(frame);
            if (m) {
              var line = parseInt(m[2], 10);
              evaled = evaled.concat(beforeLines(lines, line));
              evaled.push(columnSpacing(m[3]) + '^');
              evaled = evaled.concat(afterLines(lines, line));
              evaled.push('= = = = = = = = =');
            } else {
              evaled.push(frame);
            }
          });
          ex.stack = evaled.join('\n');
        }
        throw new ModuleEvaluationError(this.url, ex);
      }
    }}, {}, UncoatedModuleEntry);
  function getUncoatedModuleInstantiator(name) {
    if (!name)
      return;
    var url = ModuleStore.normalize(name);
    return moduleInstantiators[url];
  }
  ;
  var moduleInstances = Object.create(null);
  var liveModuleSentinel = {};
  function Module(uncoatedModule) {
    var isLive = arguments[1];
    var coatedModule = Object.create(null);
    Object.getOwnPropertyNames(uncoatedModule).forEach((function(name) {
      var getter,
          value;
      if (isLive === liveModuleSentinel) {
        var descr = Object.getOwnPropertyDescriptor(uncoatedModule, name);
        if (descr.get)
          getter = descr.get;
      }
      if (!getter) {
        value = uncoatedModule[name];
        getter = function() {
          return value;
        };
      }
      Object.defineProperty(coatedModule, name, {
        get: getter,
        enumerable: true
      });
    }));
    Object.preventExtensions(coatedModule);
    return coatedModule;
  }
  var ModuleStore = {
    normalize: function(name, refererName, refererAddress) {
      if (typeof name !== 'string')
        throw new TypeError('module name must be a string, not ' + typeof name);
      if (isAbsolute(name))
        return canonicalizeUrl(name);
      if (/[^\.]\/\.\.\//.test(name)) {
        throw new Error('module name embeds /../: ' + name);
      }
      if (name[0] === '.' && refererName)
        return resolveUrl(refererName, name);
      return canonicalizeUrl(name);
    },
    get: function(normalizedName) {
      var m = getUncoatedModuleInstantiator(normalizedName);
      if (!m)
        return undefined;
      var moduleInstance = moduleInstances[m.url];
      if (moduleInstance)
        return moduleInstance;
      moduleInstance = Module(m.getUncoatedModule(), liveModuleSentinel);
      return moduleInstances[m.url] = moduleInstance;
    },
    set: function(normalizedName, module) {
      normalizedName = String(normalizedName);
      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, (function() {
        return module;
      }));
      moduleInstances[normalizedName] = module;
    },
    get baseURL() {
      return baseURL;
    },
    set baseURL(v) {
      baseURL = String(v);
    },
    registerModule: function(name, deps, func) {
      var normalizedName = ModuleStore.normalize(name);
      if (moduleInstantiators[normalizedName])
        throw new Error('duplicate module named ' + normalizedName);
      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, func);
    },
    bundleStore: Object.create(null),
    register: function(name, deps, func) {
      if (!deps || !deps.length && !func.length) {
        this.registerModule(name, deps, func);
      } else {
        this.bundleStore[name] = {
          deps: deps,
          execute: function() {
            var $__0 = arguments;
            var depMap = {};
            deps.forEach((function(dep, index) {
              return depMap[dep] = $__0[index];
            }));
            var registryEntry = func.call(this, depMap);
            registryEntry.execute.call(this);
            return registryEntry.exports;
          }
        };
      }
    },
    getAnonymousModule: function(func) {
      return new Module(func.call(global), liveModuleSentinel);
    },
    getForTesting: function(name) {
      var $__0 = this;
      if (!this.testingPrefix_) {
        Object.keys(moduleInstances).some((function(key) {
          var m = /(traceur@[^\/]*\/)/.exec(key);
          if (m) {
            $__0.testingPrefix_ = m[1];
            return true;
          }
        }));
      }
      return this.get(this.testingPrefix_ + name);
    }
  };
  var moduleStoreModule = new Module({ModuleStore: ModuleStore});
  ModuleStore.set('@traceur/src/runtime/ModuleStore', moduleStoreModule);
  ModuleStore.set('@traceur/src/runtime/ModuleStore.js', moduleStoreModule);
  var setupGlobals = $traceurRuntime.setupGlobals;
  $traceurRuntime.setupGlobals = function(global) {
    setupGlobals(global);
  };
  $traceurRuntime.ModuleStore = ModuleStore;
  global.System = {
    register: ModuleStore.register.bind(ModuleStore),
    registerModule: ModuleStore.registerModule.bind(ModuleStore),
    get: ModuleStore.get,
    set: ModuleStore.set,
    normalize: ModuleStore.normalize
  };
  $traceurRuntime.getModuleImpl = function(name) {
    var instantiator = getUncoatedModuleInstantiator(name);
    return instantiator && instantiator.getUncoatedModule();
  };
})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this);
System.registerModule("traceur-runtime@0.0.79/src/runtime/polyfills/utils.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.79/src/runtime/polyfills/utils.js";
  var $ceil = Math.ceil;
  var $floor = Math.floor;
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var $pow = Math.pow;
  var $min = Math.min;
  var toObject = $traceurRuntime.toObject;
  function toUint32(x) {
    return x >>> 0;
  }
  function isObject(x) {
    return x && (typeof x === 'object' || typeof x === 'function');
  }
  function isCallable(x) {
    return typeof x === 'function';
  }
  function isNumber(x) {
    return typeof x === 'number';
  }
  function toInteger(x) {
    x = +x;
    if ($isNaN(x))
      return 0;
    if (x === 0 || !$isFinite(x))
      return x;
    return x > 0 ? $floor(x) : $ceil(x);
  }
  var MAX_SAFE_LENGTH = $pow(2, 53) - 1;
  function toLength(x) {
    var len = toInteger(x);
    return len < 0 ? 0 : $min(len, MAX_SAFE_LENGTH);
  }
  function checkIterable(x) {
    return !isObject(x) ? undefined : x[Symbol.iterator];
  }
  function isConstructor(x) {
    return isCallable(x);
  }
  function createIteratorResultObject(value, done) {
    return {
      value: value,
      done: done
    };
  }
  function maybeDefine(object, name, descr) {
    if (!(name in object)) {
      Object.defineProperty(object, name, descr);
    }
  }
  function maybeDefineMethod(object, name, value) {
    maybeDefine(object, name, {
      value: value,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  function maybeDefineConst(object, name, value) {
    maybeDefine(object, name, {
      value: value,
      configurable: false,
      enumerable: false,
      writable: false
    });
  }
  function maybeAddFunctions(object, functions) {
    for (var i = 0; i < functions.length; i += 2) {
      var name = functions[i];
      var value = functions[i + 1];
      maybeDefineMethod(object, name, value);
    }
  }
  function maybeAddConsts(object, consts) {
    for (var i = 0; i < consts.length; i += 2) {
      var name = consts[i];
      var value = consts[i + 1];
      maybeDefineConst(object, name, value);
    }
  }
  function maybeAddIterator(object, func, Symbol) {
    if (!Symbol || !Symbol.iterator || object[Symbol.iterator])
      return;
    if (object['@@iterator'])
      func = object['@@iterator'];
    Object.defineProperty(object, Symbol.iterator, {
      value: func,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  var polyfills = [];
  function registerPolyfill(func) {
    polyfills.push(func);
  }
  function polyfillAll(global) {
    polyfills.forEach((function(f) {
      return f(global);
    }));
  }
  return {
    get toObject() {
      return toObject;
    },
    get toUint32() {
      return toUint32;
    },
    get isObject() {
      return isObject;
    },
    get isCallable() {
      return isCallable;
    },
    get isNumber() {
      return isNumber;
    },
    get toInteger() {
      return toInteger;
    },
    get toLength() {
      return toLength;
    },
    get checkIterable() {
      return checkIterable;
    },
    get isConstructor() {
      return isConstructor;
    },
    get createIteratorResultObject() {
      return createIteratorResultObject;
    },
    get maybeDefine() {
      return maybeDefine;
    },
    get maybeDefineMethod() {
      return maybeDefineMethod;
    },
    get maybeDefineConst() {
      return maybeDefineConst;
    },
    get maybeAddFunctions() {
      return maybeAddFunctions;
    },
    get maybeAddConsts() {
      return maybeAddConsts;
    },
    get maybeAddIterator() {
      return maybeAddIterator;
    },
    get registerPolyfill() {
      return registerPolyfill;
    },
    get polyfillAll() {
      return polyfillAll;
    }
  };
});
System.registerModule("traceur-runtime@0.0.79/src/runtime/polyfills/Map.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.79/src/runtime/polyfills/Map.js";
  var $__0 = System.get("traceur-runtime@0.0.79/src/runtime/polyfills/utils.js"),
      isObject = $__0.isObject,
      maybeAddIterator = $__0.maybeAddIterator,
      registerPolyfill = $__0.registerPolyfill;
  var getOwnHashObject = $traceurRuntime.getOwnHashObject;
  var $hasOwnProperty = Object.prototype.hasOwnProperty;
  var deletedSentinel = {};
  function lookupIndex(map, key) {
    if (isObject(key)) {
      var hashObject = getOwnHashObject(key);
      return hashObject && map.objectIndex_[hashObject.hash];
    }
    if (typeof key === 'string')
      return map.stringIndex_[key];
    return map.primitiveIndex_[key];
  }
  function initMap(map) {
    map.entries_ = [];
    map.objectIndex_ = Object.create(null);
    map.stringIndex_ = Object.create(null);
    map.primitiveIndex_ = Object.create(null);
    map.deletedCount_ = 0;
  }
  var Map = function Map() {
    var iterable = arguments[0];
    if (!isObject(this))
      throw new TypeError('Map called on incompatible type');
    if ($hasOwnProperty.call(this, 'entries_')) {
      throw new TypeError('Map can not be reentrantly initialised');
    }
    initMap(this);
    if (iterable !== null && iterable !== undefined) {
      for (var $__2 = iterable[$traceurRuntime.toProperty(Symbol.iterator)](),
          $__3; !($__3 = $__2.next()).done; ) {
        var $__4 = $__3.value,
            key = $__4[0],
            value = $__4[1];
        {
          this.set(key, value);
        }
      }
    }
  };
  ($traceurRuntime.createClass)(Map, {
    get size() {
      return this.entries_.length / 2 - this.deletedCount_;
    },
    get: function(key) {
      var index = lookupIndex(this, key);
      if (index !== undefined)
        return this.entries_[index + 1];
    },
    set: function(key, value) {
      var objectMode = isObject(key);
      var stringMode = typeof key === 'string';
      var index = lookupIndex(this, key);
      if (index !== undefined) {
        this.entries_[index + 1] = value;
      } else {
        index = this.entries_.length;
        this.entries_[index] = key;
        this.entries_[index + 1] = value;
        if (objectMode) {
          var hashObject = getOwnHashObject(key);
          var hash = hashObject.hash;
          this.objectIndex_[hash] = index;
        } else if (stringMode) {
          this.stringIndex_[key] = index;
        } else {
          this.primitiveIndex_[key] = index;
        }
      }
      return this;
    },
    has: function(key) {
      return lookupIndex(this, key) !== undefined;
    },
    delete: function(key) {
      var objectMode = isObject(key);
      var stringMode = typeof key === 'string';
      var index;
      var hash;
      if (objectMode) {
        var hashObject = getOwnHashObject(key);
        if (hashObject) {
          index = this.objectIndex_[hash = hashObject.hash];
          delete this.objectIndex_[hash];
        }
      } else if (stringMode) {
        index = this.stringIndex_[key];
        delete this.stringIndex_[key];
      } else {
        index = this.primitiveIndex_[key];
        delete this.primitiveIndex_[key];
      }
      if (index !== undefined) {
        this.entries_[index] = deletedSentinel;
        this.entries_[index + 1] = undefined;
        this.deletedCount_++;
        return true;
      }
      return false;
    },
    clear: function() {
      initMap(this);
    },
    forEach: function(callbackFn) {
      var thisArg = arguments[1];
      for (var i = 0; i < this.entries_.length; i += 2) {
        var key = this.entries_[i];
        var value = this.entries_[i + 1];
        if (key === deletedSentinel)
          continue;
        callbackFn.call(thisArg, value, key, this);
      }
    },
    entries: $traceurRuntime.initGeneratorFunction(function $__5() {
      var i,
          key,
          value;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              i = 0;
              $ctx.state = 12;
              break;
            case 12:
              $ctx.state = (i < this.entries_.length) ? 8 : -2;
              break;
            case 4:
              i += 2;
              $ctx.state = 12;
              break;
            case 8:
              key = this.entries_[i];
              value = this.entries_[i + 1];
              $ctx.state = 9;
              break;
            case 9:
              $ctx.state = (key === deletedSentinel) ? 4 : 6;
              break;
            case 6:
              $ctx.state = 2;
              return [key, value];
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            default:
              return $ctx.end();
          }
      }, $__5, this);
    }),
    keys: $traceurRuntime.initGeneratorFunction(function $__6() {
      var i,
          key,
          value;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              i = 0;
              $ctx.state = 12;
              break;
            case 12:
              $ctx.state = (i < this.entries_.length) ? 8 : -2;
              break;
            case 4:
              i += 2;
              $ctx.state = 12;
              break;
            case 8:
              key = this.entries_[i];
              value = this.entries_[i + 1];
              $ctx.state = 9;
              break;
            case 9:
              $ctx.state = (key === deletedSentinel) ? 4 : 6;
              break;
            case 6:
              $ctx.state = 2;
              return key;
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            default:
              return $ctx.end();
          }
      }, $__6, this);
    }),
    values: $traceurRuntime.initGeneratorFunction(function $__7() {
      var i,
          key,
          value;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              i = 0;
              $ctx.state = 12;
              break;
            case 12:
              $ctx.state = (i < this.entries_.length) ? 8 : -2;
              break;
            case 4:
              i += 2;
              $ctx.state = 12;
              break;
            case 8:
              key = this.entries_[i];
              value = this.entries_[i + 1];
              $ctx.state = 9;
              break;
            case 9:
              $ctx.state = (key === deletedSentinel) ? 4 : 6;
              break;
            case 6:
              $ctx.state = 2;
              return value;
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            default:
              return $ctx.end();
          }
      }, $__7, this);
    })
  }, {});
  Object.defineProperty(Map.prototype, Symbol.iterator, {
    configurable: true,
    writable: true,
    value: Map.prototype.entries
  });
  function polyfillMap(global) {
    var $__4 = global,
        Object = $__4.Object,
        Symbol = $__4.Symbol;
    if (!global.Map)
      global.Map = Map;
    var mapPrototype = global.Map.prototype;
    if (mapPrototype.entries === undefined)
      global.Map = Map;
    if (mapPrototype.entries) {
      maybeAddIterator(mapPrototype, mapPrototype.entries, Symbol);
      maybeAddIterator(Object.getPrototypeOf(new global.Map().entries()), function() {
        return this;
      }, Symbol);
    }
  }
  registerPolyfill(polyfillMap);
  return {
    get Map() {
      return Map;
    },
    get polyfillMap() {
      return polyfillMap;
    }
  };
});
System.get("traceur-runtime@0.0.79/src/runtime/polyfills/Map.js" + '');
System.registerModule("traceur-runtime@0.0.79/src/runtime/polyfills/Set.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.79/src/runtime/polyfills/Set.js";
  var $__0 = System.get("traceur-runtime@0.0.79/src/runtime/polyfills/utils.js"),
      isObject = $__0.isObject,
      maybeAddIterator = $__0.maybeAddIterator,
      registerPolyfill = $__0.registerPolyfill;
  var Map = System.get("traceur-runtime@0.0.79/src/runtime/polyfills/Map.js").Map;
  var getOwnHashObject = $traceurRuntime.getOwnHashObject;
  var $hasOwnProperty = Object.prototype.hasOwnProperty;
  function initSet(set) {
    set.map_ = new Map();
  }
  var Set = function Set() {
    var iterable = arguments[0];
    if (!isObject(this))
      throw new TypeError('Set called on incompatible type');
    if ($hasOwnProperty.call(this, 'map_')) {
      throw new TypeError('Set can not be reentrantly initialised');
    }
    initSet(this);
    if (iterable !== null && iterable !== undefined) {
      for (var $__4 = iterable[$traceurRuntime.toProperty(Symbol.iterator)](),
          $__5; !($__5 = $__4.next()).done; ) {
        var item = $__5.value;
        {
          this.add(item);
        }
      }
    }
  };
  ($traceurRuntime.createClass)(Set, {
    get size() {
      return this.map_.size;
    },
    has: function(key) {
      return this.map_.has(key);
    },
    add: function(key) {
      this.map_.set(key, key);
      return this;
    },
    delete: function(key) {
      return this.map_.delete(key);
    },
    clear: function() {
      return this.map_.clear();
    },
    forEach: function(callbackFn) {
      var thisArg = arguments[1];
      var $__2 = this;
      return this.map_.forEach((function(value, key) {
        callbackFn.call(thisArg, key, key, $__2);
      }));
    },
    values: $traceurRuntime.initGeneratorFunction(function $__7() {
      var $__8,
          $__9;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $__8 = this.map_.keys()[Symbol.iterator]();
              $ctx.sent = void 0;
              $ctx.action = 'next';
              $ctx.state = 12;
              break;
            case 12:
              $__9 = $__8[$ctx.action]($ctx.sentIgnoreThrow);
              $ctx.state = 9;
              break;
            case 9:
              $ctx.state = ($__9.done) ? 3 : 2;
              break;
            case 3:
              $ctx.sent = $__9.value;
              $ctx.state = -2;
              break;
            case 2:
              $ctx.state = 12;
              return $__9.value;
            default:
              return $ctx.end();
          }
      }, $__7, this);
    }),
    entries: $traceurRuntime.initGeneratorFunction(function $__10() {
      var $__11,
          $__12;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $__11 = this.map_.entries()[Symbol.iterator]();
              $ctx.sent = void 0;
              $ctx.action = 'next';
              $ctx.state = 12;
              break;
            case 12:
              $__12 = $__11[$ctx.action]($ctx.sentIgnoreThrow);
              $ctx.state = 9;
              break;
            case 9:
              $ctx.state = ($__12.done) ? 3 : 2;
              break;
            case 3:
              $ctx.sent = $__12.value;
              $ctx.state = -2;
              break;
            case 2:
              $ctx.state = 12;
              return $__12.value;
            default:
              return $ctx.end();
          }
      }, $__10, this);
    })
  }, {});
  Object.defineProperty(Set.prototype, Symbol.iterator, {
    configurable: true,
    writable: true,
    value: Set.prototype.values
  });
  Object.defineProperty(Set.prototype, 'keys', {
    configurable: true,
    writable: true,
    value: Set.prototype.values
  });
  function polyfillSet(global) {
    var $__6 = global,
        Object = $__6.Object,
        Symbol = $__6.Symbol;
    if (!global.Set)
      global.Set = Set;
    var setPrototype = global.Set.prototype;
    if (setPrototype.values) {
      maybeAddIterator(setPrototype, setPrototype.values, Symbol);
      maybeAddIterator(Object.getPrototypeOf(new global.Set().values()), function() {
        return this;
      }, Symbol);
    }
  }
  registerPolyfill(polyfillSet);
  return {
    get Set() {
      return Set;
    },
    get polyfillSet() {
      return polyfillSet;
    }
  };
});
System.get("traceur-runtime@0.0.79/src/runtime/polyfills/Set.js" + '');
System.registerModule("traceur-runtime@0.0.79/node_modules/rsvp/lib/rsvp/asap.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.79/node_modules/rsvp/lib/rsvp/asap.js";
  var len = 0;
  function asap(callback, arg) {
    queue[len] = callback;
    queue[len + 1] = arg;
    len += 2;
    if (len === 2) {
      scheduleFlush();
    }
  }
  var $__default = asap;
  var browserGlobal = (typeof window !== 'undefined') ? window : {};
  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
  var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
  function useNextTick() {
    return function() {
      process.nextTick(flush);
    };
  }
  function useMutationObserver() {
    var iterations = 0;
    var observer = new BrowserMutationObserver(flush);
    var node = document.createTextNode('');
    observer.observe(node, {characterData: true});
    return function() {
      node.data = (iterations = ++iterations % 2);
    };
  }
  function useMessageChannel() {
    var channel = new MessageChannel();
    channel.port1.onmessage = flush;
    return function() {
      channel.port2.postMessage(0);
    };
  }
  function useSetTimeout() {
    return function() {
      setTimeout(flush, 1);
    };
  }
  var queue = new Array(1000);
  function flush() {
    for (var i = 0; i < len; i += 2) {
      var callback = queue[i];
      var arg = queue[i + 1];
      callback(arg);
      queue[i] = undefined;
      queue[i + 1] = undefined;
    }
    len = 0;
  }
  var scheduleFlush;
  if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
    scheduleFlush = useNextTick();
  } else if (BrowserMutationObserver) {
    scheduleFlush = useMutationObserver();
  } else if (isWorker) {
    scheduleFlush = useMessageChannel();
  } else {
    scheduleFlush = useSetTimeout();
  }
  return {get default() {
      return $__default;
    }};
});
System.registerModule("traceur-runtime@0.0.79/src/runtime/polyfills/Promise.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.79/src/runtime/polyfills/Promise.js";
  var async = System.get("traceur-runtime@0.0.79/node_modules/rsvp/lib/rsvp/asap.js").default;
  var registerPolyfill = System.get("traceur-runtime@0.0.79/src/runtime/polyfills/utils.js").registerPolyfill;
  var promiseRaw = {};
  function isPromise(x) {
    return x && typeof x === 'object' && x.status_ !== undefined;
  }
  function idResolveHandler(x) {
    return x;
  }
  function idRejectHandler(x) {
    throw x;
  }
  function chain(promise) {
    var onResolve = arguments[1] !== (void 0) ? arguments[1] : idResolveHandler;
    var onReject = arguments[2] !== (void 0) ? arguments[2] : idRejectHandler;
    var deferred = getDeferred(promise.constructor);
    switch (promise.status_) {
      case undefined:
        throw TypeError;
      case 0:
        promise.onResolve_.push(onResolve, deferred);
        promise.onReject_.push(onReject, deferred);
        break;
      case +1:
        promiseEnqueue(promise.value_, [onResolve, deferred]);
        break;
      case -1:
        promiseEnqueue(promise.value_, [onReject, deferred]);
        break;
    }
    return deferred.promise;
  }
  function getDeferred(C) {
    if (this === $Promise) {
      var promise = promiseInit(new $Promise(promiseRaw));
      return {
        promise: promise,
        resolve: (function(x) {
          promiseResolve(promise, x);
        }),
        reject: (function(r) {
          promiseReject(promise, r);
        })
      };
    } else {
      var result = {};
      result.promise = new C((function(resolve, reject) {
        result.resolve = resolve;
        result.reject = reject;
      }));
      return result;
    }
  }
  function promiseSet(promise, status, value, onResolve, onReject) {
    promise.status_ = status;
    promise.value_ = value;
    promise.onResolve_ = onResolve;
    promise.onReject_ = onReject;
    return promise;
  }
  function promiseInit(promise) {
    return promiseSet(promise, 0, undefined, [], []);
  }
  var Promise = function Promise(resolver) {
    if (resolver === promiseRaw)
      return;
    if (typeof resolver !== 'function')
      throw new TypeError;
    var promise = promiseInit(this);
    try {
      resolver((function(x) {
        promiseResolve(promise, x);
      }), (function(r) {
        promiseReject(promise, r);
      }));
    } catch (e) {
      promiseReject(promise, e);
    }
  };
  ($traceurRuntime.createClass)(Promise, {
    catch: function(onReject) {
      return this.then(undefined, onReject);
    },
    then: function(onResolve, onReject) {
      if (typeof onResolve !== 'function')
        onResolve = idResolveHandler;
      if (typeof onReject !== 'function')
        onReject = idRejectHandler;
      var that = this;
      var constructor = this.constructor;
      return chain(this, function(x) {
        x = promiseCoerce(constructor, x);
        return x === that ? onReject(new TypeError) : isPromise(x) ? x.then(onResolve, onReject) : onResolve(x);
      }, onReject);
    }
  }, {
    resolve: function(x) {
      if (this === $Promise) {
        if (isPromise(x)) {
          return x;
        }
        return promiseSet(new $Promise(promiseRaw), +1, x);
      } else {
        return new this(function(resolve, reject) {
          resolve(x);
        });
      }
    },
    reject: function(r) {
      if (this === $Promise) {
        return promiseSet(new $Promise(promiseRaw), -1, r);
      } else {
        return new this((function(resolve, reject) {
          reject(r);
        }));
      }
    },
    all: function(values) {
      var deferred = getDeferred(this);
      var resolutions = [];
      try {
        var count = values.length;
        if (count === 0) {
          deferred.resolve(resolutions);
        } else {
          for (var i = 0; i < values.length; i++) {
            this.resolve(values[i]).then(function(i, x) {
              resolutions[i] = x;
              if (--count === 0)
                deferred.resolve(resolutions);
            }.bind(undefined, i), (function(r) {
              deferred.reject(r);
            }));
          }
        }
      } catch (e) {
        deferred.reject(e);
      }
      return deferred.promise;
    },
    race: function(values) {
      var deferred = getDeferred(this);
      try {
        for (var i = 0; i < values.length; i++) {
          this.resolve(values[i]).then((function(x) {
            deferred.resolve(x);
          }), (function(r) {
            deferred.reject(r);
          }));
        }
      } catch (e) {
        deferred.reject(e);
      }
      return deferred.promise;
    }
  });
  var $Promise = Promise;
  var $PromiseReject = $Promise.reject;
  function promiseResolve(promise, x) {
    promiseDone(promise, +1, x, promise.onResolve_);
  }
  function promiseReject(promise, r) {
    promiseDone(promise, -1, r, promise.onReject_);
  }
  function promiseDone(promise, status, value, reactions) {
    if (promise.status_ !== 0)
      return;
    promiseEnqueue(value, reactions);
    promiseSet(promise, status, value);
  }
  function promiseEnqueue(value, tasks) {
    async((function() {
      for (var i = 0; i < tasks.length; i += 2) {
        promiseHandle(value, tasks[i], tasks[i + 1]);
      }
    }));
  }
  function promiseHandle(value, handler, deferred) {
    try {
      var result = handler(value);
      if (result === deferred.promise)
        throw new TypeError;
      else if (isPromise(result))
        chain(result, deferred.resolve, deferred.reject);
      else
        deferred.resolve(result);
    } catch (e) {
      try {
        deferred.reject(e);
      } catch (e) {}
    }
  }
  var thenableSymbol = '@@thenable';
  function isObject(x) {
    return x && (typeof x === 'object' || typeof x === 'function');
  }
  function promiseCoerce(constructor, x) {
    if (!isPromise(x) && isObject(x)) {
      var then;
      try {
        then = x.then;
      } catch (r) {
        var promise = $PromiseReject.call(constructor, r);
        x[thenableSymbol] = promise;
        return promise;
      }
      if (typeof then === 'function') {
        var p = x[thenableSymbol];
        if (p) {
          return p;
        } else {
          var deferred = getDeferred(constructor);
          x[thenableSymbol] = deferred.promise;
          try {
            then.call(x, deferred.resolve, deferred.reject);
          } catch (r) {
            deferred.reject(r);
          }
          return deferred.promise;
        }
      }
    }
    return x;
  }
  function polyfillPromise(global) {
    if (!global.Promise)
      global.Promise = Promise;
  }
  registerPolyfill(polyfillPromise);
  return {
    get Promise() {
      return Promise;
    },
    get polyfillPromise() {
      return polyfillPromise;
    }
  };
});
System.get("traceur-runtime@0.0.79/src/runtime/polyfills/Promise.js" + '');
System.registerModule("traceur-runtime@0.0.79/src/runtime/polyfills/StringIterator.js", [], function() {
  "use strict";
  var $__2;
  var __moduleName = "traceur-runtime@0.0.79/src/runtime/polyfills/StringIterator.js";
  var $__0 = System.get("traceur-runtime@0.0.79/src/runtime/polyfills/utils.js"),
      createIteratorResultObject = $__0.createIteratorResultObject,
      isObject = $__0.isObject;
  var toProperty = $traceurRuntime.toProperty;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var iteratedString = Symbol('iteratedString');
  var stringIteratorNextIndex = Symbol('stringIteratorNextIndex');
  var StringIterator = function StringIterator() {};
  ($traceurRuntime.createClass)(StringIterator, ($__2 = {}, Object.defineProperty($__2, "next", {
    value: function() {
      var o = this;
      if (!isObject(o) || !hasOwnProperty.call(o, iteratedString)) {
        throw new TypeError('this must be a StringIterator object');
      }
      var s = o[toProperty(iteratedString)];
      if (s === undefined) {
        return createIteratorResultObject(undefined, true);
      }
      var position = o[toProperty(stringIteratorNextIndex)];
      var len = s.length;
      if (position >= len) {
        o[toProperty(iteratedString)] = undefined;
        return createIteratorResultObject(undefined, true);
      }
      var first = s.charCodeAt(position);
      var resultString;
      if (first < 0xD800 || first > 0xDBFF || position + 1 === len) {
        resultString = String.fromCharCode(first);
      } else {
        var second = s.charCodeAt(position + 1);
        if (second < 0xDC00 || second > 0xDFFF) {
          resultString = String.fromCharCode(first);
        } else {
          resultString = String.fromCharCode(first) + String.fromCharCode(second);
        }
      }
      o[toProperty(stringIteratorNextIndex)] = position + resultString.length;
      return createIteratorResultObject(resultString, false);
    },
    configurable: true,
    enumerable: true,
    writable: true
  }), Object.defineProperty($__2, Symbol.iterator, {
    value: function() {
      return this;
    },
    configurable: true,
    enumerable: true,
    writable: true
  }), $__2), {});
  function createStringIterator(string) {
    var s = String(string);
    var iterator = Object.create(StringIterator.prototype);
    iterator[toProperty(iteratedString)] = s;
    iterator[toProperty(stringIteratorNextIndex)] = 0;
    return iterator;
  }
  return {get createStringIterator() {
      return createStringIterator;
    }};
});
System.registerModule("traceur-runtime@0.0.79/src/runtime/polyfills/String.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.79/src/runtime/polyfills/String.js";
  var createStringIterator = System.get("traceur-runtime@0.0.79/src/runtime/polyfills/StringIterator.js").createStringIterator;
  var $__1 = System.get("traceur-runtime@0.0.79/src/runtime/polyfills/utils.js"),
      maybeAddFunctions = $__1.maybeAddFunctions,
      maybeAddIterator = $__1.maybeAddIterator,
      registerPolyfill = $__1.registerPolyfill;
  var $toString = Object.prototype.toString;
  var $indexOf = String.prototype.indexOf;
  var $lastIndexOf = String.prototype.lastIndexOf;
  function startsWith(search) {
    var string = String(this);
    if (this == null || $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var position = arguments.length > 1 ? arguments[1] : undefined;
    var pos = position ? Number(position) : 0;
    if (isNaN(pos)) {
      pos = 0;
    }
    var start = Math.min(Math.max(pos, 0), stringLength);
    return $indexOf.call(string, searchString, pos) == start;
  }
  function endsWith(search) {
    var string = String(this);
    if (this == null || $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var pos = stringLength;
    if (arguments.length > 1) {
      var position = arguments[1];
      if (position !== undefined) {
        pos = position ? Number(position) : 0;
        if (isNaN(pos)) {
          pos = 0;
        }
      }
    }
    var end = Math.min(Math.max(pos, 0), stringLength);
    var start = end - searchLength;
    if (start < 0) {
      return false;
    }
    return $lastIndexOf.call(string, searchString, start) == start;
  }
  function includes(search) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    if (search && $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var position = arguments.length > 1 ? arguments[1] : undefined;
    var pos = position ? Number(position) : 0;
    if (pos != pos) {
      pos = 0;
    }
    var start = Math.min(Math.max(pos, 0), stringLength);
    if (searchLength + start > stringLength) {
      return false;
    }
    return $indexOf.call(string, searchString, pos) != -1;
  }
  function repeat(count) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    var n = count ? Number(count) : 0;
    if (isNaN(n)) {
      n = 0;
    }
    if (n < 0 || n == Infinity) {
      throw RangeError();
    }
    if (n == 0) {
      return '';
    }
    var result = '';
    while (n--) {
      result += string;
    }
    return result;
  }
  function codePointAt(position) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    var size = string.length;
    var index = position ? Number(position) : 0;
    if (isNaN(index)) {
      index = 0;
    }
    if (index < 0 || index >= size) {
      return undefined;
    }
    var first = string.charCodeAt(index);
    var second;
    if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) {
      second = string.charCodeAt(index + 1);
      if (second >= 0xDC00 && second <= 0xDFFF) {
        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
      }
    }
    return first;
  }
  function raw(callsite) {
    var raw = callsite.raw;
    var len = raw.length >>> 0;
    if (len === 0)
      return '';
    var s = '';
    var i = 0;
    while (true) {
      s += raw[i];
      if (i + 1 === len)
        return s;
      s += arguments[++i];
    }
  }
  function fromCodePoint() {
    var codeUnits = [];
    var floor = Math.floor;
    var highSurrogate;
    var lowSurrogate;
    var index = -1;
    var length = arguments.length;
    if (!length) {
      return '';
    }
    while (++index < length) {
      var codePoint = Number(arguments[index]);
      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {
        throw RangeError('Invalid code point: ' + codePoint);
      }
      if (codePoint <= 0xFFFF) {
        codeUnits.push(codePoint);
      } else {
        codePoint -= 0x10000;
        highSurrogate = (codePoint >> 10) + 0xD800;
        lowSurrogate = (codePoint % 0x400) + 0xDC00;
        codeUnits.push(highSurrogate, lowSurrogate);
      }
    }
    return String.fromCharCode.apply(null, codeUnits);
  }
  function stringPrototypeIterator() {
    var o = $traceurRuntime.checkObjectCoercible(this);
    var s = String(o);
    return createStringIterator(s);
  }
  function polyfillString(global) {
    var String = global.String;
    maybeAddFunctions(String.prototype, ['codePointAt', codePointAt, 'endsWith', endsWith, 'includes', includes, 'repeat', repeat, 'startsWith', startsWith]);
    maybeAddFunctions(String, ['fromCodePoint', fromCodePoint, 'raw', raw]);
    maybeAddIterator(String.prototype, stringPrototypeIterator, Symbol);
  }
  registerPolyfill(polyfillString);
  return {
    get startsWith() {
      return startsWith;
    },
    get endsWith() {
      return endsWith;
    },
    get includes() {
      return includes;
    },
    get repeat() {
      return repeat;
    },
    get codePointAt() {
      return codePointAt;
    },
    get raw() {
      return raw;
    },
    get fromCodePoint() {
      return fromCodePoint;
    },
    get stringPrototypeIterator() {
      return stringPrototypeIterator;
    },
    get polyfillString() {
      return polyfillString;
    }
  };
});
System.get("traceur-runtime@0.0.79/src/runtime/polyfills/String.js" + '');
System.registerModule("traceur-runtime@0.0.79/src/runtime/polyfills/ArrayIterator.js", [], function() {
  "use strict";
  var $__2;
  var __moduleName = "traceur-runtime@0.0.79/src/runtime/polyfills/ArrayIterator.js";
  var $__0 = System.get("traceur-runtime@0.0.79/src/runtime/polyfills/utils.js"),
      toObject = $__0.toObject,
      toUint32 = $__0.toUint32,
      createIteratorResultObject = $__0.createIteratorResultObject;
  var ARRAY_ITERATOR_KIND_KEYS = 1;
  var ARRAY_ITERATOR_KIND_VALUES = 2;
  var ARRAY_ITERATOR_KIND_ENTRIES = 3;
  var ArrayIterator = function ArrayIterator() {};
  ($traceurRuntime.createClass)(ArrayIterator, ($__2 = {}, Object.defineProperty($__2, "next", {
    value: function() {
      var iterator = toObject(this);
      var array = iterator.iteratorObject_;
      if (!array) {
        throw new TypeError('Object is not an ArrayIterator');
      }
      var index = iterator.arrayIteratorNextIndex_;
      var itemKind = iterator.arrayIterationKind_;
      var length = toUint32(array.length);
      if (index >= length) {
        iterator.arrayIteratorNextIndex_ = Infinity;
        return createIteratorResultObject(undefined, true);
      }
      iterator.arrayIteratorNextIndex_ = index + 1;
      if (itemKind == ARRAY_ITERATOR_KIND_VALUES)
        return createIteratorResultObject(array[index], false);
      if (itemKind == ARRAY_ITERATOR_KIND_ENTRIES)
        return createIteratorResultObject([index, array[index]], false);
      return createIteratorResultObject(index, false);
    },
    configurable: true,
    enumerable: true,
    writable: true
  }), Object.defineProperty($__2, Symbol.iterator, {
    value: function() {
      return this;
    },
    configurable: true,
    enumerable: true,
    writable: true
  }), $__2), {});
  function createArrayIterator(array, kind) {
    var object = toObject(array);
    var iterator = new ArrayIterator;
    iterator.iteratorObject_ = object;
    iterator.arrayIteratorNextIndex_ = 0;
    iterator.arrayIterationKind_ = kind;
    return iterator;
  }
  function entries() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_ENTRIES);
  }
  function keys() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_KEYS);
  }
  function values() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_VALUES);
  }
  return {
    get entries() {
      return entries;
    },
    get keys() {
      return keys;
    },
    get values() {
      return values;
    }
  };
});
System.registerModule("traceur-runtime@0.0.79/src/runtime/polyfills/Array.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.79/src/runtime/polyfills/Array.js";
  var $__0 = System.get("traceur-runtime@0.0.79/src/runtime/polyfills/ArrayIterator.js"),
      entries = $__0.entries,
      keys = $__0.keys,
      values = $__0.values;
  var $__1 = System.get("traceur-runtime@0.0.79/src/runtime/polyfills/utils.js"),
      checkIterable = $__1.checkIterable,
      isCallable = $__1.isCallable,
      isConstructor = $__1.isConstructor,
      maybeAddFunctions = $__1.maybeAddFunctions,
      maybeAddIterator = $__1.maybeAddIterator,
      registerPolyfill = $__1.registerPolyfill,
      toInteger = $__1.toInteger,
      toLength = $__1.toLength,
      toObject = $__1.toObject;
  function from(arrLike) {
    var mapFn = arguments[1];
    var thisArg = arguments[2];
    var C = this;
    var items = toObject(arrLike);
    var mapping = mapFn !== undefined;
    var k = 0;
    var arr,
        len;
    if (mapping && !isCallable(mapFn)) {
      throw TypeError();
    }
    if (checkIterable(items)) {
      arr = isConstructor(C) ? new C() : [];
      for (var $__2 = items[$traceurRuntime.toProperty(Symbol.iterator)](),
          $__3; !($__3 = $__2.next()).done; ) {
        var item = $__3.value;
        {
          if (mapping) {
            arr[k] = mapFn.call(thisArg, item, k);
          } else {
            arr[k] = item;
          }
          k++;
        }
      }
      arr.length = k;
      return arr;
    }
    len = toLength(items.length);
    arr = isConstructor(C) ? new C(len) : new Array(len);
    for (; k < len; k++) {
      if (mapping) {
        arr[k] = typeof thisArg === 'undefined' ? mapFn(items[k], k) : mapFn.call(thisArg, items[k], k);
      } else {
        arr[k] = items[k];
      }
    }
    arr.length = len;
    return arr;
  }
  function of() {
    for (var items = [],
        $__4 = 0; $__4 < arguments.length; $__4++)
      items[$__4] = arguments[$__4];
    var C = this;
    var len = items.length;
    var arr = isConstructor(C) ? new C(len) : new Array(len);
    for (var k = 0; k < len; k++) {
      arr[k] = items[k];
    }
    arr.length = len;
    return arr;
  }
  function fill(value) {
    var start = arguments[1] !== (void 0) ? arguments[1] : 0;
    var end = arguments[2];
    var object = toObject(this);
    var len = toLength(object.length);
    var fillStart = toInteger(start);
    var fillEnd = end !== undefined ? toInteger(end) : len;
    fillStart = fillStart < 0 ? Math.max(len + fillStart, 0) : Math.min(fillStart, len);
    fillEnd = fillEnd < 0 ? Math.max(len + fillEnd, 0) : Math.min(fillEnd, len);
    while (fillStart < fillEnd) {
      object[fillStart] = value;
      fillStart++;
    }
    return object;
  }
  function find(predicate) {
    var thisArg = arguments[1];
    return findHelper(this, predicate, thisArg);
  }
  function findIndex(predicate) {
    var thisArg = arguments[1];
    return findHelper(this, predicate, thisArg, true);
  }
  function findHelper(self, predicate) {
    var thisArg = arguments[2];
    var returnIndex = arguments[3] !== (void 0) ? arguments[3] : false;
    var object = toObject(self);
    var len = toLength(object.length);
    if (!isCallable(predicate)) {
      throw TypeError();
    }
    for (var i = 0; i < len; i++) {
      var value = object[i];
      if (predicate.call(thisArg, value, i, object)) {
        return returnIndex ? i : value;
      }
    }
    return returnIndex ? -1 : undefined;
  }
  function polyfillArray(global) {
    var $__5 = global,
        Array = $__5.Array,
        Object = $__5.Object,
        Symbol = $__5.Symbol;
    maybeAddFunctions(Array.prototype, ['entries', entries, 'keys', keys, 'values', values, 'fill', fill, 'find', find, 'findIndex', findIndex]);
    maybeAddFunctions(Array, ['from', from, 'of', of]);
    maybeAddIterator(Array.prototype, values, Symbol);
    maybeAddIterator(Object.getPrototypeOf([].values()), function() {
      return this;
    }, Symbol);
  }
  registerPolyfill(polyfillArray);
  return {
    get from() {
      return from;
    },
    get of() {
      return of;
    },
    get fill() {
      return fill;
    },
    get find() {
      return find;
    },
    get findIndex() {
      return findIndex;
    },
    get polyfillArray() {
      return polyfillArray;
    }
  };
});
System.get("traceur-runtime@0.0.79/src/runtime/polyfills/Array.js" + '');
System.registerModule("traceur-runtime@0.0.79/src/runtime/polyfills/Object.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.79/src/runtime/polyfills/Object.js";
  var $__0 = System.get("traceur-runtime@0.0.79/src/runtime/polyfills/utils.js"),
      maybeAddFunctions = $__0.maybeAddFunctions,
      registerPolyfill = $__0.registerPolyfill;
  var $__1 = $traceurRuntime,
      defineProperty = $__1.defineProperty,
      getOwnPropertyDescriptor = $__1.getOwnPropertyDescriptor,
      getOwnPropertyNames = $__1.getOwnPropertyNames,
      isPrivateName = $__1.isPrivateName,
      keys = $__1.keys;
  function is(left, right) {
    if (left === right)
      return left !== 0 || 1 / left === 1 / right;
    return left !== left && right !== right;
  }
  function assign(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      var props = source == null ? [] : keys(source);
      var p,
          length = props.length;
      for (p = 0; p < length; p++) {
        var name = props[p];
        if (isPrivateName(name))
          continue;
        target[name] = source[name];
      }
    }
    return target;
  }
  function mixin(target, source) {
    var props = getOwnPropertyNames(source);
    var p,
        descriptor,
        length = props.length;
    for (p = 0; p < length; p++) {
      var name = props[p];
      if (isPrivateName(name))
        continue;
      descriptor = getOwnPropertyDescriptor(source, props[p]);
      defineProperty(target, props[p], descriptor);
    }
    return target;
  }
  function polyfillObject(global) {
    var Object = global.Object;
    maybeAddFunctions(Object, ['assign', assign, 'is', is, 'mixin', mixin]);
  }
  registerPolyfill(polyfillObject);
  return {
    get is() {
      return is;
    },
    get assign() {
      return assign;
    },
    get mixin() {
      return mixin;
    },
    get polyfillObject() {
      return polyfillObject;
    }
  };
});
System.get("traceur-runtime@0.0.79/src/runtime/polyfills/Object.js" + '');
System.registerModule("traceur-runtime@0.0.79/src/runtime/polyfills/Number.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.79/src/runtime/polyfills/Number.js";
  var $__0 = System.get("traceur-runtime@0.0.79/src/runtime/polyfills/utils.js"),
      isNumber = $__0.isNumber,
      maybeAddConsts = $__0.maybeAddConsts,
      maybeAddFunctions = $__0.maybeAddFunctions,
      registerPolyfill = $__0.registerPolyfill,
      toInteger = $__0.toInteger;
  var $abs = Math.abs;
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
  var MIN_SAFE_INTEGER = -Math.pow(2, 53) + 1;
  var EPSILON = Math.pow(2, -52);
  function NumberIsFinite(number) {
    return isNumber(number) && $isFinite(number);
  }
  ;
  function isInteger(number) {
    return NumberIsFinite(number) && toInteger(number) === number;
  }
  function NumberIsNaN(number) {
    return isNumber(number) && $isNaN(number);
  }
  ;
  function isSafeInteger(number) {
    if (NumberIsFinite(number)) {
      var integral = toInteger(number);
      if (integral === number)
        return $abs(integral) <= MAX_SAFE_INTEGER;
    }
    return false;
  }
  function polyfillNumber(global) {
    var Number = global.Number;
    maybeAddConsts(Number, ['MAX_SAFE_INTEGER', MAX_SAFE_INTEGER, 'MIN_SAFE_INTEGER', MIN_SAFE_INTEGER, 'EPSILON', EPSILON]);
    maybeAddFunctions(Number, ['isFinite', NumberIsFinite, 'isInteger', isInteger, 'isNaN', NumberIsNaN, 'isSafeInteger', isSafeInteger]);
  }
  registerPolyfill(polyfillNumber);
  return {
    get MAX_SAFE_INTEGER() {
      return MAX_SAFE_INTEGER;
    },
    get MIN_SAFE_INTEGER() {
      return MIN_SAFE_INTEGER;
    },
    get EPSILON() {
      return EPSILON;
    },
    get isFinite() {
      return NumberIsFinite;
    },
    get isInteger() {
      return isInteger;
    },
    get isNaN() {
      return NumberIsNaN;
    },
    get isSafeInteger() {
      return isSafeInteger;
    },
    get polyfillNumber() {
      return polyfillNumber;
    }
  };
});
System.get("traceur-runtime@0.0.79/src/runtime/polyfills/Number.js" + '');
System.registerModule("traceur-runtime@0.0.79/src/runtime/polyfills/polyfills.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.79/src/runtime/polyfills/polyfills.js";
  var polyfillAll = System.get("traceur-runtime@0.0.79/src/runtime/polyfills/utils.js").polyfillAll;
  polyfillAll(Reflect.global);
  var setupGlobals = $traceurRuntime.setupGlobals;
  $traceurRuntime.setupGlobals = function(global) {
    setupGlobals(global);
    polyfillAll(global);
  };
  return {};
});
System.get("traceur-runtime@0.0.79/src/runtime/polyfills/polyfills.js" + '');

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":17,"path":16}],21:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.2.1
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


(function(_global) {
  "use strict";

  var shim = {};
  if (typeof(exports) === 'undefined') {
    if(typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
      shim.exports = {};
      define(function() {
        return shim.exports;
      });
    } else {
      // gl-matrix lives in a browser, define its namespaces in global
      shim.exports = typeof(window) !== 'undefined' ? window : _global;
    }
  }
  else {
    // gl-matrix lives in commonjs, define its namespaces in exports
    shim.exports = exports;
  }

  (function(exports) {
    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


if(!GLMAT_EPSILON) {
    var GLMAT_EPSILON = 0.000001;
}

if(!GLMAT_ARRAY_TYPE) {
    var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
}

if(!GLMAT_RANDOM) {
    var GLMAT_RANDOM = Math.random;
}

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

/**
 * Sets the type of array used when creating new vectors and matricies
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    GLMAT_ARRAY_TYPE = type;
}

if(typeof(exports) !== 'undefined') {
    exports.glMatrix = glMatrix;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */

var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec2 = vec2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */

var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    var z = (GLMAT_RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/*
* Rotate a 3D vector around the x-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/*
* Rotate a 3D vector around the y-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/*
* Rotate a 3D vector around the z-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec3 = vec3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */

var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
        out[3] = a[3] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = GLMAT_RANDOM();
    out[1] = GLMAT_RANDOM();
    out[2] = GLMAT_RANDOM();
    out[3] = GLMAT_RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec4 = vec4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x2 Matrix
 * @name mat2
 */

var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 

if(typeof(exports) !== 'undefined') {
    exports.mat2 = mat2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;


/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

if(typeof(exports) !== 'undefined') {
    exports.mat2d = mat2d;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3x3 Matrix
 * @name mat3
 */

var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};


if(typeof(exports) !== 'undefined') {
    exports.mat3 = mat3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4x4 Matrix
 * @name mat4
 */

var mat4 = {};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < GLMAT_EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < GLMAT_EPSILON &&
        Math.abs(eyey - centery) < GLMAT_EPSILON &&
        Math.abs(eyez - centerz) < GLMAT_EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};


if(typeof(exports) !== 'undefined') {
    exports.mat4 = mat4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class Quaternion
 * @name quat
 */

var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[7]-m[5])*fRoot;
        out[1] = (m[2]-m[6])*fRoot;
        out[2] = (m[3]-m[1])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[k*3+j] - m[j*3+k]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.quat = quat;
}
;













  })(shim.exports);
})(this);

},{}],22:[function(require,module,exports){
'use strict';


var yaml = require('./lib/js-yaml.js');


module.exports = yaml;

},{"./lib/js-yaml.js":23}],23:[function(require,module,exports){
'use strict';


var loader = require('./js-yaml/loader');
var dumper = require('./js-yaml/dumper');


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type                = require('./js-yaml/type');
module.exports.Schema              = require('./js-yaml/schema');
module.exports.FAILSAFE_SCHEMA     = require('./js-yaml/schema/failsafe');
module.exports.JSON_SCHEMA         = require('./js-yaml/schema/json');
module.exports.CORE_SCHEMA         = require('./js-yaml/schema/core');
module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = require('./js-yaml/exception');

// Deprecared schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');
module.exports.SAFE_SCHEMA    = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');

},{"./js-yaml/dumper":25,"./js-yaml/exception":26,"./js-yaml/loader":27,"./js-yaml/schema":29,"./js-yaml/schema/core":30,"./js-yaml/schema/default_full":31,"./js-yaml/schema/default_safe":32,"./js-yaml/schema/failsafe":33,"./js-yaml/schema/json":34,"./js-yaml/type":35}],24:[function(require,module,exports){
'use strict';


function isNothing(subject) {
  return (undefined === subject) || (null === subject);
}


function isObject(subject) {
  return ('object' === typeof subject) && (null !== subject);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) {
    return sequence;
  } else if (isNothing(sequence)) {
    return [];
  } else {
    return [ sequence ];
  }
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (0 === number) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;

},{}],25:[function(require,module,exports){
'use strict';


var common              = require('./common');
var YAMLException       = require('./exception');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');


var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */


var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';


var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];


function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (null === map) {
    return {};
  }

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if ('!!' === tag.slice(0, 2)) {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }

    type = schema.compiledTypeMap[tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}


function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}


function State(options) {
  this.schema      = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent      = Math.max(1, (options['indent'] || 2));
  this.skipInvalid = options['skipInvalid'] || false;
  this.flowLevel   = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap    = compileStyleMap(this.schema, options['styles'] || null);

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}


function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

function writeScalar(state, object) {
  var isQuoted, checkpoint, position, length, character, first;

  state.dump = '';
  isQuoted = false;
  checkpoint = 0;
  first = object.charCodeAt(0) || 0;

  if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {
    // Ensure compatibility with YAML 1.0/1.1 loaders.
    isQuoted = true;
  } else if (0 === object.length) {
    // Quote empty string
    isQuoted = true;
  } else if (CHAR_SPACE    === first ||
             CHAR_SPACE    === object.charCodeAt(object.length - 1)) {
    isQuoted = true;
  } else if (CHAR_MINUS    === first ||
             CHAR_QUESTION === first) {
    // Don't check second symbol for simplicity
    isQuoted = true;
  }

  for (position = 0, length = object.length; position < length; position += 1) {
    character = object.charCodeAt(position);

    if (!isQuoted) {
      if (CHAR_TAB                  === character ||
          CHAR_LINE_FEED            === character ||
          CHAR_CARRIAGE_RETURN      === character ||
          CHAR_COMMA                === character ||
          CHAR_LEFT_SQUARE_BRACKET  === character ||
          CHAR_RIGHT_SQUARE_BRACKET === character ||
          CHAR_LEFT_CURLY_BRACKET   === character ||
          CHAR_RIGHT_CURLY_BRACKET  === character ||
          CHAR_SHARP                === character ||
          CHAR_AMPERSAND            === character ||
          CHAR_ASTERISK             === character ||
          CHAR_EXCLAMATION          === character ||
          CHAR_VERTICAL_LINE        === character ||
          CHAR_GREATER_THAN         === character ||
          CHAR_SINGLE_QUOTE         === character ||
          CHAR_DOUBLE_QUOTE         === character ||
          CHAR_PERCENT              === character ||
          CHAR_COMMERCIAL_AT        === character ||
          CHAR_COLON                === character ||
          CHAR_GRAVE_ACCENT         === character) {
        isQuoted = true;
      }
    }

    if (ESCAPE_SEQUENCES[character] ||
        !((0x00020 <= character && character <= 0x00007E) ||
          (0x00085 === character)                         ||
          (0x000A0 <= character && character <= 0x00D7FF) ||
          (0x0E000 <= character && character <= 0x00FFFD) ||
          (0x10000 <= character && character <= 0x10FFFF))) {
      state.dump += object.slice(checkpoint, position);
      state.dump += ESCAPE_SEQUENCES[character] || encodeHex(character);
      checkpoint = position + 1;
      isQuoted = true;
    }
  }

  if (checkpoint < position) {
    state.dump += object.slice(checkpoint, position);
  }

  if (!isQuoted && testImplicitResolving(state, state.dump)) {
    isQuoted = true;
  }

  if (isQuoted) {
    state.dump = '"' + state.dump + '"';
  }
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (0 !== index) {
        _result += ', ';
      }
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || 0 !== index) {
        _result += generateNextLine(state, level);
      }
      _result += '- ' + state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (0 !== index) {
      pairBuffer += ', ';
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) {
      pairBuffer += '? ';
    }

    pairBuffer += state.dump + ': ';

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || 0 !== index) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (null !== state.tag && '?' !== state.tag) ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || (('object' === typeof object) && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if ('[object Function]' === _toString.call(type.represent)) {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (0 > state.flowLevel || state.flowLevel > level);
  }

  if ((null !== state.tag && '?' !== state.tag) || (2 !== state.indent && level > 0)) {
    compact = false;
  }

  var objectOrArray = '[object Object]' === type || '[object Array]' === type,
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if ('[object Object]' === type) {
      if (block && (0 !== Object.keys(state.dump).length)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if ('[object Array]' === type) {
      if (block && (0 !== state.dump.length)) {
        writeBlockSequence(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if ('[object String]' === type) {
      if ('?' !== state.tag) {
        writeScalar(state, state.dump);
      }
    } else if (state.skipInvalid) {
      return false;
    } else {
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (null !== state.tag && '?' !== state.tag) {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var type = _toString.call(object),
      objectKeyList,
      index,
      length;

  if (null !== object && 'object' === typeof object) {
    index = objects.indexOf(object);
    if (-1 !== index) {
      if (-1 === duplicatesIndexes.indexOf(index)) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
    
      if(Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) {
    return state.dump + '\n';
  } else {
    return '';
  }
}


function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.dump     = dump;
module.exports.safeDump = safeDump;

},{"./common":24,"./exception":26,"./schema/default_full":31,"./schema/default_safe":32}],26:[function(require,module,exports){
'use strict';


function YAMLException(reason, mark) {
  this.name    = 'YAMLException';
  this.reason  = reason;
  this.mark    = mark;
  this.message = this.toString(false);
}


YAMLException.prototype.toString = function toString(compact) {
  var result;

  result = 'JS-YAML: ' + (this.reason || '(unknown reason)');

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;

},{}],27:[function(require,module,exports){
'use strict';


var common              = require('./common');
var YAMLException       = require('./exception');
var Mark                = require('./mark');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uD800-\uDFFF\uFFFE\uFFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return 0x2C/* , */ === c ||
         0x5B/* [ */ === c ||
         0x5D/* ] */ === c ||
         0x7B/* { */ === c ||
         0x7D/* } */ === c;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  lc = c | 0x20;
  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
 return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  } else {
    // Encode UTF-16 surrogate pair
    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
    return String.fromCharCode(((c - 0x010000) >> 10) + 0xD800,
                               ((c - 0x010000) & 0x03FF) + 0xDC00);
  }
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  var error = generateError(state, message);

  if (state.onWarning) {
    state.onWarning.call(null, error);
  } else {
    throw error;
  }
}


var directiveHandlers = {

  'YAML': function handleYamlDirective(state, name, args) {

      var match, major, minor;

      if (null !== state.version) {
        throwError(state, 'duplication of %YAML directive');
      }

      if (1 !== args.length) {
        throwError(state, 'YAML directive accepts exactly one argument');
      }

      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

      if (null === match) {
        throwError(state, 'ill-formed argument of the YAML directive');
      }

      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);

      if (1 !== major) {
        throwError(state, 'unacceptable YAML version of the document');
      }

      state.version = args[0];
      state.checkLineBreaks = (minor < 2);

      if (1 !== minor && 2 !== minor) {
        throwWarning(state, 'unsupported YAML version of the document');
      }
    },

  'TAG': function handleTagDirective(state, name, args) {

      var handle, prefix;

      if (2 !== args.length) {
        throwError(state, 'TAG directive accepts exactly two arguments');
      }

      handle = args[0];
      prefix = args[1];

      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
      }

      if (_hasOwnProperty.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }

      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
      }

      state.tagMap[handle] = prefix;
    }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length;
           _position < _length;
           _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(0x09 === _character ||
              0x20 <= _character && _character <= 0x10FFFF)) {
          throwError(state, 'expected valid JSON character');
        }
      }
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
    }
  }
}

function storeMappingPair(state, _result, keyTag, keyNode, valueNode) {
  var index, quantity;

  keyNode = String(keyNode);

  if (null === _result) {
    _result = {};
  }

  if ('tag:yaml.org,2002:merge' === keyTag) {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index]);
      }
    } else {
      mergeMappings(state, _result, valueNode);
    }
  } else {
    _result[keyNode] = valueNode;
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (0x0A/* LF */ === ch) {
    state.position++;
  } else if (0x0D/* CR */ === ch) {
    state.position++;
    if (0x0A/* LF */ === state.input.charCodeAt(state.position)) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && 0x23/* # */ === ch) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && 0 !== ch);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (0x20/* Space */ === ch) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (-1 !== checkIndent && 0 !== lineBreaks && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((0x2D/* - */ === ch || 0x2E/* . */ === ch) &&
      state.input.charCodeAt(_position + 1) === ch &&
      state.input.charCodeAt(_position+ 2) === ch) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (1 === count) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)             ||
      is_FLOW_INDICATOR(ch)        ||
      0x23/* # */           === ch ||
      0x26/* & */           === ch ||
      0x2A/* * */           === ch ||
      0x21/* ! */           === ch ||
      0x7C/* | */           === ch ||
      0x3E/* > */           === ch ||
      0x27/* ' */           === ch ||
      0x22/* " */           === ch ||
      0x25/* % */           === ch ||
      0x40/* @ */           === ch ||
      0x60/* ` */           === ch) {
    return false;
  }

  if (0x3F/* ? */ === ch || 0x2D/* - */ === ch) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (0 !== ch) {
    if (0x3A/* : */ === ch) {
      following = state.input.charCodeAt(state.position+1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (0x23/* # */ === ch) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  } else {
    state.kind = _kind;
    state.result = _result;
    return false;
  }
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (0x27/* ' */ !== ch) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    if (0x27/* ' */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (0x27/* ' */ === ch) {
        captureStart = captureEnd = state.position;
        state.position++;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp, tmpEsc,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x22/* " */ !== ch) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    if (0x22/* " */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (0x5C/* \ */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        //TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D/* ] */;
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D/* } */;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (0 !== ch) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (0x3F/* ? */ === ch) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && 0x3A/* : */ === ch) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (0x2C/* , */ === ch) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (0 !== ch) {
    ch = state.input.charCodeAt(++state.position);

    if (0x2B/* + */ === ch || 0x2D/* - */ === ch) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (0x2B/* + */ === ch) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (0x23/* # */ === ch) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (0 !== ch));
    }
  }

  while (0 !== ch) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (0x20/* Space */ === ch)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (detectedIndent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat('\n', emptyLines + 1);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (0 === emptyLines) {
        if (detectedIndent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {

      // If current line isn't the first one - count line break from the last content line.
      if (detectedIndent) {
        state.result += common.repeat('\n', emptyLines + 1);

      // In case of the first content line - count only empty lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }
    }

    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (0 !== ch))
    { ch = state.input.charCodeAt(++state.position); }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {

    if (0x2D/* - */ !== ch) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (0 !== ch)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  } else {
    return false;
  }
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((0x3F/* ? */ === ch || 0x3A/* : */  === ch) && is_WS_OR_EOL(following)) {

      if (0x3F/* ? */ === ch) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (0x3A/* : */ === ch) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, keyTag, keyNode, valueNode);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (0 !== ch)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x21/* ! */ !== ch) {
    return false;
  }

  if (null !== state.tag) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (0x3C/* < */ === ch) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (0x21/* ! */ === ch) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (0 !== ch && 0x3E/* > */ !== ch);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (0 !== ch && !is_WS_OR_EOL(ch)) {

      if (0x21/* ! */ === ch) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if ('!' === tagHandle) {
    state.tag = '!' + tagName;

  } else if ('!!' === tagHandle) {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x26/* & */ !== ch) {
    return false;
  }

  if (null !== state.anchor) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      len = state.length,
      input = state.input,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x2A/* * */ !== ch) {
    return false;
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent,
      _result;

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (1 === indentStatus) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (1 === indentStatus || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (1 === indentStatus) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (null !== state.tag || null !== state.anchor) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (null === state.tag) {
            state.tag = '?';
          }
        }

        if (null !== state.anchor) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (0 === indentStatus) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (null !== state.tag && '!' !== state.tag) {
    if ('?' === state.tag) {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length;
           typeIndex < typeQuantity;
           typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only assigned to plain scalars. So, it isn't
        // needed to check for 'kind' conformity.

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (null !== state.anchor) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
      type = state.typeMap[state.tag];

      if (null !== state.result && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (null !== state.anchor) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwWarning(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  return null !== state.tag || null !== state.anchor || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || 0x25/* % */ !== ch) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (0 !== ch && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (0 !== ch) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (0x23/* # */ === ch) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (0 !== ch && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) {
        break;
      }

      _position = state.position;

      while (0 !== ch && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (0 !== ch) {
      readLineBreak(state);
    }

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (0 === state.lineIndent &&
      0x2D/* - */ === state.input.charCodeAt(state.position) &&
      0x2D/* - */ === state.input.charCodeAt(state.position + 1) &&
      0x2D/* - */ === state.input.charCodeAt(state.position + 2)) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (0x2E/* . */ === state.input.charCodeAt(state.position)) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (0 !== input.length &&
      0x0A/* LF */ !== input.charCodeAt(input.length - 1) &&
      0x0D/* CR */ !== input.charCodeAt(input.length - 1)) {
    input += '\n';
  }

  var state = new State(input, options);

  if (PATTERN_NON_PRINTABLE.test(state.input)) {
    throwError(state, 'the stream contains non-printable characters');
  }

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (0x20/* Space */ === state.input.charCodeAt(state.position)) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options), index, length;

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options), index, length;

  if (0 === documents.length) {
    return undefined;
  } else if (1 === documents.length) {
    return documents[0];
  } else {
    throw new YAMLException('expected a single document in the stream, but found more');
  }
}


function safeLoadAll(input, output, options) {
  loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;

},{"./common":24,"./exception":26,"./mark":28,"./schema/default_full":31,"./schema/default_safe":32}],28:[function(require,module,exports){
'use strict';


var common = require('./common');


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) {
    return null;
  }

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1))) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end))) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;

},{"./common":24}],29:[function(require,module,exports){
'use strict';


var common        = require('./common');
var YAMLException = require('./exception');
var Type          = require('./type');


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return -1 === exclude.indexOf(index);
  });
}


function compileMap(/* lists... */) {
  var result = {}, index, length;

  function collectType(type) {
    result[type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }

  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && 'scalar' !== type.loadKind) {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
  case 1:
    schemas = Schema.DEFAULT;
    types = arguments[0];
    break;

  case 2:
    schemas = arguments[0];
    types = arguments[1];
    break;

  default:
    throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;

},{"./common":24,"./exception":26,"./type":35}],30:[function(require,module,exports){
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./json')
  ]
});

},{"../schema":29,"./json":34}],31:[function(require,module,exports){
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.


'use strict';


var Schema = require('../schema');


module.exports = Schema.DEFAULT = new Schema({
  include: [
    require('./default_safe')
  ],
  explicit: [
    require('../type/js/undefined'),
    require('../type/js/regexp'),
    require('../type/js/function')
  ]
});

},{"../schema":29,"../type/js/function":40,"../type/js/regexp":41,"../type/js/undefined":42,"./default_safe":32}],32:[function(require,module,exports){
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./core')
  ],
  implicit: [
    require('../type/timestamp'),
    require('../type/merge')
  ],
  explicit: [
    require('../type/binary'),
    require('../type/omap'),
    require('../type/pairs'),
    require('../type/set')
  ]
});

},{"../schema":29,"../type/binary":36,"../type/merge":44,"../type/omap":46,"../type/pairs":47,"../type/set":49,"../type/timestamp":51,"./core":30}],33:[function(require,module,exports){
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  explicit: [
    require('../type/str'),
    require('../type/seq'),
    require('../type/map')
  ]
});

},{"../schema":29,"../type/map":43,"../type/seq":48,"../type/str":50}],34:[function(require,module,exports){
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./failsafe')
  ],
  implicit: [
    require('../type/null'),
    require('../type/bool'),
    require('../type/int'),
    require('../type/float')
  ]
});

},{"../schema":29,"../type/bool":37,"../type/float":38,"../type/int":39,"../type/null":45,"./failsafe":33}],35:[function(require,module,exports){
'use strict';

var YAMLException = require('./exception');

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (null !== map) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;

},{"./exception":26}],36:[function(require,module,exports){
'use strict';


// A trick for browserified version.
// Since we make browserifier to ignore `buffer` module, NodeBuffer will be undefined
var NodeBuffer = require('buffer').Buffer;
var Type       = require('../type');


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (null === data) {
    return false;
  }

  var code, idx, bitlen = 0, len = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx ++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) { continue; }

    // Fail on illegal characters
    if (code < 0) { return false; }

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var code, idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4)*6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    return new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

},{"../type":35,"buffer":11}],37:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlBoolean(data) {
  if (null === data) {
    return false;
  }

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return '[object Boolean]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":35}],38:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

var YAML_FLOAT_PATTERN = new RegExp(
  '^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?' +
  '|\\.[0-9_]+(?:[eE][-+][0-9]+)?' +
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  '|[-+]?\\.(?:inf|Inf|INF)' +
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (null === data) {
    return false;
  }

  var value, sign, base, digits;

  if (!YAML_FLOAT_PATTERN.test(data)) {
    return false;
  }
  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = '-' === value[0] ? -1 : 1;
  digits = [];

  if (0 <= '+-'.indexOf(value[0])) {
    value = value.slice(1);
  }

  if ('.inf' === value) {
    return (1 === sign) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if ('.nan' === value) {
    return NaN;

  } else if (0 <= value.indexOf(':')) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  } else {
    return sign * parseFloat(value, 10);
  }
}

function representYamlFloat(object, style) {
  if (isNaN(object)) {
    switch (style) {
    case 'lowercase':
      return '.nan';
    case 'uppercase':
      return '.NAN';
    case 'camelcase':
      return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
    case 'lowercase':
      return '.inf';
    case 'uppercase':
      return '.INF';
    case 'camelcase':
      return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
    case 'lowercase':
      return '-.inf';
    case 'uppercase':
      return '-.INF';
    case 'camelcase':
      return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  } else {
    return object.toString(10);
  }
}

function isFloat(object) {
  return ('[object Number]' === Object.prototype.toString.call(object)) &&
         (0 !== object % 1 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

},{"../common":24,"../type":35}],39:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (null === data) {
    return false;
  }

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) { return false; }

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index+1 === max) { return true; }
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') { continue; }
        if (ch !== '0' && ch !== '1') {
          return false;
        }
        hasDigits = true;
      }
      return hasDigits;
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') { continue; }
        if (!isHexCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      return hasDigits;
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') { continue; }
      if (!isOctCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    return hasDigits;
  }

  // base 10 (except 0) or base 60

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') { continue; }
    if (ch === ':') { break; }
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  if (!hasDigits) { return false; }

  // if !base60 - done;
  if (ch !== ':') { return true; }

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') { sign = -1; }
    value = value.slice(1);
    ch = value[0];
  }

  if ('0' === value) {
    return 0;
  }

  if (ch === '0') {
    if (value[1] === 'b') {
      return sign * parseInt(value.slice(2), 2);
    }
    if (value[1] === 'x') {
      return sign * parseInt(value, 16);
    }
    return sign * parseInt(value, 8);

  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return ('[object Number]' === Object.prototype.toString.call(object)) &&
         (0 === object % 1 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (object) { return '0b' + object.toString(2); },
    octal:       function (object) { return '0'  + object.toString(8); },
    decimal:     function (object) { return        object.toString(10); },
    hexadecimal: function (object) { return '0x' + object.toString(16).toUpperCase(); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

},{"../common":24,"../type":35}],40:[function(require,module,exports){
'use strict';

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  esprima = require('esprima');
} catch (_) {
  /*global window */
  if (typeof window !== 'undefined') { esprima = window.esprima; }
}

var Type = require('../../type');

function resolveJavascriptFunction(data) {
  if (null === data) {
    return false;
  }

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true }),
        params = [],
        body;

    if ('Program'             !== ast.type         ||
        1                     !== ast.body.length  ||
        'ExpressionStatement' !== ast.body[0].type ||
        'FunctionExpression'  !== ast.body[0].expression.type) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if ('Program'             !== ast.type         ||
      1                     !== ast.body.length  ||
      'ExpressionStatement' !== ast.body[0].type ||
      'FunctionExpression'  !== ast.body[0].expression.type) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  return new Function(params, source.slice(body[0]+1, body[1]-1));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return '[object Function]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

},{"../../type":35,"esprima":52}],41:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptRegExp(data) {
  if (null === data) {
    return false;
  }

  if (0 === data.length) {
    return false;
  }

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if ('/' === regexp[0]) {
    if (tail) {
      modifiers = tail[1];
    }

    if (modifiers.length > 3) { return false; }
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') { return false; }

    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  try {
    var dummy = new RegExp(regexp, modifiers);
    return true;
  } catch (error) {
    return false;
  }
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if ('/' === regexp[0]) {
    if (tail) {
      modifiers = tail[1];
    }
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) {
    result += 'g';
  }

  if (object.multiline) {
    result += 'm';
  }

  if (object.ignoreCase) {
    result += 'i';
  }

  return result;
}

function isRegExp(object) {
  return '[object RegExp]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

},{"../../type":35}],42:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return 'undefined' === typeof object;
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

},{"../../type":35}],43:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return null !== data ? data : {}; }
});

},{"../type":35}],44:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlMerge(data) {
  return '<<' === data || null === data;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

},{"../type":35}],45:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlNull(data) {
  if (null === data) {
    return true;
  }

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return null === object;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":35}],46:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (null === data) {
    return true;
  }

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if ('[object Object]' !== _toString.call(pair)) {
      return false;
    }

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) {
          pairHasKey = true;
        } else {
          return false;
        }
      }
    }

    if (!pairHasKey) {
      return false;
    }

    if (-1 === objectKeys.indexOf(pairKey)) {
      objectKeys.push(pairKey);
    } else {
      return false;
    }
  }

  return true;
}

function constructYamlOmap(data) {
  return null !== data ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

},{"../type":35}],47:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (null === data) {
    return true;
  }

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if ('[object Object]' !== _toString.call(pair)) {
      return false;
    }

    keys = Object.keys(pair);

    if (1 !== keys.length) {
      return false;
    }

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (null === data) {
    return [];
  }

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

},{"../type":35}],48:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return null !== data ? data : []; }
});

},{"../type":35}],49:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (null === data) {
    return true;
  }

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (null !== object[key]) {
        return false;
      }
    }
  }

  return true;
}

function constructYamlSet(data) {
  return null !== data ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

},{"../type":35}],50:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return null !== data ? data : ''; }
});

},{"../type":35}],51:[function(require,module,exports){
'use strict';

var Type = require('../type');

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:(?:[Tt]|[ \\t]+)'              + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?)?$');         // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (null === data) {
    return false;
  }

  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (null === match) {
    return false;
  }

  return true;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (null === match) {
    throw new Error('Date resolve error');
  }

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if ('-' === match[9]) {
      delta = -delta;
    }
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) {
    date.setTime(date.getTime() - delta);
  }

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

},{"../type":35}],52:[function(require,module,exports){
/*
  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.

    /* istanbul ignore next */
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.esprima = {}));
    }
}(this, function (exports) {
    'use strict';

    var Token,
        TokenName,
        FnExprTokens,
        Syntax,
        PlaceHolders,
        PropertyKind,
        Messages,
        Regex,
        source,
        strict,
        index,
        lineNumber,
        lineStart,
        length,
        lookahead,
        state,
        extra;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';
    TokenName[Token.RegularExpression] = 'RegularExpression';

    // A function following one of those tokens is an expression.
    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
                    'return', 'case', 'delete', 'throw', 'void',
                    // assignment operators
                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
                    '&=', '|=', '^=', ',',
                    // binary/unary operators
                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
                    '<=', '<', '>', '!=', '!=='];

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement'
    };

    PlaceHolders = {
        ArrowParameterPlaceHolder: {
            type: 'ArrowParameterPlaceHolder'
        }
    };

    PropertyKind = {
        Data: 1,
        Get: 2,
        Set: 4
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken: 'Unexpected token %0',
        UnexpectedNumber: 'Unexpected number',
        UnexpectedString: 'Unexpected string',
        UnexpectedIdentifier: 'Unexpected identifier',
        UnexpectedReserved: 'Unexpected reserved word',
        UnexpectedEOS: 'Unexpected end of input',
        NewlineAfterThrow: 'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp: 'Invalid regular expression: missing /',
        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally: 'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith: 'Strict mode code may not include a with statement',
        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
        StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',
        AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',
        AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',
        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord: 'Use of future reserved word in strict mode'
    };

    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        /* istanbul ignore if */
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function isDecimalDigit(ch) {
        return (ch >= 0x30 && ch <= 0x39);   // 0..9
    }

    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }

    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }


    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    // 7.6.1.2 Future Reserved Words

    function isFutureReservedWord(id) {
        switch (id) {
        case 'class':
        case 'enum':
        case 'export':
        case 'extends':
        case 'import':
        case 'super':
            return true;
        default:
            return false;
        }
    }

    function isStrictModeReservedWord(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // 7.6.1.1 Keywords

    function isKeyword(id) {
        if (strict && isStrictModeReservedWord(id)) {
            return true;
        }

        // 'const' is specialized as Keyword in V8.
        // 'yield' and 'let' are for compatibility with SpiderMonkey and ES.next.
        // Some others are from future reserved words.

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') ||
                (id === 'try') || (id === 'let');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    // 7.4 Comments

    function addComment(type, value, start, end, loc) {
        var comment;

        assert(typeof start === 'number', 'Comment must have valid position');

        // Because the way the actual token is scanned, often the comments
        // (if any) are skipped twice during the lexical analysis.
        // Thus, we need to skip adding a comment if the comment array already
        // handled it.
        if (state.lastCommentStart >= start) {
            return;
        }
        state.lastCommentStart = start;

        comment = {
            type: type,
            value: value
        };
        if (extra.range) {
            comment.range = [start, end];
        }
        if (extra.loc) {
            comment.loc = loc;
        }
        extra.comments.push(comment);
        if (extra.attachComment) {
            extra.leadingComments.push(comment);
            extra.trailingComments.push(comment);
        }
    }

    function skipSingleLineComment(offset) {
        var start, loc, ch, comment;

        start = index - offset;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart - offset
            }
        };

        while (index < length) {
            ch = source.charCodeAt(index);
            ++index;
            if (isLineTerminator(ch)) {
                if (extra.comments) {
                    comment = source.slice(start + offset, index - 1);
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    addComment('Line', comment, start, index - 1, loc);
                }
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                return;
            }
        }

        if (extra.comments) {
            comment = source.slice(start + offset, index);
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            addComment('Line', comment, start, index, loc);
        }
    }

    function skipMultiLineComment() {
        var start, loc, ch, comment;

        if (extra.comments) {
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (isLineTerminator(ch)) {
                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                ++index;
                lineStart = index;
                if (index >= length) {
                    throwUnexpectedToken();
                }
            } else if (ch === 0x2A) {
                // Block comment ends with '*/'.
                if (source.charCodeAt(index + 1) === 0x2F) {
                    ++index;
                    ++index;
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 2);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment('Block', comment, start, index, loc);
                    }
                    return;
                }
                ++index;
            } else {
                ++index;
            }
        }

        throwUnexpectedToken();
    }

    function skipComment() {
        var ch, start;

        start = (index === 0);
        while (index < length) {
            ch = source.charCodeAt(index);

            if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                ++index;
                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                start = true;
            } else if (ch === 0x2F) { // U+002F is '/'
                ch = source.charCodeAt(index + 1);
                if (ch === 0x2F) {
                    ++index;
                    ++index;
                    skipSingleLineComment(2);
                    start = true;
                } else if (ch === 0x2A) {  // U+002A is '*'
                    ++index;
                    ++index;
                    skipMultiLineComment();
                } else {
                    break;
                }
            } else if (start && ch === 0x2D) { // U+002D is '-'
                // U+003E is '>'
                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
                    // '-->' is a single-line comment
                    index += 3;
                    skipSingleLineComment(3);
                } else {
                    break;
                }
            } else if (ch === 0x3C) { // U+003C is '<'
                if (source.slice(index + 1, index + 4) === '!--') {
                    ++index; // `<`
                    ++index; // `!`
                    ++index; // `-`
                    ++index; // `-`
                    skipSingleLineComment(4);
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function scanUnicodeCodePointEscape() {
        var ch, code, cu1, cu2;

        ch = source[index];
        code = 0;

        // At least, one hex digit is required.
        if (ch === '}') {
            throwUnexpectedToken();
        }

        while (index < length) {
            ch = source[index++];
            if (!isHexDigit(ch)) {
                break;
            }
            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
        }

        if (code > 0x10FFFF || ch !== '}') {
            throwUnexpectedToken();
        }

        // UTF-16 Encoding
        if (code <= 0xFFFF) {
            return String.fromCharCode(code);
        }
        cu1 = ((code - 0x10000) >> 10) + 0xD800;
        cu2 = ((code - 0x10000) & 1023) + 0xDC00;
        return String.fromCharCode(cu1, cu2);
    }

    function getEscapedIdentifier() {
        var ch, id;

        ch = source.charCodeAt(index++);
        id = String.fromCharCode(ch);

        // '\u' (U+005C, U+0075) denotes an escaped character.
        if (ch === 0x5C) {
            if (source.charCodeAt(index) !== 0x75) {
                throwUnexpectedToken();
            }
            ++index;
            ch = scanHexEscape('u');
            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
                throwUnexpectedToken();
            }
            id = ch;
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (!isIdentifierPart(ch)) {
                break;
            }
            ++index;
            id += String.fromCharCode(ch);

            // '\u' (U+005C, U+0075) denotes an escaped character.
            if (ch === 0x5C) {
                id = id.substr(0, id.length - 1);
                if (source.charCodeAt(index) !== 0x75) {
                    throwUnexpectedToken();
                }
                ++index;
                ch = scanHexEscape('u');
                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
                    throwUnexpectedToken();
                }
                id += ch;
            }
        }

        return id;
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (ch === 0x5C) {
                // Blackslash (U+005C) marks Unicode escape sequence.
                index = start;
                return getEscapedIdentifier();
            }
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        // Backslash (U+005C) starts an escaped character.
        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }


    // 7.7 Punctuators

    function scanPunctuator() {
        var start = index,
            code = source.charCodeAt(index),
            code2,
            ch1 = source[index],
            ch2,
            ch3,
            ch4;

        switch (code) {

        // Check for most common single-character punctuators.
        case 0x2E:  // . dot
        case 0x28:  // ( open bracket
        case 0x29:  // ) close bracket
        case 0x3B:  // ; semicolon
        case 0x2C:  // , comma
        case 0x7B:  // { open curly brace
        case 0x7D:  // } close curly brace
        case 0x5B:  // [
        case 0x5D:  // ]
        case 0x3A:  // :
        case 0x3F:  // ?
        case 0x7E:  // ~
            ++index;
            if (extra.tokenize) {
                if (code === 0x28) {
                    extra.openParenToken = extra.tokens.length;
                } else if (code === 0x7B) {
                    extra.openCurlyToken = extra.tokens.length;
                }
            }
            return {
                type: Token.Punctuator,
                value: String.fromCharCode(code),
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };

        default:
            code2 = source.charCodeAt(index + 1);

            // '=' (U+003D) marks an assignment or comparison operator.
            if (code2 === 0x3D) {
                switch (code) {
                case 0x2B:  // +
                case 0x2D:  // -
                case 0x2F:  // /
                case 0x3C:  // <
                case 0x3E:  // >
                case 0x5E:  // ^
                case 0x7C:  // |
                case 0x25:  // %
                case 0x26:  // &
                case 0x2A:  // *
                    index += 2;
                    return {
                        type: Token.Punctuator,
                        value: String.fromCharCode(code) + String.fromCharCode(code2),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        start: start,
                        end: index
                    };

                case 0x21: // !
                case 0x3D: // =
                    index += 2;

                    // !== and ===
                    if (source.charCodeAt(index) === 0x3D) {
                        ++index;
                    }
                    return {
                        type: Token.Punctuator,
                        value: source.slice(start, index),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        start: start,
                        end: index
                    };
                }
            }
        }

        // 4-character punctuator: >>>=

        ch4 = source.substr(index, 4);

        if (ch4 === '>>>=') {
            index += 4;
            return {
                type: Token.Punctuator,
                value: ch4,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        // 3-character punctuators: === !== >>> <<= >>=

        ch3 = ch4.substr(0, 3);

        if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: ch3,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        // Other 2-character punctuators: ++ -- << >> && ||
        ch2 = ch3.substr(0, 2);

        if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {
            index += 2;
            return {
                type: Token.Punctuator,
                value: ch2,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        // 1-character punctuators: < > = ! + - * % & | ^ /

        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        throwUnexpectedToken();
    }

    // 7.8.3 Numeric Literals

    function scanHexLiteral(start) {
        var number = '';

        while (index < length) {
            if (!isHexDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            throwUnexpectedToken();
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt('0x' + number, 16),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanBinaryLiteral(start) {
        var ch, number;

        number = '';

        while (index < length) {
            ch = source[index];
            if (ch !== '0' && ch !== '1') {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            // only 0b or 0B
            throwUnexpectedToken();
        }

        if (index < length) {
            ch = source.charCodeAt(index);
            /* istanbul ignore else */
            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                throwUnexpectedToken();
            }
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 2),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanOctalLiteral(prefix, start) {
        var number, octal;

        if (isOctalDigit(prefix)) {
            octal = true;
            number = '0' + source[index++];
        } else {
            octal = false;
            ++index;
            number = '';
        }

        while (index < length) {
            if (!isOctalDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (!octal && number.length === 0) {
            // only 0o or 0O
            throwUnexpectedToken();
        }

        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function isImplicitOctalLiteral() {
        var i, ch;

        // Implicit octal, unless there is a non-octal digit.
        // (Annex B.1.1 on Numeric Literals)
        for (i = index + 1; i < length; ++i) {
            ch = source[i];
            if (ch === '8' || ch === '9') {
                return false;
            }
            if (!isOctalDigit(ch)) {
                return true;
            }
        }

        return true;
    }

    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            // Octal number in ES6 starts with '0o'.
            // Binary number in ES6 starts with '0b'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    ++index;
                    return scanHexLiteral(start);
                }
                if (ch === 'b' || ch === 'B') {
                    ++index;
                    return scanBinaryLiteral(start);
                }
                if (ch === 'o' || ch === 'O') {
                    return scanOctalLiteral(ch, start);
                }

                if (isOctalDigit(ch)) {
                    if (isImplicitOctalLiteral()) {
                        return scanOctalLiteral(ch, start);
                    }
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwUnexpectedToken();
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwUnexpectedToken();
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    // 7.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            str += scanUnicodeCodePointEscape();
                        } else {
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) {
                                str += unescaped;
                            } else {
                                index = restore;
                                str += ch;
                            }
                        }
                        break;
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\x0B';
                        break;

                    default:
                        if (isOctalDigit(ch)) {
                            code = '01234567'.indexOf(ch);

                            // \0 is not octal escape sequence
                            if (code !== 0) {
                                octal = true;
                            }

                            if (index < length && isOctalDigit(source[index])) {
                                octal = true;
                                code = code * 8 + '01234567'.indexOf(source[index++]);

                                // 3 digits are only allowed when string starts
                                // with 0, 1, 2, 3
                                if ('0123'.indexOf(ch) >= 0 &&
                                        index < length &&
                                        isOctalDigit(source[index])) {
                                    code = code * 8 + '01234567'.indexOf(source[index++]);
                                }
                            }
                            str += String.fromCharCode(code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwUnexpectedToken();
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            startLineNumber: startLineNumber,
            startLineStart: startLineStart,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function testRegExp(pattern, flags) {
        var tmp = pattern,
            value;

        if (flags.indexOf('u') >= 0) {
            // Replace each astral symbol and every Unicode code point
            // escape sequence with a single ASCII symbol to avoid throwing on
            // regular expressions that are only valid in combination with the
            // `/u` flag.
            // Note: replacing with the ASCII symbol `x` might cause false
            // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
            // perfectly valid pattern that is equivalent to `[a-b]`, but it
            // would be replaced by `[x-b]` which throws an error.
            tmp = tmp
                .replace(/\\u\{([0-9a-fA-F]+)\}/g, function ($0, $1) {
                    if (parseInt($1, 16) <= 0x10FFFF) {
                        return 'x';
                    }
                    throwError(Messages.InvalidRegExp);
                })
                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, 'x');
        }

        // First, detect invalid regular expressions.
        try {
            value = new RegExp(tmp);
        } catch (e) {
            throwError(Messages.InvalidRegExp);
        }

        // Return a regular expression object for this pattern-flag pair, or
        // `null` in case the current environment doesn't support the flags it
        // uses.
        try {
            return new RegExp(pattern, flags);
        } catch (exception) {
            return null;
        }
    }

    function scanRegExpBody() {
        var ch, str, classMarker, terminated, body;

        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];

        classMarker = false;
        terminated = false;
        while (index < length) {
            ch = source[index++];
            str += ch;
            if (ch === '\\') {
                ch = source[index++];
                // ECMA-262 7.8.5
                if (isLineTerminator(ch.charCodeAt(0))) {
                    throwError(Messages.UnterminatedRegExp);
                }
                str += ch;
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                throwError(Messages.UnterminatedRegExp);
            } else if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                }
            }
        }

        if (!terminated) {
            throwError(Messages.UnterminatedRegExp);
        }

        // Exclude leading and trailing slash.
        body = str.substr(1, str.length - 2);
        return {
            value: body,
            literal: str
        };
    }

    function scanRegExpFlags() {
        var ch, str, flags, restore;

        str = '';
        flags = '';
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch.charCodeAt(0))) {
                break;
            }

            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        for (str += '\\u'; restore < index; ++restore) {
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                    tolerateUnexpectedToken();
                } else {
                    str += '\\';
                    tolerateUnexpectedToken();
                }
            } else {
                flags += ch;
                str += ch;
            }
        }

        return {
            value: flags,
            literal: str
        };
    }

    function scanRegExp() {
        var start, body, flags, value;

        lookahead = null;
        skipComment();
        start = index;

        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);

        if (extra.tokenize) {
            return {
                type: Token.RegularExpression,
                value: value,
                regex: {
                    pattern: body.value,
                    flags: flags.value
                },
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        return {
            literal: body.literal + flags.literal,
            value: value,
            regex: {
                pattern: body.value,
                flags: flags.value
            },
            start: start,
            end: index
        };
    }

    function collectRegex() {
        var pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        regex = scanRegExp();

        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        /* istanbul ignore next */
        if (!extra.tokenize) {
            // Pop the previous token, which is likely '/' or '/='
            if (extra.tokens.length > 0) {
                token = extra.tokens[extra.tokens.length - 1];
                if (token.range[0] === pos && token.type === 'Punctuator') {
                    if (token.value === '/' || token.value === '/=') {
                        extra.tokens.pop();
                    }
                }
            }

            extra.tokens.push({
                type: 'RegularExpression',
                value: regex.literal,
                regex: regex.regex,
                range: [pos, index],
                loc: loc
            });
        }

        return regex;
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advanceSlash() {
        var prevToken,
            checkToken;
        // Using the following algorithm:
        // https://github.com/mozilla/sweet.js/wiki/design
        prevToken = extra.tokens[extra.tokens.length - 1];
        if (!prevToken) {
            // Nothing before that: it cannot be a division.
            return collectRegex();
        }
        if (prevToken.type === 'Punctuator') {
            if (prevToken.value === ']') {
                return scanPunctuator();
            }
            if (prevToken.value === ')') {
                checkToken = extra.tokens[extra.openParenToken - 1];
                if (checkToken &&
                        checkToken.type === 'Keyword' &&
                        (checkToken.value === 'if' ||
                         checkToken.value === 'while' ||
                         checkToken.value === 'for' ||
                         checkToken.value === 'with')) {
                    return collectRegex();
                }
                return scanPunctuator();
            }
            if (prevToken.value === '}') {
                // Dividing a function by anything makes little sense,
                // but we have to check for that.
                if (extra.tokens[extra.openCurlyToken - 3] &&
                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                    // Anonymous function.
                    checkToken = extra.tokens[extra.openCurlyToken - 4];
                    if (!checkToken) {
                        return scanPunctuator();
                    }
                } else if (extra.tokens[extra.openCurlyToken - 4] &&
                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                    // Named function.
                    checkToken = extra.tokens[extra.openCurlyToken - 5];
                    if (!checkToken) {
                        return collectRegex();
                    }
                } else {
                    return scanPunctuator();
                }
                // checkToken determines whether the function is
                // a declaration or an expression.
                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
                    // It is an expression.
                    return scanPunctuator();
                }
                // It is a declaration.
                return collectRegex();
            }
            return collectRegex();
        }
        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
            return collectRegex();
        }
        return scanPunctuator();
    }

    function advance() {
        var ch;

        skipComment();

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: index,
                end: index
            };
        }

        ch = source.charCodeAt(index);

        if (isIdentifierStart(ch)) {
            return scanIdentifier();
        }

        // Very common: ( and ) and ;
        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
            return scanPunctuator();
        }

        // String literal starts with single quote (U+0027) or double quote (U+0022).
        if (ch === 0x27 || ch === 0x22) {
            return scanStringLiteral();
        }


        // Dot (.) U+002E can also start a floating-point number, hence the need
        // to check the next character.
        if (ch === 0x2E) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }

        // Slash (/) U+002F can also start a regex.
        if (extra.tokenize && ch === 0x2F) {
            return advanceSlash();
        }

        return scanPunctuator();
    }

    function collectToken() {
        var loc, token, value, entry;

        skipComment();
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        token = advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (token.type !== Token.EOF) {
            value = source.slice(token.start, token.end);
            entry = {
                type: TokenName[token.type],
                value: value,
                range: [token.start, token.end],
                loc: loc
            };
            if (token.regex) {
                entry.regex = {
                    pattern: token.regex.pattern,
                    flags: token.regex.flags
                };
            }
            extra.tokens.push(entry);
        }

        return token;
    }

    function lex() {
        var token;

        token = lookahead;
        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();

        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        return token;
    }

    function peek() {
        var pos, line, start;

        pos = index;
        line = lineNumber;
        start = lineStart;
        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        index = pos;
        lineNumber = line;
        lineStart = start;
    }

    function Position() {
        this.line = lineNumber;
        this.column = index - lineStart;
    }

    function SourceLocation() {
        this.start = new Position();
        this.end = null;
    }

    function WrappingSourceLocation(startToken) {
        if (startToken.type === Token.StringLiteral) {
            this.start = {
                line: startToken.startLineNumber,
                column: startToken.start - startToken.startLineStart
            };
        } else {
            this.start = {
                line: startToken.lineNumber,
                column: startToken.start - startToken.lineStart
            };
        }
        this.end = null;
    }

    function Node() {
        // Skip comment.
        index = lookahead.start;
        if (lookahead.type === Token.StringLiteral) {
            lineNumber = lookahead.startLineNumber;
            lineStart = lookahead.startLineStart;
        } else {
            lineNumber = lookahead.lineNumber;
            lineStart = lookahead.lineStart;
        }
        if (extra.range) {
            this.range = [index, 0];
        }
        if (extra.loc) {
            this.loc = new SourceLocation();
        }
    }

    function WrappingNode(startToken) {
        if (extra.range) {
            this.range = [startToken.start, 0];
        }
        if (extra.loc) {
            this.loc = new WrappingSourceLocation(startToken);
        }
    }

    WrappingNode.prototype = Node.prototype = {

        processComment: function () {
            var lastChild,
                leadingComments,
                trailingComments,
                bottomRight = extra.bottomRightStack,
                i,
                comment,
                last = bottomRight[bottomRight.length - 1];

            if (this.type === Syntax.Program) {
                if (this.body.length > 0) {
                    return;
                }
            }

            if (extra.trailingComments.length > 0) {
                trailingComments = [];
                for (i = extra.trailingComments.length - 1; i >= 0; --i) {
                    comment = extra.trailingComments[i];
                    if (comment.range[0] >= this.range[1]) {
                        trailingComments.unshift(comment);
                        extra.trailingComments.splice(i, 1);
                    }
                }
                extra.trailingComments = [];
            } else {
                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {
                    trailingComments = last.trailingComments;
                    delete last.trailingComments;
                }
            }

            // Eating the stack.
            if (last) {
                while (last && last.range[0] >= this.range[0]) {
                    lastChild = last;
                    last = bottomRight.pop();
                }
            }

            if (lastChild) {
                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= this.range[0]) {
                    this.leadingComments = lastChild.leadingComments;
                    lastChild.leadingComments = undefined;
                }
            } else if (extra.leadingComments.length > 0) {
                leadingComments = [];
                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
                    comment = extra.leadingComments[i];
                    if (comment.range[1] <= this.range[0]) {
                        leadingComments.unshift(comment);
                        extra.leadingComments.splice(i, 1);
                    }
                }
            }


            if (leadingComments && leadingComments.length > 0) {
                this.leadingComments = leadingComments;
            }
            if (trailingComments && trailingComments.length > 0) {
                this.trailingComments = trailingComments;
            }

            bottomRight.push(this);
        },

        finish: function () {
            if (extra.range) {
                this.range[1] = index;
            }
            if (extra.loc) {
                this.loc.end = new Position();
                if (extra.source) {
                    this.loc.source = extra.source;
                }
            }

            if (extra.attachComment) {
                this.processComment();
            }
        },

        finishArrayExpression: function (elements) {
            this.type = Syntax.ArrayExpression;
            this.elements = elements;
            this.finish();
            return this;
        },

        finishArrowFunctionExpression: function (params, defaults, body, expression) {
            this.type = Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.rest = null;
            this.generator = false;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishAssignmentExpression: function (operator, left, right) {
            this.type = Syntax.AssignmentExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBinaryExpression: function (operator, left, right) {
            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBlockStatement: function (body) {
            this.type = Syntax.BlockStatement;
            this.body = body;
            this.finish();
            return this;
        },

        finishBreakStatement: function (label) {
            this.type = Syntax.BreakStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishCallExpression: function (callee, args) {
            this.type = Syntax.CallExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishCatchClause: function (param, body) {
            this.type = Syntax.CatchClause;
            this.param = param;
            this.body = body;
            this.finish();
            return this;
        },

        finishConditionalExpression: function (test, consequent, alternate) {
            this.type = Syntax.ConditionalExpression;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishContinueStatement: function (label) {
            this.type = Syntax.ContinueStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishDebuggerStatement: function () {
            this.type = Syntax.DebuggerStatement;
            this.finish();
            return this;
        },

        finishDoWhileStatement: function (body, test) {
            this.type = Syntax.DoWhileStatement;
            this.body = body;
            this.test = test;
            this.finish();
            return this;
        },

        finishEmptyStatement: function () {
            this.type = Syntax.EmptyStatement;
            this.finish();
            return this;
        },

        finishExpressionStatement: function (expression) {
            this.type = Syntax.ExpressionStatement;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishForStatement: function (init, test, update, body) {
            this.type = Syntax.ForStatement;
            this.init = init;
            this.test = test;
            this.update = update;
            this.body = body;
            this.finish();
            return this;
        },

        finishForInStatement: function (left, right, body) {
            this.type = Syntax.ForInStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.each = false;
            this.finish();
            return this;
        },

        finishFunctionDeclaration: function (id, params, defaults, body) {
            this.type = Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.rest = null;
            this.generator = false;
            this.expression = false;
            this.finish();
            return this;
        },

        finishFunctionExpression: function (id, params, defaults, body) {
            this.type = Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.rest = null;
            this.generator = false;
            this.expression = false;
            this.finish();
            return this;
        },

        finishIdentifier: function (name) {
            this.type = Syntax.Identifier;
            this.name = name;
            this.finish();
            return this;
        },

        finishIfStatement: function (test, consequent, alternate) {
            this.type = Syntax.IfStatement;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishLabeledStatement: function (label, body) {
            this.type = Syntax.LabeledStatement;
            this.label = label;
            this.body = body;
            this.finish();
            return this;
        },

        finishLiteral: function (token) {
            this.type = Syntax.Literal;
            this.value = token.value;
            this.raw = source.slice(token.start, token.end);
            if (token.regex) {
                this.regex = token.regex;
            }
            this.finish();
            return this;
        },

        finishMemberExpression: function (accessor, object, property) {
            this.type = Syntax.MemberExpression;
            this.computed = accessor === '[';
            this.object = object;
            this.property = property;
            this.finish();
            return this;
        },

        finishNewExpression: function (callee, args) {
            this.type = Syntax.NewExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishObjectExpression: function (properties) {
            this.type = Syntax.ObjectExpression;
            this.properties = properties;
            this.finish();
            return this;
        },

        finishPostfixExpression: function (operator, argument) {
            this.type = Syntax.UpdateExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = false;
            this.finish();
            return this;
        },

        finishProgram: function (body) {
            this.type = Syntax.Program;
            this.body = body;
            this.finish();
            return this;
        },

        finishProperty: function (kind, key, value, method, shorthand) {
            this.type = Syntax.Property;
            this.key = key;
            this.value = value;
            this.kind = kind;
            this.method = method;
            this.shorthand = shorthand;
            this.finish();
            return this;
        },

        finishReturnStatement: function (argument) {
            this.type = Syntax.ReturnStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishSequenceExpression: function (expressions) {
            this.type = Syntax.SequenceExpression;
            this.expressions = expressions;
            this.finish();
            return this;
        },

        finishSwitchCase: function (test, consequent) {
            this.type = Syntax.SwitchCase;
            this.test = test;
            this.consequent = consequent;
            this.finish();
            return this;
        },

        finishSwitchStatement: function (discriminant, cases) {
            this.type = Syntax.SwitchStatement;
            this.discriminant = discriminant;
            this.cases = cases;
            this.finish();
            return this;
        },

        finishThisExpression: function () {
            this.type = Syntax.ThisExpression;
            this.finish();
            return this;
        },

        finishThrowStatement: function (argument) {
            this.type = Syntax.ThrowStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishTryStatement: function (block, guardedHandlers, handlers, finalizer) {
            this.type = Syntax.TryStatement;
            this.block = block;
            this.guardedHandlers = guardedHandlers;
            this.handlers = handlers;
            this.finalizer = finalizer;
            this.finish();
            return this;
        },

        finishUnaryExpression: function (operator, argument) {
            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = true;
            this.finish();
            return this;
        },

        finishVariableDeclaration: function (declarations, kind) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = kind;
            this.finish();
            return this;
        },

        finishVariableDeclarator: function (id, init) {
            this.type = Syntax.VariableDeclarator;
            this.id = id;
            this.init = init;
            this.finish();
            return this;
        },

        finishWhileStatement: function (test, body) {
            this.type = Syntax.WhileStatement;
            this.test = test;
            this.body = body;
            this.finish();
            return this;
        },

        finishWithStatement: function (object, body) {
            this.type = Syntax.WithStatement;
            this.object = object;
            this.body = body;
            this.finish();
            return this;
        }
    };

    // Return true if there is a line terminator before the next token.

    function peekLineTerminator() {
        var pos, line, start, found;

        pos = index;
        line = lineNumber;
        start = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start;

        return found;
    }

    function createError(line, pos, description) {
        var error = new Error('Line ' + line + ': ' + description);
        error.index = pos;
        error.lineNumber = line;
        error.column = pos - lineStart + 1;
        error.description = description;
        return error;
    }

    // Throw an exception

    function throwError(messageFormat) {
        var args, msg;

        args = Array.prototype.slice.call(arguments, 1);
        msg = messageFormat.replace(/%(\d)/g,
            function (whole, idx) {
                assert(idx < args.length, 'Message reference must be in range');
                return args[idx];
            }
        );

        throw createError(lineNumber, index, msg);
    }

    function tolerateError(messageFormat) {
        var args, msg, error;

        args = Array.prototype.slice.call(arguments, 1);
        /* istanbul ignore next */
        msg = messageFormat.replace(/%(\d)/g,
            function (whole, idx) {
                assert(idx < args.length, 'Message reference must be in range');
                return args[idx];
            }
        );

        error = createError(lineNumber, index, msg);
        if (extra.errors) {
            extra.errors.push(error);
        } else {
            throw error;
        }
    }

    // Throw an exception because of the token.

    function unexpectedTokenError(token, message) {
        var msg = Messages.UnexpectedToken;

        if (token) {
            msg = message ? message :
                (token.type === Token.EOF) ? Messages.UnexpectedEOS :
                (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :
                (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :
                (token.type === Token.StringLiteral) ? Messages.UnexpectedString :
                Messages.UnexpectedToken;

            if (token.type === Token.Keyword) {
                if (isFutureReservedWord(token.value)) {
                    msg = Messages.UnexpectedReserved;
                } else if (strict && isStrictModeReservedWord(token.value)) {
                    msg = Messages.StrictReservedWord;
                }
            }
        }

        msg = msg.replace('%0', token ? token.value : 'ILLEGAL');

        return (token && typeof token.lineNumber === 'number') ?
            createError(token.lineNumber, token.start, msg) :
            createError(lineNumber, index, msg);
    }

    function throwUnexpectedToken(token, message) {
        throw unexpectedTokenError(token, message);
    }

    function tolerateUnexpectedToken(token, message) {
        var error = unexpectedTokenError(token, message);
        if (extra.errors) {
            extra.errors.push(error);
        } else {
            throw error;
        }
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpectedToken(token);
        }
    }

    /**
     * @name expectCommaSeparator
     * @description Quietly expect a comma when in tolerant mode, otherwise delegates
     * to <code>expect(value)</code>
     * @since 2.0
     */
    function expectCommaSeparator() {
        var token;

        if (extra.errors) {
            token = lookahead;
            if (token.type === Token.Punctuator && token.value === ',') {
                lex();
            } else if (token.type === Token.Punctuator && token.value === ';') {
                lex();
                tolerateUnexpectedToken(token);
            } else {
                tolerateUnexpectedToken(token, Messages.UnexpectedToken);
            }
        } else {
            expect(',');
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpectedToken(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }

    // Return true if the next token is an assignment operator

    function matchAssign() {
        var op;

        if (lookahead.type !== Token.Punctuator) {
            return false;
        }
        op = lookahead.value;
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    function consumeSemicolon() {
        var line, oldIndex = index, oldLineNumber = lineNumber,
            oldLineStart = lineStart, oldLookahead = lookahead;

        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(index) === 0x3B || match(';')) {
            lex();
            return;
        }

        line = lineNumber;
        skipComment();
        if (lineNumber !== line) {
            index = oldIndex;
            lineNumber = oldLineNumber;
            lineStart = oldLineStart;
            lookahead = oldLookahead;
            return;
        }

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpectedToken(lookahead);
        }
    }

    // Return true if provided expression is LeftHandSideExpression

    function isLeftHandSide(expr) {
        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
    }

    // 11.1.4 Array Initialiser

    function parseArrayInitialiser() {
        var elements = [], node = new Node();

        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                elements.push(parseAssignmentExpression());

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        lex();

        return node.finishArrayExpression(elements);
    }

    // 11.1.5 Object Initialiser

    function parsePropertyFunction(param, first) {
        var previousStrict, body, node = new Node();

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (first && strict && isRestrictedWord(param[0].name)) {
            tolerateUnexpectedToken(first, Messages.StrictParamName);
        }
        strict = previousStrict;
        return node.finishFunctionExpression(null, param, [], body);
    }

    function parsePropertyMethodFunction() {
        var previousStrict, param, method;

        previousStrict = strict;
        strict = true;
        param = parseParams();
        method = parsePropertyFunction(param.params);
        strict = previousStrict;

        return method;
    }

    function parseObjectPropertyKey() {
        var token, node = new Node();

        token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
            if (strict && token.octal) {
                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
            }
            return node.finishLiteral(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseObjectProperty() {
        var token, key, id, value, param, node = new Node();

        token = lookahead;

        if (token.type === Token.Identifier) {

            id = parseObjectPropertyKey();

            // Property Assignment: Getter and Setter.

            if (token.value === 'get' && !(match(':') || match('('))) {
                key = parseObjectPropertyKey();
                expect('(');
                expect(')');
                value = parsePropertyFunction([]);
                return node.finishProperty('get', key, value, false, false);
            }
            if (token.value === 'set' && !(match(':') || match('('))) {
                key = parseObjectPropertyKey();
                expect('(');
                token = lookahead;
                if (token.type !== Token.Identifier) {
                    expect(')');
                    tolerateUnexpectedToken(token);
                    value = parsePropertyFunction([]);
                } else {
                    param = [ parseVariableIdentifier() ];
                    expect(')');
                    value = parsePropertyFunction(param, token);
                }
                return node.finishProperty('set', key, value, false, false);
            }
            if (match(':')) {
                lex();
                value = parseAssignmentExpression();
                return node.finishProperty('init', id, value, false, false);
            }
            if (match('(')) {
                value = parsePropertyMethodFunction();
                return node.finishProperty('init', id, value, true, false);
            }

            value = id;
            return node.finishProperty('init', id, value, false, true);
        }
        if (token.type === Token.EOF || token.type === Token.Punctuator) {
            throwUnexpectedToken(token);
        } else {
            key = parseObjectPropertyKey();
            if (match(':')) {
                lex();
                value = parseAssignmentExpression();
                return node.finishProperty('init', key, value, false, false);
            }
            if (match('(')) {
                value = parsePropertyMethodFunction();
                return node.finishProperty('init', key, value, true, false);
            }
            throwUnexpectedToken(lex());
        }
    }

    function parseObjectInitialiser() {
        var properties = [], property, name, key, kind, map = {}, toString = String, node = new Node();

        expect('{');

        while (!match('}')) {
            property = parseObjectProperty();

            if (property.key.type === Syntax.Identifier) {
                name = property.key.name;
            } else {
                name = toString(property.key.value);
            }
            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;

            key = '$' + name;
            if (Object.prototype.hasOwnProperty.call(map, key)) {
                if (map[key] === PropertyKind.Data) {
                    if (strict && kind === PropertyKind.Data) {
                        tolerateError(Messages.StrictDuplicateProperty);
                    } else if (kind !== PropertyKind.Data) {
                        tolerateError(Messages.AccessorDataProperty);
                    }
                } else {
                    if (kind === PropertyKind.Data) {
                        tolerateError(Messages.AccessorDataProperty);
                    } else if (map[key] & kind) {
                        tolerateError(Messages.AccessorGetSet);
                    }
                }
                map[key] |= kind;
            } else {
                map[key] = kind;
            }

            properties.push(property);

            if (!match('}')) {
                expectCommaSeparator();
            }
        }

        expect('}');

        return node.finishObjectExpression(properties);
    }

    // 11.1.6 The Grouping Operator

    function parseGroupExpression() {
        var expr;

        expect('(');

        if (match(')')) {
            lex();
            return PlaceHolders.ArrowParameterPlaceHolder;
        }

        ++state.parenthesisCount;

        expr = parseExpression();

        expect(')');

        return expr;
    }


    // 11.1 Primary Expressions

    function parsePrimaryExpression() {
        var type, token, expr, node;

        if (match('(')) {
            return parseGroupExpression();
        }

        if (match('[')) {
            return parseArrayInitialiser();
        }

        if (match('{')) {
            return parseObjectInitialiser();
        }

        type = lookahead.type;
        node = new Node();

        if (type === Token.Identifier) {
            expr = node.finishIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            if (strict && lookahead.octal) {
                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);
            }
            expr = node.finishLiteral(lex());
        } else if (type === Token.Keyword) {
            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }
            if (matchKeyword('this')) {
                lex();
                expr = node.finishThisExpression();
            } else {
                throwUnexpectedToken(lex());
            }
        } else if (type === Token.BooleanLiteral) {
            token = lex();
            token.value = (token.value === 'true');
            expr = node.finishLiteral(token);
        } else if (type === Token.NullLiteral) {
            token = lex();
            token.value = null;
            expr = node.finishLiteral(token);
        } else if (match('/') || match('/=')) {
            if (typeof extra.tokens !== 'undefined') {
                expr = node.finishLiteral(collectRegex());
            } else {
                expr = node.finishLiteral(scanRegExp());
            }
            peek();
        } else {
            throwUnexpectedToken(lex());
        }

        return expr;
    }

    // 11.2 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [];

        expect('(');

        if (!match(')')) {
            while (index < length) {
                args.push(parseAssignmentExpression());
                if (match(')')) {
                    break;
                }
                expectCommaSeparator();
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token, node = new Node();

        token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpectedToken(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = parseExpression();

        expect(']');

        return expr;
    }

    function parseNewExpression() {
        var callee, args, node = new Node();

        expectKeyword('new');
        callee = parseLeftHandSideExpression();
        args = match('(') ? parseArguments() : [];

        return node.finishNewExpression(callee, args);
    }

    function parseLeftHandSideExpressionAllowCall() {
        var expr, args, property, startToken, previousAllowIn = state.allowIn;

        startToken = lookahead;
        state.allowIn = true;
        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        for (;;) {
            if (match('.')) {
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else if (match('(')) {
                args = parseArguments();
                expr = new WrappingNode(startToken).finishCallExpression(expr, args);
            } else if (match('[')) {
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else {
                break;
            }
        }
        state.allowIn = previousAllowIn;

        return expr;
    }

    function parseLeftHandSideExpression() {
        var expr, property, startToken;
        assert(state.allowIn, 'callee of new expression always allow in keyword.');

        startToken = lookahead;

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        for (;;) {
            if (match('[')) {
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else if (match('.')) {
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else {
                break;
            }
        }
        return expr;
    }

    // 11.3 Postfix Expressions

    function parsePostfixExpression() {
        var expr, token, startToken = lookahead;

        expr = parseLeftHandSideExpressionAllowCall();

        if (lookahead.type === Token.Punctuator) {
            if ((match('++') || match('--')) && !peekLineTerminator()) {
                // 11.3.1, 11.3.2
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    tolerateError(Messages.StrictLHSPostfix);
                }

                if (!isLeftHandSide(expr)) {
                    tolerateError(Messages.InvalidLHSInAssignment);
                }

                token = lex();
                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);
            }
        }

        return expr;
    }

    // 11.4 Unary Operators

    function parseUnaryExpression() {
        var token, expr, startToken;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        } else if (match('++') || match('--')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            // 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                tolerateError(Messages.StrictLHSPrefix);
            }

            if (!isLeftHandSide(expr)) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }

            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
        } else if (match('+') || match('-') || match('~') || match('!')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                tolerateError(Messages.StrictDelete);
            }
        } else {
            expr = parsePostfixExpression();
        }

        return expr;
    }

    function binaryPrecedence(token, allowIn) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
        case '||':
            prec = 1;
            break;

        case '&&':
            prec = 2;
            break;

        case '|':
            prec = 3;
            break;

        case '^':
            prec = 4;
            break;

        case '&':
            prec = 5;
            break;

        case '==':
        case '!=':
        case '===':
        case '!==':
            prec = 6;
            break;

        case '<':
        case '>':
        case '<=':
        case '>=':
        case 'instanceof':
            prec = 7;
            break;

        case 'in':
            prec = allowIn ? 7 : 0;
            break;

        case '<<':
        case '>>':
        case '>>>':
            prec = 8;
            break;

        case '+':
        case '-':
            prec = 9;
            break;

        case '*':
        case '/':
        case '%':
            prec = 11;
            break;

        default:
            break;
        }

        return prec;
    }

    // 11.5 Multiplicative Operators
    // 11.6 Additive Operators
    // 11.7 Bitwise Shift Operators
    // 11.8 Relational Operators
    // 11.9 Equality Operators
    // 11.10 Binary Bitwise Operators
    // 11.11 Binary Logical Operators

    function parseBinaryExpression() {
        var marker, markers, expr, token, prec, stack, right, operator, left, i;

        marker = lookahead;
        left = parseUnaryExpression();
        if (left === PlaceHolders.ArrowParameterPlaceHolder) {
            return left;
        }

        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        if (prec === 0) {
            return left;
        }
        token.prec = prec;
        lex();

        markers = [marker, lookahead];
        right = parseUnaryExpression();

        stack = [left, token, right];

        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                markers.pop();
                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
                stack.push(expr);
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            markers.push(lookahead);
            expr = parseUnaryExpression();
            stack.push(expr);
        }

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while (i > 1) {
            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
        }

        return expr;
    }


    // 11.12 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate, startToken;

        startToken = lookahead;

        expr = parseBinaryExpression();
        if (expr === PlaceHolders.ArrowParameterPlaceHolder) {
            return expr;
        }
        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = parseAssignmentExpression();
            state.allowIn = previousAllowIn;
            expect(':');
            alternate = parseAssignmentExpression();

            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
        }

        return expr;
    }

    // [ES6] 14.2 Arrow Function

    function parseConciseBody() {
        if (match('{')) {
            return parseFunctionSourceElements();
        }
        return parseAssignmentExpression();
    }

    function reinterpretAsCoverFormalsList(expressions) {
        var i, len, param, params, defaults, defaultCount, options, rest, token;

        params = [];
        defaults = [];
        defaultCount = 0;
        rest = null;
        options = {
            paramSet: {}
        };

        for (i = 0, len = expressions.length; i < len; i += 1) {
            param = expressions[i];
            if (param.type === Syntax.Identifier) {
                params.push(param);
                defaults.push(null);
                validateParam(options, param, param.name);
            } else if (param.type === Syntax.AssignmentExpression) {
                params.push(param.left);
                defaults.push(param.right);
                ++defaultCount;
                validateParam(options, param.left, param.left.name);
            } else {
                return null;
            }
        }

        if (options.message === Messages.StrictParamDupe) {
            token = strict ? options.stricted : options.firstRestricted;
            throwUnexpectedToken(token, options.message);
        }

        if (defaultCount === 0) {
            defaults = [];
        }

        return {
            params: params,
            defaults: defaults,
            rest: rest,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseArrowFunctionExpression(options, node) {
        var previousStrict, body;

        expect('=>');
        previousStrict = strict;

        body = parseConciseBody();

        if (strict && options.firstRestricted) {
            throwUnexpectedToken(options.firstRestricted, options.message);
        }
        if (strict && options.stricted) {
            tolerateUnexpectedToken(options.stricted, options.message);
        }

        strict = previousStrict;

        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
    }

    // 11.13 Assignment Operators

    function parseAssignmentExpression() {
        var oldParenthesisCount, token, expr, right, list, startToken;

        oldParenthesisCount = state.parenthesisCount;

        startToken = lookahead;
        token = lookahead;

        expr = parseConditionalExpression();

        if (expr === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {
            if (state.parenthesisCount === oldParenthesisCount ||
                    state.parenthesisCount === (oldParenthesisCount + 1)) {
                if (expr.type === Syntax.Identifier) {
                    list = reinterpretAsCoverFormalsList([ expr ]);
                } else if (expr.type === Syntax.AssignmentExpression) {
                    list = reinterpretAsCoverFormalsList([ expr ]);
                } else if (expr.type === Syntax.SequenceExpression) {
                    list = reinterpretAsCoverFormalsList(expr.expressions);
                } else if (expr === PlaceHolders.ArrowParameterPlaceHolder) {
                    list = reinterpretAsCoverFormalsList([]);
                }
                if (list) {
                    return parseArrowFunctionExpression(list, new WrappingNode(startToken));
                }
            }
        }

        if (matchAssign()) {
            // LeftHandSideExpression
            if (!isLeftHandSide(expr)) {
                tolerateError(Messages.InvalidLHSInAssignment);
            }

            // 11.13.1
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
            }

            token = lex();
            right = parseAssignmentExpression();
            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
        }

        return expr;
    }

    // 11.14 Comma Operator

    function parseExpression() {
        var expr, startToken = lookahead, expressions;

        expr = parseAssignmentExpression();

        if (match(',')) {
            expressions = [expr];

            while (index < length) {
                if (!match(',')) {
                    break;
                }
                lex();
                expressions.push(parseAssignmentExpression());
            }

            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
        }

        return expr;
    }

    // 12.1 Block

    function parseStatementList() {
        var list = [],
            statement;

        while (index < length) {
            if (match('}')) {
                break;
            }
            statement = parseSourceElement();
            if (typeof statement === 'undefined') {
                break;
            }
            list.push(statement);
        }

        return list;
    }

    function parseBlock() {
        var block, node = new Node();

        expect('{');

        block = parseStatementList();

        expect('}');

        return node.finishBlockStatement(block);
    }

    // 12.2 Variable Statement

    function parseVariableIdentifier() {
        var token, node = new Node();

        token = lex();

        if (token.type !== Token.Identifier) {
            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {
                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
            } else {
                throwUnexpectedToken(token);
            }
        }

        return node.finishIdentifier(token.value);
    }

    function parseVariableDeclaration(kind) {
        var init = null, id, node = new Node();

        id = parseVariableIdentifier();

        // 12.2.1
        if (strict && isRestrictedWord(id.name)) {
            tolerateError(Messages.StrictVarName);
        }

        if (kind === 'const') {
            expect('=');
            init = parseAssignmentExpression();
        } else if (match('=')) {
            lex();
            init = parseAssignmentExpression();
        }

        return node.finishVariableDeclarator(id, init);
    }

    function parseVariableDeclarationList(kind) {
        var list = [];

        do {
            list.push(parseVariableDeclaration(kind));
            if (!match(',')) {
                break;
            }
            lex();
        } while (index < length);

        return list;
    }

    function parseVariableStatement(node) {
        var declarations;

        expectKeyword('var');

        declarations = parseVariableDeclarationList();

        consumeSemicolon();

        return node.finishVariableDeclaration(declarations, 'var');
    }

    // kind may be `const` or `let`
    // Both are experimental and not in the specification yet.
    // see http://wiki.ecmascript.org/doku.php?id=harmony:const
    // and http://wiki.ecmascript.org/doku.php?id=harmony:let
    function parseConstLetDeclaration(kind) {
        var declarations, node = new Node();

        expectKeyword(kind);

        declarations = parseVariableDeclarationList(kind);

        consumeSemicolon();

        return node.finishVariableDeclaration(declarations, kind);
    }

    // 12.3 Empty Statement

    function parseEmptyStatement() {
        var node = new Node();
        expect(';');
        return node.finishEmptyStatement();
    }

    // 12.4 Expression Statement

    function parseExpressionStatement(node) {
        var expr = parseExpression();
        consumeSemicolon();
        return node.finishExpressionStatement(expr);
    }

    // 12.5 If statement

    function parseIfStatement(node) {
        var test, consequent, alternate;

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return node.finishIfStatement(test, consequent, alternate);
    }

    // 12.6 Iteration Statements

    function parseDoWhileStatement(node) {
        var body, test, oldInIteration;

        expectKeyword('do');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        if (match(';')) {
            lex();
        }

        return node.finishDoWhileStatement(body, test);
    }

    function parseWhileStatement(node) {
        var test, body, oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return node.finishWhileStatement(test, body);
    }

    function parseForVariableDeclaration() {
        var token, declarations, node = new Node();

        token = lex();
        declarations = parseVariableDeclarationList();

        return node.finishVariableDeclaration(declarations, token.value);
    }

    function parseForStatement(node) {
        var init, test, update, left, right, body, oldInIteration, previousAllowIn = state.allowIn;

        init = test = update = null;

        expectKeyword('for');

        expect('(');

        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var') || matchKeyword('let')) {
                state.allowIn = false;
                init = parseForVariableDeclaration();
                state.allowIn = previousAllowIn;

                if (init.declarations.length === 1 && matchKeyword('in')) {
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            } else {
                state.allowIn = false;
                init = parseExpression();
                state.allowIn = previousAllowIn;

                if (matchKeyword('in')) {
                    // LeftHandSideExpression
                    if (!isLeftHandSide(init)) {
                        tolerateError(Messages.InvalidLHSInForIn);
                    }

                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            }

            if (typeof left === 'undefined') {
                expect(';');
            }
        }

        if (typeof left === 'undefined') {

            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');

            if (!match(')')) {
                update = parseExpression();
            }
        }

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return (typeof left === 'undefined') ?
                node.finishForStatement(init, test, update, body) :
                node.finishForInStatement(left, right, body);
    }

    // 12.7 The continue statement

    function parseContinueStatement(node) {
        var label = null, key;

        expectKeyword('continue');

        // Optimize the most common form: 'continue;'.
        if (source.charCodeAt(index) === 0x3B) {
            lex();

            if (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (peekLineTerminator()) {
            if (!state.inIteration) {
                throwError(Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !state.inIteration) {
            throwError(Messages.IllegalContinue);
        }

        return node.finishContinueStatement(label);
    }

    // 12.8 The break statement

    function parseBreakStatement(node) {
        var label = null, key;

        expectKeyword('break');

        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(index) === 0x3B) {
            lex();

            if (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }

            return node.finishBreakStatement(null);
        }

        if (peekLineTerminator()) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError(Messages.IllegalBreak);
            }

            return node.finishBreakStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError(Messages.IllegalBreak);
        }

        return node.finishBreakStatement(label);
    }

    // 12.9 The return statement

    function parseReturnStatement(node) {
        var argument = null;

        expectKeyword('return');

        if (!state.inFunctionBody) {
            tolerateError(Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source.charCodeAt(index) === 0x20) {
            if (isIdentifierStart(source.charCodeAt(index + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return node.finishReturnStatement(argument);
            }
        }

        if (peekLineTerminator()) {
            return node.finishReturnStatement(null);
        }

        if (!match(';')) {
            if (!match('}') && lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return node.finishReturnStatement(argument);
    }

    // 12.10 The with statement

    function parseWithStatement(node) {
        var object, body;

        if (strict) {
            // TODO(ikarienator): Should we update the test cases instead?
            skipComment();
            tolerateError(Messages.StrictModeWith);
        }

        expectKeyword('with');

        expect('(');

        object = parseExpression();

        expect(')');

        body = parseStatement();

        return node.finishWithStatement(object, body);
    }

    // 12.10 The swith statement

    function parseSwitchCase() {
        var test, consequent = [], statement, node = new Node();

        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');

        while (index < length) {
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            statement = parseStatement();
            consequent.push(statement);
        }

        return node.finishSwitchCase(test, consequent);
    }

    function parseSwitchStatement(node) {
        var discriminant, cases, clause, oldInSwitch, defaultFound;

        expectKeyword('switch');

        expect('(');

        discriminant = parseExpression();

        expect(')');

        expect('{');

        cases = [];

        if (match('}')) {
            lex();
            return node.finishSwitchStatement(discriminant, cases);
        }

        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;

        while (index < length) {
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError(Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect('}');

        return node.finishSwitchStatement(discriminant, cases);
    }

    // 12.13 The throw statement

    function parseThrowStatement(node) {
        var argument;

        expectKeyword('throw');

        if (peekLineTerminator()) {
            throwError(Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        return node.finishThrowStatement(argument);
    }

    // 12.14 The try statement

    function parseCatchClause() {
        var param, body, node = new Node();

        expectKeyword('catch');

        expect('(');
        if (match(')')) {
            throwUnexpectedToken(lookahead);
        }

        param = parseVariableIdentifier();
        // 12.14.1
        if (strict && isRestrictedWord(param.name)) {
            tolerateError(Messages.StrictCatchVariable);
        }

        expect(')');
        body = parseBlock();
        return node.finishCatchClause(param, body);
    }

    function parseTryStatement(node) {
        var block, handlers = [], finalizer = null;

        expectKeyword('try');

        block = parseBlock();

        if (matchKeyword('catch')) {
            handlers.push(parseCatchClause());
        }

        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }

        if (handlers.length === 0 && !finalizer) {
            throwError(Messages.NoCatchOrFinally);
        }

        return node.finishTryStatement(block, [], handlers, finalizer);
    }

    // 12.15 The debugger statement

    function parseDebuggerStatement(node) {
        expectKeyword('debugger');

        consumeSemicolon();

        return node.finishDebuggerStatement();
    }

    // 12 Statements

    function parseStatement() {
        var type = lookahead.type,
            expr,
            labeledBody,
            key,
            node;

        if (type === Token.EOF) {
            throwUnexpectedToken(lookahead);
        }

        if (type === Token.Punctuator && lookahead.value === '{') {
            return parseBlock();
        }

        node = new Node();

        if (type === Token.Punctuator) {
            switch (lookahead.value) {
            case ';':
                return parseEmptyStatement(node);
            case '(':
                return parseExpressionStatement(node);
            default:
                break;
            }
        } else if (type === Token.Keyword) {
            switch (lookahead.value) {
            case 'break':
                return parseBreakStatement(node);
            case 'continue':
                return parseContinueStatement(node);
            case 'debugger':
                return parseDebuggerStatement(node);
            case 'do':
                return parseDoWhileStatement(node);
            case 'for':
                return parseForStatement(node);
            case 'function':
                return parseFunctionDeclaration(node);
            case 'if':
                return parseIfStatement(node);
            case 'return':
                return parseReturnStatement(node);
            case 'switch':
                return parseSwitchStatement(node);
            case 'throw':
                return parseThrowStatement(node);
            case 'try':
                return parseTryStatement(node);
            case 'var':
                return parseVariableStatement(node);
            case 'while':
                return parseWhileStatement(node);
            case 'with':
                return parseWithStatement(node);
            default:
                break;
            }
        }

        expr = parseExpression();

        // 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            key = '$' + expr.name;
            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError(Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet[key] = true;
            labeledBody = parseStatement();
            delete state.labelSet[key];
            return node.finishLabeledStatement(expr, labeledBody);
        }

        consumeSemicolon();

        return node.finishExpressionStatement(expr);
    }

    // 13 Function Definition

    function parseFunctionSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesisCount,
            node = new Node();

        expect('{');

        while (index < length) {
            if (lookahead.type !== Token.StringLiteral) {
                break;
            }
            token = lookahead;

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;
        oldParenthesisCount = state.parenthesizedCount;

        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;
        state.parenthesizedCount = 0;

        while (index < length) {
            if (match('}')) {
                break;
            }
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;
        state.parenthesizedCount = oldParenthesisCount;

        return node.finishBlockStatement(sourceElements);
    }

    function validateParam(options, param, name) {
        var key = '$' + name;
        if (strict) {
            if (isRestrictedWord(name)) {
                options.stricted = param;
                options.message = Messages.StrictParamName;
            }
            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        } else if (!options.firstRestricted) {
            if (isRestrictedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamName;
            } else if (isStrictModeReservedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictReservedWord;
            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamDupe;
            }
        }
        options.paramSet[key] = true;
    }

    function parseParam(options) {
        var token, param, def;

        token = lookahead;
        param = parseVariableIdentifier();
        validateParam(options, token, token.value);
        if (match('=')) {
            lex();
            def = parseAssignmentExpression();
            ++options.defaultCount;
        }

        options.params.push(param);
        options.defaults.push(def);

        return !match(')');
    }

    function parseParams(firstRestricted) {
        var options;

        options = {
            params: [],
            defaultCount: 0,
            defaults: [],
            firstRestricted: firstRestricted
        };

        expect('(');

        if (!match(')')) {
            options.paramSet = {};
            while (index < length) {
                if (!parseParam(options)) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        if (options.defaultCount === 0) {
            options.defaults = [];
        }

        return {
            params: options.params,
            defaults: options.defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseFunctionDeclaration() {
        var id, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict, node = new Node();

        expectKeyword('function');
        token = lookahead;
        id = parseVariableIdentifier();
        if (strict) {
            if (isRestrictedWord(token.value)) {
                tolerateUnexpectedToken(token, Messages.StrictFunctionName);
            }
        } else {
            if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictFunctionName;
            } else if (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord;
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        if (strict && stricted) {
            tolerateUnexpectedToken(stricted, message);
        }
        strict = previousStrict;

        return node.finishFunctionDeclaration(id, params, defaults, body);
    }

    function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, tmp,
            params = [], defaults = [], body, previousStrict, node = new Node();

        expectKeyword('function');

        if (!match('(')) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwUnexpectedToken(firstRestricted, message);
        }
        if (strict && stricted) {
            tolerateUnexpectedToken(stricted, message);
        }
        strict = previousStrict;

        return node.finishFunctionExpression(id, params, defaults, body);
    }

    // 14 Program

    function parseSourceElement() {
        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'const':
            case 'let':
                return parseConstLetDeclaration(lookahead.value);
            case 'function':
                return parseFunctionDeclaration();
            default:
                return parseStatement();
            }
        }

        if (lookahead.type !== Token.EOF) {
            return parseStatement();
        }
    }

    function parseSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted;

        while (index < length) {
            token = lookahead;
            if (token.type !== Token.StringLiteral) {
                break;
            }

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (index < length) {
            sourceElement = parseSourceElement();
            /* istanbul ignore if */
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }
        return sourceElements;
    }

    function parseProgram() {
        var body, node;

        skipComment();
        peek();
        node = new Node();
        strict = false;

        body = parseSourceElements();
        return node.finishProgram(body);
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];

        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (entry.regex) {
                token.regex = {
                    pattern: entry.regex.pattern,
                    flags: entry.regex.flags
                };
            }
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    function tokenize(code, options) {
        var toString,
            tokens;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1
        };

        extra = {};

        // Options matching.
        options = options || {};

        // Of course we collect tokens here.
        options.tokens = true;
        extra.tokens = [];
        extra.tokenize = true;
        // The following two fields are necessary to compute the Regex tokens.
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;

        extra.range = (typeof options.range === 'boolean') && options.range;
        extra.loc = (typeof options.loc === 'boolean') && options.loc;

        if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
        }
        if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
        }

        try {
            peek();
            if (lookahead.type === Token.EOF) {
                return extra.tokens;
            }

            lex();
            while (lookahead.type !== Token.EOF) {
                try {
                    lex();
                } catch (lexError) {
                    if (extra.errors) {
                        extra.errors.push(lexError);
                        // We have to break on the first error
                        // to avoid infinite loops.
                        break;
                    } else {
                        throw lexError;
                    }
                }
            }

            filterTokenLocation();
            tokens = extra.tokens;
            if (typeof extra.comments !== 'undefined') {
                tokens.comments = extra.comments;
            }
            if (typeof extra.errors !== 'undefined') {
                tokens.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }
        return tokens;
    }

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            parenthesisCount: 0,
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1
        };

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

            if (extra.loc && options.source !== null && options.source !== undefined) {
                extra.source = toString(options.source);
            }

            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
            if (extra.attachComment) {
                extra.range = true;
                extra.comments = [];
                extra.bottomRightStack = [];
                extra.trailingComments = [];
                extra.leadingComments = [];
            }
        }

        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }

        return program;
    }

    // Sync with *.json manifests.
    exports.version = '2.0.0';

    exports.tokenize = tokenize;

    exports.parse = parse;

    // Deep copy.
   /* istanbul ignore next */
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],53:[function(require,module,exports){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    if (typeof module === 'object' && module.exports && typeof require === 'function') {
        module.exports = definition();
    } else if (typeof define === 'function' && typeof define.amd === 'object') {
        define(definition);
    } else {
        root.log = definition();
    }
}(this, function () {
    var self = {};
    var noop = function() {};
    var undefinedType = "undefined";

    function realMethod(methodName) {
        if (typeof console === undefinedType) {
            return false; // We can't build a real method without a console to log to
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    function enableLoggingWhenConsoleArrives(methodName, level) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods(level);
                self[methodName].apply(self, arguments);
            }
        };
    }

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    function replaceLoggingMethods(level) {
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            self[methodName] = (i < level) ? noop : self.methodFactory(methodName, level);
        }
    }

    function persistLevelIfPossible(levelNum) {
        var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

        // Use localStorage if available
        try {
            window.localStorage['loglevel'] = levelName;
            return;
        } catch (ignore) {}

        // Use session cookie as fallback
        try {
            window.document.cookie = "loglevel=" + levelName + ";";
        } catch (ignore) {}
    }

    function loadPersistedLevel() {
        var storedLevel;

        try {
            storedLevel = window.localStorage['loglevel'];
        } catch (ignore) {}

        if (typeof storedLevel === undefinedType) {
            try {
                storedLevel = /loglevel=([^;]+)/.exec(window.document.cookie)[1];
            } catch (ignore) {}
        }
        
        if (self.levels[storedLevel] === undefined) {
            storedLevel = "WARN";
        }

        self.setLevel(self.levels[storedLevel]);
    }

    /*
     *
     * Public API
     *
     */

    self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
        "ERROR": 4, "SILENT": 5};

    self.methodFactory = function (methodName, level) {
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives(methodName, level);
    };

    self.setLevel = function (level) {
        if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
            level = self.levels[level.toUpperCase()];
        }
        if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
            persistLevelIfPossible(level);
            replaceLoggingMethods(level);
            if (typeof console === undefinedType && level < self.levels.SILENT) {
                return "No console available for logging";
            }
        } else {
            throw "log.setLevel() called with invalid level: " + level;
        }
    };

    self.enableAll = function() {
        self.setLevel(self.levels.TRACE);
    };

    self.disableAll = function() {
        self.setLevel(self.levels.SILENT);
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    self.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === self) {
            window.log = _log;
        }

        return self;
    };

    loadPersistedLevel();
    return self;
}));

},{}],54:[function(require,module,exports){
'use strict';

var whiteList = ['not', 'any', 'all', 'none'];


function notNull(x)  { return x != null; }
function toString(x) { return x.toString(); }
function wrap(x)     { return '(' + x + ')';}

function maybeQuote(value) {
    if (typeof value === 'string') {
        return '"' + value + '"';
    }
    return value;
}

function lookUp(key) {
    if (key.lastIndexOf('$') === 0) {
        return 'context.' + key.substring(1);
    }
    return 'context.feature.properties.' + key;
}

function nullValue(key, value) {
    return {
        type: 'nullValue',
        key: key,
        toString: function () {
            return ' true ';
        }
    };
}

function propertyEqual(key, value) {
    return {
        type: 'propertyEqual',
        opt: '===' ,
        key: key,
        value: value,
        toString: function () {
            return wrap(maybeQuote(this.value) + ' ' + this.opt + ' ' + lookUp(key));
        }
    };
}

function propertyOr(key, values) {
    return {
        type: 'propertyOr',
        key: key,
        values: values.map(function (x) { return propertyEqual(key, x); }),
        toString: function () {
            return wrap(this.values.map(toString).join(' || '));
        }
    };
}

function not(key, value) {
    return {
        type: 'notProperty',
        key: key,
        value: parseFilter(value),
        toString: function () {
            return '!' + wrap(this.value.toString());
        }
    };
}

function none(key, values) {
    return {
        type: 'none',
        values: any(null, values),
        toString: function () {
            return '!' + wrap(this.values.toString());
        }
    };
}

function printNested(values, joiner) {
    return wrap(values.filter(notNull).map(function (x) {
        return wrap(x.join(' && '));
    }).join(' ' + joiner + ' '));
}

function any(_, values) {
    return {
        type: 'any',
        values: values.map(parseFilter),
        toString: function () {
            return printNested(this.values, '||');
        }
    };
}

function all(_, values) {
    return {
        type: 'all',
        values: values.filter(notNull).map(parseFilter),
        toString: function () {
            return printNested(this.values, '&&');
        }
    };
}

function propertyMatchesBoolean(key, value) {
    return {
        type: 'propertyMatchesBoolean',
        key: key,
        value: value,
        toString: function () {
            return wrap(lookUp(this.key) + (this.value ? ' != ' : ' == ')  + 'null');
        }
    };
}

function rangeMatch(key, values) {
    return {
        type: 'rangeMatch',
        key: key,
        values: values,
        toString: function () {
            var expressions = [];

            if (this.values.max) {
                expressions.push('' + lookUp(key) + ' < ' + this.values.max);
            }

            if (this.values.min) {
                expressions.push('' + lookUp(key) + ' >= ' + this.values.min);
            }

            return wrap(expressions.join(' && '));
        }
    };
}

function parseFilter(filter) {
    var filterAST = [],
        keys      = Object.keys(filter);

    keys.forEach(function (key, idx) {

        var value = filter[key],
            type  = typeof value;
        if (type === 'string' || type === 'number') {
            filterAST.push(propertyEqual(key, value));
        } else if (type === 'boolean') {
            filterAST.push(propertyMatchesBoolean(key, value));
        } else if (value == null) {
            filterAST.push(nullValue(key, value));
        } else if (whiteList.indexOf(key) >= 0) {
            switch (key) {
            case 'not':
                filterAST.push(not(key, value));
                break;
            case 'any':
                filterAST.push(any(key, value));
                break;
            case 'all':
                filterAST.push(all(key, value));
                break;
            case 'none':
                filterAST.push(none(key, value));
                break;
            default:
                throw new Error('Unhandled WhiteListed property: ' + key);
            }
        } else if (Array.isArray(value)) {
            filterAST.push(propertyOr(key, value));
        } else if (type === 'object' && value != null) {
            if (value.max || value.min) {
                filterAST.push(rangeMatch(key, value));
            }
        } else {
            throw new Error('Unknown Query sytnax: ' + value);
        }
    });

    return keys.length === 0 ? ['true'] : filterAST;
}

function filterToString(filterAST) {
    return wrap(filterAST.join(' && '));
}

function match(filter) {
    if (filter == null) { return function () { return true; }; }
    // jshint evil: true
    return new Function('context', 'return ' + filterToString(parseFilter(filter)) + ';');
}

module.exports = {
    match: match,
    filterToString: filterToString,
    parseFilter: parseFilter
};

},{}],55:[function(require,module,exports){
'use strict';

// lightweight Buffer shim for pbf browser build
// based on code from github.com/feross/buffer (MIT-licensed)

module.exports = Buffer;

var ieee754 = require('ieee754');

function Buffer(length) {
    var arr;
    if (length && length.length) {
        arr = length;
        length = arr.length;
    }
    var buf = new Uint8Array(length || 0);
    if (arr) buf.set(arr);

    buf.readUInt32LE = BufferMethods.readUInt32LE;
    buf.writeUInt32LE = BufferMethods.writeUInt32LE;
    buf.readInt32LE = BufferMethods.readInt32LE;
    buf.writeInt32LE = BufferMethods.writeInt32LE;
    buf.readFloatLE = BufferMethods.readFloatLE;
    buf.writeFloatLE = BufferMethods.writeFloatLE;
    buf.readDoubleLE = BufferMethods.readDoubleLE;
    buf.writeDoubleLE = BufferMethods.writeDoubleLE;
    buf.toString = BufferMethods.toString;
    buf.write = BufferMethods.write;
    buf.slice = BufferMethods.slice;
    buf.copy = BufferMethods.copy;

    buf._isBuffer = true;
    return buf;
}

var lastStr, lastStrEncoded;

var BufferMethods = {
    readUInt32LE: function(pos) {
        return ((this[pos]) |
            (this[pos + 1] << 8) |
            (this[pos + 2] << 16)) +
            (this[pos + 3] * 0x1000000);
    },

    writeUInt32LE: function(val, pos) {
        this[pos] = val;
        this[pos + 1] = (val >>> 8);
        this[pos + 2] = (val >>> 16);
        this[pos + 3] = (val >>> 24);
    },

    readInt32LE: function(pos) {
        return ((this[pos]) |
            (this[pos + 1] << 8) |
            (this[pos + 2] << 16)) +
            (this[pos + 3] << 24);
    },

    readFloatLE:  function(pos) { return ieee754.read(this, pos, true, 23, 4); },
    readDoubleLE: function(pos) { return ieee754.read(this, pos, true, 52, 8); },

    writeFloatLE:  function(val, pos) { return ieee754.write(this, val, pos, true, 23, 4); },
    writeDoubleLE: function(val, pos) { return ieee754.write(this, val, pos, true, 52, 8); },

    toString: function(encoding, start, end) {
        var str = '',
            tmp = '';

        start = start || 0;
        end = Math.min(this.length, end || this.length);

        for (var i = start; i < end; i++) {
            var ch = this[i];
            if (ch <= 0x7F) {
                str += decodeURIComponent(tmp) + String.fromCharCode(ch);
                tmp = '';
            } else {
                tmp += '%' + ch.toString(16);
            }
        }

        str += decodeURIComponent(tmp);

        return str;
    },

    write: function(str, pos) {
        var bytes = str === lastStr ? lastStrEncoded : encodeString(str);
        for (var i = 0; i < bytes.length; i++) {
            this[pos + i] = bytes[i];
        }
    },

    slice: function(start, end) {
        return this.subarray(start, end);
    },

    copy: function(buf, pos) {
        pos = pos || 0;
        for (var i = 0; i < this.length; i++) {
            buf[pos + i] = this[i];
        }
    }
};

BufferMethods.writeInt32LE = BufferMethods.writeUInt32LE;

Buffer.byteLength = function(str) {
    lastStr = str;
    lastStrEncoded = encodeString(str);
    return lastStrEncoded.length;
};

Buffer.isBuffer = function(buf) {
    return !!(buf && buf._isBuffer);
};

function encodeString(str) {
    var length = str.length,
        bytes = [];

    for (var i = 0, c, lead; i < length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {

            if (lead) {
                if (c < 0xDC00) {
                    bytes.push(0xEF, 0xBF, 0xBD);
                    lead = c;
                    continue;

                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }

            } else {
                if (c > 0xDBFF || (i + 1 === length)) bytes.push(0xEF, 0xBF, 0xBD);
                else lead = c;

                continue;
            }

        } else if (lead) {
            bytes.push(0xEF, 0xBF, 0xBD);
            lead = null;
        }

        if (c < 0x80) bytes.push(c);
        else {
            if (c < 0x800) bytes.push(c >> 0x6 | 0xC0, c & 0x3F | 0x80);
            else if (c < 0x10000) bytes.push(c >> 0xC | 0xE0, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
            else bytes.push(c >> 0x12 | 0xF0, c >> 0xC & 0x3F | 0x80, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
        }
    }
    return bytes;
}

},{"ieee754":57}],56:[function(require,module,exports){
(function (global){
'use strict';

module.exports = Pbf;

var Buffer = global.Buffer || require('./buffer');

function Pbf(buf) {
    this.buf = !Buffer.isBuffer(buf) ? new Buffer(buf || 0) : buf;
    this.pos = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            var val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            readField(tag, result, this);

            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = this.buf.readUInt32LE(this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = this.buf.readInt32LE(this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = this.buf.readUInt32LE(this.pos) + this.buf.readUInt32LE(this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = this.buf.readUInt32LE(this.pos) + this.buf.readInt32LE(this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = this.buf.readFloatLE(this.pos);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = this.buf.readDoubleLE(this.pos);
        this.pos += 8;
        return val;
    },

    readVarint: function() {
        var buf = this.buf,
            val, b, b0, b1, b2, b3;

        b0 = buf[this.pos++]; if (b0 < 0x80) return b0;                 b0 = b0 & 0x7f;
        b1 = buf[this.pos++]; if (b1 < 0x80) return b0 | b1 << 7;       b1 = (b1 & 0x7f) << 7;
        b2 = buf[this.pos++]; if (b2 < 0x80) return b0 | b1 | b2 << 14; b2 = (b2 & 0x7f) << 14;
        b3 = buf[this.pos++]; if (b3 < 0x80) return b0 | b1 | b2 | b3 << 21;

        val = b0 | b1 | b2 | (b3 & 0x7f) << 21;

        b = buf[this.pos++]; val += (b & 0x7f) * 0x10000000;         if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x800000000;        if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x40000000000;      if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x2000000000000;    if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x100000000000000;  if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x8000000000000000; if (b < 0x80) return val;

        throw new Error('Expected varint not more than 10 bytes');
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos,
            str = this.buf.toString('utf8', this.pos, end);
        this.pos = end;
        return str;
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.slice(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readVarint());
        return arr;
    },
    readPackedSVarint: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f);
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error('Unimplemented type: ' + type);
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) length *= 2;

        if (length != this.length) {
            var buf = new Buffer(length);
            this.buf.copy(buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.slice(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        this.buf.writeUInt32LE(val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        this.buf.writeInt32LE(val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        this.buf.writeInt32LE(val & -1, this.pos);
        this.buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        this.buf.writeInt32LE(val & -1, this.pos);
        this.buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val;

        if (val <= 0x7f) {
            this.realloc(1);
            this.buf[this.pos++] = val;

        } else if (val <= 0x3fff) {
            this.realloc(2);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] =  (val >>> 7) & 0x7f;

        } else if (val <= 0x1fffff) {
            this.realloc(3);
            this.buf[this.pos++] = ((val >>>  0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>>  7) & 0x7f) | 0x80;
            this.buf[this.pos++] =  (val >>> 14) & 0x7f;

        } else if (val <= 0xfffffff) {
            this.realloc(4);
            this.buf[this.pos++] = ((val >>>  0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>>  7) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 14) & 0x7f) | 0x80;
            this.buf[this.pos++] =  (val >>> 21) & 0x7f;

        } else {
            var pos = this.pos;
            while (val >= 0x80) {
                this.realloc(1);
                this.buf[this.pos++] = (val & 0xff) | 0x80;
                val /= 0x80;
            }
            this.realloc(1);
            this.buf[this.pos++] = val | 0;
            if (this.pos - pos > 10) throw new Error("Given varint doesn't fit into 10 bytes");
        }
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        var bytes = Buffer.byteLength(str);
        this.writeVarint(bytes);
        this.realloc(bytes);
        this.buf.write(str, this.pos);
        this.pos += bytes;
    },

    writeFloat: function(val) {
        this.realloc(4);
        this.buf.writeFloatLE(val, this.pos);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        this.buf.writeDoubleLE(val, this.pos);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);

        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        var varintLen =
            len <= 0x7f ? 1 :
            len <= 0x3fff ? 2 :
            len <= 0x1fffff ? 3 :
            len <= 0xfffffff ? 4 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

        // if 1 byte isn't enough for encoding message length, shift the data to the right
        if (varintLen > 1) {
            this.realloc(varintLen - 1);
            for (var i = this.pos - 1; i >= startPos; i--) this.buf[i + varintLen - 1] = this.buf[i];
        }

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },
    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },
    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },
    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },
    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },
    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },
    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },
    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },
    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./buffer":55}],57:[function(require,module,exports){
module.exports=require(14)
},{"/home/ivan/dev/mapzen/tangram/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js":14}],58:[function(require,module,exports){
/*!
 * strip-comments <https://github.com/jonschlinkert/strip-comments>
 *
 * Copyright (c) 2014 Jon Schlinkert, contributors.
 * Licensed under the MIT license.
 */

'use stric';

var reBlock = '\\/\\*';
var reBlockIgnore = '\\/\\*(?!\\*?\\!)';
var reBlockEnd = '(.|[\\r\\n]|\\n)*?\\*\\/\\n?\\n?';
var reLine = /(^|[^\S\n])(?:\/\/)([\s\S]+?)$/gm;
var reLineIgnore = /(^|[^\S\n])(?:\/\/[^!])([\s\S]+?)$/gm;


/**
 * Strip all comments
 *
 * {%= docs("strip") %}
 *
 * @param   {String} `str`  file contents or string to strip.
 * @param   {Object} `opts`  options are passed to `.block`, and `.line`
 * @return  {String} String without comments.
 * @api public
 */

var strip = module.exports = function(str, opts) {
  return str ? strip.block(strip.line(str, opts), opts) : '';
};


/**
 * Strip only block comments, optionally leaving protected comments
 * (e.g. `/*!`) intact.
 *
 * {%= docs("block") %}
 *
 * @param   {String} `str`  file content or string to strip to
 * @param   {Object} `opts`  if `safe:true`, strip only comments that do not start with `/*!` or `/**!`
 * @return  {String} String without block comments.
 * @api public
 */

strip.block = function(str, opts) {
  opts = opts || {};
  var re = new RegExp(reBlock + reBlockEnd, 'gm');
  if(opts.safe) {
    re = new RegExp(reBlockIgnore + reBlockEnd, 'gm');
  }
  return str ? str.replace(re, '') : '';
};


/**
 * Strip only line comments
 *
 * {%= docs("line") %}
 *
 * @param   {String} `str`  file content or string to strip to
 * @param   {Object} `opts`  if `safe:true`, strip all that not starts with `//!`
 * @return  {String} String without line comments.
 * @api public
 */

strip.line = function(str, opts) {
  opts = opts || {};
  var re = reLine;
  if(opts.safe) {
    re = reLineIgnore;
  }
  return str ? str.replace(re, '') : '';
};

},{}],59:[function(require,module,exports){
"use strict";

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

exports.mergeTrees = mergeTrees;
exports.walkUp = walkUp;
exports.walkDown = walkDown;
exports.groupProps = groupProps;
exports.calculateStyle = calculateStyle;
exports.mergeObjects = mergeObjects;
exports.calculateOrder = calculateOrder;
exports.parseRuleTree = parseRuleTree;
exports.parseRules = parseRules;
exports.matchFeature = matchFeature;

var _require = require("match-feature");

var match = _require.match;
var whiteList = exports.whiteList = ["filter", "style", "geometry", "properties"];

var ruleCache = exports.ruleCache = {};

function cacheKey(rules) {
    return rules.map(function (r) {
        return r.id;
    }).join("/");
}

function mergeTrees(matchingTrees, context) {
    var style = {};
    var deepestOrder = undefined,
        orderReset = undefined;
    var visible = undefined;

    // Find deepest tree
    matchingTrees.sort(function (a, b) {
        return a.length > b.length ? -1 : b.length > a.length ? 1 : 0;
    });
    var len = matchingTrees[0].length;

    // Iterate trees in parallel
    for (var x = 0; x < len; x++) {
        (function (x) {
            var styles = matchingTrees.map(function (tree) {
                return tree[x];
            });
            mergeObjects.apply(undefined, [style].concat(_toConsumableArray(styles)));

            for (var i = 0; i < styles.length; i++) {
                if (!styles[i]) {
                    continue;
                }

                // `visible` property is only true if all matching rules are visible
                if (styles[i].visible === false) {
                    visible = false;
                } else if (visible === undefined) {
                    visible = true;
                }

                // Make note of the style positions of order-related properties
                if (styles[i].order !== undefined) {
                    deepestOrder = i;
                }

                if (styles[i].orderReset !== undefined) {
                    orderReset = x;
                }
            }
        })(x);
    }

    if (visible === undefined) {
        return null;
    }

    style.visible = visible;

    // Order must be calculated based on the deepest tree that had an order property
    if (deepestOrder !== undefined) {
        var orderTree = matchingTrees[deepestOrder];

        if (orderTree.length <= 1) {
            style.order = orderTree[0].order;
        } else {
            style.order = [];
            for (var x = orderReset || 0; x < orderTree.length; x++) {
                if (orderTree[x] && orderTree[x].order) {
                    style.order.push(orderTree[x].order);
                }
            }

            // Order can be cached if it is only a single value
            if (style.order.length === 1 && typeof style.order[0] === "number") {
                style.order = style.order[0];
            }
            // Or if there are no function dependencies
            else if (!style.order.some(function (v) {
                return typeof v === "function";
            })) {
                style.order = calculateOrder(style.order, context);
            }
        }
    }

    return style;
}

var Rule = (function () {
    function Rule(name, parent, style, filter, properties) {
        _classCallCheck(this, Rule);

        this.id = Rule.id++;
        this.name = name;
        this.style = style;
        this.filter = filter;
        this.properties = properties;
        this.parent = parent;
        this.buildFilter();
        this.buildStyle();
    }

    _createClass(Rule, {
        buildStyle: {
            value: function buildStyle() {
                this.calculatedStyle = calculateStyle(this);
            }
        },
        buildFilter: {
            value: function buildFilter() {
                var type = typeof this.filter;
                if (type === "object") {
                    this.filter = match(this.filter);
                }
            }
        },
        toJSON: {
            value: function toJSON() {
                return {
                    name: this.name,
                    sytle: this.style
                };
            }
        }
    });

    return Rule;
})();

Rule.id = 0;

var RuleLeaf = exports.RuleLeaf = (function (_Rule) {
    function RuleLeaf(_ref) {
        var name = _ref.name;
        var parent = _ref.parent;
        var style = _ref.style;
        var filter = _ref.filter;
        var properties = _ref.properties;

        _classCallCheck(this, RuleLeaf);

        _get(Object.getPrototypeOf(RuleLeaf.prototype), "constructor", this).call(this, name, parent, style, filter, properties);
    }

    _inherits(RuleLeaf, _Rule);

    return RuleLeaf;
})(Rule);

var RuleTree = exports.RuleTree = (function (_Rule2) {
    function RuleTree(_ref) {
        var name = _ref.name;
        var parent = _ref.parent;
        var style = _ref.style;
        var rules = _ref.rules;
        var filter = _ref.filter;
        var properties = _ref.properties;

        _classCallCheck(this, RuleTree);

        _get(Object.getPrototypeOf(RuleTree.prototype), "constructor", this).call(this, name, parent, style, filter, properties);
        this.rules = rules || [];
    }

    _inherits(RuleTree, _Rule2);

    _createClass(RuleTree, {
        addRule: {
            value: function addRule(rule) {
                this.rules.push(rule);
            }
        },
        findMatchingRules: {
            value: function findMatchingRules(context) {
                var rules = [];
                //TODO, should this function take a RuleTree
                matchFeature(context, [this], rules);

                if (rules.length > 0) {

                    var key = cacheKey(rules);
                    if (!ruleCache[key]) {
                        ruleCache[key] = mergeTrees(rules.map(function (x) {
                            return x && x.calculatedStyle;
                        }), context);
                    }
                    return ruleCache[key];
                }
            }
        }
    });

    return RuleTree;
})(Rule);

function isWhiteListed(key) {
    return whiteList.indexOf(key) > -1;
}

function isEmpty(obj) {
    return Object.keys(obj).length === 0;
}

function walkUp(rule, cb) {

    if (rule.parent) {
        walkUp(rule.parent, cb);
    }

    cb(rule);
}

function walkDown(rule, cb) {

    if (rule.rules) {
        rule.rules.forEach(function (r) {
            walkDown(r, cb);
        });
    }

    cb(rule);
}

function groupProps(obj) {
    var whiteListed = {},
        nonWhiteListed = {};

    for (var key in obj) {
        if (isWhiteListed(key)) {
            whiteListed[key] = obj[key];
        } else {
            nonWhiteListed[key] = obj[key];
        }
    }
    return [whiteListed, nonWhiteListed];
}

function calculateStyle(rule) {

    var styles = [];

    if (rule.parent) {
        var cs = rule.parent.calculatedStyle || [];
        styles.push.apply(styles, _toConsumableArray(cs));
    }

    styles.push(rule.style);
    return styles;
}

function mergeObjects(newObj) {
    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        sources[_key - 1] = arguments[_key];
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {

        for (var _iterator = sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var source = _step.value;

            if (!source) {
                continue;
            }
            for (var key in source) {
                var value = source[key];
                if (typeof value === "object" && !Array.isArray(value)) {
                    newObj[key] = mergeObjects(newObj[key] || {}, value);
                } else {
                    newObj[key] = value;
                }
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return newObj;
}

function calculateOrder(orders) {
    var context = arguments[1] === undefined ? null : arguments[1];
    var defaultOrder = arguments[2] === undefined ? 0 : arguments[2];

    var sum = defaultOrder;

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = orders[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var order = _step.value;

            if (typeof order === "function") {
                order = order(context);
            } else {
                order = parseFloat(order);
            }

            if (!order || isNaN(order)) {
                continue;
            }
            sum += order;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return sum;
}

function parseRuleTree(name, rule, parent) {

    var properties = { name: name, parent: parent };

    var _groupProps = groupProps(rule);

    var _groupProps2 = _slicedToArray(_groupProps, 2);

    var whiteListed = _groupProps2[0];
    var nonWhiteListed = _groupProps2[1];

    var empty = isEmpty(nonWhiteListed);
    var Create = undefined;

    if (empty && parent != null) {
        Create = RuleLeaf;
    } else {
        Create = RuleTree;
    }

    var r = new Create(Object.assign(properties, whiteListed));

    if (parent) {
        parent.addRule(r);
    }

    if (!empty) {
        for (var key in nonWhiteListed) {
            var property = nonWhiteListed[key];
            if (typeof property === "object") {
                parseRuleTree(key, property, r);
            } else {
                console.error("Property must be an object");
            }
        }
    }

    return r;
}

function parseRules(rules) {
    var ruleTrees = {};

    for (var key in rules) {
        var rule = rules[key];
        ruleTrees[key] = parseRuleTree(key, rule);
    }

    return ruleTrees;
}

function doesMatch(filter, context) {
    return typeof filter === "function" && filter(context) || filter == null;
}

function matchFeature(context, rules, collectedRules) {
    var matched = false;
    var childMatched = false;

    if (rules.length === 0) {
        return;
    }

    for (var r = 0; r < rules.length; r++) {
        var current = rules[r];
        context.properties = current.properties;

        if (current instanceof RuleLeaf) {

            if (doesMatch(current.filter, context)) {
                matched = true;
                collectedRules.push(current);
            }
        } else if (current instanceof RuleTree) {
            if (doesMatch(current.filter, context)) {
                matched = true;

                childMatched = matchFeature(context, current.rules, collectedRules);

                if (!childMatched) {
                    collectedRules.push(current);
                }
            }
        }

        context.properties = null;
    }

    return matched;
}

Object.defineProperty(exports, "__esModule", {
    value: true
});


},{"match-feature":60}],60:[function(require,module,exports){
module.exports=require(54)
},{"/home/ivan/dev/mapzen/tangram/node_modules/match-feature/index.js":54}],61:[function(require,module,exports){
module.exports.VectorTile = require('./lib/vectortile.js');
module.exports.VectorTileFeature = require('./lib/vectortilefeature.js');
module.exports.VectorTileLayer = require('./lib/vectortilelayer.js');

},{"./lib/vectortile.js":62,"./lib/vectortilefeature.js":63,"./lib/vectortilelayer.js":64}],62:[function(require,module,exports){
'use strict';

var VectorTileLayer = require('./vectortilelayer');

module.exports = VectorTile;

function VectorTile(pbf, end) {
    this.layers = pbf.readFields(readTile, {}, end);
}

function readTile(tag, layers, pbf) {
    if (tag === 3) {
        var layer = readLayer(pbf);
        if (layer.length) layers[layer.name] = layer;
    }
}

function readLayer(pbf) {
    var bytes = pbf.readVarint(),
        end = pbf.pos + bytes,
        layer = new VectorTileLayer(pbf, end);
    pbf.pos = end;
    return layer;
}

},{"./vectortilelayer":64}],63:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = VectorTileFeature;

function VectorTileFeature(pbf, end, extent, keys, values) {
    // Public
    this.properties = {};
    this.extent = extent;
    this.type = 0;

    // Private
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;

    pbf.readFields(readFeature, this, end);
}

function readFeature(tag, feature, pbf) {
    if (tag == 1) feature._id = pbf.readVarint();
    else if (tag == 2) readTag(pbf, feature);
    else if (tag == 3) feature.type = pbf.readVarint();
    else if (tag == 4) feature._geometry = pbf.pos;
}

function readTag(pbf, feature) {
    var bytes = pbf.readVarint(),
        end = pbf.pos + bytes;

    while (pbf.pos < end) {
        var key = feature._keys[pbf.readVarint()],
            value = feature._values[pbf.readVarint()];
        feature.properties[key] = value;
    }
}

VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature.prototype.loadGeometry = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var bytes = pbf.readVarint(),
        end = pbf.pos + bytes,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        lines = [],
        line;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();

            if (cmd === 1) { // moveTo
                if (line) lines.push(line);
                line = [];
            }

            line.push(new Point(x, y));

        } else if (cmd === 7) {
            line.push(line[0].clone()); // closePolygon

        } else {
            throw new Error('unknown command ' + cmd);
        }
    }

    if (line) lines.push(line);

    return lines;
};

VectorTileFeature.prototype.bbox = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var bytes = pbf.readVarint(),
        end = pbf.pos + bytes,

        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();
            if (x < x1) x1 = x;
            if (x > x2) x2 = x;
            if (y < y1) y1 = y;
            if (y > y2) y2 = y;

        } else if (cmd !== 7) {
            throw new Error('unknown command ' + cmd);
        }
    }

    return [x1, y1, x2, y2];
};

},{"point-geometry":65}],64:[function(require,module,exports){
'use strict';

var VectorTileFeature = require('./vectortilefeature.js');

module.exports = VectorTileLayer;

function VectorTileLayer(pbf, end) {
    // Public
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;

    // Private
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];

    pbf.readFields(readLayer, this, end);

    this.length = this._features.length;
}

function readLayer(tag, layer, pbf) {
    if (tag === 15) layer.version = pbf.readVarint();
    else if (tag === 1) layer.name = pbf.readString();
    else if (tag === 5) layer.extent = pbf.readVarint();
    else if (tag === 2) layer._features.push(pbf.pos);
    else if (tag === 3) layer._keys.push(pbf.readString());
    else if (tag === 4) layer._values.push(readValueMessage(pbf));
}

function readValueMessage(pbf) {
    var value = null,
        bytes = pbf.readVarint(),
        end = pbf.pos + bytes;

    while (pbf.pos < end) {
        var tag = pbf.readVarint() >> 3;

        value = tag === 1 ? pbf.readString() :
            tag === 2 ? pbf.readFloat() :
            tag === 3 ? pbf.readDouble() :
            tag === 4 || tag === 5 ? pbf.readVarint() :
            tag === 6 ? pbf.readSVarint() :
            tag === 7 ? Boolean(pbf.readVarint()) : null;
    }

    return value;
}

// return feature `i` from this layer as a `VectorTileFeature`
VectorTileLayer.prototype.feature = function(i) {
    if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');

    this._pbf.pos = this._features[i];
    var end = this._pbf.readVarint() + this._pbf.pos;

    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
};

},{"./vectortilefeature.js":63}],65:[function(require,module,exports){
'use strict';

module.exports = Point;

function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype = {
    clone: function() { return new Point(this.x, this.y); },

    add:     function(p) { return this.clone()._add(p);     },
    sub:     function(p) { return this.clone()._sub(p);     },
    mult:    function(k) { return this.clone()._mult(k);    },
    div:     function(k) { return this.clone()._div(k);     },
    rotate:  function(a) { return this.clone()._rotate(a);  },
    matMult: function(m) { return this.clone()._matMult(m); },
    unit:    function() { return this.clone()._unit(); },
    perp:    function() { return this.clone()._perp(); },
    round:   function() { return this.clone()._round(); },

    mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    equals: function(p) {
        return this.x === p.x &&
               this.y === p.y;
    },

    dist: function(p) {
        return Math.sqrt(this.distSqr(p));
    },

    distSqr: function(p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    angle: function() {
        return Math.atan2(this.y, this.x);
    },

    angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
    },

    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin() for .
    angleWithSep: function(x, y) {
        return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y);
    },

    _matMult: function(m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function(k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function(k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _unit: function() {
        this._div(this.mag());
        return this;
    },

    _perp: function() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

// constructs Point from an array if necessary
Point.convert = function (a) {
    if (a instanceof Point) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point(a[0], a[1]);
    }
    return a;
};

},{}],66:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  __esModule: {value: true}
});
var $__geo__,
    $__utils_47_utils__,
    $__gl_47_shader_95_program__,
    $__gl_45_matrix__;
var Geo = ($__geo__ = require("./geo"), $__geo__ && $__geo__.__esModule && $__geo__ || {default: $__geo__}).default;
var Utils = ($__utils_47_utils__ = require("./utils/utils"), $__utils_47_utils__ && $__utils_47_utils__.__esModule && $__utils_47_utils__ || {default: $__utils_47_utils__}).default;
var ShaderProgram = ($__gl_47_shader_95_program__ = require("./gl/shader_program"), $__gl_47_shader_95_program__ && $__gl_47_shader_95_program__.__esModule && $__gl_47_shader_95_program__ || {default: $__gl_47_shader_95_program__}).default;
var glMatrix = ($__gl_45_matrix__ = require("gl-matrix"), $__gl_45_matrix__ && $__gl_45_matrix__.__esModule && $__gl_45_matrix__ || {default: $__gl_45_matrix__}).default;
var mat4 = glMatrix.mat4;
var vec3 = glMatrix.vec3;
var Camera = function Camera(name, scene) {
  var options = arguments[2] !== (void 0) ? arguments[2] : {};
  this.scene = scene;
  this.position = options.position;
  this.zoom = options.zoom;
};
($traceurRuntime.createClass)(Camera, {
  update: function() {},
  setupProgram: function(program) {},
  updateScene: function() {
    if (this.position || this.zoom) {
      var view = {};
      if (this.position) {
        view = this.position;
      }
      if (this.zoom) {
        view.zoom = this.zoom;
      }
      this.scene.setView(view);
    }
  }
}, {create: function(name, scene, config) {
    switch (config.type) {
      case 'isometric':
        return new IsometricCamera(name, scene, config);
      case 'flat':
        return new FlatCamera(name, scene, config);
      case 'perspective':
      default:
        return new PerspectiveCamera(name, scene, config);
    }
  }});
var $__default = Camera;
var PerspectiveCamera = function PerspectiveCamera(name, scene) {
  var options = arguments[2] !== (void 0) ? arguments[2] : {};
  $traceurRuntime.superConstructor($PerspectiveCamera).call(this, name, scene, options);
  this.type = 'perspective';
  this.focal_length = options.focal_length;
  this.fov = options.fov;
  if (!this.focal_length && !this.fov) {
    this.focal_length = [[16, 2], [17, 2.5], [18, 3], [19, 4], [20, 6]];
  }
  this.vanishing_point = options.vanishing_point || [0, 0];
  this.vanishing_point_skew = [];
  this.position_meters = null;
  this.viewMatrix = new Float64Array(16);
  this.projectionMatrix = new Float32Array(16);
  ShaderProgram.replaceTransform('camera', "\n            uniform mat4 u_projection;\n            uniform vec3 u_eye;\n            uniform vec2 u_vanishing_point;\n\n            void cameraProjection (inout vec4 position) {\n                position = u_projection * position;\n            }");
};
var $PerspectiveCamera = PerspectiveCamera;
($traceurRuntime.createClass)(PerspectiveCamera, {
  constrainCamera: function($__5) {
    var $__6 = $__5,
        view_height = $__6.view_height,
        height = $__6.height,
        focal_length = $__6.focal_length,
        fov = $__6.fov;
    if (!height) {
      if (focal_length) {
        fov = Math.atan(1 / focal_length) * 2;
      } else if (fov) {
        fov = fov * Math.PI / 180;
        focal_length = 1 / Math.tan(fov / 2);
      }
      height = view_height / 2 * focal_length;
    } else {
      focal_length = 2 * height / view_height;
      fov = Math.atan(1 / focal_length) * 2;
    }
    return {
      view_height: view_height,
      height: height,
      focal_length: focal_length,
      fov: fov
    };
  },
  updateMatrices: function() {
    var viewport_height = this.scene.css_size.height * Geo.metersPerPixel(this.scene.zoom);
    var $__5 = this.constrainCamera({
      view_height: viewport_height,
      focal_length: Utils.interpolate(this.scene.zoom, this.focal_length),
      fov: Utils.interpolate(this.scene.zoom, this.fov)
    }),
        height = $__5.height,
        fov = $__5.fov;
    var position = [this.scene.center_meters.x, this.scene.center_meters.y, height];
    this.position_meters = position;
    mat4.lookAt(this.viewMatrix, vec3.fromValues(position[0], position[1], 0), vec3.fromValues(position[0], position[1], -1), vec3.fromValues(0, 1, 0));
    mat4.perspective(this.projectionMatrix, fov, this.scene.view_aspect, 1, height + 1);
    this.vanishing_point_skew[0] = this.vanishing_point[0] / this.scene.css_size.width;
    this.vanishing_point_skew[1] = this.vanishing_point[1] / this.scene.css_size.height;
    this.projectionMatrix[8] = -this.vanishing_point_skew[0];
    this.projectionMatrix[9] = -this.vanishing_point_skew[1];
    mat4.translate(this.projectionMatrix, this.projectionMatrix, vec3.fromValues(viewport_height / 2 * this.scene.view_aspect * -this.vanishing_point_skew[0], viewport_height / 2 * -this.vanishing_point_skew[1], 0));
    mat4.translate(this.projectionMatrix, this.projectionMatrix, vec3.fromValues(0, 0, -height));
  },
  update: function() {
    $traceurRuntime.superGet(this, $PerspectiveCamera.prototype, "update").call(this);
    this.updateMatrices();
  },
  setupProgram: function(program) {
    program.uniform('Matrix4fv', 'u_projection', false, this.projectionMatrix);
    program.uniform('3f', 'u_eye', 0, 0, this.position_meters[2]);
    program.uniform('2fv', 'u_vanishing_point', this.vanishing_point_skew);
  }
}, {}, Camera);
var IsometricCamera = function IsometricCamera(name, scene) {
  var options = arguments[2] !== (void 0) ? arguments[2] : {};
  $traceurRuntime.superConstructor($IsometricCamera).call(this, name, scene, options);
  this.type = 'isometric';
  this.axis = options.axis || {
    x: 0,
    y: 1
  };
  if (this.axis.length === 2) {
    this.axis = {
      x: this.axis[0],
      y: this.axis[1]
    };
  }
  this.viewMatrix = new Float64Array(16);
  this.projectionMatrix = new Float32Array(16);
  ShaderProgram.replaceTransform('camera', "\n            uniform mat4 u_projection;\n            uniform vec3 u_eye;\n            uniform vec2 u_vanishing_point;\n\n            void cameraProjection (inout vec4 position) {\n                position = u_projection * position;\n                // position.xy += position.z * u_isometric_axis;\n\n                // Reverse z for depth buffer so up is negative,\n                // and scale down values so objects higher than one screen height will not get clipped\n                // pull forward slightly to avoid going past far clipping plane\n                position.z = -position.z / 100. + 1. - 0.001;\n            }");
};
var $IsometricCamera = IsometricCamera;
($traceurRuntime.createClass)(IsometricCamera, {
  update: function() {
    $traceurRuntime.superGet(this, $IsometricCamera.prototype, "update").call(this);
    var position = [this.scene.center_meters.x, this.scene.center_meters.y];
    mat4.identity(this.viewMatrix);
    mat4.translate(this.viewMatrix, this.viewMatrix, vec3.fromValues(-position[0], -position[1], 0));
    mat4.identity(this.projectionMatrix);
    this.projectionMatrix[8] = this.axis.x / this.scene.view_aspect;
    this.projectionMatrix[9] = this.axis.y;
    mat4.scale(this.projectionMatrix, this.projectionMatrix, vec3.fromValues(2 / this.scene.viewport_meters.x, 2 / this.scene.viewport_meters.y, 2 / this.scene.viewport_meters.y));
  },
  setupProgram: function(program) {
    program.uniform('Matrix4fv', 'u_projection', false, this.projectionMatrix);
    var viewport_height = this.scene.css_size.height * Geo.metersPerPixel(this.scene.zoom);
    program.uniform('3f', 'u_eye', 0, 0, viewport_height);
    program.uniform('2f', 'u_vanishing_point', 0, 0);
  }
}, {}, Camera);
var FlatCamera = function FlatCamera(name, scene) {
  var options = arguments[2] !== (void 0) ? arguments[2] : {};
  $traceurRuntime.superConstructor($FlatCamera).call(this, name, scene, options);
  this.type = 'flat';
};
var $FlatCamera = FlatCamera;
($traceurRuntime.createClass)(FlatCamera, {update: function() {
    this.axis.x = 0;
    this.axis.y = 0;
    $traceurRuntime.superGet(this, $FlatCamera.prototype, "update").call(this);
  }}, {}, IsometricCamera);


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/camera.js
},{"./geo":67,"./gl/shader_program":71,"./utils/utils":98,"gl-matrix":21}],67:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  __esModule: {value: true}
});
var Geo;
var $__default = Geo = {};
Geo.tile_size = 256;
Geo.half_circumference_meters = 20037508.342789244;
Geo.min_zoom_meters_per_pixel = Geo.half_circumference_meters * 2 / Geo.tile_size;
Geo.meters_per_pixel = [];
Geo.max_zoom = 20;
for (var z = 0; z <= Geo.max_zoom; z++) {
  Geo.meters_per_pixel[z] = Geo.min_zoom_meters_per_pixel / Math.pow(2, z);
}
Geo.metersPerPixel = function(zoom) {
  return Geo.min_zoom_meters_per_pixel / Math.pow(2, zoom);
};
Geo.units_per_meter = [];
Geo.setTileScale = function(scale) {
  Geo.tile_scale = scale;
  Geo.units_per_pixel = Geo.tile_scale / Geo.tile_size;
  for (var z = 0; z <= Geo.max_zoom; z++) {
    Geo.units_per_meter[z] = Geo.tile_scale / (Geo.tile_size * Geo.meters_per_pixel[z]);
  }
};
Geo.metersForTile = function(tile) {
  return {
    x: tile.x * Geo.half_circumference_meters * 2 / Math.pow(2, tile.z) - Geo.half_circumference_meters,
    y: -(tile.y * Geo.half_circumference_meters * 2 / Math.pow(2, tile.z) - Geo.half_circumference_meters)
  };
};
Geo.tileForMeters = function($__0, zoom) {
  var $__1 = $__0,
      x = $__1[0],
      y = $__1[1];
  return {
    x: Math.floor((x + Geo.half_circumference_meters) / (Geo.half_circumference_meters * 2 / Math.pow(2, zoom))),
    y: Math.floor((-y + Geo.half_circumference_meters) / (Geo.half_circumference_meters * 2 / Math.pow(2, zoom))),
    z: zoom
  };
};
Geo.metersToLatLng = function($__0) {
  var $__1 = $__0,
      x = $__1[0],
      y = $__1[1];
  x /= Geo.half_circumference_meters;
  y /= Geo.half_circumference_meters;
  y = (2 * Math.atan(Math.exp(y * Math.PI)) - (Math.PI / 2)) / Math.PI;
  x *= 180;
  y *= 180;
  return [x, y];
};
Geo.latLngToMeters = function($__0) {
  var $__1 = $__0,
      x = $__1[0],
      y = $__1[1];
  y = Math.log(Math.tan(y * Math.PI / 360 + Math.PI / 4)) / Math.PI;
  y *= Geo.half_circumference_meters;
  x *= Geo.half_circumference_meters / 180;
  return [x, y];
};
Geo.transformGeometry = function(geometry, transform) {
  if (geometry.type === 'Point') {
    transform(geometry.coordinates);
  } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {
    geometry.coordinates.forEach(transform);
  } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {
    geometry.coordinates.forEach((function(coordinates) {
      return coordinates.forEach(transform);
    }));
  } else if (geometry.type === 'MultiPolygon') {
    geometry.coordinates.forEach((function(polygon) {
      polygon.forEach((function(coordinates) {
        return coordinates.forEach(transform);
      }));
    }));
  }
};
Geo.boxIntersect = function(b1, b2) {
  return !(b2.sw.x > b1.ne.x || b2.ne.x < b1.sw.x || b2.sw.y > b1.ne.y || b2.ne.y < b1.sw.y);
};
Geo.findBoundingBox = function(polygon) {
  var min_x = Infinity,
      max_x = -Infinity,
      min_y = Infinity,
      max_y = -Infinity;
  var num_coords = polygon[0].length;
  for (var c = 0; c < num_coords; c++) {
    var coord = polygon[0][c];
    if (coord[0] < min_x) {
      min_x = coord[0];
    }
    if (coord[1] < min_y) {
      min_y = coord[1];
    }
    if (coord[0] > max_x) {
      max_x = coord[0];
    }
    if (coord[1] > max_y) {
      max_y = coord[1];
    }
  }
  return [min_x, min_y, max_x, max_y];
};


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/geo.js
},{}],68:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  __esModule: {value: true}
});
var gl;
var $__default = gl = {};
gl.BYTE = 0x1400;
gl.UNSIGNED_BYTE = 0x1401;
gl.SHORT = 0x1402;
gl.UNSIGNED_SHORT = 0x1403;
gl.INT = 0x1404;
gl.UNSIGNED_INT = 0x1405;
gl.FLOAT = 0x1406;


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/gl/constants.js
},{}],69:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  __esModule: {value: true}
});
var $__loglevel__;
var log = ($__loglevel__ = require("loglevel"), $__loglevel__ && $__loglevel__.__esModule && $__loglevel__ || {default: $__loglevel__}).default;
var Context;
var $__default = Context = {};
Context.getContext = function getContext(canvas, options) {
  var fullscreen = false;
  if (canvas == null) {
    canvas = document.createElement('canvas');
    canvas.style.position = 'absolute';
    canvas.style.top = 0;
    canvas.style.left = 0;
    canvas.style.zIndex = -1;
    document.body.appendChild(canvas);
    fullscreen = true;
  }
  var gl = canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options);
  if (!gl) {
    log.error("Couldn't create WebGL context. Your browser probably doesn't support WebGL or it's turned off?");
    alert("Couldn't create WebGL context. Your browser probably doesn't support WebGL or it's turned off?");
    throw "Couldn't create WebGL context";
  }
  Context.resize(gl, window.innerWidth, window.innerHeight);
  if (fullscreen === true) {
    window.addEventListener('resize', function() {
      Context.resize(gl, window.innerWidth, window.innerHeight);
    });
  }
  return gl;
};
Context.resize = function(gl, width, height) {
  var device_pixel_ratio = window.devicePixelRatio || 1;
  gl.canvas.style.width = width + 'px';
  gl.canvas.style.height = height + 'px';
  gl.canvas.width = Math.round(gl.canvas.style.width * device_pixel_ratio);
  gl.canvas.height = Math.round(gl.canvas.style.width * device_pixel_ratio);
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
};


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/gl/context.js
},{"loglevel":53}],70:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  __esModule: {value: true}
});
var GLSL = {};
var $__default = GLSL;
GLSL.parseUniforms = function(uniforms) {
  var $__0,
      $__1;
  var prefix = arguments[1] !== (void 0) ? arguments[1] : null;
  var parsed = [];
  for (var name in uniforms) {
    var uniform = uniforms[name];
    var u;
    if (prefix) {
      name = prefix + '.' + name;
    }
    if (typeof uniform === 'number') {
      parsed.push({
        type: 'float',
        method: '1f',
        name: name,
        value: uniform
      });
    } else if (Array.isArray(uniform)) {
      if (typeof uniform[0] === 'number') {
        if (uniform.length >= 2 && uniform.length <= 4) {
          parsed.push({
            type: 'vec' + uniform.length,
            method: uniform.length + 'fv',
            name: name,
            value: uniform
          });
        } else if (uniform.length > 4) {
          parsed.push({
            type: 'float[]',
            method: '1fv',
            name: name + '[0]',
            value: uniform
          });
        }
      } else if (typeof uniform[0] === 'string') {
        for (u = 0; u < uniform.length; u++) {
          parsed.push({
            type: 'sampler2D',
            method: '1i',
            name: name + '[' + u + ']',
            value: uniform[u]
          });
        }
      } else if (Array.isArray(uniform[0]) && typeof uniform[0][0] === 'number') {
        if (uniform[0].length >= 2 && uniform[0].length <= 4) {
          for (u = 0; u < uniform.length; u++) {
            parsed.push({
              type: 'vec' + uniform[0].length,
              method: uniform[u].length + 'fv',
              name: name + '[' + u + ']',
              value: uniform[u]
            });
          }
        }
      } else if (typeof uniform[0] === 'object') {
        for (u = 0; u < uniform.length; u++) {
          ($__0 = parsed).push.apply($__0, $traceurRuntime.spread(GLSL.parseUniforms(uniform[u], name + '[' + u + ']')));
        }
      }
    } else if (typeof uniform === 'boolean') {
      parsed.push({
        type: 'bool',
        method: '1i',
        name: name,
        value: uniform
      });
    } else if (typeof uniform === 'string') {
      parsed.push({
        type: 'sampler2D',
        method: '1i',
        name: name,
        value: uniform
      });
    } else if (typeof uniform === 'object') {
      ($__1 = parsed).push.apply($__1, $traceurRuntime.spread(GLSL.parseUniforms(uniform, name)));
    }
  }
  return parsed;
};
GLSL.defineVariable = function(name, value) {
  var prefix = arguments[2] !== (void 0) ? arguments[2] : null;
  var type,
      array;
  var structs = '';
  prefix = prefix ? prefix + '_' + name : name;
  if (typeof value === 'number') {
    type = 'float';
  } else if (Array.isArray(value)) {
    if (typeof value[0] === 'number') {
      if (value.length >= 2 && value.length <= 4) {
        type = 'vec' + value.length;
      } else {
        type = 'float';
        array = value.length;
      }
    } else if (typeof value[0] === 'string') {
      type = 'sampler2D';
      array = value.length;
    } else if (Array.isArray(value[0]) && typeof value[0][0] === 'number') {
      if (value[0].length >= 2 && value[0].length <= 4) {
        type = 'vec' + value[0].length;
      }
      array = value[0].length;
    } else if (typeof value[0] === 'object') {
      type = '_type_' + prefix;
      array = value.length;
      structs += GLSL.defineStruct(type, value[0], prefix) + '\n';
    }
  } else if (typeof value === 'boolean') {
    type = 'bool';
  } else if (typeof value === 'string') {
    type = 'sampler2D';
  } else if (typeof value === 'object') {
    type = '_type_' + prefix;
    structs += GLSL.defineStruct(type, value, prefix) + '\n';
  }
  var variable = '';
  variable += (type + " " + name);
  if (array) {
    variable += ("[" + array + "]");
  }
  variable += ';\n';
  return {
    variable: variable,
    structs: structs
  };
};
GLSL.defineStruct = function(type, value) {
  var prefix = arguments[2] !== (void 0) ? arguments[2] : null;
  var struct = ("struct " + type + " {\n");
  var dependents = '';
  for (var field in value) {
    var subvar = GLSL.defineVariable(field, value[field], prefix);
    struct += '    ' + subvar.variable;
    dependents += subvar.structs;
  }
  struct += '};\n';
  struct = dependents + struct;
  return struct;
};
GLSL.defineUniform = function(name, value) {
  var def = GLSL.defineVariable(name, value);
  def = def.structs + 'uniform ' + def.variable;
  return def;
};
GLSL.isUniformDefined = function(name, source) {
  var re = new RegExp('uniform[^;]+(?:{[\\s\\S]*})?[^;]*\\b' + name + '\\b', 'g');
  if (source.match(re)) {
    return true;
  }
  return false;
};
GLSL.isSymbolReferenced = function(name, source) {
  var re = new RegExp('\\b' + name + '\\b', 'g');
  if (source.search(re) >= 0) {
    return true;
  }
  return false;
};
GLSL.expandVec4 = function(v) {
  var w = arguments[1] !== (void 0) ? arguments[1] : 1;
  var x;
  if (Array.isArray(v) && v.length === 3) {
    x = $traceurRuntime.spread(v, [w]).map(parseFloat);
  } else {
    x = [v, v, v, w].map(parseFloat);
  }
  if (x && x.every((function(n) {
    return typeof n === 'number' && !isNaN(n);
  }))) {
    return x;
  }
};


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/gl/glsl.js
},{}],71:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  __esModule: {value: true}
});
var $__glsl__,
    $__texture__,
    $__loglevel__,
    $__strip_45_comments__;
var GLSL = ($__glsl__ = require("./glsl"), $__glsl__ && $__glsl__.__esModule && $__glsl__ || {default: $__glsl__}).default;
var Texture = ($__texture__ = require("./texture"), $__texture__ && $__texture__.__esModule && $__texture__ || {default: $__texture__}).default;
var log = ($__loglevel__ = require("loglevel"), $__loglevel__ && $__loglevel__.__esModule && $__loglevel__ || {default: $__loglevel__}).default;
var strip = ($__strip_45_comments__ = require("strip-comments"), $__strip_45_comments__ && $__strip_45_comments__.__esModule && $__strip_45_comments__ || {default: $__strip_45_comments__}).default;
ShaderProgram.id = 0;
ShaderProgram.programs = {};
function ShaderProgram(gl, vertex_source, fragment_source, options) {
  options = options || {};
  this.gl = gl;
  this.program = null;
  this.compiled = false;
  this.compiling = false;
  this.defines = Object.assign({}, options.defines || {});
  this.transforms = Object.assign({}, options.transforms || {});
  this.dependent_uniforms = options.uniforms;
  this.uniforms = {};
  this.attribs = {};
  this.vertex_source = vertex_source;
  this.fragment_source = fragment_source;
  this.id = ShaderProgram.id++;
  ShaderProgram.programs[this.id] = this;
  this.name = options.name;
  this.compile();
}
var $__default = ShaderProgram;
ShaderProgram.prototype.destroy = function() {
  this.gl.useProgram(null);
  this.gl.deleteProgram(this.program);
  this.program = null;
  this.uniforms = {};
  this.attribs = {};
  delete ShaderProgram.programs[this.id];
  this.compiled = false;
};
ShaderProgram.prototype.use = function() {
  if (!this.compiled) {
    return;
  }
  if (ShaderProgram.current !== this) {
    this.gl.useProgram(this.program);
  }
  ShaderProgram.current = this;
};
ShaderProgram.current = null;
ShaderProgram.defines = {};
ShaderProgram.transforms = {};
ShaderProgram.addTransform = function(key) {
  var $__9;
  for (var transforms = [],
      $__6 = 1; $__6 < arguments.length; $__6++)
    transforms[$__6 - 1] = arguments[$__6];
  ShaderProgram.transforms[key] = ShaderProgram.transforms[key] || [];
  ($__9 = ShaderProgram.transforms[key]).push.apply($__9, $traceurRuntime.spread(transforms));
};
ShaderProgram.removeTransform = function(key) {
  ShaderProgram.transforms[key] = [];
};
ShaderProgram.replaceTransform = function(key) {
  var $__9;
  for (var transforms = [],
      $__7 = 1; $__7 < arguments.length; $__7++)
    transforms[$__7 - 1] = arguments[$__7];
  ShaderProgram.removeTransform(key);
  ($__9 = ShaderProgram).addTransform.apply($__9, $traceurRuntime.spread([key], transforms));
};
ShaderProgram.prototype.compile = function() {
  if (this.compiling) {
    throw (new Error(("ShaderProgram.compile(): skipping for " + this.id + " (" + this.name + ") because already compiling")));
  }
  this.compiling = true;
  this.compiled = false;
  this.computed_vertex_source = this.vertex_source;
  this.computed_fragment_source = this.fragment_source;
  var defines = this.buildDefineList();
  var transforms = this.buildShaderTransformList();
  var regexp;
  for (var key in transforms) {
    var transform = transforms[key];
    if (!transform || (Array.isArray(transform) && transform.length === 0)) {
      continue;
    }
    regexp = new RegExp('^\\s*#pragma\\s+tangram:\\s+' + key + '\\s*$', 'm');
    var inject_vertex = this.computed_vertex_source.match(regexp);
    var inject_fragment = this.computed_fragment_source.match(regexp);
    if (inject_vertex == null && inject_fragment == null) {
      continue;
    }
    var source = transform;
    if (Array.isArray(transform)) {
      source = transform.reduce((function(prev, cur) {
        return (prev + "\n" + cur);
      }));
    }
    if (inject_vertex != null) {
      this.computed_vertex_source = this.computed_vertex_source.replace(regexp, source);
    }
    if (inject_fragment != null) {
      this.computed_fragment_source = this.computed_fragment_source.replace(regexp, source);
    }
    defines['TANGRAM_TRANSFORM_' + key.replace(' ', '_').toUpperCase()] = true;
  }
  regexp = new RegExp('^\\s*#pragma\\s+tangram:\\s+\\w+\\s*$', 'gm');
  this.computed_vertex_source = this.computed_vertex_source.replace(regexp, '');
  this.computed_fragment_source = this.computed_fragment_source.replace(regexp, '');
  var define_str = ShaderProgram.buildDefineString(defines);
  this.computed_vertex_source = define_str + this.computed_vertex_source;
  this.computed_fragment_source = define_str + this.computed_fragment_source;
  this.ensureUniforms(this.dependent_uniforms);
  var info = (this.name ? (this.name + ' / id ' + this.id) : ('id ' + this.id));
  this.computed_vertex_source = '// Program: ' + info + '\n' + this.computed_vertex_source;
  this.computed_fragment_source = '// Program: ' + info + '\n' + this.computed_fragment_source;
  try {
    this.program = ShaderProgram.updateProgram(this.gl, this.program, this.computed_vertex_source, this.computed_fragment_source);
    this.compiled = true;
    this.compiling = false;
  } catch (error) {
    this.program = null;
    this.compiled = false;
    this.compiling = false;
    throw (new Error(("ShaderProgram.compile(): program " + this.id + " (" + this.name + ") error:"), error));
  }
  this.use();
  this.refreshUniforms();
  this.refreshAttributes();
};
ShaderProgram.prototype.buildDefineList = function() {
  var d,
      defines = {};
  for (d in ShaderProgram.defines) {
    defines[d] = ShaderProgram.defines[d];
  }
  for (d in this.defines) {
    defines[d] = this.defines[d];
  }
  return defines;
};
ShaderProgram.prototype.buildShaderTransformList = function() {
  var $__9,
      $__10;
  var d,
      transforms = {};
  for (d in ShaderProgram.transforms) {
    transforms[d] = [];
    if (Array.isArray(ShaderProgram.transforms[d])) {
      ($__9 = transforms[d]).push.apply($__9, $traceurRuntime.spread(ShaderProgram.transforms[d]));
    } else {
      transforms[d] = [ShaderProgram.transforms[d]];
    }
  }
  for (d in this.transforms) {
    transforms[d] = transforms[d] || [];
    if (Array.isArray(this.transforms[d])) {
      ($__10 = transforms[d]).push.apply($__10, $traceurRuntime.spread(this.transforms[d]));
    } else {
      transforms[d].push(this.transforms[d]);
    }
  }
  return transforms;
};
ShaderProgram.buildDefineString = function(defines) {
  var define_str = "";
  for (var d in defines) {
    if (defines[d] === false) {
      continue;
    } else if (typeof defines[d] === 'boolean' && defines[d] === true) {
      define_str += "#define " + d + "\n";
    } else if (typeof defines[d] === 'number' && Math.floor(defines[d]) === defines[d]) {
      define_str += "#define " + d + " " + defines[d].toFixed(1) + "\n";
    } else {
      define_str += "#define " + d + " " + defines[d] + "\n";
    }
  }
  return define_str;
};
ShaderProgram.prototype.ensureUniforms = function(uniforms) {
  if (!uniforms) {
    return;
  }
  var vs = strip(this.computed_vertex_source);
  var fs = strip(this.computed_fragment_source);
  var inject,
      vs_injections = [],
      fs_injections = [];
  for (var name in uniforms) {
    inject = null;
    if (!GLSL.isUniformDefined(name, vs) && GLSL.isSymbolReferenced(name, vs)) {
      if (!inject) {
        inject = GLSL.defineUniform(name, uniforms[name]);
      }
      log.trace(("Program " + this.name + ": " + name + " not defined in vertex shader, injecting: '" + inject + "'"));
      vs_injections.push(inject);
    }
    if (!GLSL.isUniformDefined(name, fs) && GLSL.isSymbolReferenced(name, fs)) {
      if (!inject) {
        inject = GLSL.defineUniform(name, uniforms[name]);
      }
      log.trace(("Program " + this.name + ": " + name + " not defined in fragment shader, injecting: '" + inject + "'"));
      fs_injections.push(inject);
    }
  }
  if (vs_injections.length > 0) {
    this.computed_vertex_source = vs_injections.join('\n') + this.computed_vertex_source;
  }
  if (fs_injections.length > 0) {
    this.computed_fragment_source = fs_injections.join('\n') + this.computed_fragment_source;
  }
};
ShaderProgram.prototype.setUniforms = function(uniforms) {
  var reset_texture_unit = arguments[1] !== (void 0) ? arguments[1] : true;
  if (!this.compiled) {
    return;
  }
  if (reset_texture_unit) {
    this.texture_unit = 0;
  }
  var parsed = GLSL.parseUniforms(uniforms);
  for (var $__4 = parsed[$traceurRuntime.toProperty(Symbol.iterator)](),
      $__5; !($__5 = $__4.next()).done; ) {
    var uniform = $__5.value;
    {
      if (uniform.type === 'sampler2D') {
        this.setTextureUniform(uniform.name, uniform.value);
      } else {
        this.uniform(uniform.method, uniform.name, uniform.value);
      }
    }
  }
};
ShaderProgram.prototype.saveUniforms = function(subset) {
  var uniforms = subset || this.uniforms;
  for (var u in uniforms) {
    var uniform = this.uniforms[u];
    if (uniform) {
      uniform.saved_value = uniform.value;
    }
  }
  this.saved_texture_unit = this.texture_unit || 0;
};
ShaderProgram.prototype.restoreUniforms = function(subset) {
  var uniforms = subset || this.uniforms;
  for (var u in uniforms) {
    var uniform = this.uniforms[u];
    if (uniform && uniform.saved_value) {
      uniform.value = uniform.saved_value;
      this.updateUniform(u);
    }
  }
  this.texture_unit = this.saved_texture_unit || 0;
};
ShaderProgram.prototype.setTextureUniform = function(uniform_name, texture_name) {
  var texture = Texture.textures[texture_name];
  if (texture == null) {
    texture = new Texture(this.gl, texture_name);
    texture.load(texture_name);
  }
  texture.bind(this.texture_unit);
  this.uniform('1i', uniform_name, this.texture_unit);
  this.texture_unit++;
};
ShaderProgram.prototype.uniform = function(method, name) {
  for (var value = [],
      $__8 = 2; $__8 < arguments.length; $__8++)
    value[$__8 - 2] = arguments[$__8];
  if (!this.compiled) {
    return;
  }
  this.uniforms[name] = this.uniforms[name] || {};
  var uniform = this.uniforms[name];
  uniform.name = name;
  if (uniform.location === undefined) {
    uniform.location = this.gl.getUniformLocation(this.program, name);
  }
  uniform.method = 'uniform' + method;
  uniform.value = value;
  this.updateUniform(name);
};
ShaderProgram.prototype.updateUniform = function(name) {
  if (!this.compiled) {
    return;
  }
  var uniform = this.uniforms[name];
  if (!uniform || uniform.location == null) {
    return;
  }
  this.use();
  this.gl[uniform.method].apply(this.gl, [uniform.location].concat(uniform.value));
};
ShaderProgram.prototype.refreshUniforms = function() {
  if (!this.compiled) {
    return;
  }
  for (var u in this.uniforms) {
    this.uniforms[u].location = this.gl.getUniformLocation(this.program, u);
    this.updateUniform(u);
  }
};
ShaderProgram.prototype.refreshAttributes = function() {
  this.attribs = {};
};
ShaderProgram.prototype.attribute = function(name) {
  if (!this.compiled) {
    return;
  }
  var attrib = (this.attribs[name] = this.attribs[name] || {});
  if (attrib.location != null) {
    return attrib;
  }
  attrib.name = name;
  attrib.location = this.gl.getAttribLocation(this.program, name);
  return attrib;
};
ShaderProgram.updateProgram = function(gl, program, vertex_shader_source, fragment_shader_source) {
  try {
    var vertex_shader = ShaderProgram.createShader(gl, vertex_shader_source, gl.VERTEX_SHADER);
    var fragment_shader = ShaderProgram.createShader(gl, '#ifdef GL_ES\nprecision highp float;\n#endif\n\n' + fragment_shader_source, gl.FRAGMENT_SHADER);
  } catch (err) {
    log.error(err);
    throw err;
  }
  gl.useProgram(null);
  if (program != null) {
    var old_shaders = gl.getAttachedShaders(program);
    for (var i = 0; i < old_shaders.length; i++) {
      gl.detachShader(program, old_shaders[i]);
    }
  } else {
    program = gl.createProgram();
  }
  if (vertex_shader == null || fragment_shader == null) {
    return program;
  }
  gl.attachShader(program, vertex_shader);
  gl.attachShader(program, fragment_shader);
  gl.deleteShader(vertex_shader);
  gl.deleteShader(fragment_shader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    var program_error = new Error(("WebGL program error:\n            VALIDATE_STATUS: " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n            ERROR: " + gl.getError() + "\n            --- Vertex Shader ---\n            " + vertex_shader_source + "\n            --- Fragment Shader ---\n            " + fragment_shader_source));
    log.error(program_error);
    throw program_error;
  }
  return program;
};
ShaderProgram.createShader = function(gl, source, type) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    var shader_error = "WebGL shader error:\n" + (type === gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT") + " SHADER:\n" + gl.getShaderInfoLog(shader);
    throw shader_error;
  }
  return shader;
};


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/gl/shader_program.js
},{"./glsl":70,"./texture":73,"loglevel":53,"strip-comments":58}],72:[function(require,module,exports){
"use strict";
var shaderSources = {};
shaderSources['gl/shaders/material'] = "// MATERIALS\n" + "//\n" + "struct Material {\n" + "    #ifdef TANGRAM_MATERIAL_EMISSION\n" + "        vec4 emission;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_AMBIENT\n" + "        vec4 ambient;\n" + "    #endif \n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        vec4 diffuse;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        vec4 specular;\n" + "        float shininess;\n" + "    #endif\n" + "};\n" + "\n" + "// Note: uniforms (u_[name]) and varyings (v_[name]) are \n" + "//      copy to global instances ( g_[name] ) to allow \n" + "//      modifications\n" + "//\n" + "uniform Material u_material;\n" + "Material g_material = u_material;\n" + "\n" + "// GLOBAL LIGHTS ACCUMULATORS for each enable MATERIAL property\n" + "//\n" + "#ifdef TANGRAM_MATERIAL_AMBIENT\n" + "    vec4 g_light_accumulator_ambient = vec4(0.0);\n" + "#endif\n" + "#ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "    vec4 g_light_accumulator_diffuse = vec4(0.0);\n" + "#endif\n" + "#ifdef TANGRAM_MATERIAL_SPECULAR\n" + "    vec4 g_light_accumulator_specular = vec4(0.0);\n" + "#endif\n" + "";
shaderSources['gl/shaders/spotLight'] = "struct SpotLight {\n" + "    vec4 ambient;\n" + "    vec4 diffuse;\n" + "    vec4 specular;\n" + "    vec4 position;\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "    float attenuationExponent;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "    float innerRadius;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "    float outerRadius;\n" + "#endif\n" + "\n" + "    vec3 direction;\n" + "    float spotCosCutoff;\n" + "    float spotExponent;\n" + "};\n" + "\n" + "void calculateLight(in SpotLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "\n" + "    float dist = length(_light.position.xyz - _eyeToPoint);\n" + "\n" + "    // Compute vector from surface to light position\n" + "    vec3 VP = (_light.position.xyz - _eyeToPoint) / dist;\n" + "\n" + "    // normal . light direction\n" + "    float nDotVP = clamp(dot(_normal, VP), 0.0, 1.0);\n" + "\n" + "    // Attenuation defaults\n" + "    float attenuation = 1.0;\n" + "    #ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "        float Rin = 1.0;\n" + "        float e = _light.attenuationExponent;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "            float Rdiff = _light.outerRadius-Rin;\n" + "            float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "            attenuation = 1.0-(pow(d,e));\n" + "        #else\n" + "            // If no outer is provide behaves like:\n" + "            // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "            float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "            attenuation = clamp(1.0/(pow(d,e)), 0.0, 1.0);\n" + "        #endif\n" + "    #else\n" + "        float Rin = 0.0;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float Rdiff = _light.outerRadius-Rin;\n" + "                float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                // If no outer is provide behaves like:\n" + "                // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "                float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "                attenuation = clamp(1.0/d, 0.0, 1.0);\n" + "            #endif\n" + "        #else\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float d = clamp(dist/_light.outerRadius, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                attenuation = 1.0;\n" + "            #endif\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // spotlight attenuation factor\n" + "    float spotAttenuation = 0.0;\n" + "\n" + "    // See if point on surface is inside cone of illumination\n" + "    float spotDot = clamp(dot(-VP, normalize(_light.direction)), 0.0, 1.0);\n" + "\n" + "    if (spotDot >= _light.spotCosCutoff) {\n" + "        spotAttenuation = pow(spotDot, _light.spotExponent);\n" + "    }\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_AMBIENT\n" + "        g_light_accumulator_ambient += _light.ambient * attenuation * spotAttenuation;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        g_light_accumulator_diffuse += _light.diffuse * nDotVP * attenuation * spotAttenuation;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        // Power factor for shiny speculars\n" + "        float pf = 0.0;\n" + "        if (nDotVP > 0.0) {\n" + "            vec3 reflectVector = reflect(-VP, _normal);\n" + "            float eyeDotR = max(dot(-normalize(_eyeToPoint), reflectVector), 0.0);\n" + "            pf = pow(eyeDotR, g_material.shininess);\n" + "        }\n" + "        g_light_accumulator_specular += _light.specular * pf * attenuation * spotAttenuation;\n" + "    #endif\n" + "}\n" + "";
shaderSources['gl/shaders/ambientLight'] = "struct AmbientLight {\n" + "    vec4 ambient;\n" + "};\n" + "\n" + "void calculateLight(in AmbientLight _light, in vec3 _eyeToPoint, in vec3 _normal){\n" + "    #ifdef TANGRAM_MATERIAL_AMBIENT\n" + "        g_light_accumulator_ambient += _light.ambient;\n" + "    #endif\n" + "}\n" + "";
shaderSources['gl/shaders/spherical_environment_map'] = "// Spherical environment map\n" + "// Based on: http://www.clicktorelease.com/blog/creating-spherical-environment-mapping-shader\n" + "\n" + "// view: location of camera\n" + "// position: location of current point on surface\n" + "// normal: normal of current point on surface\n" + "// skew: skewing factor (used to compensate for altered vanishing point)\n" + "// envmap: spherical environment map texture\n" + "\n" + "vec4 sphericalEnvironmentMap(vec3 view, vec3 position, vec3 normal, vec2 skew, sampler2D envmap) {\n" + "    // Normalized vector from camera to surface\n" + "    vec3 eye = normalize(position.xyz - view.xyz);\n" + "\n" + "    // Skew\n" + "    eye.xy -= skew;\n" + "    eye = normalize(eye);\n" + "\n" + "    // Reflection of eye off of surface normal\n" + "    vec3 r = reflect(eye, normal);\n" + "\n" + "    // Map reflected vector onto the surface of a sphere\n" + "    r.z += 1.;\n" + "    float m = 2. * length(r);\n" + "\n" + "    // Adjust xy to account for spherical shape, and center in middle of texture\n" + "    vec2 uv = r.xy / m + .5;\n" + "\n" + "    // Sample the environment map\n" + "    return texture2D(envmap, uv);\n" + "}\n" + "";
shaderSources['gl/shaders/pointLight'] = "struct PointLight {\n" + "    vec4 ambient;\n" + "    vec4 diffuse;\n" + "    vec4 specular;\n" + "    vec4 position;\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "    float attenuationExponent;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "    float innerRadius;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "    float outerRadius;\n" + "#endif\n" + "};\n" + "\n" + "void calculateLight(in PointLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "\n" + "    float dist = length(_light.position.xyz - _eyeToPoint);\n" + "\n" + "    // Compute vector from surface to light position\n" + "    vec3 VP = (_light.position.xyz - _eyeToPoint) / dist;\n" + "\n" + "    // Normalize the vector from surface to light position\n" + "    float nDotVP = clamp(dot(VP, _normal), 0.0, 1.0);\n" + "\n" + "    // Attenuation defaults\n" + "    float attenuation = 1.0;\n" + "    #ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "        float Rin = 1.0;\n" + "        float e = _light.attenuationExponent;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "            float Rdiff = _light.outerRadius-Rin;\n" + "            float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "            attenuation = 1.0-(pow(d,e));\n" + "        #else\n" + "            // If no outer is provide behaves like:\n" + "            // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "            float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "            attenuation = clamp(1.0/(pow(d,e)), 0.0, 1.0);\n" + "        #endif\n" + "    #else\n" + "        float Rin = 0.0;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float Rdiff = _light.outerRadius-Rin;\n" + "                float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                // If no outer is provide behaves like:\n" + "                // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "                float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "                attenuation = clamp(1.0/d, 0.0, 1.0);\n" + "            #endif\n" + "        #else\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float d = clamp(dist/_light.outerRadius, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                attenuation = 1.0;\n" + "            #endif\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // Acummulators compute\n" + "    #ifdef TANGRAM_MATERIAL_AMBIENT\n" + "        g_light_accumulator_ambient += _light.ambient * attenuation;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        g_light_accumulator_diffuse += _light.diffuse * nDotVP * attenuation;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        float pf = 0.0; // power factor for shiny speculars\n" + "        if (nDotVP > 0.0) {\n" + "            vec3 reflectVector = reflect(-VP, _normal);\n" + "            float eyeDotR = max(0.0, dot(-normalize(_eyeToPoint), reflectVector));\n" + "            pf = pow(eyeDotR, g_material.shininess);\n" + "        }\n" + "\n" + "        g_light_accumulator_specular += _light.specular * pf * attenuation;\n" + "    #endif\n" + "}\n" + "";
shaderSources['gl/shaders/selection_fragment'] = "// Fragment shader for feature selection passes\n" + "// Renders in silhouette according to selection (picking) color, or black if none defined\n" + "\n" + "#if defined(FEATURE_SELECTION)\n" + "    varying vec4 v_selection_color;\n" + "#endif\n" + "\n" + "void main (void) {\n" + "    #if defined(FEATURE_SELECTION)\n" + "        gl_FragColor = v_selection_color;\n" + "    #else\n" + "        gl_FragColor = vec4(0., 0., 0., 1.);\n" + "    #endif\n" + "}\n" + "";
shaderSources['gl/shaders/directionalLight'] = "struct DirectionalLight {\n" + "    vec4 ambient;\n" + "    vec4 diffuse;\n" + "    vec4 specular;\n" + "    vec3 direction;\n" + "};\n" + "\n" + "void calculateLight(in DirectionalLight _light, in vec3 _eyeToPoint, in vec3 _normal){\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_AMBIENT\n" + "        g_light_accumulator_ambient += _light.ambient;\n" + "    #endif\n" + "\n" + "    float nDotVP = clamp(dot(_normal, -normalize(_light.direction)), 0.0, 1.0);\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        g_light_accumulator_diffuse += _light.diffuse * nDotVP;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        float pf = 0.0;\n" + "        if (nDotVP > 0.0) {\n" + "            vec3 reflectVector = reflect(normalize(_light.direction), _normal);\n" + "            float eyeDotR = max(dot(normalize(_eyeToPoint), reflectVector), 0.0);\n" + "            pf = pow(eyeDotR, g_material.shininess);\n" + "        }\n" + "        g_light_accumulator_specular += _light.specular * pf;\n" + "    #endif\n" + "}\n" + "";
shaderSources['gl/shaders/reorder_layers'] = "// Re-orders depth so that higher numbered layers are \"force\"-drawn over lower ones\n" + "void reorderLayers (float layer, float num_layers, inout vec4 position) {\n" + "    float layer_order = ((layer + 1.) / (num_layers + 1.)) + 1.;\n" + "    position.z /= layer_order;\n" + "}\n" + "";
shaderSources['styles/points/points.vertex'] = "uniform mat4 u_modelView;\n" + "uniform float u_num_layers;\n" + "\n" + "attribute vec3 a_position;\n" + "attribute vec2 a_texcoord;\n" + "attribute vec4 a_color;\n" + "attribute float a_layer;\n" + "\n" + "varying vec4 v_color;\n" + "varying vec2 v_texcoord;\n" + "\n" + "#if defined(FEATURE_SELECTION)\n" + "    attribute vec4 a_selection_color;\n" + "    varying vec4 v_selection_color;\n" + "#endif\n" + "\n" + "#pragma tangram: globals\n" + "#pragma tangram: camera\n" + "\n" + "void main() {\n" + "    #if defined(FEATURE_SELECTION)\n" + "        if (a_selection_color.rgb == vec3(0.)) {\n" + "            // Discard by forcing invalid triangle if we\'re in the feature\n" + "            // selection pass but have no selection info\n" + "            // TODO: in some cases we may actually want non-selectable features to occlude selectable ones?\n" + "            gl_Position = vec4(0., 0., 0., 1.);\n" + "            return;\n" + "        }\n" + "        v_selection_color = a_selection_color;\n" + "    #endif\n" + "\n" + "    vec4 position = u_modelView * vec4(a_position, 1.);\n" + "\n" + "    // TODO: legacy, replace in existing styles\n" + "    // #pragma tangram: vertex\n" + "    #pragma tangram: position\n" + "\n" + "    v_color = a_color;\n" + "    v_texcoord = a_texcoord;\n" + "\n" + "    cameraProjection(position);\n" + "\n" + "    // Re-orders depth so that higher numbered layers are \"force\"-drawn over lower ones\n" + "    reorderLayers(a_layer, u_num_layers, position);\n" + "\n" + "    gl_Position = position;\n" + "}\n" + "";
shaderSources['styles/points/points.fragment'] = "uniform vec2 u_resolution;\n" + "\n" + "varying vec4 v_color;\n" + "varying vec2 v_texcoord;\n" + "\n" + "void main (void) {\n" + "    vec4 color = v_color;\n" + "    vec3 lighting = vec3(1.);\n" + "\n" + "    // Simple threshold at dot radius\n" + "    vec2 uv = v_texcoord * 2. - 1.;\n" + "    float len = length(uv);\n" + "    if (len > 1.) {\n" + "        discard;\n" + "    }\n" + "    color.rgb *= (1. - smoothstep(.25, 1., len)) + 0.5;\n" + "\n" + "    #pragma tangram: color\n" + "    #pragma tangram: filter\n" + "\n" + "    // TODO: legacy, replace in existing styles\n" + "    // #pragma tangram: fragment\n" + "\n" + "    gl_FragColor = color;\n" + "}\n" + "";
shaderSources['styles/sprites/sprites_fragment'] = "uniform vec2 u_resolution;\n" + "uniform vec2 u_aspect;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_time;\n" + "uniform float u_map_zoom;\n" + "uniform vec2 u_map_center;\n" + "uniform vec2 u_tile_origin;\n" + "\n" + "varying vec2 v_texcoord;\n" + "\n" + "// built-in uniforms for texture maps\n" + "#if defined(NUM_TEXTURES)\n" + "    uniform sampler2D u_textures[NUM_TEXTURES];\n" + "#else\n" + "    uniform sampler2D u_textures[1];\n" + "#endif\n" + "\n" + "#pragma tangram: globals\n" + "\n" + "void main (void) {\n" + "    vec4 color = texture2D(u_textures[0], v_texcoord);\n" + "\n" + "    #pragma tangram: color\n" + "    #pragma tangram: filter\n" + "\n" + "    // TODO: legacy, replace in existing styles\n" + "    // #pragma tangram: fragment\n" + "\n" + "    gl_FragColor = color;\n" + "}\n" + "";
shaderSources['styles/sprites/sprites_vertex'] = "uniform vec2 u_resolution;\n" + "uniform vec2 u_aspect;\n" + "uniform float u_time;\n" + "uniform float u_map_zoom;\n" + "uniform vec2 u_map_center;\n" + "uniform vec2 u_tile_origin;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_order_min;\n" + "uniform float u_order_range;\n" + "\n" + "uniform mat4 u_model;\n" + "uniform mat4 u_modelView;\n" + "\n" + "attribute vec3 a_position;\n" + "attribute vec4 a_shape;\n" + "attribute vec2 a_texcoord;\n" + "attribute float a_layer;\n" + "\n" + "varying vec2 v_texcoord;\n" + "\n" + "#if defined(FEATURE_SELECTION)\n" + "    attribute vec4 a_selection_color;\n" + "    varying vec4 v_selection_color;\n" + "#endif\n" + "\n" + "#pragma tangram: globals\n" + "#pragma tangram: camera\n" + "\n" + "vec2 rotate2D(vec2 _st, float _angle) {\n" + "    return mat2(cos(_angle),-sin(_angle),\n" + "                sin(_angle),cos(_angle)) * _st;\n" + "}\n" + "\n" + "void main() {\n" + "    // Selection pass-specific rendering\n" + "    #if defined(FEATURE_SELECTION)\n" + "        if (a_selection_color.rgb == vec3(0.)) {\n" + "            // Discard by forcing invalid triangle if we\'re in the feature\n" + "            // selection pass but have no selection info\n" + "            // TODO: in some cases we may actually want non-selectable features to occlude selectable ones?\n" + "            gl_Position = vec4(0., 0., 0., 1.);\n" + "            return;\n" + "        }\n" + "        v_selection_color = a_selection_color;\n" + "    #endif\n" + "\n" + "    v_texcoord = a_texcoord;\n" + "\n" + "    // Position\n" + "    vec4 position = u_modelView * vec4(a_position, 1.);\n" + "    vec4 shape = a_shape;\n" + "\n" + "    // TODO: legacy, replace in existing styles\n" + "    // #pragma tangram: vertex\n" + "    #pragma tangram: position\n" + "\n" + "    cameraProjection(position);\n" + "\n" + "    // Apply scaling in screen space\n" + "    float zscale = fract(u_map_zoom) * (shape.w * 256. - 1.) + 1.;\n" + "    // float zscale = log(fract(u_map_zoom) + 1.) / log(2.) * (shape.w - 1.) + 1.;\n" + "    position.xy += rotate2D(shape.xy * 128. * zscale, radians(shape.z * 360.)) * 2. * position.w / u_resolution;\n" + "\n" + "    // Re-orders depth so that higher numbered layers are \"force\"-drawn over lower ones\n" + "    // reorderLayers(a_layer + u_order_min, u_order_range, position);\n" + "\n" + "    gl_Position = position;\n" + "}\n" + "";
shaderSources['styles/polygons/polygons.fragment'] = "uniform vec2 u_resolution;\n" + "uniform vec2 u_aspect;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_time;\n" + "uniform float u_map_zoom;\n" + "uniform vec2 u_map_center;\n" + "uniform vec2 u_tile_origin;\n" + "\n" + "varying vec4 v_position;\n" + "varying vec3 v_normal;\n" + "varying vec4 v_color;\n" + "varying vec4 v_world_position;\n" + "\n" + "// built-in uniforms for texture maps\n" + "#if defined(NUM_TEXTURES)\n" + "    uniform sampler2D u_textures[NUM_TEXTURES];\n" + "#endif\n" + "\n" + "#if defined(TEXTURE_COORDS)\n" + "    varying vec2 v_texcoord;\n" + "#endif\n" + "\n" + "// Define a wrap value for world coordinates (allows more precision at higher zooms)\n" + "// e.g. at wrap 1000, the world space will wrap every 1000 meters\n" + "#if defined(WORLD_POSITION_WRAP)\n" + "    vec2 world_position_anchor = vec2(floor(u_tile_origin / WORLD_POSITION_WRAP) * WORLD_POSITION_WRAP);\n" + "\n" + "    // Convert back to absolute world position if needed\n" + "    vec4 absoluteWorldPosition () {\n" + "        return vec4(v_world_position.xy + world_position_anchor, v_world_position.z, v_world_position.w);\n" + "    }\n" + "#else\n" + "    vec4 absoluteWorldPosition () {\n" + "        return v_world_position;\n" + "    }\n" + "#endif\n" + "\n" + "#if defined(LIGHTING_ENVIRONMENT)\n" + "    uniform sampler2D u_env_map;\n" + "#endif\n" + "\n" + "#if defined(TANGRAM_LIGHTING_VERTEX)\n" + "    varying vec4 v_lighting;\n" + "#endif\n" + "\n" + "#pragma tangram: globals\n" + "#pragma tangram: camera\n" + "#pragma tangram: material\n" + "#pragma tangram: lighting\n" + "\n" + "void main (void) {\n" + "    vec4 color;\n" + "\n" + "    // Modify normal before lighting\n" + "    #pragma tangram: normal\n" + "\n" + "    #if defined(TEXTURE_COORDS) && defined(HAS_DEFAULT_TEXTURE)\n" + "        color = texture2D(texture_default, v_texcoord);\n" + "    #else\n" + "        color = v_color;\n" + "    #endif\n" + "\n" + "    #if defined(LIGHTING_ENVIRONMENT)\n" + "        // Replace object color with environment map\n" + "        color.rgb = sphericalEnvironmentMap(u_eye, v_position.xyz, v_normal, u_vanishing_point, u_env_map).rgb;\n" + "    #endif\n" + "\n" + "    // Modify color and material properties before lighting\n" + "    #if !defined(TANGRAM_LIGHTING_VERTEX)\n" + "    #pragma tangram: color\n" + "    #endif\n" + "\n" + "    #if defined(TANGRAM_LIGHTING_FRAGMENT)\n" + "        color = calculateLighting(v_position.xyz - u_eye, v_normal, color);\n" + "    #elif defined(TANGRAM_LIGHTING_VERTEX)\n" + "        color = v_lighting;\n" + "    #endif\n" + "\n" + "    // Modify color after lighting (filter-like effects that don\'t require a additional render passes)\n" + "    #pragma tangram: filter\n" + "\n" + "    // TODO: legacy, replace in existing styles\n" + "    // #pragma tangram: fragment\n" + "\n" + "    gl_FragColor = color;\n" + "}\n" + "";
shaderSources['styles/polygons/polygons.vertex'] = "uniform vec2 u_resolution;\n" + "uniform vec2 u_aspect;\n" + "uniform float u_time;\n" + "uniform float u_map_zoom;\n" + "uniform vec2 u_map_center;\n" + "uniform vec2 u_tile_origin;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_order_min;\n" + "uniform float u_order_range;\n" + "\n" + "uniform mat4 u_model;\n" + "uniform mat4 u_modelView;\n" + "uniform mat3 u_normalMatrix;\n" + "\n" + "attribute vec3 a_position;\n" + "attribute vec3 a_normal;\n" + "attribute vec4 a_color;\n" + "attribute float a_layer;\n" + "\n" + "varying vec4 v_position;\n" + "varying vec3 v_normal;\n" + "varying vec4 v_color;\n" + "varying vec4 v_world_position;\n" + "\n" + "// Optional texture UVs\n" + "#if defined(TEXTURE_COORDS)\n" + "    attribute vec2 a_texcoord;\n" + "    varying vec2 v_texcoord;\n" + "#endif\n" + "\n" + "// Define a wrap value for world coordinates (allows more precision at higher zooms)\n" + "// e.g. at wrap 1000, the world space will wrap every 1000 meters\n" + "#if defined(WORLD_POSITION_WRAP)\n" + "    vec2 world_position_anchor = vec2(floor(u_tile_origin / WORLD_POSITION_WRAP) * WORLD_POSITION_WRAP);\n" + "\n" + "    // Convert back to absolute world position if needed\n" + "    vec4 absoluteWorldPosition () {\n" + "        return vec4(v_world_position.xy + world_position_anchor, v_world_position.z, v_world_position.w);\n" + "    }\n" + "#else\n" + "    vec4 absoluteWorldPosition () {\n" + "        return v_world_position;\n" + "    }\n" + "#endif\n" + "\n" + "#if defined(FEATURE_SELECTION)\n" + "    attribute vec4 a_selection_color;\n" + "    varying vec4 v_selection_color;\n" + "#endif\n" + "\n" + "#if defined(TANGRAM_LIGHTING_VERTEX)\n" + "    varying vec4 v_lighting;\n" + "#endif\n" + "\n" + "#pragma tangram: globals\n" + "#pragma tangram: camera\n" + "#pragma tangram: material\n" + "#pragma tangram: lighting\n" + "\n" + "void main() {\n" + "    // Selection pass-specific rendering\n" + "    #if defined(FEATURE_SELECTION)\n" + "        if (a_selection_color.rgb == vec3(0.)) {\n" + "            // Discard by forcing invalid triangle if we\'re in the feature\n" + "            // selection pass but have no selection info\n" + "            // TODO: in some cases we may actually want non-selectable features to occlude selectable ones?\n" + "            gl_Position = vec4(0., 0., 0., 1.);\n" + "            return;\n" + "        }\n" + "        v_selection_color = a_selection_color;\n" + "    #endif\n" + "\n" + "    // Texture UVs\n" + "    #if defined(TEXTURE_COORDS)\n" + "        v_texcoord = a_texcoord;\n" + "    #endif\n" + "\n" + "    // World coordinates for 3d procedural textures\n" + "    v_world_position = u_model * vec4(a_position, 1.);\n" + "    #if defined(WORLD_POSITION_WRAP)\n" + "        v_world_position.xy -= world_position_anchor;\n" + "    #endif\n" + "\n" + "    // Position\n" + "    vec4 position = u_modelView * vec4(a_position, 1.);\n" + "\n" + "    // TODO: legacy, replace in existing styles\n" + "    // #pragma tangram: vertex\n" + "    #pragma tangram: position\n" + "\n" + "    v_position = position;\n" + "    v_normal = normalize(u_normalMatrix * a_normal);\n" + "    v_color = a_color;\n" + "\n" + "    // Shading\n" + "    #if defined(TANGRAM_LIGHTING_VERTEX)\n" + "        vec4 color = a_color;\n" + "        vec3 normal = a_normal;\n" + "\n" + "        // Modify normal before lighting\n" + "        #pragma tangram: normal\n" + "\n" + "        // Modify color and material properties before lighting\n" + "        #pragma tangram: color\n" + "\n" + "        v_lighting = calculateLighting(position.xyz, normal, color);\n" + "        v_color = color;\n" + "    #endif\n" + "\n" + "    // Camera\n" + "    cameraProjection(position);\n" + "\n" + "    // Re-orders depth so that higher numbered layers are \"force\"-drawn over lower ones\n" + "    reorderLayers(a_layer + u_order_min, u_order_range, position);\n" + "\n" + "    gl_Position = position;\n" + "}\n" + "";
module.exports = shaderSources;


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/gl/shader_sources.js
},{}],73:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  __esModule: {value: true}
});
var $___46__46__47_utils_47_utils__,
    $___46__46__47_utils_47_subscribe__,
    $___46__46__47_utils_47_worker_95_broker__,
    $__loglevel__;
var Utils = ($___46__46__47_utils_47_utils__ = require("../utils/utils"), $___46__46__47_utils_47_utils__ && $___46__46__47_utils_47_utils__.__esModule && $___46__46__47_utils_47_utils__ || {default: $___46__46__47_utils_47_utils__}).default;
var subscribeMixin = ($___46__46__47_utils_47_subscribe__ = require("../utils/subscribe"), $___46__46__47_utils_47_subscribe__ && $___46__46__47_utils_47_subscribe__.__esModule && $___46__46__47_utils_47_subscribe__ || {default: $___46__46__47_utils_47_subscribe__}).default;
var WorkerBroker = ($___46__46__47_utils_47_worker_95_broker__ = require("../utils/worker_broker"), $___46__46__47_utils_47_worker_95_broker__ && $___46__46__47_utils_47_worker_95_broker__.__esModule && $___46__46__47_utils_47_worker_95_broker__ || {default: $___46__46__47_utils_47_worker_95_broker__}).default;
var log = ($__loglevel__ = require("loglevel"), $__loglevel__ && $__loglevel__.__esModule && $__loglevel__ || {default: $__loglevel__}).default;
Texture.textures = {};
subscribeMixin(Texture);
function Texture(gl, name) {
  var options = arguments[2] !== (void 0) ? arguments[2] : {};
  this.gl = gl;
  this.texture = gl.createTexture();
  if (this.texture) {
    this.valid = true;
  }
  this.bind();
  this.image = null;
  this.canvas = null;
  this.loading = null;
  this.setData(1, 1, new Uint8Array([0, 0, 0, 255]), {filtering: 'nearest'});
  this.name = name;
  this.filtering = options.filtering;
  if (Texture.textures[this.name]) {
    Texture.textures[this.name].destroy();
  }
  Texture.textures[this.name] = this;
  this.sprites = options.sprites;
}
var $__default = Texture;
Texture.prototype.destroy = function() {
  if (!this.valid) {
    return;
  }
  this.gl.deleteTexture(this.texture);
  this.texture = null;
  delete this.data;
  this.data = null;
  delete Texture.textures[this.name];
  this.valid = false;
};
Texture.destroy = function(gl) {
  var textures = Object.keys(Texture.textures);
  for (var $__5 = textures[$traceurRuntime.toProperty(Symbol.iterator)](),
      $__6; !($__6 = $__5.next()).done; ) {
    var t = $__6.value;
    {
      var texture = Texture.textures[t];
      if (texture.gl === gl) {
        log.trace(("destroying Texture " + texture.name));
        texture.destroy();
      }
    }
  }
};
Texture.prototype.bind = function(unit) {
  if (!this.valid) {
    return;
  }
  if (unit) {
    this.gl.activeTexture(this.gl.TEXTURE0 + unit);
  }
  this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
};
Texture.prototype.unbind = function() {
  this.gl.bindTexture(this.gl.TEXTURE_2D, null);
};
Texture.prototype.load = function(url) {
  var options = arguments[1] !== (void 0) ? arguments[1] : {};
  var $__4 = this;
  if (!this.valid) {
    return;
  }
  this.loading = new Promise((function(resolve, reject) {
    $__4.image = new Image();
    $__4.image.onload = (function() {
      $__4.update(options);
      $__4.setTextureFiltering(options);
      $__4.canvas = null;
      $__4.data = null;
      resolve($__4);
    });
    $__4.image.src = url;
  }));
  return this.loading;
};
Texture.prototype.setData = function(width, height, data) {
  var options = arguments[3] !== (void 0) ? arguments[3] : {};
  this.width = width;
  this.height = height;
  this.data = data;
  this.image = null;
  this.canvas = null;
  this.update(options);
  this.setTextureFiltering(options);
};
Texture.prototype.setCanvas = function(canvas, options) {
  this.canvas = canvas;
  this.update(options);
  this.setTextureFiltering(options);
  this.image = null;
  this.data = null;
};
Texture.prototype.update = function() {
  var options = arguments[0] !== (void 0) ? arguments[0] : {};
  if (!this.valid) {
    return;
  }
  this.bind();
  this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, (options.UNPACK_FLIP_Y_WEBGL === false ? false : true));
  this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.UNPACK_PREMULTIPLY_ALPHA_WEBGL || false);
  if (this.image && this.image.complete) {
    this.width = this.image.width;
    this.height = this.image.height;
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.image);
  } else if (this.canvas) {
    this.width = this.canvas.width;
    this.height = this.canvas.height;
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.canvas);
  } else if (this.width && this.height) {
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.width, this.height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.data);
  }
  Texture.trigger('update', this);
};
Texture.prototype.setTextureFiltering = function() {
  var options = arguments[0] !== (void 0) ? arguments[0] : {};
  if (!this.valid) {
    return;
  }
  options.filtering = options.filtering || this.filtering || 'mipmap';
  var gl = this.gl;
  this.bind();
  if (Utils.isPowerOf2(this.width) && Utils.isPowerOf2(this.height)) {
    this.power_of_2 = true;
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.TEXTURE_WRAP_S || (options.repeat && gl.REPEAT) || gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.TEXTURE_WRAP_T || (options.repeat && gl.REPEAT) || gl.CLAMP_TO_EDGE);
    if (options.filtering === 'mipmap') {
      log.trace('power-of-2 MIPMAP');
      this.filtering = 'mipmap';
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.generateMipmap(gl.TEXTURE_2D);
    } else if (options.filtering === 'linear') {
      log.trace('power-of-2 LINEAR');
      this.filtering = 'linear';
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    } else if (options.filtering === 'nearest') {
      log.trace('power-of-2 NEAREST');
      this.filtering = 'nearest';
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    }
  } else {
    this.power_of_2 = false;
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    if (options.filtering === 'nearest') {
      log.trace('power-of-2 NEAREST');
      this.filtering = 'nearest';
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    } else {
      log.trace('power-of-2 LINEAR');
      this.filtering = 'linear';
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    }
  }
  this.unbind();
  Texture.trigger('update', this);
};
Texture.getInfo = function(name) {
  if (!name) {
    name = Object.keys(Texture.textures);
  }
  if (Array.isArray(name)) {
    return Promise.all(name.map((function(n) {
      return Texture.getInfo(n);
    })));
  }
  var tex = Texture.textures[name];
  if (tex) {
    var loading = tex.loading || Promise.resolve(tex);
    return loading.then((function() {
      return {
        name: tex.name,
        width: tex.width,
        height: tex.height,
        sprites: tex.sprites,
        filtering: tex.filtering,
        power_of_2: tex.power_of_2,
        valid: tex.valid
      };
    }));
  } else {
    return Promise.resolve(null);
  }
};
Texture.syncTexturesToWorker = function(names) {
  return WorkerBroker.postMessage('Texture', 'getInfo', names).then((function(textures) {
    for (var $__5 = textures[$traceurRuntime.toProperty(Symbol.iterator)](),
        $__6; !($__6 = $__5.next()).done; ) {
      var tex = $__6.value;
      {
        Texture.textures[tex.name] = tex;
      }
    }
    return Texture.textures;
  }));
};


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/gl/texture.js
},{"../utils/subscribe":97,"../utils/utils":98,"../utils/worker_broker":99,"loglevel":53}],74:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  __esModule: {value: true}
});
var $__glsl__,
    $__shader_95_program__,
    $__texture__,
    $__loglevel__;
var GLSL = ($__glsl__ = require("./glsl"), $__glsl__ && $__glsl__.__esModule && $__glsl__ || {default: $__glsl__}).default;
var ShaderProgram = ($__shader_95_program__ = require("./shader_program"), $__shader_95_program__ && $__shader_95_program__.__esModule && $__shader_95_program__ || {default: $__shader_95_program__}).default;
var Texture = ($__texture__ = require("./texture"), $__texture__ && $__texture__.__esModule && $__texture__ || {default: $__texture__}).default;
var log = ($__loglevel__ = require("loglevel"), $__loglevel__ && $__loglevel__.__esModule && $__loglevel__ || {default: $__loglevel__}).default;
function VBOMesh(gl, vertex_data, vertex_layout, options) {
  options = options || {};
  this.gl = gl;
  this.vertex_data = vertex_data;
  this.vertex_layout = vertex_layout;
  this.buffer = this.gl.createBuffer();
  this.draw_mode = options.draw_mode || this.gl.TRIANGLES;
  this.data_usage = options.data_usage || this.gl.STATIC_DRAW;
  this.vertices_per_geometry = 3;
  this.uniforms = options.uniforms;
  this.vertex_count = this.vertex_data.byteLength / this.vertex_layout.stride;
  this.geometry_count = this.vertex_count / this.vertices_per_geometry;
  this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
  this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vertex_data, this.data_usage);
  this.valid = true;
}
var $__default = VBOMesh;
VBOMesh.prototype.render = function() {
  var options = arguments[0] !== (void 0) ? arguments[0] : {};
  if (!this.valid) {
    return false;
  }
  if (typeof this._render_setup === 'function') {
    this._render_setup();
  }
  var program = options.program || ShaderProgram.current;
  program.use();
  if (this.uniforms) {
    program.saveUniforms(this.uniforms);
    program.setUniforms(this.uniforms, false);
  }
  this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
  this.vertex_layout.enable(this.gl, program);
  this.gl.drawArrays(this.draw_mode, 0, this.vertex_count);
  if (this.uniforms) {
    program.restoreUniforms(this.uniforms);
  }
  return true;
};
VBOMesh.prototype.destroy = function() {
  if (!this.valid) {
    return false;
  }
  this.valid = false;
  log.trace('VBOMesh.destroy: delete buffer of size ' + this.vertex_data.byteLength);
  this.gl.deleteBuffer(this.buffer);
  this.buffer = null;
  delete this.vertex_data;
  for (var $__4 = GLSL.parseUniforms(this.uniforms)[$traceurRuntime.toProperty(Symbol.iterator)](),
      $__5; !($__5 = $__4.next()).done; ) {
    var $__6 = $__5.value,
        type = $__6.type,
        value = $__6.value;
    {
      if (type === 'sampler2D' && Texture.textures[value]) {
        Texture.textures[value].destroy();
      }
    }
  }
  return true;
};


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/gl/vbo_mesh.js
},{"./glsl":70,"./shader_program":71,"./texture":73,"loglevel":53}],75:[function(require,module,exports){
"use strict";
var $__3;
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  __esModule: {value: true}
});
var $__constants__,
    $__loglevel__;
var gl = ($__constants__ = require("./constants"), $__constants__ && $__constants__.__esModule && $__constants__ || {default: $__constants__}).default;
var log = ($__loglevel__ = require("loglevel"), $__loglevel__ && $__loglevel__.__esModule && $__loglevel__ || {default: $__loglevel__}).default;
var VertexData = function VertexData(vertex_layout) {
  this.vertex_layout = vertex_layout;
  this.block_size = 50000;
  this.block_num = 1;
  this.buffer_offset = 0;
  this.buffer = new ArrayBuffer(this.vertex_layout.stride * this.block_size * this.block_num);
  this.components = [];
  for (var $__4 = this.vertex_layout.components[$traceurRuntime.toProperty(Symbol.iterator)](),
      $__5; !($__5 = $__4.next()).done; ) {
    var component = $__5.value;
    {
      this.components.push($traceurRuntime.spread(component));
    }
  }
  this.vertex_count = 0;
  this.setBufferViews();
};
($traceurRuntime.createClass)(VertexData, {
  setBufferViews: function() {
    this.buffer_views = {};
    for (var $__4 = this.vertex_layout.attribs[$traceurRuntime.toProperty(Symbol.iterator)](),
        $__5; !($__5 = $__4.next()).done; ) {
      var attrib = $__5.value;
      {
        if (this.buffer_views[attrib.type] == null) {
          var array_type = this.array_types[attrib.type];
          this.buffer_views[attrib.type] = new array_type(this.buffer);
        }
      }
    }
    for (var $__6 = this.components[$traceurRuntime.toProperty(Symbol.iterator)](),
        $__7; !($__7 = $__6.next()).done; ) {
      var component = $__7.value;
      {
        component[1] = this.buffer_views[component[0]];
      }
    }
  },
  checkBufferSize: function() {
    if ((this.buffer_offset + this.vertex_layout.stride) > this.buffer.byteLength) {
      this.block_num++;
      var new_block = new ArrayBuffer(this.vertex_layout.stride * this.block_size * this.block_num);
      var new_view = new Uint8Array(new_block);
      new_view.set(new Uint8Array(this.buffer));
      this.buffer = new_block;
      this.setBufferViews();
      log.info(("VertexData: expanded vertex block to " + this.block_size * this.block_num + " vertices"));
    }
  },
  addVertex: function(vertex) {
    this.checkBufferSize();
    var i = 0;
    var clen = this.components.length;
    for (var c = 0; c < clen; c++) {
      var component = this.components[c];
      component[1][(this.buffer_offset >> component[2]) + component[3]] = vertex[i++];
    }
    this.buffer_offset += this.vertex_layout.stride;
    this.vertex_count++;
  },
  end: function() {
    if (this.buffer_offset < this.buffer.byteLength) {
      var new_block = new ArrayBuffer(this.buffer_offset);
      var new_view = new Uint8Array(new_block);
      new_view.set(new Uint8Array(this.buffer, 0, this.buffer_offset));
      this.buffer = new_block;
      this.buffer_views = null;
      this.components = null;
    }
    return this;
  }
}, {});
var $__default = VertexData;
VertexData.prototype.array_types = ($__3 = {}, Object.defineProperty($__3, gl.FLOAT, {
  value: Float32Array,
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__3, gl.BYTE, {
  value: Int8Array,
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__3, gl.UNSIGNED_BYTE, {
  value: Uint8Array,
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__3, gl.INT, {
  value: Int32Array,
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__3, gl.UNSIGNED_INT, {
  value: Uint32Array,
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__3, gl.SHORT, {
  value: Int16Array,
  configurable: true,
  enumerable: true,
  writable: true
}), Object.defineProperty($__3, gl.UNSIGNED_SHORT, {
  value: Uint16Array,
  configurable: true,
  enumerable: true,
  writable: true
}), $__3);


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/gl/vertex_data.js
},{"./constants":68,"loglevel":53}],76:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  __esModule: {value: true}
});
var $__constants__,
    $__vertex_95_data__;
var gl = ($__constants__ = require("./constants"), $__constants__ && $__constants__.__esModule && $__constants__ || {default: $__constants__}).default;
var VertexData = ($__vertex_95_data__ = require("./vertex_data"), $__vertex_95_data__ && $__vertex_95_data__.__esModule && $__vertex_95_data__ || {default: $__vertex_95_data__}).default;
var VertexLayout = function VertexLayout(attribs) {
  this.attribs = attribs;
  this.components = [];
  this.index = {};
  this.stride = 0;
  var count = 0;
  for (var $__3 = this.attribs[$traceurRuntime.toProperty(Symbol.iterator)](),
      $__4; !($__4 = $__3.next()).done; ) {
    var attrib = $__4.value;
    {
      attrib.offset = this.stride;
      attrib.byte_size = attrib.size;
      var shift = 0;
      switch (attrib.type) {
        case gl.FLOAT:
        case gl.INT:
        case gl.UNSIGNED_INT:
          attrib.byte_size *= 4;
          shift = 2;
          break;
        case gl.SHORT:
        case gl.UNSIGNED_SHORT:
          attrib.byte_size *= 2;
          shift = 1;
          break;
      }
      this.stride += attrib.byte_size;
      if (this.stride & 3) {
        this.stride += 4 - (this.stride & 3);
      }
      var offset_typed = attrib.offset >> shift;
      if (attrib.size > 1) {
        for (var a = 0; a < attrib.size; a++) {
          this.components.push([attrib.type, null, shift, offset_typed++]);
        }
      } else {
        this.components.push([attrib.type, null, shift, offset_typed]);
      }
      this.index[attrib.name] = count;
      count += attrib.size;
    }
  }
};
var $VertexLayout = VertexLayout;
($traceurRuntime.createClass)(VertexLayout, {
  enable: function(gl, program) {
    var attrib,
        location;
    for (var a = 0; a < this.attribs.length; a++) {
      attrib = this.attribs[a];
      location = program.attribute(attrib.name).location;
      if (location !== -1) {
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(location, attrib.size, attrib.type, attrib.normalized, this.stride, attrib.offset);
        $VertexLayout.enabled_attribs[location] = program;
      }
    }
    for (location in $VertexLayout.enabled_attribs) {
      this.disableUnusedAttribute(gl, location, program);
    }
  },
  disableUnusedAttribute: function(gl, location, program) {
    if ($VertexLayout.enabled_attribs[location] !== program) {
      gl.disableVertexAttribArray(location);
      delete $VertexLayout.enabled_attribs[location];
    }
  },
  createVertexData: function() {
    return new VertexData(this);
  }
}, {});
var $__default = VertexLayout;
VertexLayout.enabled_attribs = {};


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/gl/vertex_layout.js
},{"./constants":68,"./vertex_data":75}],77:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  LeafletLayer: {get: function() {
      return LeafletLayer;
    }},
  leafletLayer: {get: function() {
      return leafletLayer;
    }},
  __esModule: {value: true}
});
var $__utils_47_utils__,
    $__scene__,
    $__loglevel__;
var Utils = ($__utils_47_utils__ = require("./utils/utils"), $__utils_47_utils__ && $__utils_47_utils__.__esModule && $__utils_47_utils__ || {default: $__utils_47_utils__}).default;
var Scene = ($__scene__ = require("./scene"), $__scene__ && $__scene__.__esModule && $__scene__ || {default: $__scene__}).default;
var log = ($__loglevel__ = require("loglevel"), $__loglevel__ && $__loglevel__.__esModule && $__loglevel__ || {default: $__loglevel__}).default;
var LeafletLayer;
function leafletLayer(options) {
  return new LeafletLayer(options);
}
if (Utils.isMainThread) {
  LeafletLayer = L.GridLayer.extend({
    initialize: function(options) {
      options.showDebug = (!options.showDebug ? false : true);
      L.setOptions(this, options);
      this.createScene();
      this.hooks = {};
      this._updating_tangram = false;
      this._zoomAnimated = false;
    },
    createScene: function() {
      this.scene = Scene.create(this.options.scene, {
        numWorkers: this.options.numWorkers,
        preUpdate: this.options.preUpdate,
        postUpdate: this.options.postUpdate,
        logLevel: this.options.logLevel,
        disableRenderLoop: this.options.disableRenderLoop,
        allowCrossDomainWorkers: this.options.allowCrossDomainWorkers
      });
    },
    onAdd: function() {
      var $__3 = this;
      if (!this.scene) {
        this.createScene();
      }
      L.GridLayer.prototype.onAdd.apply(this, arguments);
      this.hooks.resize = (function() {
        $__3._updating_tangram = true;
        var size = $__3._map.getSize();
        $__3.scene.resizeMap(size.x, size.y);
        $__3._updating_tangram = false;
      });
      this._map.on('resize', this.hooks.resize);
      this.hooks.move = (function() {
        if ($__3._updating_tangram) {
          return;
        }
        $__3._updating_tangram = true;
        var view = $__3._map.getCenter();
        view.zoom = $__3._map.getZoom();
        var changed = $__3.scene.setView(view);
        if (changed) {
          $__3.scene.immediateRedraw();
        }
        $__3._updating_tangram = false;
      });
      this._map.on('move', this.hooks.move);
      this.hooks.zoomstart = (function() {
        if ($__3._updating_tangram) {
          return;
        }
        $__3._updating_tangram = true;
        $__3.scene.startZoom();
        $__3._updating_tangram = false;
      });
      this._map.on('zoomstart', this.hooks.zoomstart);
      this.hooks.dragstart = (function() {
        $__3.scene.panning = true;
      });
      this._map.on('dragstart', this.hooks.dragstart);
      this.hooks.dragend = (function() {
        $__3.scene.panning = false;
      });
      this._map.on('dragend', this.hooks.dragend);
      this._map._zoomAnimated = false;
      this.scene.container = this._map.getContainer();
      var view = this._map.getCenter();
      view.zoom = this._map.getZoom();
      this.scene.setView(view);
      this.scene.subscribe({move: this.onTangramViewUpdate.bind(this)});
      this.scene.init().then((function() {
        log.debug('Scene.init() succeeded');
        $__3.fire('init');
      }), (function(error) {
        log.error('Scene.init() failed with error:', error);
        throw error;
      }));
    },
    onRemove: function() {
      L.GridLayer.prototype.onRemove.apply(this, arguments);
      this._map.off('resize', this.hooks.resize);
      this._map.off('move', this.hooks.move);
      this._map.off('zoomstart', this.hooks.zoomstart);
      this._map.off('dragstart', this.hooks.dragstart);
      this._map.off('dragend', this.hooks.dragend);
      this.hooks = {};
      if (this.scene) {
        this.scene.destroy();
        this.scene = null;
      }
    },
    createTile: function(coords) {
      var key = coords.x + '/' + coords.y + '/' + coords.z;
      var div = document.createElement('div');
      div.setAttribute('data-tile-key', key);
      div.style.width = '256px';
      div.style.height = '256px';
      if (this.options.showDebug) {
        var debug_overlay = document.createElement('div');
        debug_overlay.textContent = key;
        debug_overlay.style.position = 'absolute';
        debug_overlay.style.left = 0;
        debug_overlay.style.top = 0;
        debug_overlay.style.color = 'white';
        debug_overlay.style.fontSize = '16px';
        debug_overlay.style.textOutline = '1px #000000';
        debug_overlay.style.padding = '8px';
        div.appendChild(debug_overlay);
        div.style.borderStyle = 'solid';
        div.style.borderColor = 'white';
        div.style.borderWidth = '1px';
      }
      return div;
    },
    onTangramViewUpdate: function() {
      if (!this._map || this._updating_tangram) {
        return;
      }
      this._updating_tangram = true;
      this._map.setView([this.scene.center.lat, this.scene.center.lng], this.scene.zoom, {animate: false});
      this._updating_tangram = false;
    },
    render: function() {
      if (!this.scene) {
        return;
      }
      this.scene.update();
    }
  });
}


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/leaflet_layer.js
},{"./scene":81,"./utils/utils":98,"loglevel":53}],78:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  __esModule: {value: true}
});
var $__gl_47_shader_95_program__,
    $__gl_47_shader_95_sources__,
    $__gl_47_glsl__,
    $__geo__,
    $__styles_47_style_95_parser__;
var ShaderProgram = ($__gl_47_shader_95_program__ = require("./gl/shader_program"), $__gl_47_shader_95_program__ && $__gl_47_shader_95_program__.__esModule && $__gl_47_shader_95_program__ || {default: $__gl_47_shader_95_program__}).default;
var shaderSources = ($__gl_47_shader_95_sources__ = require("./gl/shader_sources"), $__gl_47_shader_95_sources__ && $__gl_47_shader_95_sources__.__esModule && $__gl_47_shader_95_sources__ || {default: $__gl_47_shader_95_sources__}).default;
var GLSL = ($__gl_47_glsl__ = require("./gl/glsl"), $__gl_47_glsl__ && $__gl_47_glsl__.__esModule && $__gl_47_glsl__ || {default: $__gl_47_glsl__}).default;
var Geo = ($__geo__ = require("./geo"), $__geo__ && $__geo__.__esModule && $__geo__ || {default: $__geo__}).default;
var StyleParser = ($__styles_47_style_95_parser__ = require("./styles/style_parser"), $__styles_47_style_95_parser__ && $__styles_47_style_95_parser__.__esModule && $__styles_47_style_95_parser__ || {default: $__styles_47_style_95_parser__}).StyleParser;
var Light = function Light(scene, config) {
  this.name = config.name;
  this.scene = scene;
  if (config.ambient == null || typeof config.ambient === 'number') {
    this.ambient = GLSL.expandVec4(config.ambient || 0);
  } else {
    this.ambient = StyleParser.parseColor(config.ambient);
  }
  if (config.diffuse == null || typeof config.diffuse === 'number') {
    this.diffuse = GLSL.expandVec4(config.diffuse != null ? config.diffuse : 1);
  } else {
    this.diffuse = StyleParser.parseColor(config.diffuse);
  }
  if (config.specular == null || typeof config.specular === 'number') {
    this.specular = GLSL.expandVec4(config.specular || 0);
  } else {
    this.specular = StyleParser.parseColor(config.specular);
  }
};
var $Light = Light;
($traceurRuntime.createClass)(Light, {
  inject: function() {
    var instance = ("\n            uniform " + this.struct_name + " u_" + this.name + ";\n            " + this.struct_name + " g_" + this.name + " = u_" + this.name + ";\n");
    ShaderProgram.addTransform($Light.transform, instance);
  },
  update: function() {},
  setupProgram: function(_program) {
    _program.uniform('4fv', ("u_" + this.name + ".ambient"), this.ambient);
    _program.uniform('4fv', ("u_" + this.name + ".diffuse"), this.diffuse);
    _program.uniform('4fv', ("u_" + this.name + ".specular"), this.specular);
  }
}, {
  create: function(scene, config) {
    if ($Light.types[config.type]) {
      return new $Light.types[config.type](scene, config);
    }
  },
  setMode: function(mode, style) {
    mode = $Light.enabled && ((mode != null) ? mode : 'fragment');
    style.defines['TANGRAM_LIGHTING_FRAGMENT'] = (mode === 'fragment');
    style.defines['TANGRAM_LIGHTING_VERTEX'] = (mode === 'vertex');
  },
  inject: function(lights) {
    ShaderProgram.removeTransform($Light.transform);
    if (!$Light.enabled) {
      return;
    }
    var calculateLights = "";
    if (lights && Object.keys(lights).length > 0) {
      var types = {};
      for (var light_name in lights) {
        types[lights[light_name].type] = true;
      }
      for (var type in types) {
        $Light.types[type].inject();
      }
      for (var light_name$__7 in lights) {
        lights[light_name$__7].inject();
        calculateLights += ("calculateLight(g_" + light_name$__7 + ", _eyeToPoint, _normal);\n");
      }
    } else {
      calculateLights = "\n                #ifdef TANGRAM_MATERIAL_DIFFUSE\n                    g_light_accumulator_diffuse = vec4(1.);\n                #endif\n            ";
    }
    var calculateFunction = ("\n            vec4 calculateLighting(in vec3 _eyeToPoint, in vec3 _normal, in vec4 _color) {\n\n                " + calculateLights + "\n\n                //  Final light intensity calculation\n                vec4 color = vec4(0.0);\n\n                #ifdef TANGRAM_MATERIAL_EMISSION\n                    color = g_material.emission;\n                #endif\n\n                #ifdef TANGRAM_MATERIAL_AMBIENT\n                    color += g_light_accumulator_ambient * _color * g_material.ambient;\n                #endif\n\n                #ifdef TANGRAM_MATERIAL_DIFFUSE\n                    color += g_light_accumulator_diffuse * _color * g_material.diffuse;\n                #endif\n\n                #ifdef TANGRAM_MATERIAL_SPECULAR\n                    color += g_light_accumulator_specular * g_material.specular;\n                #endif\n\n                // Clamp final color\n                color = clamp(color, 0.0, 1.0);\n\n                return color;\n            }");
    ShaderProgram.addTransform($Light.transform, calculateFunction);
  }
});
var $__default = Light;
Light.types = {};
Light.transform = 'lighting';
Light.enabled = true;
var AmbientLight = function AmbientLight(scene, config) {
  $traceurRuntime.superConstructor($AmbientLight).call(this, scene, config);
  this.type = 'ambient';
  this.struct_name = 'AmbientLight';
};
var $AmbientLight = AmbientLight;
($traceurRuntime.createClass)(AmbientLight, {setupProgram: function(_program) {
    _program.uniform('4fv', ("u_" + this.name + ".ambient"), this.ambient);
  }}, {inject: function() {
    ShaderProgram.addTransform(Light.transform, shaderSources['gl/shaders/ambientLight']);
  }}, Light);
Light.types['ambient'] = AmbientLight;
var DirectionalLight = function DirectionalLight(scene, config) {
  $traceurRuntime.superConstructor($DirectionalLight).call(this, scene, config);
  this.type = 'directional';
  this.struct_name = 'DirectionalLight';
  this.direction = (config.direction || [0.2, 0.7, -0.5]).map(parseFloat);
};
var $DirectionalLight = DirectionalLight;
($traceurRuntime.createClass)(DirectionalLight, {setupProgram: function(_program) {
    $traceurRuntime.superGet(this, $DirectionalLight.prototype, "setupProgram").call(this, _program);
    _program.uniform('3fv', ("u_" + this.name + ".direction"), this.direction);
  }}, {inject: function() {
    ShaderProgram.addTransform(Light.transform, shaderSources['gl/shaders/directionalLight']);
  }}, Light);
Light.types['directional'] = DirectionalLight;
var PointLight = function PointLight(scene, config) {
  $traceurRuntime.superConstructor($PointLight).call(this, scene, config);
  this.type = 'point';
  this.struct_name = 'PointLight';
  this.position = config.position || [0, 0, 0];
  this.position_eye = [];
  this.origin = config.origin || 'world';
  this.attenuation = !isNaN(parseFloat(config.attenuation)) ? parseFloat(config.attenuation) : 0;
  if (config.radius) {
    if (Array.isArray(config.radius) && config.radius.length === 2) {
      this.radius = config.radius;
    } else {
      this.radius = [null, config.radius];
    }
  } else {
    this.radius = null;
  }
};
var $PointLight = PointLight;
($traceurRuntime.createClass)(PointLight, {
  inject: function() {
    $traceurRuntime.superGet(this, $PointLight.prototype, "inject").call(this);
    ShaderProgram.defines['TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT'] = (this.attenuation !== 0);
    ShaderProgram.defines['TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS'] = (this.radius != null && this.radius[0] != null);
    ShaderProgram.defines['TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS'] = (this.radius != null);
  },
  update: function() {
    this.updateEyePosition();
  },
  updateEyePosition: function() {
    if (this.origin === 'world') {
      var $__6 = Geo.latLngToMeters(this.position),
          x = $__6[0],
          y = $__6[1];
      this.position_eye[0] = x - this.scene.camera.position_meters[0];
      this.position_eye[1] = y - this.scene.camera.position_meters[1];
      this.position_eye[2] = StyleParser.convertUnits(this.position[2], {zoom: this.scene.zoom});
      this.position_eye[2] = this.position_eye[2] - this.scene.camera.position_meters[2];
    }
    if (this.origin === 'ground' || this.origin === 'camera') {
      this.position_eye = StyleParser.convertUnits(this.position, {zoom: this.scene.zoom});
      if (this.origin === 'ground') {
        this.position_eye[2] = this.position_eye[2] - this.scene.camera.position_meters[2];
      }
    }
  },
  setupProgram: function(_program) {
    $traceurRuntime.superGet(this, $PointLight.prototype, "setupProgram").call(this, _program);
    _program.uniform('4f', ("u_" + this.name + ".position"), this.position_eye[0], this.position_eye[1], this.position_eye[2], 1);
    if (ShaderProgram.defines['TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT']) {
      _program.uniform('1f', ("u_" + this.name + ".attenuationExponent"), this.attenuation);
    }
    if (ShaderProgram.defines['TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS']) {
      _program.uniform('1f', ("u_" + this.name + ".innerRadius"), StyleParser.convertUnits(this.radius[0], {zoom: this.scene.zoom}));
    }
    if (ShaderProgram.defines['TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS']) {
      _program.uniform('1f', ("u_" + this.name + ".outerRadius"), StyleParser.convertUnits(this.radius[1], {zoom: this.scene.zoom}));
    }
  }
}, {inject: function() {
    ShaderProgram.addTransform(Light.transform, shaderSources['gl/shaders/pointLight']);
  }}, Light);
Light.types['point'] = PointLight;
var SpotLight = function SpotLight(scene, config) {
  $traceurRuntime.superConstructor($SpotLight).call(this, scene, config);
  this.type = 'spotlight';
  this.struct_name = 'SpotLight';
  this.direction = (config.direction || [0, 0, -1]).map(parseFloat);
  this.exponent = config.exponent ? parseFloat(config.exponent) : 0.2;
  this.angle = config.angle ? parseFloat(config.angle) : 20;
};
var $SpotLight = SpotLight;
($traceurRuntime.createClass)(SpotLight, {setupProgram: function(_program) {
    $traceurRuntime.superGet(this, $SpotLight.prototype, "setupProgram").call(this, _program);
    _program.uniform('3fv', ("u_" + this.name + ".direction"), this.direction);
    _program.uniform('1f', ("u_" + this.name + ".spotCosCutoff"), Math.cos(this.angle * 3.14159 / 180));
    _program.uniform('1f', ("u_" + this.name + ".spotExponent"), this.exponent);
  }}, {inject: function() {
    ShaderProgram.addTransform(Light.transform, shaderSources['gl/shaders/spotLight']);
  }}, PointLight);
Light.types['spotlight'] = SpotLight;


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/light.js
},{"./geo":67,"./gl/glsl":70,"./gl/shader_program":71,"./gl/shader_sources":72,"./styles/style_parser":91}],79:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  __esModule: {value: true}
});
var $__gl_47_shader_95_sources__,
    $__gl_47_glsl__,
    $__styles_47_style_95_parser__;
var shaderSources = ($__gl_47_shader_95_sources__ = require("./gl/shader_sources"), $__gl_47_shader_95_sources__ && $__gl_47_shader_95_sources__.__esModule && $__gl_47_shader_95_sources__ || {default: $__gl_47_shader_95_sources__}).default;
var GLSL = ($__gl_47_glsl__ = require("./gl/glsl"), $__gl_47_glsl__ && $__gl_47_glsl__.__esModule && $__gl_47_glsl__ || {default: $__gl_47_glsl__}).default;
var StyleParser = ($__styles_47_style_95_parser__ = require("./styles/style_parser"), $__styles_47_style_95_parser__ && $__styles_47_style_95_parser__.__esModule && $__styles_47_style_95_parser__ || {default: $__styles_47_style_95_parser__}).StyleParser;
var Material = function Material(config) {
  config = config || {};
  if (config.emission == null || typeof config.emission === 'number') {
    this.emission = GLSL.expandVec4(config.emission || 0);
  } else {
    this.emission = StyleParser.parseColor(config.emission);
  }
  if (config.ambient == null || typeof config.ambient === 'number') {
    this.ambient = GLSL.expandVec4(config.ambient != null ? config.ambient : 1);
  } else {
    this.ambient = StyleParser.parseColor(config.ambient);
  }
  if (config.diffuse == null || typeof config.diffuse === 'number') {
    this.diffuse = GLSL.expandVec4(config.diffuse != null ? config.diffuse : 1);
  } else {
    this.diffuse = StyleParser.parseColor(config.diffuse);
  }
  if (config.specular == null || typeof config.specular === 'number') {
    this.specular = GLSL.expandVec4(config.specular || 0);
  } else {
    this.specular = StyleParser.parseColor(config.specular);
  }
  this.shininess = config.shininess ? parseFloat(config.shininess) : 0.2;
};
var $Material = Material;
($traceurRuntime.createClass)(Material, {
  inject: function(style) {
    style.defines['TANGRAM_MATERIAL_EMISSION'] = (this.emission != null);
    style.defines['TANGRAM_MATERIAL_AMBIENT'] = (this.ambient != null);
    style.defines['TANGRAM_MATERIAL_DIFFUSE'] = (this.diffuse != null);
    style.defines['TANGRAM_MATERIAL_SPECULAR'] = (this.specular != null);
    style.replaceShaderTransform($Material.transform, shaderSources['gl/shaders/material']);
  },
  setupProgram: function(_program) {
    if (this.emission != null) {
      _program.uniform('4fv', 'u_material.emission', this.emission);
    }
    if (this.ambient != null) {
      _program.uniform('4fv', 'u_material.ambient', this.ambient);
    }
    if (this.diffuse != null) {
      _program.uniform('4fv', 'u_material.diffuse', this.diffuse);
    }
    if (this.specular != null) {
      _program.uniform('4fv', 'u_material.specular', this.specular);
      _program.uniform('1f', 'u_material.shininess', this.shininess);
    }
  }
}, {});
var $__default = Material;
Material.transform = 'material';


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/material.js
},{"./gl/glsl":70,"./gl/shader_sources":72,"./styles/style_parser":91}],80:[function(require,module,exports){
"use strict";
var $__utils_47_utils__,
    $__leaflet_95_layer__,
    $___46__46__47_src_47_scene_95_worker__,
    $__loglevel__,
    $__geo__,
    $__gl_47_glsl__,
    $__gl_47_shader_95_program__,
    $__gl_47_texture__,
    $__material__,
    $__light__,
    $__utils_47_worker_95_broker__,
    $__unruly__,
    $__gl_45_matrix__;
var Utils = ($__utils_47_utils__ = require("./utils/utils"), $__utils_47_utils__ && $__utils_47_utils__.__esModule && $__utils_47_utils__ || {default: $__utils_47_utils__}).default;
var $__1 = ($__leaflet_95_layer__ = require("./leaflet_layer"), $__leaflet_95_layer__ && $__leaflet_95_layer__.__esModule && $__leaflet_95_layer__ || {default: $__leaflet_95_layer__}),
    LeafletLayer = $__1.LeafletLayer,
    leafletLayer = $__1.leafletLayer;
var SceneWorker = ($___46__46__47_src_47_scene_95_worker__ = require("../src/scene_worker"), $___46__46__47_src_47_scene_95_worker__ && $___46__46__47_src_47_scene_95_worker__.__esModule && $___46__46__47_src_47_scene_95_worker__ || {default: $___46__46__47_src_47_scene_95_worker__}).SceneWorker;
var log = ($__loglevel__ = require("loglevel"), $__loglevel__ && $__loglevel__.__esModule && $__loglevel__ || {default: $__loglevel__}).default;
var Geo = ($__geo__ = require("./geo"), $__geo__ && $__geo__.__esModule && $__geo__ || {default: $__geo__}).default;
var GLSL = ($__gl_47_glsl__ = require("./gl/glsl"), $__gl_47_glsl__ && $__gl_47_glsl__.__esModule && $__gl_47_glsl__ || {default: $__gl_47_glsl__}).default;
var ShaderProgram = ($__gl_47_shader_95_program__ = require("./gl/shader_program"), $__gl_47_shader_95_program__ && $__gl_47_shader_95_program__.__esModule && $__gl_47_shader_95_program__ || {default: $__gl_47_shader_95_program__}).default;
var Texture = ($__gl_47_texture__ = require("./gl/texture"), $__gl_47_texture__ && $__gl_47_texture__.__esModule && $__gl_47_texture__ || {default: $__gl_47_texture__}).default;
var Material = ($__material__ = require("./material"), $__material__ && $__material__.__esModule && $__material__ || {default: $__material__}).default;
var Light = ($__light__ = require("./light"), $__light__ && $__light__.__esModule && $__light__ || {default: $__light__}).default;
var WorkerBroker = ($__utils_47_worker_95_broker__ = require("./utils/worker_broker"), $__utils_47_worker_95_broker__ && $__utils_47_worker_95_broker__.__esModule && $__utils_47_worker_95_broker__ || {default: $__utils_47_worker_95_broker__}).default;
var ruleCache = ($__unruly__ = require("unruly"), $__unruly__ && $__unruly__.__esModule && $__unruly__ || {default: $__unruly__}).ruleCache;
var glMatrix = ($__gl_45_matrix__ = require("gl-matrix"), $__gl_45_matrix__ && $__gl_45_matrix__.__esModule && $__gl_45_matrix__ || {default: $__gl_45_matrix__}).default;
glMatrix.glMatrix.setMatrixArrayType(Float64Array);
var debug = {
  log: log,
  Utils: Utils,
  Geo: Geo,
  GLSL: GLSL,
  ShaderProgram: ShaderProgram,
  Texture: Texture,
  Material: Material,
  Light: Light,
  SceneWorker: SceneWorker,
  WorkerBroker: WorkerBroker,
  ruleCache: ruleCache
};
if (Utils.isMainThread) {
  WorkerBroker.addTarget('Texture', Texture);
  window.Tangram = module.exports = {
    LeafletLayer: LeafletLayer,
    leafletLayer: leafletLayer,
    debug: debug
  };
}
if (Utils.isWorkerThread) {
  self.Tangram = {debug: debug};
}


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/module.js
},{"../src/scene_worker":82,"./geo":67,"./gl/glsl":70,"./gl/shader_program":71,"./gl/texture":73,"./leaflet_layer":77,"./light":78,"./material":79,"./utils/utils":98,"./utils/worker_broker":99,"gl-matrix":21,"loglevel":53,"unruly":59}],81:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  __esModule: {value: true}
});
var $__geo__,
    $__utils_47_utils__,
    $__utils_47_worker_95_broker__,
    $__utils_47_subscribe__,
    $__gl_47_context__,
    $__styles_47_builders__,
    $__gl_47_shader_95_program__,
    $__gl_47_texture__,
    $__styles_47_style_95_manager__,
    $__styles_47_style_95_parser__,
    $__camera__,
    $__light__,
    $__tile__,
    $__tile_95_source__,
    $__selection__,
    $__loglevel__,
    $__gl_45_matrix__;
var Geo = ($__geo__ = require("./geo"), $__geo__ && $__geo__.__esModule && $__geo__ || {default: $__geo__}).default;
var Utils = ($__utils_47_utils__ = require("./utils/utils"), $__utils_47_utils__ && $__utils_47_utils__.__esModule && $__utils_47_utils__ || {default: $__utils_47_utils__}).default;
var WorkerBroker = ($__utils_47_worker_95_broker__ = require("./utils/worker_broker"), $__utils_47_worker_95_broker__ && $__utils_47_worker_95_broker__.__esModule && $__utils_47_worker_95_broker__ || {default: $__utils_47_worker_95_broker__}).default;
var subscribeMixin = ($__utils_47_subscribe__ = require("./utils/subscribe"), $__utils_47_subscribe__ && $__utils_47_subscribe__.__esModule && $__utils_47_subscribe__ || {default: $__utils_47_subscribe__}).default;
var Context = ($__gl_47_context__ = require("./gl/context"), $__gl_47_context__ && $__gl_47_context__.__esModule && $__gl_47_context__ || {default: $__gl_47_context__}).default;
var Builders = ($__styles_47_builders__ = require("./styles/builders"), $__styles_47_builders__ && $__styles_47_builders__.__esModule && $__styles_47_builders__ || {default: $__styles_47_builders__}).default;
var ShaderProgram = ($__gl_47_shader_95_program__ = require("./gl/shader_program"), $__gl_47_shader_95_program__ && $__gl_47_shader_95_program__.__esModule && $__gl_47_shader_95_program__ || {default: $__gl_47_shader_95_program__}).default;
var Texture = ($__gl_47_texture__ = require("./gl/texture"), $__gl_47_texture__ && $__gl_47_texture__.__esModule && $__gl_47_texture__ || {default: $__gl_47_texture__}).default;
var StyleManager = ($__styles_47_style_95_manager__ = require("./styles/style_manager"), $__styles_47_style_95_manager__ && $__styles_47_style_95_manager__.__esModule && $__styles_47_style_95_manager__ || {default: $__styles_47_style_95_manager__}).StyleManager;
var StyleParser = ($__styles_47_style_95_parser__ = require("./styles/style_parser"), $__styles_47_style_95_parser__ && $__styles_47_style_95_parser__.__esModule && $__styles_47_style_95_parser__ || {default: $__styles_47_style_95_parser__}).StyleParser;
var Camera = ($__camera__ = require("./camera"), $__camera__ && $__camera__.__esModule && $__camera__ || {default: $__camera__}).default;
var Light = ($__light__ = require("./light"), $__light__ && $__light__.__esModule && $__light__ || {default: $__light__}).default;
var Tile = ($__tile__ = require("./tile"), $__tile__ && $__tile__.__esModule && $__tile__ || {default: $__tile__}).default;
var TileSource = ($__tile_95_source__ = require("./tile_source"), $__tile_95_source__ && $__tile_95_source__.__esModule && $__tile_95_source__ || {default: $__tile_95_source__}).default;
var FeatureSelection = ($__selection__ = require("./selection"), $__selection__ && $__selection__.__esModule && $__selection__ || {default: $__selection__}).default;
var log = ($__loglevel__ = require("loglevel"), $__loglevel__ && $__loglevel__.__esModule && $__loglevel__ || {default: $__loglevel__}).default;
var glMatrix = ($__gl_45_matrix__ = require("gl-matrix"), $__gl_45_matrix__ && $__gl_45_matrix__.__esModule && $__gl_45_matrix__ || {default: $__gl_45_matrix__}).default;
var mat4 = glMatrix.mat4;
var mat3 = glMatrix.mat3;
var vec3 = glMatrix.vec3;
if (Utils.isMainThread) {
  Utils.requestAnimationFramePolyfill();
}
Scene.tile_scale = 4096;
Geo.setTileScale(Scene.tile_scale);
Builders.setTileScale(Scene.tile_scale);
ShaderProgram.defines.TILE_SCALE = Scene.tile_scale;
function Scene(config_source, options) {
  options = options || {};
  subscribeMixin(this);
  this.initialized = false;
  this.initializing = false;
  this.sources = {};
  this.tiles = {};
  this.visible_tiles = {};
  this.queued_tiles = [];
  this.num_workers = options.numWorkers || 2;
  this.allow_cross_domain_workers = (options.allowCrossDomainWorkers === false ? false : true);
  this.worker_url = options.workerUrl;
  this.config = null;
  this.config_source = config_source;
  this.config_serialized = null;
  this.styles = null;
  this.active_styles = {};
  this.building = null;
  this.dirty = true;
  this.animated = false;
  this.preUpdate = options.preUpdate;
  this.postUpdate = options.postUpdate;
  this.render_loop = !options.disableRenderLoop;
  this.frame = 0;
  this.resetTime();
  this.zoom = null;
  this.center = null;
  this.device_pixel_ratio = window.devicePixelRatio || 1;
  this.zooming = false;
  this.panning = false;
  this.container = options.container;
  this.camera = null;
  this.lights = null;
  this.modelMatrix = new Float64Array(16);
  this.modelMatrix32 = new Float32Array(16);
  this.modelViewMatrix = new Float64Array(16);
  this.modelViewMatrix32 = new Float32Array(16);
  this.normalMatrix = new Float64Array(9);
  this.normalMatrix32 = new Float32Array(9);
  this.selection = null;
  this.texture_listener = null;
  this.debug = {profile: {geometry_build: false}};
  this.logLevel = options.logLevel || 'info';
  log.setLevel(this.logLevel);
}
var $__default = Scene;
Scene.create = function(config) {
  var options = arguments[1] !== (void 0) ? arguments[1] : {};
  return new Scene(config, options);
};
Scene.prototype.init = function() {
  var $__17 = this;
  if (this.initialized) {
    return Promise.resolve();
  }
  this.initializing = true;
  return new Promise((function(resolve, reject) {
    $__17.loadScene().then((function() {
      $__17.createWorkers().then((function() {
        $__17.createCanvas();
        $__17.selection = new FeatureSelection($__17.gl, $__17.workers);
        $__17.texture_listener = {update: (function() {
            return $__17.dirty = true;
          })};
        Texture.subscribe($__17.texture_listener);
        $__17.updateConfig();
        $__17.initializing = false;
        $__17.initialized = true;
        resolve();
        if ($__17.render_loop !== false) {
          $__17.setupRenderLoop();
        }
      })).catch((function(e) {
        throw e;
      }));
    })).catch((function(e) {
      reject(e);
    }));
  }));
};
Scene.prototype.destroy = function() {
  this.initialized = false;
  this.renderLoop = (function() {});
  this.unsubscribeAll();
  Texture.unsubscribe(this.texture_listener);
  this.texture_listener = null;
  if (this.canvas && this.canvas.parentNode) {
    this.canvas.parentNode.removeChild(this.canvas);
    this.canvas = null;
  }
  this.container = null;
  if (this.gl) {
    this.gl.deleteFramebuffer(this.fbo);
    this.fbo = null;
    Texture.destroy(this.gl);
    StyleManager.destroy(this.gl);
    this.styles = {};
    this.gl = null;
  }
  if (Array.isArray(this.workers)) {
    this.workers.forEach((function(worker) {
      worker.terminate();
    }));
    this.workers = null;
  }
  this.sources = {};
  this.tiles = {};
};
Scene.prototype.createCanvas = function() {
  this.container = this.container || document.body;
  this.canvas = document.createElement('canvas');
  this.canvas.style.position = 'absolute';
  this.canvas.style.top = 0;
  this.canvas.style.left = 0;
  this.canvas.style.zIndex = -1;
  this.container.appendChild(this.canvas);
  this.gl = Context.getContext(this.canvas, {alpha: false});
  this.resizeMap(this.container.clientWidth, this.container.clientHeight);
};
Scene.prototype.createObjectURL = function() {
  return (window.URL && window.URL.createObjectURL) || (window.webkitURL && window.webkitURL.createObjectURL);
};
Scene.loadWorkerUrl = function(scene) {
  var worker_url = scene.worker_url || Utils.findCurrentURL('tangram.debug.js', 'tangram.min.js'),
      createObjectURL = scene.createObjectURL();
  return new Promise((function(resolve, reject) {
    if (!worker_url) {
      reject(new Error("Can't load worker because couldn't find base URL that library was loaded from"));
      return;
    }
    if (createObjectURL && scene.allow_cross_domain_workers) {
      var body = ("importScripts('" + worker_url + "');");
      var worker_local_url = createObjectURL(new Blob([body], {type: 'application/javascript'}));
      resolve(worker_local_url);
    } else {
      resolve(worker_url);
    }
  }));
};
Scene.prototype.createWorkers = function() {
  var $__17 = this;
  return new Promise((function(resolve, reject) {
    Scene.loadWorkerUrl($__17).then((function(worker_url) {
      $__17.makeWorkers(worker_url).then(resolve, reject);
    }));
  }));
};
Scene.prototype.makeWorkers = function(url) {
  var queue = [];
  this.workers = [];
  var worker,
      $__23 = this,
      $__24 = function() {
        worker = new Worker(url);
        $__23.workers[id] = worker;
        worker.addEventListener('message', $__23.workerLogMessage.bind($__23));
        WorkerBroker.addWorker(worker);
        log.debug(("Scene.makeWorkers: initializing worker " + id));
        var _id = id;
        queue.push(WorkerBroker.postMessage(worker, 'init', id).then((function(id) {
          log.debug(("Scene.makeWorkers: initialized worker " + id));
          return id;
        }), (function(error) {
          log.error(("Scene.makeWorkers: failed to initialize worker " + _id + ":"), error);
          return Promise.reject(error);
        })));
      };
  for (var id = 0; id < this.num_workers; id++) {
    $__24();
  }
  this.next_worker = 0;
  this.selection_map_worker_size = {};
  return Promise.all(queue);
};
Scene.prototype.nextWorker = function() {
  var worker = this.workers[this.next_worker];
  this.next_worker = (this.next_worker + 1) % this.workers.length;
  return worker;
};
Scene.prototype.setView = function() {
  var $__20 = arguments[0] !== (void 0) ? arguments[0] : {},
      lng = $__20.lng,
      lat = $__20.lat,
      zoom = $__20.zoom;
  var changed = false;
  if (lng && lat) {
    changed = changed || !this.center || lng !== this.center.lng || lat !== this.center.lat;
    this.center = {
      lng: lng,
      lat: lat
    };
  }
  if (zoom) {
    changed = changed || zoom !== this.zoom;
    this.setZoom(zoom);
  }
  if (changed) {
    this.updateBounds();
  }
  return changed;
};
Scene.prototype.startZoom = function() {
  this.last_zoom = this.zoom;
  this.zooming = true;
};
Scene.prototype.baseZoom = function(zoom) {
  return Math.round(zoom);
};
Scene.prototype.preserve_tiles_within_zoom = 2;
Scene.prototype.setZoom = function(zoom) {
  var $__17 = this;
  this.zooming = false;
  var base = this.baseZoom(zoom);
  if (base !== this.baseZoom(this.last_zoom)) {
    var below = base;
    var above = base;
    log.trace(("scene.last_zoom: " + this.last_zoom));
    if (Math.abs(zoom - this.last_zoom) <= this.preserve_tiles_within_zoom) {
      below -= this.preserve_tiles_within_zoom;
      above += this.preserve_tiles_within_zoom;
    }
    log.trace(("removing tiles outside range [" + below + ", " + above + "]"));
    this.removeTilesOutsideZoomRange(below, above);
    this.removeTiles((function(tile) {
      if (tile.loading && $__17.baseZoom(tile.coords.z) !== base) {
        log.trace(("removed " + tile.key + " (was loading, but outside current zoom)"));
        return true;
      }
    }));
  }
  this.last_zoom = this.zoom;
  this.zoom = zoom;
  this.updateBounds();
  this.dirty = true;
};
Scene.prototype.viewReady = function() {
  if (this.css_size == null || this.center == null || this.zoom == null || Object.keys(this.sources).length === 0) {
    return false;
  }
  return true;
};
Scene.prototype.updateBounds = function() {
  if (!this.viewReady()) {
    return;
  }
  this.meters_per_pixel = Geo.metersPerPixel(this.zoom);
  this.viewport_meters = {
    x: this.css_size.width * this.meters_per_pixel,
    y: this.css_size.height * this.meters_per_pixel
  };
  var $__20 = Geo.latLngToMeters([this.center.lng, this.center.lat]),
      x = $__20[0],
      y = $__20[1];
  this.center_meters = {
    x: x,
    y: y
  };
  var z = this.baseZoom(this.zoom);
  var max_zoom = this.findMaxZoom();
  if (z > max_zoom) {
    z = max_zoom;
  }
  this.center_tile = Geo.tileForMeters([this.center_meters.x, this.center_meters.y], z);
  this.bounds_meters = {
    sw: {
      x: this.center_meters.x - this.viewport_meters.x / 2,
      y: this.center_meters.y - this.viewport_meters.y / 2
    },
    ne: {
      x: this.center_meters.x + this.viewport_meters.x / 2,
      y: this.center_meters.y + this.viewport_meters.y / 2
    }
  };
  this.visible_tiles = this.findVisibleTiles();
  for (var key in this.visible_tiles) {
    this.loadTile(this.visible_tiles[key]);
  }
  for (var key$__25 in this.tiles) {
    this.tiles[key$__25].update(this);
  }
  this.trigger('move');
  this.dirty = true;
};
Scene.prototype.findVisibleTiles = function() {
  var buffer = (arguments[0] !== (void 0) ? arguments[0] : {}).buffer;
  var z = this.baseZoom(this.zoom);
  var max_zoom = this.findMaxZoom();
  if (z > max_zoom) {
    z = max_zoom;
  }
  var sw = Geo.tileForMeters([this.bounds_meters.sw.x, this.bounds_meters.sw.y], z);
  var ne = Geo.tileForMeters([this.bounds_meters.ne.x, this.bounds_meters.ne.y], z);
  buffer = buffer || 0;
  var tiles = {};
  for (var x = sw.x - buffer; x <= ne.x + buffer; x++) {
    for (var y = ne.y - buffer; y <= sw.y + buffer; y++) {
      var coords = {
        x: x,
        y: y,
        z: z
      };
      tiles[Tile.key(coords)] = coords;
    }
  }
  return tiles;
};
Scene.prototype.removeTilesOutsideZoomRange = function(below, above) {
  below = Math.min(below, this.findMaxZoom() || below);
  above = Math.min(above, this.findMaxZoom() || above);
  this.removeTiles((function(tile) {
    if (tile.coords.z < below || tile.coords.z > above) {
      log.trace(("removed " + tile.key + " (outside range [" + below + ", " + above + "])"));
      return true;
    }
  }));
};
Scene.prototype.removeTiles = function(filter) {
  var remove_tiles = [];
  for (var t in this.tiles) {
    var tile = this.tiles[t];
    if (filter(tile)) {
      remove_tiles.push(t);
    }
  }
  for (var r = 0; r < remove_tiles.length; r++) {
    var key = remove_tiles[r];
    this.removeTile(key);
  }
};
Scene.prototype.resizeMap = function(width, height) {
  this.dirty = true;
  this.css_size = {
    width: width,
    height: height
  };
  this.device_size = {
    width: Math.round(this.css_size.width * this.device_pixel_ratio),
    height: Math.round(this.css_size.height * this.device_pixel_ratio)
  };
  this.view_aspect = this.css_size.width / this.css_size.height;
  this.updateBounds();
  if (this.canvas) {
    this.canvas.style.width = this.css_size.width + 'px';
    this.canvas.style.height = this.css_size.height + 'px';
    this.canvas.width = this.device_size.width;
    this.canvas.height = this.device_size.height;
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
  }
};
Scene.prototype.requestRedraw = function() {
  this.dirty = true;
};
Scene.prototype.immediateRedraw = function() {
  this.dirty = true;
  this.render();
};
Scene.prototype.setupRenderLoop = function() {
  var $__20 = arguments[0] !== (void 0) ? arguments[0] : {},
      pre_render = $__20.pre_render,
      post_render = $__20.post_render;
  var $__17 = this;
  this.renderLoop = (function() {
    if ($__17.initialized) {
      $__17.update();
    }
    window.requestAnimationFrame($__17.renderLoop);
  });
  setTimeout((function() {
    $__17.renderLoop();
  }), 0);
};
Scene.prototype.update = function() {
  this.loadQueuedTiles();
  var will_render = !(this.dirty === false || this.initialized === false || this.viewReady() === false);
  if (typeof this.preUpdate === 'function') {
    this.preUpdate(will_render);
  }
  if (!will_render) {
    return false;
  }
  this.dirty = false;
  this.render();
  if (typeof this.postUpdate === 'function') {
    this.postUpdate(will_render);
  }
  if (this.animated === true) {
    this.dirty = true;
  }
  this.frame++;
  log.trace('Scene.render()');
  return true;
};
Scene.prototype.render = function() {
  var $__17 = this;
  var gl = this.gl;
  if (!this.center_meters) {
    return;
  }
  this.camera.update();
  Object.keys(this.active_styles).forEach((function(i) {
    return $__17.styles[i].update();
  }));
  Object.keys(this.lights).forEach((function(i) {
    return $__17.lights[i].update();
  }));
  this.renderable_tiles = [];
  for (var t in this.tiles) {
    var tile = this.tiles[t];
    if (tile.visible && tile.loaded) {
      this.renderable_tiles.push(tile);
    }
  }
  this.renderable_tiles_count = this.renderable_tiles.length;
  this.order = this.calcOrderRange(this.renderable_tiles);
  this.render_count = this.renderPass();
  if (this.selection.pendingRequests()) {
    if (this.panning) {
      return;
    }
    this.selection.bind();
    this.renderPass('selection_program', {allow_alpha_blend: false});
    this.selection.read();
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, this.canvas.width, this.canvas.height);
  }
  if (this.render_count !== this.last_render_count) {
    log.info(("Scene: rendered " + this.render_count + " primitives"));
  }
  this.last_render_count = this.render_count;
  return true;
};
Scene.prototype.renderPass = function() {
  var program_key = arguments[0] !== (void 0) ? arguments[0] : 'program';
  var allow_alpha_blend = (arguments[1] !== (void 0) ? arguments[1] : {}).allow_alpha_blend;
  var $__17 = this;
  var styles;
  var count = 0;
  allow_alpha_blend = (allow_alpha_blend == null) ? true : allow_alpha_blend;
  this.clearFrame({
    clear_color: true,
    clear_depth: true
  });
  styles = Object.keys(this.active_styles).filter((function(s) {
    return $__17.styles[s].blend === 'opaque';
  }));
  this.setRenderState({
    depth_test: true,
    depth_write: true,
    alpha_blend: false
  });
  count += this.renderStyles(styles, program_key);
  styles = Object.keys(this.active_styles).filter((function(s) {
    return $__17.styles[s].blend === 'add';
  }));
  this.setRenderState({
    depth_test: true,
    depth_write: false,
    alpha_blend: (allow_alpha_blend && 'add')
  });
  count += this.renderStyles(styles, program_key);
  styles = Object.keys(this.active_styles).filter((function(s) {
    return $__17.styles[s].blend === 'multiply';
  }));
  this.setRenderState({
    depth_test: true,
    depth_write: false,
    alpha_blend: (allow_alpha_blend && 'multiply')
  });
  count += this.renderStyles(styles, program_key);
  styles = Object.keys(this.styles).filter((function(s) {
    return $__17.styles[s].blend === 'overlay';
  }));
  this.setRenderState({
    depth_test: false,
    depth_write: false,
    alpha_blend: allow_alpha_blend
  });
  count += this.renderStyles(styles, program_key);
  return count;
};
Scene.prototype.renderStyles = function(styles, program_key) {
  var count = 0;
  for (var $__18 = styles[$traceurRuntime.toProperty(Symbol.iterator)](),
      $__19; !($__19 = $__18.next()).done; ) {
    var style = $__19.value;
    {
      var program = this.styles[style][program_key];
      if (!program || !program.compiled) {
        continue;
      }
      count += this.renderStyle(style, program);
    }
  }
  return count;
};
Scene.prototype.renderStyle = function(style, program) {
  var first_for_style = true;
  var render_count = 0;
  for (var t in this.renderable_tiles) {
    var tile = this.renderable_tiles[t];
    if (tile.meshes[style] != null) {
      if (first_for_style === true) {
        first_for_style = false;
        program.use();
        this.styles[style].setup();
        program.uniform('2f', 'u_resolution', this.device_size.width, this.device_size.height);
        program.uniform('2f', 'u_aspect', this.view_aspect, 1.0);
        program.uniform('1f', 'u_time', ((+new Date()) - this.start_time) / 1000);
        program.uniform('1f', 'u_map_zoom', this.zoom);
        program.uniform('2f', 'u_map_center', this.center_meters.x, this.center_meters.y);
        program.uniform('1f', 'u_order_min', this.order.min);
        program.uniform('1f', 'u_order_range', this.order.range);
        program.uniform('1f', 'u_meters_per_pixel', this.meters_per_pixel);
        this.camera.setupProgram(program);
        for (var i in this.lights) {
          this.lights[i].setupProgram(program);
        }
      }
      program.uniform('2f', 'u_tile_origin', tile.min.x, tile.min.y);
      mat4.identity(this.modelMatrix);
      mat4.translate(this.modelMatrix, this.modelMatrix, vec3.fromValues(tile.min.x, tile.min.y, 0));
      mat4.scale(this.modelMatrix, this.modelMatrix, vec3.fromValues(tile.span.x / Scene.tile_scale, -1 * tile.span.y / Scene.tile_scale, 1));
      mat4.copy(this.modelMatrix32, this.modelMatrix);
      program.uniform('Matrix4fv', 'u_model', false, this.modelMatrix32);
      mat4.multiply(this.modelViewMatrix32, this.camera.viewMatrix, this.modelMatrix);
      program.uniform('Matrix4fv', 'u_modelView', false, this.modelViewMatrix32);
      mat3.normalFromMat4(this.normalMatrix32, this.modelViewMatrix32);
      program.uniform('Matrix3fv', 'u_normalMatrix', false, this.normalMatrix32);
      tile.meshes[style].render();
      render_count += tile.meshes[style].geometry_count;
    }
  }
  return render_count;
};
Scene.prototype.clearFrame = function() {
  var $__20 = arguments[0] !== (void 0) ? arguments[0] : {},
      clear_color = $__20.clear_color,
      clear_depth = $__20.clear_depth;
  if (!this.initialized) {
    return;
  }
  clear_color = (clear_color === false) ? false : true;
  clear_depth = (clear_depth === false) ? false : true;
  var gl = this.gl;
  if (clear_color) {
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
  }
  if (clear_depth) {
    gl.depthMask(true);
  }
  if (clear_color || clear_depth) {
    var mask = (clear_color && gl.COLOR_BUFFER_BIT) | (clear_depth && gl.DEPTH_BUFFER_BIT);
    gl.clear(mask);
  }
};
Scene.prototype.setRenderState = function() {
  var $__20 = arguments[0] !== (void 0) ? arguments[0] : {},
      depth_test = $__20.depth_test,
      depth_write = $__20.depth_write,
      cull_face = $__20.cull_face,
      alpha_blend = $__20.alpha_blend;
  if (!this.initialized) {
    return;
  }
  depth_test = (depth_test === false) ? false : true;
  depth_write = (depth_write === false) ? false : true;
  cull_face = (cull_face === false) ? false : true;
  alpha_blend = (alpha_blend != null) ? alpha_blend : false;
  var gl = this.gl;
  if (depth_test) {
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
  } else {
    gl.disable(gl.DEPTH_TEST);
  }
  gl.depthMask(depth_write);
  if (cull_face) {
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
  } else {
    gl.disable(gl.CULL_FACE);
  }
  if (alpha_blend) {
    gl.enable(gl.BLEND);
    if (alpha_blend === true) {
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    } else if (alpha_blend === 'add') {
      gl.blendFunc(gl.ONE, gl.ONE);
    } else if (alpha_blend === 'multiply') {
      gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
    }
  } else {
    gl.disable(gl.BLEND);
  }
};
Scene.prototype.calcOrderRange = function(tiles) {
  var order = {
    min: Infinity,
    max: -Infinity
  };
  for (var $__18 = tiles[$traceurRuntime.toProperty(Symbol.iterator)](),
      $__19; !($__19 = $__18.next()).done; ) {
    var t = $__19.value;
    {
      if (t.order.min < order.min) {
        order.min = t.order.min;
      }
      if (t.order.max > order.max) {
        order.max = t.order.max;
      }
    }
  }
  order.max += 1;
  order.range = order.max - order.min;
  return order;
};
Scene.prototype.getFeatureAt = function(pixel) {
  if (!this.initialized) {
    return Promise.reject(new Error("Scene.getFeatureAt() called before scene was initialized"));
  }
  var point = {
    x: pixel.x * this.device_pixel_ratio / this.device_size.width,
    y: pixel.y * this.device_pixel_ratio / this.device_size.height
  };
  this.dirty = true;
  return this.selection.getFeatureAt(point);
};
Scene.prototype.loadTile = function(coords) {
  this.queued_tiles[this.queued_tiles.length] = coords;
};
Scene.prototype.loadQueuedTiles = function() {
  var $__17 = this;
  if (!this.initialized) {
    return;
  }
  if (this.queued_tiles.length === 0) {
    return;
  }
  this.queued_tiles.sort((function(a, b) {
    var ad = Math.abs($__17.center_tile.x - a.x) + Math.abs($__17.center_tile.y - a.y);
    var bd = Math.abs($__17.center_tile.x - b.x) + Math.abs($__17.center_tile.y - b.y);
    return (bd > ad ? -1 : (bd === ad ? 0 : 1));
  }));
  this.queued_tiles.forEach((function(coords) {
    return $__17._loadTile(coords);
  }));
  this.queued_tiles = [];
};
Scene.prototype._loadTile = function(coords) {
  if (coords.z !== this.center_tile.z) {
    return;
  }
  var key = Tile.key(coords);
  var tile;
  if (!this.hasTile(key)) {
    tile = Tile.create({
      coords: coords,
      max_zoom: this.findMaxZoom(),
      worker: this.nextWorker()
    });
    this.cacheTile(tile);
    tile.load(this);
  } else {
    tile = this.tiles[key];
  }
  return tile;
};
Scene.prototype.cacheTile = function(tile) {
  this.tiles[tile.key] = tile;
};
Scene.prototype.hasTile = function(key) {
  return this.tiles[key] !== undefined;
};
Scene.prototype.forgetTile = function(key) {
  delete this.tiles[key];
  if (this.building && this.building.tiles) {
    delete this.building.tiles[key];
  }
};
Scene.prototype.findMaxZoom = function() {
  var max_zoom = this.max_zoom || Geo.max_zoom;
  for (var name in this.sources) {
    var source = this.sources[name];
    if (source.max_zoom < max_zoom) {
      max_zoom = source.max_zoom;
    }
  }
  return max_zoom;
};
Scene.prototype.rebuild = function() {
  return this.rebuildGeometry();
};
Scene.prototype.rebuildGeometry = function() {
  var $__17 = this;
  if (!this.initialized) {
    return Promise.reject(new Error('Scene.rebuildGeometry: scene is not initialized'));
  }
  return new Promise((function(resolve, reject) {
    if ($__17.building) {
      if ($__17.building.queued && $__17.building.queued.reject) {
        log.debug('Scene.rebuildGeometry: request superceded by a newer call');
        $__17.building.queued.resolve(false);
      }
      $__17.building.queued = {
        resolve: resolve,
        reject: reject
      };
      log.trace("Scene.rebuildGeometry(): queuing request");
      return;
    }
    $__17.building = {
      resolve: resolve,
      reject: reject,
      tiles: {}
    };
    if ($__17.debug.profile.geometry_build) {
      $__17._profile('rebuildGeometry');
    }
    $__17.syncConfigToWorker();
    var build = [];
    for (var $__18 = Utils.values($__17.tiles)[$traceurRuntime.toProperty(Symbol.iterator)](),
        $__19; !($__19 = $__18.next()).done; ) {
      var tile = $__19.value;
      {
        if (tile.visible) {
          build.push(tile);
        } else {
          $__17.removeTile(tile.key);
        }
      }
    }
    Tile.sort(build).forEach((function(tile) {
      return tile.build($__17);
    }));
    $__17.updateActiveStyles();
    $__17.resetTime();
    if ($__17.building && Object.keys($__17.building.tiles).length === 0) {
      resolve(false);
      var queued = $__17.building.queued;
      $__17.building = null;
      if (queued) {
        log.debug("Scene: starting queued rebuildGeometry() request");
        $__17.rebuildGeometry().then(queued.resolve, queued.reject);
      }
    }
  })).then((function() {
    if ($__17.debug.profile.geometry_build) {
      $__17._profileEnd('rebuildGeometry');
    }
  }));
};
Scene.prototype.buildTileCompleted = function($__20) {
  var $__21 = $__20,
      tile = $__21.tile,
      worker_id = $__21.worker_id,
      selection_map_size = $__21.selection_map_size;
  this.selection_map_worker_size[worker_id] = selection_map_size;
  this.selection_map_size = 0;
  for (var wid in this.selection_map_worker_size) {
    this.selection_map_size += this.selection_map_worker_size[wid];
  }
  if (this.tiles[tile.key] == null) {
    log.trace(("discarded tile " + tile.key + " in Scene.buildTileCompleted because previously removed"));
    Tile.abortBuild(tile);
  } else {
    var cached = this.tiles[tile.key];
    if (cached) {
      tile = cached.merge(tile);
    }
    if (!tile.error) {
      tile.finalizeBuild(this.styles);
      this.dirty = true;
    } else {
      log.error(("main thread tile load error for " + tile.key + ": " + tile.error));
    }
    tile.printDebug();
  }
  this.trackTileSetLoadStop();
  this.trackTileBuildStop(tile.key);
};
Scene.prototype.trackTileBuildStart = function(key) {
  if (!this.building) {
    this.building = {tiles: {}};
  }
  this.building.tiles[key] = true;
  log.trace(("trackTileBuildStart for " + key + ": " + Object.keys(this.building.tiles).length));
};
Scene.prototype.trackTileBuildStop = function(key) {
  if (this.building) {
    log.trace(("trackTileBuildStop for " + key + ": " + Object.keys(this.building.tiles).length));
    delete this.building.tiles[key];
    if (Object.keys(this.building.tiles).length === 0) {
      log.info("Scene: build geometry finished");
      log.debug(("Scene: updated selection map: " + this.selection_map_size + " features"));
      if (this.building.resolve) {
        this.building.resolve(true);
      }
      var queued = this.building.queued;
      this.building = null;
      if (queued) {
        log.debug("Scene: starting queued rebuildGeometry() request");
        this.rebuildGeometry().then(queued.resolve, queued.reject);
      }
    }
  }
};
Scene.prototype.removeTile = function(key) {
  if (!this.initialized) {
    return;
  }
  log.trace(("tile unload for " + key));
  var tile = this.tiles[key];
  if (tile != null) {
    tile.destroy();
  }
  this.forgetTile(tile.key);
  this.dirty = true;
};
Scene.prototype.loadScene = function() {
  var $__17 = this;
  return Utils.loadResource(this.config_source).then((function(config) {
    $__17.config = config;
    return $__17.preProcessSceneConfig().then((function() {
      $__17.trigger('loadScene', $__17.config);
    }));
  })).catch((function(e) {
    throw e;
  }));
};
Scene.prototype.reload = function() {
  var $__17 = this;
  if (!this.initialized) {
    return;
  }
  this.loadScene().then((function() {
    $__17.updateStyles($__17.gl);
    $__17.syncConfigToWorker();
    return $__17.rebuildGeometry();
  }), (function(error) {
    throw error;
  }));
};
Scene.prototype.loadDataSources = function() {
  for (var name in this.config.sources) {
    var source = this.config.sources[name];
    source.url = Utils.addBaseURL(source.url);
    this.sources[name] = TileSource.create(Object.assign({}, source, {name: name}));
  }
  this.updateBounds();
};
Scene.prototype.setSourceMax = function() {
  var max_zoom = this.findMaxZoom();
  for (var name in this.sources) {
    var source = this.sources[name];
    source.max_zoom = max_zoom;
  }
  return max_zoom;
};
Scene.prototype.preProcessSceneConfig = function() {
  for (var $__18 = Utils.recurseValues(this.config.layers)[$traceurRuntime.toProperty(Symbol.iterator)](),
      $__19; !($__19 = $__18.next()).done; ) {
    var rule = $__19.value;
    {
      if (rule.style) {
        if (rule.style.visible !== false) {
          rule.style.visible = true;
        }
      }
    }
  }
  this.config.cameras = this.config.cameras || {};
  if (this.config.camera) {
    this.config.cameras.default = this.config.camera;
  }
  var camera_names = Object.keys(this.config.cameras);
  if (camera_names.length === 0) {
    this.config.cameras.default = {active: true};
  } else if (!this._active_camera) {
    this.config.cameras[camera_names[0]].active = true;
  }
  this.config.lights = this.config.lights || {};
  return StyleManager.preload(this.config.styles);
};
Scene.prototype.updateStyles = function(gl) {
  if (!this.initialized && !this.initializing) {
    throw new Error('Scene.updateStyles() called before scene was initialized');
  }
  StyleManager.init();
  this.styles = StyleManager.build(this.config.styles);
  if (gl) {
    for (var $__18 = Utils.values(this.styles)[$traceurRuntime.toProperty(Symbol.iterator)](),
        $__19; !($__19 = $__18.next()).done; ) {
      var style = $__19.value;
      {
        style.setGL(gl);
      }
    }
  }
  StyleManager.compile();
  this.updateActiveStyles();
  this.dirty = true;
};
Scene.prototype.updateActiveStyles = function() {
  this.active_styles = {};
  var animated = false;
  for (var $__18 = Utils.recurseValues(this.config.layers)[$traceurRuntime.toProperty(Symbol.iterator)](),
      $__19; !($__19 = $__18.next()).done; ) {
    var rule = $__19.value;
    {
      if (rule.style && rule.style.visible !== false) {
        this.active_styles[rule.style.name || StyleParser.defaults.style.name] = true;
        if (this.styles[rule.style.name || StyleParser.defaults.style.name].animated) {
          animated = true;
        }
      }
    }
  }
  this.animated = animated;
};
Scene.prototype.createCamera = function() {
  this.camera = Camera.create(this._active_camera, this, this.config.cameras[this._active_camera]);
  this.camera.updateScene();
};
Scene.prototype.getActiveCamera = function() {
  return this._active_camera;
};
Scene.prototype.setActiveCamera = function(name) {
  this._active_camera = name;
  this.updateConfig();
  return this._active_camera;
};
Object.defineProperty(Scene.prototype, '_active_camera', {
  get: function() {
    for (var name in this.config.cameras) {
      if (this.config.cameras[name].active) {
        return name;
      }
    }
  },
  set: function(name) {
    var prev = this._active_camera;
    if (this.config.cameras[name]) {
      this.config.cameras[name].active = true;
      if (prev && prev !== name && this.config.cameras[prev]) {
        delete this.config.cameras[prev].active;
      }
    }
  }
});
Scene.prototype.createLights = function() {
  this.lights = {};
  for (var i in this.config.lights) {
    this.config.lights[i].name = i;
    this.lights[i] = Light.create(this, this.config.lights[i]);
  }
  Light.inject(this.lights);
};
Scene.prototype.updateConfig = function() {
  this.createCamera();
  this.createLights();
  this.loadDataSources();
  this.setSourceMax();
  this.updateStyles(this.gl);
  this.syncConfigToWorker();
};
Scene.prototype.syncConfigToWorker = function() {
  var $__17 = this;
  this.config_serialized = Utils.serializeWithFunctions(this.config);
  this.selection_map_worker_size = {};
  this.workers.forEach((function(worker) {
    WorkerBroker.postMessage(worker, 'updateConfig', {config: $__17.config_serialized});
  }));
};
Scene.prototype.resetTime = function() {
  this.start_time = +new Date();
};
Scene.prototype.trackTileSetLoadStart = function() {
  if (this.tile_set_loading == null) {
    this.tile_set_loading = +new Date();
    log.info('Scene: tile set load start');
  }
};
Scene.prototype.trackTileSetLoadStop = function() {
  if (this.tile_set_loading != null) {
    var end_tile_set = true;
    for (var t in this.tiles) {
      if (this.tiles[t].loading === true) {
        end_tile_set = false;
        break;
      }
    }
    if (end_tile_set === true) {
      this.last_tile_set_load = (+new Date()) - this.tile_set_loading;
      this.tile_set_loading = null;
      log.info(("Scene: tile set load finished in " + this.last_tile_set_load + "ms"));
    }
  }
};
Scene.prototype.getDebugSum = function(prop, filter) {
  var sum = 0;
  for (var t in this.tiles) {
    if (this.tiles[t].debug[prop] != null && (typeof filter !== 'function' || filter(this.tiles[t]) === true)) {
      sum += this.tiles[t].debug[prop];
    }
  }
  return sum;
};
Scene.prototype.getDebugAverage = function(prop, filter) {
  return this.getDebugSum(prop, filter) / Object.keys(this.tiles).length;
};
Scene.prototype.workerLogMessage = function(event) {
  var $__22;
  if (event.data.type !== 'log') {
    return;
  }
  var $__20 = event.data,
      worker_id = $__20.worker_id,
      level = $__20.level,
      msg = $__20.msg;
  if (log[level]) {
    ($__22 = log)[level].apply($__22, $traceurRuntime.spread([("worker " + worker_id + ":")], msg));
  } else {
    log.error(("Scene.workerLogMessage: unrecognized log level " + level));
  }
};
Scene.prototype._profile = function(name) {
  console.profile(("main thread: " + name));
  this.workers.forEach((function(w) {
    return WorkerBroker.postMessage(w, 'profile', name);
  }));
};
Scene.prototype._profileEnd = function(name) {
  console.profileEnd(("main thread: " + name));
  this.workers.forEach((function(w) {
    return WorkerBroker.postMessage(w, 'profileEnd', name);
  }));
};


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/scene.js
},{"./camera":66,"./geo":67,"./gl/context":69,"./gl/shader_program":71,"./gl/texture":73,"./light":78,"./selection":83,"./styles/builders":84,"./styles/style_manager":90,"./styles/style_parser":91,"./tile":94,"./tile_source":95,"./utils/subscribe":97,"./utils/utils":98,"./utils/worker_broker":99,"gl-matrix":21,"loglevel":53}],82:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  SceneWorker: {get: function() {
      return SceneWorker;
    }},
  __esModule: {value: true}
});
var $__utils_47_utils__,
    $__utils_47_worker_95_broker__,
    $__scene__,
    $__tile__,
    $__tile_95_source_46_js__,
    $__selection__,
    $__styles_47_style_95_parser__,
    $__styles_47_style_95_manager__,
    $__styles_47_rule__,
    $__styles_47_builders__,
    $__gl_47_texture__;
var Utils = ($__utils_47_utils__ = require("./utils/utils"), $__utils_47_utils__ && $__utils_47_utils__.__esModule && $__utils_47_utils__ || {default: $__utils_47_utils__}).default;
var WorkerBroker = ($__utils_47_worker_95_broker__ = require("./utils/worker_broker"), $__utils_47_worker_95_broker__ && $__utils_47_worker_95_broker__.__esModule && $__utils_47_worker_95_broker__ || {default: $__utils_47_worker_95_broker__}).default;
var Scene = ($__scene__ = require("./scene"), $__scene__ && $__scene__.__esModule && $__scene__ || {default: $__scene__}).default;
var Tile = ($__tile__ = require("./tile"), $__tile__ && $__tile__.__esModule && $__tile__ || {default: $__tile__}).default;
var TileSource = ($__tile_95_source_46_js__ = require("./tile_source.js"), $__tile_95_source_46_js__ && $__tile_95_source_46_js__.__esModule && $__tile_95_source_46_js__ || {default: $__tile_95_source_46_js__}).default;
var FeatureSelection = ($__selection__ = require("./selection"), $__selection__ && $__selection__.__esModule && $__selection__ || {default: $__selection__}).default;
var StyleParser = ($__styles_47_style_95_parser__ = require("./styles/style_parser"), $__styles_47_style_95_parser__ && $__styles_47_style_95_parser__.__esModule && $__styles_47_style_95_parser__ || {default: $__styles_47_style_95_parser__}).StyleParser;
var StyleManager = ($__styles_47_style_95_manager__ = require("./styles/style_manager"), $__styles_47_style_95_manager__ && $__styles_47_style_95_manager__.__esModule && $__styles_47_style_95_manager__ || {default: $__styles_47_style_95_manager__}).StyleManager;
var parseRules = ($__styles_47_rule__ = require("./styles/rule"), $__styles_47_rule__ && $__styles_47_rule__.__esModule && $__styles_47_rule__ || {default: $__styles_47_rule__}).parseRules;
var Builders = ($__styles_47_builders__ = require("./styles/builders"), $__styles_47_builders__ && $__styles_47_builders__.__esModule && $__styles_47_builders__ || {default: $__styles_47_builders__}).default;
var Texture = ($__gl_47_texture__ = require("./gl/texture"), $__gl_47_texture__ && $__gl_47_texture__.__esModule && $__gl_47_texture__ || {default: $__gl_47_texture__}).default;
var SceneWorker = {
  sources: {},
  styles: {},
  rules: {},
  layers: {},
  tiles: {},
  config: {}
};
if (Utils.isWorkerThread) {
  SceneWorker.worker = self;
  Builders.setTileScale(Scene.tile_scale);
  SceneWorker.worker.init = function(worker_id) {
    SceneWorker.worker_id = worker_id;
    FeatureSelection.setPrefix(SceneWorker.worker_id);
    return worker_id;
  };
  SceneWorker.worker.updateConfig = function($__14) {
    var config = $__14.config;
    SceneWorker.config = null;
    SceneWorker.styles = null;
    FeatureSelection.reset();
    config = JSON.parse(config);
    for (var name in config.sources) {
      var source = config.sources[name];
      SceneWorker.sources[name] = TileSource.create(Object.assign(source, {name: name}));
    }
    for (var layer in config.layers) {
      config.layers[layer].geometry = Utils.stringsToFunctions(config.layers[layer].geometry);
    }
    SceneWorker.config = Utils.stringsToFunctions(StyleParser.expandMacros(config), StyleParser.wrapFunction);
    SceneWorker.styles = StyleManager.build(SceneWorker.config.styles);
    SceneWorker.rules = parseRules(SceneWorker.config.layers);
    SceneWorker.syncing_textures = SceneWorker.syncTextures();
    SceneWorker.configuring = SceneWorker.syncing_textures.then((function() {
      SceneWorker.log('debug', "updated config");
    }));
  };
  SceneWorker.awaitConfiguration = function() {
    return SceneWorker.configuring;
  };
  SceneWorker.sliceTile = function(tile, keys) {
    keys = keys || {};
    keys.key = true;
    keys.loading = true;
    keys.loaded = true;
    keys.order = true;
    keys.error = true;
    keys.debug = true;
    var tile_subset = {};
    for (var k in keys) {
      tile_subset[k] = tile[k];
    }
    return tile_subset;
  };
  SceneWorker.worker.buildTile = function($__14) {
    var tile = $__14.tile;
    if (SceneWorker.tiles[tile.key] != null) {
      if (SceneWorker.tiles[tile.key].loading === true) {
        return;
      }
    }
    tile = SceneWorker.tiles[tile.key] = Object.assign(SceneWorker.tiles[tile.key] || {}, tile);
    return SceneWorker.awaitConfiguration().then((function() {
      if (tile.loaded !== true) {
        return new Promise((function(resolve, reject) {
          tile.loading = true;
          tile.loaded = false;
          tile.error = null;
          Promise.all(Object.keys(SceneWorker.sources).map((function(x) {
            return SceneWorker.sources[x].loadTile(tile);
          }))).then((function() {
            tile.loading = false;
            tile.loaded = true;
            Tile.buildGeometry(tile, SceneWorker.config.layers, SceneWorker.rules, SceneWorker.styles).then((function(keys) {
              resolve({
                tile: SceneWorker.sliceTile(tile, keys),
                worker_id: SceneWorker.worker_id,
                selection_map_size: FeatureSelection.map_size
              });
            }));
          })).catch((function(error) {
            tile.loading = false;
            tile.loaded = false;
            tile.error = error.toString();
            SceneWorker.log('error', ("tile load error for " + tile.key + ": " + error.stack));
            resolve({
              tile: SceneWorker.sliceTile(tile),
              worker_id: SceneWorker.worker_id,
              selection_map_size: FeatureSelection.map_size
            });
          }));
        }));
      } else {
        SceneWorker.log('trace', ("used worker cache for tile " + tile.key));
        return Tile.buildGeometry(tile, SceneWorker.config.layers, SceneWorker.rules, SceneWorker.styles).then((function(keys) {
          return {
            tile: SceneWorker.sliceTile(tile, keys),
            worker_id: SceneWorker.worker_id,
            selection_map_size: FeatureSelection.map_size
          };
        }));
      }
    }));
  };
  SceneWorker.worker.removeTile = function(key) {
    var tile = SceneWorker.tiles[key];
    if (tile != null) {
      if (tile.loading === true) {
        SceneWorker.log('trace', ("cancel tile load for " + key));
        tile.loading = false;
      }
      if (tile.request) {
        tile.request.abort();
      }
      delete SceneWorker.tiles[key];
      SceneWorker.log('trace', ("remove tile from cache for " + key));
    }
  };
  SceneWorker.worker.getFeatureSelection = function() {
    var $__14 = arguments[0] !== (void 0) ? arguments[0] : {},
        id = $__14.id,
        key = $__14.key;
    var selection = FeatureSelection.map[key];
    return {
      id: id,
      feature: (selection && selection.feature)
    };
  };
  SceneWorker.syncTextures = function() {
    var textures = [];
    for (var $__11 = Utils.values(SceneWorker.styles)[$traceurRuntime.toProperty(Symbol.iterator)](),
        $__12; !($__12 = $__11.next()).done; ) {
      var style = $__12.value;
      {
        if (style.textures) {
          for (var t in style.textures) {
            if (style.textures[t].sprites) {
              textures.push(style.textureName(t));
            }
          }
        }
      }
    }
    SceneWorker.log('trace', 'sync textures to worker:', textures);
    if (textures.length > 0) {
      return Texture.syncTexturesToWorker(textures);
    }
    return Promise.resolve();
  };
  SceneWorker.log = function(level) {
    for (var msg = [],
        $__13 = 1; $__13 < arguments.length; $__13++)
      msg[$__13 - 1] = arguments[$__13];
    SceneWorker.worker.postMessage({
      type: 'log',
      level: level || 'info',
      worker_id: SceneWorker.worker_id,
      msg: msg
    });
  };
  SceneWorker.worker.profile = function(name) {
    console.profile(("worker " + SceneWorker.worker_id + ": " + name));
  };
  SceneWorker.worker.profileEnd = function(name) {
    console.profileEnd(("worker " + SceneWorker.worker_id + ": " + name));
  };
}


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/scene_worker.js
},{"./gl/texture":73,"./scene":81,"./selection":83,"./styles/builders":84,"./styles/rule":87,"./styles/style_manager":90,"./styles/style_parser":91,"./tile":94,"./tile_source.js":95,"./utils/utils":98,"./utils/worker_broker":99}],83:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  __esModule: {value: true}
});
var $__gl_47_texture__,
    $__utils_47_worker_95_broker__;
var Texture = ($__gl_47_texture__ = require("./gl/texture"), $__gl_47_texture__ && $__gl_47_texture__.__esModule && $__gl_47_texture__ || {default: $__gl_47_texture__}).default;
var WorkerBroker = ($__utils_47_worker_95_broker__ = require("./utils/worker_broker"), $__utils_47_worker_95_broker__ && $__utils_47_worker_95_broker__.__esModule && $__utils_47_worker_95_broker__ || {default: $__utils_47_worker_95_broker__}).default;
var FeatureSelection = function FeatureSelection(gl, workers) {
  this.gl = gl;
  this.workers = workers;
  this.init();
};
($traceurRuntime.createClass)(FeatureSelection, {
  init: function() {
    this.requests = {};
    this.feature = null;
    this.read_delay = 5;
    this.read_delay_timer = null;
    this.pixel = new Uint8Array(4);
    this.pixel32 = new Float32Array(this.pixel.buffer);
    this.fbo = this.gl.createFramebuffer();
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo);
    this.fbo_size = {
      width: 256,
      height: 256
    };
    this.fbo_size.aspect = this.fbo_size.width / this.fbo_size.height;
    var fbo_texture = new Texture(this.gl, 'selection_fbo');
    fbo_texture.setData(this.fbo_size.width, this.fbo_size.height, null, {filtering: 'nearest'});
    this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, fbo_texture.texture, 0);
    var fbo_depth_rb = this.gl.createRenderbuffer();
    this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, fbo_depth_rb);
    this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, this.fbo_size.width, this.fbo_size.height);
    this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, fbo_depth_rb);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
  },
  bind: function() {
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo);
    this.gl.viewport(0, 0, this.fbo_size.width, this.fbo_size.height);
  },
  getFeatureAt: function(point) {
    var $__2 = this;
    return new Promise((function(resolve, reject) {
      $__2.selection_request_id = ($__2.selection_request_id + 1) || 0;
      $__2.requests[$__2.selection_request_id] = {
        type: 'point',
        id: $__2.selection_request_id,
        point: point,
        resolve: resolve
      };
    }));
  },
  pendingRequests: function() {
    return this.requests;
  },
  read: function() {
    var $__2 = this;
    if (this.read_delay_timer != null) {
      clearTimeout(this.read_delay_timer);
    }
    this.read_delay_timer = setTimeout((function() {
      var gl = $__2.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, $__2.fbo);
      for (var r in $__2.requests) {
        var request = $__2.requests[r];
        if (request.sent) {
          continue;
        }
        if (request.type !== 'point') {
          continue;
        }
        gl.readPixels(Math.floor(request.point.x * $__2.fbo_size.width), Math.floor((1 - request.point.y) * $__2.fbo_size.height), 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, $__2.pixel);
        var feature_key = ($__2.pixel[0] + ($__2.pixel[1] << 8) + ($__2.pixel[2] << 16) + ($__2.pixel[3] << 24)) >>> 0;
        var worker_id = $__2.pixel[3];
        if (worker_id !== 255) {
          if ($__2.workers[worker_id] != null) {
            WorkerBroker.postMessage($__2.workers[worker_id], 'getFeatureSelection', {
              id: request.id,
              key: feature_key
            }).then((function(message) {
              $__2.finishRead(message);
            }));
          }
        } else {
          $__2.finishRead({
            id: request.id,
            feature: null
          });
        }
        request.sent = true;
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }), this.read_delay);
  },
  finishRead: function(message) {
    var request = this.requests[message.id];
    if (!request) {
      throw new Error("FeatureSelection.finishRead() called without any message");
    }
    var feature = message.feature;
    var changed = false;
    if ((feature != null && this.feature == null) || (feature == null && this.feature != null) || (feature != null && this.feature != null && feature.id !== this.feature.id)) {
      changed = true;
    }
    this.feature = feature;
    request.resolve({
      feature: feature,
      changed: changed,
      request: request
    });
    delete this.requests[message.id];
  }
}, {
  makeEntry: function() {
    this.map_size++;
    var ir = this.map_size & 255;
    var ig = (this.map_size >> 8) & 255;
    var ib = (this.map_size >> 16) & 255;
    var ia = this.map_prefix;
    var r = ir / 255;
    var g = ig / 255;
    var b = ib / 255;
    var a = ia / 255;
    var key = (ir + (ig << 8) + (ib << 16) + (ia << 24)) >>> 0;
    this.map[key] = {color: [r, g, b, a]};
    return this.map[key];
  },
  makeColor: function(feature) {
    var selector = this.makeEntry();
    selector.feature = {
      id: feature.id,
      properties: feature.properties
    };
    return selector.color;
  },
  reset: function() {
    this.map = {};
    this.map_size = 1;
  },
  setPrefix: function(prefix) {
    this.map_prefix = prefix;
  }
});
var $__default = FeatureSelection;
FeatureSelection.map = {};
FeatureSelection.map_size = 1;
FeatureSelection.map_prefix = 0;
FeatureSelection.defaultColor = [0, 0, 0, 1];


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/selection.js
},{"./gl/texture":73,"./utils/worker_broker":99}],84:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  __esModule: {value: true}
});
var $___46__46__47_vector__,
    $___46__46__47_geo__,
    $__earcut__;
var Vector = ($___46__46__47_vector__ = require("../vector"), $___46__46__47_vector__ && $___46__46__47_vector__.__esModule && $___46__46__47_vector__ || {default: $___46__46__47_vector__}).Vector;
var Geo = ($___46__46__47_geo__ = require("../geo"), $___46__46__47_geo__ && $___46__46__47_geo__.__esModule && $___46__46__47_geo__ || {default: $___46__46__47_geo__}).default;
var earcut = ($__earcut__ = require("earcut"), $__earcut__ && $__earcut__.__esModule && $__earcut__ || {default: $__earcut__}).default;
var Builders;
var $__default = Builders = {};
Builders.debug = false;
Builders.scaleTexcoordsToSprite = function(uv, area_origin, area_size, tex_size) {
  var area_origin_y = tex_size[1] - area_origin[1] - area_size[1];
  var suv = [];
  suv[0] = (uv[0] * area_size[0] + area_origin[0]) / tex_size[0];
  suv[1] = (uv[1] * area_size[1] + area_origin_y) / tex_size[1];
  return suv;
};
Builders.getTexcoordsForSprite = function(area_origin, area_size, tex_size) {
  return [Builders.scaleTexcoordsToSprite([0, 0], area_origin, area_size, tex_size), Builders.scaleTexcoordsToSprite([1, 1], area_origin, area_size, tex_size)];
};
Builders.buildPolygons = function(polygons, vertex_data, vertex_template, $__3) {
  var $__4 = $__3,
      texcoord_index = $__4.texcoord_index,
      texcoord_scale = $__4.texcoord_scale;
  var $__5 = texcoord_scale || [[0, 0], [1, 1]],
      $__6 = $__5[0],
      min_u = $__6[0],
      min_v = $__6[1],
      $__7 = $__5[1],
      max_u = $__7[0],
      max_v = $__7[1];
  var num_polygons = polygons.length;
  for (var p = 0; p < num_polygons; p++) {
    var polygon = polygons[p];
    if (texcoord_index) {
      var $__8 = Geo.findBoundingBox(polygon),
          min_x = $__8[0],
          min_y = $__8[1],
          max_x = $__8[2],
          max_y = $__8[3];
      var span_x = max_x - min_x;
      var span_y = max_y - min_y;
      var scale_u = (max_u - min_u) / span_x;
      var scale_v = (max_v - min_v) / span_y;
    }
    var vertices = Builders.triangulatePolygon(polygon);
    var num_vertices = vertices.length;
    for (var v = 0; v < num_vertices; v++) {
      var vertex = vertices[v];
      vertex_template[0] = vertex[0];
      vertex_template[1] = vertex[1];
      if (texcoord_index) {
        vertex_template[texcoord_index + 0] = (vertex[0] - min_x) * scale_u + min_u;
        vertex_template[texcoord_index + 1] = (vertex[1] - min_y) * scale_v + min_v;
      }
      vertex_data.addVertex(vertex_template);
    }
  }
};
Builders.buildExtrudedPolygons = function(polygons, z, height, min_height, vertex_data, vertex_template, normal_index, $__3) {
  var $__4 = $__3,
      texcoord_index = $__4.texcoord_index,
      texcoord_scale = $__4.texcoord_scale;
  var min_z = z + (min_height || 0);
  var max_z = z + height;
  vertex_template[2] = max_z;
  Builders.buildPolygons(polygons, vertex_data, vertex_template, {texcoord_index: texcoord_index});
  var $__5 = texcoord_scale || [[0, 0], [1, 1]],
      $__6 = $__5[0],
      min_u = $__6[0],
      min_v = $__6[1],
      $__7 = $__5[1],
      max_u = $__7[0],
      max_v = $__7[1];
  if (texcoord_index) {
    var texcoords = [[min_u, max_v], [min_u, min_v], [max_u, min_v], [max_u, min_v], [max_u, max_v], [min_u, max_v]];
  }
  var num_polygons = polygons.length;
  for (var p = 0; p < num_polygons; p++) {
    var polygon = polygons[p];
    for (var q = 0; q < polygon.length; q++) {
      var contour = polygon[q];
      for (var w = 0; w < contour.length - 1; w++) {
        var wall_vertices = [[contour[w + 1][0], contour[w + 1][1], max_z], [contour[w + 1][0], contour[w + 1][1], min_z], [contour[w][0], contour[w][1], min_z], [contour[w][0], contour[w][1], min_z], [contour[w][0], contour[w][1], max_z], [contour[w + 1][0], contour[w + 1][1], max_z]];
        var normal = Vector.cross([0, 0, 1], Vector.normalize([contour[w + 1][0] - contour[w][0], contour[w + 1][1] - contour[w][1], 0]));
        vertex_template[normal_index + 0] = normal[0];
        vertex_template[normal_index + 1] = normal[1];
        vertex_template[normal_index + 2] = normal[2];
        for (var wv = 0; wv < wall_vertices.length; wv++) {
          vertex_template[0] = wall_vertices[wv][0];
          vertex_template[1] = wall_vertices[wv][1];
          vertex_template[2] = wall_vertices[wv][2];
          if (texcoord_index) {
            vertex_template[texcoord_index + 0] = texcoords[wv][0];
            vertex_template[texcoord_index + 1] = texcoords[wv][1];
          }
          vertex_data.addVertex(vertex_template);
        }
      }
    }
  }
};
Builders.buildPolylines = function(lines, width, vertex_data, vertex_template, $__3) {
  var $__4 = $__3,
      closed_polygon = $__4.closed_polygon,
      remove_tile_edges = $__4.remove_tile_edges,
      tile_edge_tolerance = $__4.tile_edge_tolerance,
      texcoord_index = $__4.texcoord_index,
      texcoord_scale = $__4.texcoord_scale,
      scaling_index = $__4.scaling_index,
      join = $__4.join,
      cap = $__4.cap;
  var cornersOnCap = (cap === "square") ? 2 : ((cap === "round") ? 4 : 0);
  var trianglesOnJoin = (join === "bevel") ? 1 : ((join === "round") ? 5 : 0);
  var $__5 = texcoord_scale || [[0, 0], [1, 1]],
      $__6 = $__5[0],
      min_u = $__6[0],
      min_v = $__6[1],
      $__7 = $__5[1],
      max_u = $__7[0],
      max_v = $__7[1];
  var constants = {
    vertex_data: vertex_data,
    vertex_template: vertex_template,
    halfWidth: width / 2,
    vertices: [],
    scaling_index: scaling_index,
    scalingVecs: scaling_index && [],
    texcoord_index: texcoord_index,
    texcoords: texcoord_index && [],
    min_u: min_u,
    min_v: min_v,
    max_u: max_u,
    max_v: max_v,
    nPairs: 0
  };
  for (var ln = 0; ln < lines.length; ln++) {
    var line = lines[ln];
    var lineSize = line.length;
    if (lineSize < 2) {
      continue;
    }
    var coordPrev = [0, 0],
        coordCurr = [0, 0],
        coordNext = [0, 0];
    var normPrev = [0, 0],
        normCurr = [0, 0],
        normNext = [0, 0];
    var isPrev = false,
        isNext = true;
    indexPairs(constants);
    for (var i = 0; i < lineSize; i++) {
      isNext = i + 1 < lineSize;
      if (isPrev) {
        coordPrev = coordCurr;
        normPrev = Vector.normalize(Vector.perp(coordPrev, line[i]));
      } else if (i === 0 && closed_polygon === true) {
        var needToClose = true;
        if (remove_tile_edges) {
          if (Builders.isOnTileEdge(line[i], line[lineSize - 2], {tile_edge_tolerance: tile_edge_tolerance})) {
            needToClose = false;
          }
        }
        if (needToClose) {
          coordPrev = line[lineSize - 2];
          normPrev = Vector.normalize(Vector.perp(coordPrev, line[i]));
          isPrev = true;
        }
      }
      coordCurr = line[i];
      if (isNext) {
        coordNext = line[i + 1];
      } else if (closed_polygon === true) {
        coordNext = line[1];
        isNext = true;
      }
      if (isNext) {
        normNext = Vector.normalize(Vector.perp(coordCurr, coordNext));
        if (remove_tile_edges) {
          if (Builders.isOnTileEdge(coordCurr, coordNext, {tile_edge_tolerance: tile_edge_tolerance})) {
            normCurr = Vector.normalize(Vector.perp(coordPrev, coordCurr));
            if (isPrev) {
              addVertexPair(coordCurr, normCurr, i / lineSize, constants);
              constants.nPairs++;
              indexPairs(constants);
            }
            isPrev = false;
            continue;
          }
        }
      }
      if (isPrev) {
        if (isNext) {
          normCurr = Vector.normalize(Vector.add(normPrev, normNext));
          var scale = 2 / (1 + Math.abs(Vector.dot(normPrev, normCurr)));
          normCurr = Vector.mult(normCurr, scale * scale);
        } else {
          normCurr = Vector.normalize(Vector.perp(coordPrev, coordCurr));
        }
      } else {
        if (isNext) {
          normNext = Vector.normalize(Vector.perp(coordCurr, coordNext));
          normCurr = normNext;
        } else {
          continue;
        }
      }
      if (isPrev || isNext) {
        if (i === 0 && !isPrev && !closed_polygon) {
          addCap(coordCurr, normCurr, cornersOnCap, true, constants);
        }
        if (trianglesOnJoin !== 0 && isPrev && isNext) {
          addJoin([coordPrev, coordCurr, coordNext], [normPrev, normCurr, normNext], i / lineSize, trianglesOnJoin, constants);
        } else {
          addVertexPair(coordCurr, normCurr, i / (lineSize - 1), constants);
        }
        if (isNext) {
          constants.nPairs++;
        }
        isPrev = true;
      }
    }
    indexPairs(constants);
    if (!closed_polygon) {
      addCap(coordCurr, normCurr, cornersOnCap, false, constants);
    }
  }
};
function addVertex(coord, normal, uv, $__3) {
  var $__4 = $__3,
      halfWidth = $__4.halfWidth,
      vertices = $__4.vertices,
      scalingVecs = $__4.scalingVecs,
      texcoords = $__4.texcoords;
  if (scalingVecs) {
    vertices.push(coord);
    scalingVecs.push(normal);
  } else {
    vertices.push([coord[0] + normal[0] * halfWidth, coord[1] + normal[1] * halfWidth]);
  }
  if (texcoords) {
    texcoords.push(uv);
  }
}
function addVertexPair(coord, normal, v_pct, constants) {
  addVertex(coord, normal, [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v], constants);
  addVertex(coord, Vector.neg(normal), [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v], constants);
}
function addFan(coord, nA, nC, nB, uA, uC, uB, signed, numTriangles, constants) {
  if (numTriangles < 1) {
    return;
  }
  indexPairs(constants);
  var normCurr = Vector.set(nA);
  var normPrev = [0, 0];
  var angle_delta = Vector.dot(nA, nB);
  if (angle_delta < -1) {
    angle_delta = -1;
  }
  angle_delta = Math.acos(angle_delta) / numTriangles;
  if (!signed) {
    angle_delta *= -1;
  }
  var uvCurr = Vector.set(uA);
  var uv_delta = Vector.div(Vector.sub(uB, uA), numTriangles);
  addVertex(coord, nC, uC, constants);
  addVertex(coord, normCurr, uA, constants);
  for (var t = 0; t < numTriangles; t++) {
    normPrev = Vector.normalize(normCurr);
    normCurr = Vector.rot(Vector.normalize(normCurr), angle_delta);
    if (numTriangles === 4 && (t === 0 || t === numTriangles - 2)) {
      var scale = 2 / (1 + Math.abs(Vector.dot(normPrev, normCurr)));
      normCurr = Vector.mult(normCurr, scale * scale);
    }
    uvCurr = Vector.add(uvCurr, uv_delta);
    addVertex(coord, normCurr, uvCurr, constants);
  }
  for (var i = 0; i < numTriangles; i++) {
    if (signed) {
      addIndex(i + 2, constants);
      addIndex(0, constants);
      addIndex(i + 1, constants);
    } else {
      addIndex(i + 1, constants);
      addIndex(0, constants);
      addIndex(i + 2, constants);
    }
  }
  constants.vertices = [];
  if (constants.scalingVecs) {
    constants.scalingVecs = [];
  }
  if (constants.texcoords) {
    constants.texcoords = [];
  }
}
function addJoin(coords, normals, v_pct, nTriangles, constants) {
  var T = [Vector.set(normals[0]), Vector.set(normals[1]), Vector.set(normals[2])];
  var signed = Vector.signed_area(coords[0], coords[1], coords[2]) > 0;
  var nA = T[0],
      nC = Vector.neg(T[1]),
      nB = T[2];
  var uA = [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v],
      uC = [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v],
      uB = [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];
  if (signed) {
    addVertex(coords[1], nA, uA, constants);
    addVertex(coords[1], nC, uC, constants);
  } else {
    nA = Vector.neg(T[0]);
    nC = T[1];
    nB = Vector.neg(T[2]);
    uA = [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];
    uC = [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];
    uB = [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];
    addVertex(coords[1], nC, uC, constants);
    addVertex(coords[1], nA, uA, constants);
  }
  addFan(coords[1], nA, nC, nB, uA, uC, uB, signed, nTriangles, constants);
  if (signed) {
    addVertex(coords[1], nB, uB, constants);
    addVertex(coords[1], nC, uC, constants);
  } else {
    addVertex(coords[1], nC, uC, constants);
    addVertex(coords[1], nB, uB, constants);
  }
}
function addCap(coord, normal, numCorners, isBeginning, constants) {
  if (numCorners < 1) {
    return;
  }
  var uvA = [constants.min_u, constants.min_v],
      uvC = [constants.min_u + (constants.max_u - constants.min_u) / 2, constants.min_v],
      uvB = [constants.max_u, constants.min_v];
  if (!isBeginning) {
    uvA = [constants.min_u, constants.max_v], uvC = [constants.min_u + (constants.max_u - constants.min_u) / 2, constants.max_v], uvB = [constants.max_u, constants.max_v];
  }
  addFan(coord, Vector.neg(normal), [0, 0], normal, uvA, uvC, uvB, isBeginning, numCorners * 2, constants);
}
function addIndex(index, $__3) {
  var $__4 = $__3,
      vertex_data = $__4.vertex_data,
      vertex_template = $__4.vertex_template,
      halfWidth = $__4.halfWidth,
      vertices = $__4.vertices,
      scaling_index = $__4.scaling_index,
      scalingVecs = $__4.scalingVecs,
      texcoord_index = $__4.texcoord_index,
      texcoords = $__4.texcoords;
  if (index >= vertices.length) {
    return;
  }
  vertex_template[0] = vertices[index][0];
  vertex_template[1] = vertices[index][1];
  if (texcoord_index) {
    vertex_template[texcoord_index + 0] = texcoords[index][0];
    vertex_template[texcoord_index + 1] = texcoords[index][1];
  }
  if (scaling_index) {
    vertex_template[scaling_index + 0] = scalingVecs[index][0];
    vertex_template[scaling_index + 1] = scalingVecs[index][1];
    vertex_template[scaling_index + 2] = halfWidth;
  }
  vertex_data.addVertex(vertex_template);
}
function indexPairs(constants) {
  for (var i = 0; i < constants.nPairs; i++) {
    addIndex(2 * i + 2, constants);
    addIndex(2 * i + 1, constants);
    addIndex(2 * i + 0, constants);
    addIndex(2 * i + 2, constants);
    addIndex(2 * i + 3, constants);
    addIndex(2 * i + 1, constants);
  }
  constants.nPairs = 0;
  constants.vertices = [];
  if (constants.scalingVecs) {
    constants.scalingVecs = [];
  }
  if (constants.texcoords) {
    constants.texcoords = [];
  }
}
Builders.buildQuadsForPoints = function(points, width, height, vertex_data, vertex_template, $__3) {
  var $__4 = $__3,
      texcoord_index = $__4.texcoord_index,
      texcoord_scale = $__4.texcoord_scale;
  if (texcoord_index) {
    var $__5 = texcoord_scale || [[0, 0], [1, 1]],
        $__6 = $__5[0],
        min_u = $__6[0],
        min_v = $__6[1],
        $__7 = $__5[1],
        max_u = $__7[0],
        max_v = $__7[1];
    var texcoords = [[min_u, min_v], [max_u, min_v], [max_u, max_v], [min_u, min_v], [max_u, max_v], [min_u, max_v]];
  }
  var num_points = points.length;
  for (var p = 0; p < num_points; p++) {
    var point = points[p];
    var positions = [[point[0] - width / 2, point[1] - height / 2], [point[0] + width / 2, point[1] - height / 2], [point[0] + width / 2, point[1] + height / 2], [point[0] - width / 2, point[1] - height / 2], [point[0] + width / 2, point[1] + height / 2], [point[0] - width / 2, point[1] + height / 2]];
    for (var pos = 0; pos < 6; pos++) {
      if (texcoord_index) {
        vertex_template[texcoord_index + 0] = texcoords[pos][0];
        vertex_template[texcoord_index + 1] = texcoords[pos][1];
      }
      vertex_template[0] = positions[pos][0];
      vertex_template[1] = positions[pos][1];
      vertex_data.addVertex(vertex_template);
    }
  }
};
Builders.buildSpriteQuadsForPoints = function(points, width, height, angle, scale, vertex_data, vertex_template, scaling_index, $__3) {
  var $__4 = $__3,
      texcoord_index = $__4.texcoord_index,
      texcoord_scale = $__4.texcoord_scale;
  var w2 = width / 2;
  var h2 = height / 2;
  var scaling = [[-w2, -h2], [w2, -h2], [w2, h2], [-w2, -h2], [w2, h2], [-w2, h2]];
  var $__5 = texcoord_scale || [[0, 0], [1, 1]],
      $__6 = $__5[0],
      min_u = $__6[0],
      min_v = $__6[1],
      $__7 = $__5[1],
      max_u = $__7[0],
      max_v = $__7[1];
  var texcoords;
  if (texcoord_index) {
    texcoords = [[min_u, min_v], [max_u, min_v], [max_u, max_v], [min_u, min_v], [max_u, max_v], [min_u, max_v]];
  }
  var num_points = points.length;
  for (var p = 0; p < num_points; p++) {
    var point = points[p];
    for (var pos = 0; pos < 6; pos++) {
      if (texcoord_index) {
        vertex_template[texcoord_index + 0] = texcoords[pos][0];
        vertex_template[texcoord_index + 1] = texcoords[pos][1];
      }
      vertex_template[0] = point[0];
      vertex_template[1] = point[1];
      vertex_template[scaling_index + 0] = scaling[pos][0];
      vertex_template[scaling_index + 1] = scaling[pos][1];
      vertex_template[scaling_index + 2] = angle;
      vertex_template[scaling_index + 3] = scale;
      vertex_data.addVertex(vertex_template);
    }
  }
};
Builders.triangulatePolygon = function(contours) {
  return earcut(contours);
};
Builders.isOnTileEdge = function(pa, pb, options) {
  options = options || {};
  var tolerance_function = options.tolerance_function || Builders.valuesWithinTolerance;
  var tolerance = options.tolerance || 3;
  var tile_min = Builders.tile_bounds[0];
  var tile_max = Builders.tile_bounds[1];
  var edge = null;
  if (tolerance_function(pa[0], tile_min.x, tolerance) && tolerance_function(pb[0], tile_min.x, tolerance)) {
    edge = 'left';
  } else if (tolerance_function(pa[0], tile_max.x, tolerance) && tolerance_function(pb[0], tile_max.x, tolerance)) {
    edge = 'right';
  } else if (tolerance_function(pa[1], tile_min.y, tolerance) && tolerance_function(pb[1], tile_min.y, tolerance)) {
    edge = 'top';
  } else if (tolerance_function(pa[1], tile_max.y, tolerance) && tolerance_function(pb[1], tile_max.y, tolerance)) {
    edge = 'bottom';
  }
  return edge;
};
Builders.setTileScale = function(scale) {
  Builders.tile_bounds = [{
    x: 0,
    y: 0
  }, {
    x: scale,
    y: -scale
  }];
};
Builders.valuesWithinTolerance = function(a, b, tolerance) {
  tolerance = tolerance || 1;
  return (Math.abs(a - b) < tolerance);
};
Builders.buildZigzagLineTestPattern = function() {
  var min = {
    x: 0,
    y: 0
  };
  var max = {
    x: 4096,
    y: 4096
  };
  var g = {
    id: 123,
    geometry: {
      type: 'LineString',
      coordinates: [[min.x * 0.75 + max.x * 0.25, min.y * 0.75 + max.y * 0.25], [min.x * 0.75 + max.x * 0.25, min.y * 0.5 + max.y * 0.5], [min.x * 0.25 + max.x * 0.75, min.y * 0.75 + max.y * 0.25], [min.x * 0.25 + max.x * 0.75, min.y * 0.25 + max.y * 0.75], [min.x * 0.4 + max.x * 0.6, min.y * 0.5 + max.y * 0.5], [min.x * 0.5 + max.x * 0.5, min.y * 0.25 + max.y * 0.75], [min.x * 0.75 + max.x * 0.25, min.y * 0.25 + max.y * 0.75], [min.x * 0.75 + max.x * 0.25, min.y * 0.4 + max.y * 0.6]]
    },
    properties: {kind: 'debug'}
  };
  return g;
};


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/styles/builders.js
},{"../geo":67,"../vector":100,"earcut":19}],85:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  Points: {get: function() {
      return Points;
    }},
  __esModule: {value: true}
});
var $___46__46__47_style__,
    $___46__46__47_style_95_parser__,
    $___46__46__47__46__46__47_gl_47_constants__,
    $___46__46__47__46__46__47_gl_47_vertex_95_layout__,
    $___46__46__47_builders__;
var Style = ($___46__46__47_style__ = require("../style"), $___46__46__47_style__ && $___46__46__47_style__.__esModule && $___46__46__47_style__ || {default: $___46__46__47_style__}).Style;
var StyleParser = ($___46__46__47_style_95_parser__ = require("../style_parser"), $___46__46__47_style_95_parser__ && $___46__46__47_style_95_parser__.__esModule && $___46__46__47_style_95_parser__ || {default: $___46__46__47_style_95_parser__}).StyleParser;
var gl = ($___46__46__47__46__46__47_gl_47_constants__ = require("../../gl/constants"), $___46__46__47__46__46__47_gl_47_constants__ && $___46__46__47__46__46__47_gl_47_constants__.__esModule && $___46__46__47__46__46__47_gl_47_constants__ || {default: $___46__46__47__46__46__47_gl_47_constants__}).default;
var VertexLayout = ($___46__46__47__46__46__47_gl_47_vertex_95_layout__ = require("../../gl/vertex_layout"), $___46__46__47__46__46__47_gl_47_vertex_95_layout__ && $___46__46__47__46__46__47_gl_47_vertex_95_layout__.__esModule && $___46__46__47__46__46__47_gl_47_vertex_95_layout__ || {default: $___46__46__47__46__46__47_gl_47_vertex_95_layout__}).default;
var Builders = ($___46__46__47_builders__ = require("../builders"), $___46__46__47_builders__ && $___46__46__47_builders__.__esModule && $___46__46__47_builders__ || {default: $___46__46__47_builders__}).default;
var Points = Object.create(Style);
Object.assign(Points, {
  name: 'points',
  built_in: true,
  init: function() {
    Style.init.apply(this);
    this.vertex_shader_key = 'styles/points/points.vertex';
    this.fragment_shader_key = 'styles/points/points.fragment';
    this.selection = true;
    this.vertex_layout = new VertexLayout([{
      name: 'a_position',
      size: 3,
      type: gl.FLOAT,
      normalized: false
    }, {
      name: 'a_texcoord',
      size: 2,
      type: gl.FLOAT,
      normalized: false
    }, {
      name: 'a_color',
      size: 4,
      type: gl.UNSIGNED_BYTE,
      normalized: true
    }, {
      name: 'a_selection_color',
      size: 4,
      type: gl.UNSIGNED_BYTE,
      normalized: true
    }, {
      name: 'a_layer',
      size: 1,
      type: gl.FLOAT,
      normalized: false
    }]);
  },
  _parseFeature: function(feature, rule_style, context) {
    var style = this.feature_style;
    style.color = rule_style.color && StyleParser.parseColor(rule_style.color, context);
    style.size = rule_style.size && StyleParser.parseDistance(rule_style.size, context);
    style.z = (rule_style.z && StyleParser.parseDistance(rule_style.z || 0, context)) || StyleParser.defaults.z;
    return style;
  },
  makeVertexTemplate: function(style) {
    return [0, 0, style.z, 0, 0, style.color[0] * 255, style.color[1] * 255, style.color[2] * 255, style.color[3] * 255, style.selection_color[0] * 255, style.selection_color[1] * 255, style.selection_color[2] * 255, style.selection_color[3] * 255, style.order];
  },
  buildPoints: function(points, style, vertex_data) {
    if (!style.color || !style.size) {
      return;
    }
    var vertex_template = this.makeVertexTemplate(style);
    Builders.buildQuadsForPoints(points, style.size[0] || style.size, style.size[1] || style.size, vertex_data, vertex_template, {texcoord_index: this.vertex_layout.index.a_texcoord});
  }
});


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/styles/points/points.js
},{"../../gl/constants":68,"../../gl/vertex_layout":76,"../builders":84,"../style":89,"../style_parser":91}],86:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  Polygons: {get: function() {
      return Polygons;
    }},
  __esModule: {value: true}
});
var $___46__46__47_style__,
    $___46__46__47_style_95_parser__,
    $___46__46__47__46__46__47_gl_47_constants__,
    $___46__46__47__46__46__47_gl_47_vertex_95_layout__,
    $___46__46__47_builders__;
var Style = ($___46__46__47_style__ = require("../style"), $___46__46__47_style__ && $___46__46__47_style__.__esModule && $___46__46__47_style__ || {default: $___46__46__47_style__}).Style;
var StyleParser = ($___46__46__47_style_95_parser__ = require("../style_parser"), $___46__46__47_style_95_parser__ && $___46__46__47_style_95_parser__.__esModule && $___46__46__47_style_95_parser__ || {default: $___46__46__47_style_95_parser__}).StyleParser;
var gl = ($___46__46__47__46__46__47_gl_47_constants__ = require("../../gl/constants"), $___46__46__47__46__46__47_gl_47_constants__ && $___46__46__47__46__46__47_gl_47_constants__.__esModule && $___46__46__47__46__46__47_gl_47_constants__ || {default: $___46__46__47__46__46__47_gl_47_constants__}).default;
var VertexLayout = ($___46__46__47__46__46__47_gl_47_vertex_95_layout__ = require("../../gl/vertex_layout"), $___46__46__47__46__46__47_gl_47_vertex_95_layout__ && $___46__46__47__46__46__47_gl_47_vertex_95_layout__.__esModule && $___46__46__47__46__46__47_gl_47_vertex_95_layout__ || {default: $___46__46__47__46__46__47_gl_47_vertex_95_layout__}).default;
var Builders = ($___46__46__47_builders__ = require("../builders"), $___46__46__47_builders__ && $___46__46__47_builders__.__esModule && $___46__46__47_builders__ || {default: $___46__46__47_builders__}).default;
var Polygons = Object.create(Style);
Object.assign(Polygons, {
  name: 'polygons',
  built_in: true,
  init: function() {
    Style.init.apply(this);
    this.vertex_shader_key = 'styles/polygons/polygons.vertex';
    this.fragment_shader_key = 'styles/polygons/polygons.fragment';
    this.defines['WORLD_POSITION_WRAP'] = 100000;
    this.selection = true;
    var attribs = [{
      name: 'a_position',
      size: 3,
      type: gl.FLOAT,
      normalized: false
    }, {
      name: 'a_normal',
      size: 3,
      type: gl.FLOAT,
      normalized: false
    }, {
      name: 'a_color',
      size: 4,
      type: gl.UNSIGNED_BYTE,
      normalized: true
    }, {
      name: 'a_selection_color',
      size: 4,
      type: gl.UNSIGNED_BYTE,
      normalized: true
    }, {
      name: 'a_layer',
      size: 1,
      type: gl.FLOAT,
      normalized: false
    }];
    if (this.texcoords) {
      this.defines['TEXTURE_COORDS'] = true;
      attribs.push({
        name: 'a_texcoord',
        size: 2,
        type: gl.FLOAT,
        normalized: false
      });
    }
    this.vertex_layout = new VertexLayout(attribs);
  },
  _parseFeature: function(feature, rule_style, context) {
    var style = this.feature_style;
    style.color = rule_style.color && StyleParser.parseColor(rule_style.color, context);
    style.width = rule_style.width && StyleParser.parseDistance(rule_style.width, context);
    style.z = (rule_style.z && StyleParser.parseDistance(rule_style.z || 0, context)) || StyleParser.defaults.z;
    style.texture = rule_style.texture;
    style.sprite = rule_style.sprite;
    style.size = rule_style.size && StyleParser.parseDistance(rule_style.size, context);
    style.height = feature.properties.height || StyleParser.defaults.height;
    style.min_height = feature.properties.min_height || StyleParser.defaults.min_height;
    style.extrude = rule_style.extrude;
    if (style.extrude) {
      if (typeof style.extrude === 'function') {
        style.extrude = style.extrude(context);
      }
      if (typeof style.extrude === 'number') {
        style.height = style.extrude;
      } else if (Array.isArray(style.extrude)) {
        style.min_height = style.extrude[0];
        style.height = style.extrude[1];
      }
    }
    style.cap = rule_style.cap;
    style.join = rule_style.join;
    style.outline = style.outline || {};
    if (rule_style.outline) {
      style.outline.color = StyleParser.parseColor(rule_style.outline.color, context);
      style.outline.width = StyleParser.parseDistance(rule_style.outline.width, context);
      style.outline.tile_edges = rule_style.outline.tile_edges;
      style.outline.cap = rule_style.outline.cap || rule_style.cap;
      style.outline.join = rule_style.outline.join || rule_style.join;
    } else {
      style.outline.color = null;
      style.outline.width = null;
      style.outline.tile_edges = false;
    }
    if (this.texcoords) {
      this.setTexcoordScale(style);
    }
    return style;
  },
  makeVertexTemplate: function(style) {
    var color = style.color || [0, 0, 0, 1];
    var template = [0, 0, style.z || 0, 0, 0, 1, color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255, style.selection_color[0] * 255, style.selection_color[1] * 255, style.selection_color[2] * 255, style.selection_color[3] * 255, style.order];
    if (this.texcoords) {
      template.push(0, 0);
    }
    return template;
  },
  buildPolygons: function(polygons, style, vertex_data) {
    var vertex_template = this.makeVertexTemplate(style);
    if (style.color) {
      if (style.extrude && style.height) {
        Builders.buildExtrudedPolygons(polygons, style.z, style.height, style.min_height, vertex_data, vertex_template, this.vertex_layout.index.a_normal, {
          texcoord_index: this.vertex_layout.index.a_texcoord,
          texcoord_scale: this.texcoord_scale
        });
      } else {
        Builders.buildPolygons(polygons, vertex_data, vertex_template, {
          texcoord_index: this.vertex_layout.index.a_texcoord,
          texcoord_scale: this.texcoord_scale
        });
      }
    }
    if (style.outline && style.outline.color && style.outline.width) {
      var color_index = this.vertex_layout.index.a_color;
      vertex_template[color_index + 0] = style.outline.color[0] * 255;
      vertex_template[color_index + 1] = style.outline.color[1] * 255;
      vertex_template[color_index + 2] = style.outline.color[2] * 255;
      vertex_template[this.vertex_layout.index.a_layer] += 0.0001;
      for (var mpc = 0; mpc < polygons.length; mpc++) {
        Builders.buildPolylines(polygons[mpc], style.outline.width, vertex_data, vertex_template, {
          join: style.outline.join,
          texcoord_index: this.vertex_layout.index.a_texcoord,
          texcoord_scale: this.texcoord_scale,
          closed_polygon: true,
          remove_tile_edges: !style.outline.tile_edges
        });
      }
    }
  },
  buildLines: function(lines, style, vertex_data) {
    var vertex_template = this.makeVertexTemplate(style);
    if (style.color && style.width) {
      Builders.buildPolylines(lines, style.width, vertex_data, vertex_template, {
        cap: style.cap,
        join: style.join,
        texcoord_index: this.vertex_layout.index.a_texcoord,
        texcoord_scale: this.texcoord_scale
      });
    }
    if (style.outline && style.outline.color && style.outline.width) {
      var color_index = this.vertex_layout.index.a_color;
      vertex_template[color_index + 0] = style.outline.color[0] * 255;
      vertex_template[color_index + 1] = style.outline.color[1] * 255;
      vertex_template[color_index + 2] = style.outline.color[2] * 255;
      vertex_template[this.vertex_layout.index.a_layer] -= 0.0001;
      Builders.buildPolylines(lines, style.width + 2 * style.outline.width, vertex_data, vertex_template, {
        cap: style.outline.cap,
        join: style.outline.join,
        texcoord_index: this.vertex_layout.index.a_texcoord,
        texcoord_scale: this.texcoord_scale
      });
    }
  },
  buildPoints: function(points, style, vertex_data) {
    if (!style.color || !style.size) {
      return;
    }
    var vertex_template = this.makeVertexTemplate(style);
    Builders.buildQuadsForPoints(points, style.size[0] || style.size, style.size[1] || style.size, vertex_data, vertex_template, {
      texcoord_index: this.vertex_layout.index.a_texcoord,
      texcoord_scale: this.texcoord_scale
    });
  }
});


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/styles/polygons/polygons.js
},{"../../gl/constants":68,"../../gl/vertex_layout":76,"../builders":84,"../style":89,"../style_parser":91}],87:[function(require,module,exports){
"use strict";
'use strict';
Object.defineProperties(exports, {
  whiteList: {get: function() {
      return whiteList;
    }},
  ruleCache: {get: function() {
      return ruleCache;
    }},
  mergeTrees: {get: function() {
      return mergeTrees;
    }},
  RuleLeaf: {get: function() {
      return RuleLeaf;
    }},
  RuleTree: {get: function() {
      return RuleTree;
    }},
  walkUp: {get: function() {
      return walkUp;
    }},
  walkDown: {get: function() {
      return walkDown;
    }},
  groupProps: {get: function() {
      return groupProps;
    }},
  calculateStyle: {get: function() {
      return calculateStyle;
    }},
  mergeObjects: {get: function() {
      return mergeObjects;
    }},
  calculateOrder: {get: function() {
      return calculateOrder;
    }},
  parseRuleTree: {get: function() {
      return parseRuleTree;
    }},
  parseRules: {get: function() {
      return parseRules;
    }},
  matchFeature: {get: function() {
      return matchFeature;
    }},
  __esModule: {value: true}
});
var match = require('match-feature').match;
var whiteList = ['filter', 'style', 'geometry', 'properties'];
var ruleCache = {};
function cacheKey(rules) {
  return rules.map((function(r) {
    return r.id;
  })).join('/');
}
function mergeTrees(matchingTrees, context) {
  var style = {};
  var deepestOrder,
      orderReset;
  var visible;
  matchingTrees.sort((function(a, b) {
    return a.length > b.length ? -1 : (b.length > a.length ? 1 : 0);
  }));
  var len = matchingTrees[0].length;
  var $__8 = function(x) {
    var styles = matchingTrees.map((function(tree) {
      return tree[x];
    }));
    mergeObjects.apply(null, $traceurRuntime.spread([style], styles));
    for (var i = 0; i < styles.length; i++) {
      if (!styles[i]) {
        continue;
      }
      if (styles[i].visible === false) {
        visible = false;
      } else if (visible === undefined) {
        visible = true;
      }
      if (styles[i].order !== undefined) {
        deepestOrder = i;
      }
      if (styles[i].orderReset !== undefined) {
        orderReset = x;
      }
    }
  };
  for (var x = 0; x < len; x++) {
    $__8(x);
  }
  if (visible === undefined) {
    return null;
  }
  style.visible = visible;
  if (deepestOrder !== undefined) {
    var orderTree = matchingTrees[deepestOrder];
    if (orderTree.length <= 1) {
      style.order = orderTree[0].order;
    } else {
      style.order = [];
      for (var x$__9 = orderReset || 0; x$__9 < orderTree.length; x$__9++) {
        if (orderTree[x$__9] && orderTree[x$__9].order) {
          style.order.push(orderTree[x$__9].order);
        }
      }
      if (style.order.length === 1 && typeof style.order[0] === 'number') {
        style.order = style.order[0];
      } else if (!style.order.some((function(v) {
        return typeof v === 'function';
      }))) {
        style.order = calculateOrder(style.order, context);
      }
    }
  }
  return style;
}
var Rule = function Rule(name, parent, style, filter, properties) {
  this.id = $Rule.id++;
  this.name = name;
  this.style = style;
  this.filter = filter;
  this.properties = properties;
  this.parent = parent;
  this.buildFilter();
  this.buildStyle();
};
var $Rule = Rule;
($traceurRuntime.createClass)(Rule, {
  buildStyle: function() {
    this.calculatedStyle = calculateStyle(this);
  },
  buildFilter: function() {
    var type = typeof this.filter;
    if (type === 'object') {
      this.filter = match(this.filter);
    }
  },
  toJSON: function() {
    return {
      name: this.name,
      sytle: this.style
    };
  }
}, {});
Rule.id = 0;
var RuleLeaf = function RuleLeaf($__5) {
  var $__6 = $__5,
      name = $__6.name,
      parent = $__6.parent,
      style = $__6.style,
      filter = $__6.filter,
      properties = $__6.properties;
  $traceurRuntime.superConstructor($RuleLeaf).call(this, name, parent, style, filter, properties);
};
var $RuleLeaf = RuleLeaf;
($traceurRuntime.createClass)(RuleLeaf, {}, {}, Rule);
var RuleTree = function RuleTree($__5) {
  var $__6 = $__5,
      name = $__6.name,
      parent = $__6.parent,
      style = $__6.style,
      rules = $__6.rules,
      filter = $__6.filter,
      properties = $__6.properties;
  $traceurRuntime.superConstructor($RuleTree).call(this, name, parent, style, filter, properties);
  this.rules = rules || [];
};
var $RuleTree = RuleTree;
($traceurRuntime.createClass)(RuleTree, {
  addRule: function(rule) {
    this.rules.push(rule);
  },
  findMatchingRules: function(context) {
    var rules = [];
    matchFeature(context, [this], rules);
    if (rules.length > 0) {
      var key = cacheKey(rules);
      if (!ruleCache[key]) {
        ruleCache[key] = mergeTrees(rules.map((function(x) {
          return x && x.calculatedStyle;
        })), context);
      }
      return ruleCache[key];
    }
  }
}, {}, Rule);
function isWhiteListed(key) {
  return whiteList.indexOf(key) > -1;
}
function isEmpty(obj) {
  return Object.keys(obj).length === 0;
}
function walkUp(rule, cb) {
  if (rule.parent) {
    walkUp(rule.parent, cb);
  }
  cb(rule);
}
function walkDown(rule, cb) {
  if (rule.rules) {
    rule.rules.forEach((function(r) {
      walkDown(r, cb);
    }));
  }
  cb(rule);
}
function groupProps(obj) {
  var whiteListed = {},
      nonWhiteListed = {};
  for (var key in obj) {
    if (isWhiteListed(key)) {
      whiteListed[key] = obj[key];
    } else {
      nonWhiteListed[key] = obj[key];
    }
  }
  return [whiteListed, nonWhiteListed];
}
function calculateStyle(rule) {
  var $__7;
  var styles = [];
  if (rule.parent) {
    var cs = rule.parent.calculatedStyle || [];
    ($__7 = styles).push.apply($__7, $traceurRuntime.spread(cs));
  }
  styles.push(rule.style);
  return styles;
}
function mergeObjects(newObj) {
  for (var sources = [],
      $__3 = 1; $__3 < arguments.length; $__3++)
    sources[$__3 - 1] = arguments[$__3];
  for (var $__1 = sources[$traceurRuntime.toProperty(Symbol.iterator)](),
      $__2; !($__2 = $__1.next()).done; ) {
    var source = $__2.value;
    {
      if (!source) {
        continue;
      }
      for (var key in source) {
        var value = source[key];
        if (typeof value === 'object' && !Array.isArray(value)) {
          newObj[key] = mergeObjects(newObj[key] || {}, value);
        } else {
          newObj[key] = value;
        }
      }
    }
  }
  return newObj;
}
function calculateOrder(orders) {
  var context = arguments[1] !== (void 0) ? arguments[1] : null;
  var defaultOrder = arguments[2] !== (void 0) ? arguments[2] : 0;
  var sum = defaultOrder;
  for (var $__1 = orders[$traceurRuntime.toProperty(Symbol.iterator)](),
      $__2; !($__2 = $__1.next()).done; ) {
    var order = $__2.value;
    {
      if (typeof order === 'function') {
        order = order(context);
      } else {
        order = parseFloat(order);
      }
      if (!order || isNaN(order)) {
        continue;
      }
      sum += order;
    }
  }
  return sum;
}
function parseRuleTree(name, rule, parent) {
  var properties = {
    name: name,
    parent: parent
  };
  var $__5 = groupProps(rule),
      whiteListed = $__5[0],
      nonWhiteListed = $__5[1];
  var empty = isEmpty(nonWhiteListed);
  var Create;
  if (empty && parent != null) {
    Create = RuleLeaf;
  } else {
    Create = RuleTree;
  }
  var r = new Create(Object.assign(properties, whiteListed));
  if (parent) {
    parent.addRule(r);
  }
  if (!empty) {
    for (var key in nonWhiteListed) {
      var property = nonWhiteListed[key];
      if (typeof property === 'object') {
        parseRuleTree(key, property, r);
      } else {
        console.error('Property must be an object');
      }
    }
  }
  return r;
}
function parseRules(rules) {
  var ruleTrees = {};
  for (var key in rules) {
    var rule = rules[key];
    ruleTrees[key] = parseRuleTree(key, rule);
  }
  return ruleTrees;
}
function doesMatch(filter, context) {
  return ((typeof filter === 'function' && filter(context)) || (filter == null));
}
function matchFeature(context, rules, collectedRules) {
  var matched = false;
  var childMatched = false;
  if (rules.length === 0) {
    return;
  }
  for (var r = 0; r < rules.length; r++) {
    var current = rules[r];
    context.properties = current.properties;
    if (current instanceof RuleLeaf) {
      if (doesMatch(current.filter, context)) {
        matched = true;
        collectedRules.push(current);
      }
    } else if (current instanceof RuleTree) {
      if (doesMatch(current.filter, context)) {
        matched = true;
        childMatched = matchFeature(context, current.rules, collectedRules);
        if (!childMatched) {
          collectedRules.push(current);
        }
      }
    }
    context.properties = null;
  }
  return matched;
}


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/styles/rule.js
},{"match-feature":54}],88:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  Sprites: {get: function() {
      return Sprites;
    }},
  __esModule: {value: true}
});
var $___46__46__47_style__,
    $___46__46__47_style_95_parser__,
    $___46__46__47__46__46__47_gl_47_constants__,
    $___46__46__47__46__46__47_gl_47_vertex_95_layout__,
    $___46__46__47_builders__,
    $___46__46__47__46__46__47_utils_47_utils__;
var Style = ($___46__46__47_style__ = require("../style"), $___46__46__47_style__ && $___46__46__47_style__.__esModule && $___46__46__47_style__ || {default: $___46__46__47_style__}).Style;
var StyleParser = ($___46__46__47_style_95_parser__ = require("../style_parser"), $___46__46__47_style_95_parser__ && $___46__46__47_style_95_parser__.__esModule && $___46__46__47_style_95_parser__ || {default: $___46__46__47_style_95_parser__}).StyleParser;
var gl = ($___46__46__47__46__46__47_gl_47_constants__ = require("../../gl/constants"), $___46__46__47__46__46__47_gl_47_constants__ && $___46__46__47__46__46__47_gl_47_constants__.__esModule && $___46__46__47__46__46__47_gl_47_constants__ || {default: $___46__46__47__46__46__47_gl_47_constants__}).default;
var VertexLayout = ($___46__46__47__46__46__47_gl_47_vertex_95_layout__ = require("../../gl/vertex_layout"), $___46__46__47__46__46__47_gl_47_vertex_95_layout__ && $___46__46__47__46__46__47_gl_47_vertex_95_layout__.__esModule && $___46__46__47__46__46__47_gl_47_vertex_95_layout__ || {default: $___46__46__47__46__46__47_gl_47_vertex_95_layout__}).default;
var Builders = ($___46__46__47_builders__ = require("../builders"), $___46__46__47_builders__ && $___46__46__47_builders__.__esModule && $___46__46__47_builders__ || {default: $___46__46__47_builders__}).default;
var Utils = ($___46__46__47__46__46__47_utils_47_utils__ = require("../../utils/utils"), $___46__46__47__46__46__47_utils_47_utils__ && $___46__46__47__46__46__47_utils_47_utils__.__esModule && $___46__46__47__46__46__47_utils_47_utils__ || {default: $___46__46__47__46__46__47_utils_47_utils__}).default;
var Sprites = Object.create(Style);
Object.assign(Sprites, {
  name: 'sprites',
  built_in: true,
  selection: true,
  init: function() {
    Style.init.apply(this);
    this.vertex_shader_key = 'styles/sprites/sprites_vertex';
    this.fragment_shader_key = 'styles/sprites/sprites_fragment';
    this.blend = 'overlay';
    var attribs = [{
      name: 'a_position',
      size: 3,
      type: gl.FLOAT,
      normalized: false
    }, {
      name: 'a_shape',
      size: 4,
      type: gl.SHORT,
      normalized: true
    }, {
      name: 'a_selection_color',
      size: 4,
      type: gl.UNSIGNED_BYTE,
      normalized: true
    }, {
      name: 'a_texcoord',
      size: 2,
      type: gl.FLOAT,
      normalized: false
    }, {
      name: 'a_layer',
      size: 1,
      type: gl.FLOAT,
      normalized: false
    }];
    this.vertex_layout = new VertexLayout(attribs);
  },
  _parseFeature: function(feature, rule_style, context) {
    var style = this.feature_style;
    var tile = context.tile.key;
    style.z = (rule_style.z && StyleParser.parseDistance(rule_style.z || 0, context)) || StyleParser.defaults.z;
    style.texture = rule_style.texture;
    style.sprite = rule_style.sprite;
    style.size = rule_style.size && StyleParser.parseDistance(rule_style.size, context, false);
    style.size = [Math.min((style.size[0] || style.size), 256), Math.min((style.size[1] || style.size), 256)];
    style.angle = rule_style.angle || 0;
    if (typeof style.angle === 'function') {
      style.angle = style.angle(context);
    }
    style.scale = rule_style.scale || 1;
    style.tile = tile;
    this.setTexcoordScale(style);
    return style;
  },
  makeVertexTemplate: function(style) {
    var template = [0, 0, style.z || 0, 0, 0, 0, 0, style.selection_color[0] * 255, style.selection_color[1] * 255, style.selection_color[2] * 255, style.selection_color[3] * 255, 0, 0, style.order];
    return template;
  },
  buildPoints: function(points, style, vertex_data) {
    if (!style.size) {
      return;
    }
    var vertex_template = this.makeVertexTemplate(style);
    var size = style.size;
    var angle = style.angle;
    var position = points[0];
    Builders.buildSpriteQuadsForPoints([position], Utils.scaleInt16(size[0], 128), Utils.scaleInt16(size[1], 128), Utils.scaleInt16(Utils.radToDeg(angle), 360), Utils.scaleInt16(style.scale, 256), vertex_data, vertex_template, this.vertex_layout.index.a_shape, {
      texcoord_index: this.vertex_layout.index.a_texcoord,
      texcoord_scale: this.texcoord_scale
    });
  }
});


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/styles/sprites/sprites.js
},{"../../gl/constants":68,"../../gl/vertex_layout":76,"../../utils/utils":98,"../builders":84,"../style":89,"../style_parser":91}],89:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  Style: {get: function() {
      return Style;
    }},
  __esModule: {value: true}
});
var $__style_95_parser__,
    $___46__46__47_selection__,
    $___46__46__47_gl_47_shader_95_program__,
    $___46__46__47_gl_47_vbo_95_mesh__,
    $__builders__,
    $___46__46__47_gl_47_texture__,
    $___46__46__47_material__,
    $___46__46__47_light__,
    $___46__46__47_utils_47_errors__,
    $___46__46__47_gl_47_shader_95_sources__,
    $__loglevel__;
var StyleParser = ($__style_95_parser__ = require("./style_parser"), $__style_95_parser__ && $__style_95_parser__.__esModule && $__style_95_parser__ || {default: $__style_95_parser__}).StyleParser;
var FeatureSelection = ($___46__46__47_selection__ = require("../selection"), $___46__46__47_selection__ && $___46__46__47_selection__.__esModule && $___46__46__47_selection__ || {default: $___46__46__47_selection__}).default;
var ShaderProgram = ($___46__46__47_gl_47_shader_95_program__ = require("../gl/shader_program"), $___46__46__47_gl_47_shader_95_program__ && $___46__46__47_gl_47_shader_95_program__.__esModule && $___46__46__47_gl_47_shader_95_program__ || {default: $___46__46__47_gl_47_shader_95_program__}).default;
var VBOMesh = ($___46__46__47_gl_47_vbo_95_mesh__ = require("../gl/vbo_mesh"), $___46__46__47_gl_47_vbo_95_mesh__ && $___46__46__47_gl_47_vbo_95_mesh__.__esModule && $___46__46__47_gl_47_vbo_95_mesh__ || {default: $___46__46__47_gl_47_vbo_95_mesh__}).default;
var Builders = ($__builders__ = require("./builders"), $__builders__ && $__builders__.__esModule && $__builders__ || {default: $__builders__}).default;
var Texture = ($___46__46__47_gl_47_texture__ = require("../gl/texture"), $___46__46__47_gl_47_texture__ && $___46__46__47_gl_47_texture__.__esModule && $___46__46__47_gl_47_texture__ || {default: $___46__46__47_gl_47_texture__}).default;
var Material = ($___46__46__47_material__ = require("../material"), $___46__46__47_material__ && $___46__46__47_material__.__esModule && $___46__46__47_material__ || {default: $___46__46__47_material__}).default;
var Light = ($___46__46__47_light__ = require("../light"), $___46__46__47_light__ && $___46__46__47_light__.__esModule && $___46__46__47_light__ || {default: $___46__46__47_light__}).default;
var MethodNotImplemented = ($___46__46__47_utils_47_errors__ = require("../utils/errors"), $___46__46__47_utils_47_errors__ && $___46__46__47_utils_47_errors__.__esModule && $___46__46__47_utils_47_errors__ || {default: $___46__46__47_utils_47_errors__}).MethodNotImplemented;
var shaderSources = ($___46__46__47_gl_47_shader_95_sources__ = require("../gl/shader_sources"), $___46__46__47_gl_47_shader_95_sources__ && $___46__46__47_gl_47_shader_95_sources__.__esModule && $___46__46__47_gl_47_shader_95_sources__ || {default: $___46__46__47_gl_47_shader_95_sources__}).default;
var log = ($__loglevel__ = require("loglevel"), $__loglevel__ && $__loglevel__.__esModule && $__loglevel__ || {default: $__loglevel__}).default;
var Style = {
  init: function() {
    if (this.initialized) {
      return;
    }
    if (!this.isBuiltIn()) {
      this.built_in = false;
    }
    this.blend = this.blend || 'opaque';
    this.defines = this.defines || {};
    this.shaders = this.shaders || {};
    this.selection = this.selection || false;
    this.compiling = false;
    this.compiled = false;
    this.program = null;
    this.selection_program = null;
    this.feature_style = {};
    this.textures = this.textures || {};
    if (!(this.material instanceof Material)) {
      this.material = new Material(this.material);
    }
    this.material.inject(this);
    Light.setMode(this.lighting, this);
    this.initialized = true;
  },
  destroy: function() {
    if (this.program) {
      this.program.destroy();
      this.program = null;
    }
    if (this.selection_program) {
      this.selection_program.destroy();
      this.selection_program = null;
    }
    this.gl = null;
    this.initialized = false;
  },
  isBuiltIn: function() {
    return this.hasOwnProperty('built_in') && this.built_in;
  },
  startData: function() {
    return {
      vertex_data: null,
      uniforms: null,
      order: {
        min: Infinity,
        max: -Infinity
      }
    };
  },
  endData: function(tile_data) {
    if (tile_data.vertex_data) {
      tile_data.vertex_data.end();
      tile_data.vertex_data = tile_data.vertex_data.buffer;
    }
    return Promise.resolve(tile_data);
  },
  addFeature: function(feature, rule, context, tile_data) {
    var style = this.parseFeature(feature, rule, context);
    if (!style) {
      return;
    }
    if (style.order < tile_data.order.min) {
      tile_data.order.min = style.order;
    }
    if (style.order > tile_data.order.max) {
      tile_data.order.max = style.order;
    }
    if (!tile_data.vertex_data) {
      tile_data.vertex_data = this.vertex_layout.createVertexData();
    }
    this.buildGeometry(feature.geometry, style, tile_data.vertex_data);
  },
  buildGeometry: function(geometry, style, vertex_data) {
    if (geometry.type === 'Polygon') {
      this.buildPolygons([geometry.coordinates], style, vertex_data);
    } else if (geometry.type === 'MultiPolygon') {
      this.buildPolygons(geometry.coordinates, style, vertex_data);
    } else if (geometry.type === 'LineString') {
      this.buildLines([geometry.coordinates], style, vertex_data);
    } else if (geometry.type === 'MultiLineString') {
      this.buildLines(geometry.coordinates, style, vertex_data);
    } else if (geometry.type === 'Point') {
      this.buildPoints([geometry.coordinates], style, vertex_data);
    } else if (geometry.type === 'MultiPoint') {
      this.buildPoints(geometry.coordinates, style, vertex_data);
    }
  },
  parseFeature: function(feature, rule_style, context) {
    try {
      var style = this.feature_style;
      style.order = rule_style.order;
      if (typeof style.order !== 'number') {
        style.order = StyleParser.calculateOrder(style.order, context);
      }
      var selectable = false;
      style.interactive = rule_style.interactive;
      if (this.selection) {
        if (typeof style.interactive === 'function') {
          selectable = style.interactive(context);
        } else {
          selectable = style.interactive;
        }
      }
      if (selectable) {
        style.selection_color = FeatureSelection.makeColor(feature);
      } else {
        style.selection_color = FeatureSelection.defaultColor;
      }
      style = this._parseFeature(feature, rule_style, context);
      return style;
    } catch (error) {
      log.error('Style.parseFeature: style parsing error', feature, style, error);
    }
  },
  _parseFeature: function(feature, rule_style, context) {
    throw new MethodNotImplemented('_parseFeature');
  },
  buildPolygons: function() {},
  buildLines: function() {},
  buildPoints: function() {},
  textureName: function(name) {
    return this.name + '_' + name;
  },
  setupTextureUniforms: function() {
    var num_textures = Object.keys(this.textures).length;
    if (this.textures.default) {
      this.defines['HAS_DEFAULT_TEXTURE'] = true;
    }
    if (num_textures > 0) {
      var tex_id = 0;
      this.defines['NUM_TEXTURES'] = num_textures.toString();
      this.shaders.uniforms = this.shaders.uniforms || {};
      this.shaders.uniforms.u_textures = [];
      for (var name in this.textures) {
        var texture = this.textures[name];
        texture.name = this.textureName(name);
        texture.id = tex_id++;
        this.shaders.uniforms.u_textures[texture.id] = texture.name;
        this.defines[("texture_" + name)] = ("u_textures[" + texture.id + "]");
      }
    }
  },
  preloadTextures: function() {
    if (this.textures) {
      for (var name in this.textures) {
        var $__13 = this.textures[name],
            url = $__13.url,
            filtering = $__13.filtering,
            repeat = $__13.repeat,
            sprites = $__13.sprites;
        var texture = new Texture(this.gl, this.textureName(name), {sprites: sprites});
        texture.load(url, {
          filtering: filtering,
          repeat: repeat
        });
      }
    }
  },
  calculateTextureSprites: function(name) {
    var texture = Texture.textures[this.textureName(name)];
    if (texture.sprites) {
      this.texture_sprites = this.texture_sprites || {};
      this.texture_sprites[name] = {};
      for (var s in texture.sprites) {
        var sprite = texture.sprites[s];
        this.texture_sprites[name][s] = Builders.getTexcoordsForSprite([sprite[0], sprite[1]], [sprite[2], sprite[3]], [texture.width, texture.height]);
      }
    }
  },
  setTexcoordScale: function(style) {
    if (this.textures && style.sprite) {
      var tex;
      if (this.textures.default) {
        tex = 'default';
      } else {
        tex = style.texture;
      }
      if (!tex) {
        log.error(("Style: in style '" + this.name + "', must specify texture to use for sprite '" + style.sprite + "', must be one of [" + Object.keys(this.textures).join(', ') + "]"));
      } else {
        if (!this.texture_sprites || !this.texture_sprites[tex]) {
          this.calculateTextureSprites(tex);
        }
        this.texcoord_scale = this.texture_sprites[tex] && this.texture_sprites[tex][style.sprite];
      }
    }
  },
  setGL: function(gl) {
    this.gl = gl;
    this.setupTextureUniforms();
    this.preloadTextures();
  },
  makeMesh: function(vertex_data) {
    var uniforms = (arguments[1] !== (void 0) ? arguments[1] : {}).uniforms;
    return new VBOMesh(this.gl, vertex_data, this.vertex_layout, {uniforms: uniforms});
  },
  compile: function() {
    if (!this.gl) {
      throw (new Error(("style.compile(): skipping for " + this.name + " because no GL context")));
    }
    if (this.compiling) {
      throw (new Error(("style.compile(): skipping for " + this.name + " because style is already compiling")));
    }
    this.compiling = true;
    this.compiled = false;
    var defines = this.buildDefineList();
    if (this.selection) {
      var selection_defines = Object.assign({}, defines);
      selection_defines['FEATURE_SELECTION'] = true;
    }
    var transforms = (this.shaders && this.shaders.transforms);
    var uniforms = (this.shaders && this.shaders.uniforms);
    try {
      this.program = new ShaderProgram(this.gl, shaderSources[this.vertex_shader_key], shaderSources[this.fragment_shader_key], {
        name: this.name,
        defines: defines,
        uniforms: uniforms,
        transforms: transforms
      });
      if (this.selection) {
        this.selection_program = new ShaderProgram(this.gl, shaderSources[this.vertex_shader_key], shaderSources['gl/shaders/selection_fragment'], {
          name: (this.name + ' (selection)'),
          defines: selection_defines,
          uniforms: uniforms,
          transforms: transforms
        });
      } else {
        this.selection_program = null;
      }
    } catch (error) {
      this.compiling = false;
      this.compiled = false;
      throw (new Error(("style.compile(): style " + this.name + " error:"), error));
    }
    this.compiling = false;
    this.compiled = true;
  },
  addShaderTransform: function(key) {
    var $__14;
    for (var transforms = [],
        $__11 = 1; $__11 < arguments.length; $__11++)
      transforms[$__11 - 1] = arguments[$__11];
    this.shaders.transforms = this.shaders.transforms || {};
    this.shaders.transforms[key] = this.shaders.transforms[key] || [];
    ($__14 = this.shaders.transforms[key]).push.apply($__14, $traceurRuntime.spread(transforms));
  },
  removeShaderTransform: function(key) {
    if (this.shaders.transforms) {
      this.shaders.transforms[key] = null;
    }
  },
  replaceShaderTransform: function(key) {
    var $__14;
    for (var transforms = [],
        $__12 = 1; $__12 < arguments.length; $__12++)
      transforms[$__12 - 1] = arguments[$__12];
    this.removeShaderTransform(key);
    ($__14 = this).addShaderTransform.apply($__14, $traceurRuntime.spread([key], transforms));
  },
  buildDefineList: function() {
    var defines = {};
    if (this.defines != null) {
      for (var d in this.defines) {
        defines[d] = this.defines[d];
      }
    }
    if (this.shaders != null && this.shaders.defines != null) {
      for (d in this.shaders.defines) {
        defines[d] = this.shaders.defines[d];
      }
    }
    return defines;
  },
  setup: function() {
    this.setUniforms();
    this.material.setupProgram(ShaderProgram.current);
  },
  setUniforms: function() {
    var program = ShaderProgram.current;
    if (!program) {
      return;
    }
    program.setUniforms(this.shaders && this.shaders.uniforms, true);
  },
  update: function() {}
};


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/styles/style.js
},{"../gl/shader_program":71,"../gl/shader_sources":72,"../gl/texture":73,"../gl/vbo_mesh":74,"../light":78,"../material":79,"../selection":83,"../utils/errors":96,"./builders":84,"./style_parser":91,"loglevel":53}],90:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  StyleManager: {get: function() {
      return StyleManager;
    }},
  Styles: {get: function() {
      return Styles;
    }},
  __esModule: {value: true}
});
var $___46__46__47_utils_47_utils__,
    $___46__46__47_gl_47_shader_95_program__,
    $___46__46__47_gl_47_shader_95_sources__,
    $__style__,
    $__polygons_47_polygons__,
    $__points_47_points__,
    $__sprites_47_sprites__,
    $__text_47_text__,
    $__loglevel__;
var Utils = ($___46__46__47_utils_47_utils__ = require("../utils/utils"), $___46__46__47_utils_47_utils__ && $___46__46__47_utils_47_utils__.__esModule && $___46__46__47_utils_47_utils__ || {default: $___46__46__47_utils_47_utils__}).default;
var ShaderProgram = ($___46__46__47_gl_47_shader_95_program__ = require("../gl/shader_program"), $___46__46__47_gl_47_shader_95_program__ && $___46__46__47_gl_47_shader_95_program__.__esModule && $___46__46__47_gl_47_shader_95_program__ || {default: $___46__46__47_gl_47_shader_95_program__}).default;
var shaderSources = ($___46__46__47_gl_47_shader_95_sources__ = require("../gl/shader_sources"), $___46__46__47_gl_47_shader_95_sources__ && $___46__46__47_gl_47_shader_95_sources__.__esModule && $___46__46__47_gl_47_shader_95_sources__ || {default: $___46__46__47_gl_47_shader_95_sources__}).default;
var Style = ($__style__ = require("./style"), $__style__ && $__style__.__esModule && $__style__ || {default: $__style__}).Style;
var Polygons = ($__polygons_47_polygons__ = require("./polygons/polygons"), $__polygons_47_polygons__ && $__polygons_47_polygons__.__esModule && $__polygons_47_polygons__ || {default: $__polygons_47_polygons__}).Polygons;
var Points = ($__points_47_points__ = require("./points/points"), $__points_47_points__ && $__points_47_points__.__esModule && $__points_47_points__ || {default: $__points_47_points__}).Points;
var Sprites = ($__sprites_47_sprites__ = require("./sprites/sprites"), $__sprites_47_sprites__ && $__sprites_47_sprites__.__esModule && $__sprites_47_sprites__ || {default: $__sprites_47_sprites__}).Sprites;
var TextStyle = ($__text_47_text__ = require("./text/text"), $__text_47_text__ && $__text_47_text__.__esModule && $__text_47_text__ || {default: $__text_47_text__}).TextStyle;
var log = ($__loglevel__ = require("loglevel"), $__loglevel__ && $__loglevel__.__esModule && $__loglevel__ || {default: $__loglevel__}).default;
var StyleManager = {};
var Styles = {};
StyleManager.baseStyle = Style;
StyleManager.init = function() {
  if (StyleManager.initialized) {
    return;
  }
  ShaderProgram.removeTransform('globals');
  ShaderProgram.addTransform('globals', shaderSources['gl/shaders/reorder_layers']);
  ShaderProgram.addTransform('globals', ("\n        #if defined(LIGHTING_ENVIRONMENT)\n        " + shaderSources['gl/shaders/spherical_environment_map'] + "\n        #endif\n    "));
  StyleManager.initialized = true;
};
StyleManager.destroy = function(gl) {
  Object.keys(Styles).forEach((function(_name) {
    var style = Styles[_name];
    if (style.gl === gl) {
      log.trace(("StyleManager.destroy: destroying render style " + style.name));
      if (!style.isBuiltIn()) {
        StyleManager.remove(style.name);
      }
      style.destroy();
    }
  }));
};
StyleManager.register = function(style) {
  Styles[style.name] = style;
};
StyleManager.remove = function(name) {
  delete Styles[name];
};
StyleManager.preload = function(styles) {
  if (!styles) {
    return Promise.resolve();
  }
  StyleManager.normalizeTextures(styles);
  return StyleManager.loadRemoteStyles(styles).then(StyleManager.loadRemoteShaderTransforms);
};
StyleManager.normalizeTextures = function(styles) {
  for (var $__10 = Utils.values(styles)[$traceurRuntime.toProperty(Symbol.iterator)](),
      $__11; !($__11 = $__10.next()).done; ) {
    var style = $__11.value;
    {
      style.textures = style.textures || {};
      if (style.texture) {
        style.textures.default = style.texture;
      }
    }
  }
  return styles;
};
StyleManager.loadRemoteStyles = function(styles) {
  var $__9 = this;
  var urls = {};
  for (var name in styles) {
    var style = styles[name];
    if (style.url) {
      if (!urls[style.url]) {
        urls[style.url] = [];
      }
      urls[style.url].push({
        target_name: name,
        source_name: style.name || name
      });
    }
  }
  return Promise.all(Object.keys(urls).map((function(url) {
    return new Promise((function(resolve, reject) {
      Utils.loadResource(url).then((function(data) {
        for (var $__10 = urls[url][$traceurRuntime.toProperty(Symbol.iterator)](),
            $__11; !($__11 = $__10.next()).done; ) {
          var target = $__11.value;
          {
            if (data && data[target.source_name]) {
              styles[target.target_name] = data[target.source_name];
            } else {
              delete styles[target.target_name];
              return reject(new Error(("StyleManager.preload: error importing style " + target.target_name + ", could not find source style " + target.source_name + " in " + url)));
            }
          }
        }
        resolve();
        $__9.selection = false;
      })).catch((function(error) {
        log.error(("StyleManager.preload: error importing style(s) " + JSON.stringify(urls[url]) + " from " + url), error);
      }));
    }));
  }))).then((function() {
    return Promise.resolve(styles);
  }));
};
StyleManager.loadRemoteShaderTransforms = function(styles) {
  var queue = [];
  var style,
      $__14,
      key,
      transform,
      $__18 = function() {
        style = $__13.value;
        {
          if (style.shaders && style.shaders.transforms) {
            var _transforms = style.shaders.transforms;
            var $__19 = function() {
              $__14 = $__11.value;
              key = $__14[0];
              transform = $__14[1];
              {
                var _key = key;
                if (Array.isArray(transform)) {
                  var $__20 = function(t) {
                    if (typeof transform[t] === 'object' && transform[t].url) {
                      var _index = t;
                      queue.push(Utils.io(Utils.cacheBusterForUrl(transform[t].url)).then((function(data) {
                        _transforms[_key][_index] = data;
                      })).catch((function(error) {
                        log.error("StyleManager.loadRemoteShaderTransforms: error loading shader transform", _transforms, _key, _index, error);
                      })));
                    }
                  };
                  for (var t = 0; t < transform.length; t++) {
                    $__20(t);
                  }
                } else if (typeof transform === 'object' && transform.url) {
                  queue.push(Utils.io(Utils.cacheBusterForUrl(transform.url)).then((function(data) {
                    _transforms[_key] = data;
                  })).catch((function(error) {
                    log.error("StyleManager.loadRemoteShaderTransforms: error loading shader transform", _transforms, _key, error);
                  })));
                }
              }
            };
            for (var $__10 = Utils.entries(style.shaders.transforms)[$traceurRuntime.toProperty(Symbol.iterator)](),
                $__11; !($__11 = $__10.next()).done; ) {
              $__19();
            }
          }
        }
      };
  for (var $__12 = Utils.values(styles)[$traceurRuntime.toProperty(Symbol.iterator)](),
      $__13; !($__13 = $__12.next()).done; ) {
    $__18();
  }
  return Promise.all(queue).then((function() {
    return Promise.resolve(styles);
  }));
};
StyleManager.update = function(name, settings) {
  var $__15,
      $__16;
  var base = Styles[settings.extends] || StyleManager.baseStyle;
  Styles[name] = Styles[name] || Object.create(base);
  if (Styles[settings.extends]) {
    Styles[name].super = Styles[settings.extends];
  }
  for (var s in settings) {
    Styles[name][s] = settings[s];
  }
  Styles[name].name = name;
  Styles[name].initialized = false;
  Styles[name].defines = (base.defines && Object.create(base.defines)) || {};
  var shaders = {};
  var merge = [base.shaders, settings.shaders];
  merge = merge.filter((function(x) {
    return x;
  }));
  shaders.defines = ($__15 = Object).assign.apply($__15, $traceurRuntime.spread([{}], merge.map((function(x) {
    return x.defines;
  })).filter((function(x) {
    return x;
  }))));
  shaders.uniforms = ($__16 = Object).assign.apply($__16, $traceurRuntime.spread([{}], merge.map((function(x) {
    return x.uniforms;
  })).filter((function(x) {
    return x;
  }))));
  merge.map((function(x) {
    return x.transforms;
  })).filter((function(x) {
    return x;
  })).forEach((function(transforms) {
    var $__17;
    shaders.transforms = shaders.transforms || {};
    for (var $__10 = Utils.entries(transforms)[$traceurRuntime.toProperty(Symbol.iterator)](),
        $__11; !($__11 = $__10.next()).done; ) {
      var $__14 = $__11.value,
          t = $__14[0],
          transform = $__14[1];
      {
        shaders.transforms[t] = shaders.transforms[t] || [];
        if (Array.isArray(transform)) {
          ($__17 = shaders.transforms[t]).push.apply($__17, $traceurRuntime.spread(transform));
        } else {
          shaders.transforms[t].push(transform);
        }
      }
    }
  }));
  Styles[name].shaders = shaders;
  return Styles[name];
};
StyleManager.build = function(stylesheet_styles) {
  for (var name in stylesheet_styles) {
    Styles[name] = StyleManager.update(name, stylesheet_styles[name]);
  }
  for (name in Styles) {
    Styles[name].initialized = false;
    Styles[name].init();
  }
  return Styles;
};
StyleManager.compile = function() {
  for (var name in Styles) {
    try {
      Styles[name].compile();
      log.trace(("StyleManager.compile(): compiled style " + name));
    } catch (error) {
      log.error(("StyleManager.compile(): error compiling style " + name + ":"), error);
    }
  }
  log.debug("StyleManager.compile(): compiled all styles");
};
StyleManager.register(Polygons);
StyleManager.register(Points);
StyleManager.register(Sprites);
StyleManager.register(TextStyle);


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/styles/style_manager.js
},{"../gl/shader_program":71,"../gl/shader_sources":72,"../utils/utils":98,"./points/points":85,"./polygons/polygons":86,"./sprites/sprites":88,"./style":89,"./text/text":93,"loglevel":53}],91:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  StyleParser: {get: function() {
      return StyleParser;
    }},
  __esModule: {value: true}
});
var $___46__46__47_utils_47_utils__,
    $___46__46__47_geo__,
    $__csscolorparser__,
    $__loglevel__;
var Utils = ($___46__46__47_utils_47_utils__ = require("../utils/utils"), $___46__46__47_utils_47_utils__ && $___46__46__47_utils_47_utils__.__esModule && $___46__46__47_utils_47_utils__ || {default: $___46__46__47_utils_47_utils__}).default;
var Geo = ($___46__46__47_geo__ = require("../geo"), $___46__46__47_geo__ && $___46__46__47_geo__.__esModule && $___46__46__47_geo__ || {default: $___46__46__47_geo__}).default;
var parseCSSColor = ($__csscolorparser__ = require("csscolorparser"), $__csscolorparser__ && $__csscolorparser__.__esModule && $__csscolorparser__ || {default: $__csscolorparser__}).default;
var log = ($__loglevel__ = require("loglevel"), $__loglevel__ && $__loglevel__.__esModule && $__loglevel__ || {default: $__loglevel__}).default;
var StyleParser = {};
StyleParser.expandMacros = function expandMacros(obj) {
  for (var p in obj) {
    var val = obj[p];
    if (typeof val === 'object') {
      obj[p] = expandMacros(val);
    } else if (typeof val === 'string') {
      for (var m in StyleParser.macros) {
        if (val.match(StyleParser.macros[m])) {
          var f;
          try {
            eval('f = ' + val);
            obj[p] = f;
            log.trace(("expanded macro " + val + " to " + f));
            break;
          } catch (e) {
            obj[p] = val;
            log.trace(("failed to expand macro " + val));
          }
        }
      }
    }
  }
  return obj;
};
StyleParser.macros = ['Style.color.pseudoRandomColor', 'Style.color.randomColor', 'Style.pixels'];
var Style = {};
Style.color = {
  pseudoRandomGrayscale: function() {
    var func = "function() {\n            var c = Math.max((parseInt(feature.id, 16) % 100) / 100, 0.4);\n            return [0.7 * c, 0.7 * c, 0.7 * c];\n        }";
    return func;
  },
  pseudoRandomColor: function() {
    var func = "function() {\n            return [\n                0.7 * (parseInt(feature.id, 16) / 100 % 1),\n                0.7 * (parseInt(feature.id, 16) / 10000 % 1),\n                0.7 * (parseInt(feature.id, 16) / 1000000 % 1)\n            ];\n        }";
    return func;
  },
  randomColor: function() {
    var func = "function() {\n            return [0.7 * Math.random(), 0.7 * Math.random(), 0.7 * Math.random()];\n        }";
    return func;
  }
};
Style.pixels = function(p) {
  var f;
  f = 'function() { return ' + (typeof p === 'function' ? '(' + (p.toString() + '())') : p) + ' * meters_per_pixel; }';
  return f;
};
StyleParser.wrapFunction = function(func) {
  var f = ("function(context) {\n                var feature = context.feature.properties;\n                feature.id = context.feature.id;\n                var zoom = context.zoom;\n                var meters_per_pixel = context.meters_per_pixel;\n                var properties = context.properties;\n                return (" + func + "());\n            }");
  return f;
};
StyleParser.defaults = {
  color: [1.0, 0, 0],
  width: 1,
  size: 1,
  extrude: false,
  height: 20,
  min_height: 0,
  order: 0,
  z: 0,
  style: {name: 'polygons'}
};
StyleParser.getFeatureParseContext = function(feature, tile) {
  return {
    feature: feature,
    tile: tile,
    zoom: tile.coords.z,
    meters_per_pixel: Geo.metersPerPixel(tile.coords.z),
    units_per_meter: Geo.units_per_meter[tile.coords.z]
  };
};
StyleParser.convertUnits = function(val, context) {
  var convert = arguments[2] !== (void 0) ? arguments[2] : true;
  if (typeof val === 'string') {
    var units = val.match(/([0-9.-]+)([a-z]+)/);
    if (units && units.length === 3) {
      val = parseFloat(units[1]);
      units = units[2];
    }
    if (convert) {
      if (units === 'px') {
        val *= Geo.metersPerPixel(context.zoom);
      } else if (units === 'km') {
        val *= 1000;
      }
    }
  } else if (Array.isArray(val)) {
    if (val.every((function(v) {
      return Array.isArray(v);
    }))) {
      return val.map((function(v) {
        return [v[0], StyleParser.convertUnits(v[1], context, convert)];
      }));
    } else {
      return val.map((function(v) {
        return StyleParser.convertUnits(v, context, convert);
      }));
    }
  }
  return val;
};
StyleParser.parseDistance = function(val, context) {
  var convert = arguments[2] !== (void 0) ? arguments[2] : true;
  if (typeof val === 'function') {
    val = val(context);
  }
  val = StyleParser.convertUnits(val, context, convert);
  val = Utils.interpolate(context.zoom, val);
  if (convert) {
    if (typeof val === 'number') {
      val *= context.units_per_meter;
    } else if (Array.isArray(val)) {
      val.forEach((function(v, i) {
        return val[i] *= context.units_per_meter;
      }));
    }
  }
  return val;
};
StyleParser.parseColor = function(val) {
  var context = arguments[1] !== (void 0) ? arguments[1] : {};
  if (typeof val === 'function') {
    val = val(context);
  }
  if (typeof val === 'string') {
    val = parseCSSColor.parseCSSColor(val);
    if (val && val.length === 4) {
      val = val.slice(0, 3).map((function(c) {
        return c / 255;
      }));
    } else {
      val = null;
    }
  } else if (Array.isArray(val) && val.every((function(v) {
    return Array.isArray(v);
  }))) {
    val = val.map((function(v) {
      if (typeof v[1] === 'string') {
        var vc = parseCSSColor.parseCSSColor(v[1]);
        if (vc && vc.length === 4) {
          vc = vc.slice(0, 3).map((function(c) {
            return c / 255;
          }));
        }
        return [v[0], vc];
      }
      return v;
    }));
  }
  if (context.zoom) {
    val = Utils.interpolate(context.zoom, val);
  }
  if (!val[3]) {
    val[3] = 1;
  }
  return val;
};
StyleParser.calculateOrder = function(order, context) {
  if (typeof order === 'function') {
    order = order(context);
  } else if (Array.isArray(order)) {
    order = order.reduce((function(sum, order) {
      order = order || StyleParser.defaults.order;
      if (typeof order === 'function') {
        order = order(context);
      } else {
        order = parseFloat(order);
      }
      if (!order || isNaN(order)) {
        return sum;
      }
      return sum + order;
    }), 0);
  } else {
    order = parseFloat(order);
  }
  return order;
};


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/styles/style_parser.js
},{"../geo":67,"../utils/utils":98,"csscolorparser":18,"loglevel":53}],92:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  __esModule: {value: true}
});
var $___46__46__47__46__46__47_geo__,
    $__box_45_intersect__,
    $___46__46__47__46__46__47_vector__;
var Geo = ($___46__46__47__46__46__47_geo__ = require("../../geo"), $___46__46__47__46__46__47_geo__ && $___46__46__47__46__46__47_geo__.__esModule && $___46__46__47__46__46__47_geo__ || {default: $___46__46__47__46__46__47_geo__}).default;
var boxIntersect = ($__box_45_intersect__ = require("box-intersect"), $__box_45_intersect__ && $__box_45_intersect__.__esModule && $__box_45_intersect__ || {default: $__box_45_intersect__}).default;
var Vector = ($___46__46__47__46__46__47_vector__ = require("../../vector"), $___46__46__47__46__46__47_vector__ && $___46__46__47__46__46__47_vector__.__esModule && $___46__46__47__46__46__47_vector__ || {default: $___46__46__47__46__46__47_vector__}).Vector;
var Label = function Label(text, position, size, lines) {
  Object.assign(this, {
    lines: null,
    angle: null,
    text: "",
    position: [],
    size: [],
    bbox: []
  });
  this.id = $Label.id++;
  this.text = text;
  this.size = size;
  if (lines) {
    this.segment_index = 0;
    this.lines = lines;
    this.angle = this.angleForSegment(this.currentSegment());
    this.position = this.middleSegment(this.currentSegment());
    this.bbox = this.computeOBBox();
  } else {
    this.position = position;
    this.bbox = this.computeBBox();
  }
};
var $Label = Label;
($traceurRuntime.createClass)(Label, {
  middleSegment: function(segment) {
    return [(segment[0][0] + segment[1][0]) / 2, (segment[0][1] + segment[1][1]) / 2];
  },
  occluded: function(bboxes) {
    var intersect = false;
    if (bboxes.length > 0) {
      boxIntersect([this.bbox], bboxes, (function(i, j) {
        intersect = true;
        return true;
      }));
    }
    if (!intersect) {
      $Label.bbox_labels[bboxes.length] = this;
      bboxes.push(this.bbox);
    }
    return intersect;
  },
  inTileBounds: function() {
    var min = [this.bbox[0], this.bbox[1]];
    var max = [this.bbox[2], this.bbox[3]];
    if (!this.pointInTile(min) || !this.pointInTile(max)) {
      return false;
    }
    return true;
  },
  moveNextSegment: function() {
    if (this.segment_index + 1 >= this.lines.length - 1) {
      return false;
    }
    this.segment_index++;
    var segment = this.currentSegment();
    this.angle = this.angleForSegment(segment);
    this.position = this.middleSegment(segment);
    this.bbox = this.computeOBBox();
    return true;
  },
  angleForSegment: function(segment) {
    var p0p1 = Vector.sub(segment[0], segment[1]);
    p0p1 = Vector.normalize(p0p1);
    var theta = Math.atan2(p0p1[0], p0p1[1]) + Math.PI / 2;
    if (theta > Math.PI / 2 || theta < -Math.PI / 2) {
      theta += Math.PI;
    }
    return theta;
  },
  pointInTile: function(point) {
    var tile_pixel_size = Geo.units_per_pixel * Geo.tile_size;
    return point[0] > 0 && point[1] > -tile_pixel_size && point[0] < tile_pixel_size && point[1] < 0;
  },
  fitToSegment: function(exceed_heuristic) {
    var should_fit = arguments[1] !== (void 0) ? arguments[1] : true;
    if (!should_fit) {
      return true;
    }
    var segment = this.currentSegment();
    var p0p1 = Vector.sub(segment[0], segment[1]);
    var length = Vector.length(p0p1);
    var label_length = this.mercatorLength();
    if (label_length > length) {
      var exceed = (1 - (length / label_length)) * 100;
      return exceed < exceed_heuristic;
    }
    return label_length < length;
  },
  mercatorLength: function() {
    return this.size[0] * Geo.units_per_pixel;
  },
  mercatorHeight: function() {
    return this.size[1] * Geo.units_per_pixel;
  },
  currentSegment: function() {
    var p1 = this.lines[this.segment_index];
    var p2 = this.lines[this.segment_index + 1];
    return [p1, p2];
  },
  discard: function(move_in_tile, keep_in_tile, bboxes, exceed_heuristic) {
    if (this.lines && !this.fitToSegment(exceed_heuristic)) {
      while (!this.fitToSegment(exceed_heuristic)) {
        if (!this.moveNextSegment()) {
          return true;
        }
      }
    }
    var discard = false;
    if (keep_in_tile) {
      var in_tile = this.inTileBounds();
      if (!in_tile && this.lines && move_in_tile) {
        var fits_to_segment = this.fitToSegment(exceed_heuristic);
        while (!in_tile && !fits_to_segment) {
          if (!this.moveNextSegment()) {
            break;
          }
          in_tile = this.inTileBounds();
          fits_to_segment = this.fitToSegment(exceed_heuristic);
        }
        discard = !in_tile || !fits_to_segment;
      } else if (!in_tile) {
        return true;
      }
    }
    return discard || this.occluded(bboxes);
  },
  computeBBox: function() {
    var half_merc_width = this.mercatorLength() * 0.5;
    var half_merc_height = this.mercatorHeight() * 0.5;
    return [this.position[0] - half_merc_width, this.position[1] - half_merc_height, this.position[0] + half_merc_width, this.position[1] + half_merc_height];
  },
  computeOBBox: function(size) {
    var upp = Geo.units_per_pixel;
    var merc_width = this.size[0] * upp;
    var merc_height = this.size[1] * upp;
    var c = Math.cos(this.angle);
    var s = Math.sin(this.angle);
    var x = merc_width * c - merc_height * s;
    var y = merc_width * s + merc_height * c;
    var max = Math.max(x, y) * 0.5;
    return [this.position[0] - max, this.position[1] - max, this.position[0] + max, this.position[1] + max];
  }
}, {});
var $__default = Label;
Label.id = 0;
Label.bbox_labels = {};


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/styles/text/label.js
},{"../../geo":67,"../../vector":100,"box-intersect":1}],93:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  TextStyle: {get: function() {
      return TextStyle;
    }},
  __esModule: {value: true}
});
var $___46__46__47_builders__,
    $___46__46__47_style_95_parser__,
    $___46__46__47__46__46__47_gl_47_texture__,
    $___46__46__47__46__46__47_utils_47_worker_95_broker__,
    $___46__46__47__46__46__47_utils_47_utils__,
    $___46__46__47_sprites_47_sprites__,
    $__label__,
    $__loglevel__;
var Builders = ($___46__46__47_builders__ = require("../builders"), $___46__46__47_builders__ && $___46__46__47_builders__.__esModule && $___46__46__47_builders__ || {default: $___46__46__47_builders__}).default;
var StyleParser = ($___46__46__47_style_95_parser__ = require("../style_parser"), $___46__46__47_style_95_parser__ && $___46__46__47_style_95_parser__.__esModule && $___46__46__47_style_95_parser__ || {default: $___46__46__47_style_95_parser__}).StyleParser;
var Texture = ($___46__46__47__46__46__47_gl_47_texture__ = require("../../gl/texture"), $___46__46__47__46__46__47_gl_47_texture__ && $___46__46__47__46__46__47_gl_47_texture__.__esModule && $___46__46__47__46__46__47_gl_47_texture__ || {default: $___46__46__47__46__46__47_gl_47_texture__}).default;
var WorkerBroker = ($___46__46__47__46__46__47_utils_47_worker_95_broker__ = require("../../utils/worker_broker"), $___46__46__47__46__46__47_utils_47_worker_95_broker__ && $___46__46__47__46__46__47_utils_47_worker_95_broker__.__esModule && $___46__46__47__46__46__47_utils_47_worker_95_broker__ || {default: $___46__46__47__46__46__47_utils_47_worker_95_broker__}).default;
var Utils = ($___46__46__47__46__46__47_utils_47_utils__ = require("../../utils/utils"), $___46__46__47__46__46__47_utils_47_utils__ && $___46__46__47__46__46__47_utils_47_utils__.__esModule && $___46__46__47__46__46__47_utils_47_utils__ || {default: $___46__46__47__46__46__47_utils_47_utils__}).default;
var Sprites = ($___46__46__47_sprites_47_sprites__ = require("../sprites/sprites"), $___46__46__47_sprites_47_sprites__ && $___46__46__47_sprites_47_sprites__.__esModule && $___46__46__47_sprites_47_sprites__ || {default: $___46__46__47_sprites_47_sprites__}).Sprites;
var Label = ($__label__ = require("./label"), $__label__ && $__label__.__esModule && $__label__ || {default: $__label__}).default;
var log = ($__loglevel__ = require("loglevel"), $__loglevel__ && $__loglevel__.__esModule && $__loglevel__ || {default: $__loglevel__}).default;
var TextStyle = Object.create(Sprites);
Object.assign(TextStyle, {
  name: 'text',
  super: Sprites,
  built_in: true,
  selection: false,
  init: function() {
    this.super.init.apply(this);
    if (Utils.isMainThread) {
      WorkerBroker.addTarget('TextStyle', this);
    }
    this.texts = {};
    this.texture = {};
    this.canvas = {};
    this.bboxes = {};
    this.font_style = {
      typeface: 'Helvetica',
      size: '12px',
      fill: 'white'
    };
    this.label_style = {lines: {exceed: 60}};
  },
  setFont: function(tile, $__9) {
    var $__10 = $__9,
        size = $__10.size,
        typeface = $__10.typeface,
        fill = $__10.fill,
        stroke = $__10.stroke;
    this.size = parseInt(size);
    this.buffer = 6;
    var ctx = this.canvas[tile].context;
    ctx.font = size + ' ' + typeface;
    if (stroke) {
      ctx.strokeStyle = stroke;
    }
    ctx.fillStyle = fill;
    ctx.lineWidth = 4;
    ctx.miterLimit = 2;
  },
  textSize: function(text, tile) {
    return [Math.ceil(this.canvas[tile].context.measureText(text).width) + this.buffer * 2, this.size + this.buffer * 2];
  },
  drawText: function(text, $__9, tile, stroke) {
    var $__10 = $__9,
        x = $__10[0],
        y = $__10[1];
    if (stroke) {
      this.canvas[tile].context.strokeText(text, x + this.buffer, y + this.buffer + this.size);
    }
    this.canvas[tile].context.fillText(text, x + this.buffer, y + this.buffer + this.size);
  },
  setTextureTextPositions: function(texts) {
    var widest = 0,
        height = 0;
    for (var style in texts) {
      var text_infos = texts[style];
      for (var text in text_infos) {
        var text_info = text_infos[text];
        var size = text_info.size;
        text_info.position = [0, height];
        if (size[0] > widest) {
          widest = size[0];
        }
        height += size[1];
      }
    }
    return [widest, height];
  },
  getTextSizes: function(tile, texts) {
    if (!this.canvas[tile]) {
      var canvas = document.createElement('canvas');
      this.canvas[tile] = {
        canvas: canvas,
        context: canvas.getContext('2d')
      };
    }
    for (var style in texts) {
      var text_infos = texts[style];
      for (var text in text_infos) {
        this.setFont(tile, text_infos[text].text_style);
        text_infos[text].size = this.textSize(text, tile);
      }
    }
    return Promise.resolve(texts);
  },
  freeTile: function(tile) {
    delete this.canvas[tile];
    delete this.texture[tile];
  },
  rasterize: function(tile, texts, texture_size) {
    for (var style in texts) {
      var text_infos = texts[style];
      for (var text in text_infos) {
        var info = text_infos[text];
        this.setFont(tile, info.text_style);
        this.drawText(text, info.position, tile, info.text_style.stroke);
        info.texcoords = Builders.getTexcoordsForSprite(info.position, info.size, texture_size);
      }
    }
  },
  addTexts: function(tile, texts) {
    this.texts[tile] = texts;
    var texture_size = this.setTextureTextPositions(texts);
    var context = this.canvas[tile].context;
    log.trace(("text summary for tile " + tile + ": fits in " + texture_size[0] + "x" + texture_size[1] + "px"));
    this.canvas[tile].canvas.width = texture_size[0];
    this.canvas[tile].canvas.height = texture_size[1];
    context.clearRect(0, 0, texture_size[0], texture_size[1]);
    var texture = 'labels-' + tile + '-' + (TextStyle.texture_id++);
    this.texture[tile] = new Texture(this.gl, texture, {filtering: 'linear'});
    this.rasterize(tile, texts, texture_size);
    this.texture[tile].setCanvas(this.canvas[tile].canvas);
    delete this.texture[tile];
    delete this.canvas[tile];
    return Promise.resolve({
      texts: this.texts[tile],
      texture: texture
    });
  },
  startData: function() {
    var tile_data = this.super.startData.apply(this);
    tile_data.queue = [];
    return tile_data;
  },
  endData: function(tile_data) {
    var $__8 = this;
    var tile,
        count;
    if (tile_data.queue.length > 0) {
      tile = tile_data.queue[0][2].tile.key;
      count = Object.keys(this.texts[tile] || {}).length;
      log.trace(("# texts for tile " + tile + ": " + count));
    }
    if (!count) {
      return Promise.resolve();
    }
    return WorkerBroker.postMessage('TextStyle', 'getTextSizes', tile, this.texts[tile]).then((function(texts) {
      $__8.bboxes[tile] = [];
      for (var style in texts) {
        var text_infos = texts[style];
        for (var text in text_infos) {
          var text_info = text_infos[text];
          var label;
          var keep_in_tile;
          var move_in_tile;
          var geometry = $__8.texts[tile][style][text].geometry;
          var exceed_heuristic = $__8.label_style.lines.exceed;
          if (geometry.type === "LineString") {
            var lines = geometry.coordinates;
            var line = [lines[0]];
            keep_in_tile = true;
            move_in_tile = true;
            label = new Label(text, line[0], text_info.size, lines);
          } else if (geometry.type === "Point") {
            var points = [geometry.coordinates];
            keep_in_tile = true;
            move_in_tile = false;
            label = new Label(text, points[0], text_info.size);
          } else {
            continue;
          }
          if (label.discard(move_in_tile, keep_in_tile, $__8.bboxes[tile], exceed_heuristic)) {
            delete text_infos[text];
          }
          text_info.label = label;
        }
        if (Object.keys(text_infos).length === 0) {
          delete texts[style];
        }
      }
      if (Object.keys(texts).length === 0) {
        WorkerBroker.postMessage('TextStyle', 'freeTile', tile);
        return;
      }
      return WorkerBroker.postMessage('TextStyle', 'addTexts', tile, texts).then((function($__9) {
        var $__10 = $__9,
            texts = $__10.texts,
            texture = $__10.texture;
        $__8.texts[tile] = texts;
        tile_data.uniforms = {u_textures: [texture]};
        tile_data.textures = [texture];
        tile_data.queue.forEach((function(q) {
          return $__8.super.addFeature.apply($__8, q);
        }));
        tile_data.queue = [];
        delete $__8.texts[tile];
        return $__8.super.endData.call($__8, tile_data);
      }));
    }));
  },
  addFeature: function(feature, rule, context, tile_data) {
    var text = feature.properties.name;
    if (text) {
      var tile = context.tile.key;
      if (!this.texts[tile]) {
        this.texts[tile] = {};
      }
      var style = this.constructFontStyle(rule, context);
      if (!style) {
        return;
      }
      var style_key = this.constructStyleKey(style);
      feature.font_style = style;
      feature.font_style_key = style_key;
      if (!this.texts[tile][style_key]) {
        this.texts[tile][style_key] = {};
      }
      this.texts[tile][style_key][text] = {
        text_style: style,
        geometry: feature.geometry
      };
    }
    tile_data.queue.push([feature, rule, context, tile_data]);
  },
  constructFontStyle: function(rule, context) {
    var style;
    if (rule.font) {
      rule.font.fill = rule.font.fill && StyleParser.parseColor(rule.font.fill, context);
      rule.font.stroke = rule.font.stroke && StyleParser.parseColor(rule.font.stroke, context);
      style = {
        typeface: rule.font.typeface || this.font_style.typeface,
        size: rule.font.size || this.font_style.size,
        fill: !rule.font.fill ? this.font_style.fill : Utils.toCanvasColor(rule.font.fill),
        stroke: !rule.font.stroke ? this.font_style.stroke : Utils.toCanvasColor(rule.font.stroke)
      };
    }
    return style;
  },
  constructStyleKey: function($__9) {
    var $__10 = $__9,
        typeface = $__10.typeface,
        size = $__10.size,
        fill = $__10.fill,
        stroke = $__10.stroke;
    return (typeface + "/" + size + "/" + fill + "/" + stroke);
  },
  build: function(style, vertex_data) {
    var vertex_template = this.makeVertexTemplate(style);
    Builders.buildSpriteQuadsForPoints([style.label.position], Utils.scaleInt16(style.label.size[0], 128), Utils.scaleInt16(style.label.size[1], 128), Utils.scaleInt16(Utils.radToDeg(style.label.angle), 360), Utils.scaleInt16(1, 256), vertex_data, vertex_template, this.vertex_layout.index.a_shape, {
      texcoord_index: this.vertex_layout.index.a_texcoord,
      texcoord_scale: this.texcoord_scale
    });
  },
  buildLines: function(lines, style, vertex_data) {
    this.build(style, vertex_data);
  },
  buildPoints: function(points, style, vertex_data) {
    this.build(style, vertex_data);
  },
  _parseFeature: function(feature, rule_style, context) {
    var style = this.feature_style;
    var tile = context.tile.key;
    var text = feature.properties.name;
    var style_key = feature.font_style_key;
    var text_info = this.texts[tile] && this.texts[tile][style_key] && this.texts[tile][style_key][text];
    if (!text_info || !text_info.label) {
      return;
    }
    this.texcoord_scale = text_info.texcoords;
    style.text = text;
    style.tile = tile;
    style.label = text_info.label;
    return style;
  }
});
TextStyle.texture_id = 0;


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/styles/text/text.js
},{"../../gl/texture":73,"../../utils/utils":98,"../../utils/worker_broker":99,"../builders":84,"../sprites/sprites":88,"../style_parser":91,"./label":92,"loglevel":53}],94:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  __esModule: {value: true}
});
var $__geo__,
    $__styles_47_style_95_parser__,
    $__utils_47_worker_95_broker__,
    $__gl_47_texture__,
    $__loglevel__;
var Geo = ($__geo__ = require("./geo"), $__geo__ && $__geo__.__esModule && $__geo__ || {default: $__geo__}).default;
var StyleParser = ($__styles_47_style_95_parser__ = require("./styles/style_parser"), $__styles_47_style_95_parser__ && $__styles_47_style_95_parser__.__esModule && $__styles_47_style_95_parser__ || {default: $__styles_47_style_95_parser__}).StyleParser;
var WorkerBroker = ($__utils_47_worker_95_broker__ = require("./utils/worker_broker"), $__utils_47_worker_95_broker__ && $__utils_47_worker_95_broker__.__esModule && $__utils_47_worker_95_broker__ || {default: $__utils_47_worker_95_broker__}).default;
var Texture = ($__gl_47_texture__ = require("./gl/texture"), $__gl_47_texture__ && $__gl_47_texture__.__esModule && $__gl_47_texture__ || {default: $__gl_47_texture__}).default;
var log = ($__loglevel__ = require("loglevel"), $__loglevel__ && $__loglevel__.__esModule && $__loglevel__ || {default: $__loglevel__}).default;
var Tile = function Tile($__9) {
  var $__10 = $__9,
      coords = $__10.coords,
      worker = $__10.worker,
      max_zoom = $__10.max_zoom;
  Object.assign(this, {
    coords: {
      x: null,
      y: null,
      z: null
    },
    debug: {},
    loading: false,
    loaded: false,
    error: null,
    worker: null,
    visible: false,
    order: {
      min: Infinity,
      max: -Infinity
    },
    center_dist: 0
  });
  this.worker = worker;
  this.max_zoom = max_zoom;
  this.coords = coords;
  this.coords = $Tile.calculateOverZoom(this.coords, this.max_zoom);
  this.key = $Tile.key(this.coords);
  this.min = Geo.metersForTile(this.coords);
  this.max = Geo.metersForTile({
    x: this.coords.x + 1,
    y: this.coords.y + 1,
    z: this.coords.z
  }), this.span = {
    x: (this.max.x - this.min.x),
    y: (this.max.y - this.min.y)
  };
  this.bounds = {
    sw: {
      x: this.min.x,
      y: this.max.y
    },
    ne: {
      x: this.max.x,
      y: this.min.y
    }
  };
  this.meshes = {};
  this.textures = [];
};
var $Tile = Tile;
($traceurRuntime.createClass)(Tile, {
  freeResources: function() {
    if (this.meshes) {
      for (var m in this.meshes) {
        this.meshes[m].destroy();
      }
    }
    if (this.textures) {
      for (var $__6 = this.textures[$traceurRuntime.toProperty(Symbol.iterator)](),
          $__7; !($__7 = $__6.next()).done; ) {
        var t = $__7.value;
        {
          var texture = Texture.textures[t];
          if (texture) {
            texture.destroy();
          }
        }
      }
    }
    this.meshes = {};
    this.textures = [];
  },
  destroy: function() {
    this.workerMessage('removeTile', this.key);
    this.freeResources();
    this.worker = null;
  },
  buildAsMessage: function() {
    return {
      key: this.key,
      coords: this.coords,
      min: this.min,
      max: this.max,
      order: this.order,
      debug: this.debug
    };
  },
  workerMessage: function() {
    var $__11;
    for (var message = [],
        $__8 = 0; $__8 < arguments.length; $__8++)
      message[$__8] = arguments[$__8];
    return ($__11 = WorkerBroker).postMessage.apply($__11, $traceurRuntime.spread([this.worker], message));
  },
  build: function(scene) {
    scene.trackTileBuildStart(this.key);
    this.workerMessage('buildTile', {tile: this.buildAsMessage()}).then((function(message) {
      scene.buildTileCompleted(message);
    })).catch((function(error) {
      throw error;
    }));
  },
  finalizeBuild: function(styles) {
    var $__11;
    this.freeResources();
    var mesh_data = this.mesh_data;
    if (mesh_data) {
      for (var s in mesh_data) {
        if (mesh_data[s].vertex_data) {
          this.meshes[s] = styles[s].makeMesh(mesh_data[s].vertex_data, mesh_data[s]);
        }
        if (mesh_data[s].textures) {
          ($__11 = this.textures).push.apply($__11, $traceurRuntime.spread(mesh_data[s].textures));
        }
      }
    }
    this.debug.geometries = 0;
    this.debug.buffer_size = 0;
    for (var p in this.meshes) {
      this.debug.geometries += this.meshes[p].geometry_count;
      this.debug.buffer_size += this.meshes[p].vertex_data.byteLength;
    }
    this.debug.geom_ratio = (this.debug.geometries / this.debug.features).toFixed(1);
    this.mesh_data = null;
  },
  printDebug: function() {
    log.debug(("Tile: debug for " + this.key + ": [  " + JSON.stringify(this.debug) + " ]"));
  },
  update: function(scene) {
    if (this.coords.z === scene.center_tile.z && scene.visible_tiles[this.key]) {
      this.visible = true;
    } else {
      this.visible = false;
    }
    if (this.coords.z === scene.center_tile.z) {
      this.center_dist = Math.abs(scene.center_tile.x - this.coords.x) + Math.abs(scene.center_tile.y - this.coords.y);
    } else {
      this.center_dist = Infinity;
    }
  },
  load: function(scene) {
    scene.trackTileSetLoadStart();
    this.loading = true;
    this.build(scene);
    this.update(scene);
  },
  merge: function(other) {
    for (var key in other) {
      if (key !== 'key') {
        this[key] = other[key];
      }
    }
    return this;
  }
}, {
  create: function(spec) {
    return new $Tile(spec);
  },
  key: function($__9) {
    var $__10 = $__9,
        x = $__10.x,
        y = $__10.y,
        z = $__10.z;
    return [x, y, z].join('/');
  },
  calculateOverZoom: function($__9, max_zoom) {
    var $__10 = $__9,
        x = $__10.x,
        y = $__10.y,
        z = $__10.z;
    max_zoom = max_zoom || z;
    if (z > max_zoom) {
      var zdiff = z - max_zoom;
      x = Math.floor(x >> zdiff);
      y = Math.floor(y >> zdiff);
      z -= zdiff;
    }
    return {
      x: x,
      y: y,
      z: z
    };
  },
  sort: function(tiles) {
    return tiles.sort((function(a, b) {
      var ad = a.center_dist;
      var bd = b.center_dist;
      return (bd > ad ? -1 : (bd === ad ? 0 : 1));
    }));
  },
  buildGeometry: function(tile, layers, rules, styles) {
    tile.debug.rendering = +new Date();
    var tile_data = {};
    for (var sourceName in tile.sources) {
      var source = tile.sources[sourceName];
      source.debug.rendering = +new Date();
      source.debug.features = 0;
      for (var layer_name in layers) {
        var layer = layers[layer_name];
        if (!layer.geometry) {
          log.warn(("Layer " + layer + " was defined without an geometry configuration and will not be rendered."));
          continue;
        }
        var geom = $Tile.getGeometryForSource(source, layer.geometry);
        if (!geom) {
          continue;
        }
        var num_features = geom.features.length;
        for (var f = num_features - 1; f >= 0; f--) {
          var feature = geom.features[f];
          var context = StyleParser.getFeatureParseContext(feature, tile);
          var layer_rules = rules[layer_name];
          var rule = layer_rules.findMatchingRules(context, true);
          if (!rule || !rule.visible) {
            continue;
          }
          rule.name = rule.name || StyleParser.defaults.style.name;
          var style = styles[rule.name];
          if (!tile_data[rule.name]) {
            tile_data[rule.name] = style.startData();
          }
          style.addFeature(feature, rule, context, tile_data[rule.name]);
          source.debug.features++;
        }
      }
      source.debug.rendering = +new Date() - source.debug.rendering;
    }
    tile.mesh_data = {};
    var queue = [];
    var $__12 = function(style_name) {
      var style = styles[style_name];
      queue.push(style.endData(tile_data[style_name]).then((function(style_data) {
        if (style_data) {
          tile.mesh_data[style_name] = {
            vertex_data: style_data.vertex_data,
            uniforms: style_data.uniforms,
            textures: style_data.textures
          };
          if (style_data.order.min < tile.order.min) {
            tile.order.min = style_data.order.min;
          }
          if (style_data.order.max > tile.order.max) {
            tile.order.max = style_data.order.max;
          }
        }
      })));
    };
    for (var style_name in tile_data) {
      $__12(style_name);
    }
    return Promise.all(queue).then((function() {
      tile.debug.rendering = +new Date() - tile.debug.rendering;
      tile.debug.projection = 0;
      tile.debug.features = 0;
      tile.debug.network = 0;
      tile.debug.parsing = 0;
      for (var i in tile.sources) {
        tile.debug.features += tile.sources[i].debug.features;
        tile.debug.projection += tile.sources[i].debug.projection;
        tile.debug.network += tile.sources[i].debug.network;
        tile.debug.parsing += tile.sources[i].debug.parsing;
      }
      return {mesh_data: true};
    }));
  },
  getGeometryForSource: function(sourceData, sourceConfig) {
    var geom;
    if (sourceConfig != null) {
      if (typeof sourceConfig.filter === 'string') {
        geom = sourceData.layers[sourceConfig.filter];
      } else if (typeof sourceConfig.filter === 'function') {
        geom = sourceConfig.filter(sourceData.layers);
      }
    }
    return geom;
  },
  abortBuild: function(tile) {
    if (tile.mesh_data) {
      for (var s in tile.mesh_data) {
        var textures = tile.mesh_data[s].textures;
        if (textures) {
          for (var $__6 = textures[$traceurRuntime.toProperty(Symbol.iterator)](),
              $__7; !($__7 = $__6.next()).done; ) {
            var t = $__7.value;
            {
              var texture = Texture.textures[t];
              if (texture) {
                log.trace(("destroying texture " + t + " for tile " + tile.key));
                texture.destroy();
              }
            }
          }
        }
      }
    }
  }
});
var $__default = Tile;


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/tile.js
},{"./geo":67,"./gl/texture":73,"./styles/style_parser":91,"./utils/worker_broker":99,"loglevel":53}],95:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  NetworkTileSource: {get: function() {
      return NetworkTileSource;
    }},
  GeoJSONTileSource: {get: function() {
      return GeoJSONTileSource;
    }},
  TopoJSONTileSource: {get: function() {
      return TopoJSONTileSource;
    }},
  MapboxFormatTileSource: {get: function() {
      return MapboxFormatTileSource;
    }},
  __esModule: {value: true}
});
var $__geo__,
    $__utils_47_errors__,
    $__utils_47_utils__,
    $__loglevel__;
var Geo = ($__geo__ = require("./geo"), $__geo__ && $__geo__.__esModule && $__geo__ || {default: $__geo__}).default;
var MethodNotImplemented = ($__utils_47_errors__ = require("./utils/errors"), $__utils_47_errors__ && $__utils_47_errors__.__esModule && $__utils_47_errors__ || {default: $__utils_47_errors__}).MethodNotImplemented;
var Utils = ($__utils_47_utils__ = require("./utils/utils"), $__utils_47_utils__ && $__utils_47_utils__.__esModule && $__utils_47_utils__ || {default: $__utils_47_utils__}).default;
var log = ($__loglevel__ = require("loglevel"), $__loglevel__ && $__loglevel__.__esModule && $__loglevel__ || {default: $__loglevel__}).default;
var TileSource = function TileSource(source) {
  this.name = source.name;
  this.url_template = source.url;
  this.max_zoom = source.max_zoom || Geo.max_zoom;
};
($traceurRuntime.createClass)(TileSource, {
  buildAsMessage: function() {
    return {
      name: this.name,
      type: this.type,
      url: this.url_template,
      max_zoom: this.max_zoom
    };
  },
  loadTile: function(tile) {
    throw new MethodNotImplemented('loadTile');
  }
}, {
  create: function(source) {
    switch (source.type) {
      case 'TopoJSONTileSource':
        return new TopoJSONTileSource(source);
      case 'MapboxFormatTileSource':
        return new MapboxFormatTileSource(source);
      case 'GeoJSONTileSource':
      default:
        return new GeoJSONTileSource(source);
    }
  },
  projectData: function(source) {
    var timer = +new Date();
    for (var t in source.layers) {
      var num_features = source.layers[t].features.length;
      for (var f = 0; f < num_features; f++) {
        var feature = source.layers[t].features[f];
        Geo.transformGeometry(feature.geometry, (function(coord) {
          var $__6 = Geo.latLngToMeters(coord),
              x = $__6[0],
              y = $__6[1];
          coord[0] = x;
          coord[1] = y;
        }));
      }
    }
    if (source.debug !== undefined) {
      source.debug.projection = +new Date() - timer;
    }
  },
  scaleData: function(source, $__6) {
    var $__7 = $__6,
        z = $__7.coords.z,
        min = $__7.min;
    for (var t in source.layers) {
      var num_features = source.layers[t].features.length;
      for (var f = 0; f < num_features; f++) {
        var feature = source.layers[t].features[f];
        Geo.transformGeometry(feature.geometry, (function(coord) {
          coord[0] = (coord[0] - min.x) * Geo.units_per_meter[z];
          coord[1] = (coord[1] - min.y) * Geo.units_per_meter[z];
        }));
      }
    }
  }
});
var $__default = TileSource;
var NetworkTileSource = function NetworkTileSource(source) {
  $traceurRuntime.superConstructor($NetworkTileSource).call(this, source);
  this.response_type = "";
  this.url_hosts = null;
  var host_match = this.url_template.match(/{s:\[([^}+]+)\]}/);
  if (host_match != null && host_match.length > 1) {
    this.url_hosts = host_match[1].split(',');
    this.next_host = 0;
  }
};
var $NetworkTileSource = NetworkTileSource;
($traceurRuntime.createClass)(NetworkTileSource, {
  formatTileUrl: function(tile) {
    var url = this.url_template.replace('{x}', tile.coords.x).replace('{y}', tile.coords.y).replace('{z}', tile.coords.z);
    if (this.url_hosts != null) {
      url = url.replace(/{s:\[([^}+]+)\]}/, this.url_hosts[this.next_host]);
      this.next_host = (this.next_host + 1) % this.url_hosts.length;
    }
    return url;
  },
  loadTile: function(tile) {
    var $__4 = this;
    var url = this.formatTileUrl(tile);
    if (tile.sources == null) {
      tile.sources = {};
    }
    var source = tile.sources[this.name] = {};
    source.url = url;
    source.debug = {};
    source.debug.network = +new Date();
    return new Promise((function(resolve, reject) {
      source.error = null;
      var promise = Utils.io(url, 60 * 1000, $__4.response_type);
      tile.request = promise.request;
      promise.then((function(body) {
        source.debug.response_size = body.length || body.byteLength;
        source.debug.network = +new Date() - source.debug.network;
        source.debug.parsing = +new Date();
        $__4.parseSourceData(tile, source, body);
        source.debug.parsing = +new Date() - source.debug.parsing;
        resolve(tile);
      })).catch((function(error) {
        source.error = error.toString();
        reject(error);
      }));
    }));
  },
  parseSourceData: function(tile, source, reponse) {
    throw new MethodNotImplemented('parseTile');
  }
}, {}, TileSource);
var GeoJSONTileSource = function GeoJSONTileSource(source) {
  $traceurRuntime.superConstructor($GeoJSONTileSource).call(this, source);
  this.type = 'GeoJSONTileSource';
};
var $GeoJSONTileSource = GeoJSONTileSource;
($traceurRuntime.createClass)(GeoJSONTileSource, {parseSourceData: function(tile, source, response) {
    source.layers = JSON.parse(response);
    TileSource.projectData(source);
    TileSource.scaleData(source, tile);
  }}, {}, NetworkTileSource);
var TopoJSONTileSource = function TopoJSONTileSource(source) {
  $traceurRuntime.superConstructor($TopoJSONTileSource).call(this, source);
  this.type = 'TopoJSONTileSource';
  if (typeof topojson === 'undefined') {
    try {
      importScripts('http://d3js.org/topojson.v1.min.js');
      log.info('TopoJSONTileSource: loaded topojson library');
    } catch (e) {
      log.error('TopoJSONTileSource: failed to load TopoJSON library!');
    }
  }
};
var $TopoJSONTileSource = TopoJSONTileSource;
($traceurRuntime.createClass)(TopoJSONTileSource, {parseSourceData: function(tile, source, response) {
    if (typeof topojson === 'undefined') {
      tile.layers = {};
      return;
    }
    source.layers = JSON.parse(response);
    if (source.layers.objects.vectiles != null) {
      source.layers = topojson.feature(source.layers, source.layers.objects.vectiles);
    } else {
      var layers = {};
      for (var t in source.layers.objects) {
        layers[t] = topojson.feature(source.layers, source.layers.objects[t]);
      }
      source.layers = layers;
    }
    TileSource.projectData(source);
    TileSource.scaleData(source, tile);
  }}, {}, NetworkTileSource);
var MapboxFormatTileSource = function MapboxFormatTileSource(source) {
  $traceurRuntime.superConstructor($MapboxFormatTileSource).call(this, source);
  this.type = 'MapboxFormatTileSource';
  this.response_type = "arraybuffer";
  this.Protobuf = require('pbf');
  this.VectorTile = require('vector-tile').VectorTile;
  this.VectorTileFeature = require('vector-tile').VectorTileFeature;
  this.pad_scale = source.pad_scale || 0.001;
};
var $MapboxFormatTileSource = MapboxFormatTileSource;
($traceurRuntime.createClass)(MapboxFormatTileSource, {
  parseSourceData: function(tile, source, response) {
    var $__4 = this;
    var data = new Uint8Array(response);
    var buffer = new this.Protobuf(data);
    source.data = new this.VectorTile(buffer);
    source.layers = this.toGeoJSON(source.data);
    delete source.data;
    for (var t in source.layers) {
      var num_features = source.layers[t].features.length;
      for (var f = 0; f < num_features; f++) {
        var feature = source.layers[t].features[f];
        feature.properties.id = feature.properties.osm_id;
        Geo.transformGeometry(feature.geometry, (function(coord) {
          coord[0] = Math.round(coord[0] * (1 + $__4.pad_scale) - (4096 * $__4.pad_scale / 2));
          coord[1] = Math.round(coord[1] * (1 + $__4.pad_scale) - (4096 * $__4.pad_scale / 2));
          coord[1] = -coord[1];
        }));
      }
    }
  },
  toGeoJSON: function(tile) {
    var layers = {};
    for (var l in tile.layers) {
      var layer = tile.layers[l];
      var layer_geojson = {
        type: 'FeatureCollection',
        features: []
      };
      for (var f = 0; f < layer.length; f++) {
        var feature = layer.feature(f);
        var feature_geojson = {
          type: 'Feature',
          geometry: {},
          properties: feature.properties
        };
        var geometry = feature_geojson.geometry;
        var coordinates = feature.loadGeometry();
        for (var r = 0; r < coordinates.length; r++) {
          var ring = coordinates[r];
          for (var c = 0; c < ring.length; c++) {
            ring[c] = [ring[c].x, ring[c].y];
          }
        }
        geometry.coordinates = coordinates;
        if (this.VectorTileFeature.types[feature.type] === 'Point') {
          geometry.type = 'Point';
          geometry.coordinates = geometry.coordinates[0][0];
        } else if (this.VectorTileFeature.types[feature.type] === 'LineString') {
          if (coordinates.length === 1) {
            geometry.type = 'LineString';
            geometry.coordinates = geometry.coordinates[0];
          } else {
            geometry.type = 'MultiLineString';
          }
        } else if (this.VectorTileFeature.types[feature.type] === 'Polygon') {
          geometry.type = 'Polygon';
        }
        layer_geojson.features.push(feature_geojson);
      }
      layers[l] = layer_geojson;
    }
    return layers;
  }
}, {}, NetworkTileSource);


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/tile_source.js
},{"./geo":67,"./utils/errors":96,"./utils/utils":98,"loglevel":53,"pbf":56,"vector-tile":61}],96:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  MethodNotImplemented: {get: function() {
      return MethodNotImplemented;
    }},
  __esModule: {value: true}
});
var MethodNotImplemented = function MethodNotImplemented(methodName) {
  this.name = 'MethodNotImplemented';
  this.message = 'Method ' + methodName + ' must be implemented in subclass';
};
($traceurRuntime.createClass)(MethodNotImplemented, {}, {}, Error);


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/utils/errors.js
},{}],97:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  __esModule: {value: true}
});
function subscribeMixin(target) {
  var listeners = [];
  return Object.assign(target, {
    subscribe: function(listener) {
      listeners.push(listener);
    },
    unsubscribe: function(listener) {
      var index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    },
    unsubscribeAll: function() {
      listeners = [];
    },
    trigger: function(event) {
      var $__3;
      for (var data = [],
          $__2 = 1; $__2 < arguments.length; $__2++)
        data[$__2 - 1] = arguments[$__2];
      for (var $__0 = listeners[$traceurRuntime.toProperty(Symbol.iterator)](),
          $__1; !($__1 = $__0.next()).done; ) {
        var listener = $__1.value;
        {
          if (typeof listener[event] === 'function') {
            ($__3 = listener)[event].apply($__3, $traceurRuntime.spread(data));
          }
        }
      }
    }
  });
}
var $__default = subscribeMixin;


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/utils/subscribe.js
},{}],98:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  __esModule: {value: true}
});
var $__loglevel__,
    $__js_45_yaml__;
var log = ($__loglevel__ = require("loglevel"), $__loglevel__ && $__loglevel__.__esModule && $__loglevel__ || {default: $__loglevel__}).default;
var yaml = ($__js_45_yaml__ = require("js-yaml"), $__js_45_yaml__ && $__js_45_yaml__.__esModule && $__js_45_yaml__ || {default: $__js_45_yaml__}).default;
var Utils;
var $__default = Utils = {};
Utils.addBaseURL = function(url) {
  if (!url) {
    return;
  }
  if (url.substr(0, 2) === '//') {
    url = window.location.protocol + url;
  } else if (url.search(/(http|https|data):\/\//) < 0) {
    url = window.location.origin + window.location.pathname + url;
  }
  return url;
};
Utils.cacheBusterForUrl = function(url) {
  return url + '?' + (+new Date());
};
Utils.io = function(url) {
  var timeout = arguments[1] !== (void 0) ? arguments[1] : 60000;
  var responseType = arguments[2] !== (void 0) ? arguments[2] : 'text';
  var method = arguments[3] !== (void 0) ? arguments[3] : 'GET';
  var headers = arguments[4] !== (void 0) ? arguments[4] : {};
  var request = new XMLHttpRequest();
  var promise = new Promise((function(resolve, reject) {
    request.open(method, url, true);
    request.timeout = timeout;
    request.responseType = responseType;
    request.onload = (function() {
      if (request.status === 200) {
        if (['text', 'json'].indexOf(request.responseType) > -1) {
          resolve(request.responseText);
        } else {
          resolve(request.response);
        }
      } else {
        reject(Error('Request error with a status of ' + request.statusText));
      }
    });
    request.onerror = (function(evt) {
      reject(Error('There was a network error' + evt.toString()));
    });
    request.ontimeout = (function(evt) {
      reject(Error('timeout ' + evt.toString()));
    });
    request.send();
  }));
  Object.defineProperty(promise, 'request', {value: request});
  return promise;
};
Utils.parseResource = function(body) {
  var data = null;
  try {
    eval('data = ' + body);
  } catch (e) {
    try {
      data = yaml.safeLoad(body);
    } catch (e) {
      log.error('Utils.parseResource: failed to parse', e);
      throw e;
    }
  }
  return data;
};
Utils.loadResource = function(source) {
  return new Promise((function(resolve, reject) {
    if (typeof source === 'string') {
      Utils.io(Utils.cacheBusterForUrl(source)).then((function(body) {
        var data = Utils.parseResource(body);
        resolve(data);
      }), reject);
    } else {
      resolve(source);
    }
  }));
};
Utils.requestAnimationFramePolyfill = function() {
  if (typeof window.requestAnimationFrame !== 'function') {
    window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(cb) {
      setTimeout(cb, 1000 / 60);
    };
  }
};
Utils.serializeWithFunctions = function(obj) {
  var serialized = JSON.stringify(obj, function(k, v) {
    if (typeof v === 'function') {
      return v.toString();
    }
    return v;
  });
  return serialized;
};
Utils.deserializeWithFunctions = function(serialized, wrap) {
  var obj = JSON.parse(serialized);
  obj = Utils.stringsToFunctions(obj, wrap);
  return obj;
};
Utils.stringsToFunctions = function(obj, wrap) {
  for (var p in obj) {
    var val = obj[p];
    if (typeof val === 'object') {
      obj[p] = Utils.stringsToFunctions(val, wrap);
    } else if (typeof val === 'string' && val.match(/^function.*\(.*\)/) != null) {
      var f;
      try {
        if (typeof wrap === 'function') {
          eval('f = ' + wrap(val));
        } else {
          eval('f = ' + val);
        }
        obj[p] = f;
      } catch (e) {
        obj[p] = val;
      }
    }
  }
  return obj;
};
(function() {
  try {
    if (window.document !== undefined) {
      Utils.isWorkerThread = false;
      Utils.isMainThread = true;
    }
  } catch (e) {
    if (self !== undefined) {
      Utils.isWorkerThread = true;
      Utils.isMainThread = false;
    }
  }
})();
Utils.findCurrentURL = function() {
  for (var paths = [],
      $__4 = 0; $__4 < arguments.length; $__4++)
    paths[$__4] = arguments[$__4];
  var script = document.currentScript;
  if (script) {
    return script.src;
  } else if (Array.isArray(paths)) {
    var scripts = document.getElementsByTagName('script');
    for (var s = 0; s < scripts.length; s++) {
      for (var $__2 = paths[$traceurRuntime.toProperty(Symbol.iterator)](),
          $__3; !($__3 = $__2.next()).done; ) {
        var path = $__3.value;
        {
          if (scripts[s].src.indexOf(path) > -1) {
            return scripts[s].src;
          }
        }
      }
    }
  }
};
Utils.isPowerOf2 = function(value) {
  return (value & (value - 1)) === 0;
};
Utils.nextPowerOf2 = function(value) {
  return Math.pow(2, Math.ceil(Math.log2(value)));
};
Utils.interpolate = function(x, points) {
  if (!Array.isArray(points) || points.some((function(v) {
    return !Array.isArray(v);
  }))) {
    return points;
  } else if (points.length < 1) {
    return points;
  }
  var x1,
      x2,
      d,
      y;
  if (x <= points[0][0]) {
    y = points[0][1];
  } else if (x >= points[points.length - 1][0]) {
    y = points[points.length - 1][1];
  } else {
    for (var i = 0; i < points.length - 1; i++) {
      if (x >= points[i][0] && x < points[i + 1][0]) {
        x1 = points[i][0];
        x2 = points[i + 1][0];
        if (Array.isArray(points[i][1])) {
          y = [];
          for (var c = 0; c < points[i][1].length; c++) {
            d = points[i + 1][1][c] - points[i][1][c];
            y[c] = d * (x - x1) / (x2 - x1) + points[i][1][c];
          }
        } else {
          d = points[i + 1][1] - points[i][1];
          y = d * (x - x1) / (x2 - x1) + points[i][1];
        }
        break;
      }
    }
  }
  return y;
};
Utils.entries = $traceurRuntime.initGeneratorFunction(function $__5(obj) {
  var $__2,
      $__3,
      key;
  return $traceurRuntime.createGeneratorInstance(function($ctx) {
    while (true)
      switch ($ctx.state) {
        case 0:
          $__2 = Object.keys(obj)[$traceurRuntime.toProperty(Symbol.iterator)]();
          $ctx.state = 4;
          break;
        case 4:
          $ctx.state = (!($__3 = $__2.next()).done) ? 5 : -2;
          break;
        case 5:
          key = $__3.value;
          $ctx.state = 6;
          break;
        case 6:
          $ctx.state = 2;
          return [key, obj[key]];
        case 2:
          $ctx.maybeThrow();
          $ctx.state = 4;
          break;
        default:
          return $ctx.end();
      }
  }, $__5, this);
});
Utils.values = $traceurRuntime.initGeneratorFunction(function $__6(obj) {
  var $__2,
      $__3,
      key;
  return $traceurRuntime.createGeneratorInstance(function($ctx) {
    while (true)
      switch ($ctx.state) {
        case 0:
          $__2 = Object.keys(obj)[$traceurRuntime.toProperty(Symbol.iterator)]();
          $ctx.state = 4;
          break;
        case 4:
          $ctx.state = (!($__3 = $__2.next()).done) ? 5 : -2;
          break;
        case 5:
          key = $__3.value;
          $ctx.state = 6;
          break;
        case 6:
          $ctx.state = 2;
          return obj[key];
        case 2:
          $ctx.maybeThrow();
          $ctx.state = 4;
          break;
        default:
          return $ctx.end();
      }
  }, $__6, this);
});
Utils.recurseEntries = $traceurRuntime.initGeneratorFunction(function $__7(obj) {
  var $__2,
      $__3,
      key,
      $__8,
      $__9;
  return $traceurRuntime.createGeneratorInstance(function($ctx) {
    while (true)
      switch ($ctx.state) {
        case 0:
          $ctx.state = (!obj) ? 1 : 2;
          break;
        case 1:
          $ctx.state = -2;
          break;
        case 2:
          $__2 = Object.keys(obj)[$traceurRuntime.toProperty(Symbol.iterator)]();
          $ctx.state = 17;
          break;
        case 17:
          $ctx.state = (!($__3 = $__2.next()).done) ? 22 : -2;
          break;
        case 22:
          key = $__3.value;
          $ctx.state = 23;
          break;
        case 23:
          $ctx.state = (obj[key]) ? 4 : 17;
          break;
        case 4:
          $ctx.state = 5;
          return [key, obj[key]];
        case 5:
          $ctx.maybeThrow();
          $ctx.state = 7;
          break;
        case 7:
          $ctx.state = (typeof obj[key] === 'object') ? 18 : 17;
          break;
        case 18:
          $__8 = Utils.recurseEntries(obj[key])[Symbol.iterator]();
          $ctx.sent = void 0;
          $ctx.action = 'next';
          $ctx.state = 19;
          break;
        case 19:
          $__9 = $__8[$ctx.action]($ctx.sentIgnoreThrow);
          $ctx.state = 16;
          break;
        case 16:
          $ctx.state = ($__9.done) ? 10 : 9;
          break;
        case 10:
          $ctx.sent = $__9.value;
          $ctx.state = 17;
          break;
        case 9:
          $ctx.state = 19;
          return $__9.value;
        default:
          return $ctx.end();
      }
  }, $__7, this);
});
Utils.recurseValues = $traceurRuntime.initGeneratorFunction(function $__10(obj) {
  var $__2,
      $__3,
      key,
      $__11,
      $__12;
  return $traceurRuntime.createGeneratorInstance(function($ctx) {
    while (true)
      switch ($ctx.state) {
        case 0:
          $ctx.state = (!obj) ? 1 : 2;
          break;
        case 1:
          $ctx.state = -2;
          break;
        case 2:
          $__2 = Object.keys(obj)[$traceurRuntime.toProperty(Symbol.iterator)]();
          $ctx.state = 17;
          break;
        case 17:
          $ctx.state = (!($__3 = $__2.next()).done) ? 22 : -2;
          break;
        case 22:
          key = $__3.value;
          $ctx.state = 23;
          break;
        case 23:
          $ctx.state = (obj[key]) ? 4 : 17;
          break;
        case 4:
          $ctx.state = 5;
          return obj[key];
        case 5:
          $ctx.maybeThrow();
          $ctx.state = 7;
          break;
        case 7:
          $ctx.state = (typeof obj[key] === 'object') ? 18 : 17;
          break;
        case 18:
          $__11 = Utils.recurseValues(obj[key])[Symbol.iterator]();
          $ctx.sent = void 0;
          $ctx.action = 'next';
          $ctx.state = 19;
          break;
        case 19:
          $__12 = $__11[$ctx.action]($ctx.sentIgnoreThrow);
          $ctx.state = 16;
          break;
        case 16:
          $ctx.state = ($__12.done) ? 10 : 9;
          break;
        case 10:
          $ctx.sent = $__12.value;
          $ctx.state = 17;
          break;
        case 9:
          $ctx.state = 19;
          return $__12.value;
        default:
          return $ctx.end();
      }
  }, $__10, this);
});
Utils.scaleInt16 = function(val, max) {
  return (val / max) * 32768;
};
Utils.degToRad = function(degrees) {
  return degrees * Math.PI / 180;
};
Utils.radToDeg = function(radians) {
  return radians * 180 / Math.PI;
};
Utils.toCanvasColor = function(color) {
  return 'rgb(' + Math.round(color[0] * 255) + ',' + Math.round(color[1] * 255) + ',' + Math.round(color[2] * 255) + ')';
};


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/utils/utils.js
},{"js-yaml":22,"loglevel":53}],99:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  default: {get: function() {
      return $__default;
    }},
  __esModule: {value: true}
});
var $__utils__;
var Utils = ($__utils__ = require("./utils"), $__utils__ && $__utils__.__esModule && $__utils__ || {default: $__utils__}).default;
var WorkerBroker;
var $__default = WorkerBroker = {};
var message_id = 0;
var messages = {};
function setupMainThread() {
  WorkerBroker.postMessage = function(worker, method) {
    for (var message = [],
        $__1 = 2; $__1 < arguments.length; $__1++)
      message[$__1 - 2] = arguments[$__1];
    var promise = new Promise((function(resolve, reject) {
      messages[message_id] = {
        method: method,
        message: message,
        resolve: resolve,
        reject: reject
      };
    }));
    worker.postMessage({
      type: 'main_send',
      message_id: message_id,
      method: method,
      message: message
    });
    message_id++;
    return promise;
  };
  var worker_id = 0;
  var workers = {};
  WorkerBroker.addWorker = function(worker) {
    worker._worker_broker_id = worker_id++;
    workers[worker._worker_broker_id] = worker;
    worker.addEventListener('message', (function(event) {
      if (event.data.type !== 'worker_reply') {
        return;
      }
      var id = event.data.message_id;
      if (messages[id]) {
        if (event.data.error) {
          messages[id].reject(event.data.error);
        } else {
          messages[id].resolve(event.data.message);
        }
        delete messages[id];
      }
    }));
    worker.addEventListener('message', (function(event) {
      var id = event.data.message_id;
      if (event.data.type !== 'worker_send' || id == null) {
        return;
      }
      var target = targets[event.data.target];
      if (!target) {
        throw Error(("Worker broker could not dispatch message type " + event.data.method + " on target " + event.data.target + " because no object with that name is registered on main thread"));
      }
      var method = (typeof target[event.data.method] === 'function') && target[event.data.method];
      if (!method) {
        throw Error(("Worker broker could not dispatch message type " + event.data.method + " on target " + event.data.target + " because object has no method with that name"));
      }
      var result,
          error;
      try {
        result = method.apply(target, event.data.message);
      } catch (e) {
        error = e;
      }
      if (result instanceof Promise) {
        result.then((function(value) {
          worker.postMessage({
            type: 'main_reply',
            message_id: id,
            message: value
          });
        }), (function(error) {
          worker.postMessage({
            type: 'main_reply',
            message_id: id,
            error: (error instanceof Error ? (error.message + ": " + error.stack) : error)
          });
        }));
      } else {
        worker.postMessage({
          type: 'main_reply',
          message_id: id,
          message: result,
          error: (error instanceof Error ? (error.message + ": " + error.stack) : error)
        });
      }
    }));
  };
  var targets = {};
  WorkerBroker.addTarget = function(name, target) {
    targets[name] = target;
  };
  WorkerBroker.getMessages = function() {
    return messages;
  };
  WorkerBroker.getMessageId = function() {
    return message_id;
  };
}
function setupWorkerThread() {
  WorkerBroker.postMessage = function(target, method) {
    for (var message = [],
        $__1 = 2; $__1 < arguments.length; $__1++)
      message[$__1 - 2] = arguments[$__1];
    var promise = new Promise((function(resolve, reject) {
      messages[message_id] = {
        target: target,
        method: method,
        message: message,
        resolve: resolve,
        reject: reject
      };
    }));
    self.postMessage({
      type: 'worker_send',
      message_id: message_id,
      target: target,
      method: method,
      message: message
    });
    message_id++;
    return promise;
  };
  self.addEventListener('message', (function(event) {
    if (event.data.type !== 'main_reply') {
      return;
    }
    var id = event.data.message_id;
    if (messages[id]) {
      if (event.data.error) {
        messages[id].reject(event.data.error);
      } else {
        messages[id].resolve(event.data.message);
      }
      delete messages[id];
    }
  }));
  self.addEventListener('message', (function(event) {
    var id = event.data.message_id;
    if (event.data.type !== 'main_send' || id == null) {
      return;
    }
    var method = (typeof self[event.data.method] === 'function') && self[event.data.method];
    if (!method) {
      throw Error(("Worker broker could not dispatch message type " + event.data.method + " because worker has no method with that name"));
    }
    var result,
        error;
    try {
      result = method.apply(self, event.data.message);
    } catch (e) {
      error = e;
    }
    if (result instanceof Promise) {
      result.then((function(value) {
        self.postMessage({
          type: 'worker_reply',
          message_id: id,
          message: value
        });
      }), (function(error) {
        self.postMessage({
          type: 'worker_reply',
          message_id: id,
          error: (error instanceof Error ? (error.message + ": " + error.stack) : error)
        });
      }));
    } else {
      self.postMessage({
        type: 'worker_reply',
        message_id: id,
        message: result,
        error: (error instanceof Error ? (error.message + ": " + error.stack) : error)
      });
    }
  }));
}
if (Utils.isMainThread) {
  setupMainThread();
}
if (Utils.isWorkerThread) {
  setupWorkerThread();
}


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/utils/worker_broker.js
},{"./utils":98}],100:[function(require,module,exports){
"use strict";
Object.defineProperties(exports, {
  Vector: {get: function() {
      return Vector;
    }},
  __esModule: {value: true}
});
var Vector = {};
Vector.set = function(v) {
  var V = [];
  var lim = v.length;
  for (var i = 0; i < lim; i++) {
    V[i] = v[i];
  }
  return V;
};
Vector.neg = function(v) {
  var V = [];
  var lim = v.length;
  for (var i = 0; i < lim; i++) {
    V[i] = v[i] * -1;
  }
  return V;
};
Vector.add = function(v1, v2) {
  var v = [];
  var lim = Math.min(v1.length, v2.length);
  for (var i = 0; i < lim; i++) {
    v[i] = v1[i] + v2[i];
  }
  return v;
};
Vector.sub = function(v1, v2) {
  var v = [];
  var lim = Math.min(v1.length, v2.length);
  for (var i = 0; i < lim; i++) {
    v[i] = v1[i] - v2[i];
  }
  return v;
};
Vector.signed_area = function(v1, v2, v3) {
  return (v2[0] - v1[0]) * (v3[1] - v1[1]) - (v3[0] - v1[0]) * (v2[1] - v1[1]);
};
Vector.mult = function(v1, v2) {
  var v = [],
      len = v1.length,
      i;
  if (typeof v2 === 'number') {
    for (i = 0; i < len; i++) {
      v[i] = v1[i] * v2;
    }
  } else {
    len = Math.min(v1.length, v2.length);
    for (i = 0; i < len; i++) {
      v[i] = v1[i] * v2[i];
    }
  }
  return v;
};
Vector.div = function(v1, v2) {
  var v = [],
      i;
  if (typeof v2 === 'number') {
    for (i = 0; i < v1.length; i++) {
      v[i] = v1[i] / v2;
    }
  } else {
    var len = Math.min(v1.length, v2.length);
    for (i = 0; i < len; i++) {
      v[i] = v1[i] / v2[i];
    }
  }
  return v;
};
Vector.perp = function(v1, v2) {
  return [v2[1] - v1[1], v1[0] - v2[0]];
};
Vector.rot = function(v, a) {
  var vr = Vector.length(v);
  var va = Vector.angle(v);
  return [vr * Math.cos(va + a), vr * Math.sin(va + a)];
};
Vector.angle = function($__0) {
  var $__1 = $__0,
      x = $__1[0],
      y = $__1[1];
  return Math.atan2(y, x);
};
Vector.isEqual = function(v1, v2) {
  var len = v1.length;
  for (var i = 0; i < len; i++) {
    if (v1[i] !== v2[i]) {
      return false;
    }
  }
  return true;
};
Vector.lengthSq = function(v) {
  if (v.length === 2) {
    return (v[0] * v[0] + v[1] * v[1]);
  } else {
    return (v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
  }
};
Vector.length = function(v) {
  return Math.sqrt(Vector.lengthSq(v));
};
Vector.normalize = function(v) {
  var d;
  if (v.length === 2) {
    d = v[0] * v[0] + v[1] * v[1];
    d = Math.sqrt(d);
    if (d !== 0) {
      return [v[0] / d, v[1] / d];
    }
    return [0, 0];
  } else {
    d = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
    d = Math.sqrt(d);
    if (d !== 0) {
      return [v[0] / d, v[1] / d, v[2] / d];
    }
    return [0, 0, 0];
  }
};
Vector.cross = function(v1, v2) {
  return [(v1[1] * v2[2]) - (v1[2] * v2[1]), (v1[2] * v2[0]) - (v1[0] * v2[2]), (v1[0] * v2[1]) - (v1[1] * v2[0])];
};
Vector.dot = function(v1, v2) {
  var n = 0;
  var lim = Math.min(v1.length, v2.length);
  for (var i = 0; i < lim; i++) {
    n += v1[i] * v2[i];
  }
  return n;
};
Vector.lineIntersection = function(p1, p2, p3, p4, parallel_tolerance) {
  parallel_tolerance = parallel_tolerance || 0.01;
  var a1 = p1[1] - p2[1];
  var b1 = p1[0] - p2[0];
  var a2 = p3[1] - p4[1];
  var b2 = p3[0] - p4[0];
  var c1 = (p1[0] * p2[1]) - (p1[1] * p2[0]);
  var c2 = (p3[0] * p4[1]) - (p3[1] * p4[0]);
  var denom = (b1 * a2) - (a1 * b2);
  if (Math.abs(denom) > parallel_tolerance) {
    return [((c1 * b2) - (b1 * c2)) / denom, ((c1 * a2) - (a1 * c2)) / denom];
  }
  return null;
};


//# sourceURL=/home/ivan/dev/mapzen/tangram/src/vector.js
},{}]},{},[20,80])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2xpYi9icnV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2xpYi9pbnRlcnNlY3QuanMiLCJub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9saWIvbWVkaWFuLmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL3BhcnRpdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2xpYi9zb3J0LmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL3N3ZWVwLmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3Qvbm9kZV9tb2R1bGVzL2JpdC10d2lkZGxlL3R3aWRkbGUuanMiLCJub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9ub2RlX21vZHVsZXMvdHlwZWRhcnJheS1wb29sL25vZGVfbW9kdWxlcy9kdXAvZHVwLmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3Qvbm9kZV9tb2R1bGVzL3R5cGVkYXJyYXktcG9vbC9wb29sLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pcy1hcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Nzc2NvbG9ycGFyc2VyL2Nzc2NvbG9ycGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL2VhcmN1dC9zcmMvZWFyY3V0LmpzIiwibm9kZV9tb2R1bGVzL2VzNmlmeS9ub2RlX21vZHVsZXMvdHJhY2V1ci9iaW4vdHJhY2V1ci1ydW50aW1lLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9kaXN0L2dsLW1hdHJpeC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9jb21tb24uanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9kdW1wZXIuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9leGNlcHRpb24uanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9sb2FkZXIuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9tYXJrLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hL2NvcmUuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZS5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9mYWlsc2FmZS5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9qc29uLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvYmluYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9ib29sLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9mbG9hdC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvaW50LmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy9mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvanMvcmVnZXhwLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy91bmRlZmluZWQuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL21hcC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvbWVyZ2UuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL251bGwuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL29tYXAuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL3BhaXJzLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zZXEuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL3NldC5qcyIsIm5vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvc3RyLmpzIiwibm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS90aW1lc3RhbXAuanMiLCJub2RlX21vZHVsZXMvanMteWFtbC9ub2RlX21vZHVsZXMvZXNwcmltYS9lc3ByaW1hLmpzIiwibm9kZV9tb2R1bGVzL2xvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcyIsIm5vZGVfbW9kdWxlcy9tYXRjaC1mZWF0dXJlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BiZi9idWZmZXIuanMiLCJub2RlX21vZHVsZXMvcGJmL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmlwLWNvbW1lbnRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3VucnVseS9saWIvdW5ydWx5LmpzIiwibm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2xpYi92ZWN0b3J0aWxlLmpzIiwibm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2xpYi92ZWN0b3J0aWxlZmVhdHVyZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9saWIvdmVjdG9ydGlsZWxheWVyLmpzIiwibm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL25vZGVfbW9kdWxlcy9wb2ludC1nZW9tZXRyeS9pbmRleC5qcyIsIi9ob21lL2l2YW4vZGV2L21hcHplbi90YW5ncmFtL3NyYy9jYW1lcmEuanMiLCIvaG9tZS9pdmFuL2Rldi9tYXB6ZW4vdGFuZ3JhbS9zcmMvZ2VvLmpzIiwiL2hvbWUvaXZhbi9kZXYvbWFwemVuL3RhbmdyYW0vc3JjL2dsL2NvbnN0YW50cy5qcyIsIi9ob21lL2l2YW4vZGV2L21hcHplbi90YW5ncmFtL3NyYy9nbC9jb250ZXh0LmpzIiwiL2hvbWUvaXZhbi9kZXYvbWFwemVuL3RhbmdyYW0vc3JjL2dsL2dsc2wuanMiLCIvaG9tZS9pdmFuL2Rldi9tYXB6ZW4vdGFuZ3JhbS9zcmMvZ2wvc2hhZGVyX3Byb2dyYW0uanMiLCIvaG9tZS9pdmFuL2Rldi9tYXB6ZW4vdGFuZ3JhbS9zcmMvZ2wvc2hhZGVyX3NvdXJjZXMuanMiLCIvaG9tZS9pdmFuL2Rldi9tYXB6ZW4vdGFuZ3JhbS9zcmMvZ2wvdGV4dHVyZS5qcyIsIi9ob21lL2l2YW4vZGV2L21hcHplbi90YW5ncmFtL3NyYy9nbC92Ym9fbWVzaC5qcyIsIi9ob21lL2l2YW4vZGV2L21hcHplbi90YW5ncmFtL3NyYy9nbC92ZXJ0ZXhfZGF0YS5qcyIsIi9ob21lL2l2YW4vZGV2L21hcHplbi90YW5ncmFtL3NyYy9nbC92ZXJ0ZXhfbGF5b3V0LmpzIiwiL2hvbWUvaXZhbi9kZXYvbWFwemVuL3RhbmdyYW0vc3JjL2xlYWZsZXRfbGF5ZXIuanMiLCIvaG9tZS9pdmFuL2Rldi9tYXB6ZW4vdGFuZ3JhbS9zcmMvbGlnaHQuanMiLCIvaG9tZS9pdmFuL2Rldi9tYXB6ZW4vdGFuZ3JhbS9zcmMvbWF0ZXJpYWwuanMiLCIvaG9tZS9pdmFuL2Rldi9tYXB6ZW4vdGFuZ3JhbS9zcmMvbW9kdWxlLmpzIiwiL2hvbWUvaXZhbi9kZXYvbWFwemVuL3RhbmdyYW0vc3JjL3NjZW5lLmpzIiwiL2hvbWUvaXZhbi9kZXYvbWFwemVuL3RhbmdyYW0vc3JjL3NjZW5lX3dvcmtlci5qcyIsIi9ob21lL2l2YW4vZGV2L21hcHplbi90YW5ncmFtL3NyYy9zZWxlY3Rpb24uanMiLCIvaG9tZS9pdmFuL2Rldi9tYXB6ZW4vdGFuZ3JhbS9zcmMvc3R5bGVzL2J1aWxkZXJzLmpzIiwiL2hvbWUvaXZhbi9kZXYvbWFwemVuL3RhbmdyYW0vc3JjL3N0eWxlcy9wb2ludHMvcG9pbnRzLmpzIiwiL2hvbWUvaXZhbi9kZXYvbWFwemVuL3RhbmdyYW0vc3JjL3N0eWxlcy9wb2x5Z29ucy9wb2x5Z29ucy5qcyIsIi9ob21lL2l2YW4vZGV2L21hcHplbi90YW5ncmFtL3NyYy9zdHlsZXMvcnVsZS5qcyIsIi9ob21lL2l2YW4vZGV2L21hcHplbi90YW5ncmFtL3NyYy9zdHlsZXMvc3ByaXRlcy9zcHJpdGVzLmpzIiwiL2hvbWUvaXZhbi9kZXYvbWFwemVuL3RhbmdyYW0vc3JjL3N0eWxlcy9zdHlsZS5qcyIsIi9ob21lL2l2YW4vZGV2L21hcHplbi90YW5ncmFtL3NyYy9zdHlsZXMvc3R5bGVfbWFuYWdlci5qcyIsIi9ob21lL2l2YW4vZGV2L21hcHplbi90YW5ncmFtL3NyYy9zdHlsZXMvc3R5bGVfcGFyc2VyLmpzIiwiL2hvbWUvaXZhbi9kZXYvbWFwemVuL3RhbmdyYW0vc3JjL3N0eWxlcy90ZXh0L2xhYmVsLmpzIiwiL2hvbWUvaXZhbi9kZXYvbWFwemVuL3RhbmdyYW0vc3JjL3N0eWxlcy90ZXh0L3RleHQuanMiLCIvaG9tZS9pdmFuL2Rldi9tYXB6ZW4vdGFuZ3JhbS9zcmMvdGlsZS5qcyIsIi9ob21lL2l2YW4vZGV2L21hcHplbi90YW5ncmFtL3NyYy90aWxlX3NvdXJjZS5qcyIsIi9ob21lL2l2YW4vZGV2L21hcHplbi90YW5ncmFtL3NyYy91dGlscy9lcnJvcnMuanMiLCIvaG9tZS9pdmFuL2Rldi9tYXB6ZW4vdGFuZ3JhbS9zcmMvdXRpbHMvc3Vic2NyaWJlLmpzIiwiL2hvbWUvaXZhbi9kZXYvbWFwemVuL3RhbmdyYW0vc3JjL3V0aWxzL3V0aWxzLmpzIiwiL2hvbWUvaXZhbi9kZXYvbWFwemVuL3RhbmdyYW0vc3JjL3V0aWxzL3dvcmtlcl9icm9rZXIuanMiLCIvaG9tZS9pdmFuL2Rldi9tYXB6ZW4vdGFuZ3JhbS9zcmMvdmVjdG9yLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2piQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JOQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWhDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcmdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4cElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2lEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDblpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOWNBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBREEsS0FBSyxpQkFBaUIsQUFBQyxDQUFDLE9BQU07U0FBOUIsRUFBQyxHQUFFLFlBQXFCO0FBQUUsdUJBQXdCO0lBQUUsQUFBOUIsQ0FBQztBQUF2QixXQUFTLENBQVQsRUFBQyxLQUFJLENBQU8sS0FBRyxBQUFTLENBQUM7Q0FBeUIsQ0FBQzs7Ozs7RUFDNUMsSUFBRSxFQURULEVBQUMsVUFBb0IsQ0FBQSxPQUFNLEFBQUMsU0FBa0IsQ0FDdEMsQ0FBQSxXQUFxQixv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LENBQUEsQ0FBQSxFQUFJLENBQUEsT0FBTSxPQUFPLEVBQUksRUFBQSxDQUFHLENBQUEsQ0FBQSxFQUFFLENBQUc7QUFFdkMsQUFBSSxVQUFBLENBQUEsYUFBWSxFQUFJLEVBRWhCLENBQUMsT0FBTSxDQUFFLENBQUEsRUFBRSxFQUFBLENBQUMsQ0FBRSxDQUFBLENBQUMsQ0FBRyxDQUFBLE9BQU0sQ0FBRSxDQUFBLEVBQUUsRUFBQSxDQUFDLENBQUUsQ0FBQSxDQUFDLENBQUcsTUFBSSxDQUFDLENBQ3hDLEVBQUMsT0FBTSxDQUFFLENBQUEsRUFBRSxFQUFBLENBQUMsQ0FBRSxDQUFBLENBQUMsQ0FBRyxDQUFBLE9BQU0sQ0FBRSxDQUFBLEVBQUUsRUFBQSxDQUFDLENBQUUsQ0FBQSxDQUFDLENBQUcsTUFBSSxDQUFDLENBQ3hDLEVBQUMsT0FBTSxDQUFFLENBQUEsQ0FBQyxDQUFFLENBQUEsQ0FBQyxDQUFHLENBQUEsT0FBTSxDQUFFLENBQUEsQ0FBQyxDQUFFLENBQUEsQ0FBQyxDQUFHLE1BQUksQ0FBQyxDQUVwQyxFQUFDLE9BQU0sQ0FBRSxDQUFBLENBQUMsQ0FBRSxDQUFBLENBQUMsQ0FBRyxDQUFBLE9BQU0sQ0FBRSxDQUFBLENBQUMsQ0FBRSxDQUFBLENBQUMsQ0FBRyxNQUFJLENBQUMsQ0FDcEMsRUFBQyxPQUFNLENBQUUsQ0FBQSxDQUFDLENBQUUsQ0FBQSxDQUFDLENBQUcsQ0FBQSxPQUFNLENBQUUsQ0FBQSxDQUFDLENBQUUsQ0FBQSxDQUFDLENBQUcsTUFBSSxDQUFDLENBQ3BDLEVBQUMsT0FBTSxDQUFFLENBQUEsRUFBRSxFQUFBLENBQUMsQ0FBRSxDQUFBLENBQUMsQ0FBRyxDQUFBLE9BQU0sQ0FBRSxDQUFBLEVBQUUsRUFBQSxDQUFDLENBQUUsQ0FBQSxDQUFDLENBQUcsTUFBSSxDQUFDLENBQzVDLENBQUM7QUFHRCxBQUFJLFVBQUEsQ0FBQSxNQUFLLEVBQUksQ0FBQSxNQUFLLE1BQU0sQUFBQyxDQUNyQixDQUFDLENBQUEsQ0FBRyxFQUFBLENBQUcsRUFBQSxDQUFDLENBQ1Is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TUFBTSxDQUFBLENBQUksQ0FBQSxLQUFJLEVBQUUsQ0FBQSxTQUFRLE1BQU0sQ0FBQztBQUN4RSxPQUFDLEVBQUksRUFBQyxTQUFRLE1BQU0sQ0FBRyxDQUFBLENBQUMsQ0FBQSxFQUFFLE1BQUksQ0FBQyxFQUFFLENBQUEsU0FBUSxNQUFNLENBQUEsQ0FBSSxDQUFBLEtBQUksRUFBRSxDQUFBLFNBQVEsTUFBTSxDQUFDLENBQUM7QUFFN0UsS0FBSSxNQUFLLENBQUc7QUFDUixZQUFRLEFBQUMsQ0FBQyxNQUFLLENBQUUsQ0FBQSxDQUFDLENBQUcsR0FBQyxDQUFHLEdBQUMsQ0FBRyxVQUFRLENBQUMsQ0FBQztBQUN2QyxZQUFRLEFBQUMsQ0FBQyxNQUFLLENBQUUsQ0FBQSxDQUFDLENBQUcsR0FBQyxDQUFHLEdBQUMsQ0FBRyxVQUFRLENBQUMsQ0FBQztFQUMzQyxLQUFPO0FBQ0gsS0FBQyxFQUFJLENBQUEsTUFBSyxJQUFJLEFBQUMsQ0FBQyxDQUFBLENBQUUsQ0FBQSxDQUFDLENBQUMsQ0FBQztBQUNyQixLQUFDLEVBQUksQ0FBQSxDQUFBLENBQUUsQ0FBQSxDQUFDLENBQUM7QUFDVCxLQUFDLEVBQUksQ0FBQSxNQUFLLElBQUksQUFBQyxDQUFDLENBQUEsQ0FBRSxDQUFBLENBQUMsQ0FBQyxDQUFDO0FBQ3JCLEtBQUMsRUFBSSxFQUFDLFNBQVEsTUFBTSxDQUFHLENBQUEsQ0FBQyxDQUFBLEVBQUUsTUFBSSxDQUFDLEVBQUUsQ0FBQSxTQUFRLE1BQU0sQ0FBQSxDQUFJLENBQUEsS0FBSSxFQUFFLENBQUEsU0FBUSxNQUFNLENBQUMsQ0FBQztBQUN6RSxLQUFDLEVBQUksRUFBQyxTQUFRLE1BQU0sQ0FBRyxDQUFBLENBQUMsQ0FBQSxFQUFFLE1BQUksQ0FBQyxFQUFFLENBQUEsU0FBUSxNQUFNLENBQUEsQ0FBSSxDQUFBLEtBQUksRUFBRSxDQUFBLFNBQVEsTUFBTSxDQUFDLENBQUM7QUFDekUsS0FBQyxFQUFJLEVBQUMsU0FBUSxNQUFNLENBQUcsQ0FBQSxDQUFDLENBQUEsRUFBRSxNQUFJLENB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QUFDLEtBQUksQ0FBRyxNQUFJLENBQUMsQ0FDYixFQUFDLEtBQUksQ0FBRyxNQUFJLENBQUMsQ0FFYixFQUFDLEtBQUksQ0FBRyxNQUFJLENBQUMsQ0FDYixFQUFDLEtBQUksQ0FBRyxNQUFJLENBQUMsQ0FDYixFQUFDLEtBQUksQ0FBRyxNQUFJLENBQUMsQ0FDakIsQ0FBQztFQUNMO0FBQUEsQUFFSSxJQUFBLENBQUEsVUFBUyxFQUFJLENBQUEsTUFBSyxPQUFPLENBQUM7QUFDOUIsTUFBUyxHQUFBLENBQUEsQ0FBQSxFQUFFLEVBQUEsQ0FBRyxDQUFBLENBQUEsRUFBSSxXQUFTLENBQUcsQ0FBQSxDQUFBLEVBQUUsQ0FBRztBQUMvQixBQUFJLE1BQUEsQ0FBQSxLQUFJLEVBQUksQ0FBQSxNQUFLLENBQUUsQ0FBQSxDQUFDLENBQUM7QUFFckIsQUFBSSxNQUFBLENBQUEsU0FBUSxFQUFJLEVBQ1osQ0FBQyxLQUFJLENBQUUsQ0FBQSxDQUFDLEVBQUksQ0FBQSxLQUFJLEVBQUUsRUFBQSxDQUFHLENBQUEsS0FBSSxDQUFFLENBQUEsQ0FBQyxFQUFJLENBQUEsTUFBSyxFQUFFLEVBQUEsQ0FBQyxDQUN4QyxFQUFDLEtBQUksQ0FBRSxDQUFBLENBQUMsRUFBSSxDQUFBLEtBQUksRUFBRSxFQUFBLENBQUcsQ0FBQSxLQUFJLENBQUUsQ0FBQSxDQUFDLEVBQUksQ0FBQSxNQUFLLEVBQUUsRUFBQSxDQUFDLENBQ3hDLEVBQUMsS0FBSSxDQUFFLENBQUEsQ0FBQyxFQUFJLENBQUEsS0FBSSxFQUFFLEVBQUEsQ0FBRyxDQUFBLEtBQUksQ0FBRSxDQUFBLENBQUMsRUFBSSxDQUFBLE1BQUssRUFBRSxFQUFBLENBQUMsQ0FFeEMsRUFBQyxLQUFJLENBQUUsQ0FBQSxDQUFDLEVBQUksQ0FBQSxLQUFJLEVBQUUsRUFBQSxDQUFHLENBQUEsS0FBSSxDQUFFLENBQUEsQ0FBQyxFQUFJLENBQUEsTUFBSyxFQUFFLEVBQUEsQ0FBQyxDQUN4QyxFQUFDLEtBQUksQ0FBRSxDQUFBLENBQUMsRUFBSSxDQUFBLEtBQUksRUFB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QUksQ0FBQSxFQUFDLENBQUUsQ0FBQSxDQUFDLENBQUMsQ0FBQztBQUMxQyxBQUFJLElBQUEsQ0FBQSxLQUFJLEVBQUksQ0FBQSxDQUFDLEVBQUMsRUFBSSxHQUFDLENBQUMsRUFBSSxFQUFDLEVBQUMsRUFBSSxHQUFDLENBQUMsQ0FBQztBQUVqQyxLQUFJLElBQUcsSUFBSSxBQUFDLENBQUMsS0FBSSxDQUFDLENBQUEsQ0FBSSxtQkFBaUIsQ0FBRztBQUN0QyxTQUFPLEVBQ0gsQ0FBQyxDQUFDLEVBQUMsRUFBSSxHQUFDLENBQUMsRUFBSSxFQUFDLEVBQUMsRUFBSSxHQUFDLENBQUMsQ0FBQyxFQUFJLE1BQUksQ0FDOUIsQ0FBQSxDQUFDLENBQUMsRUFBQyxFQUFJLEdBQUMsQ0FBQyxFQUFJLEVBQUMsRUFBQyxFQUFJLEdBQUMsQ0FBQyxDQUFDLEVBQUksTUFBSSxDQUNsQyxDQUFDO0VBQ0w7QUFBQSxBQUNBLE9BQU8sS0FBRyxDQUFDO0FBQ2YsQ0FBQztBQUNEIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJveEludGVyc2VjdFdyYXBwZXJcblxudmFyIHBvb2wgPSByZXF1aXJlKCd0eXBlZGFycmF5LXBvb2wnKVxudmFyIHN3ZWVwID0gcmVxdWlyZSgnLi9saWIvc3dlZXAnKVxudmFyIGJveEludGVyc2VjdEl0ZXIgPSByZXF1aXJlKCcuL2xpYi9pbnRlcnNlY3QnKVxuXG5mdW5jdGlvbiBib3hFbXB0eShkLCBib3gpIHtcbiAgZm9yKHZhciBqPTA7IGo8ZDsgKytqKSB7XG4gICAgaWYoIShib3hbal0gPD0gYm94W2orZF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy9VbnBhY2sgYm94ZXMgaW50byBhIGZsYXQgdHlwZWQgYXJyYXksIHJlbW92ZSBlbXB0eSBib3hlc1xuZnVuY3Rpb24gY29udmVydEJveGVzKGJveGVzLCBkLCBkYXRhLCBpZHMpIHtcbiAgdmFyIHB0ciA9IDBcbiAgdmFyIGNvdW50ID0gMFxuICBmb3IodmFyIGk9MCwgbj1ib3hlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdmFyIGIgPSBib3hlc1tpXVxuICAgIGlmKGJveEVtcHR5KGQsIGIpKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBmb3IodmFyIGo9MDsgajwyKmQ7ICsraikge1xuICAgICAgZGF0YVtwdHIrK10gPSBiW2pdXG4gICAgfVxuICAgIGlkc1tjb3VudCsrXSA9IGlcbiAgfVxuICByZXR1cm4gY291bnRcbn1cblxuLy9QZXJmb3JtIHR5cGUgY29udmVyc2lvbnMsIGNoZWNrIGJvdW5kc1xuZnVuY3Rpb24gYm94SW50ZXJzZWN0KHJlZCwgYmx1ZSwgdmlzaXQsIGZ1bGwpIHtcbiAgdmFyIG4gPSByZWQubGVuZ3RoXG4gIHZhciBtID0gYmx1ZS5sZW5ndGhcblxuICAvL0lmIGVpdGhlciBhcnJheSBpcyBlbXB0eSwgdGhlbiB3ZSBjYW4gc2tpcCB0aGlzIHdob2xlIHRoaW5nXG4gIGlmKG4gPD0gMCB8fCBtIDw9IDApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vQ29tcHV0ZSBkaW1lbnNpb24sIGlmIGl0IGlzIDAgdGhlbiB3ZSBza2lwXG4gIHZhciBkID0gKHJlZFswXS5sZW5ndGgpPj4+MVxuICBpZihkIDw9IDApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciByZXR2YWxcblxuICAvL0NvbnZlcnQgcmVkIGJveGVzXG4gIHZhciByZWRMaXN0ICA9IHBvb2wubWFsbG9jRG91YmxlKDIqZCpuKVxuICB2YXIgcmVkSWRzICAgPSBwb29sLm1hbGxvY0ludDMyKG4pXG4gIG4gPSBjb252ZXJ0Qm94ZXMocmVkLCBkLCByZWRMaXN0LCByZWRJZHMpXG5cbiAgaWYobiA+IDApIHtcbiAgICBpZihkID09PSAxICYmIGZ1bGwpIHtcbiAgICAgIC8vU3BlY2lhbCBjYXNlOiAxZCBjb21wbGV0ZVxuICAgICAgc3dlZXAuaW5pdChuKVxuICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBDb21wbGV0ZShcbiAgICAgICAgZCwgdmlzaXQsIFxuICAgICAgICAwLCBuLCByZWRMaXN0LCByZWRJZHMsXG4gICAgICAgIDAsIG4sIHJlZExpc3QsIHJlZElkcylcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvL0NvbnZlcnQgYmx1ZSBib3hlc1xuICAgICAgdmFyIGJsdWVMaXN0ID0gcG9vbC5tYWxsb2NEb3VibGUoMipkKm0pXG4gICAgICB2YXIgYmx1ZUlkcyAgPSBwb29sLm1hbGxvY0ludDMyKG0pXG4gICAgICBtID0gY29udmVydEJveGVzKGJsdWUsIGQsIGJsdWVMaXN0LCBibHVlSWRzKVxuXG4gICAgICBpZihtID4gMCkge1xuICAgICAgICBzd2VlcC5pbml0KG4rbSlcblxuICAgICAgICBpZihkID09PSAxKSB7XG4gICAgICAgICAgLy9TcGVjaWFsIGNhc2U6IDFkIGJpcGFydGl0ZVxuICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQmlwYXJ0aXRlKFxuICAgICAgICAgICAgZCwgdmlzaXQsIFxuICAgICAgICAgICAgMCwgbiwgcmVkTGlzdCwgIHJlZElkcyxcbiAgICAgICAgICAgIDAsIG0sIGJsdWVMaXN0LCBibHVlSWRzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vR2VuZXJhbCBjYXNlOiAgZD4xXG4gICAgICAgICAgcmV0dmFsID0gYm94SW50ZXJzZWN0SXRlcihcbiAgICAgICAgICAgIGQsIHZpc2l0LCAgICBmdWxsLFxuICAgICAgICAgICAgbiwgcmVkTGlzdCwgIHJlZElkcyxcbiAgICAgICAgICAgIG0sIGJsdWVMaXN0LCBibHVlSWRzKVxuICAgICAgICB9XG5cbiAgICAgICAgcG9vbC5mcmVlKGJsdWVMaXN0KVxuICAgICAgICBwb29sLmZyZWUoYmx1ZUlkcylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwb29sLmZyZWUocmVkTGlzdClcbiAgICBwb29sLmZyZWUocmVkSWRzKVxuICB9XG5cbiAgcmV0dXJuIHJldHZhbFxufVxuXG5cbnZhciBSRVNVTFRcblxuZnVuY3Rpb24gYXBwZW5kSXRlbShpLGopIHtcbiAgUkVTVUxULnB1c2goW2ksal0pXG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdEZ1bGxBcnJheSh4KSB7XG4gIFJFU1VMVCA9IFtdXG4gIGJveEludGVyc2VjdCh4LCB4LCBhcHBlbmRJdGVtLCB0cnVlKVxuICByZXR1cm4gUkVTVUxUXG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdEJpcGFydGl0ZUFycmF5KHgsIHkpIHtcbiAgUkVTVUxUID0gW11cbiAgYm94SW50ZXJzZWN0KHgsIHksIGFwcGVuZEl0ZW0sIGZhbHNlKVxuICByZXR1cm4gUkVTVUxUXG59XG5cbi8vVXNlci1mcmllbmRseSB3cmFwcGVyLCBoYW5kbGUgZnVsbCBpbnB1dCBhbmQgbm8tdmlzaXRvciBjYXNlc1xuZnVuY3Rpb24gYm94SW50ZXJzZWN0V3JhcHBlcihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gIHZhciByZXN1bHRcbiAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gaW50ZXJzZWN0RnVsbEFycmF5KGFyZzApXG4gICAgY2FzZSAyOlxuICAgICAgaWYodHlwZW9mIGFyZzEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGJveEludGVyc2VjdChhcmcwLCBhcmcwLCBhcmcxLCB0cnVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGludGVyc2VjdEJpcGFydGl0ZUFycmF5KGFyZzAsIGFyZzEpXG4gICAgICB9XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGJveEludGVyc2VjdChhcmcwLCBhcmcxLCBhcmcyLCBmYWxzZSlcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdib3gtaW50ZXJzZWN0OiBJbnZhbGlkIGFyZ3VtZW50cycpXG4gIH1cbn0iLCIndXNlIHN0cmljdCdcblxudmFyIERJTUVOU0lPTiAgID0gJ2QnXG52YXIgQVhJUyAgICAgICAgPSAnYXgnXG52YXIgVklTSVQgICAgICAgPSAndnYnXG52YXIgRkxJUCAgICAgICAgPSAnZnAnXG5cbnZhciBFTEVNX1NJWkUgICA9ICdlcydcblxudmFyIFJFRF9TVEFSVCAgID0gJ3JzJ1xudmFyIFJFRF9FTkQgICAgID0gJ3JlJ1xudmFyIFJFRF9CT1hFUyAgID0gJ3JiJ1xudmFyIFJFRF9JTkRFWCAgID0gJ3JpJ1xudmFyIFJFRF9QVFIgICAgID0gJ3JwJ1xuXG52YXIgQkxVRV9TVEFSVCAgPSAnYnMnXG52YXIgQkxVRV9FTkQgICAgPSAnYmUnXG52YXIgQkxVRV9CT1hFUyAgPSAnYmInXG52YXIgQkxVRV9JTkRFWCAgPSAnYmknXG52YXIgQkxVRV9QVFIgICAgPSAnYnAnXG5cbnZhciBSRVRWQUwgICAgICA9ICdydidcblxudmFyIElOTkVSX0xBQkVMID0gJ1EnXG5cbnZhciBBUkdTID0gW1xuICBESU1FTlNJT04sXG4gIEFYSVMsXG4gIFZJU0lULFxuICBSRURfU1RBUlQsXG4gIFJFRF9FTkQsXG4gIFJFRF9CT1hFUyxcbiAgUkVEX0lOREVYLFxuICBCTFVFX1NUQVJULFxuICBCTFVFX0VORCxcbiAgQkxVRV9CT1hFUyxcbiAgQkxVRV9JTkRFWFxuXVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUJydXRlRm9yY2UocmVkTWFqb3IsIGZsaXAsIGZ1bGwpIHtcbiAgdmFyIGZ1bmNOYW1lID0gJ2JydXRlRm9yY2UnICsgXG4gICAgKHJlZE1ham9yID8gJ1JlZCcgOiAnQmx1ZScpICsgXG4gICAgKGZsaXAgPyAnRmxpcCcgOiAnJykgK1xuICAgIChmdWxsID8gJ0Z1bGwnIDogJycpXG5cbiAgdmFyIGNvZGUgPSBbJ2Z1bmN0aW9uICcsIGZ1bmNOYW1lLCAnKCcsIEFSR1Muam9pbigpLCAnKXsnLFxuICAgICd2YXIgJywgRUxFTV9TSVpFLCAnPTIqJywgRElNRU5TSU9OLCAnOyddXG5cbiAgdmFyIHJlZExvb3AgPSBcbiAgICAnZm9yKHZhciBpPScgKyBSRURfU1RBUlQgKyAnLCcgKyBSRURfUFRSICsgJz0nICsgRUxFTV9TSVpFICsgJyonICsgUkVEX1NUQVJUICsgJzsnICtcbiAgICAgICAgJ2k8JyArIFJFRF9FTkQgKyc7JyArXG4gICAgICAgICcrK2ksJyArIFJFRF9QVFIgKyAnKz0nICsgRUxFTV9TSVpFICsgJyl7JyArXG4gICAgICAgICd2YXIgeDA9JyArIFJFRF9CT1hFUyArICdbJyArIEFYSVMgKyAnKycgKyBSRURfUFRSICsgJ10sJyArXG4gICAgICAgICAgICAneDE9JyArIFJFRF9CT1hFUyArICdbJyArIEFYSVMgKyAnKycgKyBSRURfUFRSICsgJysnICsgRElNRU5TSU9OICsgJ10sJyArXG4gICAgICAgICAgICAneGk9JyArIFJFRF9JTkRFWCArICdbaV07J1xuXG4gIHZhciBibHVlTG9vcCA9IFxuICAgICdmb3IodmFyIGo9JyArIEJMVUVfU1RBUlQgKyAnLCcgKyBCTFVFX1BUUiArICc9JyArIEVMRU1fU0laRSArICcqJyArIEJMVUVfU1RBUlQgKyAnOycgK1xuICAgICAgICAnajwnICsgQkxVRV9FTkQgKyAnOycgK1xuICAgICAgICAnKytqLCcgKyBCTFVFX1BUUiArICcrPScgKyBFTEVNX1NJWkUgKyAnKXsnICtcbiAgICAgICAgJ3ZhciB5MD0nICsgQkxVRV9CT1hFUyArICdbJyArIEFYSVMgKyAnKycgKyBCTFVFX1BUUiArICddLCcgK1xuICAgICAgICAgICAgKGZ1bGwgPyAneTE9JyArIEJMVUVfQk9YRVMgKyAnWycgKyBBWElTICsgJysnICsgQkxVRV9QVFIgKyAnKycgKyBESU1FTlNJT04gKyAnXSwnIDogJycpICtcbiAgICAgICAgICAgICd5aT0nICsgQkxVRV9JTkRFWCArICdbal07J1xuXG4gIGlmKHJlZE1ham9yKSB7XG4gICAgY29kZS5wdXNoKHJlZExvb3AsIElOTkVSX0xBQkVMLCAnOicsIGJsdWVMb29wKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChibHVlTG9vcCwgSU5ORVJfTEFCRUwsICc6JywgcmVkTG9vcClcbiAgfVxuXG4gIGlmKGZ1bGwpIHtcbiAgICBjb2RlLnB1c2goJ2lmKHkxPHgwfHx4MTx5MCljb250aW51ZTsnKVxuICB9IGVsc2UgaWYoZmxpcCkge1xuICAgIGNvZGUucHVzaCgnaWYoeTA8PXgwfHx4MTx5MCljb250aW51ZTsnKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaCgnaWYoeTA8eDB8fHgxPHkwKWNvbnRpbnVlOycpXG4gIH1cblxuICBjb2RlLnB1c2goJ2Zvcih2YXIgaz0nK0FYSVMrJysxO2s8JytESU1FTlNJT04rJzsrK2speycrXG4gICAgJ3ZhciByMD0nK1JFRF9CT1hFUysnW2srJytSRURfUFRSKyddLCcrXG4gICAgICAgICdyMT0nK1JFRF9CT1hFUysnW2srJytESU1FTlNJT04rJysnK1JFRF9QVFIrJ10sJytcbiAgICAgICAgJ2IwPScrQkxVRV9CT1hFUysnW2srJytCTFVFX1BUUisnXSwnK1xuICAgICAgICAnYjE9JytCTFVFX0JPWEVTKydbaysnK0RJTUVOU0lPTisnKycrQkxVRV9QVFIrJ107JytcbiAgICAgICdpZihyMTxiMHx8YjE8cjApY29udGludWUgJyArIElOTkVSX0xBQkVMICsgJzt9JyArXG4gICAgICAndmFyICcgKyBSRVRWQUwgKyAnPScgKyBWSVNJVCArICcoJylcblxuICBpZihmbGlwKSB7XG4gICAgY29kZS5wdXNoKCd5aSx4aScpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKCd4aSx5aScpXG4gIH1cblxuICBjb2RlLnB1c2goJyk7aWYoJyArIFJFVFZBTCArICchPT12b2lkIDApcmV0dXJuICcgKyBSRVRWQUwgKyAnO319fScpXG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBmdW5jTmFtZSwgXG4gICAgY29kZTogY29kZS5qb2luKCcnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJydXRlRm9yY2VQbGFubmVyKGZ1bGwpIHtcbiAgdmFyIGZ1bmNOYW1lID0gJ2JydXRlRm9yY2UnICsgKGZ1bGwgPyAnRnVsbCcgOiAnUGFydGlhbCcpXG4gIHZhciBwcmVmaXggPSBbXVxuICB2YXIgZmFyZ3MgPSBBUkdTLnNsaWNlKClcbiAgaWYoIWZ1bGwpIHtcbiAgICBmYXJncy5zcGxpY2UoMywgMCwgRkxJUClcbiAgfVxuXG4gIHZhciBjb2RlID0gWydmdW5jdGlvbiAnICsgZnVuY05hbWUgKyAnKCcgKyBmYXJncy5qb2luKCkgKyAnKXsnXVxuXG4gIGZ1bmN0aW9uIGludm9rZShyZWRNYWpvciwgZmxpcCkge1xuICAgIHZhciByZXMgPSBnZW5lcmF0ZUJydXRlRm9yY2UocmVkTWFqb3IsIGZsaXAsIGZ1bGwpXG4gICAgcHJlZml4LnB1c2gocmVzLmNvZGUpXG4gICAgY29kZS5wdXNoKCdyZXR1cm4gJyArIHJlcy5uYW1lICsgJygnICsgQVJHUy5qb2luKCkgKyAnKTsnKVxuICB9XG5cbiAgY29kZS5wdXNoKCdpZignICsgUkVEX0VORCArICctJyArIFJFRF9TVEFSVCArICc+JyArXG4gICAgICAgICAgICAgICAgICAgIEJMVUVfRU5EICsgJy0nICsgQkxVRV9TVEFSVCArICcpeycpXG5cbiAgaWYoZnVsbCkge1xuICAgIGludm9rZSh0cnVlLCBmYWxzZSlcbiAgICBjb2RlLnB1c2goJ31lbHNleycpXG4gICAgaW52b2tlKGZhbHNlLCBmYWxzZSlcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goJ2lmKCcgKyBGTElQICsgJyl7JylcbiAgICBpbnZva2UodHJ1ZSwgdHJ1ZSlcbiAgICBjb2RlLnB1c2goJ31lbHNleycpXG4gICAgaW52b2tlKHRydWUsIGZhbHNlKVxuICAgIGNvZGUucHVzaCgnfX1lbHNle2lmKCcgKyBGTElQICsgJyl7JylcbiAgICBpbnZva2UoZmFsc2UsIHRydWUpXG4gICAgY29kZS5wdXNoKCd9ZWxzZXsnKVxuICAgIGludm9rZShmYWxzZSwgZmFsc2UpXG4gICAgY29kZS5wdXNoKCd9JylcbiAgfVxuICBjb2RlLnB1c2goJ319cmV0dXJuICcgKyBmdW5jTmFtZSlcblxuICB2YXIgY29kZVN0ciA9IHByZWZpeC5qb2luKCcnKSArIGNvZGUuam9pbignJylcbiAgdmFyIHByb2MgPSBuZXcgRnVuY3Rpb24oY29kZVN0cilcbiAgcmV0dXJuIHByb2MoKVxufVxuXG5cbmV4cG9ydHMucGFydGlhbCA9IGJydXRlRm9yY2VQbGFubmVyKGZhbHNlKVxuZXhwb3J0cy5mdWxsICAgID0gYnJ1dGVGb3JjZVBsYW5uZXIodHJ1ZSkiLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBib3hJbnRlcnNlY3RJdGVyXG5cbnZhciBwb29sID0gcmVxdWlyZSgndHlwZWRhcnJheS1wb29sJylcbnZhciBiaXRzID0gcmVxdWlyZSgnYml0LXR3aWRkbGUnKVxudmFyIGJydXRlRm9yY2UgPSByZXF1aXJlKCcuL2JydXRlJylcbnZhciBicnV0ZUZvcmNlUGFydGlhbCA9IGJydXRlRm9yY2UucGFydGlhbFxudmFyIGJydXRlRm9yY2VGdWxsID0gYnJ1dGVGb3JjZS5mdWxsXG52YXIgc3dlZXAgPSByZXF1aXJlKCcuL3N3ZWVwJylcbnZhciBmaW5kTWVkaWFuID0gcmVxdWlyZSgnLi9tZWRpYW4nKVxudmFyIGdlblBhcnRpdGlvbiA9IHJlcXVpcmUoJy4vcGFydGl0aW9uJylcblxuLy9Ud2lkZGxlIHBhcmFtZXRlcnNcbnZhciBCUlVURV9GT1JDRV9DVVRPRkYgICAgPSAxMjggICAgICAgLy9DdXQgb2ZmIGZvciBicnV0ZSBmb3JjZSBzZWFyY2hcbnZhciBTQ0FOX0NVVE9GRiAgICAgICAgICAgPSAoMTw8MjIpICAgLy9DdXQgb2ZmIGZvciB0d28gd2F5IHNjYW5cbnZhciBTQ0FOX0NPTVBMRVRFX0NVVE9GRiAgPSAoMTw8MjIpICBcblxuLy9QYXJ0aXRpb24gZnVuY3Rpb25zXG52YXIgcGFydGl0aW9uSW50ZXJpb3JDb250YWluc0ludGVydmFsID0gZ2VuUGFydGl0aW9uKFxuICAnIShsbz49cDApJiYhKHAxPj1oaSknLCBcbiAgWydwMCcsICdwMSddKVxuXG52YXIgcGFydGl0aW9uU3RhcnRFcXVhbCA9IGdlblBhcnRpdGlvbihcbiAgJ2xvPT09cDAnLFxuICBbJ3AwJ10pXG5cbnZhciBwYXJ0aXRpb25TdGFydExlc3NUaGFuID0gZ2VuUGFydGl0aW9uKFxuICAnbG88cDAnLFxuICBbJ3AwJ10pXG5cbnZhciBwYXJ0aXRpb25FbmRMZXNzVGhhbkVxdWFsID0gZ2VuUGFydGl0aW9uKFxuICAnaGk8PXAwJyxcbiAgWydwMCddKVxuXG52YXIgcGFydGl0aW9uQ29udGFpbnNQb2ludCA9IGdlblBhcnRpdGlvbihcbiAgJ2xvPD1wMCYmcDA8PWhpJyxcbiAgWydwMCddKVxuXG52YXIgcGFydGl0aW9uQ29udGFpbnNQb2ludFByb3BlciA9IGdlblBhcnRpdGlvbihcbiAgJ2xvPHAwJiZwMDw9aGknLFxuICBbJ3AwJ10pXG5cbi8vRnJhbWUgc2l6ZSBmb3IgaXRlcmF0aXZlIGxvb3BcbnZhciBJRlJBTUVfU0laRSA9IDZcbnZhciBERlJBTUVfU0laRSA9IDJcblxuLy9EYXRhIGZvciBib3ggc3RhdGNrXG52YXIgSU5JVF9DQVBBQ0lUWSA9IDEwMjRcbnZhciBCT1hfSVNUQUNLICA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBCT1hfRFNUQUNLICA9IHBvb2wubWFsbG9jRG91YmxlKElOSVRfQ0FQQUNJVFkpXG5cbi8vSW5pdGlhbGl6ZSBpdGVyYXRpdmUgbG9vcCBxdWV1ZVxuZnVuY3Rpb24gaXRlckluaXQoZCwgY291bnQpIHtcbiAgdmFyIGxldmVscyA9ICg4ICogYml0cy5sb2cyKGNvdW50KzEpICogKGQrMSkpfDBcbiAgdmFyIG1heEludHMgPSBiaXRzLm5leHRQb3cyKElGUkFNRV9TSVpFKmxldmVscylcbiAgaWYoQk9YX0lTVEFDSy5sZW5ndGggPCBtYXhJbnRzKSB7XG4gICAgcG9vbC5mcmVlKEJPWF9JU1RBQ0spXG4gICAgQk9YX0lTVEFDSyA9IHBvb2wubWFsbG9jSW50MzIobWF4SW50cylcbiAgfVxuICB2YXIgbWF4RG91YmxlcyA9IGJpdHMubmV4dFBvdzIoREZSQU1FX1NJWkUqbGV2ZWxzKVxuICBpZihCT1hfRFNUQUNLIDwgbWF4RG91Ymxlcykge1xuICAgIHBvb2wuZnJlZShCT1hfRFNUQUNLKVxuICAgIEJPWF9EU1RBQ0sgPSBwb29sLm1hbGxvY0RvdWJsZShtYXhEb3VibGVzKVxuICB9XG59XG5cbi8vQXBwZW5kIGl0ZW0gdG8gcXVldWVcbmZ1bmN0aW9uIGl0ZXJQdXNoKHB0cixcbiAgYXhpcywgXG4gIHJlZFN0YXJ0LCByZWRFbmQsIFxuICBibHVlU3RhcnQsIGJsdWVFbmQsIFxuICBzdGF0ZSwgXG4gIGxvLCBoaSkge1xuXG4gIHZhciBpcHRyID0gSUZSQU1FX1NJWkUgKiBwdHJcbiAgQk9YX0lTVEFDS1tpcHRyXSAgID0gYXhpc1xuICBCT1hfSVNUQUNLW2lwdHIrMV0gPSByZWRTdGFydFxuICBCT1hfSVNUQUNLW2lwdHIrMl0gPSByZWRFbmRcbiAgQk9YX0lTVEFDS1tpcHRyKzNdID0gYmx1ZVN0YXJ0XG4gIEJPWF9JU1RBQ0tbaXB0cis0XSA9IGJsdWVFbmRcbiAgQk9YX0lTVEFDS1tpcHRyKzVdID0gc3RhdGVcblxuICB2YXIgZHB0ciA9IERGUkFNRV9TSVpFICogcHRyXG4gIEJPWF9EU1RBQ0tbZHB0cl0gICA9IGxvXG4gIEJPWF9EU1RBQ0tbZHB0cisxXSA9IGhpXG59XG5cbi8vU3BlY2lhbCBjYXNlOiAgSW50ZXJzZWN0IHNpbmdsZSBwb2ludCB3aXRoIGxpc3Qgb2YgaW50ZXJ2YWxzXG5mdW5jdGlvbiBvbmVQb2ludFBhcnRpYWwoXG4gIGQsIGF4aXMsIHZpc2l0LCBmbGlwLFxuICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICBibHVlT2Zmc2V0LCBibHVlLCBibHVlSWQpIHtcblxuICB2YXIgZWxlbVNpemUgPSAyICogZFxuICB2YXIgYmx1ZVB0ciAgPSBibHVlT2Zmc2V0ICogZWxlbVNpemVcbiAgdmFyIGJsdWVYICAgID0gYmx1ZVtibHVlUHRyICsgYXhpc11cblxucmVkX2xvb3A6XG4gIGZvcih2YXIgaT1yZWRTdGFydCwgcmVkUHRyPXJlZFN0YXJ0KmVsZW1TaXplOyBpPHJlZEVuZDsgKytpLCByZWRQdHIrPWVsZW1TaXplKSB7XG4gICAgdmFyIHIwID0gcmVkW3JlZFB0citheGlzXVxuICAgIHZhciByMSA9IHJlZFtyZWRQdHIrYXhpcytkXVxuICAgIGlmKGJsdWVYIDwgcjAgfHwgcjEgPCBibHVlWCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYoZmxpcCAmJiBibHVlWCA9PT0gcjApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciByZWRJZCA9IHJlZEluZGV4W2ldXG4gICAgZm9yKHZhciBqPWF4aXMrMTsgajxkOyArK2opIHtcbiAgICAgIHZhciByMCA9IHJlZFtyZWRQdHIral1cbiAgICAgIHZhciByMSA9IHJlZFtyZWRQdHIraitkXVxuICAgICAgdmFyIGIwID0gYmx1ZVtibHVlUHRyK2pdXG4gICAgICB2YXIgYjEgPSBibHVlW2JsdWVQdHIraitkXVxuICAgICAgaWYocjEgPCBiMCB8fCBiMSA8IHIwKSB7XG4gICAgICAgIGNvbnRpbnVlIHJlZF9sb29wXG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXR2YWxcbiAgICBpZihmbGlwKSB7XG4gICAgICByZXR2YWwgPSB2aXNpdChibHVlSWQsIHJlZElkKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR2YWwgPSB2aXNpdChyZWRJZCwgYmx1ZUlkKVxuICAgIH1cbiAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHJldHZhbFxuICAgIH1cbiAgfVxufVxuXG4vL1NwZWNpYWwgY2FzZTogIEludGVyc2VjdCBvbmUgcG9pbnQgd2l0aCBsaXN0IG9mIGludGVydmFsc1xuZnVuY3Rpb24gb25lUG9pbnRGdWxsKFxuICBkLCBheGlzLCB2aXNpdCxcbiAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgYmx1ZU9mZnNldCwgYmx1ZSwgYmx1ZUlkKSB7XG5cbiAgdmFyIGVsZW1TaXplID0gMiAqIGRcbiAgdmFyIGJsdWVQdHIgID0gYmx1ZU9mZnNldCAqIGVsZW1TaXplXG4gIHZhciBibHVlWCAgICA9IGJsdWVbYmx1ZVB0ciArIGF4aXNdXG5cbnJlZF9sb29wOlxuICBmb3IodmFyIGk9cmVkU3RhcnQsIHJlZFB0cj1yZWRTdGFydCplbGVtU2l6ZTsgaTxyZWRFbmQ7ICsraSwgcmVkUHRyKz1lbGVtU2l6ZSkge1xuICAgIHZhciByZWRJZCA9IHJlZEluZGV4W2ldXG4gICAgaWYocmVkSWQgPT09IGJsdWVJZCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdmFyIHIwID0gcmVkW3JlZFB0citheGlzXVxuICAgIHZhciByMSA9IHJlZFtyZWRQdHIrYXhpcytkXVxuICAgIGlmKGJsdWVYIDwgcjAgfHwgcjEgPCBibHVlWCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgZm9yKHZhciBqPWF4aXMrMTsgajxkOyArK2opIHtcbiAgICAgIHZhciByMCA9IHJlZFtyZWRQdHIral1cbiAgICAgIHZhciByMSA9IHJlZFtyZWRQdHIraitkXVxuICAgICAgdmFyIGIwID0gYmx1ZVtibHVlUHRyK2pdXG4gICAgICB2YXIgYjEgPSBibHVlW2JsdWVQdHIraitkXVxuICAgICAgaWYocjEgPCBiMCB8fCBiMSA8IHIwKSB7XG4gICAgICAgIGNvbnRpbnVlIHJlZF9sb29wXG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXR2YWwgPSB2aXNpdChyZWRJZCwgYmx1ZUlkKVxuICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gcmV0dmFsXG4gICAgfVxuICB9XG59XG5cbi8vVGhlIG1haW4gYm94IGludGVyc2VjdGlvbiByb3V0aW5lXG5mdW5jdGlvbiBib3hJbnRlcnNlY3RJdGVyKFxuICBkLCB2aXNpdCwgaW5pdEZ1bGwsXG4gIHhTaXplLCB4Qm94ZXMsIHhJbmRleCxcbiAgeVNpemUsIHlCb3hlcywgeUluZGV4KSB7XG5cbiAgLy9SZXNlcnZlIG1lbW9yeSBmb3Igc3RhY2tcbiAgaXRlckluaXQoZCwgeFNpemUgKyB5U2l6ZSlcblxuICB2YXIgdG9wICA9IDBcbiAgdmFyIGVsZW1TaXplID0gMiAqIGRcbiAgdmFyIHJldHZhbFxuXG4gIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgMCxcbiAgICAgIDAsIHhTaXplLFxuICAgICAgMCwgeVNpemUsXG4gICAgICBpbml0RnVsbCA/IDE2IDogMCwgXG4gICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICBpZighaW5pdEZ1bGwpIHtcbiAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgIDAsXG4gICAgICAwLCB5U2l6ZSxcbiAgICAgIDAsIHhTaXplLFxuICAgICAgMSwgXG4gICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICB9XG5cbiAgd2hpbGUodG9wID4gMCkge1xuICAgIHRvcCAgLT0gMVxuXG4gICAgdmFyIGlwdHIgPSB0b3AgKiBJRlJBTUVfU0laRVxuICAgIHZhciBheGlzICAgICAgPSBCT1hfSVNUQUNLW2lwdHJdXG4gICAgdmFyIHJlZFN0YXJ0ICA9IEJPWF9JU1RBQ0tbaXB0cisxXVxuICAgIHZhciByZWRFbmQgICAgPSBCT1hfSVNUQUNLW2lwdHIrMl1cbiAgICB2YXIgYmx1ZVN0YXJ0ID0gQk9YX0lTVEFDS1tpcHRyKzNdXG4gICAgdmFyIGJsdWVFbmQgICA9IEJPWF9JU1RBQ0tbaXB0cis0XVxuICAgIHZhciBzdGF0ZSAgICAgPSBCT1hfSVNUQUNLW2lwdHIrNV1cblxuICAgIHZhciBkcHRyID0gdG9wICogREZSQU1FX1NJWkVcbiAgICB2YXIgbG8gICAgICAgID0gQk9YX0RTVEFDS1tkcHRyXVxuICAgIHZhciBoaSAgICAgICAgPSBCT1hfRFNUQUNLW2RwdHIrMV1cblxuICAgIC8vVW5wYWNrIHN0YXRlIGluZm9cbiAgICB2YXIgZmxpcCAgICAgID0gKHN0YXRlICYgMSlcbiAgICB2YXIgZnVsbCAgICAgID0gISEoc3RhdGUgJiAxNilcblxuICAgIC8vVW5wYWNrIGluZGljZXNcbiAgICB2YXIgcmVkICAgICAgID0geEJveGVzXG4gICAgdmFyIHJlZEluZGV4ICA9IHhJbmRleFxuICAgIHZhciBibHVlICAgICAgPSB5Qm94ZXNcbiAgICB2YXIgYmx1ZUluZGV4ID0geUluZGV4XG4gICAgaWYoZmxpcCkge1xuICAgICAgcmVkICAgICAgICAgPSB5Qm94ZXNcbiAgICAgIHJlZEluZGV4ICAgID0geUluZGV4XG4gICAgICBibHVlICAgICAgICA9IHhCb3hlc1xuICAgICAgYmx1ZUluZGV4ICAgPSB4SW5kZXhcbiAgICB9XG5cbiAgICBpZihzdGF0ZSAmIDIpIHtcbiAgICAgIHJlZEVuZCA9IHBhcnRpdGlvblN0YXJ0TGVzc1RoYW4oXG4gICAgICAgIGQsIGF4aXMsXG4gICAgICAgIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgIGhpKVxuICAgICAgaWYocmVkU3RhcnQgPj0gcmVkRW5kKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmKHN0YXRlICYgNCkge1xuICAgICAgcmVkU3RhcnQgPSBwYXJ0aXRpb25FbmRMZXNzVGhhbkVxdWFsKFxuICAgICAgICBkLCBheGlzLFxuICAgICAgICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICBsbylcbiAgICAgIGlmKHJlZFN0YXJ0ID49IHJlZEVuZCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB2YXIgcmVkQ291bnQgID0gcmVkRW5kICAtIHJlZFN0YXJ0XG4gICAgdmFyIGJsdWVDb3VudCA9IGJsdWVFbmQgLSBibHVlU3RhcnRcblxuICAgIGlmKGZ1bGwpIHtcbiAgICAgIGlmKGQgKiByZWRDb3VudCAqIChyZWRDb3VudCArIGJsdWVDb3VudCkgPCBTQ0FOX0NPTVBMRVRFX0NVVE9GRikge1xuICAgICAgICByZXR2YWwgPSBzd2VlcC5zY2FuQ29tcGxldGUoXG4gICAgICAgICAgZCwgYXhpcywgdmlzaXQsIFxuICAgICAgICAgIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGQgKiBNYXRoLm1pbihyZWRDb3VudCwgYmx1ZUNvdW50KSA8IEJSVVRFX0ZPUkNFX0NVVE9GRikge1xuICAgICAgICAvL0lmIGlucHV0IHNtYWxsLCB0aGVuIHVzZSBicnV0ZSBmb3JjZVxuICAgICAgICByZXR2YWwgPSBicnV0ZUZvcmNlUGFydGlhbChcbiAgICAgICAgICAgIGQsIGF4aXMsIHZpc2l0LCBmbGlwLFxuICAgICAgICAgICAgcmVkU3RhcnQsICByZWRFbmQsICByZWQsICByZWRJbmRleCxcbiAgICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmKGQgKiByZWRDb3VudCAqIGJsdWVDb3VudCA8IFNDQU5fQ1VUT0ZGKSB7XG4gICAgICAgIC8vSWYgaW5wdXQgbWVkaXVtIHNpemVkLCB0aGVuIHVzZSBzd2VlcCBhbmQgcHJ1bmVcbiAgICAgICAgcmV0dmFsID0gc3dlZXAuc2NhbkJpcGFydGl0ZShcbiAgICAgICAgICBkLCBheGlzLCB2aXNpdCwgZmxpcCwgXG4gICAgICAgICAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy9GaXJzdCwgZmluZCBhbGwgcmVkIGludGVydmFscyB3aG9zZSBpbnRlcmlvciBjb250YWlucyAobG8saGkpXG4gICAgdmFyIHJlZDAgPSBwYXJ0aXRpb25JbnRlcmlvckNvbnRhaW5zSW50ZXJ2YWwoXG4gICAgICBkLCBheGlzLCBcbiAgICAgIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICBsbywgaGkpXG5cbiAgICAvL0xvd2VyIGRpbWVuc2lvbmFsIGNhc2VcbiAgICBpZihyZWRTdGFydCA8IHJlZDApIHtcblxuICAgICAgaWYoZCAqIChyZWQwIC0gcmVkU3RhcnQpIDwgQlJVVEVfRk9SQ0VfQ1VUT0ZGKSB7XG4gICAgICAgIC8vU3BlY2lhbCBjYXNlIGZvciBzbWFsbCBpbnB1dHM6IHVzZSBicnV0ZSBmb3JjZVxuICAgICAgICByZXR2YWwgPSBicnV0ZUZvcmNlRnVsbChcbiAgICAgICAgICBkLCBheGlzKzEsIHZpc2l0LFxuICAgICAgICAgIHJlZFN0YXJ0LCByZWQwLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKGF4aXMgPT09IGQtMikge1xuICAgICAgICBpZihmbGlwKSB7XG4gICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4LFxuICAgICAgICAgICAgcmVkU3RhcnQsIHJlZDAsIHJlZCwgcmVkSW5kZXgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgIHJlZFN0YXJ0LCByZWQwLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgIH1cbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICByZWRTdGFydCwgcmVkMCxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsXG4gICAgICAgICAgZmxpcCxcbiAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLFxuICAgICAgICAgIHJlZFN0YXJ0LCByZWQwLFxuICAgICAgICAgIGZsaXBeMSxcbiAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vRGl2aWRlIGFuZCBjb25xdWVyIHBoYXNlXG4gICAgaWYocmVkMCA8IHJlZEVuZCkge1xuXG4gICAgICAvL0N1dCBibHVlIGludG8gMyBwYXJ0czpcbiAgICAgIC8vXG4gICAgICAvLyAgUG9pbnRzIDwgbWlkIHBvaW50XG4gICAgICAvLyAgUG9pbnRzID0gbWlkIHBvaW50XG4gICAgICAvLyAgUG9pbnRzID4gbWlkIHBvaW50XG4gICAgICAvL1xuICAgICAgdmFyIGJsdWUwID0gZmluZE1lZGlhbihcbiAgICAgICAgZCwgYXhpcywgXG4gICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgdmFyIG1pZCA9IGJsdWVbZWxlbVNpemUgKiBibHVlMCArIGF4aXNdXG4gICAgICB2YXIgYmx1ZTEgPSBwYXJ0aXRpb25TdGFydEVxdWFsKFxuICAgICAgICBkLCBheGlzLFxuICAgICAgICBibHVlMCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4LFxuICAgICAgICBtaWQpXG5cbiAgICAgIC8vUmlnaHQgY2FzZVxuICAgICAgaWYoYmx1ZTEgPCBibHVlRW5kKSB7XG4gICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgIGF4aXMsXG4gICAgICAgICAgcmVkMCwgcmVkRW5kLFxuICAgICAgICAgIGJsdWUxLCBibHVlRW5kLFxuICAgICAgICAgIChmbGlwfDQpICsgKGZ1bGwgPyAxNiA6IDApLFxuICAgICAgICAgIG1pZCwgaGkpXG4gICAgICB9XG5cbiAgICAgIC8vTGVmdCBjYXNlXG4gICAgICBpZihibHVlU3RhcnQgPCBibHVlMCkge1xuICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICBheGlzLFxuICAgICAgICAgIHJlZDAsIHJlZEVuZCxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWUwLFxuICAgICAgICAgIChmbGlwfDIpICsgKGZ1bGwgPyAxNiA6IDApLFxuICAgICAgICAgIGxvLCBtaWQpXG4gICAgICB9XG5cbiAgICAgIC8vQ2VudGVyIGNhc2UgKHRoZSBoYXJkIHBhcnQpXG4gICAgICBpZihibHVlMCArIDEgPT09IGJsdWUxKSB7XG4gICAgICAgIC8vT3B0aW1pemF0aW9uOiBSYW5nZSB3aXRoIGV4YWN0bHkgMSBwb2ludCwgdXNlIGEgYnJ1dGUgZm9yY2Ugc2NhblxuICAgICAgICBpZihmdWxsKSB7XG4gICAgICAgICAgcmV0dmFsID0gb25lUG9pbnRGdWxsKFxuICAgICAgICAgICAgZCwgYXhpcywgdmlzaXQsXG4gICAgICAgICAgICByZWQwLCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICBibHVlMCwgYmx1ZSwgYmx1ZUluZGV4W2JsdWUwXSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR2YWwgPSBvbmVQb2ludFBhcnRpYWwoXG4gICAgICAgICAgICBkLCBheGlzLCB2aXNpdCwgZmxpcCxcbiAgICAgICAgICAgIHJlZDAsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgIGJsdWUwLCBibHVlLCBibHVlSW5kZXhbYmx1ZTBdKVxuICAgICAgICB9XG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoYmx1ZTAgPCBibHVlMSkge1xuICAgICAgICB2YXIgcmVkMVxuICAgICAgICBpZihmdWxsKSB7XG4gICAgICAgICAgLy9JZiBmdWxsIGludGVyc2VjdGlvbiwgbmVlZCB0byBoYW5kbGUgc3BlY2lhbCBjYXNlXG4gICAgICAgICAgcmVkMSA9IHBhcnRpdGlvbkNvbnRhaW5zUG9pbnQoXG4gICAgICAgICAgICBkLCBheGlzLFxuICAgICAgICAgICAgcmVkMCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgbWlkKVxuICAgICAgICAgIGlmKHJlZDAgPCByZWQxKSB7XG4gICAgICAgICAgICB2YXIgcmVkWCA9IHBhcnRpdGlvblN0YXJ0RXF1YWwoXG4gICAgICAgICAgICAgIGQsIGF4aXMsXG4gICAgICAgICAgICAgIHJlZDAsIHJlZDEsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgIG1pZClcbiAgICAgICAgICAgIGlmKGF4aXMgPT09IGQtMikge1xuICAgICAgICAgICAgICAvL0RlZ2VuZXJhdGUgc3dlZXAgaW50ZXJzZWN0aW9uOlxuICAgICAgICAgICAgICAvLyAgW3JlZDAsIHJlZFhdIHdpdGggW2JsdWUwLCBibHVlMV1cbiAgICAgICAgICAgICAgaWYocmVkMCA8IHJlZFgpIHtcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcENvbXBsZXRlKFxuICAgICAgICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICAgICAgICByZWQwLCByZWRYLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgICAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvL05vcm1hbCBzd2VlcCBpbnRlcnNlY3Rpb246XG4gICAgICAgICAgICAgIC8vICBbcmVkWCwgcmVkMV0gd2l0aCBbYmx1ZTAsIGJsdWUxXVxuICAgICAgICAgICAgICBpZihyZWRYIDwgcmVkMSkge1xuICAgICAgICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQmlwYXJ0aXRlKFxuICAgICAgICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICAgICAgICByZWRYLCByZWQxLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgICAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmKHJlZDAgPCByZWRYKSB7XG4gICAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgICByZWQwLCByZWRYLFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLFxuICAgICAgICAgICAgICAgICAgMTYsXG4gICAgICAgICAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmKHJlZFggPCByZWQxKSB7XG4gICAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgICByZWRYLCByZWQxLFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLFxuICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsXG4gICAgICAgICAgICAgICAgICByZWRYLCByZWQxLFxuICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYoZmxpcCkge1xuICAgICAgICAgICAgcmVkMSA9IHBhcnRpdGlvbkNvbnRhaW5zUG9pbnRQcm9wZXIoXG4gICAgICAgICAgICAgIGQsIGF4aXMsXG4gICAgICAgICAgICAgIHJlZDAsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgICAgbWlkKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWQxID0gcGFydGl0aW9uQ29udGFpbnNQb2ludChcbiAgICAgICAgICAgICAgZCwgYXhpcyxcbiAgICAgICAgICAgICAgcmVkMCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICBtaWQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHJlZDAgPCByZWQxKSB7XG4gICAgICAgICAgICBpZihheGlzID09PSBkLTIpIHtcbiAgICAgICAgICAgICAgaWYoZmxpcCkge1xuICAgICAgICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQmlwYXJ0aXRlKFxuICAgICAgICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsIGJsdWUsIGJsdWVJbmRleCxcbiAgICAgICAgICAgICAgICAgIHJlZDAsIHJlZDEsIHJlZCwgcmVkSW5kZXgpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgICAgICAgIHJlZDAsIHJlZDEsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgYXhpcysxLFxuICAgICAgICAgICAgICAgIHJlZDAsIHJlZDEsXG4gICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLFxuICAgICAgICAgICAgICAgIGZsaXAsXG4gICAgICAgICAgICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgYXhpcysxLFxuICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSxcbiAgICAgICAgICAgICAgICByZWQwLCByZWQxLFxuICAgICAgICAgICAgICAgIGZsaXBeMSxcbiAgICAgICAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRNZWRpYW5cblxudmFyIGdlblBhcnRpdGlvbiA9IHJlcXVpcmUoJy4vcGFydGl0aW9uJylcblxudmFyIHBhcnRpdGlvblN0YXJ0TGVzc1RoYW4gPSBnZW5QYXJ0aXRpb24oJ2xvPHAwJywgWydwMCddKVxuXG52YXIgUEFSVElUSU9OX1RIUkVTSE9MRCA9IDggICAvL0N1dCBvZmYgZm9yIHVzaW5nIGluc2VydGlvbiBzb3J0IGluIGZpbmRNZWRpYW5cblxuLy9CYXNlIGNhc2UgZm9yIG1lZGlhbiBmaW5kaW5nOiAgVXNlIGluc2VydGlvbiBzb3J0XG5mdW5jdGlvbiBpbnNlcnRpb25Tb3J0KGQsIGF4aXMsIHN0YXJ0LCBlbmQsIGJveGVzLCBpZHMpIHtcbiAgdmFyIGVsZW1TaXplID0gMiAqIGRcbiAgdmFyIGJveFB0ciA9IGVsZW1TaXplICogKHN0YXJ0KzEpICsgYXhpc1xuICBmb3IodmFyIGk9c3RhcnQrMTsgaTxlbmQ7ICsraSwgYm94UHRyKz1lbGVtU2l6ZSkge1xuICAgIHZhciB4ID0gYm94ZXNbYm94UHRyXVxuICAgIGZvcih2YXIgaj1pLCBwdHI9ZWxlbVNpemUqKGktMSk7IFxuICAgICAgICBqPnN0YXJ0ICYmIGJveGVzW3B0citheGlzXSA+IHg7IFxuICAgICAgICAtLWosIHB0ci09ZWxlbVNpemUpIHtcbiAgICAgIC8vU3dhcFxuICAgICAgdmFyIGFQdHIgPSBwdHJcbiAgICAgIHZhciBiUHRyID0gcHRyK2VsZW1TaXplXG4gICAgICBmb3IodmFyIGs9MDsgazxlbGVtU2l6ZTsgKytrLCArK2FQdHIsICsrYlB0cikge1xuICAgICAgICB2YXIgeSA9IGJveGVzW2FQdHJdXG4gICAgICAgIGJveGVzW2FQdHJdID0gYm94ZXNbYlB0cl1cbiAgICAgICAgYm94ZXNbYlB0cl0gPSB5XG4gICAgICB9XG4gICAgICB2YXIgdG1wID0gaWRzW2pdXG4gICAgICBpZHNbal0gPSBpZHNbai0xXVxuICAgICAgaWRzW2otMV0gPSB0bXBcbiAgICB9XG4gIH1cbn1cblxuLy9GaW5kIG1lZGlhbiB1c2luZyBxdWljayBzZWxlY3QgYWxnb3JpdGhtXG4vLyAgdGFrZXMgTyhuKSB0aW1lIHdpdGggaGlnaCBwcm9iYWJpbGl0eVxuZnVuY3Rpb24gZmluZE1lZGlhbihkLCBheGlzLCBzdGFydCwgZW5kLCBib3hlcywgaWRzKSB7XG4gIGlmKGVuZCA8PSBzdGFydCsxKSB7XG4gICAgcmV0dXJuIHN0YXJ0XG4gIH1cblxuICB2YXIgbG8gICAgICAgPSBzdGFydFxuICB2YXIgaGkgICAgICAgPSBlbmRcbiAgdmFyIG1pZCAgICAgID0gKChlbmQgKyBzdGFydCkgPj4+IDEpXG4gIHZhciBlbGVtU2l6ZSA9IDIqZFxuICB2YXIgcGl2b3QgICAgPSBtaWRcbiAgdmFyIHZhbHVlICAgID0gYm94ZXNbZWxlbVNpemUqbWlkK2F4aXNdXG4gIFxuICB3aGlsZShsbyA8IGhpKSB7XG4gICAgaWYoaGkgLSBsbyA8IFBBUlRJVElPTl9USFJFU0hPTEQpIHtcbiAgICAgIGluc2VydGlvblNvcnQoZCwgYXhpcywgbG8sIGhpLCBib3hlcywgaWRzKVxuICAgICAgdmFsdWUgPSBib3hlc1tlbGVtU2l6ZSptaWQrYXhpc11cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIFxuICAgIC8vU2VsZWN0IHBpdm90IHVzaW5nIG1lZGlhbi1vZi0zXG4gICAgdmFyIGNvdW50ICA9IGhpIC0gbG9cbiAgICB2YXIgcGl2b3QwID0gKE1hdGgucmFuZG9tKCkqY291bnQrbG8pfDBcbiAgICB2YXIgdmFsdWUwID0gYm94ZXNbZWxlbVNpemUqcGl2b3QwICsgYXhpc11cbiAgICB2YXIgcGl2b3QxID0gKE1hdGgucmFuZG9tKCkqY291bnQrbG8pfDBcbiAgICB2YXIgdmFsdWUxID0gYm94ZXNbZWxlbVNpemUqcGl2b3QxICsgYXhpc11cbiAgICB2YXIgcGl2b3QyID0gKE1hdGgucmFuZG9tKCkqY291bnQrbG8pfDBcbiAgICB2YXIgdmFsdWUyID0gYm94ZXNbZWxlbVNpemUqcGl2b3QyICsgYXhpc11cbiAgICBpZih2YWx1ZTAgPD0gdmFsdWUxKSB7XG4gICAgICBpZih2YWx1ZTIgPj0gdmFsdWUxKSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3QxXG4gICAgICAgIHZhbHVlID0gdmFsdWUxXG4gICAgICB9IGVsc2UgaWYodmFsdWUwID49IHZhbHVlMikge1xuICAgICAgICBwaXZvdCA9IHBpdm90MFxuICAgICAgICB2YWx1ZSA9IHZhbHVlMFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdDJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZTJcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYodmFsdWUxID49IHZhbHVlMikge1xuICAgICAgICBwaXZvdCA9IHBpdm90MVxuICAgICAgICB2YWx1ZSA9IHZhbHVlMVxuICAgICAgfSBlbHNlIGlmKHZhbHVlMiA+PSB2YWx1ZTApIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdDBcbiAgICAgICAgdmFsdWUgPSB2YWx1ZTBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3QyXG4gICAgICAgIHZhbHVlID0gdmFsdWUyXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9Td2FwIHBpdm90IHRvIGVuZCBvZiBhcnJheVxuICAgIHZhciBhUHRyID0gZWxlbVNpemUgKiAoaGktMSlcbiAgICB2YXIgYlB0ciA9IGVsZW1TaXplICogcGl2b3RcbiAgICBmb3IodmFyIGk9MDsgaTxlbGVtU2l6ZTsgKytpLCArK2FQdHIsICsrYlB0cikge1xuICAgICAgdmFyIHggPSBib3hlc1thUHRyXVxuICAgICAgYm94ZXNbYVB0cl0gPSBib3hlc1tiUHRyXVxuICAgICAgYm94ZXNbYlB0cl0gPSB4XG4gICAgfVxuICAgIHZhciB5ID0gaWRzW2hpLTFdXG4gICAgaWRzW2hpLTFdID0gaWRzW3Bpdm90XVxuICAgIGlkc1twaXZvdF0gPSB5XG5cbiAgICAvL1BhcnRpdGlvbiB1c2luZyBwaXZvdFxuICAgIHBpdm90ID0gcGFydGl0aW9uU3RhcnRMZXNzVGhhbihcbiAgICAgIGQsIGF4aXMsIFxuICAgICAgbG8sIGhpLTEsIGJveGVzLCBpZHMsXG4gICAgICB2YWx1ZSlcblxuICAgIC8vU3dhcCBwaXZvdCBiYWNrXG4gICAgdmFyIGFQdHIgPSBlbGVtU2l6ZSAqIChoaS0xKVxuICAgIHZhciBiUHRyID0gZWxlbVNpemUgKiBwaXZvdFxuICAgIGZvcih2YXIgaT0wOyBpPGVsZW1TaXplOyArK2ksICsrYVB0ciwgKytiUHRyKSB7XG4gICAgICB2YXIgeCA9IGJveGVzW2FQdHJdXG4gICAgICBib3hlc1thUHRyXSA9IGJveGVzW2JQdHJdXG4gICAgICBib3hlc1tiUHRyXSA9IHhcbiAgICB9XG4gICAgdmFyIHkgPSBpZHNbaGktMV1cbiAgICBpZHNbaGktMV0gPSBpZHNbcGl2b3RdXG4gICAgaWRzW3Bpdm90XSA9IHlcblxuICAgIC8vU3dhcCBwaXZvdCB0byBsYXN0IHBpdm90XG4gICAgaWYobWlkIDwgcGl2b3QpIHtcbiAgICAgIGhpID0gcGl2b3QtMVxuICAgICAgd2hpbGUobG8gPCBoaSAmJiBcbiAgICAgICAgYm94ZXNbZWxlbVNpemUqKGhpLTEpK2F4aXNdID09PSB2YWx1ZSkge1xuICAgICAgICBoaSAtPSAxXG4gICAgICB9XG4gICAgICBoaSArPSAxXG4gICAgfSBlbHNlIGlmKHBpdm90IDwgbWlkKSB7XG4gICAgICBsbyA9IHBpdm90ICsgMVxuICAgICAgd2hpbGUobG8gPCBoaSAmJlxuICAgICAgICBib3hlc1tlbGVtU2l6ZSpsbytheGlzXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgbG8gKz0gMVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vTWFrZSBzdXJlIHBpdm90IGlzIGF0IHN0YXJ0XG4gIHJldHVybiBwYXJ0aXRpb25TdGFydExlc3NUaGFuKFxuICAgIGQsIGF4aXMsIFxuICAgIHN0YXJ0LCBtaWQsIGJveGVzLCBpZHMsXG4gICAgYm94ZXNbZWxlbVNpemUqbWlkK2F4aXNdKVxufSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdlblBhcnRpdGlvblxuXG52YXIgY29kZSA9ICdmb3IodmFyIGo9MiphLGs9aipjLGw9ayxtPWMsbj1iLG89YStiLHA9YztkPnA7KytwLGsrPWope3ZhciBfO2lmKCQpaWYobT09PXApbSs9MSxsKz1qO2Vsc2V7Zm9yKHZhciBzPTA7aj5zOysrcyl7dmFyIHQ9ZVtrK3NdO2VbaytzXT1lW2xdLGVbbCsrXT10fXZhciB1PWZbcF07ZltwXT1mW21dLGZbbSsrXT11fX1yZXR1cm4gbSdcblxuZnVuY3Rpb24gZ2VuUGFydGl0aW9uKHByZWRpY2F0ZSwgYXJncykge1xuICB2YXIgZmFyZ3MgPSdhYmNkZWYnLnNwbGl0KCcnKS5jb25jYXQoYXJncylcbiAgdmFyIHJlYWRzID0gW11cbiAgaWYocHJlZGljYXRlLmluZGV4T2YoJ2xvJykgPj0gMCkge1xuICAgIHJlYWRzLnB1c2goJ2xvPWVbaytuXScpXG4gIH1cbiAgaWYocHJlZGljYXRlLmluZGV4T2YoJ2hpJykgPj0gMCkge1xuICAgIHJlYWRzLnB1c2goJ2hpPWVbaytvXScpXG4gIH1cbiAgZmFyZ3MucHVzaChcbiAgICBjb2RlLnJlcGxhY2UoJ18nLCByZWFkcy5qb2luKCkpXG4gICAgICAgIC5yZXBsYWNlKCckJywgcHJlZGljYXRlKSlcbiAgcmV0dXJuIEZ1bmN0aW9uLmFwcGx5KHZvaWQgMCwgZmFyZ3MpXG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vL1RoaXMgY29kZSBpcyBleHRyYWN0ZWQgZnJvbSBuZGFycmF5LXNvcnRcbi8vSXQgaXMgaW5saW5lZCBoZXJlIGFzIGEgdGVtcG9yYXJ5IHdvcmthcm91bmRcblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcGVyO1xuXG52YXIgSU5TRVJUX1NPUlRfQ1VUT0ZGID0gMzJcblxuZnVuY3Rpb24gd3JhcHBlcihkYXRhLCBuMCkge1xuICBpZiAobjAgPD0gNCpJTlNFUlRfU09SVF9DVVRPRkYpIHtcbiAgICBpbnNlcnRpb25Tb3J0KDAsIG4wIC0gMSwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgcXVpY2tTb3J0KDAsIG4wIC0gMSwgZGF0YSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0aW9uU29ydChsZWZ0LCByaWdodCwgZGF0YSkge1xuICB2YXIgcHRyID0gMioobGVmdCsxKVxuICBmb3IodmFyIGk9bGVmdCsxOyBpPD1yaWdodDsgKytpKSB7XG4gICAgdmFyIGEgPSBkYXRhW3B0cisrXVxuICAgIHZhciBiID0gZGF0YVtwdHIrK11cbiAgICB2YXIgaiA9IGlcbiAgICB2YXIganB0ciA9IHB0ci0yXG4gICAgd2hpbGUoai0tID4gbGVmdCkge1xuICAgICAgdmFyIHggPSBkYXRhW2pwdHItMl1cbiAgICAgIHZhciB5ID0gZGF0YVtqcHRyLTFdXG4gICAgICBpZih4IDwgYSkge1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIGlmKHggPT09IGEgJiYgeSA8IGIpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGRhdGFbanB0cl0gICA9IHhcbiAgICAgIGRhdGFbanB0cisxXSA9IHlcbiAgICAgIGpwdHIgLT0gMlxuICAgIH1cbiAgICBkYXRhW2pwdHJdICAgPSBhXG4gICAgZGF0YVtqcHRyKzFdID0gYlxuICB9XG59XG5cbmZ1bmN0aW9uIHN3YXAoaSwgaiwgZGF0YSkge1xuICBpICo9IDJcbiAgaiAqPSAyXG4gIHZhciB4ID0gZGF0YVtpXVxuICB2YXIgeSA9IGRhdGFbaSsxXVxuICBkYXRhW2ldID0gZGF0YVtqXVxuICBkYXRhW2krMV0gPSBkYXRhW2orMV1cbiAgZGF0YVtqXSA9IHhcbiAgZGF0YVtqKzFdID0geVxufVxuXG5mdW5jdGlvbiBtb3ZlKGksIGosIGRhdGEpIHtcbiAgaSAqPSAyXG4gIGogKj0gMlxuICBkYXRhW2ldID0gZGF0YVtqXVxuICBkYXRhW2krMV0gPSBkYXRhW2orMV1cbn1cblxuZnVuY3Rpb24gcm90YXRlKGksIGosIGssIGRhdGEpIHtcbiAgaSAqPSAyXG4gIGogKj0gMlxuICBrICo9IDJcbiAgdmFyIHggPSBkYXRhW2ldXG4gIHZhciB5ID0gZGF0YVtpKzFdXG4gIGRhdGFbaV0gPSBkYXRhW2pdXG4gIGRhdGFbaSsxXSA9IGRhdGFbaisxXVxuICBkYXRhW2pdID0gZGF0YVtrXVxuICBkYXRhW2orMV0gPSBkYXRhW2srMV1cbiAgZGF0YVtrXSA9IHhcbiAgZGF0YVtrKzFdID0geVxufVxuXG5mdW5jdGlvbiBzaHVmZmxlUGl2b3QoaSwgaiwgcHgsIHB5LCBkYXRhKSB7XG4gIGkgKj0gMlxuICBqICo9IDJcbiAgZGF0YVtpXSA9IGRhdGFbal1cbiAgZGF0YVtqXSA9IHB4XG4gIGRhdGFbaSsxXSA9IGRhdGFbaisxXVxuICBkYXRhW2orMV0gPSBweVxufVxuXG5mdW5jdGlvbiBjb21wYXJlKGksIGosIGRhdGEpIHtcbiAgaSAqPSAyXG4gIGogKj0gMlxuICB2YXIgeCA9IGRhdGFbaV0sXG4gICAgICB5ID0gZGF0YVtqXVxuICBpZih4IDwgeSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYoeCA9PT0geSkge1xuICAgIHJldHVybiBkYXRhW2krMV0gPiBkYXRhW2orMV1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBjb21wYXJlUGl2b3QoaSwgeSwgYiwgZGF0YSkge1xuICBpICo9IDJcbiAgdmFyIHggPSBkYXRhW2ldXG4gIGlmKHggPCB5KSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmKHggPT09IHkpIHtcbiAgICByZXR1cm4gZGF0YVtpKzFdIDwgYlxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBxdWlja1NvcnQobGVmdCwgcmlnaHQsIGRhdGEpIHtcbiAgdmFyIHNpeHRoID0gKHJpZ2h0IC0gbGVmdCArIDEpIC8gNiB8IDAsIFxuICAgICAgaW5kZXgxID0gbGVmdCArIHNpeHRoLCBcbiAgICAgIGluZGV4NSA9IHJpZ2h0IC0gc2l4dGgsIFxuICAgICAgaW5kZXgzID0gbGVmdCArIHJpZ2h0ID4+IDEsIFxuICAgICAgaW5kZXgyID0gaW5kZXgzIC0gc2l4dGgsIFxuICAgICAgaW5kZXg0ID0gaW5kZXgzICsgc2l4dGgsIFxuICAgICAgZWwxID0gaW5kZXgxLCBcbiAgICAgIGVsMiA9IGluZGV4MiwgXG4gICAgICBlbDMgPSBpbmRleDMsIFxuICAgICAgZWw0ID0gaW5kZXg0LCBcbiAgICAgIGVsNSA9IGluZGV4NSwgXG4gICAgICBsZXNzID0gbGVmdCArIDEsIFxuICAgICAgZ3JlYXQgPSByaWdodCAtIDEsIFxuICAgICAgdG1wID0gMFxuICBpZihjb21wYXJlKGVsMSwgZWwyLCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMVxuICAgIGVsMSA9IGVsMlxuICAgIGVsMiA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWw0LCBlbDUsIGRhdGEpKSB7XG4gICAgdG1wID0gZWw0XG4gICAgZWw0ID0gZWw1XG4gICAgZWw1ID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDEsIGVsMywgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDFcbiAgICBlbDEgPSBlbDNcbiAgICBlbDMgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsMiwgZWwzLCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMlxuICAgIGVsMiA9IGVsM1xuICAgIGVsMyA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWwxLCBlbDQsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwxXG4gICAgZWwxID0gZWw0XG4gICAgZWw0ID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDMsIGVsNCwgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDNcbiAgICBlbDMgPSBlbDRcbiAgICBlbDQgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsMiwgZWw1LCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMlxuICAgIGVsMiA9IGVsNVxuICAgIGVsNSA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWwyLCBlbDMsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwyXG4gICAgZWwyID0gZWwzXG4gICAgZWwzID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDQsIGVsNSwgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDRcbiAgICBlbDQgPSBlbDVcbiAgICBlbDUgPSB0bXBcbiAgfVxuXG4gIHZhciBwaXZvdDFYID0gZGF0YVsyKmVsMl1cbiAgdmFyIHBpdm90MVkgPSBkYXRhWzIqZWwyKzFdXG4gIHZhciBwaXZvdDJYID0gZGF0YVsyKmVsNF1cbiAgdmFyIHBpdm90MlkgPSBkYXRhWzIqZWw0KzFdXG5cbiAgdmFyIHB0cjAgPSAyICogZWwxO1xuICB2YXIgcHRyMiA9IDIgKiBlbDM7XG4gIHZhciBwdHI0ID0gMiAqIGVsNTtcbiAgdmFyIHB0cjUgPSAyICogaW5kZXgxO1xuICB2YXIgcHRyNiA9IDIgKiBpbmRleDM7XG4gIHZhciBwdHI3ID0gMiAqIGluZGV4NTtcbiAgZm9yICh2YXIgaTEgPSAwOyBpMSA8IDI7ICsraTEpIHtcbiAgICB2YXIgeCA9IGRhdGFbcHRyMCtpMV07XG4gICAgdmFyIHkgPSBkYXRhW3B0cjIraTFdO1xuICAgIHZhciB6ID0gZGF0YVtwdHI0K2kxXTtcbiAgICBkYXRhW3B0cjUraTFdID0geDtcbiAgICBkYXRhW3B0cjYraTFdID0geTtcbiAgICBkYXRhW3B0cjcraTFdID0gejtcbiAgfVxuXG4gIG1vdmUoaW5kZXgyLCBsZWZ0LCBkYXRhKVxuICBtb3ZlKGluZGV4NCwgcmlnaHQsIGRhdGEpXG4gIGZvciAodmFyIGsgPSBsZXNzOyBrIDw9IGdyZWF0OyArK2spIHtcbiAgICBpZiAoY29tcGFyZVBpdm90KGssIHBpdm90MVgsIHBpdm90MVksIGRhdGEpKSB7XG4gICAgICBpZiAoayAhPT0gbGVzcykge1xuICAgICAgICBzd2FwKGssIGxlc3MsIGRhdGEpXG4gICAgICB9XG4gICAgICArK2xlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY29tcGFyZVBpdm90KGssIHBpdm90MlgsIHBpdm90MlksIGRhdGEpKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgaWYgKCFjb21wYXJlUGl2b3QoZ3JlYXQsIHBpdm90MlgsIHBpdm90MlksIGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAoLS1ncmVhdCA8IGspIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbXBhcmVQaXZvdChncmVhdCwgcGl2b3QxWCwgcGl2b3QxWSwgZGF0YSkpIHtcbiAgICAgICAgICAgICAgcm90YXRlKGssIGxlc3MsIGdyZWF0LCBkYXRhKVxuICAgICAgICAgICAgICArK2xlc3M7XG4gICAgICAgICAgICAgIC0tZ3JlYXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzd2FwKGssIGdyZWF0LCBkYXRhKVxuICAgICAgICAgICAgICAtLWdyZWF0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNodWZmbGVQaXZvdChsZWZ0LCBsZXNzLTEsIHBpdm90MVgsIHBpdm90MVksIGRhdGEpXG4gIHNodWZmbGVQaXZvdChyaWdodCwgZ3JlYXQrMSwgcGl2b3QyWCwgcGl2b3QyWSwgZGF0YSlcbiAgaWYgKGxlc3MgLSAyIC0gbGVmdCA8PSBJTlNFUlRfU09SVF9DVVRPRkYpIHtcbiAgICBpbnNlcnRpb25Tb3J0KGxlZnQsIGxlc3MgLSAyLCBkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBxdWlja1NvcnQobGVmdCwgbGVzcyAtIDIsIGRhdGEpO1xuICB9XG4gIGlmIChyaWdodCAtIChncmVhdCArIDIpIDw9IElOU0VSVF9TT1JUX0NVVE9GRikge1xuICAgIGluc2VydGlvblNvcnQoZ3JlYXQgKyAyLCByaWdodCwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgcXVpY2tTb3J0KGdyZWF0ICsgMiwgcmlnaHQsIGRhdGEpO1xuICB9XG4gIGlmIChncmVhdCAtIGxlc3MgPD0gSU5TRVJUX1NPUlRfQ1VUT0ZGKSB7XG4gICAgaW5zZXJ0aW9uU29ydChsZXNzLCBncmVhdCwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgcXVpY2tTb3J0KGxlc3MsIGdyZWF0LCBkYXRhKTtcbiAgfVxufSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5pdDogICAgICAgICAgIHNxSW5pdCxcbiAgc3dlZXBCaXBhcnRpdGU6IHN3ZWVwQmlwYXJ0aXRlLFxuICBzd2VlcENvbXBsZXRlOiAgc3dlZXBDb21wbGV0ZSxcbiAgc2NhbkJpcGFydGl0ZTogIHNjYW5CaXBhcnRpdGUsXG4gIHNjYW5Db21wbGV0ZTogICBzY2FuQ29tcGxldGVcbn1cblxudmFyIHBvb2wgID0gcmVxdWlyZSgndHlwZWRhcnJheS1wb29sJylcbnZhciBiaXRzICA9IHJlcXVpcmUoJ2JpdC10d2lkZGxlJylcbnZhciBpc29ydCA9IHJlcXVpcmUoJy4vc29ydCcpXG5cbi8vRmxhZyBmb3IgYmx1ZVxudmFyIEJMVUVfRkxBRyA9ICgxPDwyOClcblxuLy8xRCBzd2VlcCBldmVudCBxdWV1ZSBzdHVmZiAodXNlIHBvb2wgdG8gc2F2ZSBzcGFjZSlcbnZhciBJTklUX0NBUEFDSVRZICAgICAgPSAxMDI0XG52YXIgUkVEX1NXRUVQX1FVRVVFICAgID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIFJFRF9TV0VFUF9JTkRFWCAgICA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBCTFVFX1NXRUVQX1FVRVVFICAgPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgQkxVRV9TV0VFUF9JTkRFWCAgID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIENPTU1PTl9TV0VFUF9RVUVVRSA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBDT01NT05fU1dFRVBfSU5ERVggPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgU1dFRVBfRVZFTlRTICAgICAgID0gcG9vbC5tYWxsb2NEb3VibGUoSU5JVF9DQVBBQ0lUWSAqIDgpXG5cbi8vUmVzZXJ2ZXMgbWVtb3J5IGZvciB0aGUgMUQgc3dlZXAgZGF0YSBzdHJ1Y3R1cmVzXG5mdW5jdGlvbiBzcUluaXQoY291bnQpIHtcbiAgdmFyIHJjb3VudCA9IGJpdHMubmV4dFBvdzIoY291bnQpXG4gIGlmKFJFRF9TV0VFUF9RVUVVRS5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoUkVEX1NXRUVQX1FVRVVFKVxuICAgIFJFRF9TV0VFUF9RVUVVRSA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKFJFRF9TV0VFUF9JTkRFWC5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoUkVEX1NXRUVQX0lOREVYKVxuICAgIFJFRF9TV0VFUF9JTkRFWCA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKEJMVUVfU1dFRVBfUVVFVUUubGVuZ3RoIDwgcmNvdW50KSB7XG4gICAgcG9vbC5mcmVlKEJMVUVfU1dFRVBfUVVFVUUpXG4gICAgQkxVRV9TV0VFUF9RVUVVRSA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKEJMVUVfU1dFRVBfSU5ERVgubGVuZ3RoIDwgcmNvdW50KSB7XG4gICAgcG9vbC5mcmVlKEJMVUVfU1dFRVBfSU5ERVgpXG4gICAgQkxVRV9TV0VFUF9JTkRFWCA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKENPTU1PTl9TV0VFUF9RVUVVRS5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoQ09NTU9OX1NXRUVQX1FVRVVFKVxuICAgIENPTU1PTl9TV0VFUF9RVUVVRSA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKENPTU1PTl9TV0VFUF9JTkRFWC5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoQ09NTU9OX1NXRUVQX0lOREVYKVxuICAgIENPTU1PTl9TV0VFUF9JTkRFWCA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIHZhciBldmVudExlbmd0aCA9IDggKiByY291bnRcbiAgaWYoU1dFRVBfRVZFTlRTLmxlbmd0aCA8IGV2ZW50TGVuZ3RoKSB7XG4gICAgcG9vbC5mcmVlKFNXRUVQX0VWRU5UUylcbiAgICBTV0VFUF9FVkVOVFMgPSBwb29sLm1hbGxvY0RvdWJsZShldmVudExlbmd0aClcbiAgfVxufVxuXG4vL1JlbW92ZSBhbiBpdGVtIGZyb20gdGhlIGFjdGl2ZSBxdWV1ZSBpbiBPKDEpXG5mdW5jdGlvbiBzcVBvcChxdWV1ZSwgaW5kZXgsIGNvdW50LCBpdGVtKSB7XG4gIHZhciBpZHggPSBpbmRleFtpdGVtXVxuICB2YXIgdG9wID0gcXVldWVbY291bnQtMV1cbiAgcXVldWVbaWR4XSA9IHRvcFxuICBpbmRleFt0b3BdID0gaWR4XG59XG5cbi8vSW5zZXJ0IGFuIGl0ZW0gaW50byB0aGUgYWN0aXZlIHF1ZXVlIGluIE8oMSlcbmZ1bmN0aW9uIHNxUHVzaChxdWV1ZSwgaW5kZXgsIGNvdW50LCBpdGVtKSB7XG4gIHF1ZXVlW2NvdW50XSA9IGl0ZW1cbiAgaW5kZXhbaXRlbV0gID0gY291bnRcbn1cblxuLy9SZWN1cnNpb24gYmFzZSBjYXNlOiB1c2UgMUQgc3dlZXAgYWxnb3JpdGhtXG5mdW5jdGlvbiBzd2VlcEJpcGFydGl0ZShcbiAgICBkLCB2aXNpdCxcbiAgICByZWRTdGFydCwgIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleCkge1xuXG4gIC8vc3RvcmUgZXZlbnRzIGFzIHBhaXJzIFtjb29yZGluYXRlLCBpZHhdXG4gIC8vXG4gIC8vICByZWQgY3JlYXRlOiAgLShpZHgrMSlcbiAgLy8gIHJlZCBkZXN0cm95OiBpZHhcbiAgLy8gIGJsdWUgY3JlYXRlOiAtKGlkeCtCTFVFX0ZMQUcpXG4gIC8vICBibHVlIGRlc3Ryb3k6IGlkeCtCTFVFX0ZMQUdcbiAgLy9cbiAgdmFyIHB0ciAgICAgID0gMFxuICB2YXIgZWxlbVNpemUgPSAyKmRcbiAgdmFyIGlzdGFydCAgID0gZC0xXG4gIHZhciBpZW5kICAgICA9IGVsZW1TaXplLTFcblxuICBmb3IodmFyIGk9cmVkU3RhcnQ7IGk8cmVkRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gcmVkSW5kZXhbaV1cbiAgICB2YXIgcmVkT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLShpZHgrMSlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHhcbiAgfVxuXG4gIGZvcih2YXIgaT1ibHVlU3RhcnQ7IGk8Ymx1ZUVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IGJsdWVJbmRleFtpXStCTFVFX0ZMQUdcbiAgICB2YXIgYmx1ZU9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gYmx1ZVtibHVlT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4XG4gIH1cblxuICAvL3Byb2Nlc3MgZXZlbnRzIGZyb20gbGVmdC0+cmlnaHRcbiAgdmFyIG4gPSBwdHIgPj4+IDFcbiAgaXNvcnQoU1dFRVBfRVZFTlRTLCBuKVxuICBcbiAgdmFyIHJlZEFjdGl2ZSAgPSAwXG4gIHZhciBibHVlQWN0aXZlID0gMFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgZSA9IFNXRUVQX0VWRU5UU1syKmkrMV18MFxuICAgIGlmKGUgPj0gQkxVRV9GTEFHKSB7XG4gICAgICAvL2JsdWUgZGVzdHJveSBldmVudFxuICAgICAgZSA9IChlLUJMVUVfRkxBRyl8MFxuICAgICAgc3FQb3AoQkxVRV9TV0VFUF9RVUVVRSwgQkxVRV9TV0VFUF9JTkRFWCwgYmx1ZUFjdGl2ZS0tLCBlKVxuICAgIH0gZWxzZSBpZihlID49IDApIHtcbiAgICAgIC8vcmVkIGRlc3Ryb3kgZXZlbnRcbiAgICAgIHNxUG9wKFJFRF9TV0VFUF9RVUVVRSwgUkVEX1NXRUVQX0lOREVYLCByZWRBY3RpdmUtLSwgZSlcbiAgICB9IGVsc2UgaWYoZSA8PSAtQkxVRV9GTEFHKSB7XG4gICAgICAvL2JsdWUgY3JlYXRlIGV2ZW50XG4gICAgICBlID0gKC1lLUJMVUVfRkxBRyl8MFxuICAgICAgZm9yKHZhciBqPTA7IGo8cmVkQWN0aXZlOyArK2opIHtcbiAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KFJFRF9TV0VFUF9RVUVVRVtqXSwgZSlcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNxUHVzaChCTFVFX1NXRUVQX1FVRVVFLCBCTFVFX1NXRUVQX0lOREVYLCBibHVlQWN0aXZlKyssIGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vcmVkIGNyZWF0ZSBldmVudFxuICAgICAgZSA9ICgtZS0xKXwwXG4gICAgICBmb3IodmFyIGo9MDsgajxibHVlQWN0aXZlOyArK2opIHtcbiAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KGUsIEJMVUVfU1dFRVBfUVVFVUVbal0pXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzcVB1c2goUkVEX1NXRUVQX1FVRVVFLCBSRURfU1dFRVBfSU5ERVgsIHJlZEFjdGl2ZSsrLCBlKVxuICAgIH1cbiAgfVxufVxuXG4vL0NvbXBsZXRlIHN3ZWVwXG5mdW5jdGlvbiBzd2VlcENvbXBsZXRlKGQsIHZpc2l0LCBcbiAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpIHtcblxuICB2YXIgcHRyICAgICAgPSAwXG4gIHZhciBlbGVtU2l6ZSA9IDIqZFxuICB2YXIgaXN0YXJ0ICAgPSBkLTFcbiAgdmFyIGllbmQgICAgID0gZWxlbVNpemUtMVxuXG4gIGZvcih2YXIgaT1yZWRTdGFydDsgaTxyZWRFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSAocmVkSW5kZXhbaV0rMSk8PDFcbiAgICB2YXIgcmVkT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2llbmRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGlkeFxuICB9XG5cbiAgZm9yKHZhciBpPWJsdWVTdGFydDsgaTxibHVlRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gKGJsdWVJbmRleFtpXSsxKTw8MVxuICAgIHZhciBibHVlT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAoLWlkeCl8MVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4fDFcbiAgfVxuXG4gIC8vcHJvY2VzcyBldmVudHMgZnJvbSBsZWZ0LT5yaWdodFxuICB2YXIgbiA9IHB0ciA+Pj4gMVxuICBpc29ydChTV0VFUF9FVkVOVFMsIG4pXG4gIFxuICB2YXIgcmVkQWN0aXZlICAgID0gMFxuICB2YXIgYmx1ZUFjdGl2ZSAgID0gMFxuICB2YXIgY29tbW9uQWN0aXZlID0gMFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgZSAgICAgPSBTV0VFUF9FVkVOVFNbMippKzFdfDBcbiAgICB2YXIgY29sb3IgPSBlJjFcbiAgICBpZihpIDwgbi0xICYmIChlPj4xKSA9PT0gKFNXRUVQX0VWRU5UU1syKmkrM10+PjEpKSB7XG4gICAgICBjb2xvciA9IDJcbiAgICAgIGkgKz0gMVxuICAgIH1cbiAgICBcbiAgICBpZihlIDwgMCkge1xuICAgICAgLy9DcmVhdGUgZXZlbnRcbiAgICAgIHZhciBpZCA9IC0oZT4+MSkgLSAxXG5cbiAgICAgIC8vSW50ZXJzZWN0IHdpdGggY29tbW9uXG4gICAgICBmb3IodmFyIGo9MDsgajxjb21tb25BY3RpdmU7ICsraikge1xuICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQoQ09NTU9OX1NXRUVQX1FVRVVFW2pdLCBpZClcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoY29sb3IgIT09IDApIHtcbiAgICAgICAgLy9JbnRlcnNlY3Qgd2l0aCByZWRcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8cmVkQWN0aXZlOyArK2opIHtcbiAgICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQoUkVEX1NXRUVQX1FVRVVFW2pdLCBpZClcbiAgICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihjb2xvciAhPT0gMSkge1xuICAgICAgICAvL0ludGVyc2VjdCB3aXRoIGJsdWVcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8Ymx1ZUFjdGl2ZTsgKytqKSB7XG4gICAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KEJMVUVfU1dFRVBfUVVFVUVbal0sIGlkKVxuICAgICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKGNvbG9yID09PSAwKSB7XG4gICAgICAgIC8vUmVkXG4gICAgICAgIHNxUHVzaChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlKyssIGlkKVxuICAgICAgfSBlbHNlIGlmKGNvbG9yID09PSAxKSB7XG4gICAgICAgIC8vQmx1ZVxuICAgICAgICBzcVB1c2goQkxVRV9TV0VFUF9RVUVVRSwgQkxVRV9TV0VFUF9JTkRFWCwgYmx1ZUFjdGl2ZSsrLCBpZClcbiAgICAgIH0gZWxzZSBpZihjb2xvciA9PT0gMikge1xuICAgICAgICAvL0JvdGhcbiAgICAgICAgc3FQdXNoKENPTU1PTl9TV0VFUF9RVUVVRSwgQ09NTU9OX1NXRUVQX0lOREVYLCBjb21tb25BY3RpdmUrKywgaWQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vRGVzdHJveSBldmVudFxuICAgICAgdmFyIGlkID0gKGU+PjEpIC0gMVxuICAgICAgaWYoY29sb3IgPT09IDApIHtcbiAgICAgICAgLy9SZWRcbiAgICAgICAgc3FQb3AoUkVEX1NXRUVQX1FVRVVFLCBSRURfU1dFRVBfSU5ERVgsIHJlZEFjdGl2ZS0tLCBpZClcbiAgICAgIH0gZWxzZSBpZihjb2xvciA9PT0gMSkge1xuICAgICAgICAvL0JsdWVcbiAgICAgICAgc3FQb3AoQkxVRV9TV0VFUF9RVUVVRSwgQkxVRV9TV0VFUF9JTkRFWCwgYmx1ZUFjdGl2ZS0tLCBpZClcbiAgICAgIH0gZWxzZSBpZihjb2xvciA9PT0gMikge1xuICAgICAgICAvL0JvdGhcbiAgICAgICAgc3FQb3AoQ09NTU9OX1NXRUVQX1FVRVVFLCBDT01NT05fU1dFRVBfSU5ERVgsIGNvbW1vbkFjdGl2ZS0tLCBpZClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy9Td2VlcCBhbmQgcHJ1bmUvc2NhbmxpbmUgYWxnb3JpdGhtOlxuLy8gIFNjYW4gYWxvbmcgYXhpcywgZGV0ZWN0IGludGVyc2VjdGlvbnNcbi8vICBCcnV0ZSBmb3JjZSBhbGwgYm94ZXMgYWxvbmcgYXhpc1xuZnVuY3Rpb24gc2NhbkJpcGFydGl0ZShcbiAgZCwgYXhpcywgdmlzaXQsIGZsaXAsXG4gIHJlZFN0YXJ0LCAgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleCkge1xuICBcbiAgdmFyIHB0ciAgICAgID0gMFxuICB2YXIgZWxlbVNpemUgPSAyKmRcbiAgdmFyIGlzdGFydCAgID0gYXhpc1xuICB2YXIgaWVuZCAgICAgPSBheGlzK2RcblxuICB2YXIgcmVkU2hpZnQgID0gMVxuICB2YXIgYmx1ZVNoaWZ0ID0gMVxuICBpZihmbGlwKSB7XG4gICAgYmx1ZVNoaWZ0ID0gQkxVRV9GTEFHXG4gIH0gZWxzZSB7XG4gICAgcmVkU2hpZnQgID0gQkxVRV9GTEFHXG4gIH1cblxuICBmb3IodmFyIGk9cmVkU3RhcnQ7IGk8cmVkRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gaSArIHJlZFNoaWZ0XG4gICAgdmFyIHJlZE9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC1pZHhcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHhcbiAgfVxuICBmb3IodmFyIGk9Ymx1ZVN0YXJ0OyBpPGJsdWVFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSBpICsgYmx1ZVNoaWZ0XG4gICAgdmFyIGJsdWVPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGJsdWVbYmx1ZU9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC1pZHhcbiAgfVxuXG4gIC8vcHJvY2VzcyBldmVudHMgZnJvbSBsZWZ0LT5yaWdodFxuICB2YXIgbiA9IHB0ciA+Pj4gMVxuICBpc29ydChTV0VFUF9FVkVOVFMsIG4pXG4gIFxuICB2YXIgcmVkQWN0aXZlICAgID0gMFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgZSA9IFNXRUVQX0VWRU5UU1syKmkrMV18MFxuICAgIGlmKGUgPCAwKSB7XG4gICAgICB2YXIgaWR4ICAgPSAtZVxuICAgICAgdmFyIGlzUmVkID0gZmFsc2VcbiAgICAgIGlmKGlkeCA+PSBCTFVFX0ZMQUcpIHtcbiAgICAgICAgaXNSZWQgPSAhZmxpcFxuICAgICAgICBpZHggLT0gQkxVRV9GTEFHIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNSZWQgPSAhIWZsaXBcbiAgICAgICAgaWR4IC09IDFcbiAgICAgIH1cbiAgICAgIGlmKGlzUmVkKSB7XG4gICAgICAgIHNxUHVzaChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlKyssIGlkeClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBibHVlSWQgID0gYmx1ZUluZGV4W2lkeF1cbiAgICAgICAgdmFyIGJsdWVQdHIgPSBlbGVtU2l6ZSAqIGlkeFxuICAgICAgICBcbiAgICAgICAgdmFyIGIwID0gYmx1ZVtibHVlUHRyK2F4aXMrMV1cbiAgICAgICAgdmFyIGIxID0gYmx1ZVtibHVlUHRyK2F4aXMrMStkXVxuXG5yZWRfbG9vcDpcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8cmVkQWN0aXZlOyArK2opIHtcbiAgICAgICAgICB2YXIgb2lkeCAgID0gUkVEX1NXRUVQX1FVRVVFW2pdXG4gICAgICAgICAgdmFyIHJlZFB0ciA9IGVsZW1TaXplICogb2lkeFxuXG4gICAgICAgICAgaWYoYjEgPCByZWRbcmVkUHRyK2F4aXMrMV0gfHwgXG4gICAgICAgICAgICAgcmVkW3JlZFB0citheGlzKzErZF0gPCBiMCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IodmFyIGs9YXhpcysyOyBrPGQ7ICsraykge1xuICAgICAgICAgICAgaWYoYmx1ZVtibHVlUHRyICsgayArIGRdIDwgcmVkW3JlZFB0ciArIGtdIHx8IFxuICAgICAgICAgICAgICAgcmVkW3JlZFB0ciArIGsgKyBkXSA8IGJsdWVbYmx1ZVB0ciArIGtdKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIHJlZF9sb29wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlZElkICA9IHJlZEluZGV4W29pZHhdXG4gICAgICAgICAgdmFyIHJldHZhbFxuICAgICAgICAgIGlmKGZsaXApIHtcbiAgICAgICAgICAgIHJldHZhbCA9IHZpc2l0KGJsdWVJZCwgcmVkSWQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHZhbCA9IHZpc2l0KHJlZElkLCBibHVlSWQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsIFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzcVBvcChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlLS0sIGUgLSByZWRTaGlmdClcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NhbkNvbXBsZXRlKFxuICBkLCBheGlzLCB2aXNpdCxcbiAgcmVkU3RhcnQsICByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KSB7XG5cbiAgdmFyIHB0ciAgICAgID0gMFxuICB2YXIgZWxlbVNpemUgPSAyKmRcbiAgdmFyIGlzdGFydCAgID0gYXhpc1xuICB2YXIgaWVuZCAgICAgPSBheGlzK2RcblxuICBmb3IodmFyIGk9cmVkU3RhcnQ7IGk8cmVkRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gaSArIEJMVUVfRkxBR1xuICAgIHZhciByZWRPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtaWR4XG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4XG4gIH1cbiAgZm9yKHZhciBpPWJsdWVTdGFydDsgaTxibHVlRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gaSArIDFcbiAgICB2YXIgYmx1ZU9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gYmx1ZVtibHVlT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICB9XG5cbiAgLy9wcm9jZXNzIGV2ZW50cyBmcm9tIGxlZnQtPnJpZ2h0XG4gIHZhciBuID0gcHRyID4+PiAxXG4gIGlzb3J0KFNXRUVQX0VWRU5UUywgbilcbiAgXG4gIHZhciByZWRBY3RpdmUgICAgPSAwXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHZhciBlID0gU1dFRVBfRVZFTlRTWzIqaSsxXXwwXG4gICAgaWYoZSA8IDApIHtcbiAgICAgIHZhciBpZHggICA9IC1lXG4gICAgICBpZihpZHggPj0gQkxVRV9GTEFHKSB7XG4gICAgICAgIFJFRF9TV0VFUF9RVUVVRVtyZWRBY3RpdmUrK10gPSBpZHggLSBCTFVFX0ZMQUdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkeCAtPSAxXG4gICAgICAgIHZhciBibHVlSWQgID0gYmx1ZUluZGV4W2lkeF1cbiAgICAgICAgdmFyIGJsdWVQdHIgPSBlbGVtU2l6ZSAqIGlkeFxuXG4gICAgICAgIHZhciBiMCA9IGJsdWVbYmx1ZVB0citheGlzKzFdXG4gICAgICAgIHZhciBiMSA9IGJsdWVbYmx1ZVB0citheGlzKzErZF1cblxucmVkX2xvb3A6XG4gICAgICAgIGZvcih2YXIgaj0wOyBqPHJlZEFjdGl2ZTsgKytqKSB7XG4gICAgICAgICAgdmFyIG9pZHggICA9IFJFRF9TV0VFUF9RVUVVRVtqXVxuICAgICAgICAgIHZhciByZWRJZCAgPSByZWRJbmRleFtvaWR4XVxuXG4gICAgICAgICAgaWYocmVkSWQgPT09IGJsdWVJZCkge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVkUHRyID0gZWxlbVNpemUgKiBvaWR4XG4gICAgICAgICAgaWYoYjEgPCByZWRbcmVkUHRyK2F4aXMrMV0gfHwgXG4gICAgICAgICAgICByZWRbcmVkUHRyK2F4aXMrMStkXSA8IGIwKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IodmFyIGs9YXhpcysyOyBrPGQ7ICsraykge1xuICAgICAgICAgICAgaWYoYmx1ZVtibHVlUHRyICsgayArIGRdIDwgcmVkW3JlZFB0ciArIGtdIHx8IFxuICAgICAgICAgICAgICAgcmVkW3JlZFB0ciArIGsgKyBkXSAgIDwgYmx1ZVtibHVlUHRyICsga10pIHtcbiAgICAgICAgICAgICAgY29udGludWUgcmVkX2xvb3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQocmVkSWQsIGJsdWVJZClcbiAgICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHZhbCBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlkeCA9IGUgLSBCTFVFX0ZMQUdcbiAgICAgIGZvcih2YXIgaj1yZWRBY3RpdmUtMTsgaj49MDsgLS1qKSB7XG4gICAgICAgIGlmKFJFRF9TV0VFUF9RVUVVRVtqXSA9PT0gaWR4KSB7XG4gICAgICAgICAgZm9yKHZhciBrPWorMTsgazxyZWRBY3RpdmU7ICsraykge1xuICAgICAgICAgICAgUkVEX1NXRUVQX1FVRVVFW2stMV0gPSBSRURfU1dFRVBfUVVFVUVba11cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLS1yZWRBY3RpdmVcbiAgICB9XG4gIH1cbn0iLCIvKipcbiAqIEJpdCB0d2lkZGxpbmcgaGFja3MgZm9yIEphdmFTY3JpcHQuXG4gKlxuICogQXV0aG9yOiBNaWtvbGEgTHlzZW5rb1xuICpcbiAqIFBvcnRlZCBmcm9tIFN0YW5mb3JkIGJpdCB0d2lkZGxpbmcgaGFjayBsaWJyYXJ5OlxuICogICAgaHR0cDovL2dyYXBoaWNzLnN0YW5mb3JkLmVkdS9+c2VhbmRlci9iaXRoYWNrcy5odG1sXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7IFwidXNlIHJlc3RyaWN0XCI7XG5cbi8vTnVtYmVyIG9mIGJpdHMgaW4gYW4gaW50ZWdlclxudmFyIElOVF9CSVRTID0gMzI7XG5cbi8vQ29uc3RhbnRzXG5leHBvcnRzLklOVF9CSVRTICA9IElOVF9CSVRTO1xuZXhwb3J0cy5JTlRfTUFYICAgPSAgMHg3ZmZmZmZmZjtcbmV4cG9ydHMuSU5UX01JTiAgID0gLTE8PChJTlRfQklUUy0xKTtcblxuLy9SZXR1cm5zIC0xLCAwLCArMSBkZXBlbmRpbmcgb24gc2lnbiBvZiB4XG5leHBvcnRzLnNpZ24gPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAodiA+IDApIC0gKHYgPCAwKTtcbn1cblxuLy9Db21wdXRlcyBhYnNvbHV0ZSB2YWx1ZSBvZiBpbnRlZ2VyXG5leHBvcnRzLmFicyA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIG1hc2sgPSB2ID4+IChJTlRfQklUUy0xKTtcbiAgcmV0dXJuICh2IF4gbWFzaykgLSBtYXNrO1xufVxuXG4vL0NvbXB1dGVzIG1pbmltdW0gb2YgaW50ZWdlcnMgeCBhbmQgeVxuZXhwb3J0cy5taW4gPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiB5IF4gKCh4IF4geSkgJiAtKHggPCB5KSk7XG59XG5cbi8vQ29tcHV0ZXMgbWF4aW11bSBvZiBpbnRlZ2VycyB4IGFuZCB5XG5leHBvcnRzLm1heCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuIHggXiAoKHggXiB5KSAmIC0oeCA8IHkpKTtcbn1cblxuLy9DaGVja3MgaWYgYSBudW1iZXIgaXMgYSBwb3dlciBvZiB0d29cbmV4cG9ydHMuaXNQb3cyID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gISh2ICYgKHYtMSkpICYmICghIXYpO1xufVxuXG4vL0NvbXB1dGVzIGxvZyBiYXNlIDIgb2YgdlxuZXhwb3J0cy5sb2cyID0gZnVuY3Rpb24odikge1xuICB2YXIgciwgc2hpZnQ7XG4gIHIgPSAgICAgKHYgPiAweEZGRkYpIDw8IDQ7IHYgPj4+PSByO1xuICBzaGlmdCA9ICh2ID4gMHhGRiAgKSA8PCAzOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHNoaWZ0ID0gKHYgPiAweEYgICApIDw8IDI7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDB4MyAgICkgPDwgMTsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICByZXR1cm4gciB8ICh2ID4+IDEpO1xufVxuXG4vL0NvbXB1dGVzIGxvZyBiYXNlIDEwIG9mIHZcbmV4cG9ydHMubG9nMTAgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAgKHYgPj0gMTAwMDAwMDAwMCkgPyA5IDogKHYgPj0gMTAwMDAwMDAwKSA/IDggOiAodiA+PSAxMDAwMDAwMCkgPyA3IDpcbiAgICAgICAgICAodiA+PSAxMDAwMDAwKSA/IDYgOiAodiA+PSAxMDAwMDApID8gNSA6ICh2ID49IDEwMDAwKSA/IDQgOlxuICAgICAgICAgICh2ID49IDEwMDApID8gMyA6ICh2ID49IDEwMCkgPyAyIDogKHYgPj0gMTApID8gMSA6IDA7XG59XG5cbi8vQ291bnRzIG51bWJlciBvZiBiaXRzXG5leHBvcnRzLnBvcENvdW50ID0gZnVuY3Rpb24odikge1xuICB2ID0gdiAtICgodiA+Pj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgdiA9ICh2ICYgMHgzMzMzMzMzMykgKyAoKHYgPj4+IDIpICYgMHgzMzMzMzMzMyk7XG4gIHJldHVybiAoKHYgKyAodiA+Pj4gNCkgJiAweEYwRjBGMEYpICogMHgxMDEwMTAxKSA+Pj4gMjQ7XG59XG5cbi8vQ291bnRzIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvc1xuZnVuY3Rpb24gY291bnRUcmFpbGluZ1plcm9zKHYpIHtcbiAgdmFyIGMgPSAzMjtcbiAgdiAmPSAtdjtcbiAgaWYgKHYpIGMtLTtcbiAgaWYgKHYgJiAweDAwMDBGRkZGKSBjIC09IDE2O1xuICBpZiAodiAmIDB4MDBGRjAwRkYpIGMgLT0gODtcbiAgaWYgKHYgJiAweDBGMEYwRjBGKSBjIC09IDQ7XG4gIGlmICh2ICYgMHgzMzMzMzMzMykgYyAtPSAyO1xuICBpZiAodiAmIDB4NTU1NTU1NTUpIGMgLT0gMTtcbiAgcmV0dXJuIGM7XG59XG5leHBvcnRzLmNvdW50VHJhaWxpbmdaZXJvcyA9IGNvdW50VHJhaWxpbmdaZXJvcztcblxuLy9Sb3VuZHMgdG8gbmV4dCBwb3dlciBvZiAyXG5leHBvcnRzLm5leHRQb3cyID0gZnVuY3Rpb24odikge1xuICB2ICs9IHYgPT09IDA7XG4gIC0tdjtcbiAgdiB8PSB2ID4+PiAxO1xuICB2IHw9IHYgPj4+IDI7XG4gIHYgfD0gdiA+Pj4gNDtcbiAgdiB8PSB2ID4+PiA4O1xuICB2IHw9IHYgPj4+IDE2O1xuICByZXR1cm4gdiArIDE7XG59XG5cbi8vUm91bmRzIGRvd24gdG8gcHJldmlvdXMgcG93ZXIgb2YgMlxuZXhwb3J0cy5wcmV2UG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgdiB8PSB2ID4+PiAxO1xuICB2IHw9IHYgPj4+IDI7XG4gIHYgfD0gdiA+Pj4gNDtcbiAgdiB8PSB2ID4+PiA4O1xuICB2IHw9IHYgPj4+IDE2O1xuICByZXR1cm4gdiAtICh2Pj4+MSk7XG59XG5cbi8vQ29tcHV0ZXMgcGFyaXR5IG9mIHdvcmRcbmV4cG9ydHMucGFyaXR5ID0gZnVuY3Rpb24odikge1xuICB2IF49IHYgPj4+IDE2O1xuICB2IF49IHYgPj4+IDg7XG4gIHYgXj0gdiA+Pj4gNDtcbiAgdiAmPSAweGY7XG4gIHJldHVybiAoMHg2OTk2ID4+PiB2KSAmIDE7XG59XG5cbnZhciBSRVZFUlNFX1RBQkxFID0gbmV3IEFycmF5KDI1Nik7XG5cbihmdW5jdGlvbih0YWIpIHtcbiAgZm9yKHZhciBpPTA7IGk8MjU2OyArK2kpIHtcbiAgICB2YXIgdiA9IGksIHIgPSBpLCBzID0gNztcbiAgICBmb3IgKHYgPj4+PSAxOyB2OyB2ID4+Pj0gMSkge1xuICAgICAgciA8PD0gMTtcbiAgICAgIHIgfD0gdiAmIDE7XG4gICAgICAtLXM7XG4gICAgfVxuICAgIHRhYltpXSA9IChyIDw8IHMpICYgMHhmZjtcbiAgfVxufSkoUkVWRVJTRV9UQUJMRSk7XG5cbi8vUmV2ZXJzZSBiaXRzIGluIGEgMzIgYml0IHdvcmRcbmV4cG9ydHMucmV2ZXJzZSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICAoUkVWRVJTRV9UQUJMRVsgdiAgICAgICAgICYgMHhmZl0gPDwgMjQpIHxcbiAgICAgICAgICAoUkVWRVJTRV9UQUJMRVsodiA+Pj4gOCkgICYgMHhmZl0gPDwgMTYpIHxcbiAgICAgICAgICAoUkVWRVJTRV9UQUJMRVsodiA+Pj4gMTYpICYgMHhmZl0gPDwgOCkgIHxcbiAgICAgICAgICAgUkVWRVJTRV9UQUJMRVsodiA+Pj4gMjQpICYgMHhmZl07XG59XG5cbi8vSW50ZXJsZWF2ZSBiaXRzIG9mIDIgY29vcmRpbmF0ZXMgd2l0aCAxNiBiaXRzLiAgVXNlZnVsIGZvciBmYXN0IHF1YWR0cmVlIGNvZGVzXG5leHBvcnRzLmludGVybGVhdmUyID0gZnVuY3Rpb24oeCwgeSkge1xuICB4ICY9IDB4RkZGRjtcbiAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgeCA9ICh4IHwgKHggPDwgMikpICYgMHgzMzMzMzMzMztcbiAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICB5ICY9IDB4RkZGRjtcbiAgeSA9ICh5IHwgKHkgPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgeSA9ICh5IHwgKHkgPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG4vL0V4dHJhY3RzIHRoZSBudGggaW50ZXJsZWF2ZWQgY29tcG9uZW50XG5leHBvcnRzLmRlaW50ZXJsZWF2ZTIgPSBmdW5jdGlvbih2LCBuKSB7XG4gIHYgPSAodiA+Pj4gbikgJiAweDU1NTU1NTU1O1xuICB2ID0gKHYgfCAodiA+Pj4gMSkpICAmIDB4MzMzMzMzMzM7XG4gIHYgPSAodiB8ICh2ID4+PiAyKSkgICYgMHgwRjBGMEYwRjtcbiAgdiA9ICh2IHwgKHYgPj4+IDQpKSAgJiAweDAwRkYwMEZGO1xuICB2ID0gKHYgfCAodiA+Pj4gMTYpKSAmIDB4MDAwRkZGRjtcbiAgcmV0dXJuICh2IDw8IDE2KSA+PiAxNjtcbn1cblxuXG4vL0ludGVybGVhdmUgYml0cyBvZiAzIGNvb3JkaW5hdGVzLCBlYWNoIHdpdGggMTAgYml0cy4gIFVzZWZ1bCBmb3IgZmFzdCBvY3RyZWUgY29kZXNcbmV4cG9ydHMuaW50ZXJsZWF2ZTMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHggJj0gMHgzRkY7XG4gIHggID0gKHggfCAoeDw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHggID0gKHggfCAoeDw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeCAgPSAoeCB8ICh4PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeCAgPSAoeCB8ICh4PDwyKSkgICYgMTIyNzEzMzUxMztcblxuICB5ICY9IDB4M0ZGO1xuICB5ICA9ICh5IHwgKHk8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB5ICA9ICh5IHwgKHk8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHkgID0gKHkgfCAoeTw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHkgID0gKHkgfCAoeTw8MikpICAmIDEyMjcxMzM1MTM7XG4gIHggfD0gKHkgPDwgMSk7XG4gIFxuICB6ICY9IDB4M0ZGO1xuICB6ICA9ICh6IHwgKHo8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB6ICA9ICh6IHwgKHo8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHogID0gKHogfCAoejw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHogID0gKHogfCAoejw8MikpICAmIDEyMjcxMzM1MTM7XG4gIFxuICByZXR1cm4geCB8ICh6IDw8IDIpO1xufVxuXG4vL0V4dHJhY3RzIG50aCBpbnRlcmxlYXZlZCBjb21wb25lbnQgb2YgYSAzLXR1cGxlXG5leHBvcnRzLmRlaW50ZXJsZWF2ZTMgPSBmdW5jdGlvbih2LCBuKSB7XG4gIHYgPSAodiA+Pj4gbikgICAgICAgJiAxMjI3MTMzNTEzO1xuICB2ID0gKHYgfCAodj4+PjIpKSAgICYgMzI3MjM1NjAzNTtcbiAgdiA9ICh2IHwgKHY+Pj40KSkgICAmIDI1MTcxOTY5NTtcbiAgdiA9ICh2IHwgKHY+Pj44KSkgICAmIDQyNzgxOTAzMzU7XG4gIHYgPSAodiB8ICh2Pj4+MTYpKSAgJiAweDNGRjtcbiAgcmV0dXJuICh2PDwyMik+PjIyO1xufVxuXG4vL0NvbXB1dGVzIG5leHQgY29tYmluYXRpb24gaW4gY29sZXhpY29ncmFwaGljIG9yZGVyICh0aGlzIGlzIG1pc3Rha2VubHkgY2FsbGVkIG5leHRQZXJtdXRhdGlvbiBvbiB0aGUgYml0IHR3aWRkbGluZyBoYWNrcyBwYWdlKVxuZXhwb3J0cy5uZXh0Q29tYmluYXRpb24gPSBmdW5jdGlvbih2KSB7XG4gIHZhciB0ID0gdiB8ICh2IC0gMSk7XG4gIHJldHVybiAodCArIDEpIHwgKCgofnQgJiAtfnQpIC0gMSkgPj4+IChjb3VudFRyYWlsaW5nWmVyb3ModikgKyAxKSk7XG59XG5cbiIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIGR1cGVfYXJyYXkoY291bnQsIHZhbHVlLCBpKSB7XG4gIHZhciBjID0gY291bnRbaV18MFxuICBpZihjIDw9IDApIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGMpLCBqXG4gIGlmKGkgPT09IGNvdW50Lmxlbmd0aC0xKSB7XG4gICAgZm9yKGo9MDsgajxjOyArK2opIHtcbiAgICAgIHJlc3VsdFtqXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvcihqPTA7IGo8YzsgKytqKSB7XG4gICAgICByZXN1bHRbal0gPSBkdXBlX2FycmF5KGNvdW50LCB2YWx1ZSwgaSsxKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGR1cGVfbnVtYmVyKGNvdW50LCB2YWx1ZSkge1xuICB2YXIgcmVzdWx0LCBpXG4gIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudClcbiAgZm9yKGk9MDsgaTxjb3VudDsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gdmFsdWVcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGR1cGUoY291bnQsIHZhbHVlKSB7XG4gIGlmKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhbHVlID0gMFxuICB9XG4gIHN3aXRjaCh0eXBlb2YgY291bnQpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBpZihjb3VudCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGR1cGVfbnVtYmVyKGNvdW50fDAsIHZhbHVlKVxuICAgICAgfVxuICAgIGJyZWFrXG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYodHlwZW9mIChjb3VudC5sZW5ndGgpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBkdXBlX2FycmF5KGNvdW50LCB2YWx1ZSwgMClcbiAgICAgIH1cbiAgICBicmVha1xuICB9XG4gIHJldHVybiBbXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGR1cGUiLCIndXNlIHN0cmljdCdcblxudmFyIGJpdHMgPSByZXF1aXJlKCdiaXQtdHdpZGRsZScpXG52YXIgZHVwID0gcmVxdWlyZSgnZHVwJylcblxuLy9MZWdhY3kgcG9vbCBzdXBwb3J0XG5pZighZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MKSB7XG4gIGdsb2JhbC5fX1RZUEVEQVJSQVlfUE9PTCA9IHtcbiAgICAgIFVJTlQ4ICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQxNiAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQzMiAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIElOVDggICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIElOVDE2ICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIElOVDMyICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIEZMT0FUICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIERPVUJMRSAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIERBVEEgICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQ4QyAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIEJVRkZFUiAgOiBkdXAoWzMyLCAwXSlcbiAgfVxufVxuXG52YXIgaGFzVWludDhDID0gKHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSkgIT09ICd1bmRlZmluZWQnXG52YXIgUE9PTCA9IGdsb2JhbC5fX1RZUEVEQVJSQVlfUE9PTFxuXG4vL1VwZ3JhZGUgcG9vbFxuaWYoIVBPT0wuVUlOVDhDKSB7XG4gIFBPT0wuVUlOVDhDID0gZHVwKFszMiwgMF0pXG59XG5pZighUE9PTC5CVUZGRVIpIHtcbiAgUE9PTC5CVUZGRVIgPSBkdXAoWzMyLCAwXSlcbn1cblxuLy9OZXcgdGVjaG5pcXVlOiBPbmx5IGFsbG9jYXRlIGZyb20gQXJyYXlCdWZmZXJWaWV3IGFuZCBCdWZmZXJcbnZhciBEQVRBICAgID0gUE9PTC5EQVRBXG4gICwgQlVGRkVSICA9IFBPT0wuQlVGRkVSXG5cbmV4cG9ydHMuZnJlZSA9IGZ1bmN0aW9uIGZyZWUoYXJyYXkpIHtcbiAgaWYoQnVmZmVyLmlzQnVmZmVyKGFycmF5KSkge1xuICAgIEJVRkZFUltiaXRzLmxvZzIoYXJyYXkubGVuZ3RoKV0ucHVzaChhcnJheSlcbiAgfSBlbHNlIHtcbiAgICBpZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyYXkpICE9PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBhcnJheSA9IGFycmF5LmJ1ZmZlclxuICAgIH1cbiAgICBpZighYXJyYXkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgbiA9IGFycmF5Lmxlbmd0aCB8fCBhcnJheS5ieXRlTGVuZ3RoXG4gICAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pfDBcbiAgICBEQVRBW2xvZ19uXS5wdXNoKGFycmF5KVxuICB9XG59XG5cbmZ1bmN0aW9uIGZyZWVBcnJheUJ1ZmZlcihidWZmZXIpIHtcbiAgaWYoIWJ1ZmZlcikge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBuID0gYnVmZmVyLmxlbmd0aCB8fCBidWZmZXIuYnl0ZUxlbmd0aFxuICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobilcbiAgREFUQVtsb2dfbl0ucHVzaChidWZmZXIpXG59XG5cbmZ1bmN0aW9uIGZyZWVUeXBlZEFycmF5KGFycmF5KSB7XG4gIGZyZWVBcnJheUJ1ZmZlcihhcnJheS5idWZmZXIpXG59XG5cbmV4cG9ydHMuZnJlZVVpbnQ4ID1cbmV4cG9ydHMuZnJlZVVpbnQxNiA9XG5leHBvcnRzLmZyZWVVaW50MzIgPVxuZXhwb3J0cy5mcmVlSW50OCA9XG5leHBvcnRzLmZyZWVJbnQxNiA9XG5leHBvcnRzLmZyZWVJbnQzMiA9XG5leHBvcnRzLmZyZWVGbG9hdDMyID0gXG5leHBvcnRzLmZyZWVGbG9hdCA9XG5leHBvcnRzLmZyZWVGbG9hdDY0ID0gXG5leHBvcnRzLmZyZWVEb3VibGUgPSBcbmV4cG9ydHMuZnJlZVVpbnQ4Q2xhbXBlZCA9IFxuZXhwb3J0cy5mcmVlRGF0YVZpZXcgPSBmcmVlVHlwZWRBcnJheVxuXG5leHBvcnRzLmZyZWVBcnJheUJ1ZmZlciA9IGZyZWVBcnJheUJ1ZmZlclxuXG5leHBvcnRzLmZyZWVCdWZmZXIgPSBmdW5jdGlvbiBmcmVlQnVmZmVyKGFycmF5KSB7XG4gIEJVRkZFUltiaXRzLmxvZzIoYXJyYXkubGVuZ3RoKV0ucHVzaChhcnJheSlcbn1cblxuZXhwb3J0cy5tYWxsb2MgPSBmdW5jdGlvbiBtYWxsb2MobiwgZHR5cGUpIHtcbiAgaWYoZHR5cGUgPT09IHVuZGVmaW5lZCB8fCBkdHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgIHJldHVybiBtYWxsb2NBcnJheUJ1ZmZlcihuKVxuICB9IGVsc2Uge1xuICAgIHN3aXRjaChkdHlwZSkge1xuICAgICAgY2FzZSAndWludDgnOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDgobilcbiAgICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50MTYobilcbiAgICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50MzIobilcbiAgICAgIGNhc2UgJ2ludDgnOlxuICAgICAgICByZXR1cm4gbWFsbG9jSW50OChuKVxuICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgICByZXR1cm4gbWFsbG9jSW50MTYobilcbiAgICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0ludDMyKG4pXG4gICAgICBjYXNlICdmbG9hdCc6XG4gICAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0Zsb2F0KG4pXG4gICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NEb3VibGUobilcbiAgICAgIGNhc2UgJ3VpbnQ4X2NsYW1wZWQnOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDhDbGFtcGVkKG4pXG4gICAgICBjYXNlICdidWZmZXInOlxuICAgICAgICByZXR1cm4gbWFsbG9jQnVmZmVyKG4pXG4gICAgICBjYXNlICdkYXRhJzpcbiAgICAgIGNhc2UgJ2RhdGF2aWV3JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0RhdGFWaWV3KG4pXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIG1hbGxvY0FycmF5QnVmZmVyKG4pIHtcbiAgdmFyIG4gPSBiaXRzLm5leHRQb3cyKG4pXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICB2YXIgZCA9IERBVEFbbG9nX25dXG4gIGlmKGQubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBkLnBvcCgpXG4gIH1cbiAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcihuKVxufVxuZXhwb3J0cy5tYWxsb2NBcnJheUJ1ZmZlciA9IG1hbGxvY0FycmF5QnVmZmVyXG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQ4KG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50OCA9IG1hbGxvY1VpbnQ4XG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQxNihuKSB7XG4gIHJldHVybiBuZXcgVWludDE2QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoMipuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jVWludDE2ID0gbWFsbG9jVWludDE2XG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQzMihuKSB7XG4gIHJldHVybiBuZXcgVWludDMyQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoNCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jVWludDMyID0gbWFsbG9jVWludDMyXG5cbmZ1bmN0aW9uIG1hbGxvY0ludDgobikge1xuICByZXR1cm4gbmV3IEludDhBcnJheShtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jSW50OCA9IG1hbGxvY0ludDhcblxuZnVuY3Rpb24gbWFsbG9jSW50MTYobikge1xuICByZXR1cm4gbmV3IEludDE2QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoMipuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jSW50MTYgPSBtYWxsb2NJbnQxNlxuXG5mdW5jdGlvbiBtYWxsb2NJbnQzMihuKSB7XG4gIHJldHVybiBuZXcgSW50MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQzMiA9IG1hbGxvY0ludDMyXG5cbmZ1bmN0aW9uIG1hbGxvY0Zsb2F0KG4pIHtcbiAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoNCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jRmxvYXQzMiA9IGV4cG9ydHMubWFsbG9jRmxvYXQgPSBtYWxsb2NGbG9hdFxuXG5mdW5jdGlvbiBtYWxsb2NEb3VibGUobikge1xuICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig4Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NGbG9hdDY0ID0gZXhwb3J0cy5tYWxsb2NEb3VibGUgPSBtYWxsb2NEb3VibGVcblxuZnVuY3Rpb24gbWFsbG9jVWludDhDbGFtcGVkKG4pIHtcbiAgaWYoaGFzVWludDhDKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OENsYW1wZWRBcnJheShtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWFsbG9jVWludDgobilcbiAgfVxufVxuZXhwb3J0cy5tYWxsb2NVaW50OENsYW1wZWQgPSBtYWxsb2NVaW50OENsYW1wZWRcblxuZnVuY3Rpb24gbWFsbG9jRGF0YVZpZXcobikge1xuICByZXR1cm4gbmV3IERhdGFWaWV3KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NEYXRhVmlldyA9IG1hbGxvY0RhdGFWaWV3XG5cbmZ1bmN0aW9uIG1hbGxvY0J1ZmZlcihuKSB7XG4gIG4gPSBiaXRzLm5leHRQb3cyKG4pXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICB2YXIgY2FjaGUgPSBCVUZGRVJbbG9nX25dXG4gIGlmKGNhY2hlLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gY2FjaGUucG9wKClcbiAgfVxuICByZXR1cm4gbmV3IEJ1ZmZlcihuKVxufVxuZXhwb3J0cy5tYWxsb2NCdWZmZXIgPSBtYWxsb2NCdWZmZXJcblxuZXhwb3J0cy5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgZm9yKHZhciBpPTA7IGk8MzI7ICsraSkge1xuICAgIFBPT0wuVUlOVDhbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDE2W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLlVJTlQzMltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5JTlQ4W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDE2W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDMyW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLkZMT0FUW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLkRPVUJMRVtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5VSU5UOENbaV0ubGVuZ3RoID0gMFxuICAgIERBVEFbaV0ubGVuZ3RoID0gMFxuICAgIEJVRkZFUltpXS5sZW5ndGggPSAwXG4gIH1cbn0iLG51bGwsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpcy1hcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbnZhciBrTWF4TGVuZ3RoID0gMHgzZmZmZmZmZlxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqIC0gSW1wbGVtZW50YXRpb24gbXVzdCBzdXBwb3J0IGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLlxuICogICBGaXJlZm94IDQtMjkgbGFja2VkIHN1cHBvcnQsIGZpeGVkIGluIEZpcmVmb3ggMzArLlxuICogICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuICpcbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5IHdpbGxcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IHdpbGwgd29yayBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiA0MiA9PT0gYXJyLmZvbygpICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIG5ldyBVaW50OEFycmF5KDEpLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG5cbiAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gIHZhciBsZW5ndGhcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKVxuICAgIGxlbmd0aCA9IHN1YmplY3QgPiAwID8gc3ViamVjdCA+Pj4gMCA6IDBcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKVxuICAgICAgc3ViamVjdCA9IGJhc2U2NGNsZWFuKHN1YmplY3QpXG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgc3ViamVjdCAhPT0gbnVsbCkgeyAvLyBhc3N1bWUgb2JqZWN0IGlzIGFycmF5LWxpa2VcbiAgICBpZiAoc3ViamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KHN1YmplY3QuZGF0YSkpXG4gICAgICBzdWJqZWN0ID0gc3ViamVjdC5kYXRhXG4gICAgbGVuZ3RoID0gK3N1YmplY3QubGVuZ3RoID4gMCA/IE1hdGguZmxvb3IoK3N1YmplY3QubGVuZ3RoKSA6IDBcbiAgfSBlbHNlXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzdGFydCB3aXRoIG51bWJlciwgYnVmZmVyLCBhcnJheSBvciBzdHJpbmcnKVxuXG4gIGlmICh0aGlzLmxlbmd0aCA+IGtNYXhMZW5ndGgpXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcblxuICB2YXIgYnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFByZWZlcnJlZDogUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBidWYgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIFRISVMgaW5zdGFuY2Ugb2YgQnVmZmVyIChjcmVhdGVkIGJ5IGBuZXdgKVxuICAgIGJ1ZiA9IHRoaXNcbiAgICBidWYubGVuZ3RoID0gbGVuZ3RoXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2Ygc3ViamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIHR5cGVkIGFycmF5XG4gICAgYnVmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9ICgoc3ViamVjdFtpXSAlIDI1NikgKyAyNTYpICUgMjU2XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhbm9aZXJvKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbiAmJiBhW2ldID09PSBiW2ldOyBpKyspIHt9XG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3RbLCBsZW5ndGhdKScpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAodG90YWxMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHRvdGFsTGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIgKyAnJ1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoICogMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCA+Pj4gMVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICB9XG4gIHJldHVybiByZXRcbn1cblxuLy8gcHJlLXNldCBmb3IgdmFsdWVzIHRoYXQgbWF5IGV4aXN0IGluIHRoZSBmdXR1cmVcbkJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gdW5kZWZpbmVkXG5CdWZmZXIucHJvdG90eXBlLnBhcmVudCA9IHVuZGVmaW5lZFxuXG4vLyB0b1N0cmluZyhlbmNvZGluZywgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoZW5kIDw9IHN0YXJ0KSByZXR1cm4gJydcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChiKSB7XG4gIGlmKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KVxuICAgICAgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4oYnl0ZSkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIDIpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gdXRmMTZsZVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlcyA9ICcnXG4gIHZhciB0bXAgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gICAgICB0bXAgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlbjtcbiAgICBpZiAoc3RhcnQgPCAwKVxuICAgICAgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApXG4gICAgICBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpXG4gICAgZW5kID0gc3RhcnRcblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICByZXR1cm4gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICB2YXIgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkLCB0cnVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICAgIHJldHVybiBuZXdCdWZcbiAgfVxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKVxuICAgIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0X3N0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzXG5cbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCBzb3VyY2UubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc291cmNlRW5kIDwgc291cmNlU3RhcnQnKVxuICBpZiAodGFyZ2V0X3N0YXJ0IDwgMCB8fCB0YXJnZXRfc3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSBzb3VyY2UubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gc291cmNlLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aClcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KVxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydFxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0X3N0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldF9zdGFydClcbiAgfVxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLmNvbnN0cnVjdG9yID0gQnVmZmVyXG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBnZXQvc2V0IG1ldGhvZHMgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fZ2V0ID0gYXJyLmdldFxuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS16XS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gaXNBcnJheWlzaCAoc3ViamVjdCkge1xuICByZXR1cm4gaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGIgPD0gMHg3Rikge1xuICAgICAgYnl0ZUFycmF5LnB1c2goYilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gaVxuICAgICAgaWYgKGIgPj0gMHhEODAwICYmIGIgPD0gMHhERkZGKSBpKytcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5zbGljZShzdGFydCwgaSsxKSkuc3Vic3RyKDEpLnNwbGl0KCclJylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKykge1xuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KHN0cilcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoLCB1bml0U2l6ZSkge1xuICBpZiAodW5pdFNpemUpIGxlbmd0aCAtPSBsZW5ndGggJSB1bml0U2l6ZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIgKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpIC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG4iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSClcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwLFxuICAgICAgZCA9IGlzTEUgPyAtMSA6IDEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcbiAgICAgIGQgPSBpc0xFID8gMSA6IC0xLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG4iLCJcbi8qKlxuICogaXNBcnJheVxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiB0b1N0cmluZ1xuICovXG5cbnZhciBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBgdmFsYFxuICogaXMgYW4gYXJyYXkuXG4gKlxuICogZXhhbXBsZTpcbiAqXG4gKiAgICAgICAgaXNBcnJheShbXSk7XG4gKiAgICAgICAgLy8gPiB0cnVlXG4gKiAgICAgICAgaXNBcnJheShhcmd1bWVudHMpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqICAgICAgICBpc0FycmF5KCcnKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKlxuICogQHBhcmFtIHttaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtib29sfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheSB8fCBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiAhISB2YWwgJiYgJ1tvYmplY3QgQXJyYXldJyA9PSBzdHIuY2FsbCh2YWwpO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuTXV0YXRpb25PYnNlcnZlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgdmFyIHF1ZXVlID0gW107XG5cbiAgICBpZiAoY2FuTXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgICB2YXIgaGlkZGVuRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHF1ZXVlTGlzdCA9IHF1ZXVlLnNsaWNlKCk7XG4gICAgICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcXVldWVMaXN0LmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGhpZGRlbkRpdiwgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgaWYgKCFxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBoaWRkZW5EaXYuc2V0QXR0cmlidXRlKCd5ZXMnLCAnbm8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiIsIi8vIChjKSBEZWFuIE1jTmFtZWUgPGRlYW5AZ21haWwuY29tPiwgMjAxMi5cbi8vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGVhbm0vY3NzLWNvbG9yLXBhcnNlci1qc1xuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4vLyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvXG52YXIga0NTU0NvbG9yVGFibGUgPSB7XG4gIFwidHJhbnNwYXJlbnRcIjogWzAsMCwwLDBdLCBcImFsaWNlYmx1ZVwiOiBbMjQwLDI0OCwyNTUsMV0sXG4gIFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsMjM1LDIxNSwxXSwgXCJhcXVhXCI6IFswLDI1NSwyNTUsMV0sXG4gIFwiYXF1YW1hcmluZVwiOiBbMTI3LDI1NSwyMTIsMV0sIFwiYXp1cmVcIjogWzI0MCwyNTUsMjU1LDFdLFxuICBcImJlaWdlXCI6IFsyNDUsMjQ1LDIyMCwxXSwgXCJiaXNxdWVcIjogWzI1NSwyMjgsMTk2LDFdLFxuICBcImJsYWNrXCI6IFswLDAsMCwxXSwgXCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LDIzNSwyMDUsMV0sXG4gIFwiYmx1ZVwiOiBbMCwwLDI1NSwxXSwgXCJibHVldmlvbGV0XCI6IFsxMzgsNDMsMjI2LDFdLFxuICBcImJyb3duXCI6IFsxNjUsNDIsNDIsMV0sIFwiYnVybHl3b29kXCI6IFsyMjIsMTg0LDEzNSwxXSxcbiAgXCJjYWRldGJsdWVcIjogWzk1LDE1OCwxNjAsMV0sIFwiY2hhcnRyZXVzZVwiOiBbMTI3LDI1NSwwLDFdLFxuICBcImNob2NvbGF0ZVwiOiBbMjEwLDEwNSwzMCwxXSwgXCJjb3JhbFwiOiBbMjU1LDEyNyw4MCwxXSxcbiAgXCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLDE0OSwyMzcsMV0sIFwiY29ybnNpbGtcIjogWzI1NSwyNDgsMjIwLDFdLFxuICBcImNyaW1zb25cIjogWzIyMCwyMCw2MCwxXSwgXCJjeWFuXCI6IFswLDI1NSwyNTUsMV0sXG4gIFwiZGFya2JsdWVcIjogWzAsMCwxMzksMV0sIFwiZGFya2N5YW5cIjogWzAsMTM5LDEzOSwxXSxcbiAgXCJkYXJrZ29sZGVucm9kXCI6IFsxODQsMTM0LDExLDFdLCBcImRhcmtncmF5XCI6IFsxNjksMTY5LDE2OSwxXSxcbiAgXCJkYXJrZ3JlZW5cIjogWzAsMTAwLDAsMV0sIFwiZGFya2dyZXlcIjogWzE2OSwxNjksMTY5LDFdLFxuICBcImRhcmtraGFraVwiOiBbMTg5LDE4MywxMDcsMV0sIFwiZGFya21hZ2VudGFcIjogWzEzOSwwLDEzOSwxXSxcbiAgXCJkYXJrb2xpdmVncmVlblwiOiBbODUsMTA3LDQ3LDFdLCBcImRhcmtvcmFuZ2VcIjogWzI1NSwxNDAsMCwxXSxcbiAgXCJkYXJrb3JjaGlkXCI6IFsxNTMsNTAsMjA0LDFdLCBcImRhcmtyZWRcIjogWzEzOSwwLDAsMV0sXG4gIFwiZGFya3NhbG1vblwiOiBbMjMzLDE1MCwxMjIsMV0sIFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsMTg4LDE0MywxXSxcbiAgXCJkYXJrc2xhdGVibHVlXCI6IFs3Miw2MSwxMzksMV0sIFwiZGFya3NsYXRlZ3JheVwiOiBbNDcsNzksNzksMV0sXG4gIFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsNzksNzksMV0sIFwiZGFya3R1cnF1b2lzZVwiOiBbMCwyMDYsMjA5LDFdLFxuICBcImRhcmt2aW9sZXRcIjogWzE0OCwwLDIxMSwxXSwgXCJkZWVwcGlua1wiOiBbMjU1LDIwLDE0NywxXSxcbiAgXCJkZWVwc2t5Ymx1ZVwiOiBbMCwxOTEsMjU1LDFdLCBcImRpbWdyYXlcIjogWzEwNSwxMDUsMTA1LDFdLFxuICBcImRpbWdyZXlcIjogWzEwNSwxMDUsMTA1LDFdLCBcImRvZGdlcmJsdWVcIjogWzMwLDE0NCwyNTUsMV0sXG4gIFwiZmlyZWJyaWNrXCI6IFsxNzgsMzQsMzQsMV0sIFwiZmxvcmFsd2hpdGVcIjogWzI1NSwyNTAsMjQwLDFdLFxuICBcImZvcmVzdGdyZWVuXCI6IFszNCwxMzksMzQsMV0sIFwiZnVjaHNpYVwiOiBbMjU1LDAsMjU1LDFdLFxuICBcImdhaW5zYm9yb1wiOiBbMjIwLDIyMCwyMjAsMV0sIFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LDI0OCwyNTUsMV0sXG4gIFwiZ29sZFwiOiBbMjU1LDIxNSwwLDFdLCBcImdvbGRlbnJvZFwiOiBbMjE4LDE2NSwzMiwxXSxcbiAgXCJncmF5XCI6IFsxMjgsMTI4LDEyOCwxXSwgXCJncmVlblwiOiBbMCwxMjgsMCwxXSxcbiAgXCJncmVlbnllbGxvd1wiOiBbMTczLDI1NSw0NywxXSwgXCJncmV5XCI6IFsxMjgsMTI4LDEyOCwxXSxcbiAgXCJob25leWRld1wiOiBbMjQwLDI1NSwyNDAsMV0sIFwiaG90cGlua1wiOiBbMjU1LDEwNSwxODAsMV0sXG4gIFwiaW5kaWFucmVkXCI6IFsyMDUsOTIsOTIsMV0sIFwiaW5kaWdvXCI6IFs3NSwwLDEzMCwxXSxcbiAgXCJpdm9yeVwiOiBbMjU1LDI1NSwyNDAsMV0sIFwia2hha2lcIjogWzI0MCwyMzAsMTQwLDFdLFxuICBcImxhdmVuZGVyXCI6IFsyMzAsMjMwLDI1MCwxXSwgXCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsMjQwLDI0NSwxXSxcbiAgXCJsYXduZ3JlZW5cIjogWzEyNCwyNTIsMCwxXSwgXCJsZW1vbmNoaWZmb25cIjogWzI1NSwyNTAsMjA1LDFdLFxuICBcImxpZ2h0Ymx1ZVwiOiBbMTczLDIxNiwyMzAsMV0sIFwibGlnaHRjb3JhbFwiOiBbMjQwLDEyOCwxMjgsMV0sXG4gIFwibGlnaHRjeWFuXCI6IFsyMjQsMjU1LDI1NSwxXSwgXCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLDI1MCwyMTAsMV0sXG4gIFwibGlnaHRncmF5XCI6IFsyMTEsMjExLDIxMSwxXSwgXCJsaWdodGdyZWVuXCI6IFsxNDQsMjM4LDE0NCwxXSxcbiAgXCJsaWdodGdyZXlcIjogWzIxMSwyMTEsMjExLDFdLCBcImxpZ2h0cGlua1wiOiBbMjU1LDE4MiwxOTMsMV0sXG4gIFwibGlnaHRzYWxtb25cIjogWzI1NSwxNjAsMTIyLDFdLCBcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLDE3OCwxNzAsMV0sXG4gIFwibGlnaHRza3libHVlXCI6IFsxMzUsMjA2LDI1MCwxXSwgXCJsaWdodHNsYXRlZ3JheVwiOiBbMTE5LDEzNiwxNTMsMV0sXG4gIFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwxMzYsMTUzLDFdLCBcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsMTk2LDIyMiwxXSxcbiAgXCJsaWdodHllbGxvd1wiOiBbMjU1LDI1NSwyMjQsMV0sIFwibGltZVwiOiBbMCwyNTUsMCwxXSxcbiAgXCJsaW1lZ3JlZW5cIjogWzUwLDIwNSw1MCwxXSwgXCJsaW5lblwiOiBbMjUwLDI0MCwyMzAsMV0sXG4gIFwibWFnZW50YVwiOiBbMjU1LDAsMjU1LDFdLCBcIm1hcm9vblwiOiBbMTI4LDAsMCwxXSxcbiAgXCJtZWRpdW1hcXVhbWFyaW5lXCI6IFsxMDIsMjA1LDE3MCwxXSwgXCJtZWRpdW1ibHVlXCI6IFswLDAsMjA1LDFdLFxuICBcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LDg1LDIxMSwxXSwgXCJtZWRpdW1wdXJwbGVcIjogWzE0NywxMTIsMjE5LDFdLFxuICBcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwxNzksMTEzLDFdLCBcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLDEwNCwyMzgsMV0sXG4gIFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogWzAsMjUwLDE1NCwxXSwgXCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLDIwOSwyMDQsMV0sXG4gIFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksMjEsMTMzLDFdLCBcIm1pZG5pZ2h0Ymx1ZVwiOiBbMjUsMjUsMTEyLDFdLFxuICBcIm1pbnRjcmVhbVwiOiBbMjQ1LDI1NSwyNTAsMV0sIFwibWlzdHlyb3NlXCI6IFsyNTUsMjI4LDIyNSwxXSxcbiAgXCJtb2NjYXNpblwiOiBbMjU1LDIyOCwxODEsMV0sIFwibmF2YWpvd2hpdGVcIjogWzI1NSwyMjIsMTczLDFdLFxuICBcIm5hdnlcIjogWzAsMCwxMjgsMV0sIFwib2xkbGFjZVwiOiBbMjUzLDI0NSwyMzAsMV0sXG4gIFwib2xpdmVcIjogWzEyOCwxMjgsMCwxXSwgXCJvbGl2ZWRyYWJcIjogWzEwNywxNDIsMzUsMV0sXG4gIFwib3JhbmdlXCI6IFsyNTUsMTY1LDAsMV0sIFwib3JhbmdlcmVkXCI6IFsyNTUsNjksMCwxXSxcbiAgXCJvcmNoaWRcIjogWzIxOCwxMTIsMjE0LDFdLCBcInBhbGVnb2xkZW5yb2RcIjogWzIzOCwyMzIsMTcwLDFdLFxuICBcInBhbGVncmVlblwiOiBbMTUyLDI1MSwxNTIsMV0sIFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LDIzOCwyMzgsMV0sXG4gIFwicGFsZXZpb2xldHJlZFwiOiBbMjE5LDExMiwxNDcsMV0sIFwicGFwYXlhd2hpcFwiOiBbMjU1LDIzOSwyMTMsMV0sXG4gIFwicGVhY2hwdWZmXCI6IFsyNTUsMjE4LDE4NSwxXSwgXCJwZXJ1XCI6IFsyMDUsMTMzLDYzLDFdLFxuICBcInBpbmtcIjogWzI1NSwxOTIsMjAzLDFdLCBcInBsdW1cIjogWzIyMSwxNjAsMjIxLDFdLFxuICBcInBvd2RlcmJsdWVcIjogWzE3NiwyMjQsMjMwLDFdLCBcInB1cnBsZVwiOiBbMTI4LDAsMTI4LDFdLFxuICBcInJlZFwiOiBbMjU1LDAsMCwxXSwgXCJyb3N5YnJvd25cIjogWzE4OCwxNDMsMTQzLDFdLFxuICBcInJveWFsYmx1ZVwiOiBbNjUsMTA1LDIyNSwxXSwgXCJzYWRkbGVicm93blwiOiBbMTM5LDY5LDE5LDFdLFxuICBcInNhbG1vblwiOiBbMjUwLDEyOCwxMTQsMV0sIFwic2FuZHlicm93blwiOiBbMjQ0LDE2NCw5NiwxXSxcbiAgXCJzZWFncmVlblwiOiBbNDYsMTM5LDg3LDFdLCBcInNlYXNoZWxsXCI6IFsyNTUsMjQ1LDIzOCwxXSxcbiAgXCJzaWVubmFcIjogWzE2MCw4Miw0NSwxXSwgXCJzaWx2ZXJcIjogWzE5MiwxOTIsMTkyLDFdLFxuICBcInNreWJsdWVcIjogWzEzNSwyMDYsMjM1LDFdLCBcInNsYXRlYmx1ZVwiOiBbMTA2LDkwLDIwNSwxXSxcbiAgXCJzbGF0ZWdyYXlcIjogWzExMiwxMjgsMTQ0LDFdLCBcInNsYXRlZ3JleVwiOiBbMTEyLDEyOCwxNDQsMV0sXG4gIFwic25vd1wiOiBbMjU1LDI1MCwyNTAsMV0sIFwic3ByaW5nZ3JlZW5cIjogWzAsMjU1LDEyNywxXSxcbiAgXCJzdGVlbGJsdWVcIjogWzcwLDEzMCwxODAsMV0sIFwidGFuXCI6IFsyMTAsMTgwLDE0MCwxXSxcbiAgXCJ0ZWFsXCI6IFswLDEyOCwxMjgsMV0sIFwidGhpc3RsZVwiOiBbMjE2LDE5MSwyMTYsMV0sXG4gIFwidG9tYXRvXCI6IFsyNTUsOTksNzEsMV0sIFwidHVycXVvaXNlXCI6IFs2NCwyMjQsMjA4LDFdLFxuICBcInZpb2xldFwiOiBbMjM4LDEzMCwyMzgsMV0sIFwid2hlYXRcIjogWzI0NSwyMjIsMTc5LDFdLFxuICBcIndoaXRlXCI6IFsyNTUsMjU1LDI1NSwxXSwgXCJ3aGl0ZXNtb2tlXCI6IFsyNDUsMjQ1LDI0NSwxXSxcbiAgXCJ5ZWxsb3dcIjogWzI1NSwyNTUsMCwxXSwgXCJ5ZWxsb3dncmVlblwiOiBbMTU0LDIwNSw1MCwxXX1cblxuZnVuY3Rpb24gY2xhbXBfY3NzX2J5dGUoaSkgeyAgLy8gQ2xhbXAgdG8gaW50ZWdlciAwIC4uIDI1NS5cbiAgaSA9IE1hdGgucm91bmQoaSk7ICAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cbiAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAyNTUgPyAyNTUgOiBpO1xufVxuXG5mdW5jdGlvbiBjbGFtcF9jc3NfZmxvYXQoZikgeyAgLy8gQ2xhbXAgdG8gZmxvYXQgMC4wIC4uIDEuMC5cbiAgcmV0dXJuIGYgPCAwID8gMCA6IGYgPiAxID8gMSA6IGY7XG59XG5cbmZ1bmN0aW9uIHBhcnNlX2Nzc19pbnQoc3RyKSB7ICAvLyBpbnQgb3IgcGVyY2VudGFnZS5cbiAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICclJylcbiAgICByZXR1cm4gY2xhbXBfY3NzX2J5dGUocGFyc2VGbG9hdChzdHIpIC8gMTAwICogMjU1KTtcbiAgcmV0dXJuIGNsYW1wX2Nzc19ieXRlKHBhcnNlSW50KHN0cikpO1xufVxuXG5mdW5jdGlvbiBwYXJzZV9jc3NfZmxvYXQoc3RyKSB7ICAvLyBmbG9hdCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJyUnKVxuICAgIHJldHVybiBjbGFtcF9jc3NfZmxvYXQocGFyc2VGbG9hdChzdHIpIC8gMTAwKTtcbiAgcmV0dXJuIGNsYW1wX2Nzc19mbG9hdChwYXJzZUZsb2F0KHN0cikpO1xufVxuXG5mdW5jdGlvbiBjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgpIHtcbiAgaWYgKGggPCAwKSBoICs9IDE7XG4gIGVsc2UgaWYgKGggPiAxKSBoIC09IDE7XG5cbiAgaWYgKGggKiA2IDwgMSkgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7XG4gIGlmIChoICogMiA8IDEpIHJldHVybiBtMjtcbiAgaWYgKGggKiAzIDwgMikgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIvMyAtIGgpICogNjtcbiAgcmV0dXJuIG0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNTU0NvbG9yKGNzc19zdHIpIHtcbiAgLy8gUmVtb3ZlIGFsbCB3aGl0ZXNwYWNlLCBub3QgY29tcGxpYW50LCBidXQgc2hvdWxkIGp1c3QgYmUgbW9yZSBhY2NlcHRpbmcuXG4gIHZhciBzdHIgPSBjc3Nfc3RyLnJlcGxhY2UoLyAvZywgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gQ29sb3Iga2V5d29yZHMgKGFuZCB0cmFuc3BhcmVudCkgbG9va3VwLlxuICBpZiAoc3RyIGluIGtDU1NDb2xvclRhYmxlKSByZXR1cm4ga0NTU0NvbG9yVGFibGVbc3RyXS5zbGljZSgpOyAgLy8gZHVwLlxuXG4gIC8vICNhYmMgYW5kICNhYmMxMjMgc3ludGF4LlxuICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmKSkgcmV0dXJuIG51bGw7ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgcmV0dXJuIFsoKGl2ICYgMHhmMDApID4+IDQpIHwgKChpdiAmIDB4ZjAwKSA+PiA4KSxcbiAgICAgICAgICAgICAgKGl2ICYgMHhmMCkgfCAoKGl2ICYgMHhmMCkgPj4gNCksXG4gICAgICAgICAgICAgIChpdiAmIDB4ZikgfCAoKGl2ICYgMHhmKSA8PCA0KSxcbiAgICAgICAgICAgICAgMV07XG4gICAgfSBlbHNlIGlmIChzdHIubGVuZ3RoID09PSA3KSB7XG4gICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmZmZmYpKSByZXR1cm4gbnVsbDsgIC8vIENvdmVycyBOYU4uXG4gICAgICByZXR1cm4gWyhpdiAmIDB4ZmYwMDAwKSA+PiAxNixcbiAgICAgICAgICAgICAgKGl2ICYgMHhmZjAwKSA+PiA4LFxuICAgICAgICAgICAgICBpdiAmIDB4ZmYsXG4gICAgICAgICAgICAgIDFdO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG9wID0gc3RyLmluZGV4T2YoJygnKSwgZXAgPSBzdHIuaW5kZXhPZignKScpO1xuICBpZiAob3AgIT09IC0xICYmIGVwICsgMSA9PT0gc3RyLmxlbmd0aCkge1xuICAgIHZhciBmbmFtZSA9IHN0ci5zdWJzdHIoMCwgb3ApO1xuICAgIHZhciBwYXJhbXMgPSBzdHIuc3Vic3RyKG9wKzEsIGVwLShvcCsxKSkuc3BsaXQoJywnKTtcbiAgICB2YXIgYWxwaGEgPSAxOyAgLy8gVG8gYWxsb3cgY2FzZSBmYWxsdGhyb3VnaC5cbiAgICBzd2l0Y2ggKGZuYW1lKSB7XG4gICAgICBjYXNlICdyZ2JhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHJldHVybiBudWxsO1xuICAgICAgICBhbHBoYSA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICdyZ2InOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBbcGFyc2VfY3NzX2ludChwYXJhbXNbMF0pLFxuICAgICAgICAgICAgICAgIHBhcnNlX2Nzc19pbnQocGFyYW1zWzFdKSxcbiAgICAgICAgICAgICAgICBwYXJzZV9jc3NfaW50KHBhcmFtc1syXSksXG4gICAgICAgICAgICAgICAgYWxwaGFdO1xuICAgICAgY2FzZSAnaHNsYSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgYWxwaGEgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zLnBvcCgpKTtcbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuICAgICAgY2FzZSAnaHNsJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgaCA9ICgoKHBhcnNlRmxvYXQocGFyYW1zWzBdKSAlIDM2MCkgKyAzNjApICUgMzYwKSAvIDM2MDsgIC8vIDAgLi4gMVxuICAgICAgICAvLyBOT1RFKGRlYW5tKTogQWNjb3JkaW5nIHRvIHRoZSBDU1Mgc3BlYyBzL2wgc2hvdWxkIG9ubHkgYmVcbiAgICAgICAgLy8gcGVyY2VudGFnZXMsIGJ1dCB3ZSBkb24ndCBib3RoZXIgYW5kIGxldCBmbG9hdCBvciBwZXJjZW50YWdlLlxuICAgICAgICB2YXIgcyA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMV0pO1xuICAgICAgICB2YXIgbCA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMl0pO1xuICAgICAgICB2YXIgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIG0xID0gbCAqIDIgLSBtMjtcbiAgICAgICAgcmV0dXJuIFtjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgrMS8zKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoLTEvMykgKiAyNTUpLFxuICAgICAgICAgICAgICAgIGFscGhhXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG50cnkgeyBleHBvcnRzLnBhcnNlQ1NTQ29sb3IgPSBwYXJzZUNTU0NvbG9yIH0gY2F0Y2goZSkgeyB9XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZWFyY3V0O1xuXG5mdW5jdGlvbiBlYXJjdXQocG9pbnRzKSB7XG5cbiAgICB2YXIgb3V0ZXJOb2RlID0gbGlua2VkTGlzdChwb2ludHNbMF0sIHRydWUpLFxuICAgICAgICBub2RlLCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCB4LCB5LCBzaXplLFxuICAgICAgICBsZW4gPSAwLFxuICAgICAgICB0aHJlc2hvbGQgPSA4MDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBsZW4gPCB0aHJlc2hvbGQgJiYgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykgbGVuICs9IHBvaW50c1tpXS5sZW5ndGg7XG5cbiAgICAvLyBpZiB0aGUgc2hhcGUgaXMgbm90IHRvbyBzaW1wbGUsIHdlJ2xsIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2ggbGF0ZXI7IGNhbGN1bGF0ZSBwb2x5Z29uIGJib3hcbiAgICBpZiAobGVuID49IHRocmVzaG9sZCkge1xuICAgICAgICBub2RlID0gb3V0ZXJOb2RlLm5leHQ7XG4gICAgICAgIG1pblggPSBtYXhYID0gbm9kZS5wWzBdO1xuICAgICAgICBtaW5ZID0gbWF4WSA9IG5vZGUucFsxXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgeCA9IG5vZGUucFswXTtcbiAgICAgICAgICAgIHkgPSBub2RlLnBbMV07XG4gICAgICAgICAgICBpZiAoeCA8IG1pblgpIG1pblggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSBtaW5ZID0geTtcbiAgICAgICAgICAgIGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA+IG1heFkpIG1heFkgPSB5O1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfSB3aGlsZSAobm9kZSAhPT0gb3V0ZXJOb2RlKTtcblxuICAgICAgICAvLyBtaW5YLCBtaW5ZIGFuZCBzaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxuICAgICAgICBzaXplID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICB9XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA+IDEpIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKHBvaW50cywgb3V0ZXJOb2RlKTtcblxuICAgIHZhciB0cmlhbmdsZXMgPSBbXTtcbiAgICBpZiAob3V0ZXJOb2RlKSBlYXJjdXRMaW5rZWQob3V0ZXJOb2RlLCB0cmlhbmdsZXMsIG1pblgsIG1pblksIHNpemUpO1xuXG4gICAgcmV0dXJuIHRyaWFuZ2xlcztcbn1cblxuLy8gY3JlYXRlIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0IGZyb20gcG9seWdvbiBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCB3aW5kaW5nIG9yZGVyXG5mdW5jdGlvbiBsaW5rZWRMaXN0KHBvaW50cywgY2xvY2t3aXNlKSB7XG4gICAgdmFyIHN1bSA9IDAsXG4gICAgICAgIGxlbiA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIGksIGosIGxhc3Q7XG5cbiAgICAvLyBjYWxjdWxhdGUgb3JpZ2luYWwgd2luZGluZyBvcmRlciBvZiBhIHBvbHlnb24gcmluZ1xuICAgIGZvciAoaSA9IDAsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XG4gICAgICAgIHZhciBwMSA9IHBvaW50c1tpXSxcbiAgICAgICAgICAgIHAyID0gcG9pbnRzW2pdO1xuICAgICAgICBzdW0gKz0gKHAyWzBdIC0gcDFbMF0pICogKHAxWzFdICsgcDJbMV0pO1xuICAgIH1cblxuICAgIC8vIGxpbmsgcG9pbnRzIGludG8gY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaXN0IGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxuICAgIGlmIChjbG9ja3dpc2UgPT09IChzdW0gPiAwKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIGxhc3QgPSBpbnNlcnROb2RlKHBvaW50c1tpXSwgbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIGxhc3QgPSBpbnNlcnROb2RlKHBvaW50c1tpXSwgbGFzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhc3Q7XG59XG5cbmZ1bmN0aW9uIGZpbHRlclBvaW50cyhzdGFydCkge1xuICAgIC8vIGVsaW1pbmF0ZSBjb2xpbmVhciBvciBkdXBsaWNhdGUgcG9pbnRzXG4gICAgdmFyIG5vZGUgPSBzdGFydCxcbiAgICAgICAgYWdhaW47XG4gICAgZG8ge1xuICAgICAgICBhZ2FpbiA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChlcXVhbHMobm9kZS5wLCBub2RlLm5leHQucCkgfHwgb3JpZW50KG5vZGUucHJldi5wLCBub2RlLnAsIG5vZGUubmV4dC5wKSA9PT0gMCkge1xuXG4gICAgICAgICAgICBub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgIG5vZGUubmV4dC5wcmV2ID0gbm9kZS5wcmV2O1xuXG4gICAgICAgICAgICBpZiAobm9kZS5wcmV2Wikgbm9kZS5wcmV2Wi5uZXh0WiA9IG5vZGUubmV4dFo7XG4gICAgICAgICAgICBpZiAobm9kZS5uZXh0Wikgbm9kZS5uZXh0Wi5wcmV2WiA9IG5vZGUucHJldlo7XG5cbiAgICAgICAgICAgIG5vZGUgPSBzdGFydCA9IG5vZGUucHJldjtcblxuICAgICAgICAgICAgaWYgKG5vZGUgPT09IG5vZGUubmV4dCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBhZ2FpbiA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChhZ2FpbiB8fCBub2RlICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gc3RhcnQ7XG59XG5cbmZ1bmN0aW9uIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgbWluWCwgbWluWSwgc2l6ZSwgc2Vjb25kUGFzcykge1xuICAgIGVhciA9IGZpbHRlclBvaW50cyhlYXIpO1xuICAgIGlmICghZWFyKSByZXR1cm47XG5cbiAgICBpZiAoIXNlY29uZFBhc3MgJiYgbWluWCAhPT0gdW5kZWZpbmVkKSBpbmRleEN1cnZlKGVhciwgbWluWCwgbWluWSwgc2l6ZSk7XG5cbiAgICB2YXIgc3RvcCA9IGVhcixcbiAgICAgICAgcHJldiwgbmV4dDtcblxuICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBlYXJzLCBzbGljaW5nIHRoZW0gb25lIGJ5IG9uZVxuICAgIHdoaWxlIChlYXIucHJldiAhPT0gZWFyLm5leHQpIHtcbiAgICAgICAgcHJldiA9IGVhci5wcmV2O1xuICAgICAgICBuZXh0ID0gZWFyLm5leHQ7XG5cbiAgICAgICAgaWYgKGlzRWFyKGVhciwgbWluWCwgbWluWSwgc2l6ZSkpIHtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHByZXYucCwgZWFyLnAsIG5leHQucCk7XG5cbiAgICAgICAgICAgIG5leHQucHJldiA9IHByZXY7XG4gICAgICAgICAgICBwcmV2Lm5leHQgPSBuZXh0O1xuXG4gICAgICAgICAgICBpZiAoZWFyLnByZXZaKSBlYXIucHJldloubmV4dFogPSBlYXIubmV4dFo7XG4gICAgICAgICAgICBpZiAoZWFyLm5leHRaKSBlYXIubmV4dFoucHJldlogPSBlYXIucHJldlo7XG5cbiAgICAgICAgICAgIGVhciA9IG5leHQubmV4dDtcbiAgICAgICAgICAgIHN0b3AgPSBuZXh0Lm5leHQ7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFyID0gbmV4dDtcblxuICAgICAgICBpZiAoZWFyID09PSBzdG9wKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnMsIHRyeSBmaWx0ZXJpbmcgcG9pbnRzIGFuZCBjdXR0aW5nIGFnYWluXG4gICAgICAgICAgICBpZiAoIXNlY29uZFBhc3MpIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgbWluWCwgbWluWSwgc2l6ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgc3BsaXR0aW5nIHRoZSByZW1haW5pbmcgcG9seWdvbiBpbnRvIHR3b1xuICAgICAgICAgICAgZWxzZSBzcGxpdEVhcmN1dChlYXIsIHRyaWFuZ2xlcywgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNFYXIoZWFyLCBtaW5YLCBtaW5ZLCBzaXplKSB7XG5cbiAgICB2YXIgYSA9IGVhci5wcmV2LnAsXG4gICAgICAgIGIgPSBlYXIucCxcbiAgICAgICAgYyA9IGVhci5uZXh0LnAsXG5cbiAgICAgICAgYXggPSBhWzBdLCBieCA9IGJbMF0sIGN4ID0gY1swXSxcbiAgICAgICAgYXkgPSBhWzFdLCBieSA9IGJbMV0sIGN5ID0gY1sxXSxcblxuICAgICAgICBhYmQgPSBheCAqIGJ5IC0gYXkgKiBieCxcbiAgICAgICAgYWNkID0gYXggKiBjeSAtIGF5ICogY3gsXG4gICAgICAgIGNiZCA9IGN4ICogYnkgLSBjeSAqIGJ4LFxuICAgICAgICBBID0gYWJkIC0gYWNkIC0gY2JkO1xuXG4gICAgaWYgKEEgPD0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcblxuICAgIHZhciBjYXkgPSBjeSAtIGF5LFxuICAgICAgICBhY3ggPSBheCAtIGN4LFxuICAgICAgICBhYnkgPSBheSAtIGJ5LFxuICAgICAgICBiYXggPSBieCAtIGF4LFxuICAgICAgICBwLCBweCwgcHksIHMsIHQsIGssIG5vZGU7XG5cbiAgICAvLyBpZiB3ZSB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoaW5nLCBpdGVyYXRlIHRocm91Z2ggdGhlIGN1cnZlXG4gICAgaWYgKG1pblggIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgIC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXG4gICAgICAgIHZhciBtaW5UWCA9IGF4IDwgYnggPyAoYXggPCBjeCA/IGF4IDogY3gpIDogKGJ4IDwgY3ggPyBieCA6IGN4KSxcbiAgICAgICAgICAgIG1pblRZID0gYXkgPCBieSA/IChheSA8IGN5ID8gYXkgOiBjeSkgOiAoYnkgPCBjeSA/IGJ5IDogY3kpLFxuICAgICAgICAgICAgbWF4VFggPSBheCA+IGJ4ID8gKGF4ID4gY3ggPyBheCA6IGN4KSA6IChieCA+IGN4ID8gYnggOiBjeCksXG4gICAgICAgICAgICBtYXhUWSA9IGF5ID4gYnkgPyAoYXkgPiBjeSA/IGF5IDogY3kpIDogKGJ5ID4gY3kgPyBieSA6IGN5KSxcblxuICAgICAgICAgICAgLy8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcbiAgICAgICAgICAgIG1pblogPSB6T3JkZXIobWluVFgsIG1pblRZLCBtaW5YLCBtaW5ZLCBzaXplKSxcbiAgICAgICAgICAgIG1heFogPSB6T3JkZXIobWF4VFgsIG1heFRZLCBtaW5YLCBtaW5ZLCBzaXplKTtcblxuICAgICAgICAvLyBmaXJzdCBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBpbiBpbmNyZWFzaW5nIHotb3JkZXJcbiAgICAgICAgbm9kZSA9IGVhci5uZXh0WjtcblxuICAgICAgICB3aGlsZSAobm9kZSAmJiBub2RlLnogPD0gbWF4Wikge1xuICAgICAgICAgICAgcCA9IG5vZGUucDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHRaO1xuICAgICAgICAgICAgaWYgKHAgPT09IGEgfHwgcCA9PT0gYykgY29udGludWU7XG5cbiAgICAgICAgICAgIHB4ID0gcFswXTtcbiAgICAgICAgICAgIHB5ID0gcFsxXTtcblxuICAgICAgICAgICAgcyA9IGNheSAqIHB4ICsgYWN4ICogcHkgLSBhY2Q7XG4gICAgICAgICAgICBpZiAocyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdCA9IGFieSAqIHB4ICsgYmF4ICogcHkgKyBhYmQ7XG4gICAgICAgICAgICAgICAgaWYgKHQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBrID0gQSAtIHMgLSB0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGsgPj0gMCkgJiYgKChzICYmIHQpIHx8IChzICYmIGspIHx8ICh0ICYmIGspKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZW4gbG9vayBmb3IgcG9pbnRzIGluIGRlY3JlYXNpbmcgei1vcmRlclxuICAgICAgICBub2RlID0gZWFyLnByZXZaO1xuXG4gICAgICAgIHdoaWxlIChub2RlICYmIG5vZGUueiA+PSBtaW5aKSB7XG4gICAgICAgICAgICBwID0gbm9kZS5wO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucHJldlo7XG4gICAgICAgICAgICBpZiAocCA9PT0gYSB8fCBwID09PSBjKSBjb250aW51ZTtcblxuICAgICAgICAgICAgcHggPSBwWzBdO1xuICAgICAgICAgICAgcHkgPSBwWzFdO1xuXG4gICAgICAgICAgICBzID0gY2F5ICogcHggKyBhY3ggKiBweSAtIGFjZDtcbiAgICAgICAgICAgIGlmIChzID49IDApIHtcbiAgICAgICAgICAgICAgICB0ID0gYWJ5ICogcHggKyBiYXggKiBweSArIGFiZDtcbiAgICAgICAgICAgICAgICBpZiAodCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSBBIC0gcyAtIHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoayA+PSAwKSAmJiAoKHMgJiYgdCkgfHwgKHMgJiYgaykgfHwgKHQgJiYgaykpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAvLyBpZiB3ZSBkb24ndCB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoLCBzaW1wbHkgaXRlcmF0ZSB0aHJvdWdoIGFsbCBvdGhlciBwb2ludHNcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gZWFyLm5leHQubmV4dDtcblxuICAgICAgICB3aGlsZSAobm9kZSAhPT0gZWFyLnByZXYpIHtcbiAgICAgICAgICAgIHAgPSBub2RlLnA7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuXG4gICAgICAgICAgICBweCA9IHBbMF07XG4gICAgICAgICAgICBweSA9IHBbMV07XG5cbiAgICAgICAgICAgIHMgPSBjYXkgKiBweCArIGFjeCAqIHB5IC0gYWNkO1xuICAgICAgICAgICAgaWYgKHMgPj0gMCkge1xuICAgICAgICAgICAgICAgIHQgPSBhYnkgKiBweCArIGJheCAqIHB5ICsgYWJkO1xuICAgICAgICAgICAgICAgIGlmICh0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IEEgLSBzIC0gdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChrID49IDApICYmICgocyAmJiB0KSB8fCAocyAmJiBrKSB8fCAodCAmJiBrKSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc3BsaXRFYXJjdXQoc3RhcnQsIHRyaWFuZ2xlcywgbWluWCwgbWluWSwgc2l6ZSkge1xuICAgIC8vIGZpbmQgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cbiAgICB2YXIgYSA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGIgPSBhLm5leHQubmV4dDtcbiAgICAgICAgd2hpbGUgKGIgIT09IGEucHJldikge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREaWFnb25hbChhLCBiKSkge1xuICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBwb2x5Z29uIGluIHR3byBieSB0aGUgZGlhZ29uYWxcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHNwbGl0UG9seWdvbihhLCBiKTtcblxuICAgICAgICAgICAgICAgIC8vIHJ1biBlYXJjdXQgb24gZWFjaCBoYWxmXG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGEsIHRyaWFuZ2xlcywgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGMsIHRyaWFuZ2xlcywgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYiA9IGIubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBhID0gYS5uZXh0O1xuICAgIH0gd2hpbGUgKGEgIT09IHN0YXJ0KTtcbn1cblxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZXMocG9pbnRzLCBvdXRlck5vZGUpIHtcbiAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcblxuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGxpc3QgPSBmaWx0ZXJQb2ludHMobGlua2VkTGlzdChwb2ludHNbaV0sIGZhbHNlKSk7XG4gICAgICAgIGlmIChsaXN0KSBxdWV1ZS5wdXNoKGdldExlZnRtb3N0KGxpc3QpKTtcbiAgICB9XG4gICAgcXVldWUuc29ydChjb21wYXJlWCk7XG5cbiAgICAvLyBwcm9jZXNzIGhvbGVzIGZyb20gbGVmdCB0byByaWdodFxuICAgIGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGltaW5hdGVIb2xlKHF1ZXVlW2ldLCBvdXRlck5vZGUpO1xuICAgICAgICBvdXRlck5vZGUgPSBmaWx0ZXJQb2ludHMob3V0ZXJOb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0ZXJOb2RlO1xufVxuXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlKGhvbGVOb2RlLCBvdXRlck5vZGUpIHtcbiAgICBvdXRlck5vZGUgPSBmaW5kSG9sZUJyaWRnZShob2xlTm9kZSwgb3V0ZXJOb2RlKTtcbiAgICBpZiAob3V0ZXJOb2RlKSBzcGxpdFBvbHlnb24oaG9sZU5vZGUsIG91dGVyTm9kZSk7XG59XG5cbi8vIERhdmlkIEViZXJseSdzIGFsZ29yaXRobSBmb3IgZmluZGluZyBhIGJyaWRnZSBiZXR3ZWVuIGhvbGUgYW5kIG91dGVyIHBvbHlnb25cbmZ1bmN0aW9uIGZpbmRIb2xlQnJpZGdlKGhvbGVOb2RlLCBvdXRlck5vZGUpIHtcbiAgICB2YXIgbm9kZSA9IG91dGVyTm9kZSxcbiAgICAgICAgcCA9IGhvbGVOb2RlLnAsXG4gICAgICAgIHB4ID0gcFswXSxcbiAgICAgICAgcHkgPSBwWzFdLFxuICAgICAgICBxTWF4ID0gLUluZmluaXR5LFxuICAgICAgICBtTm9kZSwgYSwgYjtcblxuICAgIC8vIGZpbmQgYSBzZWdtZW50IGludGVyc2VjdGVkIGJ5IGEgcmF5IGZyb20gdGhlIGhvbGUncyBsZWZ0bW9zdCBwb2ludCB0byB0aGUgbGVmdDtcbiAgICAvLyBzZWdtZW50J3MgZW5kcG9pbnQgd2l0aCBsZXNzZXIgeCB3aWxsIGJlIHBvdGVudGlhbCBjb25uZWN0aW9uIHBvaW50XG4gICAgZG8ge1xuICAgICAgICBhID0gbm9kZS5wO1xuICAgICAgICBiID0gbm9kZS5uZXh0LnA7XG5cbiAgICAgICAgaWYgKHB5IDw9IGFbMV0gJiYgcHkgPj0gYlsxXSkge1xuICAgICAgICAgICAgdmFyIHF4ID0gYVswXSArIChweSAtIGFbMV0pICogKGJbMF0gLSBhWzBdKSAvIChiWzFdIC0gYVsxXSk7XG4gICAgICAgICAgICBpZiAocXggPD0gcHggJiYgcXggPiBxTWF4KSB7XG4gICAgICAgICAgICAgICAgcU1heCA9IHF4O1xuICAgICAgICAgICAgICAgIG1Ob2RlID0gYVswXSA8IGJbMF0gPyBub2RlIDogbm9kZS5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfSB3aGlsZSAobm9kZSAhPT0gb3V0ZXJOb2RlKTtcblxuICAgIGlmICghbU5vZGUpIHJldHVybiBudWxsO1xuXG4gICAgLy8gbG9vayBmb3IgcG9pbnRzIHN0cmljdGx5IGluc2lkZSB0aGUgdHJpYW5nbGUgb2YgaG9sZSBwb2ludCwgc2VnbWVudCBpbnRlcnNlY3Rpb24gYW5kIGVuZHBvaW50O1xuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBwb2ludHMgZm91bmQsIHdlIGhhdmUgYSB2YWxpZCBjb25uZWN0aW9uO1xuICAgIC8vIG90aGVyd2lzZSBjaG9vc2UgdGhlIHBvaW50IG9mIHRoZSBtaW5pbXVtIGFuZ2xlIHdpdGggdGhlIHJheSBhcyBjb25uZWN0aW9uIHBvaW50XG5cbiAgICB2YXIgYnggPSBtTm9kZS5wWzBdLFxuICAgICAgICBieSA9IG1Ob2RlLnBbMV0sXG4gICAgICAgIHBiZCA9IHB4ICogYnkgLSBweSAqIGJ4LFxuICAgICAgICBwY2QgPSBweCAqIHB5IC0gcHkgKiBxTWF4LFxuICAgICAgICBjcHkgPSBweSAtIHB5LFxuICAgICAgICBwY3ggPSBweCAtIHFNYXgsXG4gICAgICAgIHBieSA9IHB5IC0gYnksXG4gICAgICAgIGJweCA9IGJ4IC0gcHgsXG4gICAgICAgIEEgPSBwYmQgLSBwY2QgLSAocU1heCAqIGJ5IC0gcHkgKiBieCksXG4gICAgICAgIHNpZ24gPSBBIDw9IDAgPyAtMSA6IDEsXG4gICAgICAgIHN0b3AgPSBtTm9kZSxcbiAgICAgICAgdGFuTWluID0gSW5maW5pdHksXG4gICAgICAgIG14LCBteSwgYW14LCBzLCB0LCB0YW47XG5cbiAgICBub2RlID0gbU5vZGUubmV4dDtcblxuICAgIHdoaWxlIChub2RlICE9PSBzdG9wKSB7XG5cbiAgICAgICAgbXggPSBub2RlLnBbMF07XG4gICAgICAgIG15ID0gbm9kZS5wWzFdO1xuICAgICAgICBhbXggPSBweCAtIG14O1xuXG4gICAgICAgIGlmIChhbXggPj0gMCAmJiBteCA+PSBieCkge1xuICAgICAgICAgICAgcyA9IChjcHkgKiBteCArIHBjeCAqIG15IC0gcGNkKSAqIHNpZ247XG4gICAgICAgICAgICBpZiAocyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdCA9IChwYnkgKiBteCArIGJweCAqIG15ICsgcGJkKSAqIHNpZ247XG5cbiAgICAgICAgICAgICAgICBpZiAodCA+PSAwICYmIEEgKiBzaWduIC0gcyAtIHQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0YW4gPSBNYXRoLmFicyhweSAtIG15KSAvIGFteDsgLy8gdGFuZ2VudGlhbFxuICAgICAgICAgICAgICAgICAgICBpZiAodGFuIDwgdGFuTWluICYmIGxvY2FsbHlJbnNpZGUobm9kZSwgaG9sZU5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YW5NaW4gPSB0YW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBtTm9kZTtcbn1cblxuZnVuY3Rpb24gaW5kZXhDdXJ2ZShzdGFydCwgbWluWCwgbWluWSwgc2l6ZSkge1xuICAgIHZhciBub2RlID0gc3RhcnQ7XG5cbiAgICBkbyB7XG4gICAgICAgIG5vZGUueiA9IG5vZGUueiB8fCB6T3JkZXIobm9kZS5wWzBdLCBub2RlLnBbMV0sIG1pblgsIG1pblksIHNpemUpO1xuICAgICAgICBub2RlLnByZXZaID0gbm9kZS5wcmV2O1xuICAgICAgICBub2RlLm5leHRaID0gbm9kZS5uZXh0O1xuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH0gd2hpbGUgKG5vZGUgIT09IHN0YXJ0KTtcblxuICAgIG5vZGUucHJldloubmV4dFogPSBudWxsO1xuICAgIG5vZGUucHJldlogPSBudWxsO1xuXG4gICAgc29ydExpbmtlZChub2RlKTtcbn1cblxuLy8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cbi8vIGh0dHA6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vYWxnb3JpdGhtcy9saXN0c29ydC5odG1sXG5mdW5jdGlvbiBzb3J0TGlua2VkKGxpc3QpIHtcbiAgICB2YXIgaSwgcCwgcSwgZSwgdGFpbCwgbnVtTWVyZ2VzLCBwU2l6ZSwgcVNpemUsXG4gICAgICAgIGluU2l6ZSA9IDE7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBwID0gbGlzdDtcbiAgICAgICAgbGlzdCA9IG51bGw7XG4gICAgICAgIHRhaWwgPSBudWxsO1xuICAgICAgICBudW1NZXJnZXMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBudW1NZXJnZXMrKztcbiAgICAgICAgICAgIHEgPSBwO1xuICAgICAgICAgICAgcFNpemUgPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcFNpemUrKztcbiAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICBpZiAoIXEpIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBxU2l6ZSA9IGluU2l6ZTtcblxuICAgICAgICAgICAgd2hpbGUgKHBTaXplID4gMCB8fCAocVNpemUgPiAwICYmIHEpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocFNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBxU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocVNpemUgPT09IDAgfHwgIXEpIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocC56IDw9IHEueikge1xuICAgICAgICAgICAgICAgICAgICBlID0gcDtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHBTaXplLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBxU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0YWlsKSB0YWlsLm5leHRaID0gZTtcbiAgICAgICAgICAgICAgICBlbHNlIGxpc3QgPSBlO1xuXG4gICAgICAgICAgICAgICAgZS5wcmV2WiA9IHRhaWw7XG4gICAgICAgICAgICAgICAgdGFpbCA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAgPSBxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFpbC5uZXh0WiA9IG51bGw7XG5cbiAgICAgICAgaWYgKG51bU1lcmdlcyA8PSAxKSByZXR1cm4gbGlzdDtcblxuICAgICAgICBpblNpemUgKj0gMjtcbiAgICB9XG59XG5cbi8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIGJib3hcbmZ1bmN0aW9uIHpPcmRlcih4LCB5LCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgLy8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvICgwLi4xMDAwKSBpbnRlZ2VyIHJhbmdlXG4gICAgeCA9IDEwMDAgKiAoeCAtIG1pblgpIC8gc2l6ZTtcbiAgICB4ID0gKHggfCAoeCA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHggPSAoeCB8ICh4IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeCA9ICh4IHwgKHggPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB4ID0gKHggfCAoeCA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgeSA9IDEwMDAgKiAoeSAtIG1pblkpIC8gc2l6ZTtcbiAgICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuZnVuY3Rpb24gZ2V0TGVmdG1vc3Qoc3RhcnQpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0LFxuICAgICAgICBsZWZ0bW9zdCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKG5vZGUucFswXSA8IGxlZnRtb3N0LnBbMF0pIGxlZnRtb3N0ID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICB9IHdoaWxlIChub2RlICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gbGVmdG1vc3Q7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREaWFnb25hbChhLCBiKSB7XG4gICAgcmV0dXJuICFpbnRlcnNlY3RzUG9seWdvbihhLCBhLnAsIGIucCkgJiZcbiAgICAgICAgICAgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpICYmXG4gICAgICAgICAgIG1pZGRsZUluc2lkZShhLCBhLnAsIGIucCk7XG59XG5cbi8vIHdpbmRpbmcgb3JkZXIgb2YgdHJpYW5nbGUgZm9ybWVkIGJ5IDMgZ2l2ZW4gcG9pbnRzXG5mdW5jdGlvbiBvcmllbnQocCwgcSwgcikge1xuICAgIHZhciBvID0gKHFbMV0gLSBwWzFdKSAqIChyWzBdIC0gcVswXSkgLSAocVswXSAtIHBbMF0pICogKHJbMV0gLSBxWzFdKTtcbiAgICByZXR1cm4gbyA+IDAgPyAxIDpcbiAgICAgICAgICAgbyA8IDAgPyAtMSA6IDA7XG59XG5cbmZ1bmN0aW9uIGVxdWFscyhwMSwgcDIpIHtcbiAgICByZXR1cm4gcDFbMF0gPT09IHAyWzBdICYmIHAxWzFdID09PSBwMlsxXTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHNlZ21lbnRzIGludGVyc2VjdFxuZnVuY3Rpb24gaW50ZXJzZWN0cyhwMSwgcTEsIHAyLCBxMikge1xuICAgIHJldHVybiBvcmllbnQocDEsIHExLCBwMikgIT09IG9yaWVudChwMSwgcTEsIHEyKSAmJlxuICAgICAgICAgICBvcmllbnQocDIsIHEyLCBwMSkgIT09IG9yaWVudChwMiwgcTIsIHExKTtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGludGVyc2VjdHMgYW55IHBvbHlnb24gc2VnbWVudHNcbmZ1bmN0aW9uIGludGVyc2VjdHNQb2x5Z29uKHN0YXJ0LCBhLCBiKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBwMSA9IG5vZGUucCxcbiAgICAgICAgICAgIHAyID0gbm9kZS5uZXh0LnA7XG5cbiAgICAgICAgaWYgKHAxICE9PSBhICYmIHAyICE9PSBhICYmIHAxICE9PSBiICYmIHAyICE9PSBiICYmIGludGVyc2VjdHMocDEsIHAyLCBhLCBiKSkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICB9IHdoaWxlIChub2RlICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbG9jYWxseUluc2lkZShhLCBiKSB7XG4gICAgcmV0dXJuIG9yaWVudChhLnByZXYucCwgYS5wLCBhLm5leHQucCkgPT09IC0xID9cbiAgICAgICAgb3JpZW50KGEucCwgYi5wLCBhLm5leHQucCkgIT09IC0xICYmIG9yaWVudChhLnAsIGEucHJldi5wLCBiLnApICE9PSAtMSA6XG4gICAgICAgIG9yaWVudChhLnAsIGIucCwgYS5wcmV2LnApID09PSAtMSB8fCBvcmllbnQoYS5wLCBhLm5leHQucCwgYi5wKSA9PT0gLTE7XG59XG5cbi8vIGNoZWNrIGlmIHRoZSBtaWRkbGUgcG9pbnQgb2YgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbWlkZGxlSW5zaWRlKHN0YXJ0LCBhLCBiKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydCxcbiAgICAgICAgaW5zaWRlID0gZmFsc2UsXG4gICAgICAgIHB4ID0gKGFbMF0gKyBiWzBdKSAvIDIsXG4gICAgICAgIHB5ID0gKGFbMV0gKyBiWzFdKSAvIDI7XG4gICAgZG8ge1xuICAgICAgICB2YXIgcDEgPSBub2RlLnAsXG4gICAgICAgICAgICBwMiA9IG5vZGUubmV4dC5wO1xuXG4gICAgICAgIGlmICgoKHAxWzFdID4gcHkpICE9PSAocDJbMV0gPiBweSkpICYmXG4gICAgICAgICAgICAocHggPCAocDJbMF0gLSBwMVswXSkgKiAocHkgLSBwMVsxXSkgLyAocDJbMV0gLSBwMVsxXSkgKyBwMVswXSkpIGluc2lkZSA9ICFpbnNpZGU7XG5cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICB9IHdoaWxlIChub2RlICE9PSBzdGFydCk7XG5cbiAgICByZXR1cm4gaW5zaWRlO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlWChhLCBiKSB7XG4gICAgcmV0dXJuIGEucFswXSAtIGIucFswXTtcbn1cblxuLy8gc3BsaXQgdGhlIHBvbHlnb24gdmVydGljZXMgY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaW5rZWQgbGlzdCBpbnRvIHR3b1xuZnVuY3Rpb24gc3BsaXRQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgYTIgPSBuZXcgTm9kZShhLnApLFxuICAgICAgICBiMiA9IG5ldyBOb2RlKGIucCksXG4gICAgICAgIGFuID0gYS5uZXh0LFxuICAgICAgICBicCA9IGIucHJldjtcblxuICAgIGEubmV4dCA9IGI7XG4gICAgYi5wcmV2ID0gYTtcblxuICAgIGEyLm5leHQgPSBhbjtcbiAgICBhbi5wcmV2ID0gYTI7XG5cbiAgICBiMi5uZXh0ID0gYTI7XG4gICAgYTIucHJldiA9IGIyO1xuXG4gICAgYnAubmV4dCA9IGIyO1xuICAgIGIyLnByZXYgPSBicDtcblxuICAgIHJldHVybiBhMjtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShwb2ludCwgbGFzdCkge1xuICAgIHZhciBub2RlID0gbmV3IE5vZGUocG9pbnQpO1xuXG4gICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIG5vZGUucHJldiA9IG5vZGU7XG4gICAgICAgIG5vZGUubmV4dCA9IG5vZGU7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLm5leHQgPSBsYXN0Lm5leHQ7XG4gICAgICAgIG5vZGUucHJldiA9IGxhc3Q7XG4gICAgICAgIGxhc3QubmV4dC5wcmV2ID0gbm9kZTtcbiAgICAgICAgbGFzdC5uZXh0ID0gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIE5vZGUocCkge1xuICAgIHRoaXMucCA9IHA7XG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuXG4gICAgdGhpcy56ID0gbnVsbDtcbiAgICB0aGlzLnByZXZaID0gbnVsbDtcbiAgICB0aGlzLm5leHRaID0gbnVsbDtcbn1cbiIsIihmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICBpZiAoZ2xvYmFsLiR0cmFjZXVyUnVudGltZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgJE9iamVjdCA9IE9iamVjdDtcbiAgdmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gIHZhciAkY3JlYXRlID0gJE9iamVjdC5jcmVhdGU7XG4gIHZhciAkZGVmaW5lUHJvcGVydGllcyA9ICRPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbiAgdmFyICRkZWZpbmVQcm9wZXJ0eSA9ICRPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gIHZhciAkZnJlZXplID0gJE9iamVjdC5mcmVlemU7XG4gIHZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gJE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gIHZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9ICRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgdmFyICRrZXlzID0gJE9iamVjdC5rZXlzO1xuICB2YXIgJGhhc093blByb3BlcnR5ID0gJE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciAkdG9TdHJpbmcgPSAkT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyICRwcmV2ZW50RXh0ZW5zaW9ucyA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucztcbiAgdmFyICRzZWFsID0gT2JqZWN0LnNlYWw7XG4gIHZhciAkaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcbiAgZnVuY3Rpb24gbm9uRW51bSh2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfTtcbiAgfVxuICB2YXIgbWV0aG9kID0gbm9uRW51bTtcbiAgdmFyIGNvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBuZXdVbmlxdWVTdHJpbmcoKSB7XG4gICAgcmV0dXJuICdfXyQnICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWU5KSArICckJyArICsrY291bnRlciArICckX18nO1xuICB9XG4gIHZhciBzeW1ib2xJbnRlcm5hbFByb3BlcnR5ID0gbmV3VW5pcXVlU3RyaW5nKCk7XG4gIHZhciBzeW1ib2xEZXNjcmlwdGlvblByb3BlcnR5ID0gbmV3VW5pcXVlU3RyaW5nKCk7XG4gIHZhciBzeW1ib2xEYXRhUHJvcGVydHkgPSBuZXdVbmlxdWVTdHJpbmcoKTtcbiAgdmFyIHN5bWJvbFZhbHVlcyA9ICRjcmVhdGUobnVsbCk7XG4gIHZhciBwcml2YXRlTmFtZXMgPSAkY3JlYXRlKG51bGwpO1xuICBmdW5jdGlvbiBpc1ByaXZhdGVOYW1lKHMpIHtcbiAgICByZXR1cm4gcHJpdmF0ZU5hbWVzW3NdO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVByaXZhdGVOYW1lKCkge1xuICAgIHZhciBzID0gbmV3VW5pcXVlU3RyaW5nKCk7XG4gICAgcHJpdmF0ZU5hbWVzW3NdID0gdHJ1ZTtcbiAgICByZXR1cm4gcztcbiAgfVxuICBmdW5jdGlvbiBpc1NoaW1TeW1ib2woc3ltYm9sKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzeW1ib2wgPT09ICdvYmplY3QnICYmIHN5bWJvbCBpbnN0YW5jZW9mIFN5bWJvbFZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHR5cGVPZih2KSB7XG4gICAgaWYgKGlzU2hpbVN5bWJvbCh2KSlcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICByZXR1cm4gdHlwZW9mIHY7XG4gIH1cbiAgZnVuY3Rpb24gU3ltYm9sKGRlc2NyaXB0aW9uKSB7XG4gICAgdmFyIHZhbHVlID0gbmV3IFN5bWJvbFZhbHVlKGRlc2NyaXB0aW9uKTtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3ltYm9sKSlcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTeW1ib2wgY2Fubm90IGJlIG5ld1xcJ2VkJyk7XG4gIH1cbiAgJGRlZmluZVByb3BlcnR5KFN5bWJvbC5wcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIG5vbkVudW0oU3ltYm9sKSk7XG4gICRkZWZpbmVQcm9wZXJ0eShTeW1ib2wucHJvdG90eXBlLCAndG9TdHJpbmcnLCBtZXRob2QoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN5bWJvbFZhbHVlID0gdGhpc1tzeW1ib2xEYXRhUHJvcGVydHldO1xuICAgIGlmICghZ2V0T3B0aW9uKCdzeW1ib2xzJykpXG4gICAgICByZXR1cm4gc3ltYm9sVmFsdWVbc3ltYm9sSW50ZXJuYWxQcm9wZXJ0eV07XG4gICAgaWYgKCFzeW1ib2xWYWx1ZSlcbiAgICAgIHRocm93IFR5cGVFcnJvcignQ29udmVyc2lvbiBmcm9tIHN5bWJvbCB0byBzdHJpbmcnKTtcbiAgICB2YXIgZGVzYyA9IHN5bWJvbFZhbHVlW3N5bWJvbERlc2NyaXB0aW9uUHJvcGVydHldO1xuICAgIGlmIChkZXNjID09PSB1bmRlZmluZWQpXG4gICAgICBkZXNjID0gJyc7XG4gICAgcmV0dXJuICdTeW1ib2woJyArIGRlc2MgKyAnKSc7XG4gIH0pKTtcbiAgJGRlZmluZVByb3BlcnR5KFN5bWJvbC5wcm90b3R5cGUsICd2YWx1ZU9mJywgbWV0aG9kKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzeW1ib2xWYWx1ZSA9IHRoaXNbc3ltYm9sRGF0YVByb3BlcnR5XTtcbiAgICBpZiAoIXN5bWJvbFZhbHVlKVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdDb252ZXJzaW9uIGZyb20gc3ltYm9sIHRvIHN0cmluZycpO1xuICAgIGlmICghZ2V0T3B0aW9uKCdzeW1ib2xzJykpXG4gICAgICByZXR1cm4gc3ltYm9sVmFsdWVbc3ltYm9sSW50ZXJuYWxQcm9wZXJ0eV07XG4gICAgcmV0dXJuIHN5bWJvbFZhbHVlO1xuICB9KSk7XG4gIGZ1bmN0aW9uIFN5bWJvbFZhbHVlKGRlc2NyaXB0aW9uKSB7XG4gICAgdmFyIGtleSA9IG5ld1VuaXF1ZVN0cmluZygpO1xuICAgICRkZWZpbmVQcm9wZXJ0eSh0aGlzLCBzeW1ib2xEYXRhUHJvcGVydHksIHt2YWx1ZTogdGhpc30pO1xuICAgICRkZWZpbmVQcm9wZXJ0eSh0aGlzLCBzeW1ib2xJbnRlcm5hbFByb3BlcnR5LCB7dmFsdWU6IGtleX0pO1xuICAgICRkZWZpbmVQcm9wZXJ0eSh0aGlzLCBzeW1ib2xEZXNjcmlwdGlvblByb3BlcnR5LCB7dmFsdWU6IGRlc2NyaXB0aW9ufSk7XG4gICAgZnJlZXplKHRoaXMpO1xuICAgIHN5bWJvbFZhbHVlc1trZXldID0gdGhpcztcbiAgfVxuICAkZGVmaW5lUHJvcGVydHkoU3ltYm9sVmFsdWUucHJvdG90eXBlLCAnY29uc3RydWN0b3InLCBub25FbnVtKFN5bWJvbCkpO1xuICAkZGVmaW5lUHJvcGVydHkoU3ltYm9sVmFsdWUucHJvdG90eXBlLCAndG9TdHJpbmcnLCB7XG4gICAgdmFsdWU6IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG4gICRkZWZpbmVQcm9wZXJ0eShTeW1ib2xWYWx1ZS5wcm90b3R5cGUsICd2YWx1ZU9mJywge1xuICAgIHZhbHVlOiBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YsXG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG4gIHZhciBoYXNoUHJvcGVydHkgPSBjcmVhdGVQcml2YXRlTmFtZSgpO1xuICB2YXIgaGFzaFByb3BlcnR5RGVzY3JpcHRvciA9IHt2YWx1ZTogdW5kZWZpbmVkfTtcbiAgdmFyIGhhc2hPYmplY3RQcm9wZXJ0aWVzID0ge1xuICAgIGhhc2g6IHt2YWx1ZTogdW5kZWZpbmVkfSxcbiAgICBzZWxmOiB7dmFsdWU6IHVuZGVmaW5lZH1cbiAgfTtcbiAgdmFyIGhhc2hDb3VudGVyID0gMDtcbiAgZnVuY3Rpb24gZ2V0T3duSGFzaE9iamVjdChvYmplY3QpIHtcbiAgICB2YXIgaGFzaE9iamVjdCA9IG9iamVjdFtoYXNoUHJvcGVydHldO1xuICAgIGlmIChoYXNoT2JqZWN0ICYmIGhhc2hPYmplY3Quc2VsZiA9PT0gb2JqZWN0KVxuICAgICAgcmV0dXJuIGhhc2hPYmplY3Q7XG4gICAgaWYgKCRpc0V4dGVuc2libGUob2JqZWN0KSkge1xuICAgICAgaGFzaE9iamVjdFByb3BlcnRpZXMuaGFzaC52YWx1ZSA9IGhhc2hDb3VudGVyKys7XG4gICAgICBoYXNoT2JqZWN0UHJvcGVydGllcy5zZWxmLnZhbHVlID0gb2JqZWN0O1xuICAgICAgaGFzaFByb3BlcnR5RGVzY3JpcHRvci52YWx1ZSA9ICRjcmVhdGUobnVsbCwgaGFzaE9iamVjdFByb3BlcnRpZXMpO1xuICAgICAgJGRlZmluZVByb3BlcnR5KG9iamVjdCwgaGFzaFByb3BlcnR5LCBoYXNoUHJvcGVydHlEZXNjcmlwdG9yKTtcbiAgICAgIHJldHVybiBoYXNoUHJvcGVydHlEZXNjcmlwdG9yLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIGZyZWV6ZShvYmplY3QpIHtcbiAgICBnZXRPd25IYXNoT2JqZWN0KG9iamVjdCk7XG4gICAgcmV0dXJuICRmcmVlemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyhvYmplY3QpIHtcbiAgICBnZXRPd25IYXNoT2JqZWN0KG9iamVjdCk7XG4gICAgcmV0dXJuICRwcmV2ZW50RXh0ZW5zaW9ucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIGZ1bmN0aW9uIHNlYWwob2JqZWN0KSB7XG4gICAgZ2V0T3duSGFzaE9iamVjdChvYmplY3QpO1xuICAgIHJldHVybiAkc2VhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIGZyZWV6ZShTeW1ib2xWYWx1ZS5wcm90b3R5cGUpO1xuICBmdW5jdGlvbiBpc1N5bWJvbFN0cmluZyhzKSB7XG4gICAgcmV0dXJuIHN5bWJvbFZhbHVlc1tzXSB8fCBwcml2YXRlTmFtZXNbc107XG4gIH1cbiAgZnVuY3Rpb24gdG9Qcm9wZXJ0eShuYW1lKSB7XG4gICAgaWYgKGlzU2hpbVN5bWJvbChuYW1lKSlcbiAgICAgIHJldHVybiBuYW1lW3N5bWJvbEludGVybmFsUHJvcGVydHldO1xuICAgIHJldHVybiBuYW1lO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZVN5bWJvbEtleXMoYXJyYXkpIHtcbiAgICB2YXIgcnYgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWlzU3ltYm9sU3RyaW5nKGFycmF5W2ldKSkge1xuICAgICAgICBydi5wdXNoKGFycmF5W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xuICB9XG4gIGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KSB7XG4gICAgcmV0dXJuIHJlbW92ZVN5bWJvbEtleXMoJGdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KSk7XG4gIH1cbiAgZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICByZXR1cm4gcmVtb3ZlU3ltYm9sS2V5cygka2V5cyhvYmplY3QpKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KSB7XG4gICAgdmFyIHJ2ID0gW107XG4gICAgdmFyIG5hbWVzID0gJGdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3ltYm9sID0gc3ltYm9sVmFsdWVzW25hbWVzW2ldXTtcbiAgICAgIGlmIChzeW1ib2wpIHtcbiAgICAgICAgcnYucHVzaChzeW1ib2wpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnY7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgbmFtZSkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgdG9Qcm9wZXJ0eShuYW1lKSk7XG4gIH1cbiAgZnVuY3Rpb24gaGFzT3duUHJvcGVydHkobmFtZSkge1xuICAgIHJldHVybiAkaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCB0b1Byb3BlcnR5KG5hbWUpKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRPcHRpb24obmFtZSkge1xuICAgIHJldHVybiBnbG9iYWwudHJhY2V1ciAmJiBnbG9iYWwudHJhY2V1ci5vcHRpb25zW25hbWVdO1xuICB9XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwgZGVzY3JpcHRvcikge1xuICAgIGlmIChpc1NoaW1TeW1ib2wobmFtZSkpIHtcbiAgICAgIG5hbWUgPSBuYW1lW3N5bWJvbEludGVybmFsUHJvcGVydHldO1xuICAgIH1cbiAgICAkZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBkZXNjcmlwdG9yKTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIGZ1bmN0aW9uIHBvbHlmaWxsT2JqZWN0KE9iamVjdCkge1xuICAgICRkZWZpbmVQcm9wZXJ0eShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScsIHt2YWx1ZTogZGVmaW5lUHJvcGVydHl9KTtcbiAgICAkZGVmaW5lUHJvcGVydHkoT2JqZWN0LCAnZ2V0T3duUHJvcGVydHlOYW1lcycsIHt2YWx1ZTogZ2V0T3duUHJvcGVydHlOYW1lc30pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShPYmplY3QsICdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCB7dmFsdWU6IGdldE93blByb3BlcnR5RGVzY3JpcHRvcn0pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShPYmplY3QucHJvdG90eXBlLCAnaGFzT3duUHJvcGVydHknLCB7dmFsdWU6IGhhc093blByb3BlcnR5fSk7XG4gICAgJGRlZmluZVByb3BlcnR5KE9iamVjdCwgJ2ZyZWV6ZScsIHt2YWx1ZTogZnJlZXplfSk7XG4gICAgJGRlZmluZVByb3BlcnR5KE9iamVjdCwgJ3ByZXZlbnRFeHRlbnNpb25zJywge3ZhbHVlOiBwcmV2ZW50RXh0ZW5zaW9uc30pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShPYmplY3QsICdzZWFsJywge3ZhbHVlOiBzZWFsfSk7XG4gICAgJGRlZmluZVByb3BlcnR5KE9iamVjdCwgJ2tleXMnLCB7dmFsdWU6IGtleXN9KTtcbiAgfVxuICBmdW5jdGlvbiBleHBvcnRTdGFyKG9iamVjdCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZXMgPSAkZ2V0T3duUHJvcGVydHlOYW1lcyhhcmd1bWVudHNbaV0pO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2pdO1xuICAgICAgICBpZiAoaXNTeW1ib2xTdHJpbmcobmFtZSkpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIChmdW5jdGlvbihtb2QsIG5hbWUpIHtcbiAgICAgICAgICAkZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gbW9kW25hbWVdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkoYXJndW1lbnRzW2ldLCBuYW1lc1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICAgIHJldHVybiB4ICE9IG51bGwgJiYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH1cbiAgZnVuY3Rpb24gdG9PYmplY3QoeCkge1xuICAgIGlmICh4ID09IG51bGwpXG4gICAgICB0aHJvdyAkVHlwZUVycm9yKCk7XG4gICAgcmV0dXJuICRPYmplY3QoeCk7XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tPYmplY3RDb2VyY2libGUoYXJndW1lbnQpIHtcbiAgICBpZiAoYXJndW1lbnQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVmFsdWUgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhbiBPYmplY3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3VtZW50O1xuICB9XG4gIGZ1bmN0aW9uIHBvbHlmaWxsU3ltYm9sKGdsb2JhbCwgU3ltYm9sKSB7XG4gICAgaWYgKCFnbG9iYWwuU3ltYm9sKSB7XG4gICAgICBnbG9iYWwuU3ltYm9sID0gU3ltYm9sO1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scztcbiAgICB9XG4gICAgaWYgKCFnbG9iYWwuU3ltYm9sLml0ZXJhdG9yKSB7XG4gICAgICBnbG9iYWwuU3ltYm9sLml0ZXJhdG9yID0gU3ltYm9sKCdTeW1ib2wuaXRlcmF0b3InKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0dXBHbG9iYWxzKGdsb2JhbCkge1xuICAgIHBvbHlmaWxsU3ltYm9sKGdsb2JhbCwgU3ltYm9sKTtcbiAgICBnbG9iYWwuUmVmbGVjdCA9IGdsb2JhbC5SZWZsZWN0IHx8IHt9O1xuICAgIGdsb2JhbC5SZWZsZWN0Lmdsb2JhbCA9IGdsb2JhbC5SZWZsZWN0Lmdsb2JhbCB8fCBnbG9iYWw7XG4gICAgcG9seWZpbGxPYmplY3QoZ2xvYmFsLk9iamVjdCk7XG4gIH1cbiAgc2V0dXBHbG9iYWxzKGdsb2JhbCk7XG4gIGdsb2JhbC4kdHJhY2V1clJ1bnRpbWUgPSB7XG4gICAgY2hlY2tPYmplY3RDb2VyY2libGU6IGNoZWNrT2JqZWN0Q29lcmNpYmxlLFxuICAgIGNyZWF0ZVByaXZhdGVOYW1lOiBjcmVhdGVQcml2YXRlTmFtZSxcbiAgICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAgIGV4cG9ydFN0YXI6IGV4cG9ydFN0YXIsXG4gICAgZ2V0T3duSGFzaE9iamVjdDogZ2V0T3duSGFzaE9iamVjdCxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gICAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgIGlzUHJpdmF0ZU5hbWU6IGlzUHJpdmF0ZU5hbWUsXG4gICAgaXNTeW1ib2xTdHJpbmc6IGlzU3ltYm9sU3RyaW5nLFxuICAgIGtleXM6ICRrZXlzLFxuICAgIHNldHVwR2xvYmFsczogc2V0dXBHbG9iYWxzLFxuICAgIHRvT2JqZWN0OiB0b09iamVjdCxcbiAgICB0b1Byb3BlcnR5OiB0b1Byb3BlcnR5LFxuICAgIHR5cGVvZjogdHlwZU9mXG4gIH07XG59KSh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpO1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBwYXRoO1xuICBmdW5jdGlvbiByZWxhdGl2ZVJlcXVpcmUoY2FsbGVyUGF0aCwgcmVxdWlyZWRQYXRoKSB7XG4gICAgcGF0aCA9IHBhdGggfHwgdHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnICYmIHJlcXVpcmUoJ3BhdGgnKTtcbiAgICBmdW5jdGlvbiBpc0RpcmVjdG9yeShwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5zbGljZSgtMSkgPT09ICcvJztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNBYnNvbHV0ZShwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aFswXSA9PT0gJy8nO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1JlbGF0aXZlKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoWzBdID09PSAnLic7XG4gICAgfVxuICAgIGlmIChpc0RpcmVjdG9yeShyZXF1aXJlZFBhdGgpIHx8IGlzQWJzb2x1dGUocmVxdWlyZWRQYXRoKSlcbiAgICAgIHJldHVybjtcbiAgICByZXR1cm4gaXNSZWxhdGl2ZShyZXF1aXJlZFBhdGgpID8gcmVxdWlyZShwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGNhbGxlclBhdGgpLCByZXF1aXJlZFBhdGgpKSA6IHJlcXVpcmUocmVxdWlyZWRQYXRoKTtcbiAgfVxuICAkdHJhY2V1clJ1bnRpbWUucmVxdWlyZSA9IHJlbGF0aXZlUmVxdWlyZTtcbn0pKCk7XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgZnVuY3Rpb24gc3ByZWFkKCkge1xuICAgIHZhciBydiA9IFtdLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgaXRlclJlc3VsdDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlVG9TcHJlYWQgPSAkdHJhY2V1clJ1bnRpbWUuY2hlY2tPYmplY3RDb2VyY2libGUoYXJndW1lbnRzW2ldKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVUb1NwcmVhZFskdHJhY2V1clJ1bnRpbWUudG9Qcm9wZXJ0eShTeW1ib2wuaXRlcmF0b3IpXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3Qgc3ByZWFkIG5vbi1pdGVyYWJsZSBvYmplY3QuJyk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlciA9IHZhbHVlVG9TcHJlYWRbJHRyYWNldXJSdW50aW1lLnRvUHJvcGVydHkoU3ltYm9sLml0ZXJhdG9yKV0oKTtcbiAgICAgIHdoaWxlICghKGl0ZXJSZXN1bHQgPSBpdGVyLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBydltqKytdID0gaXRlclJlc3VsdC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xuICB9XG4gICR0cmFjZXVyUnVudGltZS5zcHJlYWQgPSBzcHJlYWQ7XG59KSgpO1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciAkT2JqZWN0ID0gT2JqZWN0O1xuICB2YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbiAgdmFyICRjcmVhdGUgPSAkT2JqZWN0LmNyZWF0ZTtcbiAgdmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gJHRyYWNldXJSdW50aW1lLmRlZmluZVByb3BlcnRpZXM7XG4gIHZhciAkZGVmaW5lUHJvcGVydHkgPSAkdHJhY2V1clJ1bnRpbWUuZGVmaW5lUHJvcGVydHk7XG4gIHZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gJHRyYWNldXJSdW50aW1lLmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgdmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gJHRyYWNldXJSdW50aW1lLmdldE93blByb3BlcnR5TmFtZXM7XG4gIHZhciAkZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciAkX18wID0gT2JqZWN0LFxuICAgICAgZ2V0T3duUHJvcGVydHlOYW1lcyA9ICRfXzAuZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgICAgIGdldE93blByb3BlcnR5U3ltYm9scyA9ICRfXzAuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuICBmdW5jdGlvbiBzdXBlckRlc2NyaXB0b3IoaG9tZU9iamVjdCwgbmFtZSkge1xuICAgIHZhciBwcm90byA9ICRnZXRQcm90b3R5cGVPZihob21lT2JqZWN0KTtcbiAgICBkbyB7XG4gICAgICB2YXIgcmVzdWx0ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgbmFtZSk7XG4gICAgICBpZiAocmVzdWx0KVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgcHJvdG8gPSAkZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgIH0gd2hpbGUgKHByb3RvKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIHN1cGVyQ29uc3RydWN0b3IoY3Rvcikge1xuICAgIHJldHVybiBjdG9yLl9fcHJvdG9fXztcbiAgfVxuICBmdW5jdGlvbiBzdXBlckNhbGwoc2VsZiwgaG9tZU9iamVjdCwgbmFtZSwgYXJncykge1xuICAgIHJldHVybiBzdXBlckdldChzZWxmLCBob21lT2JqZWN0LCBuYW1lKS5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuICBmdW5jdGlvbiBzdXBlckdldChzZWxmLCBob21lT2JqZWN0LCBuYW1lKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBzdXBlckRlc2NyaXB0b3IoaG9tZU9iamVjdCwgbmFtZSk7XG4gICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgIGlmICghZGVzY3JpcHRvci5nZXQpXG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwoc2VsZik7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgZnVuY3Rpb24gc3VwZXJTZXQoc2VsZiwgaG9tZU9iamVjdCwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHN1cGVyRGVzY3JpcHRvcihob21lT2JqZWN0LCBuYW1lKTtcbiAgICBpZiAoZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnNldCkge1xuICAgICAgZGVzY3JpcHRvci5zZXQuY2FsbChzZWxmLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHRocm93ICRUeXBlRXJyb3IoKFwic3VwZXIgaGFzIG5vIHNldHRlciAnXCIgKyBuYW1lICsgXCInLlwiKSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RGVzY3JpcHRvcnMob2JqZWN0KSB7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0ge307XG4gICAgdmFyIG5hbWVzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICBkZXNjcmlwdG9yc1tuYW1lXSA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBuYW1lKTtcbiAgICB9XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzeW1ib2wgPSBzeW1ib2xzW2ldO1xuICAgICAgZGVzY3JpcHRvcnNbJHRyYWNldXJSdW50aW1lLnRvUHJvcGVydHkoc3ltYm9sKV0gPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgJHRyYWNldXJSdW50aW1lLnRvUHJvcGVydHkoc3ltYm9sKSk7XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVDbGFzcyhjdG9yLCBvYmplY3QsIHN0YXRpY09iamVjdCwgc3VwZXJDbGFzcykge1xuICAgICRkZWZpbmVQcm9wZXJ0eShvYmplY3QsICdjb25zdHJ1Y3RvcicsIHtcbiAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMykge1xuICAgICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzID09PSAnZnVuY3Rpb24nKVxuICAgICAgICBjdG9yLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9ICRjcmVhdGUoZ2V0UHJvdG9QYXJlbnQoc3VwZXJDbGFzcyksIGdldERlc2NyaXB0b3JzKG9iamVjdCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG9iamVjdDtcbiAgICB9XG4gICAgJGRlZmluZVByb3BlcnR5KGN0b3IsICdwcm90b3R5cGUnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuICRkZWZpbmVQcm9wZXJ0aWVzKGN0b3IsIGdldERlc2NyaXB0b3JzKHN0YXRpY09iamVjdCkpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFByb3RvUGFyZW50KHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBwcm90b3R5cGUgPSBzdXBlckNsYXNzLnByb3RvdHlwZTtcbiAgICAgIGlmICgkT2JqZWN0KHByb3RvdHlwZSkgPT09IHByb3RvdHlwZSB8fCBwcm90b3R5cGUgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBzdXBlckNsYXNzLnByb3RvdHlwZTtcbiAgICAgIHRocm93IG5ldyAkVHlwZUVycm9yKCdzdXBlciBwcm90b3R5cGUgbXVzdCBiZSBhbiBPYmplY3Qgb3IgbnVsbCcpO1xuICAgIH1cbiAgICBpZiAoc3VwZXJDbGFzcyA9PT0gbnVsbClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHRocm93IG5ldyAkVHlwZUVycm9yKChcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyArIFwiLlwiKSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVmYXVsdFN1cGVyQ2FsbChzZWxmLCBob21lT2JqZWN0LCBhcmdzKSB7XG4gICAgaWYgKCRnZXRQcm90b3R5cGVPZihob21lT2JqZWN0KSAhPT0gbnVsbClcbiAgICAgIHN1cGVyQ2FsbChzZWxmLCBob21lT2JqZWN0LCAnY29uc3RydWN0b3InLCBhcmdzKTtcbiAgfVxuICAkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MgPSBjcmVhdGVDbGFzcztcbiAgJHRyYWNldXJSdW50aW1lLmRlZmF1bHRTdXBlckNhbGwgPSBkZWZhdWx0U3VwZXJDYWxsO1xuICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDYWxsID0gc3VwZXJDYWxsO1xuICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvciA9IHN1cGVyQ29uc3RydWN0b3I7XG4gICR0cmFjZXVyUnVudGltZS5zdXBlckdldCA9IHN1cGVyR2V0O1xuICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJTZXQgPSBzdXBlclNldDtcbn0pKCk7XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgaWYgKHR5cGVvZiAkdHJhY2V1clJ1bnRpbWUgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0cmFjZXVyIHJ1bnRpbWUgbm90IGZvdW5kLicpO1xuICB9XG4gIHZhciBjcmVhdGVQcml2YXRlTmFtZSA9ICR0cmFjZXVyUnVudGltZS5jcmVhdGVQcml2YXRlTmFtZTtcbiAgdmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gJHRyYWNldXJSdW50aW1lLmRlZmluZVByb3BlcnRpZXM7XG4gIHZhciAkZGVmaW5lUHJvcGVydHkgPSAkdHJhY2V1clJ1bnRpbWUuZGVmaW5lUHJvcGVydHk7XG4gIHZhciAkY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbiAgdmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gIGZ1bmN0aW9uIG5vbkVudW0odmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH07XG4gIH1cbiAgdmFyIFNUX05FV0JPUk4gPSAwO1xuICB2YXIgU1RfRVhFQ1VUSU5HID0gMTtcbiAgdmFyIFNUX1NVU1BFTkRFRCA9IDI7XG4gIHZhciBTVF9DTE9TRUQgPSAzO1xuICB2YXIgRU5EX1NUQVRFID0gLTI7XG4gIHZhciBSRVRIUk9XX1NUQVRFID0gLTM7XG4gIGZ1bmN0aW9uIGdldEludGVybmFsRXJyb3Ioc3RhdGUpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdUcmFjZXVyIGNvbXBpbGVyIGJ1ZzogaW52YWxpZCBzdGF0ZSBpbiBzdGF0ZSBtYWNoaW5lOiAnICsgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckNvbnRleHQoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IDA7XG4gICAgdGhpcy5HU3RhdGUgPSBTVF9ORVdCT1JOO1xuICAgIHRoaXMuc3RvcmVkRXhjZXB0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZmluYWxseUZhbGxUaHJvdWdoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2VudF8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yZXR1cm5WYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRyeVN0YWNrXyA9IFtdO1xuICB9XG4gIEdlbmVyYXRvckNvbnRleHQucHJvdG90eXBlID0ge1xuICAgIHB1c2hUcnk6IGZ1bmN0aW9uKGNhdGNoU3RhdGUsIGZpbmFsbHlTdGF0ZSkge1xuICAgICAgaWYgKGZpbmFsbHlTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZmluYWxseUZhbGxUaHJvdWdoID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5U3RhY2tfLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKHRoaXMudHJ5U3RhY2tfW2ldLmNhdGNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZpbmFsbHlGYWxsVGhyb3VnaCA9IHRoaXMudHJ5U3RhY2tfW2ldLmNhdGNoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5hbGx5RmFsbFRocm91Z2ggPT09IG51bGwpXG4gICAgICAgICAgZmluYWxseUZhbGxUaHJvdWdoID0gUkVUSFJPV19TVEFURTtcbiAgICAgICAgdGhpcy50cnlTdGFja18ucHVzaCh7XG4gICAgICAgICAgZmluYWxseTogZmluYWxseVN0YXRlLFxuICAgICAgICAgIGZpbmFsbHlGYWxsVGhyb3VnaDogZmluYWxseUZhbGxUaHJvdWdoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGNhdGNoU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy50cnlTdGFja18ucHVzaCh7Y2F0Y2g6IGNhdGNoU3RhdGV9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBvcFRyeTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRyeVN0YWNrXy5wb3AoKTtcbiAgICB9LFxuICAgIGdldCBzZW50KCkge1xuICAgICAgdGhpcy5tYXliZVRocm93KCk7XG4gICAgICByZXR1cm4gdGhpcy5zZW50XztcbiAgICB9LFxuICAgIHNldCBzZW50KHYpIHtcbiAgICAgIHRoaXMuc2VudF8gPSB2O1xuICAgIH0sXG4gICAgZ2V0IHNlbnRJZ25vcmVUaHJvdygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbnRfO1xuICAgIH0sXG4gICAgbWF5YmVUaHJvdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5hY3Rpb24gPT09ICd0aHJvdycpIHtcbiAgICAgICAgdGhpcy5hY3Rpb24gPSAnbmV4dCc7XG4gICAgICAgIHRocm93IHRoaXMuc2VudF87XG4gICAgICB9XG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgRU5EX1NUQVRFOlxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBjYXNlIFJFVEhST1dfU1RBVEU6XG4gICAgICAgICAgdGhyb3cgdGhpcy5zdG9yZWRFeGNlcHRpb247XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxFcnJvcih0aGlzLnN0YXRlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZUV4Y2VwdGlvbjogZnVuY3Rpb24oZXgpIHtcbiAgICAgIHRoaXMuR1N0YXRlID0gU1RfQ0xPU0VEO1xuICAgICAgdGhpcy5zdGF0ZSA9IEVORF9TVEFURTtcbiAgICAgIHRocm93IGV4O1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gbmV4dE9yVGhyb3coY3R4LCBtb3ZlTmV4dCwgYWN0aW9uLCB4KSB7XG4gICAgc3dpdGNoIChjdHguR1N0YXRlKSB7XG4gICAgICBjYXNlIFNUX0VYRUNVVElORzpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIlxcXCJcIiArIGFjdGlvbiArIFwiXFxcIiBvbiBleGVjdXRpbmcgZ2VuZXJhdG9yXCIpKTtcbiAgICAgIGNhc2UgU1RfQ0xPU0VEOlxuICAgICAgICBpZiAoYWN0aW9uID09ICduZXh0Jykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgeDtcbiAgICAgIGNhc2UgU1RfTkVXQk9STjpcbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3Rocm93Jykge1xuICAgICAgICAgIGN0eC5HU3RhdGUgPSBTVF9DTE9TRUQ7XG4gICAgICAgICAgdGhyb3cgeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRocm93ICRUeXBlRXJyb3IoJ1NlbnQgdmFsdWUgdG8gbmV3Ym9ybiBnZW5lcmF0b3InKTtcbiAgICAgIGNhc2UgU1RfU1VTUEVOREVEOlxuICAgICAgICBjdHguR1N0YXRlID0gU1RfRVhFQ1VUSU5HO1xuICAgICAgICBjdHguYWN0aW9uID0gYWN0aW9uO1xuICAgICAgICBjdHguc2VudCA9IHg7XG4gICAgICAgIHZhciB2YWx1ZSA9IG1vdmVOZXh0KGN0eCk7XG4gICAgICAgIHZhciBkb25lID0gdmFsdWUgPT09IGN0eDtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgdmFsdWUgPSBjdHgucmV0dXJuVmFsdWU7XG4gICAgICAgIGN0eC5HU3RhdGUgPSBkb25lID8gU1RfQ0xPU0VEIDogU1RfU1VTUEVOREVEO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBkb25lOiBkb25lXG4gICAgICAgIH07XG4gICAgfVxuICB9XG4gIHZhciBjdHhOYW1lID0gY3JlYXRlUHJpdmF0ZU5hbWUoKTtcbiAgdmFyIG1vdmVOZXh0TmFtZSA9IGNyZWF0ZVByaXZhdGVOYW1lKCk7XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgJGRlZmluZVByb3BlcnR5KEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCAnY29uc3RydWN0b3InLCBub25FbnVtKEdlbmVyYXRvckZ1bmN0aW9uKSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgbmV4dDogZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIG5leHRPclRocm93KHRoaXNbY3R4TmFtZV0sIHRoaXNbbW92ZU5leHROYW1lXSwgJ25leHQnLCB2KTtcbiAgICB9LFxuICAgIHRocm93OiBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gbmV4dE9yVGhyb3codGhpc1tjdHhOYW1lXSwgdGhpc1ttb3ZlTmV4dE5hbWVdLCAndGhyb3cnLCB2KTtcbiAgICB9XG4gIH07XG4gICRkZWZpbmVQcm9wZXJ0aWVzKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7ZW51bWVyYWJsZTogZmFsc2V9LFxuICAgIG5leHQ6IHtlbnVtZXJhYmxlOiBmYWxzZX0sXG4gICAgdGhyb3c6IHtlbnVtZXJhYmxlOiBmYWxzZX1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUsIFN5bWJvbC5pdGVyYXRvciwgbm9uRW51bShmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSkpO1xuICBmdW5jdGlvbiBjcmVhdGVHZW5lcmF0b3JJbnN0YW5jZShpbm5lckZ1bmN0aW9uLCBmdW5jdGlvbk9iamVjdCwgc2VsZikge1xuICAgIHZhciBtb3ZlTmV4dCA9IGdldE1vdmVOZXh0KGlubmVyRnVuY3Rpb24sIHNlbGYpO1xuICAgIHZhciBjdHggPSBuZXcgR2VuZXJhdG9yQ29udGV4dCgpO1xuICAgIHZhciBvYmplY3QgPSAkY3JlYXRlKGZ1bmN0aW9uT2JqZWN0LnByb3RvdHlwZSk7XG4gICAgb2JqZWN0W2N0eE5hbWVdID0gY3R4O1xuICAgIG9iamVjdFttb3ZlTmV4dE5hbWVdID0gbW92ZU5leHQ7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBmdW5jdGlvbiBpbml0R2VuZXJhdG9yRnVuY3Rpb24oZnVuY3Rpb25PYmplY3QpIHtcbiAgICBmdW5jdGlvbk9iamVjdC5wcm90b3R5cGUgPSAkY3JlYXRlKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSk7XG4gICAgZnVuY3Rpb25PYmplY3QuX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uT2JqZWN0O1xuICB9XG4gIGZ1bmN0aW9uIEFzeW5jRnVuY3Rpb25Db250ZXh0KCkge1xuICAgIEdlbmVyYXRvckNvbnRleHQuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmVyciA9IHVuZGVmaW5lZDtcbiAgICB2YXIgY3R4ID0gdGhpcztcbiAgICBjdHgucmVzdWx0ID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBjdHgucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBjdHgucmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICB9XG4gIEFzeW5jRnVuY3Rpb25Db250ZXh0LnByb3RvdHlwZSA9ICRjcmVhdGUoR2VuZXJhdG9yQ29udGV4dC5wcm90b3R5cGUpO1xuICBBc3luY0Z1bmN0aW9uQ29udGV4dC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIEVORF9TVEFURTpcbiAgICAgICAgdGhpcy5yZXNvbHZlKHRoaXMucmV0dXJuVmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUkVUSFJPV19TVEFURTpcbiAgICAgICAgdGhpcy5yZWplY3QodGhpcy5zdG9yZWRFeGNlcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMucmVqZWN0KGdldEludGVybmFsRXJyb3IodGhpcy5zdGF0ZSkpO1xuICAgIH1cbiAgfTtcbiAgQXN5bmNGdW5jdGlvbkNvbnRleHQucHJvdG90eXBlLmhhbmRsZUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3RhdGUgPSBSRVRIUk9XX1NUQVRFO1xuICB9O1xuICBmdW5jdGlvbiBhc3luY1dyYXAoaW5uZXJGdW5jdGlvbiwgc2VsZikge1xuICAgIHZhciBtb3ZlTmV4dCA9IGdldE1vdmVOZXh0KGlubmVyRnVuY3Rpb24sIHNlbGYpO1xuICAgIHZhciBjdHggPSBuZXcgQXN5bmNGdW5jdGlvbkNvbnRleHQoKTtcbiAgICBjdHguY3JlYXRlQ2FsbGJhY2sgPSBmdW5jdGlvbihuZXdTdGF0ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGN0eC5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBjdHgudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgbW92ZU5leHQoY3R4KTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjdHguZXJyYmFjayA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgaGFuZGxlQ2F0Y2goY3R4LCBlcnIpO1xuICAgICAgbW92ZU5leHQoY3R4KTtcbiAgICB9O1xuICAgIG1vdmVOZXh0KGN0eCk7XG4gICAgcmV0dXJuIGN0eC5yZXN1bHQ7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TW92ZU5leHQoaW5uZXJGdW5jdGlvbiwgc2VsZikge1xuICAgIHJldHVybiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGlubmVyRnVuY3Rpb24uY2FsbChzZWxmLCBjdHgpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGhhbmRsZUNhdGNoKGN0eCwgZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVDYXRjaChjdHgsIGV4KSB7XG4gICAgY3R4LnN0b3JlZEV4Y2VwdGlvbiA9IGV4O1xuICAgIHZhciBsYXN0ID0gY3R4LnRyeVN0YWNrX1tjdHgudHJ5U3RhY2tfLmxlbmd0aCAtIDFdO1xuICAgIGlmICghbGFzdCkge1xuICAgICAgY3R4LmhhbmRsZUV4Y2VwdGlvbihleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5zdGF0ZSA9IGxhc3QuY2F0Y2ggIT09IHVuZGVmaW5lZCA/IGxhc3QuY2F0Y2ggOiBsYXN0LmZpbmFsbHk7XG4gICAgaWYgKGxhc3QuZmluYWxseUZhbGxUaHJvdWdoICE9PSB1bmRlZmluZWQpXG4gICAgICBjdHguZmluYWxseUZhbGxUaHJvdWdoID0gbGFzdC5maW5hbGx5RmFsbFRocm91Z2g7XG4gIH1cbiAgJHRyYWNldXJSdW50aW1lLmFzeW5jV3JhcCA9IGFzeW5jV3JhcDtcbiAgJHRyYWNldXJSdW50aW1lLmluaXRHZW5lcmF0b3JGdW5jdGlvbiA9IGluaXRHZW5lcmF0b3JGdW5jdGlvbjtcbiAgJHRyYWNldXJSdW50aW1lLmNyZWF0ZUdlbmVyYXRvckluc3RhbmNlID0gY3JlYXRlR2VuZXJhdG9ySW5zdGFuY2U7XG59KSgpO1xuKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBidWlsZEZyb21FbmNvZGVkUGFydHMob3B0X3NjaGVtZSwgb3B0X3VzZXJJbmZvLCBvcHRfZG9tYWluLCBvcHRfcG9ydCwgb3B0X3BhdGgsIG9wdF9xdWVyeURhdGEsIG9wdF9mcmFnbWVudCkge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBpZiAob3B0X3NjaGVtZSkge1xuICAgICAgb3V0LnB1c2gob3B0X3NjaGVtZSwgJzonKTtcbiAgICB9XG4gICAgaWYgKG9wdF9kb21haW4pIHtcbiAgICAgIG91dC5wdXNoKCcvLycpO1xuICAgICAgaWYgKG9wdF91c2VySW5mbykge1xuICAgICAgICBvdXQucHVzaChvcHRfdXNlckluZm8sICdAJyk7XG4gICAgICB9XG4gICAgICBvdXQucHVzaChvcHRfZG9tYWluKTtcbiAgICAgIGlmIChvcHRfcG9ydCkge1xuICAgICAgICBvdXQucHVzaCgnOicsIG9wdF9wb3J0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdF9wYXRoKSB7XG4gICAgICBvdXQucHVzaChvcHRfcGF0aCk7XG4gICAgfVxuICAgIGlmIChvcHRfcXVlcnlEYXRhKSB7XG4gICAgICBvdXQucHVzaCgnPycsIG9wdF9xdWVyeURhdGEpO1xuICAgIH1cbiAgICBpZiAob3B0X2ZyYWdtZW50KSB7XG4gICAgICBvdXQucHVzaCgnIycsIG9wdF9mcmFnbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBvdXQuam9pbignJyk7XG4gIH1cbiAgO1xuICB2YXIgc3BsaXRSZSA9IG5ldyBSZWdFeHAoJ14nICsgJyg/OicgKyAnKFteOi8/Iy5dKyknICsgJzopPycgKyAnKD86Ly8nICsgJyg/OihbXi8/I10qKUApPycgKyAnKFtcXFxcd1xcXFxkXFxcXC1cXFxcdTAxMDAtXFxcXHVmZmZmLiVdKiknICsgJyg/OjooWzAtOV0rKSk/JyArICcpPycgKyAnKFtePyNdKyk/JyArICcoPzpcXFxcPyhbXiNdKikpPycgKyAnKD86IyguKikpPycgKyAnJCcpO1xuICB2YXIgQ29tcG9uZW50SW5kZXggPSB7XG4gICAgU0NIRU1FOiAxLFxuICAgIFVTRVJfSU5GTzogMixcbiAgICBET01BSU46IDMsXG4gICAgUE9SVDogNCxcbiAgICBQQVRIOiA1LFxuICAgIFFVRVJZX0RBVEE6IDYsXG4gICAgRlJBR01FTlQ6IDdcbiAgfTtcbiAgZnVuY3Rpb24gc3BsaXQodXJpKSB7XG4gICAgcmV0dXJuICh1cmkubWF0Y2goc3BsaXRSZSkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzKHBhdGgpIHtcbiAgICBpZiAocGF0aCA9PT0gJy8nKVxuICAgICAgcmV0dXJuICcvJztcbiAgICB2YXIgbGVhZGluZ1NsYXNoID0gcGF0aFswXSA9PT0gJy8nID8gJy8nIDogJyc7XG4gICAgdmFyIHRyYWlsaW5nU2xhc2ggPSBwYXRoLnNsaWNlKC0xKSA9PT0gJy8nID8gJy8nIDogJyc7XG4gICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICB2YXIgdXAgPSAwO1xuICAgIGZvciAodmFyIHBvcyA9IDA7IHBvcyA8IHNlZ21lbnRzLmxlbmd0aDsgcG9zKyspIHtcbiAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbcG9zXTtcbiAgICAgIHN3aXRjaCAoc2VnbWVudCkge1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnLi4nOlxuICAgICAgICAgIGlmIChvdXQubGVuZ3RoKVxuICAgICAgICAgICAgb3V0LnBvcCgpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHVwKys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgb3V0LnB1c2goc2VnbWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbGVhZGluZ1NsYXNoKSB7XG4gICAgICB3aGlsZSAodXAtLSA+IDApIHtcbiAgICAgICAgb3V0LnVuc2hpZnQoJy4uJyk7XG4gICAgICB9XG4gICAgICBpZiAob3V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgb3V0LnB1c2goJy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlYWRpbmdTbGFzaCArIG91dC5qb2luKCcvJykgKyB0cmFpbGluZ1NsYXNoO1xuICB9XG4gIGZ1bmN0aW9uIGpvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKSB7XG4gICAgdmFyIHBhdGggPSBwYXJ0c1tDb21wb25lbnRJbmRleC5QQVRIXSB8fCAnJztcbiAgICBwYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocGF0aCk7XG4gICAgcGFydHNbQ29tcG9uZW50SW5kZXguUEFUSF0gPSBwYXRoO1xuICAgIHJldHVybiBidWlsZEZyb21FbmNvZGVkUGFydHMocGFydHNbQ29tcG9uZW50SW5kZXguU0NIRU1FXSwgcGFydHNbQ29tcG9uZW50SW5kZXguVVNFUl9JTkZPXSwgcGFydHNbQ29tcG9uZW50SW5kZXguRE9NQUlOXSwgcGFydHNbQ29tcG9uZW50SW5kZXguUE9SVF0sIHBhcnRzW0NvbXBvbmVudEluZGV4LlBBVEhdLCBwYXJ0c1tDb21wb25lbnRJbmRleC5RVUVSWV9EQVRBXSwgcGFydHNbQ29tcG9uZW50SW5kZXguRlJBR01FTlRdKTtcbiAgfVxuICBmdW5jdGlvbiBjYW5vbmljYWxpemVVcmwodXJsKSB7XG4gICAgdmFyIHBhcnRzID0gc3BsaXQodXJsKTtcbiAgICByZXR1cm4gam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc29sdmVVcmwoYmFzZSwgdXJsKSB7XG4gICAgdmFyIHBhcnRzID0gc3BsaXQodXJsKTtcbiAgICB2YXIgYmFzZVBhcnRzID0gc3BsaXQoYmFzZSk7XG4gICAgaWYgKHBhcnRzW0NvbXBvbmVudEluZGV4LlNDSEVNRV0pIHtcbiAgICAgIHJldHVybiBqb2luQW5kQ2Fub25pY2FsaXplUGF0aChwYXJ0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRzW0NvbXBvbmVudEluZGV4LlNDSEVNRV0gPSBiYXNlUGFydHNbQ29tcG9uZW50SW5kZXguU0NIRU1FXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IENvbXBvbmVudEluZGV4LlNDSEVNRTsgaSA8PSBDb21wb25lbnRJbmRleC5QT1JUOyBpKyspIHtcbiAgICAgIGlmICghcGFydHNbaV0pIHtcbiAgICAgICAgcGFydHNbaV0gPSBiYXNlUGFydHNbaV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJ0c1tDb21wb25lbnRJbmRleC5QQVRIXVswXSA9PSAnLycpIHtcbiAgICAgIHJldHVybiBqb2luQW5kQ2Fub25pY2FsaXplUGF0aChwYXJ0cyk7XG4gICAgfVxuICAgIHZhciBwYXRoID0gYmFzZVBhcnRzW0NvbXBvbmVudEluZGV4LlBBVEhdO1xuICAgIHZhciBpbmRleCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBpbmRleCArIDEpICsgcGFydHNbQ29tcG9uZW50SW5kZXguUEFUSF07XG4gICAgcGFydHNbQ29tcG9uZW50SW5kZXguUEFUSF0gPSBwYXRoO1xuICAgIHJldHVybiBqb2luQW5kQ2Fub25pY2FsaXplUGF0aChwYXJ0cyk7XG4gIH1cbiAgZnVuY3Rpb24gaXNBYnNvbHV0ZShuYW1lKSB7XG4gICAgaWYgKCFuYW1lKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChuYW1lWzBdID09PSAnLycpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgcGFydHMgPSBzcGxpdChuYW1lKTtcbiAgICBpZiAocGFydHNbQ29tcG9uZW50SW5kZXguU0NIRU1FXSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAkdHJhY2V1clJ1bnRpbWUuY2Fub25pY2FsaXplVXJsID0gY2Fub25pY2FsaXplVXJsO1xuICAkdHJhY2V1clJ1bnRpbWUuaXNBYnNvbHV0ZSA9IGlzQWJzb2x1dGU7XG4gICR0cmFjZXVyUnVudGltZS5yZW1vdmVEb3RTZWdtZW50cyA9IHJlbW92ZURvdFNlZ21lbnRzO1xuICAkdHJhY2V1clJ1bnRpbWUucmVzb2x2ZVVybCA9IHJlc29sdmVVcmw7XG59KSgpO1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciB0eXBlcyA9IHtcbiAgICBhbnk6IHtuYW1lOiAnYW55J30sXG4gICAgYm9vbGVhbjoge25hbWU6ICdib29sZWFuJ30sXG4gICAgbnVtYmVyOiB7bmFtZTogJ251bWJlcid9LFxuICAgIHN0cmluZzoge25hbWU6ICdzdHJpbmcnfSxcbiAgICBzeW1ib2w6IHtuYW1lOiAnc3ltYm9sJ30sXG4gICAgdm9pZDoge25hbWU6ICd2b2lkJ31cbiAgfTtcbiAgdmFyIEdlbmVyaWNUeXBlID0gZnVuY3Rpb24gR2VuZXJpY1R5cGUodHlwZSwgYXJndW1lbnRUeXBlcykge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hcmd1bWVudFR5cGVzID0gYXJndW1lbnRUeXBlcztcbiAgfTtcbiAgKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoR2VuZXJpY1R5cGUsIHt9LCB7fSk7XG4gIHZhciB0eXBlUmVnaXN0ZXIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmdW5jdGlvbiBnZW5lcmljVHlwZSh0eXBlKSB7XG4gICAgZm9yICh2YXIgYXJndW1lbnRUeXBlcyA9IFtdLFxuICAgICAgICAkX18xID0gMTsgJF9fMSA8IGFyZ3VtZW50cy5sZW5ndGg7ICRfXzErKylcbiAgICAgIGFyZ3VtZW50VHlwZXNbJF9fMSAtIDFdID0gYXJndW1lbnRzWyRfXzFdO1xuICAgIHZhciB0eXBlTWFwID0gdHlwZVJlZ2lzdGVyO1xuICAgIHZhciBrZXkgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0T3duSGFzaE9iamVjdCh0eXBlKS5oYXNoO1xuICAgIGlmICghdHlwZU1hcFtrZXldKSB7XG4gICAgICB0eXBlTWFwW2tleV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICB0eXBlTWFwID0gdHlwZU1hcFtrZXldO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRUeXBlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGtleSA9ICR0cmFjZXVyUnVudGltZS5nZXRPd25IYXNoT2JqZWN0KGFyZ3VtZW50VHlwZXNbaV0pLmhhc2g7XG4gICAgICBpZiAoIXR5cGVNYXBba2V5XSkge1xuICAgICAgICB0eXBlTWFwW2tleV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfVxuICAgICAgdHlwZU1hcCA9IHR5cGVNYXBba2V5XTtcbiAgICB9XG4gICAgdmFyIHRhaWwgPSBhcmd1bWVudFR5cGVzW2FyZ3VtZW50VHlwZXMubGVuZ3RoIC0gMV07XG4gICAga2V5ID0gJHRyYWNldXJSdW50aW1lLmdldE93bkhhc2hPYmplY3QodGFpbCkuaGFzaDtcbiAgICBpZiAoIXR5cGVNYXBba2V5XSkge1xuICAgICAgdHlwZU1hcFtrZXldID0gbmV3IEdlbmVyaWNUeXBlKHR5cGUsIGFyZ3VtZW50VHlwZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZU1hcFtrZXldO1xuICB9XG4gICR0cmFjZXVyUnVudGltZS5HZW5lcmljVHlwZSA9IEdlbmVyaWNUeXBlO1xuICAkdHJhY2V1clJ1bnRpbWUuZ2VuZXJpY1R5cGUgPSBnZW5lcmljVHlwZTtcbiAgJHRyYWNldXJSdW50aW1lLnR5cGUgPSB0eXBlcztcbn0pKCk7XG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyICRfXzIgPSAkdHJhY2V1clJ1bnRpbWUsXG4gICAgICBjYW5vbmljYWxpemVVcmwgPSAkX18yLmNhbm9uaWNhbGl6ZVVybCxcbiAgICAgIHJlc29sdmVVcmwgPSAkX18yLnJlc29sdmVVcmwsXG4gICAgICBpc0Fic29sdXRlID0gJF9fMi5pc0Fic29sdXRlO1xuICB2YXIgbW9kdWxlSW5zdGFudGlhdG9ycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBiYXNlVVJMO1xuICBpZiAoZ2xvYmFsLmxvY2F0aW9uICYmIGdsb2JhbC5sb2NhdGlvbi5ocmVmKVxuICAgIGJhc2VVUkwgPSByZXNvbHZlVXJsKGdsb2JhbC5sb2NhdGlvbi5ocmVmLCAnLi8nKTtcbiAgZWxzZVxuICAgIGJhc2VVUkwgPSAnJztcbiAgdmFyIFVuY29hdGVkTW9kdWxlRW50cnkgPSBmdW5jdGlvbiBVbmNvYXRlZE1vZHVsZUVudHJ5KHVybCwgdW5jb2F0ZWRNb2R1bGUpIHtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnZhbHVlXyA9IHVuY29hdGVkTW9kdWxlO1xuICB9O1xuICAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShVbmNvYXRlZE1vZHVsZUVudHJ5LCB7fSwge30pO1xuICB2YXIgTW9kdWxlRXZhbHVhdGlvbkVycm9yID0gZnVuY3Rpb24gTW9kdWxlRXZhbHVhdGlvbkVycm9yKGVycm9uZW91c01vZHVsZU5hbWUsIGNhdXNlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJzogJyArIHRoaXMuc3RyaXBDYXVzZShjYXVzZSkgKyAnIGluICcgKyBlcnJvbmVvdXNNb2R1bGVOYW1lO1xuICAgIGlmICghKGNhdXNlIGluc3RhbmNlb2YgJE1vZHVsZUV2YWx1YXRpb25FcnJvcikgJiYgY2F1c2Uuc3RhY2spXG4gICAgICB0aGlzLnN0YWNrID0gdGhpcy5zdHJpcFN0YWNrKGNhdXNlLnN0YWNrKTtcbiAgICBlbHNlXG4gICAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH07XG4gIHZhciAkTW9kdWxlRXZhbHVhdGlvbkVycm9yID0gTW9kdWxlRXZhbHVhdGlvbkVycm9yO1xuICAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShNb2R1bGVFdmFsdWF0aW9uRXJyb3IsIHtcbiAgICBzdHJpcEVycm9yOiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZS5yZXBsYWNlKC8uKkVycm9yOi8sIHRoaXMuY29uc3RydWN0b3IubmFtZSArICc6Jyk7XG4gICAgfSxcbiAgICBzdHJpcENhdXNlOiBmdW5jdGlvbihjYXVzZSkge1xuICAgICAgaWYgKCFjYXVzZSlcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgaWYgKCFjYXVzZS5tZXNzYWdlKVxuICAgICAgICByZXR1cm4gY2F1c2UgKyAnJztcbiAgICAgIHJldHVybiB0aGlzLnN0cmlwRXJyb3IoY2F1c2UubWVzc2FnZSk7XG4gICAgfSxcbiAgICBsb2FkZWRCeTogZnVuY3Rpb24obW9kdWxlTmFtZSkge1xuICAgICAgdGhpcy5zdGFjayArPSAnXFxuIGxvYWRlZCBieSAnICsgbW9kdWxlTmFtZTtcbiAgICB9LFxuICAgIHN0cmlwU3RhY2s6IGZ1bmN0aW9uKGNhdXNlU3RhY2spIHtcbiAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgY2F1c2VTdGFjay5zcGxpdCgnXFxuJykuc29tZSgoZnVuY3Rpb24oZnJhbWUpIHtcbiAgICAgICAgaWYgKC9VbmNvYXRlZE1vZHVsZUluc3RhbnRpYXRvci8udGVzdChmcmFtZSkpXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHN0YWNrLnB1c2goZnJhbWUpO1xuICAgICAgfSkpO1xuICAgICAgc3RhY2tbMF0gPSB0aGlzLnN0cmlwRXJyb3Ioc3RhY2tbMF0pO1xuICAgICAgcmV0dXJuIHN0YWNrLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgfSwge30sIEVycm9yKTtcbiAgZnVuY3Rpb24gYmVmb3JlTGluZXMobGluZXMsIG51bWJlcikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgZmlyc3QgPSBudW1iZXIgLSAzO1xuICAgIGlmIChmaXJzdCA8IDApXG4gICAgICBmaXJzdCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IGZpcnN0OyBpIDwgbnVtYmVyOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKGxpbmVzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBhZnRlckxpbmVzKGxpbmVzLCBudW1iZXIpIHtcbiAgICB2YXIgbGFzdCA9IG51bWJlciArIDE7XG4gICAgaWYgKGxhc3QgPiBsaW5lcy5sZW5ndGggLSAxKVxuICAgICAgbGFzdCA9IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSBudW1iZXI7IGkgPD0gbGFzdDsgaSsrKSB7XG4gICAgICByZXN1bHQucHVzaChsaW5lc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZnVuY3Rpb24gY29sdW1uU3BhY2luZyhjb2x1bW5zKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1ucyAtIDE7IGkrKykge1xuICAgICAgcmVzdWx0ICs9ICctJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YXIgVW5jb2F0ZWRNb2R1bGVJbnN0YW50aWF0b3IgPSBmdW5jdGlvbiBVbmNvYXRlZE1vZHVsZUluc3RhbnRpYXRvcih1cmwsIGZ1bmMpIHtcbiAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcigkVW5jb2F0ZWRNb2R1bGVJbnN0YW50aWF0b3IpLmNhbGwodGhpcywgdXJsLCBudWxsKTtcbiAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICB9O1xuICB2YXIgJFVuY29hdGVkTW9kdWxlSW5zdGFudGlhdG9yID0gVW5jb2F0ZWRNb2R1bGVJbnN0YW50aWF0b3I7XG4gICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFVuY29hdGVkTW9kdWxlSW5zdGFudGlhdG9yLCB7Z2V0VW5jb2F0ZWRNb2R1bGU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMudmFsdWVfKVxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZV87XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVsYXRpdmVSZXF1aXJlO1xuICAgICAgICBpZiAodHlwZW9mICR0cmFjZXVyUnVudGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVsYXRpdmVSZXF1aXJlID0gJHRyYWNldXJSdW50aW1lLnJlcXVpcmUuYmluZChudWxsLCB0aGlzLnVybCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVfID0gdGhpcy5mdW5jLmNhbGwoZ2xvYmFsLCByZWxhdGl2ZVJlcXVpcmUpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgaWYgKGV4IGluc3RhbmNlb2YgTW9kdWxlRXZhbHVhdGlvbkVycm9yKSB7XG4gICAgICAgICAgZXgubG9hZGVkQnkodGhpcy51cmwpO1xuICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChleC5zdGFjaykge1xuICAgICAgICAgIHZhciBsaW5lcyA9IHRoaXMuZnVuYy50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICB2YXIgZXZhbGVkID0gW107XG4gICAgICAgICAgZXguc3RhY2suc3BsaXQoJ1xcbicpLnNvbWUoZnVuY3Rpb24oZnJhbWUpIHtcbiAgICAgICAgICAgIGlmIChmcmFtZS5pbmRleE9mKCdVbmNvYXRlZE1vZHVsZUluc3RhbnRpYXRvci5nZXRVbmNvYXRlZE1vZHVsZScpID4gMClcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB2YXIgbSA9IC8oYXRcXHNbXlxcc10qXFxzKS4qPjooXFxkKik6KFxcZCopXFwpLy5leGVjKGZyYW1lKTtcbiAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgIHZhciBsaW5lID0gcGFyc2VJbnQobVsyXSwgMTApO1xuICAgICAgICAgICAgICBldmFsZWQgPSBldmFsZWQuY29uY2F0KGJlZm9yZUxpbmVzKGxpbmVzLCBsaW5lKSk7XG4gICAgICAgICAgICAgIGV2YWxlZC5wdXNoKGNvbHVtblNwYWNpbmcobVszXSkgKyAnXicpO1xuICAgICAgICAgICAgICBldmFsZWQgPSBldmFsZWQuY29uY2F0KGFmdGVyTGluZXMobGluZXMsIGxpbmUpKTtcbiAgICAgICAgICAgICAgZXZhbGVkLnB1c2goJz0gPSA9ID0gPSA9ID0gPSA9Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBldmFsZWQucHVzaChmcmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXguc3RhY2sgPSBldmFsZWQuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE1vZHVsZUV2YWx1YXRpb25FcnJvcih0aGlzLnVybCwgZXgpO1xuICAgICAgfVxuICAgIH19LCB7fSwgVW5jb2F0ZWRNb2R1bGVFbnRyeSk7XG4gIGZ1bmN0aW9uIGdldFVuY29hdGVkTW9kdWxlSW5zdGFudGlhdG9yKG5hbWUpIHtcbiAgICBpZiAoIW5hbWUpXG4gICAgICByZXR1cm47XG4gICAgdmFyIHVybCA9IE1vZHVsZVN0b3JlLm5vcm1hbGl6ZShuYW1lKTtcbiAgICByZXR1cm4gbW9kdWxlSW5zdGFudGlhdG9yc1t1cmxdO1xuICB9XG4gIDtcbiAgdmFyIG1vZHVsZUluc3RhbmNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXZlTW9kdWxlU2VudGluZWwgPSB7fTtcbiAgZnVuY3Rpb24gTW9kdWxlKHVuY29hdGVkTW9kdWxlKSB7XG4gICAgdmFyIGlzTGl2ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgY29hdGVkTW9kdWxlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh1bmNvYXRlZE1vZHVsZSkuZm9yRWFjaCgoZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGdldHRlcixcbiAgICAgICAgICB2YWx1ZTtcbiAgICAgIGlmIChpc0xpdmUgPT09IGxpdmVNb2R1bGVTZW50aW5lbCkge1xuICAgICAgICB2YXIgZGVzY3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHVuY29hdGVkTW9kdWxlLCBuYW1lKTtcbiAgICAgICAgaWYgKGRlc2NyLmdldClcbiAgICAgICAgICBnZXR0ZXIgPSBkZXNjci5nZXQ7XG4gICAgICB9XG4gICAgICBpZiAoIWdldHRlcikge1xuICAgICAgICB2YWx1ZSA9IHVuY29hdGVkTW9kdWxlW25hbWVdO1xuICAgICAgICBnZXR0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29hdGVkTW9kdWxlLCBuYW1lLCB7XG4gICAgICAgIGdldDogZ2V0dGVyLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KSk7XG4gICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKGNvYXRlZE1vZHVsZSk7XG4gICAgcmV0dXJuIGNvYXRlZE1vZHVsZTtcbiAgfVxuICB2YXIgTW9kdWxlU3RvcmUgPSB7XG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbihuYW1lLCByZWZlcmVyTmFtZSwgcmVmZXJlckFkZHJlc3MpIHtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21vZHVsZSBuYW1lIG11c3QgYmUgYSBzdHJpbmcsIG5vdCAnICsgdHlwZW9mIG5hbWUpO1xuICAgICAgaWYgKGlzQWJzb2x1dGUobmFtZSkpXG4gICAgICAgIHJldHVybiBjYW5vbmljYWxpemVVcmwobmFtZSk7XG4gICAgICBpZiAoL1teXFwuXVxcL1xcLlxcLlxcLy8udGVzdChuYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZHVsZSBuYW1lIGVtYmVkcyAvLi4vOiAnICsgbmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAobmFtZVswXSA9PT0gJy4nICYmIHJlZmVyZXJOYW1lKVxuICAgICAgICByZXR1cm4gcmVzb2x2ZVVybChyZWZlcmVyTmFtZSwgbmFtZSk7XG4gICAgICByZXR1cm4gY2Fub25pY2FsaXplVXJsKG5hbWUpO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbihub3JtYWxpemVkTmFtZSkge1xuICAgICAgdmFyIG0gPSBnZXRVbmNvYXRlZE1vZHVsZUluc3RhbnRpYXRvcihub3JtYWxpemVkTmFtZSk7XG4gICAgICBpZiAoIW0pXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbW9kdWxlSW5zdGFuY2UgPSBtb2R1bGVJbnN0YW5jZXNbbS51cmxdO1xuICAgICAgaWYgKG1vZHVsZUluc3RhbmNlKVxuICAgICAgICByZXR1cm4gbW9kdWxlSW5zdGFuY2U7XG4gICAgICBtb2R1bGVJbnN0YW5jZSA9IE1vZHVsZShtLmdldFVuY29hdGVkTW9kdWxlKCksIGxpdmVNb2R1bGVTZW50aW5lbCk7XG4gICAgICByZXR1cm4gbW9kdWxlSW5zdGFuY2VzW20udXJsXSA9IG1vZHVsZUluc3RhbmNlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihub3JtYWxpemVkTmFtZSwgbW9kdWxlKSB7XG4gICAgICBub3JtYWxpemVkTmFtZSA9IFN0cmluZyhub3JtYWxpemVkTmFtZSk7XG4gICAgICBtb2R1bGVJbnN0YW50aWF0b3JzW25vcm1hbGl6ZWROYW1lXSA9IG5ldyBVbmNvYXRlZE1vZHVsZUluc3RhbnRpYXRvcihub3JtYWxpemVkTmFtZSwgKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgICAgfSkpO1xuICAgICAgbW9kdWxlSW5zdGFuY2VzW25vcm1hbGl6ZWROYW1lXSA9IG1vZHVsZTtcbiAgICB9LFxuICAgIGdldCBiYXNlVVJMKCkge1xuICAgICAgcmV0dXJuIGJhc2VVUkw7XG4gICAgfSxcbiAgICBzZXQgYmFzZVVSTCh2KSB7XG4gICAgICBiYXNlVVJMID0gU3RyaW5nKHYpO1xuICAgIH0sXG4gICAgcmVnaXN0ZXJNb2R1bGU6IGZ1bmN0aW9uKG5hbWUsIGRlcHMsIGZ1bmMpIHtcbiAgICAgIHZhciBub3JtYWxpemVkTmFtZSA9IE1vZHVsZVN0b3JlLm5vcm1hbGl6ZShuYW1lKTtcbiAgICAgIGlmIChtb2R1bGVJbnN0YW50aWF0b3JzW25vcm1hbGl6ZWROYW1lXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkdXBsaWNhdGUgbW9kdWxlIG5hbWVkICcgKyBub3JtYWxpemVkTmFtZSk7XG4gICAgICBtb2R1bGVJbnN0YW50aWF0b3JzW25vcm1hbGl6ZWROYW1lXSA9IG5ldyBVbmNvYXRlZE1vZHVsZUluc3RhbnRpYXRvcihub3JtYWxpemVkTmFtZSwgZnVuYyk7XG4gICAgfSxcbiAgICBidW5kbGVTdG9yZTogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICByZWdpc3RlcjogZnVuY3Rpb24obmFtZSwgZGVwcywgZnVuYykge1xuICAgICAgaWYgKCFkZXBzIHx8ICFkZXBzLmxlbmd0aCAmJiAhZnVuYy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5yZWdpc3Rlck1vZHVsZShuYW1lLCBkZXBzLCBmdW5jKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYnVuZGxlU3RvcmVbbmFtZV0gPSB7XG4gICAgICAgICAgZGVwczogZGVwcyxcbiAgICAgICAgICBleGVjdXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciAkX18wID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdmFyIGRlcE1hcCA9IHt9O1xuICAgICAgICAgICAgZGVwcy5mb3JFYWNoKChmdW5jdGlvbihkZXAsIGluZGV4KSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZXBNYXBbZGVwXSA9ICRfXzBbaW5kZXhdO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdmFyIHJlZ2lzdHJ5RW50cnkgPSBmdW5jLmNhbGwodGhpcywgZGVwTWFwKTtcbiAgICAgICAgICAgIHJlZ2lzdHJ5RW50cnkuZXhlY3V0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdHJ5RW50cnkuZXhwb3J0cztcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRBbm9ueW1vdXNNb2R1bGU6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIHJldHVybiBuZXcgTW9kdWxlKGZ1bmMuY2FsbChnbG9iYWwpLCBsaXZlTW9kdWxlU2VudGluZWwpO1xuICAgIH0sXG4gICAgZ2V0Rm9yVGVzdGluZzogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyICRfXzAgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLnRlc3RpbmdQcmVmaXhfKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG1vZHVsZUluc3RhbmNlcykuc29tZSgoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgdmFyIG0gPSAvKHRyYWNldXJAW15cXC9dKlxcLykvLmV4ZWMoa2V5KTtcbiAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgJF9fMC50ZXN0aW5nUHJlZml4XyA9IG1bMV07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnRlc3RpbmdQcmVmaXhfICsgbmFtZSk7XG4gICAgfVxuICB9O1xuICB2YXIgbW9kdWxlU3RvcmVNb2R1bGUgPSBuZXcgTW9kdWxlKHtNb2R1bGVTdG9yZTogTW9kdWxlU3RvcmV9KTtcbiAgTW9kdWxlU3RvcmUuc2V0KCdAdHJhY2V1ci9zcmMvcnVudGltZS9Nb2R1bGVTdG9yZScsIG1vZHVsZVN0b3JlTW9kdWxlKTtcbiAgTW9kdWxlU3RvcmUuc2V0KCdAdHJhY2V1ci9zcmMvcnVudGltZS9Nb2R1bGVTdG9yZS5qcycsIG1vZHVsZVN0b3JlTW9kdWxlKTtcbiAgdmFyIHNldHVwR2xvYmFscyA9ICR0cmFjZXVyUnVudGltZS5zZXR1cEdsb2JhbHM7XG4gICR0cmFjZXVyUnVudGltZS5zZXR1cEdsb2JhbHMgPSBmdW5jdGlvbihnbG9iYWwpIHtcbiAgICBzZXR1cEdsb2JhbHMoZ2xvYmFsKTtcbiAgfTtcbiAgJHRyYWNldXJSdW50aW1lLk1vZHVsZVN0b3JlID0gTW9kdWxlU3RvcmU7XG4gIGdsb2JhbC5TeXN0ZW0gPSB7XG4gICAgcmVnaXN0ZXI6IE1vZHVsZVN0b3JlLnJlZ2lzdGVyLmJpbmQoTW9kdWxlU3RvcmUpLFxuICAgIHJlZ2lzdGVyTW9kdWxlOiBNb2R1bGVTdG9yZS5yZWdpc3Rlck1vZHVsZS5iaW5kKE1vZHVsZVN0b3JlKSxcbiAgICBnZXQ6IE1vZHVsZVN0b3JlLmdldCxcbiAgICBzZXQ6IE1vZHVsZVN0b3JlLnNldCxcbiAgICBub3JtYWxpemU6IE1vZHVsZVN0b3JlLm5vcm1hbGl6ZVxuICB9O1xuICAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlSW1wbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaW5zdGFudGlhdG9yID0gZ2V0VW5jb2F0ZWRNb2R1bGVJbnN0YW50aWF0b3IobmFtZSk7XG4gICAgcmV0dXJuIGluc3RhbnRpYXRvciAmJiBpbnN0YW50aWF0b3IuZ2V0VW5jb2F0ZWRNb2R1bGUoKTtcbiAgfTtcbn0pKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyk7XG5TeXN0ZW0ucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyLXJ1bnRpbWVAMC4wLjc5L3NyYy9ydW50aW1lL3BvbHlmaWxscy91dGlscy5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyLXJ1bnRpbWVAMC4wLjc5L3NyYy9ydW50aW1lL3BvbHlmaWxscy91dGlscy5qc1wiO1xuICB2YXIgJGNlaWwgPSBNYXRoLmNlaWw7XG4gIHZhciAkZmxvb3IgPSBNYXRoLmZsb29yO1xuICB2YXIgJGlzRmluaXRlID0gaXNGaW5pdGU7XG4gIHZhciAkaXNOYU4gPSBpc05hTjtcbiAgdmFyICRwb3cgPSBNYXRoLnBvdztcbiAgdmFyICRtaW4gPSBNYXRoLm1pbjtcbiAgdmFyIHRvT2JqZWN0ID0gJHRyYWNldXJSdW50aW1lLnRvT2JqZWN0O1xuICBmdW5jdGlvbiB0b1VpbnQzMih4KSB7XG4gICAgcmV0dXJuIHggPj4+IDA7XG4gIH1cbiAgZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICAgIHJldHVybiB4ICYmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbicpO1xuICB9XG4gIGZ1bmN0aW9uIGlzQ2FsbGFibGUoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuICBmdW5jdGlvbiBpc051bWJlcih4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnbnVtYmVyJztcbiAgfVxuICBmdW5jdGlvbiB0b0ludGVnZXIoeCkge1xuICAgIHggPSAreDtcbiAgICBpZiAoJGlzTmFOKHgpKVxuICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKHggPT09IDAgfHwgISRpc0Zpbml0ZSh4KSlcbiAgICAgIHJldHVybiB4O1xuICAgIHJldHVybiB4ID4gMCA/ICRmbG9vcih4KSA6ICRjZWlsKHgpO1xuICB9XG4gIHZhciBNQVhfU0FGRV9MRU5HVEggPSAkcG93KDIsIDUzKSAtIDE7XG4gIGZ1bmN0aW9uIHRvTGVuZ3RoKHgpIHtcbiAgICB2YXIgbGVuID0gdG9JbnRlZ2VyKHgpO1xuICAgIHJldHVybiBsZW4gPCAwID8gMCA6ICRtaW4obGVuLCBNQVhfU0FGRV9MRU5HVEgpO1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrSXRlcmFibGUoeCkge1xuICAgIHJldHVybiAhaXNPYmplY3QoeCkgPyB1bmRlZmluZWQgOiB4W1N5bWJvbC5pdGVyYXRvcl07XG4gIH1cbiAgZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcih4KSB7XG4gICAgcmV0dXJuIGlzQ2FsbGFibGUoeCk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSXRlcmF0b3JSZXN1bHRPYmplY3QodmFsdWUsIGRvbmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZG9uZTogZG9uZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVEZWZpbmUob2JqZWN0LCBuYW1lLCBkZXNjcikge1xuICAgIGlmICghKG5hbWUgaW4gb2JqZWN0KSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwgZGVzY3IpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtYXliZURlZmluZU1ldGhvZChvYmplY3QsIG5hbWUsIHZhbHVlKSB7XG4gICAgbWF5YmVEZWZpbmUob2JqZWN0LCBuYW1lLCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVEZWZpbmVDb25zdChvYmplY3QsIG5hbWUsIHZhbHVlKSB7XG4gICAgbWF5YmVEZWZpbmUob2JqZWN0LCBuYW1lLCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBtYXliZUFkZEZ1bmN0aW9ucyhvYmplY3QsIGZ1bmN0aW9ucykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICB2YXIgbmFtZSA9IGZ1bmN0aW9uc1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IGZ1bmN0aW9uc1tpICsgMV07XG4gICAgICBtYXliZURlZmluZU1ldGhvZChvYmplY3QsIG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVBZGRDb25zdHMob2JqZWN0LCBjb25zdHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnN0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmFyIG5hbWUgPSBjb25zdHNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBjb25zdHNbaSArIDFdO1xuICAgICAgbWF5YmVEZWZpbmVDb25zdChvYmplY3QsIG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVBZGRJdGVyYXRvcihvYmplY3QsIGZ1bmMsIFN5bWJvbCkge1xuICAgIGlmICghU3ltYm9sIHx8ICFTeW1ib2wuaXRlcmF0b3IgfHwgb2JqZWN0W1N5bWJvbC5pdGVyYXRvcl0pXG4gICAgICByZXR1cm47XG4gICAgaWYgKG9iamVjdFsnQEBpdGVyYXRvciddKVxuICAgICAgZnVuYyA9IG9iamVjdFsnQEBpdGVyYXRvciddO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIFN5bWJvbC5pdGVyYXRvciwge1xuICAgICAgdmFsdWU6IGZ1bmMsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgdmFyIHBvbHlmaWxscyA9IFtdO1xuICBmdW5jdGlvbiByZWdpc3RlclBvbHlmaWxsKGZ1bmMpIHtcbiAgICBwb2x5ZmlsbHMucHVzaChmdW5jKTtcbiAgfVxuICBmdW5jdGlvbiBwb2x5ZmlsbEFsbChnbG9iYWwpIHtcbiAgICBwb2x5ZmlsbHMuZm9yRWFjaCgoZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGYoZ2xvYmFsKTtcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXQgdG9PYmplY3QoKSB7XG4gICAgICByZXR1cm4gdG9PYmplY3Q7XG4gICAgfSxcbiAgICBnZXQgdG9VaW50MzIoKSB7XG4gICAgICByZXR1cm4gdG9VaW50MzI7XG4gICAgfSxcbiAgICBnZXQgaXNPYmplY3QoKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3Q7XG4gICAgfSxcbiAgICBnZXQgaXNDYWxsYWJsZSgpIHtcbiAgICAgIHJldHVybiBpc0NhbGxhYmxlO1xuICAgIH0sXG4gICAgZ2V0IGlzTnVtYmVyKCkge1xuICAgICAgcmV0dXJuIGlzTnVtYmVyO1xuICAgIH0sXG4gICAgZ2V0IHRvSW50ZWdlcigpIHtcbiAgICAgIHJldHVybiB0b0ludGVnZXI7XG4gICAgfSxcbiAgICBnZXQgdG9MZW5ndGgoKSB7XG4gICAgICByZXR1cm4gdG9MZW5ndGg7XG4gICAgfSxcbiAgICBnZXQgY2hlY2tJdGVyYWJsZSgpIHtcbiAgICAgIHJldHVybiBjaGVja0l0ZXJhYmxlO1xuICAgIH0sXG4gICAgZ2V0IGlzQ29uc3RydWN0b3IoKSB7XG4gICAgICByZXR1cm4gaXNDb25zdHJ1Y3RvcjtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVJdGVyYXRvclJlc3VsdE9iamVjdCgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVJdGVyYXRvclJlc3VsdE9iamVjdDtcbiAgICB9LFxuICAgIGdldCBtYXliZURlZmluZSgpIHtcbiAgICAgIHJldHVybiBtYXliZURlZmluZTtcbiAgICB9LFxuICAgIGdldCBtYXliZURlZmluZU1ldGhvZCgpIHtcbiAgICAgIHJldHVybiBtYXliZURlZmluZU1ldGhvZDtcbiAgICB9LFxuICAgIGdldCBtYXliZURlZmluZUNvbnN0KCkge1xuICAgICAgcmV0dXJuIG1heWJlRGVmaW5lQ29uc3Q7XG4gICAgfSxcbiAgICBnZXQgbWF5YmVBZGRGdW5jdGlvbnMoKSB7XG4gICAgICByZXR1cm4gbWF5YmVBZGRGdW5jdGlvbnM7XG4gICAgfSxcbiAgICBnZXQgbWF5YmVBZGRDb25zdHMoKSB7XG4gICAgICByZXR1cm4gbWF5YmVBZGRDb25zdHM7XG4gICAgfSxcbiAgICBnZXQgbWF5YmVBZGRJdGVyYXRvcigpIHtcbiAgICAgIHJldHVybiBtYXliZUFkZEl0ZXJhdG9yO1xuICAgIH0sXG4gICAgZ2V0IHJlZ2lzdGVyUG9seWZpbGwoKSB7XG4gICAgICByZXR1cm4gcmVnaXN0ZXJQb2x5ZmlsbDtcbiAgICB9LFxuICAgIGdldCBwb2x5ZmlsbEFsbCgpIHtcbiAgICAgIHJldHVybiBwb2x5ZmlsbEFsbDtcbiAgICB9XG4gIH07XG59KTtcblN5c3RlbS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXItcnVudGltZUAwLjAuNzkvc3JjL3J1bnRpbWUvcG9seWZpbGxzL01hcC5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyLXJ1bnRpbWVAMC4wLjc5L3NyYy9ydW50aW1lL3BvbHlmaWxscy9NYXAuanNcIjtcbiAgdmFyICRfXzAgPSBTeXN0ZW0uZ2V0KFwidHJhY2V1ci1ydW50aW1lQDAuMC43OS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvdXRpbHMuanNcIiksXG4gICAgICBpc09iamVjdCA9ICRfXzAuaXNPYmplY3QsXG4gICAgICBtYXliZUFkZEl0ZXJhdG9yID0gJF9fMC5tYXliZUFkZEl0ZXJhdG9yLFxuICAgICAgcmVnaXN0ZXJQb2x5ZmlsbCA9ICRfXzAucmVnaXN0ZXJQb2x5ZmlsbDtcbiAgdmFyIGdldE93bkhhc2hPYmplY3QgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0T3duSGFzaE9iamVjdDtcbiAgdmFyICRoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciBkZWxldGVkU2VudGluZWwgPSB7fTtcbiAgZnVuY3Rpb24gbG9va3VwSW5kZXgobWFwLCBrZXkpIHtcbiAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgdmFyIGhhc2hPYmplY3QgPSBnZXRPd25IYXNoT2JqZWN0KGtleSk7XG4gICAgICByZXR1cm4gaGFzaE9iamVjdCAmJiBtYXAub2JqZWN0SW5kZXhfW2hhc2hPYmplY3QuaGFzaF07XG4gICAgfVxuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJylcbiAgICAgIHJldHVybiBtYXAuc3RyaW5nSW5kZXhfW2tleV07XG4gICAgcmV0dXJuIG1hcC5wcmltaXRpdmVJbmRleF9ba2V5XTtcbiAgfVxuICBmdW5jdGlvbiBpbml0TWFwKG1hcCkge1xuICAgIG1hcC5lbnRyaWVzXyA9IFtdO1xuICAgIG1hcC5vYmplY3RJbmRleF8gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIG1hcC5zdHJpbmdJbmRleF8gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIG1hcC5wcmltaXRpdmVJbmRleF8gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIG1hcC5kZWxldGVkQ291bnRfID0gMDtcbiAgfVxuICB2YXIgTWFwID0gZnVuY3Rpb24gTWFwKCkge1xuICAgIHZhciBpdGVyYWJsZSA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoIWlzT2JqZWN0KHRoaXMpKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWFwIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgdHlwZScpO1xuICAgIGlmICgkaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnZW50cmllc18nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWFwIGNhbiBub3QgYmUgcmVlbnRyYW50bHkgaW5pdGlhbGlzZWQnKTtcbiAgICB9XG4gICAgaW5pdE1hcCh0aGlzKTtcbiAgICBpZiAoaXRlcmFibGUgIT09IG51bGwgJiYgaXRlcmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yICh2YXIgJF9fMiA9IGl0ZXJhYmxlWyR0cmFjZXVyUnVudGltZS50b1Byb3BlcnR5KFN5bWJvbC5pdGVyYXRvcildKCksXG4gICAgICAgICAgJF9fMzsgISgkX18zID0gJF9fMi5uZXh0KCkpLmRvbmU7ICkge1xuICAgICAgICB2YXIgJF9fNCA9ICRfXzMudmFsdWUsXG4gICAgICAgICAgICBrZXkgPSAkX180WzBdLFxuICAgICAgICAgICAgdmFsdWUgPSAkX180WzFdO1xuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKE1hcCwge1xuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW50cmllc18ubGVuZ3RoIC8gMiAtIHRoaXMuZGVsZXRlZENvdW50XztcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgaW5kZXggPSBsb29rdXBJbmRleCh0aGlzLCBrZXkpO1xuICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXNfW2luZGV4ICsgMV07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBvYmplY3RNb2RlID0gaXNPYmplY3Qoa2V5KTtcbiAgICAgIHZhciBzdHJpbmdNb2RlID0gdHlwZW9mIGtleSA9PT0gJ3N0cmluZyc7XG4gICAgICB2YXIgaW5kZXggPSBsb29rdXBJbmRleCh0aGlzLCBrZXkpO1xuICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5lbnRyaWVzX1tpbmRleCArIDFdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCA9IHRoaXMuZW50cmllc18ubGVuZ3RoO1xuICAgICAgICB0aGlzLmVudHJpZXNfW2luZGV4XSA9IGtleTtcbiAgICAgICAgdGhpcy5lbnRyaWVzX1tpbmRleCArIDFdID0gdmFsdWU7XG4gICAgICAgIGlmIChvYmplY3RNb2RlKSB7XG4gICAgICAgICAgdmFyIGhhc2hPYmplY3QgPSBnZXRPd25IYXNoT2JqZWN0KGtleSk7XG4gICAgICAgICAgdmFyIGhhc2ggPSBoYXNoT2JqZWN0Lmhhc2g7XG4gICAgICAgICAgdGhpcy5vYmplY3RJbmRleF9baGFzaF0gPSBpbmRleDtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpbmdNb2RlKSB7XG4gICAgICAgICAgdGhpcy5zdHJpbmdJbmRleF9ba2V5XSA9IGluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucHJpbWl0aXZlSW5kZXhfW2tleV0gPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBoYXM6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGxvb2t1cEluZGV4KHRoaXMsIGtleSkgIT09IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIGRlbGV0ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgb2JqZWN0TW9kZSA9IGlzT2JqZWN0KGtleSk7XG4gICAgICB2YXIgc3RyaW5nTW9kZSA9IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnO1xuICAgICAgdmFyIGluZGV4O1xuICAgICAgdmFyIGhhc2g7XG4gICAgICBpZiAob2JqZWN0TW9kZSkge1xuICAgICAgICB2YXIgaGFzaE9iamVjdCA9IGdldE93bkhhc2hPYmplY3Qoa2V5KTtcbiAgICAgICAgaWYgKGhhc2hPYmplY3QpIHtcbiAgICAgICAgICBpbmRleCA9IHRoaXMub2JqZWN0SW5kZXhfW2hhc2ggPSBoYXNoT2JqZWN0Lmhhc2hdO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLm9iamVjdEluZGV4X1toYXNoXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJpbmdNb2RlKSB7XG4gICAgICAgIGluZGV4ID0gdGhpcy5zdHJpbmdJbmRleF9ba2V5XTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RyaW5nSW5kZXhfW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCA9IHRoaXMucHJpbWl0aXZlSW5kZXhfW2tleV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLnByaW1pdGl2ZUluZGV4X1trZXldO1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5lbnRyaWVzX1tpbmRleF0gPSBkZWxldGVkU2VudGluZWw7XG4gICAgICAgIHRoaXMuZW50cmllc19baW5kZXggKyAxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kZWxldGVkQ291bnRfKys7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgaW5pdE1hcCh0aGlzKTtcbiAgICB9LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uKGNhbGxiYWNrRm4pIHtcbiAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVudHJpZXNfLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmVudHJpZXNfW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmVudHJpZXNfW2kgKyAxXTtcbiAgICAgICAgaWYgKGtleSA9PT0gZGVsZXRlZFNlbnRpbmVsKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYWxsYmFja0ZuLmNhbGwodGhpc0FyZywgdmFsdWUsIGtleSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnRyaWVzOiAkdHJhY2V1clJ1bnRpbWUuaW5pdEdlbmVyYXRvckZ1bmN0aW9uKGZ1bmN0aW9uICRfXzUoKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgdmFsdWU7XG4gICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLmNyZWF0ZUdlbmVyYXRvckluc3RhbmNlKGZ1bmN0aW9uKCRjdHgpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpXG4gICAgICAgICAgc3dpdGNoICgkY3R4LnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9IChpIDwgdGhpcy5lbnRyaWVzXy5sZW5ndGgpID8gOCA6IC0yO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBrZXkgPSB0aGlzLmVudHJpZXNfW2ldO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZW50cmllc19baSArIDFdO1xuICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICRjdHguc3RhdGUgPSAoa2V5ID09PSBkZWxldGVkU2VudGluZWwpID8gNCA6IDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgJGN0eC5tYXliZVRocm93KCk7XG4gICAgICAgICAgICAgICRjdHguc3RhdGUgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiAkY3R4LmVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgIH0sICRfXzUsIHRoaXMpO1xuICAgIH0pLFxuICAgIGtleXM6ICR0cmFjZXVyUnVudGltZS5pbml0R2VuZXJhdG9yRnVuY3Rpb24oZnVuY3Rpb24gJF9fNigpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICB2YWx1ZTtcbiAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuY3JlYXRlR2VuZXJhdG9ySW5zdGFuY2UoZnVuY3Rpb24oJGN0eCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSlcbiAgICAgICAgICBzd2l0Y2ggKCRjdHguc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICRjdHguc3RhdGUgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gKGkgPCB0aGlzLmVudHJpZXNfLmxlbmd0aCkgPyA4IDogLTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICRjdHguc3RhdGUgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIGtleSA9IHRoaXMuZW50cmllc19baV07XG4gICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5lbnRyaWVzX1tpICsgMV07XG4gICAgICAgICAgICAgICRjdHguc3RhdGUgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9IChrZXkgPT09IGRlbGV0ZWRTZW50aW5lbCkgPyA0IDogNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICRjdHguc3RhdGUgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAkY3R4Lm1heWJlVGhyb3coKTtcbiAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuICRjdHguZW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgfSwgJF9fNiwgdGhpcyk7XG4gICAgfSksXG4gICAgdmFsdWVzOiAkdHJhY2V1clJ1bnRpbWUuaW5pdEdlbmVyYXRvckZ1bmN0aW9uKGZ1bmN0aW9uICRfXzcoKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgdmFsdWU7XG4gICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLmNyZWF0ZUdlbmVyYXRvckluc3RhbmNlKGZ1bmN0aW9uKCRjdHgpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpXG4gICAgICAgICAgc3dpdGNoICgkY3R4LnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9IChpIDwgdGhpcy5lbnRyaWVzXy5sZW5ndGgpID8gOCA6IC0yO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBrZXkgPSB0aGlzLmVudHJpZXNfW2ldO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZW50cmllc19baSArIDFdO1xuICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICRjdHguc3RhdGUgPSAoa2V5ID09PSBkZWxldGVkU2VudGluZWwpID8gNCA6IDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAkY3R4Lm1heWJlVGhyb3coKTtcbiAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuICRjdHguZW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgfSwgJF9fNywgdGhpcyk7XG4gICAgfSlcbiAgfSwge30pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwLnByb3RvdHlwZSwgU3ltYm9sLml0ZXJhdG9yLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBNYXAucHJvdG90eXBlLmVudHJpZXNcbiAgfSk7XG4gIGZ1bmN0aW9uIHBvbHlmaWxsTWFwKGdsb2JhbCkge1xuICAgIHZhciAkX180ID0gZ2xvYmFsLFxuICAgICAgICBPYmplY3QgPSAkX180Lk9iamVjdCxcbiAgICAgICAgU3ltYm9sID0gJF9fNC5TeW1ib2w7XG4gICAgaWYgKCFnbG9iYWwuTWFwKVxuICAgICAgZ2xvYmFsLk1hcCA9IE1hcDtcbiAgICB2YXIgbWFwUHJvdG90eXBlID0gZ2xvYmFsLk1hcC5wcm90b3R5cGU7XG4gICAgaWYgKG1hcFByb3RvdHlwZS5lbnRyaWVzID09PSB1bmRlZmluZWQpXG4gICAgICBnbG9iYWwuTWFwID0gTWFwO1xuICAgIGlmIChtYXBQcm90b3R5cGUuZW50cmllcykge1xuICAgICAgbWF5YmVBZGRJdGVyYXRvcihtYXBQcm90b3R5cGUsIG1hcFByb3RvdHlwZS5lbnRyaWVzLCBTeW1ib2wpO1xuICAgICAgbWF5YmVBZGRJdGVyYXRvcihPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IGdsb2JhbC5NYXAoKS5lbnRyaWVzKCkpLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LCBTeW1ib2wpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlclBvbHlmaWxsKHBvbHlmaWxsTWFwKTtcbiAgcmV0dXJuIHtcbiAgICBnZXQgTWFwKCkge1xuICAgICAgcmV0dXJuIE1hcDtcbiAgICB9LFxuICAgIGdldCBwb2x5ZmlsbE1hcCgpIHtcbiAgICAgIHJldHVybiBwb2x5ZmlsbE1hcDtcbiAgICB9XG4gIH07XG59KTtcblN5c3RlbS5nZXQoXCJ0cmFjZXVyLXJ1bnRpbWVAMC4wLjc5L3NyYy9ydW50aW1lL3BvbHlmaWxscy9NYXAuanNcIiArICcnKTtcblN5c3RlbS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXItcnVudGltZUAwLjAuNzkvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1NldC5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyLXJ1bnRpbWVAMC4wLjc5L3NyYy9ydW50aW1lL3BvbHlmaWxscy9TZXQuanNcIjtcbiAgdmFyICRfXzAgPSBTeXN0ZW0uZ2V0KFwidHJhY2V1ci1ydW50aW1lQDAuMC43OS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvdXRpbHMuanNcIiksXG4gICAgICBpc09iamVjdCA9ICRfXzAuaXNPYmplY3QsXG4gICAgICBtYXliZUFkZEl0ZXJhdG9yID0gJF9fMC5tYXliZUFkZEl0ZXJhdG9yLFxuICAgICAgcmVnaXN0ZXJQb2x5ZmlsbCA9ICRfXzAucmVnaXN0ZXJQb2x5ZmlsbDtcbiAgdmFyIE1hcCA9IFN5c3RlbS5nZXQoXCJ0cmFjZXVyLXJ1bnRpbWVAMC4wLjc5L3NyYy9ydW50aW1lL3BvbHlmaWxscy9NYXAuanNcIikuTWFwO1xuICB2YXIgZ2V0T3duSGFzaE9iamVjdCA9ICR0cmFjZXVyUnVudGltZS5nZXRPd25IYXNoT2JqZWN0O1xuICB2YXIgJGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgZnVuY3Rpb24gaW5pdFNldChzZXQpIHtcbiAgICBzZXQubWFwXyA9IG5ldyBNYXAoKTtcbiAgfVxuICB2YXIgU2V0ID0gZnVuY3Rpb24gU2V0KCkge1xuICAgIHZhciBpdGVyYWJsZSA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoIWlzT2JqZWN0KHRoaXMpKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2V0IGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgdHlwZScpO1xuICAgIGlmICgkaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnbWFwXycpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTZXQgY2FuIG5vdCBiZSByZWVudHJhbnRseSBpbml0aWFsaXNlZCcpO1xuICAgIH1cbiAgICBpbml0U2V0KHRoaXMpO1xuICAgIGlmIChpdGVyYWJsZSAhPT0gbnVsbCAmJiBpdGVyYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKHZhciAkX180ID0gaXRlcmFibGVbJHRyYWNldXJSdW50aW1lLnRvUHJvcGVydHkoU3ltYm9sLml0ZXJhdG9yKV0oKSxcbiAgICAgICAgICAkX181OyAhKCRfXzUgPSAkX180Lm5leHQoKSkuZG9uZTsgKSB7XG4gICAgICAgIHZhciBpdGVtID0gJF9fNS52YWx1ZTtcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuYWRkKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShTZXQsIHtcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcF8uc2l6ZTtcbiAgICB9LFxuICAgIGhhczogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXBfLmhhcyhrZXkpO1xuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHRoaXMubWFwXy5zZXQoa2V5LCBrZXkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBkZWxldGU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMubWFwXy5kZWxldGUoa2V5KTtcbiAgICB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcF8uY2xlYXIoKTtcbiAgICB9LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uKGNhbGxiYWNrRm4pIHtcbiAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyICRfXzIgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMubWFwXy5mb3JFYWNoKChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIGNhbGxiYWNrRm4uY2FsbCh0aGlzQXJnLCBrZXksIGtleSwgJF9fMik7XG4gICAgICB9KSk7XG4gICAgfSxcbiAgICB2YWx1ZXM6ICR0cmFjZXVyUnVudGltZS5pbml0R2VuZXJhdG9yRnVuY3Rpb24oZnVuY3Rpb24gJF9fNygpIHtcbiAgICAgIHZhciAkX184LFxuICAgICAgICAgICRfXzk7XG4gICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLmNyZWF0ZUdlbmVyYXRvckluc3RhbmNlKGZ1bmN0aW9uKCRjdHgpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpXG4gICAgICAgICAgc3dpdGNoICgkY3R4LnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICRfXzggPSB0aGlzLm1hcF8ua2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgICAgICAgJGN0eC5zZW50ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAkY3R4LmFjdGlvbiA9ICduZXh0JztcbiAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICRfXzkgPSAkX184WyRjdHguYWN0aW9uXSgkY3R4LnNlbnRJZ25vcmVUaHJvdyk7XG4gICAgICAgICAgICAgICRjdHguc3RhdGUgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9ICgkX185LmRvbmUpID8gMyA6IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAkY3R4LnNlbnQgPSAkX185LnZhbHVlO1xuICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gLTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gMTI7XG4gICAgICAgICAgICAgIHJldHVybiAkX185LnZhbHVlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuICRjdHguZW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgfSwgJF9fNywgdGhpcyk7XG4gICAgfSksXG4gICAgZW50cmllczogJHRyYWNldXJSdW50aW1lLmluaXRHZW5lcmF0b3JGdW5jdGlvbihmdW5jdGlvbiAkX18xMCgpIHtcbiAgICAgIHZhciAkX18xMSxcbiAgICAgICAgICAkX18xMjtcbiAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuY3JlYXRlR2VuZXJhdG9ySW5zdGFuY2UoZnVuY3Rpb24oJGN0eCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSlcbiAgICAgICAgICBzd2l0Y2ggKCRjdHguc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgJF9fMTEgPSB0aGlzLm1hcF8uZW50cmllcygpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgICAgICAgJGN0eC5zZW50ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAkY3R4LmFjdGlvbiA9ICduZXh0JztcbiAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICRfXzEyID0gJF9fMTFbJGN0eC5hY3Rpb25dKCRjdHguc2VudElnbm9yZVRocm93KTtcbiAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9IDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gKCRfXzEyLmRvbmUpID8gMyA6IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAkY3R4LnNlbnQgPSAkX18xMi52YWx1ZTtcbiAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9IC0yO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9IDEyO1xuICAgICAgICAgICAgICByZXR1cm4gJF9fMTIudmFsdWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gJGN0eC5lbmQoKTtcbiAgICAgICAgICB9XG4gICAgICB9LCAkX18xMCwgdGhpcyk7XG4gICAgfSlcbiAgfSwge30pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2V0LnByb3RvdHlwZSwgU3ltYm9sLml0ZXJhdG9yLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBTZXQucHJvdG90eXBlLnZhbHVlc1xuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldC5wcm90b3R5cGUsICdrZXlzJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogU2V0LnByb3RvdHlwZS52YWx1ZXNcbiAgfSk7XG4gIGZ1bmN0aW9uIHBvbHlmaWxsU2V0KGdsb2JhbCkge1xuICAgIHZhciAkX182ID0gZ2xvYmFsLFxuICAgICAgICBPYmplY3QgPSAkX182Lk9iamVjdCxcbiAgICAgICAgU3ltYm9sID0gJF9fNi5TeW1ib2w7XG4gICAgaWYgKCFnbG9iYWwuU2V0KVxuICAgICAgZ2xvYmFsLlNldCA9IFNldDtcbiAgICB2YXIgc2V0UHJvdG90eXBlID0gZ2xvYmFsLlNldC5wcm90b3R5cGU7XG4gICAgaWYgKHNldFByb3RvdHlwZS52YWx1ZXMpIHtcbiAgICAgIG1heWJlQWRkSXRlcmF0b3Ioc2V0UHJvdG90eXBlLCBzZXRQcm90b3R5cGUudmFsdWVzLCBTeW1ib2wpO1xuICAgICAgbWF5YmVBZGRJdGVyYXRvcihPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IGdsb2JhbC5TZXQoKS52YWx1ZXMoKSksIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sIFN5bWJvbCk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyUG9seWZpbGwocG9seWZpbGxTZXQpO1xuICByZXR1cm4ge1xuICAgIGdldCBTZXQoKSB7XG4gICAgICByZXR1cm4gU2V0O1xuICAgIH0sXG4gICAgZ2V0IHBvbHlmaWxsU2V0KCkge1xuICAgICAgcmV0dXJuIHBvbHlmaWxsU2V0O1xuICAgIH1cbiAgfTtcbn0pO1xuU3lzdGVtLmdldChcInRyYWNldXItcnVudGltZUAwLjAuNzkvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1NldC5qc1wiICsgJycpO1xuU3lzdGVtLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ci1ydW50aW1lQDAuMC43OS9ub2RlX21vZHVsZXMvcnN2cC9saWIvcnN2cC9hc2FwLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXItcnVudGltZUAwLjAuNzkvbm9kZV9tb2R1bGVzL3JzdnAvbGliL3JzdnAvYXNhcC5qc1wiO1xuICB2YXIgbGVuID0gMDtcbiAgZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gICAgcXVldWVbbGVuXSA9IGNhbGxiYWNrO1xuICAgIHF1ZXVlW2xlbiArIDFdID0gYXJnO1xuICAgIGxlbiArPSAyO1xuICAgIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICB9XG4gIH1cbiAgdmFyICRfX2RlZmF1bHQgPSBhc2FwO1xuICB2YXIgYnJvd3Nlckdsb2JhbCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgPyB3aW5kb3cgOiB7fTtcbiAgdmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbiAgdmFyIGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJztcbiAgZnVuY3Rpb24gdXNlTmV4dFRpY2soKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG9ic2VydmVyLm9ic2VydmUobm9kZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBub2RlLmRhdGEgPSAoaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDIpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gdXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB1c2VTZXRUaW1lb3V0KCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDEpO1xuICAgIH07XG4gIH1cbiAgdmFyIHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBxdWV1ZVtpXTtcbiAgICAgIHZhciBhcmcgPSBxdWV1ZVtpICsgMV07XG4gICAgICBjYWxsYmFjayhhcmcpO1xuICAgICAgcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgICBxdWV1ZVtpICsgMV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxlbiA9IDA7XG4gIH1cbiAgdmFyIHNjaGVkdWxlRmx1c2g7XG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgc2NoZWR1bGVGbHVzaCA9IHVzZU5leHRUaWNrKCk7XG4gIH0gZWxzZSBpZiAoQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICBzY2hlZHVsZUZsdXNoID0gdXNlTXV0YXRpb25PYnNlcnZlcigpO1xuICB9IGVsc2UgaWYgKGlzV29ya2VyKSB7XG4gICAgc2NoZWR1bGVGbHVzaCA9IHVzZU1lc3NhZ2VDaGFubmVsKCk7XG4gIH0gZWxzZSB7XG4gICAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbiAgfVxuICByZXR1cm4ge2dldCBkZWZhdWx0KCkge1xuICAgICAgcmV0dXJuICRfX2RlZmF1bHQ7XG4gICAgfX07XG59KTtcblN5c3RlbS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXItcnVudGltZUAwLjAuNzkvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1Byb21pc2UuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ci1ydW50aW1lQDAuMC43OS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvUHJvbWlzZS5qc1wiO1xuICB2YXIgYXN5bmMgPSBTeXN0ZW0uZ2V0KFwidHJhY2V1ci1ydW50aW1lQDAuMC43OS9ub2RlX21vZHVsZXMvcnN2cC9saWIvcnN2cC9hc2FwLmpzXCIpLmRlZmF1bHQ7XG4gIHZhciByZWdpc3RlclBvbHlmaWxsID0gU3lzdGVtLmdldChcInRyYWNldXItcnVudGltZUAwLjAuNzkvc3JjL3J1bnRpbWUvcG9seWZpbGxzL3V0aWxzLmpzXCIpLnJlZ2lzdGVyUG9seWZpbGw7XG4gIHZhciBwcm9taXNlUmF3ID0ge307XG4gIGZ1bmN0aW9uIGlzUHJvbWlzZSh4KSB7XG4gICAgcmV0dXJuIHggJiYgdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHguc3RhdHVzXyAhPT0gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIGlkUmVzb2x2ZUhhbmRsZXIoeCkge1xuICAgIHJldHVybiB4O1xuICB9XG4gIGZ1bmN0aW9uIGlkUmVqZWN0SGFuZGxlcih4KSB7XG4gICAgdGhyb3cgeDtcbiAgfVxuICBmdW5jdGlvbiBjaGFpbihwcm9taXNlKSB7XG4gICAgdmFyIG9uUmVzb2x2ZSA9IGFyZ3VtZW50c1sxXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMV0gOiBpZFJlc29sdmVIYW5kbGVyO1xuICAgIHZhciBvblJlamVjdCA9IGFyZ3VtZW50c1syXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMl0gOiBpZFJlamVjdEhhbmRsZXI7XG4gICAgdmFyIGRlZmVycmVkID0gZ2V0RGVmZXJyZWQocHJvbWlzZS5jb25zdHJ1Y3Rvcik7XG4gICAgc3dpdGNoIChwcm9taXNlLnN0YXR1c18pIHtcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICB0aHJvdyBUeXBlRXJyb3I7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHByb21pc2Uub25SZXNvbHZlXy5wdXNoKG9uUmVzb2x2ZSwgZGVmZXJyZWQpO1xuICAgICAgICBwcm9taXNlLm9uUmVqZWN0Xy5wdXNoKG9uUmVqZWN0LCBkZWZlcnJlZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSArMTpcbiAgICAgICAgcHJvbWlzZUVucXVldWUocHJvbWlzZS52YWx1ZV8sIFtvblJlc29sdmUsIGRlZmVycmVkXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAtMTpcbiAgICAgICAgcHJvbWlzZUVucXVldWUocHJvbWlzZS52YWx1ZV8sIFtvblJlamVjdCwgZGVmZXJyZWRdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICB9XG4gIGZ1bmN0aW9uIGdldERlZmVycmVkKEMpIHtcbiAgICBpZiAodGhpcyA9PT0gJFByb21pc2UpIHtcbiAgICAgIHZhciBwcm9taXNlID0gcHJvbWlzZUluaXQobmV3ICRQcm9taXNlKHByb21pc2VSYXcpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgIHJlc29sdmU6IChmdW5jdGlvbih4KSB7XG4gICAgICAgICAgcHJvbWlzZVJlc29sdmUocHJvbWlzZSwgeCk7XG4gICAgICAgIH0pLFxuICAgICAgICByZWplY3Q6IChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgcHJvbWlzZVJlamVjdChwcm9taXNlLCByKTtcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIHJlc3VsdC5wcm9taXNlID0gbmV3IEMoKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZXN1bHQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIHJlc3VsdC5yZWplY3QgPSByZWplY3Q7XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm9taXNlU2V0KHByb21pc2UsIHN0YXR1cywgdmFsdWUsIG9uUmVzb2x2ZSwgb25SZWplY3QpIHtcbiAgICBwcm9taXNlLnN0YXR1c18gPSBzdGF0dXM7XG4gICAgcHJvbWlzZS52YWx1ZV8gPSB2YWx1ZTtcbiAgICBwcm9taXNlLm9uUmVzb2x2ZV8gPSBvblJlc29sdmU7XG4gICAgcHJvbWlzZS5vblJlamVjdF8gPSBvblJlamVjdDtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBmdW5jdGlvbiBwcm9taXNlSW5pdChwcm9taXNlKSB7XG4gICAgcmV0dXJuIHByb21pc2VTZXQocHJvbWlzZSwgMCwgdW5kZWZpbmVkLCBbXSwgW10pO1xuICB9XG4gIHZhciBQcm9taXNlID0gZnVuY3Rpb24gUHJvbWlzZShyZXNvbHZlcikge1xuICAgIGlmIChyZXNvbHZlciA9PT0gcHJvbWlzZVJhdylcbiAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICB2YXIgcHJvbWlzZSA9IHByb21pc2VJbml0KHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICByZXNvbHZlcigoZnVuY3Rpb24oeCkge1xuICAgICAgICBwcm9taXNlUmVzb2x2ZShwcm9taXNlLCB4KTtcbiAgICAgIH0pLCAoZnVuY3Rpb24ocikge1xuICAgICAgICBwcm9taXNlUmVqZWN0KHByb21pc2UsIHIpO1xuICAgICAgfSkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHByb21pc2VSZWplY3QocHJvbWlzZSwgZSk7XG4gICAgfVxuICB9O1xuICAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShQcm9taXNlLCB7XG4gICAgY2F0Y2g6IGZ1bmN0aW9uKG9uUmVqZWN0KSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3QpO1xuICAgIH0sXG4gICAgdGhlbjogZnVuY3Rpb24ob25SZXNvbHZlLCBvblJlamVjdCkge1xuICAgICAgaWYgKHR5cGVvZiBvblJlc29sdmUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIG9uUmVzb2x2ZSA9IGlkUmVzb2x2ZUhhbmRsZXI7XG4gICAgICBpZiAodHlwZW9mIG9uUmVqZWN0ICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICBvblJlamVjdCA9IGlkUmVqZWN0SGFuZGxlcjtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBjb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICByZXR1cm4gY2hhaW4odGhpcywgZnVuY3Rpb24oeCkge1xuICAgICAgICB4ID0gcHJvbWlzZUNvZXJjZShjb25zdHJ1Y3RvciwgeCk7XG4gICAgICAgIHJldHVybiB4ID09PSB0aGF0ID8gb25SZWplY3QobmV3IFR5cGVFcnJvcikgOiBpc1Byb21pc2UoeCkgPyB4LnRoZW4ob25SZXNvbHZlLCBvblJlamVjdCkgOiBvblJlc29sdmUoeCk7XG4gICAgICB9LCBvblJlamVjdCk7XG4gICAgfVxuICB9LCB7XG4gICAgcmVzb2x2ZTogZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKHRoaXMgPT09ICRQcm9taXNlKSB7XG4gICAgICAgIGlmIChpc1Byb21pc2UoeCkpIHtcbiAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZVNldChuZXcgJFByb21pc2UocHJvbWlzZVJhdyksICsxLCB4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZXNvbHZlKHgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlamVjdDogZnVuY3Rpb24ocikge1xuICAgICAgaWYgKHRoaXMgPT09ICRQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlU2V0KG5ldyAkUHJvbWlzZShwcm9taXNlUmF3KSwgLTEsIHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZWplY3Qocik7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFsbDogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICB2YXIgZGVmZXJyZWQgPSBnZXREZWZlcnJlZCh0aGlzKTtcbiAgICAgIHZhciByZXNvbHV0aW9ucyA9IFtdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGNvdW50ID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXNvbHV0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSh2YWx1ZXNbaV0pLnRoZW4oZnVuY3Rpb24oaSwgeCkge1xuICAgICAgICAgICAgICByZXNvbHV0aW9uc1tpXSA9IHg7XG4gICAgICAgICAgICAgIGlmICgtLWNvdW50ID09PSAwKVxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzb2x1dGlvbnMpO1xuICAgICAgICAgICAgfS5iaW5kKHVuZGVmaW5lZCwgaSksIChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChyKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfSxcbiAgICByYWNlOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgIHZhciBkZWZlcnJlZCA9IGdldERlZmVycmVkKHRoaXMpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLnJlc29sdmUodmFsdWVzW2ldKS50aGVuKChmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHgpO1xuICAgICAgICAgIH0pLCAoZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KHIpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG4gIH0pO1xuICB2YXIgJFByb21pc2UgPSBQcm9taXNlO1xuICB2YXIgJFByb21pc2VSZWplY3QgPSAkUHJvbWlzZS5yZWplY3Q7XG4gIGZ1bmN0aW9uIHByb21pc2VSZXNvbHZlKHByb21pc2UsIHgpIHtcbiAgICBwcm9taXNlRG9uZShwcm9taXNlLCArMSwgeCwgcHJvbWlzZS5vblJlc29sdmVfKTtcbiAgfVxuICBmdW5jdGlvbiBwcm9taXNlUmVqZWN0KHByb21pc2UsIHIpIHtcbiAgICBwcm9taXNlRG9uZShwcm9taXNlLCAtMSwgciwgcHJvbWlzZS5vblJlamVjdF8pO1xuICB9XG4gIGZ1bmN0aW9uIHByb21pc2VEb25lKHByb21pc2UsIHN0YXR1cywgdmFsdWUsIHJlYWN0aW9ucykge1xuICAgIGlmIChwcm9taXNlLnN0YXR1c18gIT09IDApXG4gICAgICByZXR1cm47XG4gICAgcHJvbWlzZUVucXVldWUodmFsdWUsIHJlYWN0aW9ucyk7XG4gICAgcHJvbWlzZVNldChwcm9taXNlLCBzdGF0dXMsIHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiBwcm9taXNlRW5xdWV1ZSh2YWx1ZSwgdGFza3MpIHtcbiAgICBhc3luYygoZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhc2tzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHByb21pc2VIYW5kbGUodmFsdWUsIHRhc2tzW2ldLCB0YXNrc1tpICsgMV0pO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBwcm9taXNlSGFuZGxlKHZhbHVlLCBoYW5kbGVyLCBkZWZlcnJlZCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBkZWZlcnJlZC5wcm9taXNlKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgZWxzZSBpZiAoaXNQcm9taXNlKHJlc3VsdCkpXG4gICAgICAgIGNoYWluKHJlc3VsdCwgZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgIGVsc2VcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICB9XG4gIHZhciB0aGVuYWJsZVN5bWJvbCA9ICdAQHRoZW5hYmxlJztcbiAgZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICAgIHJldHVybiB4ICYmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbicpO1xuICB9XG4gIGZ1bmN0aW9uIHByb21pc2VDb2VyY2UoY29uc3RydWN0b3IsIHgpIHtcbiAgICBpZiAoIWlzUHJvbWlzZSh4KSAmJiBpc09iamVjdCh4KSkge1xuICAgICAgdmFyIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICB0aGVuID0geC50aGVuO1xuICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICB2YXIgcHJvbWlzZSA9ICRQcm9taXNlUmVqZWN0LmNhbGwoY29uc3RydWN0b3IsIHIpO1xuICAgICAgICB4W3RoZW5hYmxlU3ltYm9sXSA9IHByb21pc2U7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBwID0geFt0aGVuYWJsZVN5bWJvbF07XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRlZmVycmVkID0gZ2V0RGVmZXJyZWQoY29uc3RydWN0b3IpO1xuICAgICAgICAgIHhbdGhlbmFibGVTeW1ib2xdID0gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhlbi5jYWxsKHgsIGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geDtcbiAgfVxuICBmdW5jdGlvbiBwb2x5ZmlsbFByb21pc2UoZ2xvYmFsKSB7XG4gICAgaWYgKCFnbG9iYWwuUHJvbWlzZSlcbiAgICAgIGdsb2JhbC5Qcm9taXNlID0gUHJvbWlzZTtcbiAgfVxuICByZWdpc3RlclBvbHlmaWxsKHBvbHlmaWxsUHJvbWlzZSk7XG4gIHJldHVybiB7XG4gICAgZ2V0IFByb21pc2UoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZTtcbiAgICB9LFxuICAgIGdldCBwb2x5ZmlsbFByb21pc2UoKSB7XG4gICAgICByZXR1cm4gcG9seWZpbGxQcm9taXNlO1xuICAgIH1cbiAgfTtcbn0pO1xuU3lzdGVtLmdldChcInRyYWNldXItcnVudGltZUAwLjAuNzkvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1Byb21pc2UuanNcIiArICcnKTtcblN5c3RlbS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXItcnVudGltZUAwLjAuNzkvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1N0cmluZ0l0ZXJhdG9yLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciAkX18yO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyLXJ1bnRpbWVAMC4wLjc5L3NyYy9ydW50aW1lL3BvbHlmaWxscy9TdHJpbmdJdGVyYXRvci5qc1wiO1xuICB2YXIgJF9fMCA9IFN5c3RlbS5nZXQoXCJ0cmFjZXVyLXJ1bnRpbWVAMC4wLjc5L3NyYy9ydW50aW1lL3BvbHlmaWxscy91dGlscy5qc1wiKSxcbiAgICAgIGNyZWF0ZUl0ZXJhdG9yUmVzdWx0T2JqZWN0ID0gJF9fMC5jcmVhdGVJdGVyYXRvclJlc3VsdE9iamVjdCxcbiAgICAgIGlzT2JqZWN0ID0gJF9fMC5pc09iamVjdDtcbiAgdmFyIHRvUHJvcGVydHkgPSAkdHJhY2V1clJ1bnRpbWUudG9Qcm9wZXJ0eTtcbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIGl0ZXJhdGVkU3RyaW5nID0gU3ltYm9sKCdpdGVyYXRlZFN0cmluZycpO1xuICB2YXIgc3RyaW5nSXRlcmF0b3JOZXh0SW5kZXggPSBTeW1ib2woJ3N0cmluZ0l0ZXJhdG9yTmV4dEluZGV4Jyk7XG4gIHZhciBTdHJpbmdJdGVyYXRvciA9IGZ1bmN0aW9uIFN0cmluZ0l0ZXJhdG9yKCkge307XG4gICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFN0cmluZ0l0ZXJhdG9yLCAoJF9fMiA9IHt9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkoJF9fMiwgXCJuZXh0XCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbyA9IHRoaXM7XG4gICAgICBpZiAoIWlzT2JqZWN0KG8pIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGl0ZXJhdGVkU3RyaW5nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIG11c3QgYmUgYSBTdHJpbmdJdGVyYXRvciBvYmplY3QnKTtcbiAgICAgIH1cbiAgICAgIHZhciBzID0gb1t0b1Byb3BlcnR5KGl0ZXJhdGVkU3RyaW5nKV07XG4gICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVJdGVyYXRvclJlc3VsdE9iamVjdCh1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfVxuICAgICAgdmFyIHBvc2l0aW9uID0gb1t0b1Byb3BlcnR5KHN0cmluZ0l0ZXJhdG9yTmV4dEluZGV4KV07XG4gICAgICB2YXIgbGVuID0gcy5sZW5ndGg7XG4gICAgICBpZiAocG9zaXRpb24gPj0gbGVuKSB7XG4gICAgICAgIG9bdG9Qcm9wZXJ0eShpdGVyYXRlZFN0cmluZyldID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gY3JlYXRlSXRlcmF0b3JSZXN1bHRPYmplY3QodW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBmaXJzdCA9IHMuY2hhckNvZGVBdChwb3NpdGlvbik7XG4gICAgICB2YXIgcmVzdWx0U3RyaW5nO1xuICAgICAgaWYgKGZpcnN0IDwgMHhEODAwIHx8IGZpcnN0ID4gMHhEQkZGIHx8IHBvc2l0aW9uICsgMSA9PT0gbGVuKSB7XG4gICAgICAgIHJlc3VsdFN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZmlyc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNlY29uZCA9IHMuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpO1xuICAgICAgICBpZiAoc2Vjb25kIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRikge1xuICAgICAgICAgIHJlc3VsdFN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZmlyc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZmlyc3QpICsgU3RyaW5nLmZyb21DaGFyQ29kZShzZWNvbmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvW3RvUHJvcGVydHkoc3RyaW5nSXRlcmF0b3JOZXh0SW5kZXgpXSA9IHBvc2l0aW9uICsgcmVzdWx0U3RyaW5nLmxlbmd0aDtcbiAgICAgIHJldHVybiBjcmVhdGVJdGVyYXRvclJlc3VsdE9iamVjdChyZXN1bHRTdHJpbmcsIGZhbHNlKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoJF9fMiwgU3ltYm9sLml0ZXJhdG9yLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgJF9fMiksIHt9KTtcbiAgZnVuY3Rpb24gY3JlYXRlU3RyaW5nSXRlcmF0b3Ioc3RyaW5nKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoc3RyaW5nKTtcbiAgICB2YXIgaXRlcmF0b3IgPSBPYmplY3QuY3JlYXRlKFN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgaXRlcmF0b3JbdG9Qcm9wZXJ0eShpdGVyYXRlZFN0cmluZyldID0gcztcbiAgICBpdGVyYXRvclt0b1Byb3BlcnR5KHN0cmluZ0l0ZXJhdG9yTmV4dEluZGV4KV0gPSAwO1xuICAgIHJldHVybiBpdGVyYXRvcjtcbiAgfVxuICByZXR1cm4ge2dldCBjcmVhdGVTdHJpbmdJdGVyYXRvcigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVTdHJpbmdJdGVyYXRvcjtcbiAgICB9fTtcbn0pO1xuU3lzdGVtLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ci1ydW50aW1lQDAuMC43OS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvU3RyaW5nLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXItcnVudGltZUAwLjAuNzkvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1N0cmluZy5qc1wiO1xuICB2YXIgY3JlYXRlU3RyaW5nSXRlcmF0b3IgPSBTeXN0ZW0uZ2V0KFwidHJhY2V1ci1ydW50aW1lQDAuMC43OS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvU3RyaW5nSXRlcmF0b3IuanNcIikuY3JlYXRlU3RyaW5nSXRlcmF0b3I7XG4gIHZhciAkX18xID0gU3lzdGVtLmdldChcInRyYWNldXItcnVudGltZUAwLjAuNzkvc3JjL3J1bnRpbWUvcG9seWZpbGxzL3V0aWxzLmpzXCIpLFxuICAgICAgbWF5YmVBZGRGdW5jdGlvbnMgPSAkX18xLm1heWJlQWRkRnVuY3Rpb25zLFxuICAgICAgbWF5YmVBZGRJdGVyYXRvciA9ICRfXzEubWF5YmVBZGRJdGVyYXRvcixcbiAgICAgIHJlZ2lzdGVyUG9seWZpbGwgPSAkX18xLnJlZ2lzdGVyUG9seWZpbGw7XG4gIHZhciAkdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICB2YXIgJGluZGV4T2YgPSBTdHJpbmcucHJvdG90eXBlLmluZGV4T2Y7XG4gIHZhciAkbGFzdEluZGV4T2YgPSBTdHJpbmcucHJvdG90eXBlLmxhc3RJbmRleE9mO1xuICBmdW5jdGlvbiBzdGFydHNXaXRoKHNlYXJjaCkge1xuICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG4gICAgaWYgKHRoaXMgPT0gbnVsbCB8fCAkdG9TdHJpbmcuY2FsbChzZWFyY2gpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICB9XG4gICAgdmFyIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgdmFyIHNlYXJjaFN0cmluZyA9IFN0cmluZyhzZWFyY2gpO1xuICAgIHZhciBzZWFyY2hMZW5ndGggPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xuICAgIHZhciBwb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBwb3MgPSBwb3NpdGlvbiA/IE51bWJlcihwb3NpdGlvbikgOiAwO1xuICAgIGlmIChpc05hTihwb3MpKSB7XG4gICAgICBwb3MgPSAwO1xuICAgIH1cbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1pbihNYXRoLm1heChwb3MsIDApLCBzdHJpbmdMZW5ndGgpO1xuICAgIHJldHVybiAkaW5kZXhPZi5jYWxsKHN0cmluZywgc2VhcmNoU3RyaW5nLCBwb3MpID09IHN0YXJ0O1xuICB9XG4gIGZ1bmN0aW9uIGVuZHNXaXRoKHNlYXJjaCkge1xuICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG4gICAgaWYgKHRoaXMgPT0gbnVsbCB8fCAkdG9TdHJpbmcuY2FsbChzZWFyY2gpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICB9XG4gICAgdmFyIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgdmFyIHNlYXJjaFN0cmluZyA9IFN0cmluZyhzZWFyY2gpO1xuICAgIHZhciBzZWFyY2hMZW5ndGggPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xuICAgIHZhciBwb3MgPSBzdHJpbmdMZW5ndGg7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAocG9zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb3MgPSBwb3NpdGlvbiA/IE51bWJlcihwb3NpdGlvbikgOiAwO1xuICAgICAgICBpZiAoaXNOYU4ocG9zKSkge1xuICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGVuZCA9IE1hdGgubWluKE1hdGgubWF4KHBvcywgMCksIHN0cmluZ0xlbmd0aCk7XG4gICAgdmFyIHN0YXJ0ID0gZW5kIC0gc2VhcmNoTGVuZ3RoO1xuICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICRsYXN0SW5kZXhPZi5jYWxsKHN0cmluZywgc2VhcmNoU3RyaW5nLCBzdGFydCkgPT0gc3RhcnQ7XG4gIH1cbiAgZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoKSB7XG4gICAgaWYgKHRoaXMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgfVxuICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG4gICAgaWYgKHNlYXJjaCAmJiAkdG9TdHJpbmcuY2FsbChzZWFyY2gpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICB9XG4gICAgdmFyIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgdmFyIHNlYXJjaFN0cmluZyA9IFN0cmluZyhzZWFyY2gpO1xuICAgIHZhciBzZWFyY2hMZW5ndGggPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xuICAgIHZhciBwb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBwb3MgPSBwb3NpdGlvbiA/IE51bWJlcihwb3NpdGlvbikgOiAwO1xuICAgIGlmIChwb3MgIT0gcG9zKSB7XG4gICAgICBwb3MgPSAwO1xuICAgIH1cbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1pbihNYXRoLm1heChwb3MsIDApLCBzdHJpbmdMZW5ndGgpO1xuICAgIGlmIChzZWFyY2hMZW5ndGggKyBzdGFydCA+IHN0cmluZ0xlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gJGluZGV4T2YuY2FsbChzdHJpbmcsIHNlYXJjaFN0cmluZywgcG9zKSAhPSAtMTtcbiAgfVxuICBmdW5jdGlvbiByZXBlYXQoY291bnQpIHtcbiAgICBpZiAodGhpcyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICB9XG4gICAgdmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcbiAgICB2YXIgbiA9IGNvdW50ID8gTnVtYmVyKGNvdW50KSA6IDA7XG4gICAgaWYgKGlzTmFOKG4pKSB7XG4gICAgICBuID0gMDtcbiAgICB9XG4gICAgaWYgKG4gPCAwIHx8IG4gPT0gSW5maW5pdHkpIHtcbiAgICAgIHRocm93IFJhbmdlRXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKG4gPT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgd2hpbGUgKG4tLSkge1xuICAgICAgcmVzdWx0ICs9IHN0cmluZztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBjb2RlUG9pbnRBdChwb3NpdGlvbikge1xuICAgIGlmICh0aGlzID09IG51bGwpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgIH1cbiAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgIHZhciBzaXplID0gc3RyaW5nLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSBwb3NpdGlvbiA/IE51bWJlcihwb3NpdGlvbikgOiAwO1xuICAgIGlmIChpc05hTihpbmRleCkpIHtcbiAgICAgIGluZGV4ID0gMDtcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzaXplKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgZmlyc3QgPSBzdHJpbmcuY2hhckNvZGVBdChpbmRleCk7XG4gICAgdmFyIHNlY29uZDtcbiAgICBpZiAoZmlyc3QgPj0gMHhEODAwICYmIGZpcnN0IDw9IDB4REJGRiAmJiBzaXplID4gaW5kZXggKyAxKSB7XG4gICAgICBzZWNvbmQgPSBzdHJpbmcuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICAgICAgaWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikge1xuICAgICAgICByZXR1cm4gKGZpcnN0IC0gMHhEODAwKSAqIDB4NDAwICsgc2Vjb25kIC0gMHhEQzAwICsgMHgxMDAwMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0O1xuICB9XG4gIGZ1bmN0aW9uIHJhdyhjYWxsc2l0ZSkge1xuICAgIHZhciByYXcgPSBjYWxsc2l0ZS5yYXc7XG4gICAgdmFyIGxlbiA9IHJhdy5sZW5ndGggPj4+IDA7XG4gICAgaWYgKGxlbiA9PT0gMClcbiAgICAgIHJldHVybiAnJztcbiAgICB2YXIgcyA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgcyArPSByYXdbaV07XG4gICAgICBpZiAoaSArIDEgPT09IGxlbilcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICBzICs9IGFyZ3VtZW50c1srK2ldO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KCkge1xuICAgIHZhciBjb2RlVW5pdHMgPSBbXTtcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBoaWdoU3Vycm9nYXRlO1xuICAgIHZhciBsb3dTdXJyb2dhdGU7XG4gICAgdmFyIGluZGV4ID0gLTE7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBjb2RlUG9pbnQgPSBOdW1iZXIoYXJndW1lbnRzW2luZGV4XSk7XG4gICAgICBpZiAoIWlzRmluaXRlKGNvZGVQb2ludCkgfHwgY29kZVBvaW50IDwgMCB8fCBjb2RlUG9pbnQgPiAweDEwRkZGRiB8fCBmbG9vcihjb2RlUG9pbnQpICE9IGNvZGVQb2ludCkge1xuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQ6ICcgKyBjb2RlUG9pbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGVQb2ludCA8PSAweEZGRkYpIHtcbiAgICAgICAgY29kZVVuaXRzLnB1c2goY29kZVBvaW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICBoaWdoU3Vycm9nYXRlID0gKGNvZGVQb2ludCA+PiAxMCkgKyAweEQ4MDA7XG4gICAgICAgIGxvd1N1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgJSAweDQwMCkgKyAweERDMDA7XG4gICAgICAgIGNvZGVVbml0cy5wdXNoKGhpZ2hTdXJyb2dhdGUsIGxvd1N1cnJvZ2F0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNvZGVVbml0cyk7XG4gIH1cbiAgZnVuY3Rpb24gc3RyaW5nUHJvdG90eXBlSXRlcmF0b3IoKSB7XG4gICAgdmFyIG8gPSAkdHJhY2V1clJ1bnRpbWUuY2hlY2tPYmplY3RDb2VyY2libGUodGhpcyk7XG4gICAgdmFyIHMgPSBTdHJpbmcobyk7XG4gICAgcmV0dXJuIGNyZWF0ZVN0cmluZ0l0ZXJhdG9yKHMpO1xuICB9XG4gIGZ1bmN0aW9uIHBvbHlmaWxsU3RyaW5nKGdsb2JhbCkge1xuICAgIHZhciBTdHJpbmcgPSBnbG9iYWwuU3RyaW5nO1xuICAgIG1heWJlQWRkRnVuY3Rpb25zKFN0cmluZy5wcm90b3R5cGUsIFsnY29kZVBvaW50QXQnLCBjb2RlUG9pbnRBdCwgJ2VuZHNXaXRoJywgZW5kc1dpdGgsICdpbmNsdWRlcycsIGluY2x1ZGVzLCAncmVwZWF0JywgcmVwZWF0LCAnc3RhcnRzV2l0aCcsIHN0YXJ0c1dpdGhdKTtcbiAgICBtYXliZUFkZEZ1bmN0aW9ucyhTdHJpbmcsIFsnZnJvbUNvZGVQb2ludCcsIGZyb21Db2RlUG9pbnQsICdyYXcnLCByYXddKTtcbiAgICBtYXliZUFkZEl0ZXJhdG9yKFN0cmluZy5wcm90b3R5cGUsIHN0cmluZ1Byb3RvdHlwZUl0ZXJhdG9yLCBTeW1ib2wpO1xuICB9XG4gIHJlZ2lzdGVyUG9seWZpbGwocG9seWZpbGxTdHJpbmcpO1xuICByZXR1cm4ge1xuICAgIGdldCBzdGFydHNXaXRoKCkge1xuICAgICAgcmV0dXJuIHN0YXJ0c1dpdGg7XG4gICAgfSxcbiAgICBnZXQgZW5kc1dpdGgoKSB7XG4gICAgICByZXR1cm4gZW5kc1dpdGg7XG4gICAgfSxcbiAgICBnZXQgaW5jbHVkZXMoKSB7XG4gICAgICByZXR1cm4gaW5jbHVkZXM7XG4gICAgfSxcbiAgICBnZXQgcmVwZWF0KCkge1xuICAgICAgcmV0dXJuIHJlcGVhdDtcbiAgICB9LFxuICAgIGdldCBjb2RlUG9pbnRBdCgpIHtcbiAgICAgIHJldHVybiBjb2RlUG9pbnRBdDtcbiAgICB9LFxuICAgIGdldCByYXcoKSB7XG4gICAgICByZXR1cm4gcmF3O1xuICAgIH0sXG4gICAgZ2V0IGZyb21Db2RlUG9pbnQoKSB7XG4gICAgICByZXR1cm4gZnJvbUNvZGVQb2ludDtcbiAgICB9LFxuICAgIGdldCBzdHJpbmdQcm90b3R5cGVJdGVyYXRvcigpIHtcbiAgICAgIHJldHVybiBzdHJpbmdQcm90b3R5cGVJdGVyYXRvcjtcbiAgICB9LFxuICAgIGdldCBwb2x5ZmlsbFN0cmluZygpIHtcbiAgICAgIHJldHVybiBwb2x5ZmlsbFN0cmluZztcbiAgICB9XG4gIH07XG59KTtcblN5c3RlbS5nZXQoXCJ0cmFjZXVyLXJ1bnRpbWVAMC4wLjc5L3NyYy9ydW50aW1lL3BvbHlmaWxscy9TdHJpbmcuanNcIiArICcnKTtcblN5c3RlbS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXItcnVudGltZUAwLjAuNzkvc3JjL3J1bnRpbWUvcG9seWZpbGxzL0FycmF5SXRlcmF0b3IuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyICRfXzI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXItcnVudGltZUAwLjAuNzkvc3JjL3J1bnRpbWUvcG9seWZpbGxzL0FycmF5SXRlcmF0b3IuanNcIjtcbiAgdmFyICRfXzAgPSBTeXN0ZW0uZ2V0KFwidHJhY2V1ci1ydW50aW1lQDAuMC43OS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvdXRpbHMuanNcIiksXG4gICAgICB0b09iamVjdCA9ICRfXzAudG9PYmplY3QsXG4gICAgICB0b1VpbnQzMiA9ICRfXzAudG9VaW50MzIsXG4gICAgICBjcmVhdGVJdGVyYXRvclJlc3VsdE9iamVjdCA9ICRfXzAuY3JlYXRlSXRlcmF0b3JSZXN1bHRPYmplY3Q7XG4gIHZhciBBUlJBWV9JVEVSQVRPUl9LSU5EX0tFWVMgPSAxO1xuICB2YXIgQVJSQVlfSVRFUkFUT1JfS0lORF9WQUxVRVMgPSAyO1xuICB2YXIgQVJSQVlfSVRFUkFUT1JfS0lORF9FTlRSSUVTID0gMztcbiAgdmFyIEFycmF5SXRlcmF0b3IgPSBmdW5jdGlvbiBBcnJheUl0ZXJhdG9yKCkge307XG4gICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEFycmF5SXRlcmF0b3IsICgkX18yID0ge30sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgkX18yLCBcIm5leHRcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IHRvT2JqZWN0KHRoaXMpO1xuICAgICAgdmFyIGFycmF5ID0gaXRlcmF0b3IuaXRlcmF0b3JPYmplY3RfO1xuICAgICAgaWYgKCFhcnJheSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QgaXMgbm90IGFuIEFycmF5SXRlcmF0b3InKTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGl0ZXJhdG9yLmFycmF5SXRlcmF0b3JOZXh0SW5kZXhfO1xuICAgICAgdmFyIGl0ZW1LaW5kID0gaXRlcmF0b3IuYXJyYXlJdGVyYXRpb25LaW5kXztcbiAgICAgIHZhciBsZW5ndGggPSB0b1VpbnQzMihhcnJheS5sZW5ndGgpO1xuICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICBpdGVyYXRvci5hcnJheUl0ZXJhdG9yTmV4dEluZGV4XyA9IEluZmluaXR5O1xuICAgICAgICByZXR1cm4gY3JlYXRlSXRlcmF0b3JSZXN1bHRPYmplY3QodW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGl0ZXJhdG9yLmFycmF5SXRlcmF0b3JOZXh0SW5kZXhfID0gaW5kZXggKyAxO1xuICAgICAgaWYgKGl0ZW1LaW5kID09IEFSUkFZX0lURVJBVE9SX0tJTkRfVkFMVUVTKVxuICAgICAgICByZXR1cm4gY3JlYXRlSXRlcmF0b3JSZXN1bHRPYmplY3QoYXJyYXlbaW5kZXhdLCBmYWxzZSk7XG4gICAgICBpZiAoaXRlbUtpbmQgPT0gQVJSQVlfSVRFUkFUT1JfS0lORF9FTlRSSUVTKVxuICAgICAgICByZXR1cm4gY3JlYXRlSXRlcmF0b3JSZXN1bHRPYmplY3QoW2luZGV4LCBhcnJheVtpbmRleF1dLCBmYWxzZSk7XG4gICAgICByZXR1cm4gY3JlYXRlSXRlcmF0b3JSZXN1bHRPYmplY3QoaW5kZXgsIGZhbHNlKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoJF9fMiwgU3ltYm9sLml0ZXJhdG9yLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgJF9fMiksIHt9KTtcbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlJdGVyYXRvcihhcnJheSwga2luZCkge1xuICAgIHZhciBvYmplY3QgPSB0b09iamVjdChhcnJheSk7XG4gICAgdmFyIGl0ZXJhdG9yID0gbmV3IEFycmF5SXRlcmF0b3I7XG4gICAgaXRlcmF0b3IuaXRlcmF0b3JPYmplY3RfID0gb2JqZWN0O1xuICAgIGl0ZXJhdG9yLmFycmF5SXRlcmF0b3JOZXh0SW5kZXhfID0gMDtcbiAgICBpdGVyYXRvci5hcnJheUl0ZXJhdGlvbktpbmRfID0ga2luZDtcbiAgICByZXR1cm4gaXRlcmF0b3I7XG4gIH1cbiAgZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICByZXR1cm4gY3JlYXRlQXJyYXlJdGVyYXRvcih0aGlzLCBBUlJBWV9JVEVSQVRPUl9LSU5EX0VOVFJJRVMpO1xuICB9XG4gIGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFycmF5SXRlcmF0b3IodGhpcywgQVJSQVlfSVRFUkFUT1JfS0lORF9LRVlTKTtcbiAgfVxuICBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFycmF5SXRlcmF0b3IodGhpcywgQVJSQVlfSVRFUkFUT1JfS0lORF9WQUxVRVMpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0IGVudHJpZXMoKSB7XG4gICAgICByZXR1cm4gZW50cmllcztcbiAgICB9LFxuICAgIGdldCBrZXlzKCkge1xuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfSxcbiAgICBnZXQgdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gIH07XG59KTtcblN5c3RlbS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXItcnVudGltZUAwLjAuNzkvc3JjL3J1bnRpbWUvcG9seWZpbGxzL0FycmF5LmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXItcnVudGltZUAwLjAuNzkvc3JjL3J1bnRpbWUvcG9seWZpbGxzL0FycmF5LmpzXCI7XG4gIHZhciAkX18wID0gU3lzdGVtLmdldChcInRyYWNldXItcnVudGltZUAwLjAuNzkvc3JjL3J1bnRpbWUvcG9seWZpbGxzL0FycmF5SXRlcmF0b3IuanNcIiksXG4gICAgICBlbnRyaWVzID0gJF9fMC5lbnRyaWVzLFxuICAgICAga2V5cyA9ICRfXzAua2V5cyxcbiAgICAgIHZhbHVlcyA9ICRfXzAudmFsdWVzO1xuICB2YXIgJF9fMSA9IFN5c3RlbS5nZXQoXCJ0cmFjZXVyLXJ1bnRpbWVAMC4wLjc5L3NyYy9ydW50aW1lL3BvbHlmaWxscy91dGlscy5qc1wiKSxcbiAgICAgIGNoZWNrSXRlcmFibGUgPSAkX18xLmNoZWNrSXRlcmFibGUsXG4gICAgICBpc0NhbGxhYmxlID0gJF9fMS5pc0NhbGxhYmxlLFxuICAgICAgaXNDb25zdHJ1Y3RvciA9ICRfXzEuaXNDb25zdHJ1Y3RvcixcbiAgICAgIG1heWJlQWRkRnVuY3Rpb25zID0gJF9fMS5tYXliZUFkZEZ1bmN0aW9ucyxcbiAgICAgIG1heWJlQWRkSXRlcmF0b3IgPSAkX18xLm1heWJlQWRkSXRlcmF0b3IsXG4gICAgICByZWdpc3RlclBvbHlmaWxsID0gJF9fMS5yZWdpc3RlclBvbHlmaWxsLFxuICAgICAgdG9JbnRlZ2VyID0gJF9fMS50b0ludGVnZXIsXG4gICAgICB0b0xlbmd0aCA9ICRfXzEudG9MZW5ndGgsXG4gICAgICB0b09iamVjdCA9ICRfXzEudG9PYmplY3Q7XG4gIGZ1bmN0aW9uIGZyb20oYXJyTGlrZSkge1xuICAgIHZhciBtYXBGbiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGl0ZW1zID0gdG9PYmplY3QoYXJyTGlrZSk7XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBGbiAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBrID0gMDtcbiAgICB2YXIgYXJyLFxuICAgICAgICBsZW47XG4gICAgaWYgKG1hcHBpbmcgJiYgIWlzQ2FsbGFibGUobWFwRm4pKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKGNoZWNrSXRlcmFibGUoaXRlbXMpKSB7XG4gICAgICBhcnIgPSBpc0NvbnN0cnVjdG9yKEMpID8gbmV3IEMoKSA6IFtdO1xuICAgICAgZm9yICh2YXIgJF9fMiA9IGl0ZW1zWyR0cmFjZXVyUnVudGltZS50b1Byb3BlcnR5KFN5bWJvbC5pdGVyYXRvcildKCksXG4gICAgICAgICAgJF9fMzsgISgkX18zID0gJF9fMi5uZXh0KCkpLmRvbmU7ICkge1xuICAgICAgICB2YXIgaXRlbSA9ICRfXzMudmFsdWU7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobWFwcGluZykge1xuICAgICAgICAgICAgYXJyW2tdID0gbWFwRm4uY2FsbCh0aGlzQXJnLCBpdGVtLCBrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyW2tdID0gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcnIubGVuZ3RoID0gaztcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIGxlbiA9IHRvTGVuZ3RoKGl0ZW1zLmxlbmd0aCk7XG4gICAgYXJyID0gaXNDb25zdHJ1Y3RvcihDKSA/IG5ldyBDKGxlbikgOiBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKDsgayA8IGxlbjsgaysrKSB7XG4gICAgICBpZiAobWFwcGluZykge1xuICAgICAgICBhcnJba10gPSB0eXBlb2YgdGhpc0FyZyA9PT0gJ3VuZGVmaW5lZCcgPyBtYXBGbihpdGVtc1trXSwgaykgOiBtYXBGbi5jYWxsKHRoaXNBcmcsIGl0ZW1zW2tdLCBrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycltrXSA9IGl0ZW1zW2tdO1xuICAgICAgfVxuICAgIH1cbiAgICBhcnIubGVuZ3RoID0gbGVuO1xuICAgIHJldHVybiBhcnI7XG4gIH1cbiAgZnVuY3Rpb24gb2YoKSB7XG4gICAgZm9yICh2YXIgaXRlbXMgPSBbXSxcbiAgICAgICAgJF9fNCA9IDA7ICRfXzQgPCBhcmd1bWVudHMubGVuZ3RoOyAkX180KyspXG4gICAgICBpdGVtc1skX180XSA9IGFyZ3VtZW50c1skX180XTtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGxlbiA9IGl0ZW1zLmxlbmd0aDtcbiAgICB2YXIgYXJyID0gaXNDb25zdHJ1Y3RvcihDKSA/IG5ldyBDKGxlbikgOiBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGxlbjsgaysrKSB7XG4gICAgICBhcnJba10gPSBpdGVtc1trXTtcbiAgICB9XG4gICAgYXJyLmxlbmd0aCA9IGxlbjtcbiAgICByZXR1cm4gYXJyO1xuICB9XG4gIGZ1bmN0aW9uIGZpbGwodmFsdWUpIHtcbiAgICB2YXIgc3RhcnQgPSBhcmd1bWVudHNbMV0gIT09ICh2b2lkIDApID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICB2YXIgZW5kID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBvYmplY3QgPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgob2JqZWN0Lmxlbmd0aCk7XG4gICAgdmFyIGZpbGxTdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG4gICAgdmFyIGZpbGxFbmQgPSBlbmQgIT09IHVuZGVmaW5lZCA/IHRvSW50ZWdlcihlbmQpIDogbGVuO1xuICAgIGZpbGxTdGFydCA9IGZpbGxTdGFydCA8IDAgPyBNYXRoLm1heChsZW4gKyBmaWxsU3RhcnQsIDApIDogTWF0aC5taW4oZmlsbFN0YXJ0LCBsZW4pO1xuICAgIGZpbGxFbmQgPSBmaWxsRW5kIDwgMCA/IE1hdGgubWF4KGxlbiArIGZpbGxFbmQsIDApIDogTWF0aC5taW4oZmlsbEVuZCwgbGVuKTtcbiAgICB3aGlsZSAoZmlsbFN0YXJ0IDwgZmlsbEVuZCkge1xuICAgICAgb2JqZWN0W2ZpbGxTdGFydF0gPSB2YWx1ZTtcbiAgICAgIGZpbGxTdGFydCsrO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlKSB7XG4gICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMV07XG4gICAgcmV0dXJuIGZpbmRIZWxwZXIodGhpcywgcHJlZGljYXRlLCB0aGlzQXJnKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlKSB7XG4gICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMV07XG4gICAgcmV0dXJuIGZpbmRIZWxwZXIodGhpcywgcHJlZGljYXRlLCB0aGlzQXJnLCB0cnVlKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kSGVscGVyKHNlbGYsIHByZWRpY2F0ZSkge1xuICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciByZXR1cm5JbmRleCA9IGFyZ3VtZW50c1szXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3Qoc2VsZik7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKG9iamVjdC5sZW5ndGgpO1xuICAgIGlmICghaXNDYWxsYWJsZShwcmVkaWNhdGUpKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpLCBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiByZXR1cm5JbmRleCA/IGkgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldHVybkluZGV4ID8gLTEgOiB1bmRlZmluZWQ7XG4gIH1cbiAgZnVuY3Rpb24gcG9seWZpbGxBcnJheShnbG9iYWwpIHtcbiAgICB2YXIgJF9fNSA9IGdsb2JhbCxcbiAgICAgICAgQXJyYXkgPSAkX181LkFycmF5LFxuICAgICAgICBPYmplY3QgPSAkX181Lk9iamVjdCxcbiAgICAgICAgU3ltYm9sID0gJF9fNS5TeW1ib2w7XG4gICAgbWF5YmVBZGRGdW5jdGlvbnMoQXJyYXkucHJvdG90eXBlLCBbJ2VudHJpZXMnLCBlbnRyaWVzLCAna2V5cycsIGtleXMsICd2YWx1ZXMnLCB2YWx1ZXMsICdmaWxsJywgZmlsbCwgJ2ZpbmQnLCBmaW5kLCAnZmluZEluZGV4JywgZmluZEluZGV4XSk7XG4gICAgbWF5YmVBZGRGdW5jdGlvbnMoQXJyYXksIFsnZnJvbScsIGZyb20sICdvZicsIG9mXSk7XG4gICAgbWF5YmVBZGRJdGVyYXRvcihBcnJheS5wcm90b3R5cGUsIHZhbHVlcywgU3ltYm9sKTtcbiAgICBtYXliZUFkZEl0ZXJhdG9yKE9iamVjdC5nZXRQcm90b3R5cGVPZihbXS52YWx1ZXMoKSksIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgU3ltYm9sKTtcbiAgfVxuICByZWdpc3RlclBvbHlmaWxsKHBvbHlmaWxsQXJyYXkpO1xuICByZXR1cm4ge1xuICAgIGdldCBmcm9tKCkge1xuICAgICAgcmV0dXJuIGZyb207XG4gICAgfSxcbiAgICBnZXQgb2YoKSB7XG4gICAgICByZXR1cm4gb2Y7XG4gICAgfSxcbiAgICBnZXQgZmlsbCgpIHtcbiAgICAgIHJldHVybiBmaWxsO1xuICAgIH0sXG4gICAgZ2V0IGZpbmQoKSB7XG4gICAgICByZXR1cm4gZmluZDtcbiAgICB9LFxuICAgIGdldCBmaW5kSW5kZXgoKSB7XG4gICAgICByZXR1cm4gZmluZEluZGV4O1xuICAgIH0sXG4gICAgZ2V0IHBvbHlmaWxsQXJyYXkoKSB7XG4gICAgICByZXR1cm4gcG9seWZpbGxBcnJheTtcbiAgICB9XG4gIH07XG59KTtcblN5c3RlbS5nZXQoXCJ0cmFjZXVyLXJ1bnRpbWVAMC4wLjc5L3NyYy9ydW50aW1lL3BvbHlmaWxscy9BcnJheS5qc1wiICsgJycpO1xuU3lzdGVtLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ci1ydW50aW1lQDAuMC43OS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvT2JqZWN0LmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXItcnVudGltZUAwLjAuNzkvc3JjL3J1bnRpbWUvcG9seWZpbGxzL09iamVjdC5qc1wiO1xuICB2YXIgJF9fMCA9IFN5c3RlbS5nZXQoXCJ0cmFjZXVyLXJ1bnRpbWVAMC4wLjc5L3NyYy9ydW50aW1lL3BvbHlmaWxscy91dGlscy5qc1wiKSxcbiAgICAgIG1heWJlQWRkRnVuY3Rpb25zID0gJF9fMC5tYXliZUFkZEZ1bmN0aW9ucyxcbiAgICAgIHJlZ2lzdGVyUG9seWZpbGwgPSAkX18wLnJlZ2lzdGVyUG9seWZpbGw7XG4gIHZhciAkX18xID0gJHRyYWNldXJSdW50aW1lLFxuICAgICAgZGVmaW5lUHJvcGVydHkgPSAkX18xLmRlZmluZVByb3BlcnR5LFxuICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gJF9fMS5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gICAgICBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gJF9fMS5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAgICAgaXNQcml2YXRlTmFtZSA9ICRfXzEuaXNQcml2YXRlTmFtZSxcbiAgICAgIGtleXMgPSAkX18xLmtleXM7XG4gIGZ1bmN0aW9uIGlzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgPT09IHJpZ2h0KVxuICAgICAgcmV0dXJuIGxlZnQgIT09IDAgfHwgMSAvIGxlZnQgPT09IDEgLyByaWdodDtcbiAgICByZXR1cm4gbGVmdCAhPT0gbGVmdCAmJiByaWdodCAhPT0gcmlnaHQ7XG4gIH1cbiAgZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgdmFyIHByb3BzID0gc291cmNlID09IG51bGwgPyBbXSA6IGtleXMoc291cmNlKTtcbiAgICAgIHZhciBwLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgIGZvciAocCA9IDA7IHAgPCBsZW5ndGg7IHArKykge1xuICAgICAgICB2YXIgbmFtZSA9IHByb3BzW3BdO1xuICAgICAgICBpZiAoaXNQcml2YXRlTmFtZShuYW1lKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdGFyZ2V0W25hbWVdID0gc291cmNlW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGZ1bmN0aW9uIG1peGluKHRhcmdldCwgc291cmNlKSB7XG4gICAgdmFyIHByb3BzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2UpO1xuICAgIHZhciBwLFxuICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgZm9yIChwID0gMDsgcCA8IGxlbmd0aDsgcCsrKSB7XG4gICAgICB2YXIgbmFtZSA9IHByb3BzW3BdO1xuICAgICAgaWYgKGlzUHJpdmF0ZU5hbWUobmFtZSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHByb3BzW3BdKTtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcHNbcF0sIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGZ1bmN0aW9uIHBvbHlmaWxsT2JqZWN0KGdsb2JhbCkge1xuICAgIHZhciBPYmplY3QgPSBnbG9iYWwuT2JqZWN0O1xuICAgIG1heWJlQWRkRnVuY3Rpb25zKE9iamVjdCwgWydhc3NpZ24nLCBhc3NpZ24sICdpcycsIGlzLCAnbWl4aW4nLCBtaXhpbl0pO1xuICB9XG4gIHJlZ2lzdGVyUG9seWZpbGwocG9seWZpbGxPYmplY3QpO1xuICByZXR1cm4ge1xuICAgIGdldCBpcygpIHtcbiAgICAgIHJldHVybiBpcztcbiAgICB9LFxuICAgIGdldCBhc3NpZ24oKSB7XG4gICAgICByZXR1cm4gYXNzaWduO1xuICAgIH0sXG4gICAgZ2V0IG1peGluKCkge1xuICAgICAgcmV0dXJuIG1peGluO1xuICAgIH0sXG4gICAgZ2V0IHBvbHlmaWxsT2JqZWN0KCkge1xuICAgICAgcmV0dXJuIHBvbHlmaWxsT2JqZWN0O1xuICAgIH1cbiAgfTtcbn0pO1xuU3lzdGVtLmdldChcInRyYWNldXItcnVudGltZUAwLjAuNzkvc3JjL3J1bnRpbWUvcG9seWZpbGxzL09iamVjdC5qc1wiICsgJycpO1xuU3lzdGVtLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ci1ydW50aW1lQDAuMC43OS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvTnVtYmVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXItcnVudGltZUAwLjAuNzkvc3JjL3J1bnRpbWUvcG9seWZpbGxzL051bWJlci5qc1wiO1xuICB2YXIgJF9fMCA9IFN5c3RlbS5nZXQoXCJ0cmFjZXVyLXJ1bnRpbWVAMC4wLjc5L3NyYy9ydW50aW1lL3BvbHlmaWxscy91dGlscy5qc1wiKSxcbiAgICAgIGlzTnVtYmVyID0gJF9fMC5pc051bWJlcixcbiAgICAgIG1heWJlQWRkQ29uc3RzID0gJF9fMC5tYXliZUFkZENvbnN0cyxcbiAgICAgIG1heWJlQWRkRnVuY3Rpb25zID0gJF9fMC5tYXliZUFkZEZ1bmN0aW9ucyxcbiAgICAgIHJlZ2lzdGVyUG9seWZpbGwgPSAkX18wLnJlZ2lzdGVyUG9seWZpbGwsXG4gICAgICB0b0ludGVnZXIgPSAkX18wLnRvSW50ZWdlcjtcbiAgdmFyICRhYnMgPSBNYXRoLmFicztcbiAgdmFyICRpc0Zpbml0ZSA9IGlzRmluaXRlO1xuICB2YXIgJGlzTmFOID0gaXNOYU47XG4gIHZhciBNQVhfU0FGRV9JTlRFR0VSID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbiAgdmFyIE1JTl9TQUZFX0lOVEVHRVIgPSAtTWF0aC5wb3coMiwgNTMpICsgMTtcbiAgdmFyIEVQU0lMT04gPSBNYXRoLnBvdygyLCAtNTIpO1xuICBmdW5jdGlvbiBOdW1iZXJJc0Zpbml0ZShudW1iZXIpIHtcbiAgICByZXR1cm4gaXNOdW1iZXIobnVtYmVyKSAmJiAkaXNGaW5pdGUobnVtYmVyKTtcbiAgfVxuICA7XG4gIGZ1bmN0aW9uIGlzSW50ZWdlcihudW1iZXIpIHtcbiAgICByZXR1cm4gTnVtYmVySXNGaW5pdGUobnVtYmVyKSAmJiB0b0ludGVnZXIobnVtYmVyKSA9PT0gbnVtYmVyO1xuICB9XG4gIGZ1bmN0aW9uIE51bWJlcklzTmFOKG51bWJlcikge1xuICAgIHJldHVybiBpc051bWJlcihudW1iZXIpICYmICRpc05hTihudW1iZXIpO1xuICB9XG4gIDtcbiAgZnVuY3Rpb24gaXNTYWZlSW50ZWdlcihudW1iZXIpIHtcbiAgICBpZiAoTnVtYmVySXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgdmFyIGludGVncmFsID0gdG9JbnRlZ2VyKG51bWJlcik7XG4gICAgICBpZiAoaW50ZWdyYWwgPT09IG51bWJlcilcbiAgICAgICAgcmV0dXJuICRhYnMoaW50ZWdyYWwpIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBwb2x5ZmlsbE51bWJlcihnbG9iYWwpIHtcbiAgICB2YXIgTnVtYmVyID0gZ2xvYmFsLk51bWJlcjtcbiAgICBtYXliZUFkZENvbnN0cyhOdW1iZXIsIFsnTUFYX1NBRkVfSU5URUdFUicsIE1BWF9TQUZFX0lOVEVHRVIsICdNSU5fU0FGRV9JTlRFR0VSJywgTUlOX1NBRkVfSU5URUdFUiwgJ0VQU0lMT04nLCBFUFNJTE9OXSk7XG4gICAgbWF5YmVBZGRGdW5jdGlvbnMoTnVtYmVyLCBbJ2lzRmluaXRlJywgTnVtYmVySXNGaW5pdGUsICdpc0ludGVnZXInLCBpc0ludGVnZXIsICdpc05hTicsIE51bWJlcklzTmFOLCAnaXNTYWZlSW50ZWdlcicsIGlzU2FmZUludGVnZXJdKTtcbiAgfVxuICByZWdpc3RlclBvbHlmaWxsKHBvbHlmaWxsTnVtYmVyKTtcbiAgcmV0dXJuIHtcbiAgICBnZXQgTUFYX1NBRkVfSU5URUdFUigpIHtcbiAgICAgIHJldHVybiBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH0sXG4gICAgZ2V0IE1JTl9TQUZFX0lOVEVHRVIoKSB7XG4gICAgICByZXR1cm4gTUlOX1NBRkVfSU5URUdFUjtcbiAgICB9LFxuICAgIGdldCBFUFNJTE9OKCkge1xuICAgICAgcmV0dXJuIEVQU0lMT047XG4gICAgfSxcbiAgICBnZXQgaXNGaW5pdGUoKSB7XG4gICAgICByZXR1cm4gTnVtYmVySXNGaW5pdGU7XG4gICAgfSxcbiAgICBnZXQgaXNJbnRlZ2VyKCkge1xuICAgICAgcmV0dXJuIGlzSW50ZWdlcjtcbiAgICB9LFxuICAgIGdldCBpc05hTigpIHtcbiAgICAgIHJldHVybiBOdW1iZXJJc05hTjtcbiAgICB9LFxuICAgIGdldCBpc1NhZmVJbnRlZ2VyKCkge1xuICAgICAgcmV0dXJuIGlzU2FmZUludGVnZXI7XG4gICAgfSxcbiAgICBnZXQgcG9seWZpbGxOdW1iZXIoKSB7XG4gICAgICByZXR1cm4gcG9seWZpbGxOdW1iZXI7XG4gICAgfVxuICB9O1xufSk7XG5TeXN0ZW0uZ2V0KFwidHJhY2V1ci1ydW50aW1lQDAuMC43OS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvTnVtYmVyLmpzXCIgKyAnJyk7XG5TeXN0ZW0ucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyLXJ1bnRpbWVAMC4wLjc5L3NyYy9ydW50aW1lL3BvbHlmaWxscy9wb2x5ZmlsbHMuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ci1ydW50aW1lQDAuMC43OS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvcG9seWZpbGxzLmpzXCI7XG4gIHZhciBwb2x5ZmlsbEFsbCA9IFN5c3RlbS5nZXQoXCJ0cmFjZXVyLXJ1bnRpbWVAMC4wLjc5L3NyYy9ydW50aW1lL3BvbHlmaWxscy91dGlscy5qc1wiKS5wb2x5ZmlsbEFsbDtcbiAgcG9seWZpbGxBbGwoUmVmbGVjdC5nbG9iYWwpO1xuICB2YXIgc2V0dXBHbG9iYWxzID0gJHRyYWNldXJSdW50aW1lLnNldHVwR2xvYmFscztcbiAgJHRyYWNldXJSdW50aW1lLnNldHVwR2xvYmFscyA9IGZ1bmN0aW9uKGdsb2JhbCkge1xuICAgIHNldHVwR2xvYmFscyhnbG9iYWwpO1xuICAgIHBvbHlmaWxsQWxsKGdsb2JhbCk7XG4gIH07XG4gIHJldHVybiB7fTtcbn0pO1xuU3lzdGVtLmdldChcInRyYWNldXItcnVudGltZUAwLjAuNzkvc3JjL3J1bnRpbWUvcG9seWZpbGxzL3BvbHlmaWxscy5qc1wiICsgJycpO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGdsLW1hdHJpeCAtIEhpZ2ggcGVyZm9ybWFuY2UgbWF0cml4IGFuZCB2ZWN0b3Igb3BlcmF0aW9uc1xuICogQGF1dGhvciBCcmFuZG9uIEpvbmVzXG4gKiBAYXV0aG9yIENvbGluIE1hY0tlbnppZSBJVlxuICogQHZlcnNpb24gMi4yLjFcbiAqL1xuXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuXG4oZnVuY3Rpb24oX2dsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgc2hpbSA9IHt9O1xuICBpZiAodHlwZW9mKGV4cG9ydHMpID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICBzaGltLmV4cG9ydHMgPSB7fTtcbiAgICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNoaW0uZXhwb3J0cztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBnbC1tYXRyaXggbGl2ZXMgaW4gYSBicm93c2VyLCBkZWZpbmUgaXRzIG5hbWVzcGFjZXMgaW4gZ2xvYmFsXG4gICAgICBzaGltLmV4cG9ydHMgPSB0eXBlb2Yod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBfZ2xvYmFsO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBnbC1tYXRyaXggbGl2ZXMgaW4gY29tbW9uanMsIGRlZmluZSBpdHMgbmFtZXNwYWNlcyBpbiBleHBvcnRzXG4gICAgc2hpbS5leHBvcnRzID0gZXhwb3J0cztcbiAgfVxuXG4gIChmdW5jdGlvbihleHBvcnRzKSB7XG4gICAgLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuXG5pZighR0xNQVRfRVBTSUxPTikge1xuICAgIHZhciBHTE1BVF9FUFNJTE9OID0gMC4wMDAwMDE7XG59XG5cbmlmKCFHTE1BVF9BUlJBWV9UWVBFKSB7XG4gICAgdmFyIEdMTUFUX0FSUkFZX1RZUEUgPSAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG59XG5cbmlmKCFHTE1BVF9SQU5ET00pIHtcbiAgICB2YXIgR0xNQVRfUkFORE9NID0gTWF0aC5yYW5kb207XG59XG5cbi8qKlxuICogQGNsYXNzIENvbW1vbiB1dGlsaXRpZXNcbiAqIEBuYW1lIGdsTWF0cml4XG4gKi9cbnZhciBnbE1hdHJpeCA9IHt9O1xuXG4vKipcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNpZXNcbiAqXG4gKiBAcGFyYW0ge1R5cGV9IHR5cGUgQXJyYXkgdHlwZSwgc3VjaCBhcyBGbG9hdDMyQXJyYXkgb3IgQXJyYXlcbiAqL1xuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlID0gZnVuY3Rpb24odHlwZSkge1xuICAgIEdMTUFUX0FSUkFZX1RZUEUgPSB0eXBlO1xufVxuXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5nbE1hdHJpeCA9IGdsTWF0cml4O1xufVxuXG52YXIgZGVncmVlID0gTWF0aC5QSSAvIDE4MDtcblxuLyoqXG4qIENvbnZlcnQgRGVncmVlIFRvIFJhZGlhblxuKlxuKiBAcGFyYW0ge051bWJlcn0gQW5nbGUgaW4gRGVncmVlc1xuKi9cbmdsTWF0cml4LnRvUmFkaWFuID0gZnVuY3Rpb24oYSl7XG4gICAgIHJldHVybiBhICogZGVncmVlO1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgMiBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzJcbiAqL1xuXG52YXIgdmVjMiA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzJcbiAqXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbnZlYzIuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDIpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbnZlYzIuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDIpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbnZlYzIuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLnN1YiA9IHZlYzIuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIubXVsID0gdmVjMi5tdWx0aXBseTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLmRpdiA9IHZlYzIuZGl2aWRlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5taW4gPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubWF4ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zY2FsZUFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMyLmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLmRpc3QgPSB2ZWMyLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMi5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zcXJEaXN0ID0gdmVjMi5zcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjMi5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIubGVuID0gdmVjMi5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjMi5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuc3FyTGVuID0gdmVjMi5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubmVnYXRlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeTtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjMi5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzIuY3Jvc3MgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gICAgb3V0WzBdID0gb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIucmFuZG9tID0gZnVuY3Rpb24gKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcbiAgICB2YXIgciA9IEdMTUFUX1JBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHNjYWxlO1xuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogc2NhbGU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0Mn0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQyID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5O1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJkfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDJkID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQzXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0M30gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQzID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bM10gKiB5ICsgbVs2XTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNF0gKiB5ICsgbVs3XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQ0XG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVsxM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzIuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMycyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZWMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdO1xuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMyLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWMyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnKSc7XG59O1xuXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy52ZWMyID0gdmVjMjtcbn1cbjtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogQGNsYXNzIDMgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbmFtZSB2ZWMzXG4gKi9cblxudmFyIHZlYzMgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXG4gKlxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgzKTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbnZlYzMuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbnZlYzMuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMyk7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHksIHopIHtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5zdWIgPSB2ZWMzLnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLm11bCA9IHZlYzMubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5kaXYgPSB2ZWMzLmRpdmlkZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMydzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc2NhbGVBbmRBZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzMuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5kaXN0ID0gdmVjMy5kaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzMuc3F1YXJlZERpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Kno7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5zcXJEaXN0ID0gdmVjMy5zcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjMy5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmxlbiA9IHZlYzMubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbnZlYzMuc3F1YXJlZExlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqejtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5zcXJMZW4gPSB2ZWMzLnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeSArIHoqejtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgICAgIG91dFsyXSA9IGFbMl0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjMy5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuY3Jvc3MgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXTtcblxuICAgIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl07XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yYW5kb20gPSBmdW5jdGlvbiAob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuXG4gICAgdmFyIHIgPSBHTE1BVF9SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gICAgdmFyIHogPSAoR0xNQVRfUkFORE9NKCkgKiAyLjApIC0gMS4wO1xuICAgIHZhciB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wLXoqeikgKiBzY2FsZTtcblxuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlO1xuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlO1xuICAgIG91dFsyXSA9IHogKiBzY2FsZTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdO1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdO1xuICAgIG91dFsyXSA9IG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSB0aGUgM3gzIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnRyYW5zZm9ybU1hdDMgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcbiAgICBvdXRbMF0gPSB4ICogbVswXSArIHkgKiBtWzNdICsgeiAqIG1bNl07XG4gICAgb3V0WzFdID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddO1xuICAgIG91dFsyXSA9IHggKiBtWzJdICsgeSAqIG1bNV0gKyB6ICogbVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBxdWF0XG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy50cmFuc2Zvcm1RdWF0ID0gZnVuY3Rpb24ob3V0LCBhLCBxKSB7XG4gICAgLy8gYmVuY2htYXJrczogaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnNcblxuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICAgIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKlxuKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcbiogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4qIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4qIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuKiBAcmV0dXJucyB7dmVjM30gb3V0XG4qL1xudmVjMy5yb3RhdGVYID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgIHZhciBwID0gW10sIHI9W107XG5cdCAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXHQgIHBbMF0gPSBhWzBdIC0gYlswXTtcblx0ICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuXG5cdCAgLy9wZXJmb3JtIHJvdGF0aW9uXG5cdCAgclswXSA9IHBbMF07XG5cdCAgclsxXSA9IHBbMV0qTWF0aC5jb3MoYykgLSBwWzJdKk1hdGguc2luKGMpO1xuXHQgIHJbMl0gPSBwWzFdKk1hdGguc2luKGMpICsgcFsyXSpNYXRoLmNvcyhjKTtcblxuXHQgIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblx0ICBvdXRbMF0gPSByWzBdICsgYlswXTtcblx0ICBvdXRbMV0gPSByWzFdICsgYlsxXTtcblx0ICBvdXRbMl0gPSByWzJdICsgYlsyXTtcblxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKlxuKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4qIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4qIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuKiBAcmV0dXJucyB7dmVjM30gb3V0XG4qL1xudmVjMy5yb3RhdGVZID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgXHR2YXIgcCA9IFtdLCByPVtdO1xuICBcdC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgXHRwWzBdID0gYVswXSAtIGJbMF07XG4gIFx0cFsxXSA9IGFbMV0gLSBiWzFdO1xuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcbiAgXG4gIFx0Ly9wZXJmb3JtIHJvdGF0aW9uXG4gIFx0clswXSA9IHBbMl0qTWF0aC5zaW4oYykgKyBwWzBdKk1hdGguY29zKGMpO1xuICBcdHJbMV0gPSBwWzFdO1xuICBcdHJbMl0gPSBwWzJdKk1hdGguY29zKGMpIC0gcFswXSpNYXRoLnNpbihjKTtcbiAgXG4gIFx0Ly90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICBcdG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBcdG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBcdG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICBcbiAgXHRyZXR1cm4gb3V0O1xufTtcblxuLypcbiogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXG4qIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4qIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiogQHJldHVybnMge3ZlYzN9IG91dFxuKi9cbnZlYzMucm90YXRlWiA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgYyl7XG4gIFx0dmFyIHAgPSBbXSwgcj1bXTtcbiAgXHQvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIFx0cFswXSA9IGFbMF0gLSBiWzBdO1xuICBcdHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgXHRwWzJdID0gYVsyXSAtIGJbMl07XG4gIFxuICBcdC8vcGVyZm9ybSByb3RhdGlvblxuICBcdHJbMF0gPSBwWzBdKk1hdGguY29zKGMpIC0gcFsxXSpNYXRoLnNpbihjKTtcbiAgXHRyWzFdID0gcFswXSpNYXRoLnNpbihjKSArIHBbMV0qTWF0aC5jb3MoYyk7XG4gIFx0clsyXSA9IHBbMl07XG4gIFxuICBcdC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgXHRvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgXHRvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgXHRvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgXG4gIFx0cmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzNzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzMuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZWMgPSB2ZWMzLmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdOyB2ZWNbMl0gPSBhW2krMl07XG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgICAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTsgYVtpKzJdID0gdmVjWzJdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjMy5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAndmVjMygnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnKSc7XG59O1xuXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy52ZWMzID0gdmVjMztcbn1cbjtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogQGNsYXNzIDQgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbmFtZSB2ZWM0XG4gKi9cblxudmFyIHZlYzQgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWM0XG4gKlxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xudmVjNC5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xudmVjNC5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSwgeiwgdykge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWM0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5LCB6LCB3KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgb3V0WzNdID0gdztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSArIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5zdWIgPSB2ZWM0LnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gKiBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0Lm11bCA9IHZlYzQubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLyBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5kaXYgPSB2ZWM0LmRpdmlkZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gICAgb3V0WzNdID0gTWF0aC5taW4oYVszXSwgYlszXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICAgIG91dFszXSA9IE1hdGgubWF4KGFbM10sIGJbM10pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzQgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgb3V0WzNdID0gYVszXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjNCdzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc2NhbGVBbmRBZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSk7XG4gICAgb3V0WzNdID0gYVszXSArIChiWzNdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWM0LmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdLFxuICAgICAgICB3ID0gYlszXSAtIGFbM107XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnogKyB3KncpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5kaXN0ID0gdmVjNC5kaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzQuc3F1YXJlZERpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdLFxuICAgICAgICB3ID0gYlszXSAtIGFbM107XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqeiArIHcqdztcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LnNxckRpc3QgPSB2ZWM0LnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWM0Lmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBhWzNdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6ICsgdyp3KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LmxlbiA9IHZlYzQubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbnZlYzQuc3F1YXJlZExlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBhWzNdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuc3FyTGVuID0gdmVjNC5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubmVnYXRlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgb3V0WzNdID0gLWFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICB2YXIgbGVuID0geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgICAgICAgb3V0WzJdID0gYVsyXSAqIGxlbjtcbiAgICAgICAgb3V0WzNdID0gYVszXSAqIGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG52ZWM0LmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXSArIGFbM10gKiBiWzNdO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5sZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXSxcbiAgICAgICAgYXogPSBhWzJdLFxuICAgICAgICBhdyA9IGFbM107XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gICAgb3V0WzNdID0gYXcgKyB0ICogKGJbM10gLSBhdyk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5yYW5kb20gPSBmdW5jdGlvbiAob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuXG4gICAgLy9UT0RPOiBUaGlzIGlzIGEgcHJldHR5IGF3ZnVsIHdheSBvZiBkb2luZyB0aGlzLiBGaW5kIHNvbWV0aGluZyBiZXR0ZXIuXG4gICAgb3V0WzBdID0gR0xNQVRfUkFORE9NKCk7XG4gICAgb3V0WzFdID0gR0xNQVRfUkFORE9NKCk7XG4gICAgb3V0WzJdID0gR0xNQVRfUkFORE9NKCk7XG4gICAgb3V0WzNdID0gR0xNQVRfUkFORE9NKCk7XG4gICAgdmVjNC5ub3JtYWxpemUob3V0LCBvdXQpO1xuICAgIHZlYzQuc2NhbGUob3V0LCBvdXQsIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBtYXQ0LlxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC50cmFuc2Zvcm1NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sIHcgPSBhWzNdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdICogdztcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSAqIHc7XG4gICAgb3V0WzJdID0gbVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdICogdztcbiAgICBvdXRbM10gPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV0gKiB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnRyYW5zZm9ybVF1YXQgPSBmdW5jdGlvbihvdXQsIGEsIHEpIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdLFxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gICAgICAgIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5LFxuICAgICAgICBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogeixcbiAgICAgICAgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHgsXG4gICAgICAgIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gICAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjNHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjNC4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzJzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LmZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlYyA9IHZlYzQuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSA0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoY291bnQpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07IHZlY1syXSA9IGFbaSsyXTsgdmVjWzNdID0gYVtpKzNdO1xuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07IGFbaSsyXSA9IHZlY1syXTsgYVtpKzNdID0gdmVjWzNdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWM0fSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjNC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAndmVjNCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn07XG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLnZlYzQgPSB2ZWM0O1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgMngyIE1hdHJpeFxuICogQG5hbWUgbWF0MlxuICovXG5cbnZhciBtYXQyID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyXG4gKlxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xubWF0Mi5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5tYXQyLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MiB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMSA9IGFbMV07XG4gICAgICAgIG91dFsxXSA9IGFbMl07XG4gICAgICAgIG91dFsyXSA9IGExO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbMl07XG4gICAgICAgIG91dFsyXSA9IGFbMV07XG4gICAgICAgIG91dFszXSA9IGFbM107XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBhMCAqIGEzIC0gYTIgKiBhMTtcblxuICAgIGlmICghZGV0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgXG4gICAgb3V0WzBdID0gIGEzICogZGV0O1xuICAgIG91dFsxXSA9IC1hMSAqIGRldDtcbiAgICBvdXRbMl0gPSAtYTIgKiBkZXQ7XG4gICAgb3V0WzNdID0gIGEwICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBDYWNoaW5nIHRoaXMgdmFsdWUgaXMgbmVzc2VjYXJ5IGlmIG91dCA9PSBhXG4gICAgdmFyIGEwID0gYVswXTtcbiAgICBvdXRbMF0gPSAgYVszXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSAgYTA7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0Mi5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV07XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuICAgIHZhciBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107XG4gICAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gICAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gICAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gICAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDIubXVsID0gbWF0Mi5tdWx0aXBseTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MiBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBhMCAqICBjICsgYTIgKiBzO1xuICAgIG91dFsxXSA9IGExICogIGMgKyBhMyAqIHM7XG4gICAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MiBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKiovXG5tYXQyLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTAgKiB2MDtcbiAgICBvdXRbMV0gPSBhMSAqIHYwO1xuICAgIG91dFsyXSA9IGEyICogdjE7XG4gICAgb3V0WzNdID0gYTMgKiB2MTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gbWF0IG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbm1hdDIuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ21hdDIoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQyLmZyb2IgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikpKVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIEwsIEQgYW5kIFUgbWF0cmljZXMgKExvd2VyIHRyaWFuZ3VsYXIsIERpYWdvbmFsIGFuZCBVcHBlciB0cmlhbmd1bGFyKSBieSBmYWN0b3JpemluZyB0aGUgaW5wdXQgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IEwgdGhlIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4IFxuICogQHBhcmFtIHttYXQyfSBEIHRoZSBkaWFnb25hbCBtYXRyaXggXG4gKiBAcGFyYW0ge21hdDJ9IFUgdGhlIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4IFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBpbnB1dCBtYXRyaXggdG8gZmFjdG9yaXplXG4gKi9cblxubWF0Mi5MRFUgPSBmdW5jdGlvbiAoTCwgRCwgVSwgYSkgeyBcbiAgICBMWzJdID0gYVsyXS9hWzBdOyBcbiAgICBVWzBdID0gYVswXTsgXG4gICAgVVsxXSA9IGFbMV07IFxuICAgIFVbM10gPSBhWzNdIC0gTFsyXSAqIFVbMV07IFxuICAgIHJldHVybiBbTCwgRCwgVV07ICAgICAgIFxufTsgXG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLm1hdDIgPSBtYXQyO1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgMngzIE1hdHJpeFxuICogQG5hbWUgbWF0MmRcbiAqIFxuICogQGRlc2NyaXB0aW9uIFxuICogQSBtYXQyZCBjb250YWlucyBzaXggZWxlbWVudHMgZGVmaW5lZCBhczpcbiAqIDxwcmU+XG4gKiBbYSwgYywgdHgsXG4gKiAgYiwgZCwgdHldXG4gKiA8L3ByZT5cbiAqIFRoaXMgaXMgYSBzaG9ydCBmb3JtIGZvciB0aGUgM3gzIG1hdHJpeDpcbiAqIDxwcmU+XG4gKiBbYSwgYywgdHgsXG4gKiAgYiwgZCwgdHksXG4gKiAgMCwgMCwgMV1cbiAqIDwvcHJlPlxuICogVGhlIGxhc3Qgcm93IGlzIGlnbm9yZWQgc28gdGhlIGFycmF5IGlzIHNob3J0ZXIgYW5kIG9wZXJhdGlvbnMgYXJlIGZhc3Rlci5cbiAqL1xuXG52YXIgbWF0MmQgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJkXG4gKlxuICogQHJldHVybnMge21hdDJkfSBhIG5ldyAyeDMgbWF0cml4XG4gKi9cbm1hdDJkLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg2KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDJkIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxuICovXG5tYXQyZC5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoNik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDJkIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQyZCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGFhID0gYVswXSwgYWIgPSBhWzFdLCBhYyA9IGFbMl0sIGFkID0gYVszXSxcbiAgICAgICAgYXR4ID0gYVs0XSwgYXR5ID0gYVs1XTtcblxuICAgIHZhciBkZXQgPSBhYSAqIGFkIC0gYWIgKiBhYztcbiAgICBpZighZGV0KXtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IGFkICogZGV0O1xuICAgIG91dFsxXSA9IC1hYiAqIGRldDtcbiAgICBvdXRbMl0gPSAtYWMgKiBkZXQ7XG4gICAgb3V0WzNdID0gYWEgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xuICAgIG91dFs1XSA9IChhYiAqIGF0eCAtIGFhICogYXR5KSAqIGRldDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5tYXQyZC5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsxXSAqIGFbMl07XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDJkJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdLCBiNCA9IGJbNF0sIGI1ID0gYls1XTtcbiAgICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcbiAgICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMTtcbiAgICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcbiAgICBvdXRbNF0gPSBhMCAqIGI0ICsgYTIgKiBiNSArIGE0O1xuICAgIG91dFs1XSA9IGExICogYjQgKyBhMyAqIGI1ICsgYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyZC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQyZC5tdWwgPSBtYXQyZC5tdWx0aXBseTtcblxuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQyZCBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHM7XG4gICAgb3V0WzFdID0gYTEgKiAgYyArIGEzICogcztcbiAgICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xuICAgIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gICAgb3V0WzRdID0gYTQ7XG4gICAgb3V0WzVdID0gYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5tYXQyZC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgICBvdXRbMF0gPSBhMCAqIHYwO1xuICAgIG91dFsxXSA9IGExICogdjA7XG4gICAgb3V0WzJdID0gYTIgKiB2MTtcbiAgICBvdXRbM10gPSBhMyAqIHYxO1xuICAgIG91dFs0XSA9IGE0O1xuICAgIG91dFs1XSA9IGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gdHJhbnNsYXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5tYXQyZC50cmFuc2xhdGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTA7XG4gICAgb3V0WzFdID0gYTE7XG4gICAgb3V0WzJdID0gYTI7XG4gICAgb3V0WzNdID0gYTM7XG4gICAgb3V0WzRdID0gYTAgKiB2MCArIGEyICogdjEgKyBhNDtcbiAgICBvdXRbNV0gPSBhMSAqIHYwICsgYTMgKiB2MSArIGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0MmQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ21hdDJkKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBcbiAgICAgICAgICAgICAgICAgICAgYVszXSArICcsICcgKyBhWzRdICsgJywgJyArIGFbNV0gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDJkLmZyb2IgPSBmdW5jdGlvbiAoYSkgeyBcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIDEpKVxufTsgXG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLm1hdDJkID0gbWF0MmQ7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyAzeDMgTWF0cml4XG4gKiBAbmFtZSBtYXQzXG4gKi9cblxudmFyIG1hdDMgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDNcbiAqXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5tYXQzLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg5KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDE7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3BpZXMgdGhlIHVwcGVyLWxlZnQgM3gzIHZhbHVlcyBpbnRvIHRoZSBnaXZlbiBtYXQzLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgM3gzIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhICAgdGhlIHNvdXJjZSA0eDQgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuZnJvbU1hdDQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzRdO1xuICAgIG91dFs0XSA9IGFbNV07XG4gICAgb3V0WzVdID0gYVs2XTtcbiAgICBvdXRbNl0gPSBhWzhdO1xuICAgIG91dFs3XSA9IGFbOV07XG4gICAgb3V0WzhdID0gYVsxMF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcbiAqL1xubWF0My5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoOSk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MyB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMTtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTEyID0gYVs1XTtcbiAgICAgICAgb3V0WzFdID0gYVszXTtcbiAgICAgICAgb3V0WzJdID0gYVs2XTtcbiAgICAgICAgb3V0WzNdID0gYTAxO1xuICAgICAgICBvdXRbNV0gPSBhWzddO1xuICAgICAgICBvdXRbNl0gPSBhMDI7XG4gICAgICAgIG91dFs3XSA9IGExMjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzNdO1xuICAgICAgICBvdXRbMl0gPSBhWzZdO1xuICAgICAgICBvdXRbM10gPSBhWzFdO1xuICAgICAgICBvdXRbNF0gPSBhWzRdO1xuICAgICAgICBvdXRbNV0gPSBhWzddO1xuICAgICAgICBvdXRbNl0gPSBhWzJdO1xuICAgICAgICBvdXRbN10gPSBhWzVdO1xuICAgICAgICBvdXRbOF0gPSBhWzhdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBiMDEgPSBhMjIgKiBhMTEgLSBhMTIgKiBhMjEsXG4gICAgICAgIGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjAsXG4gICAgICAgIGIyMSA9IGEyMSAqIGExMCAtIGExMSAqIGEyMCxcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMTtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IGIwMSAqIGRldDtcbiAgICBvdXRbMV0gPSAoLWEyMiAqIGEwMSArIGEwMiAqIGEyMSkgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBkZXQ7XG4gICAgb3V0WzNdID0gYjExICogZGV0O1xuICAgIG91dFs0XSA9IChhMjIgKiBhMDAgLSBhMDIgKiBhMjApICogZGV0O1xuICAgIG91dFs1XSA9ICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGRldDtcbiAgICBvdXRbNl0gPSBiMjEgKiBkZXQ7XG4gICAgb3V0WzddID0gKC1hMjEgKiBhMDAgKyBhMDEgKiBhMjApICogZGV0O1xuICAgIG91dFs4XSA9IChhMTEgKiBhMDAgLSBhMDEgKiBhMTApICogZGV0O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF07XG5cbiAgICBvdXRbMF0gPSAoYTExICogYTIyIC0gYTEyICogYTIxKTtcbiAgICBvdXRbMV0gPSAoYTAyICogYTIxIC0gYTAxICogYTIyKTtcbiAgICBvdXRbMl0gPSAoYTAxICogYTEyIC0gYTAyICogYTExKTtcbiAgICBvdXRbM10gPSAoYTEyICogYTIwIC0gYTEwICogYTIyKTtcbiAgICBvdXRbNF0gPSAoYTAwICogYTIyIC0gYTAyICogYTIwKTtcbiAgICBvdXRbNV0gPSAoYTAyICogYTEwIC0gYTAwICogYTEyKTtcbiAgICBvdXRbNl0gPSAoYTEwICogYTIxIC0gYTExICogYTIwKTtcbiAgICBvdXRbN10gPSAoYTAxICogYTIwIC0gYTAwICogYTIxKTtcbiAgICBvdXRbOF0gPSAoYTAwICogYTExIC0gYTAxICogYTEwKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0My5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF07XG5cbiAgICByZXR1cm4gYTAwICogKGEyMiAqIGExMSAtIGExMiAqIGEyMSkgKyBhMDEgKiAoLWEyMiAqIGExMCArIGExMiAqIGEyMCkgKyBhMDIgKiAoYTIxICogYTEwIC0gYTExICogYTIwKTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MydzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuXG4gICAgICAgIGIwMCA9IGJbMF0sIGIwMSA9IGJbMV0sIGIwMiA9IGJbMl0sXG4gICAgICAgIGIxMCA9IGJbM10sIGIxMSA9IGJbNF0sIGIxMiA9IGJbNV0sXG4gICAgICAgIGIyMCA9IGJbNl0sIGIyMSA9IGJbN10sIGIyMiA9IGJbOF07XG5cbiAgICBvdXRbMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjA7XG4gICAgb3V0WzFdID0gYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxO1xuICAgIG91dFsyXSA9IGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMjtcblxuICAgIG91dFszXSA9IGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMDtcbiAgICBvdXRbNF0gPSBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjE7XG4gICAgb3V0WzVdID0gYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyO1xuXG4gICAgb3V0WzZdID0gYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwO1xuICAgIG91dFs3XSA9IGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMTtcbiAgICBvdXRbOF0gPSBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDMubXVsID0gbWF0My5tdWx0aXBseTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQzIGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuICAgICAgICB4ID0gdlswXSwgeSA9IHZbMV07XG5cbiAgICBvdXRbMF0gPSBhMDA7XG4gICAgb3V0WzFdID0gYTAxO1xuICAgIG91dFsyXSA9IGEwMjtcblxuICAgIG91dFszXSA9IGExMDtcbiAgICBvdXRbNF0gPSBhMTE7XG4gICAgb3V0WzVdID0gYTEyO1xuXG4gICAgb3V0WzZdID0geCAqIGEwMCArIHkgKiBhMTAgKyBhMjA7XG4gICAgb3V0WzddID0geCAqIGEwMSArIHkgKiBhMTEgKyBhMjE7XG4gICAgb3V0WzhdID0geCAqIGEwMiArIHkgKiBhMTIgKyBhMjI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDMgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBjICogYTAwICsgcyAqIGExMDtcbiAgICBvdXRbMV0gPSBjICogYTAxICsgcyAqIGExMTtcbiAgICBvdXRbMl0gPSBjICogYTAyICsgcyAqIGExMjtcblxuICAgIG91dFszXSA9IGMgKiBhMTAgLSBzICogYTAwO1xuICAgIG91dFs0XSA9IGMgKiBhMTEgLSBzICogYTAxO1xuICAgIG91dFs1XSA9IGMgKiBhMTIgLSBzICogYTAyO1xuXG4gICAgb3V0WzZdID0gYTIwO1xuICAgIG91dFs3XSA9IGEyMTtcbiAgICBvdXRbOF0gPSBhMjI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQzIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqKi9cbm1hdDMuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdO1xuXG4gICAgb3V0WzBdID0geCAqIGFbMF07XG4gICAgb3V0WzFdID0geCAqIGFbMV07XG4gICAgb3V0WzJdID0geCAqIGFbMl07XG5cbiAgICBvdXRbM10gPSB5ICogYVszXTtcbiAgICBvdXRbNF0gPSB5ICogYVs0XTtcbiAgICBvdXRbNV0gPSB5ICogYVs1XTtcblxuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIGZyb20gYSBtYXQyZCBpbnRvIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY29weVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xubWF0My5mcm9tTWF0MmQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gMDtcblxuICAgIG91dFszXSA9IGFbMl07XG4gICAgb3V0WzRdID0gYVszXTtcbiAgICBvdXRbNV0gPSAwO1xuXG4gICAgb3V0WzZdID0gYVs0XTtcbiAgICBvdXRbN10gPSBhWzVdO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHtxdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4qXG4qIEByZXR1cm5zIHttYXQzfSBvdXRcbiovXG5tYXQzLmZyb21RdWF0ID0gZnVuY3Rpb24gKG91dCwgcSkge1xuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeXggPSB5ICogeDIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB6eCA9IHogKiB4MixcbiAgICAgICAgenkgPSB6ICogeTIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gICAgb3V0WzNdID0geXggLSB3ejtcbiAgICBvdXRbNl0gPSB6eCArIHd5O1xuXG4gICAgb3V0WzFdID0geXggKyB3ejtcbiAgICBvdXRbNF0gPSAxIC0geHggLSB6ejtcbiAgICBvdXRbN10gPSB6eSAtIHd4O1xuXG4gICAgb3V0WzJdID0genggLSB3eTtcbiAgICBvdXRbNV0gPSB6eSArIHd4O1xuICAgIG91dFs4XSA9IDEgLSB4eCAtIHl5O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG5vcm1hbCBtYXRyaXggKHRyYW5zcG9zZSBpbnZlcnNlKSBmcm9tIHRoZSA0eDQgbWF0cml4XG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHttYXQ0fSBhIE1hdDQgdG8gZGVyaXZlIHRoZSBub3JtYWwgbWF0cml4IGZyb21cbipcbiogQHJldHVybnMge21hdDN9IG91dFxuKi9cbm1hdDMubm9ybWFsRnJvbU1hdDQgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFsyXSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuXG4gICAgb3V0WzNdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG5cbiAgICBvdXRbNl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0My5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MygnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICsgYVs4XSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDMuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyBNYXRoLnBvdyhhWzZdLCAyKSArIE1hdGgucG93KGFbN10sIDIpICsgTWF0aC5wb3coYVs4XSwgMikpKVxufTtcblxuXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5tYXQzID0gbWF0Mztcbn1cbjtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogQGNsYXNzIDR4NCBNYXRyaXhcbiAqIEBuYW1lIG1hdDRcbiAqL1xuXG52YXIgbWF0NCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0NFxuICpcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbm1hdDQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDE2KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbm1hdDQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDE2KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQ0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIG91dFs5XSA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0NCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICAgICAgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgICAgIG91dFsxXSA9IGFbNF07XG4gICAgICAgIG91dFsyXSA9IGFbOF07XG4gICAgICAgIG91dFszXSA9IGFbMTJdO1xuICAgICAgICBvdXRbNF0gPSBhMDE7XG4gICAgICAgIG91dFs2XSA9IGFbOV07XG4gICAgICAgIG91dFs3XSA9IGFbMTNdO1xuICAgICAgICBvdXRbOF0gPSBhMDI7XG4gICAgICAgIG91dFs5XSA9IGExMjtcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTJdID0gYTAzO1xuICAgICAgICBvdXRbMTNdID0gYTEzO1xuICAgICAgICBvdXRbMTRdID0gYTIzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbNF07XG4gICAgICAgIG91dFsyXSA9IGFbOF07XG4gICAgICAgIG91dFszXSA9IGFbMTJdO1xuICAgICAgICBvdXRbNF0gPSBhWzFdO1xuICAgICAgICBvdXRbNV0gPSBhWzVdO1xuICAgICAgICBvdXRbNl0gPSBhWzldO1xuICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzhdID0gYVsyXTtcbiAgICAgICAgb3V0WzldID0gYVs2XTtcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgICAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgICAgIG91dFsxMl0gPSBhWzNdO1xuICAgICAgICBvdXRbMTNdID0gYVs3XTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTFdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgICBpZiAoIWRldCkgeyBcbiAgICAgICAgcmV0dXJuIG51bGw7IFxuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzExXSA9IChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzE0XSA9IChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0O1xuICAgIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICBvdXRbMF0gID0gIChhMTEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICAgIG91dFsxXSAgPSAtKGEwMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gICAgb3V0WzJdICA9ICAoYTAxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbM10gID0gLShhMDEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs0XSAgPSAtKGExMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gICAgb3V0WzVdICA9ICAoYTAwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgICBvdXRbNl0gID0gLShhMDAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs3XSAgPSAgKGEwMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTEwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzhdICA9ICAoYTEwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpKTtcbiAgICBvdXRbOV0gID0gLShhMDAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkpO1xuICAgIG91dFsxMF0gPSAgKGEwMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gICAgb3V0WzExXSA9IC0oYTAwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgICBvdXRbMTJdID0gLShhMTAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkpO1xuICAgIG91dFsxM10gPSAgKGEwMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSk7XG4gICAgb3V0WzE0XSA9IC0oYTAwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgICBvdXRbMTVdID0gIChhMDAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5tYXQ0LmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgIHJldHVybiBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDQnc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICAgIC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeFxuICAgIHZhciBiMCAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdOyAgXG4gICAgb3V0WzBdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzNdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzRdOyBiMSA9IGJbNV07IGIyID0gYls2XTsgYjMgPSBiWzddO1xuICAgIG91dFs0XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbNV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzZdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFs3XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls4XTsgYjEgPSBiWzldOyBiMiA9IGJbMTBdOyBiMyA9IGJbMTFdO1xuICAgIG91dFs4XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbOV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzEwXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTFdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzEyXTsgYjEgPSBiWzEzXTsgYjIgPSBiWzE0XTsgYjMgPSBiWzE1XTtcbiAgICBvdXRbMTJdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxM10gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzE0XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTVdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQ0Lm11bCA9IG1hdDQubXVsdGlwbHk7XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC50cmFuc2xhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl0sXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjM7XG5cbiAgICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMF0gPSBhMDA7IG91dFsxXSA9IGEwMTsgb3V0WzJdID0gYTAyOyBvdXRbM10gPSBhMDM7XG4gICAgICAgIG91dFs0XSA9IGExMDsgb3V0WzVdID0gYTExOyBvdXRbNl0gPSBhMTI7IG91dFs3XSA9IGExMztcbiAgICAgICAgb3V0WzhdID0gYTIwOyBvdXRbOV0gPSBhMjE7IG91dFsxMF0gPSBhMjI7IG91dFsxMV0gPSBhMjM7XG5cbiAgICAgICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhMDIgKiB4ICsgYTEyICogeSArIGEyMiAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjM1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHt2ZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqKi9cbm1hdDQuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdLCB6ID0gdlsyXTtcblxuICAgIG91dFswXSA9IGFbMF0gKiB4O1xuICAgIG91dFsxXSA9IGFbMV0gKiB4O1xuICAgIG91dFsyXSA9IGFbMl0gKiB4O1xuICAgIG91dFszXSA9IGFbM10gKiB4O1xuICAgIG91dFs0XSA9IGFbNF0gKiB5O1xuICAgIG91dFs1XSA9IGFbNV0gKiB5O1xuICAgIG91dFs2XSA9IGFbNl0gKiB5O1xuICAgIG91dFs3XSA9IGFbN10gKiB5O1xuICAgIG91dFs4XSA9IGFbOF0gKiB6O1xuICAgIG91dFs5XSA9IGFbOV0gKiB6O1xuICAgIG91dFsxMF0gPSBhWzEwXSAqIHo7XG4gICAgb3V0WzExXSA9IGFbMTFdICogejtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gICAgdmFyIHggPSBheGlzWzBdLCB5ID0gYXhpc1sxXSwgeiA9IGF4aXNbMl0sXG4gICAgICAgIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopLFxuICAgICAgICBzLCBjLCB0LFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzLFxuICAgICAgICBiMDAsIGIwMSwgYjAyLFxuICAgICAgICBiMTAsIGIxMSwgYjEyLFxuICAgICAgICBiMjAsIGIyMSwgYjIyO1xuXG4gICAgaWYgKE1hdGguYWJzKGxlbikgPCBHTE1BVF9FUFNJTE9OKSB7IHJldHVybiBudWxsOyB9XG4gICAgXG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4ICo9IGxlbjtcbiAgICB5ICo9IGxlbjtcbiAgICB6ICo9IGxlbjtcblxuICAgIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIHQgPSAxIC0gYztcblxuICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAvLyBDb25zdHJ1Y3QgdGhlIGVsZW1lbnRzIG9mIHRoZSByb3RhdGlvbiBtYXRyaXhcbiAgICBiMDAgPSB4ICogeCAqIHQgKyBjOyBiMDEgPSB5ICogeCAqIHQgKyB6ICogczsgYjAyID0geiAqIHggKiB0IC0geSAqIHM7XG4gICAgYjEwID0geCAqIHkgKiB0IC0geiAqIHM7IGIxMSA9IHkgKiB5ICogdCArIGM7IGIxMiA9IHogKiB5ICogdCArIHggKiBzO1xuICAgIGIyMCA9IHggKiB6ICogdCArIHkgKiBzOyBiMjEgPSB5ICogeiAqIHQgLSB4ICogczsgYjIyID0geiAqIHogKiB0ICsgYztcblxuICAgIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyO1xuICAgIG91dFsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcbiAgICBvdXRbMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDI7XG4gICAgb3V0WzNdID0gYTAzICogYjAwICsgYTEzICogYjAxICsgYTIzICogYjAyO1xuICAgIG91dFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcbiAgICBvdXRbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTI7XG4gICAgb3V0WzZdID0gYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyO1xuICAgIG91dFs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcbiAgICBvdXRbOF0gPSBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjI7XG4gICAgb3V0WzldID0gYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyO1xuICAgIG91dFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gICAgb3V0WzExXSA9IGEwMyAqIGIyMCArIGExMyAqIGIyMSArIGEyMyAqIGIyMjtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlWCA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGExMCA9IGFbNF0sXG4gICAgICAgIGExMSA9IGFbNV0sXG4gICAgICAgIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbMF0gID0gYVswXTtcbiAgICAgICAgb3V0WzFdICA9IGFbMV07XG4gICAgICAgIG91dFsyXSAgPSBhWzJdO1xuICAgICAgICBvdXRbM10gID0gYVszXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbNF0gPSBhMTAgKiBjICsgYTIwICogcztcbiAgICBvdXRbNV0gPSBhMTEgKiBjICsgYTIxICogcztcbiAgICBvdXRbNl0gPSBhMTIgKiBjICsgYTIyICogcztcbiAgICBvdXRbN10gPSBhMTMgKiBjICsgYTIzICogcztcbiAgICBvdXRbOF0gPSBhMjAgKiBjIC0gYTEwICogcztcbiAgICBvdXRbOV0gPSBhMjEgKiBjIC0gYTExICogcztcbiAgICBvdXRbMTBdID0gYTIyICogYyAtIGExMiAqIHM7XG4gICAgb3V0WzExXSA9IGEyMyAqIGMgLSBhMTMgKiBzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGVZID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTAwID0gYVswXSxcbiAgICAgICAgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXSxcbiAgICAgICAgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICAgIG91dFs0XSAgPSBhWzRdO1xuICAgICAgICBvdXRbNV0gID0gYVs1XTtcbiAgICAgICAgb3V0WzZdICA9IGFbNl07XG4gICAgICAgIG91dFs3XSAgPSBhWzddO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGMgLSBhMjAgKiBzO1xuICAgIG91dFsxXSA9IGEwMSAqIGMgLSBhMjEgKiBzO1xuICAgIG91dFsyXSA9IGEwMiAqIGMgLSBhMjIgKiBzO1xuICAgIG91dFszXSA9IGEwMyAqIGMgLSBhMjMgKiBzO1xuICAgIG91dFs4XSA9IGEwMCAqIHMgKyBhMjAgKiBjO1xuICAgIG91dFs5XSA9IGEwMSAqIHMgKyBhMjEgKiBjO1xuICAgIG91dFsxMF0gPSBhMDIgKiBzICsgYTIyICogYztcbiAgICBvdXRbMTFdID0gYTAzICogcyArIGEyMyAqIGM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZVogPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLFxuICAgICAgICBhMTEgPSBhWzVdLFxuICAgICAgICBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgICAgICBvdXRbOF0gID0gYVs4XTtcbiAgICAgICAgb3V0WzldICA9IGFbOV07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTFdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGMgKyBhMTAgKiBzO1xuICAgIG91dFsxXSA9IGEwMSAqIGMgKyBhMTEgKiBzO1xuICAgIG91dFsyXSA9IGEwMiAqIGMgKyBhMTIgKiBzO1xuICAgIG91dFszXSA9IGEwMyAqIGMgKyBhMTMgKiBzO1xuICAgIG91dFs0XSA9IGExMCAqIGMgLSBhMDAgKiBzO1xuICAgIG91dFs1XSA9IGExMSAqIGMgLSBhMDEgKiBzO1xuICAgIG91dFs2XSA9IGExMiAqIGMgLSBhMDIgKiBzO1xuICAgIG91dFs3XSA9IGExMyAqIGMgLSBhMDMgKiBzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24gYW5kIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICB2YXIgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24gPSBmdW5jdGlvbiAob3V0LCBxLCB2KSB7XG4gICAgLy8gUXVhdGVybmlvbiBtYXRoXG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB4eSA9IHggKiB5MixcbiAgICAgICAgeHogPSB4ICogejIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB5eiA9IHkgKiB6MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0gKHl5ICsgenopO1xuICAgIG91dFsxXSA9IHh5ICsgd3o7XG4gICAgb3V0WzJdID0geHogLSB3eTtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHh5IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtICh4eCArIHp6KTtcbiAgICBvdXRbNl0gPSB5eiArIHd4O1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geHogKyB3eTtcbiAgICBvdXRbOV0gPSB5eiAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0gKHh4ICsgeXkpO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSB2WzBdO1xuICAgIG91dFsxM10gPSB2WzFdO1xuICAgIG91dFsxNF0gPSB2WzJdO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG5tYXQ0LmZyb21RdWF0ID0gZnVuY3Rpb24gKG91dCwgcSkge1xuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeXggPSB5ICogeDIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB6eCA9IHogKiB4MixcbiAgICAgICAgenkgPSB6ICogeTIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gICAgb3V0WzFdID0geXggKyB3ejtcbiAgICBvdXRbMl0gPSB6eCAtIHd5O1xuICAgIG91dFszXSA9IDA7XG5cbiAgICBvdXRbNF0gPSB5eCAtIHd6O1xuICAgIG91dFs1XSA9IDEgLSB4eCAtIHp6O1xuICAgIG91dFs2XSA9IHp5ICsgd3g7XG4gICAgb3V0WzddID0gMDtcblxuICAgIG91dFs4XSA9IHp4ICsgd3k7XG4gICAgb3V0WzldID0genkgLSB3eDtcbiAgICBvdXRbMTBdID0gMSAtIHh4IC0geXk7XG4gICAgb3V0WzExXSA9IDA7XG5cbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGZydXN0dW0gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZydXN0dW0gPSBmdW5jdGlvbiAob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICAgIHZhciBybCA9IDEgLyAocmlnaHQgLSBsZWZ0KSxcbiAgICAgICAgdGIgPSAxIC8gKHRvcCAtIGJvdHRvbSksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSAobmVhciAqIDIpICogcmw7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAobmVhciAqIDIpICogdGI7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IChyaWdodCArIGxlZnQpICogcmw7XG4gICAgb3V0WzldID0gKHRvcCArIGJvdHRvbSkgKiB0YjtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzExXSA9IC0xO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAoZmFyICogbmVhciAqIDIpICogbmY7XG4gICAgb3V0WzE1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGZvdnkgVmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IEFzcGVjdCByYXRpby4gdHlwaWNhbGx5IHZpZXdwb3J0IHdpZHRoL2hlaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5wZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uIChvdXQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIGYgPSAxLjAgLyBNYXRoLnRhbihmb3Z5IC8gMiksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSBmIC8gYXNwZWN0O1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gZjtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTFdID0gLTE7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9ICgyICogZmFyICogbmVhcikgKiBuZjtcbiAgICBvdXRbMTVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBvcnRob2dvbmFsIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lm9ydGhvID0gZnVuY3Rpb24gKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgbHIgPSAxIC8gKGxlZnQgLSByaWdodCksXG4gICAgICAgIGJ0ID0gMSAvIChib3R0b20gLSB0b3ApLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gLTIgKiBscjtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IC0yICogYnQ7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMiAqIG5mO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xuICAgIG91dFsxM10gPSAodG9wICsgYm90dG9tKSAqIGJ0O1xuICAgIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBsb29rLWF0IG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBleWUgcG9zaXRpb24sIGZvY2FsIHBvaW50LCBhbmQgdXAgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7dmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7dmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxuICogQHBhcmFtIHt2ZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQubG9va0F0ID0gZnVuY3Rpb24gKG91dCwgZXllLCBjZW50ZXIsIHVwKSB7XG4gICAgdmFyIHgwLCB4MSwgeDIsIHkwLCB5MSwgeTIsIHowLCB6MSwgejIsIGxlbixcbiAgICAgICAgZXlleCA9IGV5ZVswXSxcbiAgICAgICAgZXlleSA9IGV5ZVsxXSxcbiAgICAgICAgZXlleiA9IGV5ZVsyXSxcbiAgICAgICAgdXB4ID0gdXBbMF0sXG4gICAgICAgIHVweSA9IHVwWzFdLFxuICAgICAgICB1cHogPSB1cFsyXSxcbiAgICAgICAgY2VudGVyeCA9IGNlbnRlclswXSxcbiAgICAgICAgY2VudGVyeSA9IGNlbnRlclsxXSxcbiAgICAgICAgY2VudGVyeiA9IGNlbnRlclsyXTtcblxuICAgIGlmIChNYXRoLmFicyhleWV4IC0gY2VudGVyeCkgPCBHTE1BVF9FUFNJTE9OICYmXG4gICAgICAgIE1hdGguYWJzKGV5ZXkgLSBjZW50ZXJ5KSA8IEdMTUFUX0VQU0lMT04gJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleiAtIGNlbnRlcnopIDwgR0xNQVRfRVBTSUxPTikge1xuICAgICAgICByZXR1cm4gbWF0NC5pZGVudGl0eShvdXQpO1xuICAgIH1cblxuICAgIHowID0gZXlleCAtIGNlbnRlcng7XG4gICAgejEgPSBleWV5IC0gY2VudGVyeTtcbiAgICB6MiA9IGV5ZXogLSBjZW50ZXJ6O1xuXG4gICAgbGVuID0gMSAvIE1hdGguc3FydCh6MCAqIHowICsgejEgKiB6MSArIHoyICogejIpO1xuICAgIHowICo9IGxlbjtcbiAgICB6MSAqPSBsZW47XG4gICAgejIgKj0gbGVuO1xuXG4gICAgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICAgIHgxID0gdXB6ICogejAgLSB1cHggKiB6MjtcbiAgICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG4gICAgbGVuID0gTWF0aC5zcXJ0KHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4Mik7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgICAgeDAgPSAwO1xuICAgICAgICB4MSA9IDA7XG4gICAgICAgIHgyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICB4MCAqPSBsZW47XG4gICAgICAgIHgxICo9IGxlbjtcbiAgICAgICAgeDIgKj0gbGVuO1xuICAgIH1cblxuICAgIHkwID0gejEgKiB4MiAtIHoyICogeDE7XG4gICAgeTEgPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgICB5MiA9IHowICogeDEgLSB6MSAqIHgwO1xuXG4gICAgbGVuID0gTWF0aC5zcXJ0KHkwICogeTAgKyB5MSAqIHkxICsgeTIgKiB5Mik7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgICAgeTAgPSAwO1xuICAgICAgICB5MSA9IDA7XG4gICAgICAgIHkyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICB5MCAqPSBsZW47XG4gICAgICAgIHkxICo9IGxlbjtcbiAgICAgICAgeTIgKj0gbGVuO1xuICAgIH1cblxuICAgIG91dFswXSA9IHgwO1xuICAgIG91dFsxXSA9IHkwO1xuICAgIG91dFsyXSA9IHowO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geDE7XG4gICAgb3V0WzVdID0geTE7XG4gICAgb3V0WzZdID0gejE7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4MjtcbiAgICBvdXRbOV0gPSB5MjtcbiAgICBvdXRbMTBdID0gejI7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IC0oeDAgKiBleWV4ICsgeDEgKiBleWV5ICsgeDIgKiBleWV6KTtcbiAgICBvdXRbMTNdID0gLSh5MCAqIGV5ZXggKyB5MSAqIGV5ZXkgKyB5MiAqIGV5ZXopO1xuICAgIG91dFsxNF0gPSAtKHowICogZXlleCArIHoxICogZXlleSArIHoyICogZXlleik7XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gbWF0IG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbm1hdDQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ21hdDQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICBhWzhdICsgJywgJyArIGFbOV0gKyAnLCAnICsgYVsxMF0gKyAnLCAnICsgYVsxMV0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbMTJdICsgJywgJyArIGFbMTNdICsgJywgJyArIGFbMTRdICsgJywgJyArIGFbMTVdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0NC5mcm9iID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIE1hdGgucG93KGFbNl0sIDIpICsgTWF0aC5wb3coYVs2XSwgMikgKyBNYXRoLnBvdyhhWzddLCAyKSArIE1hdGgucG93KGFbOF0sIDIpICsgTWF0aC5wb3coYVs5XSwgMikgKyBNYXRoLnBvdyhhWzEwXSwgMikgKyBNYXRoLnBvdyhhWzExXSwgMikgKyBNYXRoLnBvdyhhWzEyXSwgMikgKyBNYXRoLnBvdyhhWzEzXSwgMikgKyBNYXRoLnBvdyhhWzE0XSwgMikgKyBNYXRoLnBvdyhhWzE1XSwgMikgKSlcbn07XG5cblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMubWF0NCA9IG1hdDQ7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyBRdWF0ZXJuaW9uXG4gKiBAbmFtZSBxdWF0XG4gKi9cblxudmFyIHF1YXQgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IHF1YXRcbiAqXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICovXG5xdWF0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldHMgYSBxdWF0ZXJuaW9uIHRvIHJlcHJlc2VudCB0aGUgc2hvcnRlc3Qgcm90YXRpb24gZnJvbSBvbmVcbiAqIHZlY3RvciB0byBhbm90aGVyLlxuICpcbiAqIEJvdGggdmVjdG9ycyBhcmUgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGluaXRpYWwgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIGRlc3RpbmF0aW9uIHZlY3RvclxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0aW9uVG8gPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRtcHZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIHZhciB4VW5pdFZlYzMgPSB2ZWMzLmZyb21WYWx1ZXMoMSwwLDApO1xuICAgIHZhciB5VW5pdFZlYzMgPSB2ZWMzLmZyb21WYWx1ZXMoMCwxLDApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgICAgICB2YXIgZG90ID0gdmVjMy5kb3QoYSwgYik7XG4gICAgICAgIGlmIChkb3QgPCAtMC45OTk5OTkpIHtcbiAgICAgICAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgeFVuaXRWZWMzLCBhKTtcbiAgICAgICAgICAgIGlmICh2ZWMzLmxlbmd0aCh0bXB2ZWMzKSA8IDAuMDAwMDAxKVxuICAgICAgICAgICAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgeVVuaXRWZWMzLCBhKTtcbiAgICAgICAgICAgIHZlYzMubm9ybWFsaXplKHRtcHZlYzMsIHRtcHZlYzMpO1xuICAgICAgICAgICAgcXVhdC5zZXRBeGlzQW5nbGUob3V0LCB0bXB2ZWMzLCBNYXRoLlBJKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZG90ID4gMC45OTk5OTkpIHtcbiAgICAgICAgICAgIG91dFswXSA9IDA7XG4gICAgICAgICAgICBvdXRbMV0gPSAwO1xuICAgICAgICAgICAgb3V0WzJdID0gMDtcbiAgICAgICAgICAgIG91dFszXSA9IDE7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCBhLCBiKTtcbiAgICAgICAgICAgIG91dFswXSA9IHRtcHZlYzNbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB0bXB2ZWMzWzFdO1xuICAgICAgICAgICAgb3V0WzJdID0gdG1wdmVjM1syXTtcbiAgICAgICAgICAgIG91dFszXSA9IDEgKyBkb3Q7XG4gICAgICAgICAgICByZXR1cm4gcXVhdC5ub3JtYWxpemUob3V0LCBvdXQpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogU2V0cyB0aGUgc3BlY2lmaWVkIHF1YXRlcm5pb24gd2l0aCB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW5cbiAqIGF4ZXMuIEVhY2ggYXhpcyBpcyBhIHZlYzMgYW5kIGlzIGV4cGVjdGVkIHRvIGJlIHVuaXQgbGVuZ3RoIGFuZFxuICogcGVycGVuZGljdWxhciB0byBhbGwgb3RoZXIgc3BlY2lmaWVkIGF4ZXMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSB2aWV3ICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgdmlld2luZyBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7dmVjM30gcmlnaHQgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsIFwicmlnaHRcIiBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7dmVjM30gdXAgICAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsIFwidXBcIiBkaXJlY3Rpb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5zZXRBeGVzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXRyID0gbWF0My5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihvdXQsIHZpZXcsIHJpZ2h0LCB1cCkge1xuICAgICAgICBtYXRyWzBdID0gcmlnaHRbMF07XG4gICAgICAgIG1hdHJbM10gPSByaWdodFsxXTtcbiAgICAgICAgbWF0cls2XSA9IHJpZ2h0WzJdO1xuXG4gICAgICAgIG1hdHJbMV0gPSB1cFswXTtcbiAgICAgICAgbWF0cls0XSA9IHVwWzFdO1xuICAgICAgICBtYXRyWzddID0gdXBbMl07XG5cbiAgICAgICAgbWF0clsyXSA9IC12aWV3WzBdO1xuICAgICAgICBtYXRyWzVdID0gLXZpZXdbMV07XG4gICAgICAgIG1hdHJbOF0gPSAtdmlld1syXTtcblxuICAgICAgICByZXR1cm4gcXVhdC5ub3JtYWxpemUob3V0LCBxdWF0LmZyb21NYXQzKG91dCwgbWF0cikpO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdGVybmlvbiB0byBjbG9uZVxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmNsb25lID0gdmVjNC5jbG9uZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5mcm9tVmFsdWVzID0gdmVjNC5mcm9tVmFsdWVzO1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBxdWF0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgc291cmNlIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmNvcHkgPSB2ZWM0LmNvcHk7XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgcXVhdCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc2V0ID0gdmVjNC5zZXQ7XG5cbi8qKlxuICogU2V0IGEgcXVhdCB0byB0aGUgaWRlbnRpdHkgcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXRzIGEgcXVhdCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhbmQgcm90YXRpb24gYXhpcyxcbiAqIHRoZW4gcmV0dXJucyBpdC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyBhcm91bmQgd2hpY2ggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiovXG5xdWF0LnNldEF4aXNBbmdsZSA9IGZ1bmN0aW9uKG91dCwgYXhpcywgcmFkKSB7XG4gICAgcmFkID0gcmFkICogMC41O1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBvdXRbMF0gPSBzICogYXhpc1swXTtcbiAgICBvdXRbMV0gPSBzICogYXhpc1sxXTtcbiAgICBvdXRbMl0gPSBzICogYXhpc1syXTtcbiAgICBvdXRbM10gPSBNYXRoLmNvcyhyYWQpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5hZGQgPSB2ZWM0LmFkZDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0Lm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXSwgYncgPSBiWzNdO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieTtcbiAgICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYng7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5tdWwgPSBxdWF0Lm11bHRpcGx5O1xuXG4vKipcbiAqIFNjYWxlcyBhIHF1YXQgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc2NhbGUgPSB2ZWM0LnNjYWxlO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGVYID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTsgXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBheiAqIGJ4O1xuICAgIG91dFsyXSA9IGF6ICogYncgLSBheSAqIGJ4O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWSBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGVZID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTsgXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieSA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGF4ICogYncgLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5O1xuICAgIG91dFsyXSA9IGF6ICogYncgKyBheCAqIGJ5O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheSAqIGJ5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWiBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGVaID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTsgXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieiA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGF4ICogYncgKyBheSAqIGJ6O1xuICAgIG91dFsxXSA9IGF5ICogYncgLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheiAqIGJ6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIFcgY29tcG9uZW50IG9mIGEgcXVhdCBmcm9tIHRoZSBYLCBZLCBhbmQgWiBjb21wb25lbnRzLlxuICogQXNzdW1lcyB0aGF0IHF1YXRlcm5pb24gaXMgMSB1bml0IGluIGxlbmd0aC5cbiAqIEFueSBleGlzdGluZyBXIGNvbXBvbmVudCB3aWxsIGJlIGlnbm9yZWQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgVyBjb21wb25lbnQgb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5jYWxjdWxhdGVXID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuXG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgb3V0WzNdID0gLU1hdGguc3FydChNYXRoLmFicygxLjAgLSB4ICogeCAtIHkgKiB5IC0geiAqIHopKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5kb3QgPSB2ZWM0LmRvdDtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5sZXJwID0gdmVjNC5sZXJwO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnNsZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIC8vIGJlbmNobWFya3M6XG4gICAgLy8gICAgaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi1zbGVycC1pbXBsZW1lbnRhdGlvbnNcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl0sIGJ3ID0gYlszXTtcblxuICAgIHZhciAgICAgICAgb21lZ2EsIGNvc29tLCBzaW5vbSwgc2NhbGUwLCBzY2FsZTE7XG5cbiAgICAvLyBjYWxjIGNvc2luZVxuICAgIGNvc29tID0gYXggKiBieCArIGF5ICogYnkgKyBheiAqIGJ6ICsgYXcgKiBidztcbiAgICAvLyBhZGp1c3Qgc2lnbnMgKGlmIG5lY2Vzc2FyeSlcbiAgICBpZiAoIGNvc29tIDwgMC4wICkge1xuICAgICAgICBjb3NvbSA9IC1jb3NvbTtcbiAgICAgICAgYnggPSAtIGJ4O1xuICAgICAgICBieSA9IC0gYnk7XG4gICAgICAgIGJ6ID0gLSBiejtcbiAgICAgICAgYncgPSAtIGJ3O1xuICAgIH1cbiAgICAvLyBjYWxjdWxhdGUgY29lZmZpY2llbnRzXG4gICAgaWYgKCAoMS4wIC0gY29zb20pID4gMC4wMDAwMDEgKSB7XG4gICAgICAgIC8vIHN0YW5kYXJkIGNhc2UgKHNsZXJwKVxuICAgICAgICBvbWVnYSAgPSBNYXRoLmFjb3MoY29zb20pO1xuICAgICAgICBzaW5vbSAgPSBNYXRoLnNpbihvbWVnYSk7XG4gICAgICAgIHNjYWxlMCA9IE1hdGguc2luKCgxLjAgLSB0KSAqIG9tZWdhKSAvIHNpbm9tO1xuICAgICAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207XG4gICAgfSBlbHNlIHsgICAgICAgIFxuICAgICAgICAvLyBcImZyb21cIiBhbmQgXCJ0b1wiIHF1YXRlcm5pb25zIGFyZSB2ZXJ5IGNsb3NlIFxuICAgICAgICAvLyAgLi4uIHNvIHdlIGNhbiBkbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICAgIHNjYWxlMCA9IDEuMCAtIHQ7XG4gICAgICAgIHNjYWxlMSA9IHQ7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZXNcbiAgICBvdXRbMF0gPSBzY2FsZTAgKiBheCArIHNjYWxlMSAqIGJ4O1xuICAgIG91dFsxXSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XG4gICAgb3V0WzJdID0gc2NhbGUwICogYXogKyBzY2FsZTEgKiBiejtcbiAgICBvdXRbM10gPSBzY2FsZTAgKiBhdyArIHNjYWxlMSAqIGJ3O1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGludmVyc2Ugb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgaW52ZXJzZSBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIGRvdCA9IGEwKmEwICsgYTEqYTEgKyBhMiphMiArIGEzKmEzLFxuICAgICAgICBpbnZEb3QgPSBkb3QgPyAxLjAvZG90IDogMDtcbiAgICBcbiAgICAvLyBUT0RPOiBXb3VsZCBiZSBmYXN0ZXIgdG8gcmV0dXJuIFswLDAsMCwwXSBpbW1lZGlhdGVseSBpZiBkb3QgPT0gMFxuXG4gICAgb3V0WzBdID0gLWEwKmludkRvdDtcbiAgICBvdXRbMV0gPSAtYTEqaW52RG90O1xuICAgIG91dFsyXSA9IC1hMippbnZEb3Q7XG4gICAgb3V0WzNdID0gYTMqaW52RG90O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGNvbmp1Z2F0ZSBvZiBhIHF1YXRcbiAqIElmIHRoZSBxdWF0ZXJuaW9uIGlzIG5vcm1hbGl6ZWQsIHRoaXMgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW4gcXVhdC5pbnZlcnNlIGFuZCBwcm9kdWNlcyB0aGUgc2FtZSByZXN1bHQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgY29uanVnYXRlIG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuY29uanVnYXRlID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0Lmxlbmd0aCA9IHZlYzQubGVuZ3RoO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5sZW4gPSBxdWF0Lmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc3F1YXJlZExlbmd0aCA9IHZlYzQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNxckxlbiA9IHF1YXQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdGVybmlvbiB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0Lm5vcm1hbGl6ZSA9IHZlYzQubm9ybWFsaXplO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIDN4MyByb3RhdGlvbiBtYXRyaXguXG4gKlxuICogTk9URTogVGhlIHJlc3VsdGFudCBxdWF0ZXJuaW9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyB5b3Ugc2hvdWxkIGJlIHN1cmVcbiAqIHRvIHJlbm9ybWFsaXplIHRoZSBxdWF0ZXJuaW9uIHlvdXJzZWxmIHdoZXJlIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7bWF0M30gbSByb3RhdGlvbiBtYXRyaXhcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmZyb21NYXQzID0gZnVuY3Rpb24ob3V0LCBtKSB7XG4gICAgLy8gQWxnb3JpdGhtIGluIEtlbiBTaG9lbWFrZSdzIGFydGljbGUgaW4gMTk4NyBTSUdHUkFQSCBjb3Vyc2Ugbm90ZXNcbiAgICAvLyBhcnRpY2xlIFwiUXVhdGVybmlvbiBDYWxjdWx1cyBhbmQgRmFzdCBBbmltYXRpb25cIi5cbiAgICB2YXIgZlRyYWNlID0gbVswXSArIG1bNF0gKyBtWzhdO1xuICAgIHZhciBmUm9vdDtcblxuICAgIGlmICggZlRyYWNlID4gMC4wICkge1xuICAgICAgICAvLyB8d3wgPiAxLzIsIG1heSBhcyB3ZWxsIGNob29zZSB3ID4gMS8yXG4gICAgICAgIGZSb290ID0gTWF0aC5zcXJ0KGZUcmFjZSArIDEuMCk7ICAvLyAyd1xuICAgICAgICBvdXRbM10gPSAwLjUgKiBmUm9vdDtcbiAgICAgICAgZlJvb3QgPSAwLjUvZlJvb3Q7ICAvLyAxLyg0dylcbiAgICAgICAgb3V0WzBdID0gKG1bN10tbVs1XSkqZlJvb3Q7XG4gICAgICAgIG91dFsxXSA9IChtWzJdLW1bNl0pKmZSb290O1xuICAgICAgICBvdXRbMl0gPSAobVszXS1tWzFdKSpmUm9vdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB8d3wgPD0gMS8yXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgaWYgKCBtWzRdID4gbVswXSApXG4gICAgICAgICAgaSA9IDE7XG4gICAgICAgIGlmICggbVs4XSA+IG1baSozK2ldIClcbiAgICAgICAgICBpID0gMjtcbiAgICAgICAgdmFyIGogPSAoaSsxKSUzO1xuICAgICAgICB2YXIgayA9IChpKzIpJTM7XG4gICAgICAgIFxuICAgICAgICBmUm9vdCA9IE1hdGguc3FydChtW2kqMytpXS1tW2oqMytqXS1tW2sqMytrXSArIDEuMCk7XG4gICAgICAgIG91dFtpXSA9IDAuNSAqIGZSb290O1xuICAgICAgICBmUm9vdCA9IDAuNSAvIGZSb290O1xuICAgICAgICBvdXRbM10gPSAobVtrKjMral0gLSBtW2oqMytrXSkgKiBmUm9vdDtcbiAgICAgICAgb3V0W2pdID0gKG1baiozK2ldICsgbVtpKjMral0pICogZlJvb3Q7XG4gICAgICAgIG91dFtrXSA9IChtW2sqMytpXSArIG1baSozK2tdKSAqIGZSb290O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgcXVhdGVuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xucXVhdC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAncXVhdCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn07XG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLnF1YXQgPSBxdWF0O1xufVxuO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4gIH0pKHNoaW0uZXhwb3J0cyk7XG59KSh0aGlzKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgeWFtbCA9IHJlcXVpcmUoJy4vbGliL2pzLXlhbWwuanMnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHlhbWw7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGxvYWRlciA9IHJlcXVpcmUoJy4vanMteWFtbC9sb2FkZXInKTtcbnZhciBkdW1wZXIgPSByZXF1aXJlKCcuL2pzLXlhbWwvZHVtcGVyJyk7XG5cblxuZnVuY3Rpb24gZGVwcmVjYXRlZChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiAnICsgbmFtZSArICcgaXMgZGVwcmVjYXRlZCBhbmQgY2Fubm90IGJlIHVzZWQuJyk7XG4gIH07XG59XG5cblxubW9kdWxlLmV4cG9ydHMuVHlwZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC90eXBlJyk7XG5tb2R1bGUuZXhwb3J0cy5TY2hlbWEgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYScpO1xubW9kdWxlLmV4cG9ydHMuRkFJTFNBRkVfU0NIRU1BICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZmFpbHNhZmUnKTtcbm1vZHVsZS5leHBvcnRzLkpTT05fU0NIRU1BICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2pzb24nKTtcbm1vZHVsZS5leHBvcnRzLkNPUkVfU0NIRU1BICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfU0FGRV9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9GVUxMX1NDSEVNQSA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XG5tb2R1bGUuZXhwb3J0cy5sb2FkICAgICAgICAgICAgICAgID0gbG9hZGVyLmxvYWQ7XG5tb2R1bGUuZXhwb3J0cy5sb2FkQWxsICAgICAgICAgICAgID0gbG9hZGVyLmxvYWRBbGw7XG5tb2R1bGUuZXhwb3J0cy5zYWZlTG9hZCAgICAgICAgICAgID0gbG9hZGVyLnNhZmVMb2FkO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWRBbGwgICAgICAgICA9IGxvYWRlci5zYWZlTG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLmR1bXAgICAgICAgICAgICAgICAgPSBkdW1wZXIuZHVtcDtcbm1vZHVsZS5leHBvcnRzLnNhZmVEdW1wICAgICAgICAgICAgPSBkdW1wZXIuc2FmZUR1bXA7XG5tb2R1bGUuZXhwb3J0cy5ZQU1MRXhjZXB0aW9uICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL2V4Y2VwdGlvbicpO1xuXG4vLyBEZXByZWNhcmVkIHNjaGVtYSBuYW1lcyBmcm9tIEpTLVlBTUwgMi4wLnhcbm1vZHVsZS5leHBvcnRzLk1JTklNQUxfU0NIRU1BID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9mYWlsc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuU0FGRV9TQ0hFTUEgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xuXG4vLyBEZXByZWNhdGVkIGZ1bmN0aW9ucyBmcm9tIEpTLVlBTUwgMS54Lnhcbm1vZHVsZS5leHBvcnRzLnNjYW4gICAgICAgICAgID0gZGVwcmVjYXRlZCgnc2NhbicpO1xubW9kdWxlLmV4cG9ydHMucGFyc2UgICAgICAgICAgPSBkZXByZWNhdGVkKCdwYXJzZScpO1xubW9kdWxlLmV4cG9ydHMuY29tcG9zZSAgICAgICAgPSBkZXByZWNhdGVkKCdjb21wb3NlJyk7XG5tb2R1bGUuZXhwb3J0cy5hZGRDb25zdHJ1Y3RvciA9IGRlcHJlY2F0ZWQoJ2FkZENvbnN0cnVjdG9yJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gaXNOb3RoaW5nKHN1YmplY3QpIHtcbiAgcmV0dXJuICh1bmRlZmluZWQgPT09IHN1YmplY3QpIHx8IChudWxsID09PSBzdWJqZWN0KTtcbn1cblxuXG5mdW5jdGlvbiBpc09iamVjdChzdWJqZWN0KSB7XG4gIHJldHVybiAoJ29iamVjdCcgPT09IHR5cGVvZiBzdWJqZWN0KSAmJiAobnVsbCAhPT0gc3ViamVjdCk7XG59XG5cblxuZnVuY3Rpb24gdG9BcnJheShzZXF1ZW5jZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzZXF1ZW5jZSkpIHtcbiAgICByZXR1cm4gc2VxdWVuY2U7XG4gIH0gZWxzZSBpZiAoaXNOb3RoaW5nKHNlcXVlbmNlKSkge1xuICAgIHJldHVybiBbXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gWyBzZXF1ZW5jZSBdO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gIHZhciBpbmRleCwgbGVuZ3RoLCBrZXksIHNvdXJjZUtleXM7XG5cbiAgaWYgKHNvdXJjZSkge1xuICAgIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHNvdXJjZUtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAga2V5ID0gc291cmNlS2V5c1tpbmRleF07XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cblxuZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgY291bnQpIHtcbiAgdmFyIHJlc3VsdCA9ICcnLCBjeWNsZTtcblxuICBmb3IgKGN5Y2xlID0gMDsgY3ljbGUgPCBjb3VudDsgY3ljbGUgKz0gMSkge1xuICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIGlzTmVnYXRpdmVaZXJvKG51bWJlcikge1xuICByZXR1cm4gKDAgPT09IG51bWJlcikgJiYgKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA9PT0gMSAvIG51bWJlcik7XG59XG5cblxubW9kdWxlLmV4cG9ydHMuaXNOb3RoaW5nICAgICAgPSBpc05vdGhpbmc7XG5tb2R1bGUuZXhwb3J0cy5pc09iamVjdCAgICAgICA9IGlzT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMudG9BcnJheSAgICAgICAgPSB0b0FycmF5O1xubW9kdWxlLmV4cG9ydHMucmVwZWF0ICAgICAgICAgPSByZXBlYXQ7XG5tb2R1bGUuZXhwb3J0cy5pc05lZ2F0aXZlWmVybyA9IGlzTmVnYXRpdmVaZXJvO1xubW9kdWxlLmV4cG9ydHMuZXh0ZW5kICAgICAgICAgPSBleHRlbmQ7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGNvbW1vbiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIFlBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xudmFyIERFRkFVTFRfRlVMTF9TQ0hFTUEgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0X2Z1bGwnKTtcbnZhciBERUZBVUxUX1NBRkVfU0NIRU1BID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdF9zYWZlJyk7XG5cblxudmFyIF90b1N0cmluZyAgICAgICA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuXG52YXIgQ0hBUl9UQUIgICAgICAgICAgICAgICAgICA9IDB4MDk7IC8qIFRhYiAqL1xudmFyIENIQVJfTElORV9GRUVEICAgICAgICAgICAgPSAweDBBOyAvKiBMRiAqL1xudmFyIENIQVJfQ0FSUklBR0VfUkVUVVJOICAgICAgPSAweDBEOyAvKiBDUiAqL1xudmFyIENIQVJfU1BBQ0UgICAgICAgICAgICAgICAgPSAweDIwOyAvKiBTcGFjZSAqL1xudmFyIENIQVJfRVhDTEFNQVRJT04gICAgICAgICAgPSAweDIxOyAvKiAhICovXG52YXIgQ0hBUl9ET1VCTEVfUVVPVEUgICAgICAgICA9IDB4MjI7IC8qIFwiICovXG52YXIgQ0hBUl9TSEFSUCAgICAgICAgICAgICAgICA9IDB4MjM7IC8qICMgKi9cbnZhciBDSEFSX1BFUkNFTlQgICAgICAgICAgICAgID0gMHgyNTsgLyogJSAqL1xudmFyIENIQVJfQU1QRVJTQU5EICAgICAgICAgICAgPSAweDI2OyAvKiAmICovXG52YXIgQ0hBUl9TSU5HTEVfUVVPVEUgICAgICAgICA9IDB4Mjc7IC8qICcgKi9cbnZhciBDSEFSX0FTVEVSSVNLICAgICAgICAgICAgID0gMHgyQTsgLyogKiAqL1xudmFyIENIQVJfQ09NTUEgICAgICAgICAgICAgICAgPSAweDJDOyAvKiAsICovXG52YXIgQ0hBUl9NSU5VUyAgICAgICAgICAgICAgICA9IDB4MkQ7IC8qIC0gKi9cbnZhciBDSEFSX0NPTE9OICAgICAgICAgICAgICAgID0gMHgzQTsgLyogOiAqL1xudmFyIENIQVJfR1JFQVRFUl9USEFOICAgICAgICAgPSAweDNFOyAvKiA+ICovXG52YXIgQ0hBUl9RVUVTVElPTiAgICAgICAgICAgICA9IDB4M0Y7IC8qID8gKi9cbnZhciBDSEFSX0NPTU1FUkNJQUxfQVQgICAgICAgID0gMHg0MDsgLyogQCAqL1xudmFyIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCAgPSAweDVCOyAvKiBbICovXG52YXIgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCA9IDB4NUQ7IC8qIF0gKi9cbnZhciBDSEFSX0dSQVZFX0FDQ0VOVCAgICAgICAgID0gMHg2MDsgLyogYCAqL1xudmFyIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUICAgPSAweDdCOyAvKiB7ICovXG52YXIgQ0hBUl9WRVJUSUNBTF9MSU5FICAgICAgICA9IDB4N0M7IC8qIHwgKi9cbnZhciBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgID0gMHg3RDsgLyogfSAqL1xuXG5cbnZhciBFU0NBUEVfU0VRVUVOQ0VTID0ge307XG5cbkVTQ0FQRV9TRVFVRU5DRVNbMHgwMF0gICA9ICdcXFxcMCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDddICAgPSAnXFxcXGEnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA4XSAgID0gJ1xcXFxiJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOV0gICA9ICdcXFxcdCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MEFdICAgPSAnXFxcXG4nO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBCXSAgID0gJ1xcXFx2JztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQ10gICA9ICdcXFxcZic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MERdICAgPSAnXFxcXHInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDFCXSAgID0gJ1xcXFxlJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMl0gICA9ICdcXFxcXCInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDVDXSAgID0gJ1xcXFxcXFxcJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHg4NV0gICA9ICdcXFxcTic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4QTBdICAgPSAnXFxcXF8nO1xuRVNDQVBFX1NFUVVFTkNFU1sweDIwMjhdID0gJ1xcXFxMJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI5XSA9ICdcXFxcUCc7XG5cblxudmFyIERFUFJFQ0FURURfQk9PTEVBTlNfU1lOVEFYID0gW1xuICAneScsICdZJywgJ3llcycsICdZZXMnLCAnWUVTJywgJ29uJywgJ09uJywgJ09OJyxcbiAgJ24nLCAnTicsICdubycsICdObycsICdOTycsICdvZmYnLCAnT2ZmJywgJ09GRidcbl07XG5cblxuZnVuY3Rpb24gY29tcGlsZVN0eWxlTWFwKHNjaGVtYSwgbWFwKSB7XG4gIHZhciByZXN1bHQsIGtleXMsIGluZGV4LCBsZW5ndGgsIHRhZywgc3R5bGUsIHR5cGU7XG5cbiAgaWYgKG51bGwgPT09IG1hcCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHJlc3VsdCA9IHt9O1xuICBrZXlzID0gT2JqZWN0LmtleXMobWFwKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdGFnID0ga2V5c1tpbmRleF07XG4gICAgc3R5bGUgPSBTdHJpbmcobWFwW3RhZ10pO1xuXG4gICAgaWYgKCchIScgPT09IHRhZy5zbGljZSgwLCAyKSkge1xuICAgICAgdGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOicgKyB0YWcuc2xpY2UoMik7XG4gICAgfVxuXG4gICAgdHlwZSA9IHNjaGVtYS5jb21waWxlZFR5cGVNYXBbdGFnXTtcblxuICAgIGlmICh0eXBlICYmIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHR5cGUuc3R5bGVBbGlhc2VzLCBzdHlsZSkpIHtcbiAgICAgIHN0eWxlID0gdHlwZS5zdHlsZUFsaWFzZXNbc3R5bGVdO1xuICAgIH1cblxuICAgIHJlc3VsdFt0YWddID0gc3R5bGU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIGVuY29kZUhleChjaGFyYWN0ZXIpIHtcbiAgdmFyIHN0cmluZywgaGFuZGxlLCBsZW5ndGg7XG5cbiAgc3RyaW5nID0gY2hhcmFjdGVyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXG4gIGlmIChjaGFyYWN0ZXIgPD0gMHhGRikge1xuICAgIGhhbmRsZSA9ICd4JztcbiAgICBsZW5ndGggPSAyO1xuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA8PSAweEZGRkYpIHtcbiAgICBoYW5kbGUgPSAndSc7XG4gICAgbGVuZ3RoID0gNDtcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPD0gMHhGRkZGRkZGRikge1xuICAgIGhhbmRsZSA9ICdVJztcbiAgICBsZW5ndGggPSA4O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdjb2RlIHBvaW50IHdpdGhpbiBhIHN0cmluZyBtYXkgbm90IGJlIGdyZWF0ZXIgdGhhbiAweEZGRkZGRkZGJyk7XG4gIH1cblxuICByZXR1cm4gJ1xcXFwnICsgaGFuZGxlICsgY29tbW9uLnJlcGVhdCgnMCcsIGxlbmd0aCAtIHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufVxuXG5cbmZ1bmN0aW9uIFN0YXRlKG9wdGlvbnMpIHtcbiAgdGhpcy5zY2hlbWEgICAgICA9IG9wdGlvbnNbJ3NjaGVtYSddIHx8IERFRkFVTFRfRlVMTF9TQ0hFTUE7XG4gIHRoaXMuaW5kZW50ICAgICAgPSBNYXRoLm1heCgxLCAob3B0aW9uc1snaW5kZW50J10gfHwgMikpO1xuICB0aGlzLnNraXBJbnZhbGlkID0gb3B0aW9uc1snc2tpcEludmFsaWQnXSB8fCBmYWxzZTtcbiAgdGhpcy5mbG93TGV2ZWwgICA9IChjb21tb24uaXNOb3RoaW5nKG9wdGlvbnNbJ2Zsb3dMZXZlbCddKSA/IC0xIDogb3B0aW9uc1snZmxvd0xldmVsJ10pO1xuICB0aGlzLnN0eWxlTWFwICAgID0gY29tcGlsZVN0eWxlTWFwKHRoaXMuc2NoZW1hLCBvcHRpb25zWydzdHlsZXMnXSB8fCBudWxsKTtcblxuICB0aGlzLmltcGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEltcGxpY2l0O1xuICB0aGlzLmV4cGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEV4cGxpY2l0O1xuXG4gIHRoaXMudGFnID0gbnVsbDtcbiAgdGhpcy5yZXN1bHQgPSAnJztcblxuICB0aGlzLmR1cGxpY2F0ZXMgPSBbXTtcbiAgdGhpcy51c2VkRHVwbGljYXRlcyA9IG51bGw7XG59XG5cblxuZnVuY3Rpb24gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpIHtcbiAgcmV0dXJuICdcXG4nICsgY29tbW9uLnJlcGVhdCgnICcsIHN0YXRlLmluZGVudCAqIGxldmVsKTtcbn1cblxuZnVuY3Rpb24gdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBzdHIpIHtcbiAgdmFyIGluZGV4LCBsZW5ndGgsIHR5cGU7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHN0YXRlLmltcGxpY2l0VHlwZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHR5cGUgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzW2luZGV4XTtcblxuICAgIGlmICh0eXBlLnJlc29sdmUoc3RyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB3cml0ZVNjYWxhcihzdGF0ZSwgb2JqZWN0KSB7XG4gIHZhciBpc1F1b3RlZCwgY2hlY2twb2ludCwgcG9zaXRpb24sIGxlbmd0aCwgY2hhcmFjdGVyLCBmaXJzdDtcblxuICBzdGF0ZS5kdW1wID0gJyc7XG4gIGlzUXVvdGVkID0gZmFsc2U7XG4gIGNoZWNrcG9pbnQgPSAwO1xuICBmaXJzdCA9IG9iamVjdC5jaGFyQ29kZUF0KDApIHx8IDA7XG5cbiAgaWYgKC0xICE9PSBERVBSRUNBVEVEX0JPT0xFQU5TX1NZTlRBWC5pbmRleE9mKG9iamVjdCkpIHtcbiAgICAvLyBFbnN1cmUgY29tcGF0aWJpbGl0eSB3aXRoIFlBTUwgMS4wLzEuMSBsb2FkZXJzLlxuICAgIGlzUXVvdGVkID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICgwID09PSBvYmplY3QubGVuZ3RoKSB7XG4gICAgLy8gUXVvdGUgZW1wdHkgc3RyaW5nXG4gICAgaXNRdW90ZWQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKENIQVJfU1BBQ0UgICAgPT09IGZpcnN0IHx8XG4gICAgICAgICAgICAgQ0hBUl9TUEFDRSAgICA9PT0gb2JqZWN0LmNoYXJDb2RlQXQob2JqZWN0Lmxlbmd0aCAtIDEpKSB7XG4gICAgaXNRdW90ZWQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKENIQVJfTUlOVVMgICAgPT09IGZpcnN0IHx8XG4gICAgICAgICAgICAgQ0hBUl9RVUVTVElPTiA9PT0gZmlyc3QpIHtcbiAgICAvLyBEb24ndCBjaGVjayBzZWNvbmQgc3ltYm9sIGZvciBzaW1wbGljaXR5XG4gICAgaXNRdW90ZWQgPSB0cnVlO1xuICB9XG5cbiAgZm9yIChwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IHBvc2l0aW9uIDwgbGVuZ3RoOyBwb3NpdGlvbiArPSAxKSB7XG4gICAgY2hhcmFjdGVyID0gb2JqZWN0LmNoYXJDb2RlQXQocG9zaXRpb24pO1xuXG4gICAgaWYgKCFpc1F1b3RlZCkge1xuICAgICAgaWYgKENIQVJfVEFCICAgICAgICAgICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfTElORV9GRUVEICAgICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfQ0FSUklBR0VfUkVUVVJOICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfQ09NTUEgICAgICAgICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVCAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfU0hBUlAgICAgICAgICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfQU1QRVJTQU5EICAgICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfQVNURVJJU0sgICAgICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfRVhDTEFNQVRJT04gICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfVkVSVElDQUxfTElORSAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfR1JFQVRFUl9USEFOICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfU0lOR0xFX1FVT1RFICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfRE9VQkxFX1FVT1RFICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfUEVSQ0VOVCAgICAgICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfQ09NTUVSQ0lBTF9BVCAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfQ09MT04gICAgICAgICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfR1JBVkVfQUNDRU5UICAgICAgICAgPT09IGNoYXJhY3Rlcikge1xuICAgICAgICBpc1F1b3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKEVTQ0FQRV9TRVFVRU5DRVNbY2hhcmFjdGVyXSB8fFxuICAgICAgICAhKCgweDAwMDIwIDw9IGNoYXJhY3RlciAmJiBjaGFyYWN0ZXIgPD0gMHgwMDAwN0UpIHx8XG4gICAgICAgICAgKDB4MDAwODUgPT09IGNoYXJhY3RlcikgICAgICAgICAgICAgICAgICAgICAgICAgfHxcbiAgICAgICAgICAoMHgwMDBBMCA8PSBjaGFyYWN0ZXIgJiYgY2hhcmFjdGVyIDw9IDB4MDBEN0ZGKSB8fFxuICAgICAgICAgICgweDBFMDAwIDw9IGNoYXJhY3RlciAmJiBjaGFyYWN0ZXIgPD0gMHgwMEZGRkQpIHx8XG4gICAgICAgICAgKDB4MTAwMDAgPD0gY2hhcmFjdGVyICYmIGNoYXJhY3RlciA8PSAweDEwRkZGRikpKSB7XG4gICAgICBzdGF0ZS5kdW1wICs9IG9iamVjdC5zbGljZShjaGVja3BvaW50LCBwb3NpdGlvbik7XG4gICAgICBzdGF0ZS5kdW1wICs9IEVTQ0FQRV9TRVFVRU5DRVNbY2hhcmFjdGVyXSB8fCBlbmNvZGVIZXgoY2hhcmFjdGVyKTtcbiAgICAgIGNoZWNrcG9pbnQgPSBwb3NpdGlvbiArIDE7XG4gICAgICBpc1F1b3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNoZWNrcG9pbnQgPCBwb3NpdGlvbikge1xuICAgIHN0YXRlLmR1bXAgKz0gb2JqZWN0LnNsaWNlKGNoZWNrcG9pbnQsIHBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmICghaXNRdW90ZWQgJiYgdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBzdGF0ZS5kdW1wKSkge1xuICAgIGlzUXVvdGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChpc1F1b3RlZCkge1xuICAgIHN0YXRlLmR1bXAgPSAnXCInICsgc3RhdGUuZHVtcCArICdcIic7XG4gIH1cbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RbaW5kZXhdLCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBpZiAoMCAhPT0gaW5kZXgpIHtcbiAgICAgICAgX3Jlc3VsdCArPSAnLCAnO1xuICAgICAgfVxuICAgICAgX3Jlc3VsdCArPSBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSAnWycgKyBfcmVzdWx0ICsgJ10nO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJsb2NrU2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QsIGNvbXBhY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0W2luZGV4XSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgIGlmICghY29tcGFjdCB8fCAwICE9PSBpbmRleCkge1xuICAgICAgICBfcmVzdWx0ICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICAgIH1cbiAgICAgIF9yZXN1bHQgKz0gJy0gJyArIHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9IF9yZXN1bHQgfHwgJ1tdJzsgLy8gRW1wdHkgc2VxdWVuY2UgaWYgbm8gdmFsaWQgdmFsdWVzLlxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb3dNYXBwaW5nKHN0YXRlLCBsZXZlbCwgb2JqZWN0KSB7XG4gIHZhciBfcmVzdWx0ICAgICAgID0gJycsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9iamVjdEtleSxcbiAgICAgIG9iamVjdFZhbHVlLFxuICAgICAgcGFpckJ1ZmZlcjtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpckJ1ZmZlciA9ICcnO1xuXG4gICAgaWYgKDAgIT09IGluZGV4KSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICcsICc7XG4gICAgfVxuXG4gICAgb2JqZWN0S2V5ID0gb2JqZWN0S2V5TGlzdFtpbmRleF07XG4gICAgb2JqZWN0VmFsdWUgPSBvYmplY3Rbb2JqZWN0S2V5XTtcblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0S2V5LCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZHVtcC5sZW5ndGggPiAxMDI0KSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICc/ICc7XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wICsgJzogJztcblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0VmFsdWUsIGZhbHNlLCBmYWxzZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQgdmFsdWUuXG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgLy8gQm90aCBrZXkgYW5kIHZhbHVlIGFyZSB2YWxpZC5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gJ3snICsgX3Jlc3VsdCArICd9Jztcbn1cblxuZnVuY3Rpb24gd3JpdGVCbG9ja01hcHBpbmcoc3RhdGUsIGxldmVsLCBvYmplY3QsIGNvbXBhY3QpIHtcbiAgdmFyIF9yZXN1bHQgICAgICAgPSAnJyxcbiAgICAgIF90YWcgICAgICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgb2JqZWN0S2V5LFxuICAgICAgb2JqZWN0VmFsdWUsXG4gICAgICBleHBsaWNpdFBhaXIsXG4gICAgICBwYWlyQnVmZmVyO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyQnVmZmVyID0gJyc7XG5cbiAgICBpZiAoIWNvbXBhY3QgfHwgMCAhPT0gaW5kZXgpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIG9iamVjdEtleSA9IG9iamVjdEtleUxpc3RbaW5kZXhdO1xuICAgIG9iamVjdFZhbHVlID0gb2JqZWN0W29iamVjdEtleV07XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RLZXksIHRydWUsIHRydWUpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleS5cbiAgICB9XG5cbiAgICBleHBsaWNpdFBhaXIgPSAobnVsbCAhPT0gc3RhdGUudGFnICYmICc/JyAhPT0gc3RhdGUudGFnKSB8fFxuICAgICAgICAgICAgICAgICAgIChzdGF0ZS5kdW1wICYmIHN0YXRlLmR1bXAubGVuZ3RoID4gMTAyNCk7XG5cbiAgICBpZiAoZXhwbGljaXRQYWlyKSB7XG4gICAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIHBhaXJCdWZmZXIgKz0gJz8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFpckJ1ZmZlciArPSAnPyAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIGlmIChleHBsaWNpdFBhaXIpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdFZhbHVlLCB0cnVlLCBleHBsaWNpdFBhaXIpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJzonO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICc6ICc7XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgLy8gQm90aCBrZXkgYW5kIHZhbHVlIGFyZSB2YWxpZC5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gX3Jlc3VsdCB8fCAne30nOyAvLyBFbXB0eSBtYXBwaW5nIGlmIG5vIHZhbGlkIHBhaXJzLlxufVxuXG5mdW5jdGlvbiBkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIGV4cGxpY2l0KSB7XG4gIHZhciBfcmVzdWx0LCB0eXBlTGlzdCwgaW5kZXgsIGxlbmd0aCwgdHlwZSwgc3R5bGU7XG5cbiAgdHlwZUxpc3QgPSBleHBsaWNpdCA/IHN0YXRlLmV4cGxpY2l0VHlwZXMgOiBzdGF0ZS5pbXBsaWNpdFR5cGVzO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB0eXBlTGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdHlwZSA9IHR5cGVMaXN0W2luZGV4XTtcblxuICAgIGlmICgodHlwZS5pbnN0YW5jZU9mICB8fCB0eXBlLnByZWRpY2F0ZSkgJiZcbiAgICAgICAgKCF0eXBlLmluc3RhbmNlT2YgfHwgKCgnb2JqZWN0JyA9PT0gdHlwZW9mIG9iamVjdCkgJiYgKG9iamVjdCBpbnN0YW5jZW9mIHR5cGUuaW5zdGFuY2VPZikpKSAmJlxuICAgICAgICAoIXR5cGUucHJlZGljYXRlICB8fCB0eXBlLnByZWRpY2F0ZShvYmplY3QpKSkge1xuXG4gICAgICBzdGF0ZS50YWcgPSBleHBsaWNpdCA/IHR5cGUudGFnIDogJz8nO1xuXG4gICAgICBpZiAodHlwZS5yZXByZXNlbnQpIHtcbiAgICAgICAgc3R5bGUgPSBzdGF0ZS5zdHlsZU1hcFt0eXBlLnRhZ10gfHwgdHlwZS5kZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgaWYgKCdbb2JqZWN0IEZ1bmN0aW9uXScgPT09IF90b1N0cmluZy5jYWxsKHR5cGUucmVwcmVzZW50KSkge1xuICAgICAgICAgIF9yZXN1bHQgPSB0eXBlLnJlcHJlc2VudChvYmplY3QsIHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlLnJlcHJlc2VudCwgc3R5bGUpKSB7XG4gICAgICAgICAgX3Jlc3VsdCA9IHR5cGUucmVwcmVzZW50W3N0eWxlXShvYmplY3QsIHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignITwnICsgdHlwZS50YWcgKyAnPiB0YWcgcmVzb2x2ZXIgYWNjZXB0cyBub3QgXCInICsgc3R5bGUgKyAnXCIgc3R5bGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmR1bXAgPSBfcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFNlcmlhbGl6ZXMgYG9iamVjdGAgYW5kIHdyaXRlcyBpdCB0byBnbG9iYWwgYHJlc3VsdGAuXG4vLyBSZXR1cm5zIHRydWUgb24gc3VjY2Vzcywgb3IgZmFsc2Ugb24gaW52YWxpZCBvYmplY3QuXG4vL1xuZnVuY3Rpb24gd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBibG9jaywgY29tcGFjdCkge1xuICBzdGF0ZS50YWcgPSBudWxsO1xuICBzdGF0ZS5kdW1wID0gb2JqZWN0O1xuXG4gIGlmICghZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCBmYWxzZSkpIHtcbiAgICBkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIHRydWUpO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBfdG9TdHJpbmcuY2FsbChzdGF0ZS5kdW1wKTtcblxuICBpZiAoYmxvY2spIHtcbiAgICBibG9jayA9ICgwID4gc3RhdGUuZmxvd0xldmVsIHx8IHN0YXRlLmZsb3dMZXZlbCA+IGxldmVsKTtcbiAgfVxuXG4gIGlmICgobnVsbCAhPT0gc3RhdGUudGFnICYmICc/JyAhPT0gc3RhdGUudGFnKSB8fCAoMiAhPT0gc3RhdGUuaW5kZW50ICYmIGxldmVsID4gMCkpIHtcbiAgICBjb21wYWN0ID0gZmFsc2U7XG4gIH1cblxuICB2YXIgb2JqZWN0T3JBcnJheSA9ICdbb2JqZWN0IE9iamVjdF0nID09PSB0eXBlIHx8ICdbb2JqZWN0IEFycmF5XScgPT09IHR5cGUsXG4gICAgICBkdXBsaWNhdGVJbmRleCxcbiAgICAgIGR1cGxpY2F0ZTtcblxuICBpZiAob2JqZWN0T3JBcnJheSkge1xuICAgIGR1cGxpY2F0ZUluZGV4ID0gc3RhdGUuZHVwbGljYXRlcy5pbmRleE9mKG9iamVjdCk7XG4gICAgZHVwbGljYXRlID0gZHVwbGljYXRlSW5kZXggIT09IC0xO1xuICB9XG5cbiAgaWYgKGR1cGxpY2F0ZSAmJiBzdGF0ZS51c2VkRHVwbGljYXRlc1tkdXBsaWNhdGVJbmRleF0pIHtcbiAgICBzdGF0ZS5kdW1wID0gJypyZWZfJyArIGR1cGxpY2F0ZUluZGV4O1xuICB9IGVsc2Uge1xuICAgIGlmIChvYmplY3RPckFycmF5ICYmIGR1cGxpY2F0ZSAmJiAhc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdKSB7XG4gICAgICBzdGF0ZS51c2VkRHVwbGljYXRlc1tkdXBsaWNhdGVJbmRleF0gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoJ1tvYmplY3QgT2JqZWN0XScgPT09IHR5cGUpIHtcbiAgICAgIGlmIChibG9jayAmJiAoMCAhPT0gT2JqZWN0LmtleXMoc3RhdGUuZHVtcCkubGVuZ3RoKSkge1xuICAgICAgICB3cml0ZUJsb2NrTWFwcGluZyhzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXAsIGNvbXBhY3QpO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArICgwID09PSBsZXZlbCA/ICdcXG4nIDogJycpICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVGbG93TWFwcGluZyhzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXApO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArICcgJyArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCdbb2JqZWN0IEFycmF5XScgPT09IHR5cGUpIHtcbiAgICAgIGlmIChibG9jayAmJiAoMCAhPT0gc3RhdGUuZHVtcC5sZW5ndGgpKSB7XG4gICAgICAgIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXAsIGNvbXBhY3QpO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArICgwID09PSBsZXZlbCA/ICdcXG4nIDogJycpICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wKTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyAnICcgKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgnW29iamVjdCBTdHJpbmddJyA9PT0gdHlwZSkge1xuICAgICAgaWYgKCc/JyAhPT0gc3RhdGUudGFnKSB7XG4gICAgICAgIHdyaXRlU2NhbGFyKHN0YXRlLCBzdGF0ZS5kdW1wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0YXRlLnNraXBJbnZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCd1bmFjY2VwdGFibGUga2luZCBvZiBhbiBvYmplY3QgdG8gZHVtcCAnICsgdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKG51bGwgIT09IHN0YXRlLnRhZyAmJiAnPycgIT09IHN0YXRlLnRhZykge1xuICAgICAgc3RhdGUuZHVtcCA9ICchPCcgKyBzdGF0ZS50YWcgKyAnPiAnICsgc3RhdGUuZHVtcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0RHVwbGljYXRlUmVmZXJlbmNlcyhvYmplY3QsIHN0YXRlKSB7XG4gIHZhciBvYmplY3RzID0gW10sXG4gICAgICBkdXBsaWNhdGVzSW5kZXhlcyA9IFtdLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG5cbiAgaW5zcGVjdE5vZGUob2JqZWN0LCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGR1cGxpY2F0ZXNJbmRleGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBzdGF0ZS5kdXBsaWNhdGVzLnB1c2gob2JqZWN0c1tkdXBsaWNhdGVzSW5kZXhlc1tpbmRleF1dKTtcbiAgfVxuICBzdGF0ZS51c2VkRHVwbGljYXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBpbnNwZWN0Tm9kZShvYmplY3QsIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKSB7XG4gIHZhciB0eXBlID0gX3RvU3RyaW5nLmNhbGwob2JqZWN0KSxcbiAgICAgIG9iamVjdEtleUxpc3QsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBpZiAobnVsbCAhPT0gb2JqZWN0ICYmICdvYmplY3QnID09PSB0eXBlb2Ygb2JqZWN0KSB7XG4gICAgaW5kZXggPSBvYmplY3RzLmluZGV4T2Yob2JqZWN0KTtcbiAgICBpZiAoLTEgIT09IGluZGV4KSB7XG4gICAgICBpZiAoLTEgPT09IGR1cGxpY2F0ZXNJbmRleGVzLmluZGV4T2YoaW5kZXgpKSB7XG4gICAgICAgIGR1cGxpY2F0ZXNJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICBcbiAgICAgIGlmKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICBpbnNwZWN0Tm9kZShvYmplY3RbaW5kZXhdLCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICBpbnNwZWN0Tm9kZShvYmplY3Rbb2JqZWN0S2V5TGlzdFtpbmRleF1dLCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHVtcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUob3B0aW9ucyk7XG5cbiAgZ2V0RHVwbGljYXRlUmVmZXJlbmNlcyhpbnB1dCwgc3RhdGUpO1xuXG4gIGlmICh3cml0ZU5vZGUoc3RhdGUsIDAsIGlucHV0LCB0cnVlLCB0cnVlKSkge1xuICAgIHJldHVybiBzdGF0ZS5kdW1wICsgJ1xcbic7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc2FmZUR1bXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGR1bXAoaW5wdXQsIGNvbW1vbi5leHRlbmQoeyBzY2hlbWE6IERFRkFVTFRfU0FGRV9TQ0hFTUEgfSwgb3B0aW9ucykpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLmR1bXAgICAgID0gZHVtcDtcbm1vZHVsZS5leHBvcnRzLnNhZmVEdW1wID0gc2FmZUR1bXA7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gWUFNTEV4Y2VwdGlvbihyZWFzb24sIG1hcmspIHtcbiAgdGhpcy5uYW1lICAgID0gJ1lBTUxFeGNlcHRpb24nO1xuICB0aGlzLnJlYXNvbiAgPSByZWFzb247XG4gIHRoaXMubWFyayAgICA9IG1hcms7XG4gIHRoaXMubWVzc2FnZSA9IHRoaXMudG9TdHJpbmcoZmFsc2UpO1xufVxuXG5cbllBTUxFeGNlcHRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoY29tcGFjdCkge1xuICB2YXIgcmVzdWx0O1xuXG4gIHJlc3VsdCA9ICdKUy1ZQU1MOiAnICsgKHRoaXMucmVhc29uIHx8ICcodW5rbm93biByZWFzb24pJyk7XG5cbiAgaWYgKCFjb21wYWN0ICYmIHRoaXMubWFyaykge1xuICAgIHJlc3VsdCArPSAnICcgKyB0aGlzLm1hcmsudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gWUFNTEV4Y2VwdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgY29tbW9uICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgTWFyayAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vbWFyaycpO1xudmFyIERFRkFVTFRfU0FGRV9TQ0hFTUEgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0X3NhZmUnKTtcbnZhciBERUZBVUxUX0ZVTExfU0NIRU1BID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XG5cblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblxudmFyIENPTlRFWFRfRkxPV19JTiAgID0gMTtcbnZhciBDT05URVhUX0ZMT1dfT1VUICA9IDI7XG52YXIgQ09OVEVYVF9CTE9DS19JTiAgPSAzO1xudmFyIENPTlRFWFRfQkxPQ0tfT1VUID0gNDtcblxuXG52YXIgQ0hPTVBJTkdfQ0xJUCAgPSAxO1xudmFyIENIT01QSU5HX1NUUklQID0gMjtcbnZhciBDSE9NUElOR19LRUVQICA9IDM7XG5cblxudmFyIFBBVFRFUk5fTk9OX1BSSU5UQUJMRSAgICAgICAgID0gL1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRlxceDdGLVxceDg0XFx4ODYtXFx4OUZcXHVEODAwLVxcdURGRkZcXHVGRkZFXFx1RkZGRl0vO1xudmFyIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTID0gL1tcXHg4NVxcdTIwMjhcXHUyMDI5XS87XG52YXIgUEFUVEVSTl9GTE9XX0lORElDQVRPUlMgICAgICAgPSAvWyxcXFtcXF1cXHtcXH1dLztcbnZhciBQQVRURVJOX1RBR19IQU5ETEUgICAgICAgICAgICA9IC9eKD86IXwhIXwhW2EtelxcLV0rISkkL2k7XG52YXIgUEFUVEVSTl9UQUdfVVJJICAgICAgICAgICAgICAgPSAvXig/OiF8W14sXFxbXFxdXFx7XFx9XSkoPzolWzAtOWEtZl17Mn18WzAtOWEtelxcLSM7XFwvXFw/OkAmPVxcK1xcJCxfXFwuIX5cXConXFwoXFwpXFxbXFxdXSkqJC9pO1xuXG5cbmZ1bmN0aW9uIGlzX0VPTChjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgwQS8qIExGICovKSB8fCAoYyA9PT0gMHgwRC8qIENSICovKTtcbn1cblxuZnVuY3Rpb24gaXNfV0hJVEVfU1BBQ0UoYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8IChjID09PSAweDIwLyogU3BhY2UgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19XU19PUl9FT0woYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgyMC8qIFNwYWNlICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MEEvKiBMRiAqLykgfHxcbiAgICAgICAgIChjID09PSAweDBELyogQ1IgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19GTE9XX0lORElDQVRPUihjKSB7XG4gIHJldHVybiAweDJDLyogLCAqLyA9PT0gYyB8fFxuICAgICAgICAgMHg1Qi8qIFsgKi8gPT09IGMgfHxcbiAgICAgICAgIDB4NUQvKiBdICovID09PSBjIHx8XG4gICAgICAgICAweDdCLyogeyAqLyA9PT0gYyB8fFxuICAgICAgICAgMHg3RC8qIH0gKi8gPT09IGM7XG59XG5cbmZ1bmN0aW9uIGZyb21IZXhDb2RlKGMpIHtcbiAgdmFyIGxjO1xuXG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgbGMgPSBjIHwgMHgyMDtcbiAgaWYgKCgweDYxLyogYSAqLyA8PSBsYykgJiYgKGxjIDw9IDB4NjYvKiBmICovKSkge1xuICAgIHJldHVybiBsYyAtIDB4NjEgKyAxMDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlZEhleExlbihjKSB7XG4gIGlmIChjID09PSAweDc4LyogeCAqLykgeyByZXR1cm4gMjsgfVxuICBpZiAoYyA9PT0gMHg3NS8qIHUgKi8pIHsgcmV0dXJuIDQ7IH1cbiAgaWYgKGMgPT09IDB4NTUvKiBVICovKSB7IHJldHVybiA4OyB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBmcm9tRGVjaW1hbENvZGUoYykge1xuICBpZiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkge1xuICAgIHJldHVybiBjIC0gMHgzMDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRXNjYXBlU2VxdWVuY2UoYykge1xuIHJldHVybiAoYyA9PT0gMHgzMC8qIDAgKi8pID8gJ1xceDAwJyA6XG4gICAgICAgIChjID09PSAweDYxLyogYSAqLykgPyAnXFx4MDcnIDpcbiAgICAgICAgKGMgPT09IDB4NjIvKiBiICovKSA/ICdcXHgwOCcgOlxuICAgICAgICAoYyA9PT0gMHg3NC8qIHQgKi8pID8gJ1xceDA5JyA6XG4gICAgICAgIChjID09PSAweDA5LyogVGFiICovKSA/ICdcXHgwOScgOlxuICAgICAgICAoYyA9PT0gMHg2RS8qIG4gKi8pID8gJ1xceDBBJyA6XG4gICAgICAgIChjID09PSAweDc2LyogdiAqLykgPyAnXFx4MEInIDpcbiAgICAgICAgKGMgPT09IDB4NjYvKiBmICovKSA/ICdcXHgwQycgOlxuICAgICAgICAoYyA9PT0gMHg3Mi8qIHIgKi8pID8gJ1xceDBEJyA6XG4gICAgICAgIChjID09PSAweDY1LyogZSAqLykgPyAnXFx4MUInIDpcbiAgICAgICAgKGMgPT09IDB4MjAvKiBTcGFjZSAqLykgPyAnICcgOlxuICAgICAgICAoYyA9PT0gMHgyMi8qIFwiICovKSA/ICdcXHgyMicgOlxuICAgICAgICAoYyA9PT0gMHgyRi8qIC8gKi8pID8gJy8nIDpcbiAgICAgICAgKGMgPT09IDB4NUMvKiBcXCAqLykgPyAnXFx4NUMnIDpcbiAgICAgICAgKGMgPT09IDB4NEUvKiBOICovKSA/ICdcXHg4NScgOlxuICAgICAgICAoYyA9PT0gMHg1Ri8qIF8gKi8pID8gJ1xceEEwJyA6XG4gICAgICAgIChjID09PSAweDRDLyogTCAqLykgPyAnXFx1MjAyOCcgOlxuICAgICAgICAoYyA9PT0gMHg1MC8qIFAgKi8pID8gJ1xcdTIwMjknIDogJyc7XG59XG5cbmZ1bmN0aW9uIGNoYXJGcm9tQ29kZXBvaW50KGMpIHtcbiAgaWYgKGMgPD0gMHhGRkZGKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRW5jb2RlIFVURi0xNiBzdXJyb2dhdGUgcGFpclxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi0xNiNDb2RlX3BvaW50c19VLjJCMDEwMDAwX3RvX1UuMkIxMEZGRkZcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgLSAweDAxMDAwMCkgPj4gMTApICsgMHhEODAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoYyAtIDB4MDEwMDAwKSAmIDB4MDNGRikgKyAweERDMDApO1xuICB9XG59XG5cbnZhciBzaW1wbGVFc2NhcGVDaGVjayA9IG5ldyBBcnJheSgyNTYpOyAvLyBpbnRlZ2VyLCBmb3IgZmFzdCBhY2Nlc3NcbnZhciBzaW1wbGVFc2NhcGVNYXAgPSBuZXcgQXJyYXkoMjU2KTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgc2ltcGxlRXNjYXBlQ2hlY2tbaV0gPSBzaW1wbGVFc2NhcGVTZXF1ZW5jZShpKSA/IDEgOiAwO1xuICBzaW1wbGVFc2NhcGVNYXBbaV0gPSBzaW1wbGVFc2NhcGVTZXF1ZW5jZShpKTtcbn1cblxuXG5mdW5jdGlvbiBTdGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB0aGlzLmlucHV0ID0gaW5wdXQ7XG5cbiAgdGhpcy5maWxlbmFtZSAgPSBvcHRpb25zWydmaWxlbmFtZSddICB8fCBudWxsO1xuICB0aGlzLnNjaGVtYSAgICA9IG9wdGlvbnNbJ3NjaGVtYSddICAgIHx8IERFRkFVTFRfRlVMTF9TQ0hFTUE7XG4gIHRoaXMub25XYXJuaW5nID0gb3B0aW9uc1snb25XYXJuaW5nJ10gfHwgbnVsbDtcbiAgdGhpcy5sZWdhY3kgICAgPSBvcHRpb25zWydsZWdhY3knXSAgICB8fCBmYWxzZTtcblxuICB0aGlzLmltcGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEltcGxpY2l0O1xuICB0aGlzLnR5cGVNYXAgICAgICAgPSB0aGlzLnNjaGVtYS5jb21waWxlZFR5cGVNYXA7XG5cbiAgdGhpcy5sZW5ndGggICAgID0gaW5wdXQubGVuZ3RoO1xuICB0aGlzLnBvc2l0aW9uICAgPSAwO1xuICB0aGlzLmxpbmUgICAgICAgPSAwO1xuICB0aGlzLmxpbmVTdGFydCAgPSAwO1xuICB0aGlzLmxpbmVJbmRlbnQgPSAwO1xuXG4gIHRoaXMuZG9jdW1lbnRzID0gW107XG5cbiAgLypcbiAgdGhpcy52ZXJzaW9uO1xuICB0aGlzLmNoZWNrTGluZUJyZWFrcztcbiAgdGhpcy50YWdNYXA7XG4gIHRoaXMuYW5jaG9yTWFwO1xuICB0aGlzLnRhZztcbiAgdGhpcy5hbmNob3I7XG4gIHRoaXMua2luZDtcbiAgdGhpcy5yZXN1bHQ7Ki9cblxufVxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlRXJyb3Ioc3RhdGUsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIG5ldyBZQU1MRXhjZXB0aW9uKFxuICAgIG1lc3NhZ2UsXG4gICAgbmV3IE1hcmsoc3RhdGUuZmlsZW5hbWUsIHN0YXRlLmlucHV0LCBzdGF0ZS5wb3NpdGlvbiwgc3RhdGUubGluZSwgKHN0YXRlLnBvc2l0aW9uIC0gc3RhdGUubGluZVN0YXJ0KSkpO1xufVxuXG5mdW5jdGlvbiB0aHJvd0Vycm9yKHN0YXRlLCBtZXNzYWdlKSB7XG4gIHRocm93IGdlbmVyYXRlRXJyb3Ioc3RhdGUsIG1lc3NhZ2UpO1xufVxuXG5mdW5jdGlvbiB0aHJvd1dhcm5pbmcoc3RhdGUsIG1lc3NhZ2UpIHtcbiAgdmFyIGVycm9yID0gZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSk7XG5cbiAgaWYgKHN0YXRlLm9uV2FybmluZykge1xuICAgIHN0YXRlLm9uV2FybmluZy5jYWxsKG51bGwsIGVycm9yKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5cbnZhciBkaXJlY3RpdmVIYW5kbGVycyA9IHtcblxuICAnWUFNTCc6IGZ1bmN0aW9uIGhhbmRsZVlhbWxEaXJlY3RpdmUoc3RhdGUsIG5hbWUsIGFyZ3MpIHtcblxuICAgICAgdmFyIG1hdGNoLCBtYWpvciwgbWlub3I7XG5cbiAgICAgIGlmIChudWxsICE9PSBzdGF0ZS52ZXJzaW9uKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiAlWUFNTCBkaXJlY3RpdmUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKDEgIT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdZQU1MIGRpcmVjdGl2ZSBhY2NlcHRzIGV4YWN0bHkgb25lIGFyZ3VtZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIG1hdGNoID0gL14oWzAtOV0rKVxcLihbMC05XSspJC8uZXhlYyhhcmdzWzBdKTtcblxuICAgICAgaWYgKG51bGwgPT09IG1hdGNoKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIGFyZ3VtZW50IG9mIHRoZSBZQU1MIGRpcmVjdGl2ZScpO1xuICAgICAgfVxuXG4gICAgICBtYWpvciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICBtaW5vciA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG5cbiAgICAgIGlmICgxICE9PSBtYWpvcikge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIFlBTUwgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUudmVyc2lvbiA9IGFyZ3NbMF07XG4gICAgICBzdGF0ZS5jaGVja0xpbmVCcmVha3MgPSAobWlub3IgPCAyKTtcblxuICAgICAgaWYgKDEgIT09IG1pbm9yICYmIDIgIT09IG1pbm9yKSB7XG4gICAgICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ3Vuc3VwcG9ydGVkIFlBTUwgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQnKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICdUQUcnOiBmdW5jdGlvbiBoYW5kbGVUYWdEaXJlY3RpdmUoc3RhdGUsIG5hbWUsIGFyZ3MpIHtcblxuICAgICAgdmFyIGhhbmRsZSwgcHJlZml4O1xuXG4gICAgICBpZiAoMiAhPT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1RBRyBkaXJlY3RpdmUgYWNjZXB0cyBleGFjdGx5IHR3byBhcmd1bWVudHMnKTtcbiAgICAgIH1cblxuICAgICAgaGFuZGxlID0gYXJnc1swXTtcbiAgICAgIHByZWZpeCA9IGFyZ3NbMV07XG5cbiAgICAgIGlmICghUEFUVEVSTl9UQUdfSEFORExFLnRlc3QoaGFuZGxlKSkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgaGFuZGxlIChmaXJzdCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnRhZ01hcCwgaGFuZGxlKSkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGhlcmUgaXMgYSBwcmV2aW91c2x5IGRlY2xhcmVkIHN1ZmZpeCBmb3IgXCInICsgaGFuZGxlICsgJ1wiIHRhZyBoYW5kbGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFQQVRURVJOX1RBR19VUkkudGVzdChwcmVmaXgpKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIHRhZyBwcmVmaXggKHNlY29uZCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUudGFnTWFwW2hhbmRsZV0gPSBwcmVmaXg7XG4gICAgfVxufTtcblxuXG5mdW5jdGlvbiBjYXB0dXJlU2VnbWVudChzdGF0ZSwgc3RhcnQsIGVuZCwgY2hlY2tKc29uKSB7XG4gIHZhciBfcG9zaXRpb24sIF9sZW5ndGgsIF9jaGFyYWN0ZXIsIF9yZXN1bHQ7XG5cbiAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgX3Jlc3VsdCA9IHN0YXRlLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgaWYgKGNoZWNrSnNvbikge1xuICAgICAgZm9yIChfcG9zaXRpb24gPSAwLCBfbGVuZ3RoID0gX3Jlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgIF9wb3NpdGlvbiA8IF9sZW5ndGg7XG4gICAgICAgICAgIF9wb3NpdGlvbiArPSAxKSB7XG4gICAgICAgIF9jaGFyYWN0ZXIgPSBfcmVzdWx0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcbiAgICAgICAgaWYgKCEoMHgwOSA9PT0gX2NoYXJhY3RlciB8fFxuICAgICAgICAgICAgICAweDIwIDw9IF9jaGFyYWN0ZXIgJiYgX2NoYXJhY3RlciA8PSAweDEwRkZGRikpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgdmFsaWQgSlNPTiBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLnJlc3VsdCArPSBfcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlTWFwcGluZ3Moc3RhdGUsIGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgdmFyIHNvdXJjZUtleXMsIGtleSwgaW5kZXgsIHF1YW50aXR5O1xuXG4gIGlmICghY29tbW9uLmlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2Fubm90IG1lcmdlIG1hcHBpbmdzOyB0aGUgcHJvdmlkZWQgc291cmNlIG9iamVjdCBpcyB1bmFjY2VwdGFibGUnKTtcbiAgfVxuXG4gIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IHNvdXJjZUtleXMubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpbmRleF07XG5cbiAgICBpZiAoIV9oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc3RpbmF0aW9uLCBrZXkpKSB7XG4gICAgICBkZXN0aW5hdGlvbltrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKSB7XG4gIHZhciBpbmRleCwgcXVhbnRpdHk7XG5cbiAga2V5Tm9kZSA9IFN0cmluZyhrZXlOb2RlKTtcblxuICBpZiAobnVsbCA9PT0gX3Jlc3VsdCkge1xuICAgIF9yZXN1bHQgPSB7fTtcbiAgfVxuXG4gIGlmICgndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnID09PSBrZXlUYWcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZU5vZGUpKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSB2YWx1ZU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZVtpbmRleF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZU1hcHBpbmdzKHN0YXRlLCBfcmVzdWx0LCB2YWx1ZU5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBfcmVzdWx0W2tleU5vZGVdID0gdmFsdWVOb2RlO1xuICB9XG5cbiAgcmV0dXJuIF9yZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRMaW5lQnJlYWsoc3RhdGUpIHtcbiAgdmFyIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKDB4MEEvKiBMRiAqLyA9PT0gY2gpIHtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICB9IGVsc2UgaWYgKDB4MEQvKiBDUiAqLyA9PT0gY2gpIHtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgIGlmICgweDBBLyogTEYgKi8gPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYSBsaW5lIGJyZWFrIGlzIGV4cGVjdGVkJyk7XG4gIH1cblxuICBzdGF0ZS5saW5lICs9IDE7XG4gIHN0YXRlLmxpbmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xufVxuXG5mdW5jdGlvbiBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBhbGxvd0NvbW1lbnRzLCBjaGVja0luZGVudCkge1xuICB2YXIgbGluZUJyZWFrcyA9IDAsXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlICgwICE9PSBjaCkge1xuICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dDb21tZW50cyAmJiAweDIzLyogIyAqLyA9PT0gY2gpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfSB3aGlsZSAoY2ggIT09IDB4MEEvKiBMRiAqLyAmJiBjaCAhPT0gMHgwRC8qIENSICovICYmIDAgIT09IGNoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBsaW5lQnJlYWtzKys7XG4gICAgICBzdGF0ZS5saW5lSW5kZW50ID0gMDtcblxuICAgICAgd2hpbGUgKDB4MjAvKiBTcGFjZSAqLyA9PT0gY2gpIHtcbiAgICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICgtMSAhPT0gY2hlY2tJbmRlbnQgJiYgMCAhPT0gbGluZUJyZWFrcyAmJiBzdGF0ZS5saW5lSW5kZW50IDwgY2hlY2tJbmRlbnQpIHtcbiAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICdkZWZpY2llbnQgaW5kZW50YXRpb24nKTtcbiAgfVxuXG4gIHJldHVybiBsaW5lQnJlYWtzO1xufVxuXG5mdW5jdGlvbiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG5cbiAgLy8gQ29uZGl0aW9uIHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgaXMgdGVzdGVkXG4gIC8vIGluIHBhcmVudCBvbiBlYWNoIGNhbGwsIGZvciBlZmZpY2llbmN5LiBObyBuZWVkcyB0byB0ZXN0IGhlcmUgYWdhaW4uXG4gIGlmICgoMHgyRC8qIC0gKi8gPT09IGNoIHx8IDB4MkUvKiAuICovID09PSBjaCkgJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uICsgMSkgPT09IGNoICYmXG4gICAgICBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbisgMikgPT09IGNoKSB7XG5cbiAgICBfcG9zaXRpb24gKz0gMztcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAwIHx8IGlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgY291bnQpIHtcbiAgaWYgKDEgPT09IGNvdW50KSB7XG4gICAgc3RhdGUucmVzdWx0ICs9ICcgJztcbiAgfSBlbHNlIGlmIChjb3VudCA+IDEpIHtcbiAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgY291bnQgLSAxKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHJlYWRQbGFpblNjYWxhcihzdGF0ZSwgbm9kZUluZGVudCwgd2l0aGluRmxvd0NvbGxlY3Rpb24pIHtcbiAgdmFyIHByZWNlZGluZyxcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIGNhcHR1cmVTdGFydCxcbiAgICAgIGNhcHR1cmVFbmQsXG4gICAgICBoYXNQZW5kaW5nQ29udGVudCxcbiAgICAgIF9saW5lLFxuICAgICAgX2xpbmVTdGFydCxcbiAgICAgIF9saW5lSW5kZW50LFxuICAgICAgX2tpbmQgPSBzdGF0ZS5raW5kLFxuICAgICAgX3Jlc3VsdCA9IHN0YXRlLnJlc3VsdCxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGlzX1dTX09SX0VPTChjaCkgICAgICAgICAgICAgfHxcbiAgICAgIGlzX0ZMT1dfSU5ESUNBVE9SKGNoKSAgICAgICAgfHxcbiAgICAgIDB4MjMvKiAjICovICAgICAgICAgICA9PT0gY2ggfHxcbiAgICAgIDB4MjYvKiAmICovICAgICAgICAgICA9PT0gY2ggfHxcbiAgICAgIDB4MkEvKiAqICovICAgICAgICAgICA9PT0gY2ggfHxcbiAgICAgIDB4MjEvKiAhICovICAgICAgICAgICA9PT0gY2ggfHxcbiAgICAgIDB4N0MvKiB8ICovICAgICAgICAgICA9PT0gY2ggfHxcbiAgICAgIDB4M0UvKiA+ICovICAgICAgICAgICA9PT0gY2ggfHxcbiAgICAgIDB4MjcvKiAnICovICAgICAgICAgICA9PT0gY2ggfHxcbiAgICAgIDB4MjIvKiBcIiAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDI1LyogJSAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDQwLyogQCAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDYwLyogYCAqLyAgICAgICAgICAgPT09IGNoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKDB4M0YvKiA/ICovID09PSBjaCB8fCAweDJELyogLSAqLyA9PT0gY2gpIHtcbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoZm9sbG93aW5nKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgaGFzUGVuZGluZ0NvbnRlbnQgPSBmYWxzZTtcblxuICB3aGlsZSAoMCAhPT0gY2gpIHtcbiAgICBpZiAoMHgzQS8qIDogKi8gPT09IGNoKSB7XG4gICAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKzEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihmb2xsb3dpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgweDIzLyogIyAqLyA9PT0gY2gpIHtcbiAgICAgIHByZWNlZGluZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gLSAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChwcmVjZWRpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB8fFxuICAgICAgICAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgICBicmVhaztcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgX2xpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIF9saW5lSW5kZW50ID0gc3RhdGUubGluZUluZGVudDtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCAtMSk7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID49IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uID0gY2FwdHVyZUVuZDtcbiAgICAgICAgc3RhdGUubGluZSA9IF9saW5lO1xuICAgICAgICBzdGF0ZS5saW5lU3RhcnQgPSBfbGluZVN0YXJ0O1xuICAgICAgICBzdGF0ZS5saW5lSW5kZW50ID0gX2xpbmVJbmRlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nQ29udGVudCkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc3RhdGUubGluZSAtIF9saW5lKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbiArIDE7XG4gICAgfVxuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuXG4gIGlmIChzdGF0ZS5yZXN1bHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5raW5kID0gX2tpbmQ7XG4gICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZFNpbmdsZVF1b3RlZFNjYWxhcihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgY2gsXG4gICAgICBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQ7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoMHgyNy8qICcgKi8gIT09IGNoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcbiAgc3RhdGUucG9zaXRpb24rKztcbiAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlICgwICE9PSAoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkpIHtcbiAgICBpZiAoMHgyNy8qICcgKi8gPT09IGNoKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgIGlmICgweDI3LyogJyAqLyA9PT0gY2gpIHtcbiAgICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBzaW5nbGUgcXVvdGVkIHNjYWxhcicpO1xufVxuXG5mdW5jdGlvbiByZWFkRG91YmxlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGV4TGVuZ3RoLFxuICAgICAgaGV4UmVzdWx0LFxuICAgICAgdG1wLCB0bXBFc2MsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmICgweDIyLyogXCIgKi8gIT09IGNoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcbiAgc3RhdGUucG9zaXRpb24rKztcbiAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlICgwICE9PSAoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkpIHtcbiAgICBpZiAoMHgyMi8qIFwiICovID09PSBjaCkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfSBlbHNlIGlmICgweDVDLyogXFwgKi8gPT09IGNoKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCBub2RlSW5kZW50KTtcblxuICAgICAgICAvL1RPRE86IHJld29yayB0byBpbmxpbmUgZm4gd2l0aCBubyB0eXBlIGNhc3Q/XG4gICAgICB9IGVsc2UgaWYgKGNoIDwgMjU2ICYmIHNpbXBsZUVzY2FwZUNoZWNrW2NoXSkge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gc2ltcGxlRXNjYXBlTWFwW2NoXTtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgICAgfSBlbHNlIGlmICgodG1wID0gZXNjYXBlZEhleExlbihjaCkpID4gMCkge1xuICAgICAgICBoZXhMZW5ndGggPSB0bXA7XG4gICAgICAgIGhleFJlc3VsdCA9IDA7XG5cbiAgICAgICAgZm9yICg7IGhleExlbmd0aCA+IDA7IGhleExlbmd0aC0tKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgICAgaWYgKCh0bXAgPSBmcm9tSGV4Q29kZShjaCkpID49IDApIHtcbiAgICAgICAgICAgIGhleFJlc3VsdCA9IChoZXhSZXN1bHQgPDwgNCkgKyB0bXA7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2V4cGVjdGVkIGhleGFkZWNpbWFsIGNoYXJhY3RlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjaGFyRnJvbUNvZGVwb2ludChoZXhSZXN1bHQpO1xuXG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmtub3duIGVzY2FwZSBzZXF1ZW5jZScpO1xuICAgICAgfVxuXG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBkb3VibGUgcXVvdGVkIHNjYWxhcicpO1xufVxuXG5mdW5jdGlvbiByZWFkRmxvd0NvbGxlY3Rpb24oc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIHJlYWROZXh0ID0gdHJ1ZSxcbiAgICAgIF9saW5lLFxuICAgICAgX3RhZyAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBfcmVzdWx0LFxuICAgICAgX2FuY2hvciAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICB0ZXJtaW5hdG9yLFxuICAgICAgaXNQYWlyLFxuICAgICAgaXNFeHBsaWNpdFBhaXIsXG4gICAgICBpc01hcHBpbmcsXG4gICAgICBrZXlOb2RlLFxuICAgICAga2V5VGFnLFxuICAgICAgdmFsdWVOb2RlLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4NUIvKiBbICovKSB7XG4gICAgdGVybWluYXRvciA9IDB4NUQvKiBdICovO1xuICAgIGlzTWFwcGluZyA9IGZhbHNlO1xuICAgIF9yZXN1bHQgPSBbXTtcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHg3Qi8qIHsgKi8pIHtcbiAgICB0ZXJtaW5hdG9yID0gMHg3RC8qIH0gKi87XG4gICAgaXNNYXBwaW5nID0gdHJ1ZTtcbiAgICBfcmVzdWx0ID0ge307XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG51bGwgIT09IHN0YXRlLmFuY2hvcikge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoMCAhPT0gY2gpIHtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IHRlcm1pbmF0b3IpIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgIHN0YXRlLmtpbmQgPSBpc01hcHBpbmcgPyAnbWFwcGluZycgOiAnc2VxdWVuY2UnO1xuICAgICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXJlYWROZXh0KSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbWlzc2VkIGNvbW1hIGJldHdlZW4gZmxvdyBjb2xsZWN0aW9uIGVudHJpZXMnKTtcbiAgICB9XG5cbiAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICBpc1BhaXIgPSBpc0V4cGxpY2l0UGFpciA9IGZhbHNlO1xuXG4gICAgaWYgKDB4M0YvKiA/ICovID09PSBjaCkge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcbiAgICAgICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfRkxPV19JTiwgZmFsc2UsIHRydWUpO1xuICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoaXNFeHBsaWNpdFBhaXIgfHwgc3RhdGUubGluZSA9PT0gX2xpbmUpICYmIDB4M0EvKiA6ICovID09PSBjaCkge1xuICAgICAgaXNQYWlyID0gdHJ1ZTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuICAgICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfRkxPV19JTiwgZmFsc2UsIHRydWUpO1xuICAgICAgdmFsdWVOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgIH1cblxuICAgIGlmIChpc01hcHBpbmcpIHtcbiAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKTtcbiAgICB9IGVsc2UgaWYgKGlzUGFpcikge1xuICAgICAgX3Jlc3VsdC5wdXNoKHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIG51bGwsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9yZXN1bHQucHVzaChrZXlOb2RlKTtcbiAgICB9XG5cbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoMHgyQy8qICwgKi8gPT09IGNoKSB7XG4gICAgICByZWFkTmV4dCA9IHRydWU7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlYWROZXh0ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgZmxvdyBjb2xsZWN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgY2FwdHVyZVN0YXJ0LFxuICAgICAgZm9sZGluZyxcbiAgICAgIGNob21waW5nICAgICAgID0gQ0hPTVBJTkdfQ0xJUCxcbiAgICAgIGRldGVjdGVkSW5kZW50ID0gZmFsc2UsXG4gICAgICB0ZXh0SW5kZW50ICAgICA9IG5vZGVJbmRlbnQsXG4gICAgICBlbXB0eUxpbmVzICAgICA9IDAsXG4gICAgICBhdE1vcmVJbmRlbnRlZCA9IGZhbHNlLFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4N0MvKiB8ICovKSB7XG4gICAgZm9sZGluZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDNFLyogPiAqLykge1xuICAgIGZvbGRpbmcgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG5cbiAgd2hpbGUgKDAgIT09IGNoKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKDB4MkIvKiArICovID09PSBjaCB8fCAweDJELyogLSAqLyA9PT0gY2gpIHtcbiAgICAgIGlmIChDSE9NUElOR19DTElQID09PSBjaG9tcGluZykge1xuICAgICAgICBjaG9tcGluZyA9ICgweDJCLyogKyAqLyA9PT0gY2gpID8gQ0hPTVBJTkdfS0VFUCA6IENIT01QSU5HX1NUUklQO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3JlcGVhdCBvZiBhIGNob21waW5nIG1vZGUgaWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgodG1wID0gZnJvbURlY2ltYWxDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgaWYgKHRtcCA9PT0gMCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGV4cGxpY2l0IGluZGVudGF0aW9uIHdpZHRoIG9mIGEgYmxvY2sgc2NhbGFyOyBpdCBjYW5ub3QgYmUgbGVzcyB0aGFuIG9uZScpO1xuICAgICAgfSBlbHNlIGlmICghZGV0ZWN0ZWRJbmRlbnQpIHtcbiAgICAgICAgdGV4dEluZGVudCA9IG5vZGVJbmRlbnQgKyB0bXAgLSAxO1xuICAgICAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAncmVwZWF0IG9mIGFuIGluZGVudGF0aW9uIHdpZHRoIGlkZW50aWZpZXInKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKTtcblxuICAgIGlmICgweDIzLyogIyAqLyA9PT0gY2gpIHtcbiAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKDAgIT09IGNoKSk7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKDAgIT09IGNoKSB7XG4gICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG4gICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgd2hpbGUgKCghZGV0ZWN0ZWRJbmRlbnQgfHwgc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpICYmXG4gICAgICAgICAgICgweDIwLyogU3BhY2UgKi8gPT09IGNoKSkge1xuICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmICghZGV0ZWN0ZWRJbmRlbnQgJiYgc3RhdGUubGluZUluZGVudCA+IHRleHRJbmRlbnQpIHtcbiAgICAgIHRleHRJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBlbXB0eUxpbmVzKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBFbmQgb2YgdGhlIHNjYWxhci5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpIHtcblxuICAgICAgLy8gUGVyZm9ybSB0aGUgY2hvbXBpbmcuXG4gICAgICBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0tFRVApIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMpO1xuICAgICAgfSBlbHNlIGlmIChjaG9tcGluZyA9PT0gQ0hPTVBJTkdfQ0xJUCkge1xuICAgICAgICBpZiAoZGV0ZWN0ZWRJbmRlbnQpIHsgLy8gaS5lLiBvbmx5IGlmIHRoZSBzY2FsYXIgaXMgbm90IGVtcHR5LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBCcmVhayB0aGlzIGB3aGlsZWAgY3ljbGUgYW5kIGdvIHRvIHRoZSBmdW5jaXRvbidzIGVwaWxvZ3VlLlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gRm9sZGVkIHN0eWxlOiB1c2UgZmFuY3kgcnVsZXMgdG8gaGFuZGxlIGxpbmUgYnJlYWtzLlxuICAgIGlmIChmb2xkaW5nKSB7XG5cbiAgICAgIC8vIExpbmVzIHN0YXJ0aW5nIHdpdGggd2hpdGUgc3BhY2UgY2hhcmFjdGVycyAobW9yZS1pbmRlbnRlZCBsaW5lcykgYXJlIG5vdCBmb2xkZWQuXG4gICAgICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGF0TW9yZUluZGVudGVkID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMgKyAxKTtcblxuICAgICAgLy8gRW5kIG9mIG1vcmUtaW5kZW50ZWQgYmxvY2suXG4gICAgICB9IGVsc2UgaWYgKGF0TW9yZUluZGVudGVkKSB7XG4gICAgICAgIGF0TW9yZUluZGVudGVkID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzICsgMSk7XG5cbiAgICAgIC8vIEp1c3Qgb25lIGxpbmUgYnJlYWsgLSBwZXJjZWl2ZSBhcyB0aGUgc2FtZSBsaW5lLlxuICAgICAgfSBlbHNlIGlmICgwID09PSBlbXB0eUxpbmVzKSB7XG4gICAgICAgIGlmIChkZXRlY3RlZEluZGVudCkgeyAvLyBpLmUuIG9ubHkgaWYgd2UgaGF2ZSBhbHJlYWR5IHJlYWQgc29tZSBzY2FsYXIgY29udGVudC5cbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gJyAnO1xuICAgICAgICB9XG5cbiAgICAgIC8vIFNldmVyYWwgbGluZSBicmVha3MgLSBwZXJjZWl2ZSBhcyBkaWZmZXJlbnQgbGluZXMuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZW1wdHlMaW5lcyk7XG4gICAgICB9XG5cbiAgICAvLyBMaXRlcmFsIHN0eWxlOiBqdXN0IGFkZCBleGFjdCBudW1iZXIgb2YgbGluZSBicmVha3MgYmV0d2VlbiBjb250ZW50IGxpbmVzLlxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIElmIGN1cnJlbnQgbGluZSBpc24ndCB0aGUgZmlyc3Qgb25lIC0gY291bnQgbGluZSBicmVhayBmcm9tIHRoZSBsYXN0IGNvbnRlbnQgbGluZS5cbiAgICAgIGlmIChkZXRlY3RlZEluZGVudCkge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZW1wdHlMaW5lcyArIDEpO1xuXG4gICAgICAvLyBJbiBjYXNlIG9mIHRoZSBmaXJzdCBjb250ZW50IGxpbmUgLSBjb3VudCBvbmx5IGVtcHR5IGxpbmVzLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRldGVjdGVkSW5kZW50ID0gdHJ1ZTtcbiAgICBlbXB0eUxpbmVzID0gMDtcbiAgICBjYXB0dXJlU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIHdoaWxlICghaXNfRU9MKGNoKSAmJiAoMCAhPT0gY2gpKVxuICAgIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG5cbiAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBfbGluZSxcbiAgICAgIF90YWcgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9hbmNob3IgICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIF9yZXN1bHQgICA9IFtdLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgZGV0ZWN0ZWQgID0gZmFsc2UsXG4gICAgICBjaDtcblxuICBpZiAobnVsbCAhPT0gc3RhdGUuYW5jaG9yKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoMCAhPT0gY2gpIHtcblxuICAgIGlmICgweDJELyogLSAqLyAhPT0gY2gpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgIGlmICghaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgaWYgKHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKSkge1xuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPD0gbm9kZUluZGVudCkge1xuICAgICAgICBfcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9saW5lID0gc3RhdGUubGluZTtcbiAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19JTiwgZmFsc2UsIHRydWUpO1xuICAgIF9yZXN1bHQucHVzaChzdGF0ZS5yZXN1bHQpO1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSAmJiAoMCAhPT0gY2gpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgc2VxdWVuY2UgZW50cnknKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBub2RlSW5kZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoZGV0ZWN0ZWQpIHtcbiAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgc3RhdGUua2luZCA9ICdzZXF1ZW5jZSc7XG4gICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgbm9kZUluZGVudCwgZmxvd0luZGVudCkge1xuICB2YXIgZm9sbG93aW5nLFxuICAgICAgYWxsb3dDb21wYWN0LFxuICAgICAgX2xpbmUsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgX2FuY2hvciAgICAgICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIF9yZXN1bHQgICAgICAgPSB7fSxcbiAgICAgIGtleVRhZyAgICAgICAgPSBudWxsLFxuICAgICAga2V5Tm9kZSAgICAgICA9IG51bGwsXG4gICAgICB2YWx1ZU5vZGUgICAgID0gbnVsbCxcbiAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZSxcbiAgICAgIGRldGVjdGVkICAgICAgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmIChudWxsICE9PSBzdGF0ZS5hbmNob3IpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlICgwICE9PSBjaCkge1xuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7IC8vIFNhdmUgdGhlIGN1cnJlbnQgbGluZS5cblxuICAgIC8vXG4gICAgLy8gRXhwbGljaXQgbm90YXRpb24gY2FzZS4gVGhlcmUgYXJlIHR3byBzZXBhcmF0ZSBibG9ja3M6XG4gICAgLy8gZmlyc3QgZm9yIHRoZSBrZXkgKGRlbm90ZWQgYnkgXCI/XCIpIGFuZCBzZWNvbmQgZm9yIHRoZSB2YWx1ZSAoZGVub3RlZCBieSBcIjpcIilcbiAgICAvL1xuICAgIGlmICgoMHgzRi8qID8gKi8gPT09IGNoIHx8IDB4M0EvKiA6ICovICA9PT0gY2gpICYmIGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG5cbiAgICAgIGlmICgweDNGLyogPyAqLyA9PT0gY2gpIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBrZXlUYWcsIGtleU5vZGUsIG51bGwpO1xuICAgICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICBhdEV4cGxpY2l0S2V5ID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dDb21wYWN0ID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgIC8vIGkuZS4gMHgzQS8qIDogKi8gPT09IGNoYXJhY3RlciBhZnRlciB0aGUgZXhwbGljaXQga2V5LlxuICAgICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgIGFsbG93Q29tcGFjdCA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbmNvbXBsZXRlIGV4cGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBrZXkgbm9kZSBpcyBtaXNzZWQnKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMTtcbiAgICAgIGNoID0gZm9sbG93aW5nO1xuXG4gICAgLy9cbiAgICAvLyBJbXBsaWNpdCBub3RhdGlvbiBjYXNlLiBGbG93LXN0eWxlIG5vZGUgYXMgdGhlIGtleSBmaXJzdCwgdGhlbiBcIjpcIiwgYW5kIHRoZSB2YWx1ZS5cbiAgICAvL1xuICAgIH0gZWxzZSBpZiAoY29tcG9zZU5vZGUoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19PVVQsIGZhbHNlLCB0cnVlKSkge1xuXG4gICAgICBpZiAoc3RhdGUubGluZSA9PT0gX2xpbmUpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKDB4M0EvKiA6ICovID09PSBjaCkge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICAgIGlmICghaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Egd2hpdGVzcGFjZSBjaGFyYWN0ZXIgaXMgZXhwZWN0ZWQgYWZ0ZXIgdGhlIGtleS12YWx1ZSBzZXBhcmF0b3Igd2l0aGluIGEgYmxvY2sgbWFwcGluZycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBrZXlUYWcsIGtleU5vZGUsIG51bGwpO1xuICAgICAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgICAgICAgICBhbGxvd0NvbXBhY3QgPSBmYWxzZTtcbiAgICAgICAgICBrZXlUYWcgPSBzdGF0ZS50YWc7XG4gICAgICAgICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcblxuICAgICAgICB9IGVsc2UgaWYgKGRldGVjdGVkKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2NhbiBub3QgcmVhZCBhbiBpbXBsaWNpdCBtYXBwaW5nIHBhaXI7IGEgY29sb24gaXMgbWlzc2VkJyk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICAgICAgcmV0dXJuIHRydWU7IC8vIEtlZXAgdGhlIHJlc3VsdCBvZiBgY29tcG9zZU5vZGVgLlxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2NhbiBub3QgcmVhZCBhIGJsb2NrIG1hcHBpbmcgZW50cnk7IGEgbXVsdGlsaW5lIGtleSBtYXkgbm90IGJlIGFuIGltcGxpY2l0IGtleScpO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gS2VlcCB0aGUgcmVzdWx0IG9mIGBjb21wb3NlTm9kZWAuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7IC8vIFJlYWRpbmcgaXMgZG9uZS4gR28gdG8gdGhlIGVwaWxvZ3VlLlxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gQ29tbW9uIHJlYWRpbmcgY29kZSBmb3IgYm90aCBleHBsaWNpdCBhbmQgaW1wbGljaXQgbm90YXRpb25zLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSB7XG4gICAgICBpZiAoY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfQkxPQ0tfT1VULCB0cnVlLCBhbGxvd0NvbXBhY3QpKSB7XG4gICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKTtcbiAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50ICYmICgwICE9PSBjaCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgaW5kZW50YXRpb24gb2YgYSBtYXBwaW5nIGVudHJ5Jyk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgbm9kZUluZGVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy9cbiAgLy8gRXBpbG9ndWUuXG4gIC8vXG5cbiAgLy8gU3BlY2lhbCBjYXNlOiBsYXN0IG1hcHBpbmcncyBub2RlIGNvbnRhaW5zIG9ubHkgdGhlIGtleSBpbiBleHBsaWNpdCBub3RhdGlvbi5cbiAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBrZXlUYWcsIGtleU5vZGUsIG51bGwpO1xuICB9XG5cbiAgLy8gRXhwb3NlIHRoZSByZXN1bHRpbmcgbWFwcGluZy5cbiAgaWYgKGRldGVjdGVkKSB7XG4gICAgc3RhdGUudGFnID0gX3RhZztcbiAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgIHN0YXRlLmtpbmQgPSAnbWFwcGluZyc7XG4gICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBkZXRlY3RlZDtcbn1cblxuZnVuY3Rpb24gcmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sXG4gICAgICBpc1ZlcmJhdGltID0gZmFsc2UsXG4gICAgICBpc05hbWVkICAgID0gZmFsc2UsXG4gICAgICB0YWdIYW5kbGUsXG4gICAgICB0YWdOYW1lLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoMHgyMS8qICEgKi8gIT09IGNoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG51bGwgIT09IHN0YXRlLnRhZykge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiBhIHRhZyBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmICgweDNDLyogPCAqLyA9PT0gY2gpIHtcbiAgICBpc1ZlcmJhdGltID0gdHJ1ZTtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgfSBlbHNlIGlmICgweDIxLyogISAqLyA9PT0gY2gpIHtcbiAgICBpc05hbWVkID0gdHJ1ZTtcbiAgICB0YWdIYW5kbGUgPSAnISEnO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB9IGVsc2Uge1xuICAgIHRhZ0hhbmRsZSA9ICchJztcbiAgfVxuXG4gIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIGlmIChpc1ZlcmJhdGltKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoMCAhPT0gY2ggJiYgMHgzRS8qID4gKi8gIT09IGNoKTtcblxuICAgIGlmIChzdGF0ZS5wb3NpdGlvbiA8IHN0YXRlLmxlbmd0aCkge1xuICAgICAgdGFnTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSB2ZXJiYXRpbSB0YWcnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKDAgIT09IGNoICYmICFpc19XU19PUl9FT0woY2gpKSB7XG5cbiAgICAgIGlmICgweDIxLyogISAqLyA9PT0gY2gpIHtcbiAgICAgICAgaWYgKCFpc05hbWVkKSB7XG4gICAgICAgICAgdGFnSGFuZGxlID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uIC0gMSwgc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgICAgIGlmICghUEFUVEVSTl9UQUdfSEFORExFLnRlc3QodGFnSGFuZGxlKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWVkIHRhZyBoYW5kbGUgY2Fubm90IGNvbnRhaW4gc3VjaCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXNOYW1lZCA9IHRydWU7XG4gICAgICAgICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb24gKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgc3VmZml4IGNhbm5vdCBjb250YWluIGV4Y2xhbWF0aW9uIG1hcmtzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIHRhZ05hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChQQVRURVJOX0ZMT1dfSU5ESUNBVE9SUy50ZXN0KHRhZ05hbWUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBmbG93IGluZGljYXRvciBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRhZ05hbWUgJiYgIVBBVFRFUk5fVEFHX1VSSS50ZXN0KHRhZ05hbWUpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBuYW1lIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVyczogJyArIHRhZ05hbWUpO1xuICB9XG5cbiAgaWYgKGlzVmVyYmF0aW0pIHtcbiAgICBzdGF0ZS50YWcgPSB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoc3RhdGUudGFnTWFwLCB0YWdIYW5kbGUpKSB7XG4gICAgc3RhdGUudGFnID0gc3RhdGUudGFnTWFwW3RhZ0hhbmRsZV0gKyB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAoJyEnID09PSB0YWdIYW5kbGUpIHtcbiAgICBzdGF0ZS50YWcgPSAnIScgKyB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAoJyEhJyA9PT0gdGFnSGFuZGxlKSB7XG4gICAgc3RhdGUudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOicgKyB0YWdOYW1lO1xuXG4gIH0gZWxzZSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZGVjbGFyZWQgdGFnIGhhbmRsZSBcIicgKyB0YWdIYW5kbGUgKyAnXCInKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbixcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKDB4MjYvKiAmICovICE9PSBjaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChudWxsICE9PSBzdGF0ZS5hbmNob3IpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRpb24gb2YgYW4gYW5jaG9yIHByb3BlcnR5Jyk7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlICgwICE9PSBjaCAmJiAhaXNfV1NfT1JfRU9MKGNoKSAmJiAhaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBfcG9zaXRpb24pIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbmFtZSBvZiBhbiBhbmNob3Igbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlcicpO1xuICB9XG5cbiAgc3RhdGUuYW5jaG9yID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWFkQWxpYXMoc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbiwgYWxpYXMsXG4gICAgICBsZW4gPSBzdGF0ZS5sZW5ndGgsXG4gICAgICBpbnB1dCA9IHN0YXRlLmlucHV0LFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoMHgyQS8qICogKi8gIT09IGNoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoMCAhPT0gY2ggJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYWxpYXMgbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlcicpO1xuICB9XG5cbiAgYWxpYXMgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoIXN0YXRlLmFuY2hvck1hcC5oYXNPd25Qcm9wZXJ0eShhbGlhcykpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5pZGVudGlmaWVkIGFsaWFzIFwiJyArIGFsaWFzICsgJ1wiJyk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bHQgPSBzdGF0ZS5hbmNob3JNYXBbYWxpYXNdO1xuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb21wb3NlTm9kZShzdGF0ZSwgcGFyZW50SW5kZW50LCBub2RlQ29udGV4dCwgYWxsb3dUb1NlZWssIGFsbG93Q29tcGFjdCkge1xuICB2YXIgYWxsb3dCbG9ja1N0eWxlcyxcbiAgICAgIGFsbG93QmxvY2tTY2FsYXJzLFxuICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zLFxuICAgICAgaW5kZW50U3RhdHVzID0gMSwgLy8gMTogdGhpcz5wYXJlbnQsIDA6IHRoaXM9cGFyZW50LCAtMTogdGhpczxwYXJlbnRcbiAgICAgIGF0TmV3TGluZSAgPSBmYWxzZSxcbiAgICAgIGhhc0NvbnRlbnQgPSBmYWxzZSxcbiAgICAgIHR5cGVJbmRleCxcbiAgICAgIHR5cGVRdWFudGl0eSxcbiAgICAgIHR5cGUsXG4gICAgICBmbG93SW5kZW50LFxuICAgICAgYmxvY2tJbmRlbnQsXG4gICAgICBfcmVzdWx0O1xuXG4gIHN0YXRlLnRhZyAgICA9IG51bGw7XG4gIHN0YXRlLmFuY2hvciA9IG51bGw7XG4gIHN0YXRlLmtpbmQgICA9IG51bGw7XG4gIHN0YXRlLnJlc3VsdCA9IG51bGw7XG5cbiAgYWxsb3dCbG9ja1N0eWxlcyA9IGFsbG93QmxvY2tTY2FsYXJzID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zID1cbiAgICBDT05URVhUX0JMT0NLX09VVCA9PT0gbm9kZUNvbnRleHQgfHxcbiAgICBDT05URVhUX0JMT0NLX0lOICA9PT0gbm9kZUNvbnRleHQ7XG5cbiAgaWYgKGFsbG93VG9TZWVrKSB7XG4gICAgaWYgKHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKSkge1xuICAgICAgYXROZXdMaW5lID0gdHJ1ZTtcblxuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaW5kZW50U3RhdHVzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaW5kZW50U3RhdHVzID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKDEgPT09IGluZGVudFN0YXR1cykge1xuICAgIHdoaWxlIChyZWFkVGFnUHJvcGVydHkoc3RhdGUpIHx8IHJlYWRBbmNob3JQcm9wZXJ0eShzdGF0ZSkpIHtcbiAgICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgICAgYXROZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYWxsb3dCbG9ja1N0eWxlcztcblxuICAgICAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gcGFyZW50SW5kZW50KSB7XG4gICAgICAgICAgaW5kZW50U3RhdHVzID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgICAgaW5kZW50U3RhdHVzID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhbGxvd0Jsb2NrQ29sbGVjdGlvbnMpIHtcbiAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBhdE5ld0xpbmUgfHwgYWxsb3dDb21wYWN0O1xuICB9XG5cbiAgaWYgKDEgPT09IGluZGVudFN0YXR1cyB8fCBDT05URVhUX0JMT0NLX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICBpZiAoQ09OVEVYVF9GTE9XX0lOID09PSBub2RlQ29udGV4dCB8fCBDT05URVhUX0ZMT1dfT1VUID09PSBub2RlQ29udGV4dCkge1xuICAgICAgZmxvd0luZGVudCA9IHBhcmVudEluZGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxvd0luZGVudCA9IHBhcmVudEluZGVudCArIDE7XG4gICAgfVxuXG4gICAgYmxvY2tJbmRlbnQgPSBzdGF0ZS5wb3NpdGlvbiAtIHN0YXRlLmxpbmVTdGFydDtcblxuICAgIGlmICgxID09PSBpbmRlbnRTdGF0dXMpIHtcbiAgICAgIGlmIChhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgJiZcbiAgICAgICAgICAocmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIGJsb2NrSW5kZW50KSB8fFxuICAgICAgICAgICByZWFkQmxvY2tNYXBwaW5nKHN0YXRlLCBibG9ja0luZGVudCwgZmxvd0luZGVudCkpIHx8XG4gICAgICAgICAgcmVhZEZsb3dDb2xsZWN0aW9uKHN0YXRlLCBmbG93SW5kZW50KSkge1xuICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgoYWxsb3dCbG9ja1NjYWxhcnMgJiYgcmVhZEJsb2NrU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSkgfHxcbiAgICAgICAgICAgIHJlYWRTaW5nbGVRdW90ZWRTY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQpIHx8XG4gICAgICAgICAgICByZWFkRG91YmxlUXVvdGVkU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSkge1xuICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVhZEFsaWFzKHN0YXRlKSkge1xuICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKG51bGwgIT09IHN0YXRlLnRhZyB8fCBudWxsICE9PSBzdGF0ZS5hbmNob3IpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdhbGlhcyBub2RlIHNob3VsZCBub3QgaGF2ZSBhbnkgcHJvcGVydGllcycpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRQbGFpblNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCwgQ09OVEVYVF9GTE9XX0lOID09PSBub2RlQ29udGV4dCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChudWxsID09PSBzdGF0ZS50YWcpIHtcbiAgICAgICAgICAgIHN0YXRlLnRhZyA9ICc/JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobnVsbCAhPT0gc3RhdGUuYW5jaG9yKSB7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKDAgPT09IGluZGVudFN0YXR1cykge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlOiBibG9jayBzZXF1ZW5jZXMgYXJlIGFsbG93ZWQgdG8gaGF2ZSBzYW1lIGluZGVudGF0aW9uIGxldmVsIGFzIHRoZSBwYXJlbnQuXG4gICAgICAvLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI3OTk3ODRcbiAgICAgIGhhc0NvbnRlbnQgPSBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgJiYgcmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIGJsb2NrSW5kZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAobnVsbCAhPT0gc3RhdGUudGFnICYmICchJyAhPT0gc3RhdGUudGFnKSB7XG4gICAgaWYgKCc/JyA9PT0gc3RhdGUudGFnKSB7XG4gICAgICBmb3IgKHR5cGVJbmRleCA9IDAsIHR5cGVRdWFudGl0eSA9IHN0YXRlLmltcGxpY2l0VHlwZXMubGVuZ3RoO1xuICAgICAgICAgICB0eXBlSW5kZXggPCB0eXBlUXVhbnRpdHk7XG4gICAgICAgICAgIHR5cGVJbmRleCArPSAxKSB7XG4gICAgICAgIHR5cGUgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzW3R5cGVJbmRleF07XG5cbiAgICAgICAgLy8gSW1wbGljaXQgcmVzb2x2aW5nIGlzIG5vdCBhbGxvd2VkIGZvciBub24tc2NhbGFyIHR5cGVzLCBhbmQgJz8nXG4gICAgICAgIC8vIG5vbi1zcGVjaWZpYyB0YWcgaXMgb25seSBhc3NpZ25lZCB0byBwbGFpbiBzY2FsYXJzLiBTbywgaXQgaXNuJ3RcbiAgICAgICAgLy8gbmVlZGVkIHRvIGNoZWNrIGZvciAna2luZCcgY29uZm9ybWl0eS5cblxuICAgICAgICBpZiAodHlwZS5yZXNvbHZlKHN0YXRlLnJlc3VsdCkpIHsgLy8gYHN0YXRlLnJlc3VsdGAgdXBkYXRlZCBpbiByZXNvbHZlciBpZiBtYXRjaGVkXG4gICAgICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0KTtcbiAgICAgICAgICBzdGF0ZS50YWcgPSB0eXBlLnRhZztcbiAgICAgICAgICBpZiAobnVsbCAhPT0gc3RhdGUuYW5jaG9yKSB7XG4gICAgICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnR5cGVNYXAsIHN0YXRlLnRhZykpIHtcbiAgICAgIHR5cGUgPSBzdGF0ZS50eXBlTWFwW3N0YXRlLnRhZ107XG5cbiAgICAgIGlmIChudWxsICE9PSBzdGF0ZS5yZXN1bHQgJiYgdHlwZS5raW5kICE9PSBzdGF0ZS5raW5kKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgbm9kZSBraW5kIGZvciAhPCcgKyBzdGF0ZS50YWcgKyAnPiB0YWc7IGl0IHNob3VsZCBiZSBcIicgKyB0eXBlLmtpbmQgKyAnXCIsIG5vdCBcIicgKyBzdGF0ZS5raW5kICsgJ1wiJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdHlwZS5yZXNvbHZlKHN0YXRlLnJlc3VsdCkpIHsgLy8gYHN0YXRlLnJlc3VsdGAgdXBkYXRlZCBpbiByZXNvbHZlciBpZiBtYXRjaGVkXG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW5ub3QgcmVzb2x2ZSBhIG5vZGUgd2l0aCAhPCcgKyBzdGF0ZS50YWcgKyAnPiBleHBsaWNpdCB0YWcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCA9IHR5cGUuY29uc3RydWN0KHN0YXRlLnJlc3VsdCk7XG4gICAgICAgIGlmIChudWxsICE9PSBzdGF0ZS5hbmNob3IpIHtcbiAgICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICd1bmtub3duIHRhZyAhPCcgKyBzdGF0ZS50YWcgKyAnPicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsICE9PSBzdGF0ZS50YWcgfHwgbnVsbCAhPT0gc3RhdGUuYW5jaG9yIHx8IGhhc0NvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIHJlYWREb2N1bWVudChzdGF0ZSkge1xuICB2YXIgZG9jdW1lbnRTdGFydCA9IHN0YXRlLnBvc2l0aW9uLFxuICAgICAgX3Bvc2l0aW9uLFxuICAgICAgZGlyZWN0aXZlTmFtZSxcbiAgICAgIGRpcmVjdGl2ZUFyZ3MsXG4gICAgICBoYXNEaXJlY3RpdmVzID0gZmFsc2UsXG4gICAgICBjaDtcblxuICBzdGF0ZS52ZXJzaW9uID0gbnVsbDtcbiAgc3RhdGUuY2hlY2tMaW5lQnJlYWtzID0gc3RhdGUubGVnYWN5O1xuICBzdGF0ZS50YWdNYXAgPSB7fTtcbiAgc3RhdGUuYW5jaG9yTWFwID0ge307XG5cbiAgd2hpbGUgKDAgIT09IChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSkge1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IDAgfHwgMHgyNS8qICUgKi8gIT09IGNoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBoYXNEaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB3aGlsZSAoMCAhPT0gY2ggJiYgIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBkaXJlY3RpdmVOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG4gICAgZGlyZWN0aXZlQXJncyA9IFtdO1xuXG4gICAgaWYgKGRpcmVjdGl2ZU5hbWUubGVuZ3RoIDwgMSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2RpcmVjdGl2ZSBuYW1lIG11c3Qgbm90IGJlIGxlc3MgdGhhbiBvbmUgY2hhcmFjdGVyIGluIGxlbmd0aCcpO1xuICAgIH1cblxuICAgIHdoaWxlICgwICE9PSBjaCkge1xuICAgICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmICgweDIzLyogIyAqLyA9PT0gY2gpIHtcbiAgICAgICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICAgICAgd2hpbGUgKDAgIT09IGNoICYmICFpc19FT0woY2gpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgICAgd2hpbGUgKDAgIT09IGNoICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGlyZWN0aXZlQXJncy5wdXNoKHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pKTtcbiAgICB9XG5cbiAgICBpZiAoMCAhPT0gY2gpIHtcbiAgICAgIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChkaXJlY3RpdmVIYW5kbGVycywgZGlyZWN0aXZlTmFtZSkpIHtcbiAgICAgIGRpcmVjdGl2ZUhhbmRsZXJzW2RpcmVjdGl2ZU5hbWVdKHN0YXRlLCBkaXJlY3RpdmVOYW1lLCBkaXJlY3RpdmVBcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAndW5rbm93biBkb2N1bWVudCBkaXJlY3RpdmUgXCInICsgZGlyZWN0aXZlTmFtZSArICdcIicpO1xuICAgIH1cbiAgfVxuXG4gIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICBpZiAoMCA9PT0gc3RhdGUubGluZUluZGVudCAmJlxuICAgICAgMHgyRC8qIC0gKi8gPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pICYmXG4gICAgICAweDJELyogLSAqLyA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpICYmXG4gICAgICAweDJELyogLSAqLyA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDIpKSB7XG4gICAgc3RhdGUucG9zaXRpb24gKz0gMztcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgfSBlbHNlIGlmIChoYXNEaXJlY3RpdmVzKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2RpcmVjdGl2ZXMgZW5kIG1hcmsgaXMgZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGNvbXBvc2VOb2RlKHN0YXRlLCBzdGF0ZS5saW5lSW5kZW50IC0gMSwgQ09OVEVYVF9CTE9DS19PVVQsIGZhbHNlLCB0cnVlKTtcbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIGlmIChzdGF0ZS5jaGVja0xpbmVCcmVha3MgJiZcbiAgICAgIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTLnRlc3Qoc3RhdGUuaW5wdXQuc2xpY2UoZG9jdW1lbnRTdGFydCwgc3RhdGUucG9zaXRpb24pKSkge1xuICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ25vbi1BU0NJSSBsaW5lIGJyZWFrcyBhcmUgaW50ZXJwcmV0ZWQgYXMgY29udGVudCcpO1xuICB9XG5cbiAgc3RhdGUuZG9jdW1lbnRzLnB1c2goc3RhdGUucmVzdWx0KTtcblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG5cbiAgICBpZiAoMHgyRS8qIC4gKi8gPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiArPSAzO1xuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPCAoc3RhdGUubGVuZ3RoIC0gMSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZW5kIG9mIHRoZSBzdHJlYW0gb3IgYSBkb2N1bWVudCBzZXBhcmF0b3IgaXMgZXhwZWN0ZWQnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKSB7XG4gIGlucHV0ID0gU3RyaW5nKGlucHV0KTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKDAgIT09IGlucHV0Lmxlbmd0aCAmJlxuICAgICAgMHgwQS8qIExGICovICE9PSBpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpICYmXG4gICAgICAweDBELyogQ1IgKi8gIT09IGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkpIHtcbiAgICBpbnB1dCArPSAnXFxuJztcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShpbnB1dCwgb3B0aW9ucyk7XG5cbiAgaWYgKFBBVFRFUk5fTk9OX1BSSU5UQUJMRS50ZXN0KHN0YXRlLmlucHV0KSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd0aGUgc3RyZWFtIGNvbnRhaW5zIG5vbi1wcmludGFibGUgY2hhcmFjdGVycycpO1xuICB9XG5cbiAgLy8gVXNlIDAgYXMgc3RyaW5nIHRlcm1pbmF0b3IuIFRoYXQgc2lnbmlmaWNhbnRseSBzaW1wbGlmaWVzIGJvdW5kcyBjaGVjay5cbiAgc3RhdGUuaW5wdXQgKz0gJ1xcMCc7XG5cbiAgd2hpbGUgKDB4MjAvKiBTcGFjZSAqLyA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpIHtcbiAgICBzdGF0ZS5saW5lSW5kZW50ICs9IDE7XG4gICAgc3RhdGUucG9zaXRpb24gKz0gMTtcbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5wb3NpdGlvbiA8IChzdGF0ZS5sZW5ndGggLSAxKSkge1xuICAgIHJlYWREb2N1bWVudChzdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGUuZG9jdW1lbnRzO1xufVxuXG5cbmZ1bmN0aW9uIGxvYWRBbGwoaW5wdXQsIGl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIHZhciBkb2N1bWVudHMgPSBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKSwgaW5kZXgsIGxlbmd0aDtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gZG9jdW1lbnRzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBpdGVyYXRvcihkb2N1bWVudHNbaW5kZXhdKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGxvYWQoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRvY3VtZW50cyA9IGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpLCBpbmRleCwgbGVuZ3RoO1xuXG4gIGlmICgwID09PSBkb2N1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmICgxID09PSBkb2N1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50c1swXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignZXhwZWN0ZWQgYSBzaW5nbGUgZG9jdW1lbnQgaW4gdGhlIHN0cmVhbSwgYnV0IGZvdW5kIG1vcmUnKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHNhZmVMb2FkQWxsKGlucHV0LCBvdXRwdXQsIG9wdGlvbnMpIHtcbiAgbG9hZEFsbChpbnB1dCwgb3V0cHV0LCBjb21tb24uZXh0ZW5kKHsgc2NoZW1hOiBERUZBVUxUX1NBRkVfU0NIRU1BIH0sIG9wdGlvbnMpKTtcbn1cblxuXG5mdW5jdGlvbiBzYWZlTG9hZChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbG9hZChpbnB1dCwgY29tbW9uLmV4dGVuZCh7IHNjaGVtYTogREVGQVVMVF9TQUZFX1NDSEVNQSB9LCBvcHRpb25zKSk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMubG9hZEFsbCAgICAgPSBsb2FkQWxsO1xubW9kdWxlLmV4cG9ydHMubG9hZCAgICAgICAgPSBsb2FkO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWRBbGwgPSBzYWZlTG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLnNhZmVMb2FkICAgID0gc2FmZUxvYWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuZnVuY3Rpb24gTWFyayhuYW1lLCBidWZmZXIsIHBvc2l0aW9uLCBsaW5lLCBjb2x1bW4pIHtcbiAgdGhpcy5uYW1lICAgICA9IG5hbWU7XG4gIHRoaXMuYnVmZmVyICAgPSBidWZmZXI7XG4gIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgdGhpcy5saW5lICAgICA9IGxpbmU7XG4gIHRoaXMuY29sdW1uICAgPSBjb2x1bW47XG59XG5cblxuTWFyay5wcm90b3R5cGUuZ2V0U25pcHBldCA9IGZ1bmN0aW9uIGdldFNuaXBwZXQoaW5kZW50LCBtYXhMZW5ndGgpIHtcbiAgdmFyIGhlYWQsIHN0YXJ0LCB0YWlsLCBlbmQsIHNuaXBwZXQ7XG5cbiAgaWYgKCF0aGlzLmJ1ZmZlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaW5kZW50ID0gaW5kZW50IHx8IDQ7XG4gIG1heExlbmd0aCA9IG1heExlbmd0aCB8fCA3NTtcblxuICBoZWFkID0gJyc7XG4gIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbjtcblxuICB3aGlsZSAoc3RhcnQgPiAwICYmIC0xID09PSAnXFx4MDBcXHJcXG5cXHg4NVxcdTIwMjhcXHUyMDI5Jy5pbmRleE9mKHRoaXMuYnVmZmVyLmNoYXJBdChzdGFydCAtIDEpKSkge1xuICAgIHN0YXJ0IC09IDE7XG4gICAgaWYgKHRoaXMucG9zaXRpb24gLSBzdGFydCA+IChtYXhMZW5ndGggLyAyIC0gMSkpIHtcbiAgICAgIGhlYWQgPSAnIC4uLiAnO1xuICAgICAgc3RhcnQgKz0gNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRhaWwgPSAnJztcbiAgZW5kID0gdGhpcy5wb3NpdGlvbjtcblxuICB3aGlsZSAoZW5kIDwgdGhpcy5idWZmZXIubGVuZ3RoICYmIC0xID09PSAnXFx4MDBcXHJcXG5cXHg4NVxcdTIwMjhcXHUyMDI5Jy5pbmRleE9mKHRoaXMuYnVmZmVyLmNoYXJBdChlbmQpKSkge1xuICAgIGVuZCArPSAxO1xuICAgIGlmIChlbmQgLSB0aGlzLnBvc2l0aW9uID4gKG1heExlbmd0aCAvIDIgLSAxKSkge1xuICAgICAgdGFpbCA9ICcgLi4uICc7XG4gICAgICBlbmQgLT0gNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHNuaXBwZXQgPSB0aGlzLmJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTtcblxuICByZXR1cm4gY29tbW9uLnJlcGVhdCgnICcsIGluZGVudCkgKyBoZWFkICsgc25pcHBldCArIHRhaWwgKyAnXFxuJyArXG4gICAgICAgICBjb21tb24ucmVwZWF0KCcgJywgaW5kZW50ICsgdGhpcy5wb3NpdGlvbiAtIHN0YXJ0ICsgaGVhZC5sZW5ndGgpICsgJ14nO1xufTtcblxuXG5NYXJrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbXBhY3QpIHtcbiAgdmFyIHNuaXBwZXQsIHdoZXJlID0gJyc7XG5cbiAgaWYgKHRoaXMubmFtZSkge1xuICAgIHdoZXJlICs9ICdpbiBcIicgKyB0aGlzLm5hbWUgKyAnXCIgJztcbiAgfVxuXG4gIHdoZXJlICs9ICdhdCBsaW5lICcgKyAodGhpcy5saW5lICsgMSkgKyAnLCBjb2x1bW4gJyArICh0aGlzLmNvbHVtbiArIDEpO1xuXG4gIGlmICghY29tcGFjdCkge1xuICAgIHNuaXBwZXQgPSB0aGlzLmdldFNuaXBwZXQoKTtcblxuICAgIGlmIChzbmlwcGV0KSB7XG4gICAgICB3aGVyZSArPSAnOlxcbicgKyBzbmlwcGV0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3aGVyZTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBNYXJrO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBjb21tb24gICAgICAgID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbnZhciBZQU1MRXhjZXB0aW9uID0gcmVxdWlyZSgnLi9leGNlcHRpb24nKTtcbnZhciBUeXBlICAgICAgICAgID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cblxuZnVuY3Rpb24gY29tcGlsZUxpc3Qoc2NoZW1hLCBuYW1lLCByZXN1bHQpIHtcbiAgdmFyIGV4Y2x1ZGUgPSBbXTtcblxuICBzY2hlbWEuaW5jbHVkZS5mb3JFYWNoKGZ1bmN0aW9uIChpbmNsdWRlZFNjaGVtYSkge1xuICAgIHJlc3VsdCA9IGNvbXBpbGVMaXN0KGluY2x1ZGVkU2NoZW1hLCBuYW1lLCByZXN1bHQpO1xuICB9KTtcblxuICBzY2hlbWFbbmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoY3VycmVudFR5cGUpIHtcbiAgICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAocHJldmlvdXNUeXBlLCBwcmV2aW91c0luZGV4KSB7XG4gICAgICBpZiAocHJldmlvdXNUeXBlLnRhZyA9PT0gY3VycmVudFR5cGUudGFnKSB7XG4gICAgICAgIGV4Y2x1ZGUucHVzaChwcmV2aW91c0luZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlc3VsdC5wdXNoKGN1cnJlbnRUeXBlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdC5maWx0ZXIoZnVuY3Rpb24gKHR5cGUsIGluZGV4KSB7XG4gICAgcmV0dXJuIC0xID09PSBleGNsdWRlLmluZGV4T2YoaW5kZXgpO1xuICB9KTtcbn1cblxuXG5mdW5jdGlvbiBjb21waWxlTWFwKC8qIGxpc3RzLi4uICovKSB7XG4gIHZhciByZXN1bHQgPSB7fSwgaW5kZXgsIGxlbmd0aDtcblxuICBmdW5jdGlvbiBjb2xsZWN0VHlwZSh0eXBlKSB7XG4gICAgcmVzdWx0W3R5cGUudGFnXSA9IHR5cGU7XG4gIH1cblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBhcmd1bWVudHNbaW5kZXhdLmZvckVhY2goY29sbGVjdFR5cGUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBTY2hlbWEoZGVmaW5pdGlvbikge1xuICB0aGlzLmluY2x1ZGUgID0gZGVmaW5pdGlvbi5pbmNsdWRlICB8fCBbXTtcbiAgdGhpcy5pbXBsaWNpdCA9IGRlZmluaXRpb24uaW1wbGljaXQgfHwgW107XG4gIHRoaXMuZXhwbGljaXQgPSBkZWZpbml0aW9uLmV4cGxpY2l0IHx8IFtdO1xuXG4gIHRoaXMuaW1wbGljaXQuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICh0eXBlLmxvYWRLaW5kICYmICdzY2FsYXInICE9PSB0eXBlLmxvYWRLaW5kKSB7XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVGhlcmUgaXMgYSBub24tc2NhbGFyIHR5cGUgaW4gdGhlIGltcGxpY2l0IGxpc3Qgb2YgYSBzY2hlbWEuIEltcGxpY2l0IHJlc29sdmluZyBvZiBzdWNoIHR5cGVzIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICB9KTtcblxuICB0aGlzLmNvbXBpbGVkSW1wbGljaXQgPSBjb21waWxlTGlzdCh0aGlzLCAnaW1wbGljaXQnLCBbXSk7XG4gIHRoaXMuY29tcGlsZWRFeHBsaWNpdCA9IGNvbXBpbGVMaXN0KHRoaXMsICdleHBsaWNpdCcsIFtdKTtcbiAgdGhpcy5jb21waWxlZFR5cGVNYXAgID0gY29tcGlsZU1hcCh0aGlzLmNvbXBpbGVkSW1wbGljaXQsIHRoaXMuY29tcGlsZWRFeHBsaWNpdCk7XG59XG5cblxuU2NoZW1hLkRFRkFVTFQgPSBudWxsO1xuXG5cblNjaGVtYS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVTY2hlbWEoKSB7XG4gIHZhciBzY2hlbWFzLCB0eXBlcztcblxuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgY2FzZSAxOlxuICAgIHNjaGVtYXMgPSBTY2hlbWEuREVGQVVMVDtcbiAgICB0eXBlcyA9IGFyZ3VtZW50c1swXTtcbiAgICBicmVhaztcblxuICBjYXNlIDI6XG4gICAgc2NoZW1hcyA9IGFyZ3VtZW50c1swXTtcbiAgICB0eXBlcyA9IGFyZ3VtZW50c1sxXTtcbiAgICBicmVhaztcblxuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBTY2hlbWEuY3JlYXRlIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBzY2hlbWFzID0gY29tbW9uLnRvQXJyYXkoc2NoZW1hcyk7XG4gIHR5cGVzID0gY29tbW9uLnRvQXJyYXkodHlwZXMpO1xuXG4gIGlmICghc2NoZW1hcy5ldmVyeShmdW5jdGlvbiAoc2NoZW1hKSB7IHJldHVybiBzY2hlbWEgaW5zdGFuY2VvZiBTY2hlbWE7IH0pKSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1NwZWNpZmllZCBsaXN0IG9mIHN1cGVyIHNjaGVtYXMgKG9yIGEgc2luZ2xlIFNjaGVtYSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVNjaGVtYSBvYmplY3QuJyk7XG4gIH1cblxuICBpZiAoIXR5cGVzLmV2ZXJ5KGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlIGluc3RhbmNlb2YgVHlwZTsgfSkpIHtcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignU3BlY2lmaWVkIGxpc3Qgb2YgWUFNTCB0eXBlcyAob3IgYSBzaW5nbGUgVHlwZSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVR5cGUgb2JqZWN0LicpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTY2hlbWEoe1xuICAgIGluY2x1ZGU6IHNjaGVtYXMsXG4gICAgZXhwbGljaXQ6IHR5cGVzXG4gIH0pO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYTtcbiIsIi8vIFN0YW5kYXJkIFlBTUwncyBDb3JlIHNjaGVtYS5cbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwNDkyM1xuLy9cbi8vIE5PVEU6IEpTLVlBTUwgZG9lcyBub3Qgc3VwcG9ydCBzY2hlbWEtc3BlY2lmaWMgdGFnIHJlc29sdXRpb24gcmVzdHJpY3Rpb25zLlxuLy8gU28sIENvcmUgc2NoZW1hIGhhcyBubyBkaXN0aW5jdGlvbnMgZnJvbSBKU09OIHNjaGVtYSBpcyBKUy1ZQU1MLlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcbiAgaW5jbHVkZTogW1xuICAgIHJlcXVpcmUoJy4vanNvbicpXG4gIF1cbn0pO1xuIiwiLy8gSlMtWUFNTCdzIGRlZmF1bHQgc2NoZW1hIGZvciBgbG9hZGAgZnVuY3Rpb24uXG4vLyBJdCBpcyBub3QgZGVzY3JpYmVkIGluIHRoZSBZQU1MIHNwZWNpZmljYXRpb24uXG4vL1xuLy8gVGhpcyBzY2hlbWEgaXMgYmFzZWQgb24gSlMtWUFNTCdzIGRlZmF1bHQgc2FmZSBzY2hlbWEgYW5kIGluY2x1ZGVzXG4vLyBKYXZhU2NyaXB0LXNwZWNpZmljIHR5cGVzOiAhIWpzL3VuZGVmaW5lZCwgISFqcy9yZWdleHAgYW5kICEhanMvZnVuY3Rpb24uXG4vL1xuLy8gQWxzbyB0aGlzIHNjaGVtYSBpcyB1c2VkIGFzIGRlZmF1bHQgYmFzZSBzY2hlbWEgYXQgYFNjaGVtYS5jcmVhdGVgIGZ1bmN0aW9uLlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWEuREVGQVVMVCA9IG5ldyBTY2hlbWEoe1xuICBpbmNsdWRlOiBbXG4gICAgcmVxdWlyZSgnLi9kZWZhdWx0X3NhZmUnKVxuICBdLFxuICBleHBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvanMvdW5kZWZpbmVkJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9qcy9yZWdleHAnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2pzL2Z1bmN0aW9uJylcbiAgXVxufSk7XG4iLCIvLyBKUy1ZQU1MJ3MgZGVmYXVsdCBzY2hlbWEgZm9yIGBzYWZlTG9hZGAgZnVuY3Rpb24uXG4vLyBJdCBpcyBub3QgZGVzY3JpYmVkIGluIHRoZSBZQU1MIHNwZWNpZmljYXRpb24uXG4vL1xuLy8gVGhpcyBzY2hlbWEgaXMgYmFzZWQgb24gc3RhbmRhcmQgWUFNTCdzIENvcmUgc2NoZW1hIGFuZCBpbmNsdWRlcyBtb3N0IG9mXG4vLyBleHRyYSB0eXBlcyBkZXNjcmliZWQgYXQgWUFNTCB0YWcgcmVwb3NpdG9yeS4gKGh0dHA6Ly95YW1sLm9yZy90eXBlLylcblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGluY2x1ZGU6IFtcbiAgICByZXF1aXJlKCcuL2NvcmUnKVxuICBdLFxuICBpbXBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvdGltZXN0YW1wJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9tZXJnZScpXG4gIF0sXG4gIGV4cGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9iaW5hcnknKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL29tYXAnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL3BhaXJzJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9zZXQnKVxuICBdXG59KTtcbiIsIi8vIFN0YW5kYXJkIFlBTUwncyBGYWlsc2FmZSBzY2hlbWEuXG4vLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI4MDIzNDZcblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGV4cGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9zdHInKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL3NlcScpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvbWFwJylcbiAgXVxufSk7XG4iLCIvLyBTdGFuZGFyZCBZQU1MJ3MgSlNPTiBzY2hlbWEuXG4vLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI4MDMyMzFcbi8vXG4vLyBOT1RFOiBKUy1ZQU1MIGRvZXMgbm90IHN1cHBvcnQgc2NoZW1hLXNwZWNpZmljIHRhZyByZXNvbHV0aW9uIHJlc3RyaWN0aW9ucy5cbi8vIFNvLCB0aGlzIHNjaGVtYSBpcyBub3Qgc3VjaCBzdHJpY3QgYXMgZGVmaW5lZCBpbiB0aGUgWUFNTCBzcGVjaWZpY2F0aW9uLlxuLy8gSXQgYWxsb3dzIG51bWJlcnMgaW4gYmluYXJ5IG5vdGFpb24sIHVzZSBgTnVsbGAgYW5kIGBOVUxMYCBhcyBgbnVsbGAsIGV0Yy5cblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGluY2x1ZGU6IFtcbiAgICByZXF1aXJlKCcuL2ZhaWxzYWZlJylcbiAgXSxcbiAgaW1wbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL251bGwnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2Jvb2wnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2ludCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvZmxvYXQnKVxuICBdXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFlBTUxFeGNlcHRpb24gPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xuXG52YXIgVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TID0gW1xuICAna2luZCcsXG4gICdyZXNvbHZlJyxcbiAgJ2NvbnN0cnVjdCcsXG4gICdpbnN0YW5jZU9mJyxcbiAgJ3ByZWRpY2F0ZScsXG4gICdyZXByZXNlbnQnLFxuICAnZGVmYXVsdFN0eWxlJyxcbiAgJ3N0eWxlQWxpYXNlcydcbl07XG5cbnZhciBZQU1MX05PREVfS0lORFMgPSBbXG4gICdzY2FsYXInLFxuICAnc2VxdWVuY2UnLFxuICAnbWFwcGluZydcbl07XG5cbmZ1bmN0aW9uIGNvbXBpbGVTdHlsZUFsaWFzZXMobWFwKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBpZiAobnVsbCAhPT0gbWFwKSB7XG4gICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgbWFwW3N0eWxlXS5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICByZXN1bHRbU3RyaW5nKGFsaWFzKV0gPSBzdHlsZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gVHlwZSh0YWcsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICgtMSA9PT0gVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TLmluZGV4T2YobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdVbmtub3duIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiIGlzIG1ldCBpbiBkZWZpbml0aW9uIG9mIFwiJyArIHRhZyArICdcIiBZQU1MIHR5cGUuJyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBUT0RPOiBBZGQgdGFnIGZvcm1hdCBjaGVjay5cbiAgdGhpcy50YWcgICAgICAgICAgPSB0YWc7XG4gIHRoaXMua2luZCAgICAgICAgID0gb3B0aW9uc1sna2luZCddICAgICAgICAgfHwgbnVsbDtcbiAgdGhpcy5yZXNvbHZlICAgICAgPSBvcHRpb25zWydyZXNvbHZlJ10gICAgICB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICB0aGlzLmNvbnN0cnVjdCAgICA9IG9wdGlvbnNbJ2NvbnN0cnVjdCddICAgIHx8IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhOyB9O1xuICB0aGlzLmluc3RhbmNlT2YgICA9IG9wdGlvbnNbJ2luc3RhbmNlT2YnXSAgIHx8IG51bGw7XG4gIHRoaXMucHJlZGljYXRlICAgID0gb3B0aW9uc1sncHJlZGljYXRlJ10gICAgfHwgbnVsbDtcbiAgdGhpcy5yZXByZXNlbnQgICAgPSBvcHRpb25zWydyZXByZXNlbnQnXSAgICB8fCBudWxsO1xuICB0aGlzLmRlZmF1bHRTdHlsZSA9IG9wdGlvbnNbJ2RlZmF1bHRTdHlsZSddIHx8IG51bGw7XG4gIHRoaXMuc3R5bGVBbGlhc2VzID0gY29tcGlsZVN0eWxlQWxpYXNlcyhvcHRpb25zWydzdHlsZUFsaWFzZXMnXSB8fCBudWxsKTtcblxuICBpZiAoLTEgPT09IFlBTUxfTk9ERV9LSU5EUy5pbmRleE9mKHRoaXMua2luZCkpIHtcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVW5rbm93biBraW5kIFwiJyArIHRoaXMua2luZCArICdcIiBpcyBzcGVjaWZpZWQgZm9yIFwiJyArIHRhZyArICdcIiBZQU1MIHR5cGUuJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIEEgdHJpY2sgZm9yIGJyb3dzZXJpZmllZCB2ZXJzaW9uLlxuLy8gU2luY2Ugd2UgbWFrZSBicm93c2VyaWZpZXIgdG8gaWdub3JlIGBidWZmZXJgIG1vZHVsZSwgTm9kZUJ1ZmZlciB3aWxsIGJlIHVuZGVmaW5lZFxudmFyIE5vZGVCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG52YXIgVHlwZSAgICAgICA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuXG4vLyBbIDY0LCA2NSwgNjYgXSAtPiBbIHBhZGRpbmcsIENSLCBMRiBdXG52YXIgQkFTRTY0X01BUCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVxcblxccic7XG5cblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxCaW5hcnkoZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBjb2RlLCBpZHgsIGJpdGxlbiA9IDAsIGxlbiA9IDAsIG1heCA9IGRhdGEubGVuZ3RoLCBtYXAgPSBCQVNFNjRfTUFQO1xuXG4gIC8vIENvbnZlcnQgb25lIGJ5IG9uZS5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCArKykge1xuICAgIGNvZGUgPSBtYXAuaW5kZXhPZihkYXRhLmNoYXJBdChpZHgpKTtcblxuICAgIC8vIFNraXAgQ1IvTEZcbiAgICBpZiAoY29kZSA+IDY0KSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBGYWlsIG9uIGlsbGVnYWwgY2hhcmFjdGVyc1xuICAgIGlmIChjb2RlIDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGJpdGxlbiArPSA2O1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgYXJlIGFueSBiaXRzIGxlZnQsIHNvdXJjZSB3YXMgY29ycnVwdGVkXG4gIHJldHVybiAoYml0bGVuICUgOCkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxCaW5hcnkoZGF0YSkge1xuICB2YXIgY29kZSwgaWR4LCB0YWlsYml0cyxcbiAgICAgIGlucHV0ID0gZGF0YS5yZXBsYWNlKC9bXFxyXFxuPV0vZywgJycpLCAvLyByZW1vdmUgQ1IvTEYgJiBwYWRkaW5nIHRvIHNpbXBsaWZ5IHNjYW5cbiAgICAgIG1heCA9IGlucHV0Lmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVAsXG4gICAgICBiaXRzID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIC8vIENvbGxlY3QgYnkgNio0IGJpdHMgKDMgYnl0ZXMpXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKChpZHggJSA0ID09PSAwKSAmJiBpZHgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gOCkgJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKGJpdHMgJiAweEZGKTtcbiAgICB9XG5cbiAgICBiaXRzID0gKGJpdHMgPDwgNikgfCBtYXAuaW5kZXhPZihpbnB1dC5jaGFyQXQoaWR4KSk7XG4gIH1cblxuICAvLyBEdW1wIHRhaWxcblxuICB0YWlsYml0cyA9IChtYXggJSA0KSo2O1xuXG4gIGlmICh0YWlsYml0cyA9PT0gMCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goYml0cyAmIDB4RkYpO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxOCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDEwKSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDIpICYgMHhGRik7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDEyKSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gNCkgJiAweEZGKTtcbiAgfVxuXG4gIC8vIFdyYXAgaW50byBCdWZmZXIgZm9yIE5vZGVKUyBhbmQgbGVhdmUgQXJyYXkgZm9yIGJyb3dzZXJcbiAgaWYgKE5vZGVCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IE5vZGVCdWZmZXIocmVzdWx0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxCaW5hcnkob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHZhciByZXN1bHQgPSAnJywgYml0cyA9IDAsIGlkeCwgdGFpbCxcbiAgICAgIG1heCA9IG9iamVjdC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQO1xuXG4gIC8vIENvbnZlcnQgZXZlcnkgdGhyZWUgYnl0ZXMgdG8gNCBBU0NJSSBjaGFyYWN0ZXJzLlxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgMyA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICAgIH1cblxuICAgIGJpdHMgPSAoYml0cyA8PCA4KSArIG9iamVjdFtpZHhdO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbCA9IG1heCAlIDM7XG5cbiAgaWYgKHRhaWwgPT09IDApIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA2KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICB9IGVsc2UgaWYgKHRhaWwgPT09IDIpIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEwKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMSkge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDQpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc0JpbmFyeShvYmplY3QpIHtcbiAgcmV0dXJuIE5vZGVCdWZmZXIgJiYgTm9kZUJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpiaW5hcnknLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEJpbmFyeSxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sQmluYXJ5LFxuICBwcmVkaWNhdGU6IGlzQmluYXJ5LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxCaW5hcnlcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxCb29sZWFuKGRhdGEpIHtcbiAgaWYgKG51bGwgPT09IGRhdGEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGg7XG5cbiAgcmV0dXJuIChtYXggPT09IDQgJiYgKGRhdGEgPT09ICd0cnVlJyB8fCBkYXRhID09PSAnVHJ1ZScgfHwgZGF0YSA9PT0gJ1RSVUUnKSkgfHxcbiAgICAgICAgIChtYXggPT09IDUgJiYgKGRhdGEgPT09ICdmYWxzZScgfHwgZGF0YSA9PT0gJ0ZhbHNlJyB8fCBkYXRhID09PSAnRkFMU0UnKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxCb29sZWFuKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09ICd0cnVlJyB8fFxuICAgICAgICAgZGF0YSA9PT0gJ1RydWUnIHx8XG4gICAgICAgICBkYXRhID09PSAnVFJVRSc7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihvYmplY3QpIHtcbiAgcmV0dXJuICdbb2JqZWN0IEJvb2xlYW5dJyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEJvb2xlYW4sXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEJvb2xlYW4sXG4gIHByZWRpY2F0ZTogaXNCb29sZWFuLFxuICByZXByZXNlbnQ6IHtcbiAgICBsb3dlcmNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICd0cnVlJyA6ICdmYWxzZSc7IH0sXG4gICAgdXBwZXJjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAnVFJVRScgOiAnRkFMU0UnOyB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ1RydWUnIDogJ0ZhbHNlJzsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIFR5cGUgICA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIFlBTUxfRkxPQVRfUEFUVEVSTiA9IG5ldyBSZWdFeHAoXG4gICdeKD86Wy0rXT8oPzpbMC05XVswLTlfXSopXFxcXC5bMC05X10qKD86W2VFXVstK11bMC05XSspPycgK1xuICAnfFxcXFwuWzAtOV9dKyg/OltlRV1bLStdWzAtOV0rKT8nICtcbiAgJ3xbLStdP1swLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrXFxcXC5bMC05X10qJyArXG4gICd8Wy0rXT9cXFxcLig/OmluZnxJbmZ8SU5GKScgK1xuICAnfFxcXFwuKD86bmFufE5hTnxOQU4pKSQnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxGbG9hdChkYXRhKSB7XG4gIGlmIChudWxsID09PSBkYXRhKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHZhbHVlLCBzaWduLCBiYXNlLCBkaWdpdHM7XG5cbiAgaWYgKCFZQU1MX0ZMT0FUX1BBVFRFUk4udGVzdChkYXRhKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEZsb2F0KGRhdGEpIHtcbiAgdmFyIHZhbHVlLCBzaWduLCBiYXNlLCBkaWdpdHM7XG5cbiAgdmFsdWUgID0gZGF0YS5yZXBsYWNlKC9fL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICBzaWduICAgPSAnLScgPT09IHZhbHVlWzBdID8gLTEgOiAxO1xuICBkaWdpdHMgPSBbXTtcblxuICBpZiAoMCA8PSAnKy0nLmluZGV4T2YodmFsdWVbMF0pKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgfVxuXG4gIGlmICgnLmluZicgPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuICgxID09PSBzaWduKSA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICB9IGVsc2UgaWYgKCcubmFuJyA9PT0gdmFsdWUpIHtcbiAgICByZXR1cm4gTmFOO1xuXG4gIH0gZWxzZSBpZiAoMCA8PSB2YWx1ZS5pbmRleE9mKCc6JykpIHtcbiAgICB2YWx1ZS5zcGxpdCgnOicpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIGRpZ2l0cy51bnNoaWZ0KHBhcnNlRmxvYXQodiwgMTApKTtcbiAgICB9KTtcblxuICAgIHZhbHVlID0gMC4wO1xuICAgIGJhc2UgPSAxO1xuXG4gICAgZGlnaXRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhbHVlICs9IGQgKiBiYXNlO1xuICAgICAgYmFzZSAqPSA2MDtcbiAgICB9KTtcblxuICAgIHJldHVybiBzaWduICogdmFsdWU7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2lnbiAqIHBhcnNlRmxvYXQodmFsdWUsIDEwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sRmxvYXQob2JqZWN0LCBzdHlsZSkge1xuICBpZiAoaXNOYU4ob2JqZWN0KSkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICBjYXNlICdsb3dlcmNhc2UnOlxuICAgICAgcmV0dXJuICcubmFuJztcbiAgICBjYXNlICd1cHBlcmNhc2UnOlxuICAgICAgcmV0dXJuICcuTkFOJztcbiAgICBjYXNlICdjYW1lbGNhc2UnOlxuICAgICAgcmV0dXJuICcuTmFOJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZID09PSBvYmplY3QpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgY2FzZSAnbG93ZXJjYXNlJzpcbiAgICAgIHJldHVybiAnLmluZic7XG4gICAgY2FzZSAndXBwZXJjYXNlJzpcbiAgICAgIHJldHVybiAnLklORic7XG4gICAgY2FzZSAnY2FtZWxjYXNlJzpcbiAgICAgIHJldHVybiAnLkluZic7XG4gICAgfVxuICB9IGVsc2UgaWYgKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA9PT0gb2JqZWN0KSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgIGNhc2UgJ2xvd2VyY2FzZSc6XG4gICAgICByZXR1cm4gJy0uaW5mJztcbiAgICBjYXNlICd1cHBlcmNhc2UnOlxuICAgICAgcmV0dXJuICctLklORic7XG4gICAgY2FzZSAnY2FtZWxjYXNlJzpcbiAgICAgIHJldHVybiAnLS5JbmYnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSkge1xuICAgIHJldHVybiAnLTAuMCc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iamVjdC50b1N0cmluZygxMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNGbG9hdChvYmplY3QpIHtcbiAgcmV0dXJuICgnW29iamVjdCBOdW1iZXJdJyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkpICYmXG4gICAgICAgICAoMCAhPT0gb2JqZWN0ICUgMSB8fCBjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxGbG9hdCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sRmxvYXQsXG4gIHByZWRpY2F0ZTogaXNGbG9hdCxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sRmxvYXQsXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG52YXIgVHlwZSAgID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5mdW5jdGlvbiBpc0hleENvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpIHx8XG4gICAgICAgICAoKDB4NDEvKiBBICovIDw9IGMpICYmIChjIDw9IDB4NDYvKiBGICovKSkgfHxcbiAgICAgICAgICgoMHg2MS8qIGEgKi8gPD0gYykgJiYgKGMgPD0gMHg2Ni8qIGYgKi8pKTtcbn1cblxuZnVuY3Rpb24gaXNPY3RDb2RlKGMpIHtcbiAgcmV0dXJuICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzNy8qIDcgKi8pKTtcbn1cblxuZnVuY3Rpb24gaXNEZWNDb2RlKGMpIHtcbiAgcmV0dXJuICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxJbnRlZ2VyKGRhdGEpIHtcbiAgaWYgKG51bGwgPT09IGRhdGEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGgsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBoYXNEaWdpdHMgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmICghbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGNoID0gZGF0YVtpbmRleF07XG5cbiAgLy8gc2lnblxuICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgY2ggPSBkYXRhWysraW5kZXhdO1xuICB9XG5cbiAgaWYgKGNoID09PSAnMCcpIHtcbiAgICAvLyAwXG4gICAgaWYgKGluZGV4KzEgPT09IG1heCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGNoID0gZGF0YVsrK2luZGV4XTtcblxuICAgIC8vIGJhc2UgMiwgYmFzZSA4LCBiYXNlIDE2XG5cbiAgICBpZiAoY2ggPT09ICdiJykge1xuICAgICAgLy8gYmFzZSAyXG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIHsgY29udGludWU7IH1cbiAgICAgICAgaWYgKGNoICE9PSAnMCcgJiYgY2ggIT09ICcxJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0RpZ2l0cztcbiAgICB9XG5cblxuICAgIGlmIChjaCA9PT0gJ3gnKSB7XG4gICAgICAvLyBiYXNlIDE2XG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIHsgY29udGludWU7IH1cbiAgICAgICAgaWYgKCFpc0hleENvZGUoZGF0YS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHM7XG4gICAgfVxuXG4gICAgLy8gYmFzZSA4XG4gICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgICAgaWYgKGNoID09PSAnXycpIHsgY29udGludWU7IH1cbiAgICAgIGlmICghaXNPY3RDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBoYXNEaWdpdHM7XG4gIH1cblxuICAvLyBiYXNlIDEwIChleGNlcHQgMCkgb3IgYmFzZSA2MFxuXG4gIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgaWYgKGNoID09PSAnXycpIHsgY29udGludWU7IH1cbiAgICBpZiAoY2ggPT09ICc6JykgeyBicmVhazsgfVxuICAgIGlmICghaXNEZWNDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gIH1cblxuICBpZiAoIWhhc0RpZ2l0cykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBpZiAhYmFzZTYwIC0gZG9uZTtcbiAgaWYgKGNoICE9PSAnOicpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBiYXNlNjAgYWxtb3N0IG5vdCB1c2VkLCBubyBuZWVkcyB0byBvcHRpbWl6ZVxuICByZXR1cm4gL14oOlswLTVdP1swLTldKSskLy50ZXN0KGRhdGEuc2xpY2UoaW5kZXgpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEludGVnZXIoZGF0YSkge1xuICB2YXIgdmFsdWUgPSBkYXRhLCBzaWduID0gMSwgY2gsIGJhc2UsIGRpZ2l0cyA9IFtdO1xuXG4gIGlmICh2YWx1ZS5pbmRleE9mKCdfJykgIT09IC0xKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9fL2csICcnKTtcbiAgfVxuXG4gIGNoID0gdmFsdWVbMF07XG5cbiAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgIGlmIChjaCA9PT0gJy0nKSB7IHNpZ24gPSAtMTsgfVxuICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gICAgY2ggPSB2YWx1ZVswXTtcbiAgfVxuXG4gIGlmICgnMCcgPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ2InKSB7XG4gICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAyKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlWzFdID09PSAneCcpIHtcbiAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZSwgOCk7XG5cbiAgfVxuXG4gIGlmICh2YWx1ZS5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgdmFsdWUuc3BsaXQoJzonKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICBkaWdpdHMudW5zaGlmdChwYXJzZUludCh2LCAxMCkpO1xuICAgIH0pO1xuXG4gICAgdmFsdWUgPSAwO1xuICAgIGJhc2UgPSAxO1xuXG4gICAgZGlnaXRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhbHVlICs9IChkICogYmFzZSk7XG4gICAgICBiYXNlICo9IDYwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNpZ24gKiB2YWx1ZTtcblxuICB9XG5cbiAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZSwgMTApO1xufVxuXG5mdW5jdGlvbiBpc0ludGVnZXIob2JqZWN0KSB7XG4gIHJldHVybiAoJ1tvYmplY3QgTnVtYmVyXScgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpKSAmJlxuICAgICAgICAgKDAgPT09IG9iamVjdCAlIDEgJiYgIWNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6aW50Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxJbnRlZ2VyLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxJbnRlZ2VyLFxuICBwcmVkaWNhdGU6IGlzSW50ZWdlcixcbiAgcmVwcmVzZW50OiB7XG4gICAgYmluYXJ5OiAgICAgIGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuICcwYicgKyBvYmplY3QudG9TdHJpbmcoMik7IH0sXG4gICAgb2N0YWw6ICAgICAgIGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuICcwJyAgKyBvYmplY3QudG9TdHJpbmcoOCk7IH0sXG4gICAgZGVjaW1hbDogICAgIGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuICAgICAgICBvYmplY3QudG9TdHJpbmcoMTApOyB9LFxuICAgIGhleGFkZWNpbWFsOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAnMHgnICsgb2JqZWN0LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2RlY2ltYWwnLFxuICBzdHlsZUFsaWFzZXM6IHtcbiAgICBiaW5hcnk6ICAgICAgWyAyLCAgJ2JpbicgXSxcbiAgICBvY3RhbDogICAgICAgWyA4LCAgJ29jdCcgXSxcbiAgICBkZWNpbWFsOiAgICAgWyAxMCwgJ2RlYycgXSxcbiAgICBoZXhhZGVjaW1hbDogWyAxNiwgJ2hleCcgXVxuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVzcHJpbWE7XG5cbi8vIEJyb3dzZXJpZmllZCB2ZXJzaW9uIGRvZXMgbm90IGhhdmUgZXNwcmltYVxuLy9cbi8vIDEuIEZvciBub2RlLmpzIGp1c3QgcmVxdWlyZSBtb2R1bGUgYXMgZGVwc1xuLy8gMi4gRm9yIGJyb3dzZXIgdHJ5IHRvIHJlcXVpcmUgbXVkdWxlIHZpYSBleHRlcm5hbCBBTUQgc3lzdGVtLlxuLy8gICAgSWYgbm90IGZvdW5kIC0gdHJ5IHRvIGZhbGxiYWNrIHRvIHdpbmRvdy5lc3ByaW1hLiBJZiBub3Rcbi8vICAgIGZvdW5kIHRvbyAtIHRoZW4gZmFpbCB0byBwYXJzZS5cbi8vXG50cnkge1xuICBlc3ByaW1hID0gcmVxdWlyZSgnZXNwcmltYScpO1xufSBjYXRjaCAoXykge1xuICAvKmdsb2JhbCB3aW5kb3cgKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IGVzcHJpbWEgPSB3aW5kb3cuZXNwcmltYTsgfVxufVxuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uLy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZUphdmFzY3JpcHRGdW5jdGlvbihkYXRhKSB7XG4gIGlmIChudWxsID09PSBkYXRhKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgc291cmNlID0gJygnICsgZGF0YSArICcpJyxcbiAgICAgICAgYXN0ICAgID0gZXNwcmltYS5wYXJzZShzb3VyY2UsIHsgcmFuZ2U6IHRydWUgfSksXG4gICAgICAgIHBhcmFtcyA9IFtdLFxuICAgICAgICBib2R5O1xuXG4gICAgaWYgKCdQcm9ncmFtJyAgICAgICAgICAgICAhPT0gYXN0LnR5cGUgICAgICAgICB8fFxuICAgICAgICAxICAgICAgICAgICAgICAgICAgICAgIT09IGFzdC5ib2R5Lmxlbmd0aCAgfHxcbiAgICAgICAgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnICE9PSBhc3QuYm9keVswXS50eXBlIHx8XG4gICAgICAgICdGdW5jdGlvbkV4cHJlc3Npb24nICAhPT0gYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RKYXZhc2NyaXB0RnVuY3Rpb24oZGF0YSkge1xuICAvKmpzbGludCBldmlsOnRydWUqL1xuXG4gIHZhciBzb3VyY2UgPSAnKCcgKyBkYXRhICsgJyknLFxuICAgICAgYXN0ICAgID0gZXNwcmltYS5wYXJzZShzb3VyY2UsIHsgcmFuZ2U6IHRydWUgfSksXG4gICAgICBwYXJhbXMgPSBbXSxcbiAgICAgIGJvZHk7XG5cbiAgaWYgKCdQcm9ncmFtJyAgICAgICAgICAgICAhPT0gYXN0LnR5cGUgICAgICAgICB8fFxuICAgICAgMSAgICAgICAgICAgICAgICAgICAgICE9PSBhc3QuYm9keS5sZW5ndGggIHx8XG4gICAgICAnRXhwcmVzc2lvblN0YXRlbWVudCcgIT09IGFzdC5ib2R5WzBdLnR5cGUgfHxcbiAgICAgICdGdW5jdGlvbkV4cHJlc3Npb24nICAhPT0gYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcmVzb2x2ZSBmdW5jdGlvbicpO1xuICB9XG5cbiAgYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi5wYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICBwYXJhbXMucHVzaChwYXJhbS5uYW1lKTtcbiAgfSk7XG5cbiAgYm9keSA9IGFzdC5ib2R5WzBdLmV4cHJlc3Npb24uYm9keS5yYW5nZTtcblxuICAvLyBFc3ByaW1hJ3MgcmFuZ2VzIGluY2x1ZGUgdGhlIGZpcnN0ICd7JyBhbmQgdGhlIGxhc3QgJ30nIGNoYXJhY3RlcnMgb25cbiAgLy8gZnVuY3Rpb24gZXhwcmVzc2lvbnMuIFNvIGN1dCB0aGVtIG91dC5cbiAgcmV0dXJuIG5ldyBGdW5jdGlvbihwYXJhbXMsIHNvdXJjZS5zbGljZShib2R5WzBdKzEsIGJvZHlbMV0tMSkpO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRKYXZhc2NyaXB0RnVuY3Rpb24ob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHJldHVybiBvYmplY3QudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmplY3QpIHtcbiAgcmV0dXJuICdbb2JqZWN0IEZ1bmN0aW9uXScgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy9mdW5jdGlvbicsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0RnVuY3Rpb24sXG4gIGNvbnN0cnVjdDogY29uc3RydWN0SmF2YXNjcmlwdEZ1bmN0aW9uLFxuICBwcmVkaWNhdGU6IGlzRnVuY3Rpb24sXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdEZ1bmN0aW9uXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi8uLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVKYXZhc2NyaXB0UmVnRXhwKGRhdGEpIHtcbiAgaWYgKG51bGwgPT09IGRhdGEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoMCA9PT0gZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gZGF0YSxcbiAgICAgIHRhaWwgICA9IC9cXC8oW2dpbV0qKSQvLmV4ZWMoZGF0YSksXG4gICAgICBtb2RpZmllcnMgPSAnJztcblxuICAvLyBpZiByZWdleHAgc3RhcnRzIHdpdGggJy8nIGl0IGNhbiBoYXZlIG1vZGlmaWVycyBhbmQgbXVzdCBiZSBwcm9wZXJseSBjbG9zZWRcbiAgLy8gYC9mb28vZ2ltYCAtIG1vZGlmaWVycyB0YWlsIGNhbiBiZSBtYXhpbXVtIDMgY2hhcnNcbiAgaWYgKCcvJyA9PT0gcmVnZXhwWzBdKSB7XG4gICAgaWYgKHRhaWwpIHtcbiAgICAgIG1vZGlmaWVycyA9IHRhaWxbMV07XG4gICAgfVxuXG4gICAgaWYgKG1vZGlmaWVycy5sZW5ndGggPiAzKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8vIGlmIGV4cHJlc3Npb24gc3RhcnRzIHdpdGggLywgaXMgc2hvdWxkIGJlIHByb3Blcmx5IHRlcm1pbmF0ZWRcbiAgICBpZiAocmVnZXhwW3JlZ2V4cC5sZW5ndGggLSBtb2RpZmllcnMubGVuZ3RoIC0gMV0gIT09ICcvJykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIHJlZ2V4cCA9IHJlZ2V4cC5zbGljZSgxLCByZWdleHAubGVuZ3RoIC0gbW9kaWZpZXJzLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgZHVtbXkgPSBuZXcgUmVnRXhwKHJlZ2V4cCwgbW9kaWZpZXJzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdFJlZ0V4cChkYXRhKSB7XG4gIHZhciByZWdleHAgPSBkYXRhLFxuICAgICAgdGFpbCAgID0gL1xcLyhbZ2ltXSopJC8uZXhlYyhkYXRhKSxcbiAgICAgIG1vZGlmaWVycyA9ICcnO1xuXG4gIC8vIGAvZm9vL2dpbWAgLSB0YWlsIGNhbiBiZSBtYXhpbXVtIDQgY2hhcnNcbiAgaWYgKCcvJyA9PT0gcmVnZXhwWzBdKSB7XG4gICAgaWYgKHRhaWwpIHtcbiAgICAgIG1vZGlmaWVycyA9IHRhaWxbMV07XG4gICAgfVxuICAgIHJlZ2V4cCA9IHJlZ2V4cC5zbGljZSgxLCByZWdleHAubGVuZ3RoIC0gbW9kaWZpZXJzLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwLCBtb2RpZmllcnMpO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRKYXZhc2NyaXB0UmVnRXhwKG9iamVjdCAvKiwgc3R5bGUqLykge1xuICB2YXIgcmVzdWx0ID0gJy8nICsgb2JqZWN0LnNvdXJjZSArICcvJztcblxuICBpZiAob2JqZWN0Lmdsb2JhbCkge1xuICAgIHJlc3VsdCArPSAnZyc7XG4gIH1cblxuICBpZiAob2JqZWN0Lm11bHRpbGluZSkge1xuICAgIHJlc3VsdCArPSAnbSc7XG4gIH1cblxuICBpZiAob2JqZWN0Lmlnbm9yZUNhc2UpIHtcbiAgICByZXN1bHQgKz0gJ2knO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAob2JqZWN0KSB7XG4gIHJldHVybiAnW29iamVjdCBSZWdFeHBdJyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL3JlZ2V4cCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0UmVnRXhwLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdEphdmFzY3JpcHRSZWdFeHAsXG4gIHByZWRpY2F0ZTogaXNSZWdFeHAsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdFJlZ0V4cFxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlSmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdEphdmFzY3JpcHRVbmRlZmluZWQoKSB7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudEphdmFzY3JpcHRVbmRlZmluZWQoKSB7XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqZWN0KSB7XG4gIHJldHVybiAndW5kZWZpbmVkJyA9PT0gdHlwZW9mIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6anMvdW5kZWZpbmVkJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZUphdmFzY3JpcHRVbmRlZmluZWQsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0SmF2YXNjcmlwdFVuZGVmaW5lZCxcbiAgcHJlZGljYXRlOiBpc1VuZGVmaW5lZCxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRKYXZhc2NyaXB0VW5kZWZpbmVkXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsIHtcbiAga2luZDogJ21hcHBpbmcnLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBudWxsICE9PSBkYXRhID8gZGF0YSA6IHt9OyB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sTWVyZ2UoZGF0YSkge1xuICByZXR1cm4gJzw8JyA9PT0gZGF0YSB8fCBudWxsID09PSBkYXRhO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sTWVyZ2Vcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxOdWxsKGRhdGEpIHtcbiAgaWYgKG51bGwgPT09IGRhdGEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aDtcblxuICByZXR1cm4gKG1heCA9PT0gMSAmJiBkYXRhID09PSAnficpIHx8XG4gICAgICAgICAobWF4ID09PSA0ICYmIChkYXRhID09PSAnbnVsbCcgfHwgZGF0YSA9PT0gJ051bGwnIHx8IGRhdGEgPT09ICdOVUxMJykpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbChvYmplY3QpIHtcbiAgcmV0dXJuIG51bGwgPT09IG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sTnVsbCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sTnVsbCxcbiAgcHJlZGljYXRlOiBpc051bGwsXG4gIHJlcHJlc2VudDoge1xuICAgIGNhbm9uaWNhbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ34nOyAgICB9LFxuICAgIGxvd2VyY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ251bGwnOyB9LFxuICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ05VTEwnOyB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ051bGwnOyB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX3RvU3RyaW5nICAgICAgID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxPbWFwKGRhdGEpIHtcbiAgaWYgKG51bGwgPT09IGRhdGEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBvYmplY3RLZXlzID0gW10sIGluZGV4LCBsZW5ndGgsIHBhaXIsIHBhaXJLZXksIHBhaXJIYXNLZXksXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuICAgIHBhaXJIYXNLZXkgPSBmYWxzZTtcblxuICAgIGlmICgnW29iamVjdCBPYmplY3RdJyAhPT0gX3RvU3RyaW5nLmNhbGwocGFpcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKHBhaXJLZXkgaW4gcGFpcikge1xuICAgICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhaXIsIHBhaXJLZXkpKSB7XG4gICAgICAgIGlmICghcGFpckhhc0tleSkge1xuICAgICAgICAgIHBhaXJIYXNLZXkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFpckhhc0tleSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICgtMSA9PT0gb2JqZWN0S2V5cy5pbmRleE9mKHBhaXJLZXkpKSB7XG4gICAgICBvYmplY3RLZXlzLnB1c2gocGFpcktleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbE9tYXAoZGF0YSkge1xuICByZXR1cm4gbnVsbCAhPT0gZGF0YSA/IGRhdGEgOiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6b21hcCcsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxPbWFwLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxPbWFwXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFBhaXJzKGRhdGEpIHtcbiAgaWYgKG51bGwgPT09IGRhdGEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBpbmRleCwgbGVuZ3RoLCBwYWlyLCBrZXlzLCByZXN1bHQsXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIHJlc3VsdCA9IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGlmICgnW29iamVjdCBPYmplY3RdJyAhPT0gX3RvU3RyaW5nLmNhbGwocGFpcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMocGFpcik7XG5cbiAgICBpZiAoMSAhPT0ga2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXN1bHRbaW5kZXhdID0gWyBrZXlzWzBdLCBwYWlyW2tleXNbMF1dIF07XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFBhaXJzKGRhdGEpIHtcbiAgaWYgKG51bGwgPT09IGRhdGEpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgaW5kZXgsIGxlbmd0aCwgcGFpciwga2V5cywgcmVzdWx0LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICByZXN1bHQgPSBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMocGFpcik7XG5cbiAgICByZXN1bHRbaW5kZXhdID0gWyBrZXlzWzBdLCBwYWlyW2tleXNbMF1dIF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycycsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxQYWlycyxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sUGFpcnNcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c2VxJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBudWxsICE9PSBkYXRhID8gZGF0YSA6IFtdOyB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFNldChkYXRhKSB7XG4gIGlmIChudWxsID09PSBkYXRhKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIga2V5LCBvYmplY3QgPSBkYXRhO1xuXG4gIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgIGlmIChudWxsICE9PSBvYmplY3Rba2V5XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxTZXQoZGF0YSkge1xuICByZXR1cm4gbnVsbCAhPT0gZGF0YSA/IGRhdGEgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c2V0Jywge1xuICBraW5kOiAnbWFwcGluZycsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sU2V0LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxTZXRcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gbnVsbCAhPT0gZGF0YSA/IGRhdGEgOiAnJzsgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgWUFNTF9USU1FU1RBTVBfUkVHRVhQID0gbmV3IFJlZ0V4cChcbiAgJ14oWzAtOV1bMC05XVswLTldWzAtOV0pJyAgICAgICAgICArIC8vIFsxXSB5ZWFyXG4gICctKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgKyAvLyBbMl0gbW9udGhcbiAgJy0oWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICArIC8vIFszXSBkYXlcbiAgJyg/Oig/OltUdF18WyBcXFxcdF0rKScgICAgICAgICAgICAgICsgLy8gLi4uXG4gICcoWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNF0gaG91clxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzVdIG1pbnV0ZVxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzZdIHNlY29uZFxuICAnKD86XFxcXC4oWzAtOV0qKSk/JyAgICAgICAgICAgICAgICAgKyAvLyBbN10gZnJhY3Rpb25cbiAgJyg/OlsgXFxcXHRdKihafChbLStdKShbMC05XVswLTldPyknICsgLy8gWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91clxuICAnKD86OihbMC05XVswLTldKSk/KSk/KT8kJyk7ICAgICAgICAgLy8gWzExXSB0el9taW51dGVcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxUaW1lc3RhbXAoZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBtYXRjaCwgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWN0aW9uID0gMCxcbiAgICAgIGRlbHRhID0gbnVsbCwgdHpfaG91ciwgdHpfbWludXRlLCBkYXRlO1xuXG4gIG1hdGNoID0gWUFNTF9USU1FU1RBTVBfUkVHRVhQLmV4ZWMoZGF0YSk7XG5cbiAgaWYgKG51bGwgPT09IG1hdGNoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxUaW1lc3RhbXAoZGF0YSkge1xuICB2YXIgbWF0Y2gsIHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmcmFjdGlvbiA9IDAsXG4gICAgICBkZWx0YSA9IG51bGwsIHR6X2hvdXIsIHR6X21pbnV0ZSwgZGF0ZTtcblxuICBtYXRjaCA9IFlBTUxfVElNRVNUQU1QX1JFR0VYUC5leGVjKGRhdGEpO1xuXG4gIGlmIChudWxsID09PSBtYXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGF0ZSByZXNvbHZlIGVycm9yJyk7XG4gIH1cblxuICAvLyBtYXRjaDogWzFdIHllYXIgWzJdIG1vbnRoIFszXSBkYXlcblxuICB5ZWFyID0gKyhtYXRjaFsxXSk7XG4gIG1vbnRoID0gKyhtYXRjaFsyXSkgLSAxOyAvLyBKUyBtb250aCBzdGFydHMgd2l0aCAwXG4gIGRheSA9ICsobWF0Y2hbM10pO1xuXG4gIGlmICghbWF0Y2hbNF0pIHsgLy8gbm8gaG91clxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5KSk7XG4gIH1cblxuICAvLyBtYXRjaDogWzRdIGhvdXIgWzVdIG1pbnV0ZSBbNl0gc2Vjb25kIFs3XSBmcmFjdGlvblxuXG4gIGhvdXIgPSArKG1hdGNoWzRdKTtcbiAgbWludXRlID0gKyhtYXRjaFs1XSk7XG4gIHNlY29uZCA9ICsobWF0Y2hbNl0pO1xuXG4gIGlmIChtYXRjaFs3XSkge1xuICAgIGZyYWN0aW9uID0gbWF0Y2hbN10uc2xpY2UoMCwgMyk7XG4gICAgd2hpbGUgKGZyYWN0aW9uLmxlbmd0aCA8IDMpIHsgLy8gbWlsbGktc2Vjb25kc1xuICAgICAgZnJhY3Rpb24gKz0gJzAnO1xuICAgIH1cbiAgICBmcmFjdGlvbiA9ICtmcmFjdGlvbjtcbiAgfVxuXG4gIC8vIG1hdGNoOiBbOF0gdHogWzldIHR6X3NpZ24gWzEwXSB0el9ob3VyIFsxMV0gdHpfbWludXRlXG5cbiAgaWYgKG1hdGNoWzldKSB7XG4gICAgdHpfaG91ciA9ICsobWF0Y2hbMTBdKTtcbiAgICB0el9taW51dGUgPSArKG1hdGNoWzExXSB8fCAwKTtcbiAgICBkZWx0YSA9ICh0el9ob3VyICogNjAgKyB0el9taW51dGUpICogNjAwMDA7IC8vIGRlbHRhIGluIG1pbGktc2Vjb25kc1xuICAgIGlmICgnLScgPT09IG1hdGNoWzldKSB7XG4gICAgICBkZWx0YSA9IC1kZWx0YTtcbiAgICB9XG4gIH1cblxuICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWN0aW9uKSk7XG5cbiAgaWYgKGRlbHRhKSB7XG4gICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpIC0gZGVsdGEpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGU7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxUaW1lc3RhbXAob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHJldHVybiBvYmplY3QudG9JU09TdHJpbmcoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6dGltZXN0YW1wJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxUaW1lc3RhbXAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFRpbWVzdGFtcCxcbiAgaW5zdGFuY2VPZjogRGF0ZSxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sVGltZXN0YW1wXG59KTtcbiIsIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMyBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEzIFRoYWRkZWUgVHlsIDx0aGFkZGVlLnR5bEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMyBNYXRoaWFzIEJ5bmVucyA8bWF0aGlhc0BxaXdpLmJlPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBNYXRoaWFzIEJ5bmVucyA8bWF0aGlhc0BxaXdpLmJlPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgSm9vc3QtV2ltIEJvZWtlc3RlaWpuIDxqb29zdC13aW1AYm9la2VzdGVpam4ubmw+XG4gIENvcHlyaWdodCAoQykgMjAxMiBLcmlzIEtvd2FsIDxrcmlzLmtvd2FsQGNpeGFyLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFycGFkIEJvcnNvcyA8YXJwYWQuYm9yc29zQGdvb2dsZW1haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTEgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLFxuICAgIC8vIFJoaW5vLCBhbmQgcGxhaW4gYnJvd3NlciBsb2FkaW5nLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZmFjdG9yeShleHBvcnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5KChyb290LmVzcHJpbWEgPSB7fSkpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgVG9rZW4sXG4gICAgICAgIFRva2VuTmFtZSxcbiAgICAgICAgRm5FeHByVG9rZW5zLFxuICAgICAgICBTeW50YXgsXG4gICAgICAgIFBsYWNlSG9sZGVycyxcbiAgICAgICAgUHJvcGVydHlLaW5kLFxuICAgICAgICBNZXNzYWdlcyxcbiAgICAgICAgUmVnZXgsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgc3RyaWN0LFxuICAgICAgICBpbmRleCxcbiAgICAgICAgbGluZU51bWJlcixcbiAgICAgICAgbGluZVN0YXJ0LFxuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGxvb2thaGVhZCxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGV4dHJhO1xuXG4gICAgVG9rZW4gPSB7XG4gICAgICAgIEJvb2xlYW5MaXRlcmFsOiAxLFxuICAgICAgICBFT0Y6IDIsXG4gICAgICAgIElkZW50aWZpZXI6IDMsXG4gICAgICAgIEtleXdvcmQ6IDQsXG4gICAgICAgIE51bGxMaXRlcmFsOiA1LFxuICAgICAgICBOdW1lcmljTGl0ZXJhbDogNixcbiAgICAgICAgUHVuY3R1YXRvcjogNyxcbiAgICAgICAgU3RyaW5nTGl0ZXJhbDogOCxcbiAgICAgICAgUmVndWxhckV4cHJlc3Npb246IDlcbiAgICB9O1xuXG4gICAgVG9rZW5OYW1lID0ge307XG4gICAgVG9rZW5OYW1lW1Rva2VuLkJvb2xlYW5MaXRlcmFsXSA9ICdCb29sZWFuJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uRU9GXSA9ICc8ZW5kPic7XG4gICAgVG9rZW5OYW1lW1Rva2VuLklkZW50aWZpZXJdID0gJ0lkZW50aWZpZXInO1xuICAgIFRva2VuTmFtZVtUb2tlbi5LZXl3b3JkXSA9ICdLZXl3b3JkJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uTnVsbExpdGVyYWxdID0gJ051bGwnO1xuICAgIFRva2VuTmFtZVtUb2tlbi5OdW1lcmljTGl0ZXJhbF0gPSAnTnVtZXJpYyc7XG4gICAgVG9rZW5OYW1lW1Rva2VuLlB1bmN0dWF0b3JdID0gJ1B1bmN0dWF0b3InO1xuICAgIFRva2VuTmFtZVtUb2tlbi5TdHJpbmdMaXRlcmFsXSA9ICdTdHJpbmcnO1xuICAgIFRva2VuTmFtZVtUb2tlbi5SZWd1bGFyRXhwcmVzc2lvbl0gPSAnUmVndWxhckV4cHJlc3Npb24nO1xuXG4gICAgLy8gQSBmdW5jdGlvbiBmb2xsb3dpbmcgb25lIG9mIHRob3NlIHRva2VucyBpcyBhbiBleHByZXNzaW9uLlxuICAgIEZuRXhwclRva2VucyA9IFsnKCcsICd7JywgJ1snLCAnaW4nLCAndHlwZW9mJywgJ2luc3RhbmNlb2YnLCAnbmV3JyxcbiAgICAgICAgICAgICAgICAgICAgJ3JldHVybicsICdjYXNlJywgJ2RlbGV0ZScsICd0aHJvdycsICd2b2lkJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gYXNzaWdubWVudCBvcGVyYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgJz0nLCAnKz0nLCAnLT0nLCAnKj0nLCAnLz0nLCAnJT0nLCAnPDw9JywgJz4+PScsICc+Pj49JyxcbiAgICAgICAgICAgICAgICAgICAgJyY9JywgJ3w9JywgJ149JywgJywnLFxuICAgICAgICAgICAgICAgICAgICAvLyBiaW5hcnkvdW5hcnkgb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgICcrJywgJy0nLCAnKicsICcvJywgJyUnLCAnKysnLCAnLS0nLCAnPDwnLCAnPj4nLCAnPj4+JywgJyYnLFxuICAgICAgICAgICAgICAgICAgICAnfCcsICdeJywgJyEnLCAnficsICcmJicsICd8fCcsICc/JywgJzonLCAnPT09JywgJz09JywgJz49JyxcbiAgICAgICAgICAgICAgICAgICAgJzw9JywgJzwnLCAnPicsICchPScsICchPT0nXTtcblxuICAgIFN5bnRheCA9IHtcbiAgICAgICAgQXNzaWdubWVudEV4cHJlc3Npb246ICdBc3NpZ25tZW50RXhwcmVzc2lvbicsXG4gICAgICAgIEFycmF5RXhwcmVzc2lvbjogJ0FycmF5RXhwcmVzc2lvbicsXG4gICAgICAgIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiAnQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nLFxuICAgICAgICBCbG9ja1N0YXRlbWVudDogJ0Jsb2NrU3RhdGVtZW50JyxcbiAgICAgICAgQmluYXJ5RXhwcmVzc2lvbjogJ0JpbmFyeUV4cHJlc3Npb24nLFxuICAgICAgICBCcmVha1N0YXRlbWVudDogJ0JyZWFrU3RhdGVtZW50JyxcbiAgICAgICAgQ2FsbEV4cHJlc3Npb246ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICAgIENhdGNoQ2xhdXNlOiAnQ2F0Y2hDbGF1c2UnLFxuICAgICAgICBDb25kaXRpb25hbEV4cHJlc3Npb246ICdDb25kaXRpb25hbEV4cHJlc3Npb24nLFxuICAgICAgICBDb250aW51ZVN0YXRlbWVudDogJ0NvbnRpbnVlU3RhdGVtZW50JyxcbiAgICAgICAgRG9XaGlsZVN0YXRlbWVudDogJ0RvV2hpbGVTdGF0ZW1lbnQnLFxuICAgICAgICBEZWJ1Z2dlclN0YXRlbWVudDogJ0RlYnVnZ2VyU3RhdGVtZW50JyxcbiAgICAgICAgRW1wdHlTdGF0ZW1lbnQ6ICdFbXB0eVN0YXRlbWVudCcsXG4gICAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcbiAgICAgICAgRm9yU3RhdGVtZW50OiAnRm9yU3RhdGVtZW50JyxcbiAgICAgICAgRm9ySW5TdGF0ZW1lbnQ6ICdGb3JJblN0YXRlbWVudCcsXG4gICAgICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246ICdGdW5jdGlvbkRlY2xhcmF0aW9uJyxcbiAgICAgICAgRnVuY3Rpb25FeHByZXNzaW9uOiAnRnVuY3Rpb25FeHByZXNzaW9uJyxcbiAgICAgICAgSWRlbnRpZmllcjogJ0lkZW50aWZpZXInLFxuICAgICAgICBJZlN0YXRlbWVudDogJ0lmU3RhdGVtZW50JyxcbiAgICAgICAgTGl0ZXJhbDogJ0xpdGVyYWwnLFxuICAgICAgICBMYWJlbGVkU3RhdGVtZW50OiAnTGFiZWxlZFN0YXRlbWVudCcsXG4gICAgICAgIExvZ2ljYWxFeHByZXNzaW9uOiAnTG9naWNhbEV4cHJlc3Npb24nLFxuICAgICAgICBNZW1iZXJFeHByZXNzaW9uOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgIE5ld0V4cHJlc3Npb246ICdOZXdFeHByZXNzaW9uJyxcbiAgICAgICAgT2JqZWN0RXhwcmVzc2lvbjogJ09iamVjdEV4cHJlc3Npb24nLFxuICAgICAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXG4gICAgICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxuICAgICAgICBSZXR1cm5TdGF0ZW1lbnQ6ICdSZXR1cm5TdGF0ZW1lbnQnLFxuICAgICAgICBTZXF1ZW5jZUV4cHJlc3Npb246ICdTZXF1ZW5jZUV4cHJlc3Npb24nLFxuICAgICAgICBTd2l0Y2hTdGF0ZW1lbnQ6ICdTd2l0Y2hTdGF0ZW1lbnQnLFxuICAgICAgICBTd2l0Y2hDYXNlOiAnU3dpdGNoQ2FzZScsXG4gICAgICAgIFRoaXNFeHByZXNzaW9uOiAnVGhpc0V4cHJlc3Npb24nLFxuICAgICAgICBUaHJvd1N0YXRlbWVudDogJ1Rocm93U3RhdGVtZW50JyxcbiAgICAgICAgVHJ5U3RhdGVtZW50OiAnVHJ5U3RhdGVtZW50JyxcbiAgICAgICAgVW5hcnlFeHByZXNzaW9uOiAnVW5hcnlFeHByZXNzaW9uJyxcbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogJ1VwZGF0ZUV4cHJlc3Npb24nLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiAnVmFyaWFibGVEZWNsYXJhdGlvbicsXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogJ1ZhcmlhYmxlRGVjbGFyYXRvcicsXG4gICAgICAgIFdoaWxlU3RhdGVtZW50OiAnV2hpbGVTdGF0ZW1lbnQnLFxuICAgICAgICBXaXRoU3RhdGVtZW50OiAnV2l0aFN0YXRlbWVudCdcbiAgICB9O1xuXG4gICAgUGxhY2VIb2xkZXJzID0ge1xuICAgICAgICBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyOiB7XG4gICAgICAgICAgICB0eXBlOiAnQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcidcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBQcm9wZXJ0eUtpbmQgPSB7XG4gICAgICAgIERhdGE6IDEsXG4gICAgICAgIEdldDogMixcbiAgICAgICAgU2V0OiA0XG4gICAgfTtcblxuICAgIC8vIEVycm9yIG1lc3NhZ2VzIHNob3VsZCBiZSBpZGVudGljYWwgdG8gVjguXG4gICAgTWVzc2FnZXMgPSB7XG4gICAgICAgIFVuZXhwZWN0ZWRUb2tlbjogJ1VuZXhwZWN0ZWQgdG9rZW4gJTAnLFxuICAgICAgICBVbmV4cGVjdGVkTnVtYmVyOiAnVW5leHBlY3RlZCBudW1iZXInLFxuICAgICAgICBVbmV4cGVjdGVkU3RyaW5nOiAnVW5leHBlY3RlZCBzdHJpbmcnLFxuICAgICAgICBVbmV4cGVjdGVkSWRlbnRpZmllcjogJ1VuZXhwZWN0ZWQgaWRlbnRpZmllcicsXG4gICAgICAgIFVuZXhwZWN0ZWRSZXNlcnZlZDogJ1VuZXhwZWN0ZWQgcmVzZXJ2ZWQgd29yZCcsXG4gICAgICAgIFVuZXhwZWN0ZWRFT1M6ICdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcsXG4gICAgICAgIE5ld2xpbmVBZnRlclRocm93OiAnSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93JyxcbiAgICAgICAgSW52YWxpZFJlZ0V4cDogJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uJyxcbiAgICAgICAgVW50ZXJtaW5hdGVkUmVnRXhwOiAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IG1pc3NpbmcgLycsXG4gICAgICAgIEludmFsaWRMSFNJbkFzc2lnbm1lbnQ6ICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGFzc2lnbm1lbnQnLFxuICAgICAgICBJbnZhbGlkTEhTSW5Gb3JJbjogJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLWluJyxcbiAgICAgICAgTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoOiAnTW9yZSB0aGFuIG9uZSBkZWZhdWx0IGNsYXVzZSBpbiBzd2l0Y2ggc3RhdGVtZW50JyxcbiAgICAgICAgTm9DYXRjaE9yRmluYWxseTogJ01pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBhZnRlciB0cnknLFxuICAgICAgICBVbmtub3duTGFiZWw6ICdVbmRlZmluZWQgbGFiZWwgXFwnJTBcXCcnLFxuICAgICAgICBSZWRlY2xhcmF0aW9uOiAnJTAgXFwnJTFcXCcgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZCcsXG4gICAgICAgIElsbGVnYWxDb250aW51ZTogJ0lsbGVnYWwgY29udGludWUgc3RhdGVtZW50JyxcbiAgICAgICAgSWxsZWdhbEJyZWFrOiAnSWxsZWdhbCBicmVhayBzdGF0ZW1lbnQnLFxuICAgICAgICBJbGxlZ2FsUmV0dXJuOiAnSWxsZWdhbCByZXR1cm4gc3RhdGVtZW50JyxcbiAgICAgICAgU3RyaWN0TW9kZVdpdGg6ICdTdHJpY3QgbW9kZSBjb2RlIG1heSBub3QgaW5jbHVkZSBhIHdpdGggc3RhdGVtZW50JyxcbiAgICAgICAgU3RyaWN0Q2F0Y2hWYXJpYWJsZTogJ0NhdGNoIHZhcmlhYmxlIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RWYXJOYW1lOiAnVmFyaWFibGUgbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0UGFyYW1OYW1lOiAnUGFyYW1ldGVyIG5hbWUgZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RQYXJhbUR1cGU6ICdTdHJpY3QgbW9kZSBmdW5jdGlvbiBtYXkgbm90IGhhdmUgZHVwbGljYXRlIHBhcmFtZXRlciBuYW1lcycsXG4gICAgICAgIFN0cmljdEZ1bmN0aW9uTmFtZTogJ0Z1bmN0aW9uIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdE9jdGFsTGl0ZXJhbDogJ09jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZS4nLFxuICAgICAgICBTdHJpY3REZWxldGU6ICdEZWxldGUgb2YgYW4gdW5xdWFsaWZpZWQgaWRlbnRpZmllciBpbiBzdHJpY3QgbW9kZS4nLFxuICAgICAgICBTdHJpY3REdXBsaWNhdGVQcm9wZXJ0eTogJ0R1cGxpY2F0ZSBkYXRhIHByb3BlcnR5IGluIG9iamVjdCBsaXRlcmFsIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgQWNjZXNzb3JEYXRhUHJvcGVydHk6ICdPYmplY3QgbGl0ZXJhbCBtYXkgbm90IGhhdmUgZGF0YSBhbmQgYWNjZXNzb3IgcHJvcGVydHkgd2l0aCB0aGUgc2FtZSBuYW1lJyxcbiAgICAgICAgQWNjZXNzb3JHZXRTZXQ6ICdPYmplY3QgbGl0ZXJhbCBtYXkgbm90IGhhdmUgbXVsdGlwbGUgZ2V0L3NldCBhY2Nlc3NvcnMgd2l0aCB0aGUgc2FtZSBuYW1lJyxcbiAgICAgICAgU3RyaWN0TEhTQXNzaWdubWVudDogJ0Fzc2lnbm1lbnQgdG8gZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RMSFNQb3N0Zml4OiAnUG9zdGZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0TEhTUHJlZml4OiAnUHJlZml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RSZXNlcnZlZFdvcmQ6ICdVc2Ugb2YgZnV0dXJlIHJlc2VydmVkIHdvcmQgaW4gc3RyaWN0IG1vZGUnXG4gICAgfTtcblxuICAgIC8vIFNlZSBhbHNvIHRvb2xzL2dlbmVyYXRlLXVuaWNvZGUtcmVnZXgucHkuXG4gICAgUmVnZXggPSB7XG4gICAgICAgIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OiBuZXcgUmVnRXhwKCdbXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjJcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNThcXHUwQzU5XFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENjBcXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QzEtXFx1MTlDN1xcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBN0FEXFx1QTdCMFxcdUE3QjFcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI1RlxcdUFCNjRcXHVBQjY1XFx1QUJDMC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXScpLFxuICAgICAgICBOb25Bc2NpaUlkZW50aWZpZXJQYXJ0OiBuZXcgUmVnRXhwKCdbXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4My1cXHUwNDg3XFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MTAtXFx1MDYxQVxcdTA2MjAtXFx1MDY2OVxcdTA2NkUtXFx1MDZEM1xcdTA2RDUtXFx1MDZEQ1xcdTA2REYtXFx1MDZFOFxcdTA2RUEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwLVxcdTA3NEFcXHUwNzRELVxcdTA3QjFcXHUwN0MwLVxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODJEXFx1MDg0MC1cXHUwODVCXFx1MDhBMC1cXHUwOEIyXFx1MDhFNC1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZGXFx1MDk3MS1cXHUwOTgzXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCQy1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0VcXHUwOUQ3XFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTNcXHUwOUU2LVxcdTA5RjFcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJDLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFFNi1cXHUwQUVGXFx1MEIwMS1cXHUwQjAzXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0MtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNjYtXFx1MEI2RlxcdTBCNzFcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQwXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDAtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM1OFxcdTBDNTlcXHUwQzYwLVxcdTBDNjNcXHUwQzY2LVxcdTBDNkZcXHUwQzgxLVxcdTBDODNcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JDLVxcdTBDQzRcXHUwQ0M2LVxcdTBDQzhcXHUwQ0NBLVxcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDREVcXHUwQ0UwLVxcdTBDRTNcXHUwQ0U2LVxcdTBDRUZcXHUwQ0YxXFx1MENGMlxcdTBEMDEtXFx1MEQwM1xcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0QtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RVxcdTBENTdcXHUwRDYwLVxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERTYtXFx1MERFRlxcdTBERjJcXHUwREYzXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMThcXHUwRjE5XFx1MEYyMC1cXHUwRjI5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRS1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY3MS1cXHUwRjg0XFx1MEY4Ni1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5RFxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzNUZcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdEM1xcdTE3RDdcXHUxN0RDXFx1MTdERFxcdTE3RTAtXFx1MTdFOVxcdTE4MEItXFx1MTgwRFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEOVxcdTFBMDAtXFx1MUExQlxcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCNEJcXHUxQjUwLVxcdTFCNTlcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCRjNcXHUxQzAwLVxcdTFDMzdcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRjZcXHUxQ0Y4XFx1MUNGOVxcdTFEMDAtXFx1MURGNVxcdTFERkMtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDdGLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyREUwLVxcdTJERkZcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDJGXFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5OVxcdTMwOUFcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGQ0NcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MkJcXHVBNjQwLVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjdGLVxcdUE2OURcXHVBNjlGLVxcdUE2RjFcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3OEVcXHVBNzkwLVxcdUE3QURcXHVBN0IwXFx1QTdCMVxcdUE3RjctXFx1QTgyN1xcdUE4NDAtXFx1QTg3M1xcdUE4ODAtXFx1QThDNFxcdUE4RDAtXFx1QThEOVxcdUE4RTAtXFx1QThGN1xcdUE4RkJcXHVBOTAwLVxcdUE5MkRcXHVBOTMwLVxcdUE5NTNcXHVBOTYwLVxcdUE5N0NcXHVBOTgwLVxcdUE5QzBcXHVBOUNGLVxcdUE5RDlcXHVBOUUwLVxcdUE5RkVcXHVBQTAwLVxcdUFBMzZcXHVBQTQwLVxcdUFBNERcXHVBQTUwLVxcdUFBNTlcXHVBQTYwLVxcdUFBNzZcXHVBQTdBLVxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUZcXHVBQUYyLVxcdUFBRjZcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNUZcXHVBQjY0XFx1QUI2NVxcdUFCQzAtXFx1QUJFQVxcdUFCRUNcXHVBQkVEXFx1QUJGMC1cXHVBQkY5XFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRC1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkRcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMTAtXFx1RkYxOVxcdUZGMjEtXFx1RkYzQVxcdUZGM0ZcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdJylcbiAgICB9O1xuXG4gICAgLy8gRW5zdXJlIHRoZSBjb25kaXRpb24gaXMgdHJ1ZSwgb3RoZXJ3aXNlIHRocm93IGFuIGVycm9yLlxuICAgIC8vIFRoaXMgaXMgb25seSB0byBoYXZlIGEgYmV0dGVyIGNvbnRyYWN0IHNlbWFudGljLCBpLmUuIGFub3RoZXIgc2FmZXR5IG5ldFxuICAgIC8vIHRvIGNhdGNoIGEgbG9naWMgZXJyb3IuIFRoZSBjb25kaXRpb24gc2hhbGwgYmUgZnVsZmlsbGVkIGluIG5vcm1hbCBjYXNlLlxuICAgIC8vIERvIE5PVCB1c2UgdGhpcyB0byBlbmZvcmNlIGEgY2VydGFpbiBjb25kaXRpb24gb24gYW55IHVzZXIgaW5wdXQuXG5cbiAgICBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBU1NFUlQ6ICcgKyBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPj0gMHgzMCAmJiBjaCA8PSAweDM5KTsgICAvLyAwLi45XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gJzAxMjM0NTY3ODlhYmNkZWZBQkNERUYnLmluZGV4T2YoY2gpID49IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpID49IDA7XG4gICAgfVxuXG5cbiAgICAvLyA3LjIgV2hpdGUgU3BhY2VcblxuICAgIGZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAweDIwKSB8fCAoY2ggPT09IDB4MDkpIHx8IChjaCA9PT0gMHgwQikgfHwgKGNoID09PSAweDBDKSB8fCAoY2ggPT09IDB4QTApIHx8XG4gICAgICAgICAgICAoY2ggPj0gMHgxNjgwICYmIFsweDE2ODAsIDB4MTgwRSwgMHgyMDAwLCAweDIwMDEsIDB4MjAwMiwgMHgyMDAzLCAweDIwMDQsIDB4MjAwNSwgMHgyMDA2LCAweDIwMDcsIDB4MjAwOCwgMHgyMDA5LCAweDIwMEEsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDAsIDB4RkVGRl0uaW5kZXhPZihjaCkgPj0gMCk7XG4gICAgfVxuXG4gICAgLy8gNy4zIExpbmUgVGVybWluYXRvcnNcblxuICAgIGZ1bmN0aW9uIGlzTGluZVRlcm1pbmF0b3IoY2gpIHtcbiAgICAgICAgcmV0dXJuIChjaCA9PT0gMHgwQSkgfHwgKGNoID09PSAweDBEKSB8fCAoY2ggPT09IDB4MjAyOCkgfHwgKGNoID09PSAweDIwMjkpO1xuICAgIH1cblxuICAgIC8vIDcuNiBJZGVudGlmaWVyIE5hbWVzIGFuZCBJZGVudGlmaWVyc1xuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY2gpIHtcbiAgICAgICAgcmV0dXJuIChjaCA9PT0gMHgyNCkgfHwgKGNoID09PSAweDVGKSB8fCAgLy8gJCAoZG9sbGFyKSBhbmQgXyAodW5kZXJzY29yZSlcbiAgICAgICAgICAgIChjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEpIHx8ICAgICAgICAgLy8gQS4uWlxuICAgICAgICAgICAgKGNoID49IDB4NjEgJiYgY2ggPD0gMHg3QSkgfHwgICAgICAgICAvLyBhLi56XG4gICAgICAgICAgICAoY2ggPT09IDB4NUMpIHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIFxcIChiYWNrc2xhc2gpXG4gICAgICAgICAgICAoKGNoID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPT09IDB4MjQpIHx8IChjaCA9PT0gMHg1RikgfHwgIC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXG4gICAgICAgICAgICAoY2ggPj0gMHg0MSAmJiBjaCA8PSAweDVBKSB8fCAgICAgICAgIC8vIEEuLlpcbiAgICAgICAgICAgIChjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EpIHx8ICAgICAgICAgLy8gYS4uelxuICAgICAgICAgICAgKGNoID49IDB4MzAgJiYgY2ggPD0gMHgzOSkgfHwgICAgICAgICAvLyAwLi45XG4gICAgICAgICAgICAoY2ggPT09IDB4NUMpIHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIFxcIChiYWNrc2xhc2gpXG4gICAgICAgICAgICAoKGNoID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclBhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpO1xuICAgIH1cblxuICAgIC8vIDcuNi4xLjIgRnV0dXJlIFJlc2VydmVkIFdvcmRzXG5cbiAgICBmdW5jdGlvbiBpc0Z1dHVyZVJlc2VydmVkV29yZChpZCkge1xuICAgICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgY2FzZSAnZW51bSc6XG4gICAgICAgIGNhc2UgJ2V4cG9ydCc6XG4gICAgICAgIGNhc2UgJ2V4dGVuZHMnOlxuICAgICAgICBjYXNlICdpbXBvcnQnOlxuICAgICAgICBjYXNlICdzdXBlcic6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZCkge1xuICAgICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxuICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxuICAgICAgICBjYXNlICdwYWNrYWdlJzpcbiAgICAgICAgY2FzZSAncHJpdmF0ZSc6XG4gICAgICAgIGNhc2UgJ3Byb3RlY3RlZCc6XG4gICAgICAgIGNhc2UgJ3B1YmxpYyc6XG4gICAgICAgIGNhc2UgJ3N0YXRpYyc6XG4gICAgICAgIGNhc2UgJ3lpZWxkJzpcbiAgICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNSZXN0cmljdGVkV29yZChpZCkge1xuICAgICAgICByZXR1cm4gaWQgPT09ICdldmFsJyB8fCBpZCA9PT0gJ2FyZ3VtZW50cyc7XG4gICAgfVxuXG4gICAgLy8gNy42LjEuMSBLZXl3b3Jkc1xuXG4gICAgZnVuY3Rpb24gaXNLZXl3b3JkKGlkKSB7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAnY29uc3QnIGlzIHNwZWNpYWxpemVkIGFzIEtleXdvcmQgaW4gVjguXG4gICAgICAgIC8vICd5aWVsZCcgYW5kICdsZXQnIGFyZSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIFNwaWRlck1vbmtleSBhbmQgRVMubmV4dC5cbiAgICAgICAgLy8gU29tZSBvdGhlcnMgYXJlIGZyb20gZnV0dXJlIHJlc2VydmVkIHdvcmRzLlxuXG4gICAgICAgIHN3aXRjaCAoaWQubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpZicpIHx8IChpZCA9PT0gJ2luJykgfHwgKGlkID09PSAnZG8nKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3ZhcicpIHx8IChpZCA9PT0gJ2ZvcicpIHx8IChpZCA9PT0gJ25ldycpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAndHJ5JykgfHwgKGlkID09PSAnbGV0Jyk7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd0aGlzJykgfHwgKGlkID09PSAnZWxzZScpIHx8IChpZCA9PT0gJ2Nhc2UnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ3ZvaWQnKSB8fCAoaWQgPT09ICd3aXRoJykgfHwgKGlkID09PSAnZW51bScpO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnd2hpbGUnKSB8fCAoaWQgPT09ICdicmVhaycpIHx8IChpZCA9PT0gJ2NhdGNoJykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICd0aHJvdycpIHx8IChpZCA9PT0gJ2NvbnN0JykgfHwgKGlkID09PSAneWllbGQnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ2NsYXNzJykgfHwgKGlkID09PSAnc3VwZXInKTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3JldHVybicpIHx8IChpZCA9PT0gJ3R5cGVvZicpIHx8IChpZCA9PT0gJ2RlbGV0ZScpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAnc3dpdGNoJykgfHwgKGlkID09PSAnZXhwb3J0JykgfHwgKGlkID09PSAnaW1wb3J0Jyk7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdkZWZhdWx0JykgfHwgKGlkID09PSAnZmluYWxseScpIHx8IChpZCA9PT0gJ2V4dGVuZHMnKTtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2Z1bmN0aW9uJykgfHwgKGlkID09PSAnY29udGludWUnKSB8fCAoaWQgPT09ICdkZWJ1Z2dlcicpO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2luc3RhbmNlb2YnKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIDcuNCBDb21tZW50c1xuXG4gICAgZnVuY3Rpb24gYWRkQ29tbWVudCh0eXBlLCB2YWx1ZSwgc3RhcnQsIGVuZCwgbG9jKSB7XG4gICAgICAgIHZhciBjb21tZW50O1xuXG4gICAgICAgIGFzc2VydCh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInLCAnQ29tbWVudCBtdXN0IGhhdmUgdmFsaWQgcG9zaXRpb24nKTtcblxuICAgICAgICAvLyBCZWNhdXNlIHRoZSB3YXkgdGhlIGFjdHVhbCB0b2tlbiBpcyBzY2FubmVkLCBvZnRlbiB0aGUgY29tbWVudHNcbiAgICAgICAgLy8gKGlmIGFueSkgYXJlIHNraXBwZWQgdHdpY2UgZHVyaW5nIHRoZSBsZXhpY2FsIGFuYWx5c2lzLlxuICAgICAgICAvLyBUaHVzLCB3ZSBuZWVkIHRvIHNraXAgYWRkaW5nIGEgY29tbWVudCBpZiB0aGUgY29tbWVudCBhcnJheSBhbHJlYWR5XG4gICAgICAgIC8vIGhhbmRsZWQgaXQuXG4gICAgICAgIGlmIChzdGF0ZS5sYXN0Q29tbWVudFN0YXJ0ID49IHN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGFzdENvbW1lbnRTdGFydCA9IHN0YXJ0O1xuXG4gICAgICAgIGNvbW1lbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgY29tbWVudC5yYW5nZSA9IFtzdGFydCwgZW5kXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICBjb21tZW50LmxvYyA9IGxvYztcbiAgICAgICAgfVxuICAgICAgICBleHRyYS5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICBpZiAoZXh0cmEuYXR0YWNoQ29tbWVudCkge1xuICAgICAgICAgICAgZXh0cmEubGVhZGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICBleHRyYS50cmFpbGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2lwU2luZ2xlTGluZUNvbW1lbnQob2Zmc2V0KSB7XG4gICAgICAgIHZhciBzdGFydCwgbG9jLCBjaCwgY29tbWVudDtcblxuICAgICAgICBzdGFydCA9IGluZGV4IC0gb2Zmc2V0O1xuICAgICAgICBsb2MgPSB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydCAtIG9mZnNldFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQgKyBvZmZzZXQsIGluZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydCAtIDFcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ29tbWVudCgnTGluZScsIGNvbW1lbnQsIHN0YXJ0LCBpbmRleCAtIDEsIGxvYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMTMgJiYgc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICBjb21tZW50ID0gc291cmNlLnNsaWNlKHN0YXJ0ICsgb2Zmc2V0LCBpbmRleCk7XG4gICAgICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFkZENvbW1lbnQoJ0xpbmUnLCBjb21tZW50LCBzdGFydCwgaW5kZXgsIGxvYyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2lwTXVsdGlMaW5lQ29tbWVudCgpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBsb2MsIGNoLCBjb21tZW50O1xuXG4gICAgICAgIGlmIChleHRyYS5jb21tZW50cykge1xuICAgICAgICAgICAgc3RhcnQgPSBpbmRleCAtIDI7XG4gICAgICAgICAgICBsb2MgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydCAtIDJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgwRCAmJiBzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpID09PSAweDBBKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAweDJBKSB7XG4gICAgICAgICAgICAgICAgLy8gQmxvY2sgY29tbWVudCBlbmRzIHdpdGggJyovJy5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSA9PT0gMHgyRikge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmEuY29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQgKyAyLCBpbmRleCAtIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDb21tZW50KCdCbG9jaycsIGNvbW1lbnQsIHN0YXJ0LCBpbmRleCwgbG9jKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNraXBDb21tZW50KCkge1xuICAgICAgICB2YXIgY2gsIHN0YXJ0O1xuXG4gICAgICAgIHN0YXJ0ID0gKGluZGV4ID09PSAwKTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgICAgICAgICAgaWYgKGlzV2hpdGVTcGFjZShjaCkpIHtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAweDBEICYmIHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgwQSkge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyRikgeyAvLyBVKzAwMkYgaXMgJy8nXG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgyRikge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICBza2lwU2luZ2xlTGluZUNvbW1lbnQoMik7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAweDJBKSB7ICAvLyBVKzAwMkEgaXMgJyonXG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHNraXBNdWx0aUxpbmVDb21tZW50KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydCAmJiBjaCA9PT0gMHgyRCkgeyAvLyBVKzAwMkQgaXMgJy0nXG4gICAgICAgICAgICAgICAgLy8gVSswMDNFIGlzICc+J1xuICAgICAgICAgICAgICAgIGlmICgoc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSA9PT0gMHgyRCkgJiYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMikgPT09IDB4M0UpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICctLT4nIGlzIGEgc2luZ2xlLWxpbmUgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAzO1xuICAgICAgICAgICAgICAgICAgICBza2lwU2luZ2xlTGluZUNvbW1lbnQoMyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMHgzQykgeyAvLyBVKzAwM0MgaXMgJzwnXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShpbmRleCArIDEsIGluZGV4ICsgNCkgPT09ICchLS0nKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7IC8vIGA8YFxuICAgICAgICAgICAgICAgICAgICArK2luZGV4OyAvLyBgIWBcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDsgLy8gYC1gXG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7IC8vIGAtYFxuICAgICAgICAgICAgICAgICAgICBza2lwU2luZ2xlTGluZUNvbW1lbnQoNCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5IZXhFc2NhcGUocHJlZml4KSB7XG4gICAgICAgIHZhciBpLCBsZW4sIGNoLCBjb2RlID0gMDtcblxuICAgICAgICBsZW4gPSAocHJlZml4ID09PSAndScpID8gNCA6IDI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGlzSGV4RGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDE2ICsgJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpIHtcbiAgICAgICAgdmFyIGNoLCBjb2RlLCBjdTEsIGN1MjtcblxuICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgIGNvZGUgPSAwO1xuXG4gICAgICAgIC8vIEF0IGxlYXN0LCBvbmUgaGV4IGRpZ2l0IGlzIHJlcXVpcmVkLlxuICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICBpZiAoIWlzSGV4RGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RlID0gY29kZSAqIDE2ICsgJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA+IDB4MTBGRkZGIHx8IGNoICE9PSAnfScpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVVEYtMTYgRW5jb2RpbmdcbiAgICAgICAgaWYgKGNvZGUgPD0gMHhGRkZGKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjdTEgPSAoKGNvZGUgLSAweDEwMDAwKSA+PiAxMCkgKyAweEQ4MDA7XG4gICAgICAgIGN1MiA9ICgoY29kZSAtIDB4MTAwMDApICYgMTAyMykgKyAweERDMDA7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGN1MSwgY3UyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFc2NhcGVkSWRlbnRpZmllcigpIHtcbiAgICAgICAgdmFyIGNoLCBpZDtcblxuICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KyspO1xuICAgICAgICBpZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuXG4gICAgICAgIC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgaWYgKGNoID09PSAweDVDKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpICE9PSAweDc1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcbiAgICAgICAgICAgIGlmICghY2ggfHwgY2ggPT09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyU3RhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWQgPSBjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgaWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG5cbiAgICAgICAgICAgIC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgICAgICAgICAgIGlkID0gaWQuc3Vic3RyKDAsIGlkLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgIT09IDB4NzUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoIHx8IGNoID09PSAnXFxcXCcgfHwgIWlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWQgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SWRlbnRpZmllcigpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBjaDtcblxuICAgICAgICBzdGFydCA9IGluZGV4Kys7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDB4NUMpIHtcbiAgICAgICAgICAgICAgICAvLyBCbGFja3NsYXNoIChVKzAwNUMpIG1hcmtzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgIGluZGV4ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEVzY2FwZWRJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2Uoc3RhcnQsIGluZGV4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuSWRlbnRpZmllcigpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBpZCwgdHlwZTtcblxuICAgICAgICBzdGFydCA9IGluZGV4O1xuXG4gICAgICAgIC8vIEJhY2tzbGFzaCAoVSswMDVDKSBzdGFydHMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgIGlkID0gKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHg1QykgPyBnZXRFc2NhcGVkSWRlbnRpZmllcigpIDogZ2V0SWRlbnRpZmllcigpO1xuXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIGtleXdvcmQgb3IgbGl0ZXJhbCB3aXRoIG9ubHkgb25lIGNoYXJhY3Rlci5cbiAgICAgICAgLy8gVGh1cywgaXQgbXVzdCBiZSBhbiBpZGVudGlmaWVyLlxuICAgICAgICBpZiAoaWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0eXBlID0gVG9rZW4uSWRlbnRpZmllcjtcbiAgICAgICAgfSBlbHNlIGlmIChpc0tleXdvcmQoaWQpKSB7XG4gICAgICAgICAgICB0eXBlID0gVG9rZW4uS2V5d29yZDtcbiAgICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICB0eXBlID0gVG9rZW4uTnVsbExpdGVyYWw7XG4gICAgICAgIH0gZWxzZSBpZiAoaWQgPT09ICd0cnVlJyB8fCBpZCA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgdHlwZSA9IFRva2VuLkJvb2xlYW5MaXRlcmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHlwZSA9IFRva2VuLklkZW50aWZpZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiBpZCxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIC8vIDcuNyBQdW5jdHVhdG9yc1xuXG4gICAgZnVuY3Rpb24gc2NhblB1bmN0dWF0b3IoKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGluZGV4LFxuICAgICAgICAgICAgY29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSxcbiAgICAgICAgICAgIGNvZGUyLFxuICAgICAgICAgICAgY2gxID0gc291cmNlW2luZGV4XSxcbiAgICAgICAgICAgIGNoMixcbiAgICAgICAgICAgIGNoMyxcbiAgICAgICAgICAgIGNoNDtcblxuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcblxuICAgICAgICAvLyBDaGVjayBmb3IgbW9zdCBjb21tb24gc2luZ2xlLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cbiAgICAgICAgY2FzZSAweDJFOiAgLy8gLiBkb3RcbiAgICAgICAgY2FzZSAweDI4OiAgLy8gKCBvcGVuIGJyYWNrZXRcbiAgICAgICAgY2FzZSAweDI5OiAgLy8gKSBjbG9zZSBicmFja2V0XG4gICAgICAgIGNhc2UgMHgzQjogIC8vIDsgc2VtaWNvbG9uXG4gICAgICAgIGNhc2UgMHgyQzogIC8vICwgY29tbWFcbiAgICAgICAgY2FzZSAweDdCOiAgLy8geyBvcGVuIGN1cmx5IGJyYWNlXG4gICAgICAgIGNhc2UgMHg3RDogIC8vIH0gY2xvc2UgY3VybHkgYnJhY2VcbiAgICAgICAgY2FzZSAweDVCOiAgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6ICAvLyBdXG4gICAgICAgIGNhc2UgMHgzQTogIC8vIDpcbiAgICAgICAgY2FzZSAweDNGOiAgLy8gP1xuICAgICAgICBjYXNlIDB4N0U6ICAvLyB+XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgaWYgKGV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDB4MjgpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmEub3BlblBhcmVuVG9rZW4gPSBleHRyYS50b2tlbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg3Qikge1xuICAgICAgICAgICAgICAgICAgICBleHRyYS5vcGVuQ3VybHlUb2tlbiA9IGV4dHJhLnRva2Vucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvZGUyID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblxuICAgICAgICAgICAgLy8gJz0nIChVKzAwM0QpIG1hcmtzIGFuIGFzc2lnbm1lbnQgb3IgY29tcGFyaXNvbiBvcGVyYXRvci5cbiAgICAgICAgICAgIGlmIChjb2RlMiA9PT0gMHgzRCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMHgyQjogIC8vICtcbiAgICAgICAgICAgICAgICBjYXNlIDB4MkQ6ICAvLyAtXG4gICAgICAgICAgICAgICAgY2FzZSAweDJGOiAgLy8gL1xuICAgICAgICAgICAgICAgIGNhc2UgMHgzQzogIC8vIDxcbiAgICAgICAgICAgICAgICBjYXNlIDB4M0U6ICAvLyA+XG4gICAgICAgICAgICAgICAgY2FzZSAweDVFOiAgLy8gXlxuICAgICAgICAgICAgICAgIGNhc2UgMHg3QzogIC8vIHxcbiAgICAgICAgICAgICAgICBjYXNlIDB4MjU6ICAvLyAlXG4gICAgICAgICAgICAgICAgY2FzZSAweDI2OiAgLy8gJlxuICAgICAgICAgICAgICAgIGNhc2UgMHgyQTogIC8vICpcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgY2FzZSAweDIxOiAvLyAhXG4gICAgICAgICAgICAgICAgY2FzZSAweDNEOiAvLyA9XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gIT09IGFuZCA9PT1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgzRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzb3VyY2Uuc2xpY2Uoc3RhcnQsIGluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyA0LWNoYXJhY3RlciBwdW5jdHVhdG9yOiA+Pj49XG5cbiAgICAgICAgY2g0ID0gc291cmNlLnN1YnN0cihpbmRleCwgNCk7XG5cbiAgICAgICAgaWYgKGNoNCA9PT0gJz4+Pj0nKSB7XG4gICAgICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjaDQsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMtY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiA9PT0gIT09ID4+PiA8PD0gPj49XG5cbiAgICAgICAgY2gzID0gY2g0LnN1YnN0cigwLCAzKTtcblxuICAgICAgICBpZiAoY2gzID09PSAnPj4+JyB8fCBjaDMgPT09ICc8PD0nIHx8IGNoMyA9PT0gJz4+PScpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoMyxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXIgMi1jaGFyYWN0ZXIgcHVuY3R1YXRvcnM6ICsrIC0tIDw8ID4+ICYmIHx8XG4gICAgICAgIGNoMiA9IGNoMy5zdWJzdHIoMCwgMik7XG5cbiAgICAgICAgaWYgKChjaDEgPT09IGNoMlsxXSAmJiAoJystPD4mfCcuaW5kZXhPZihjaDEpID49IDApKSB8fCBjaDIgPT09ICc9PicpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoMixcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnM6IDwgPiA9ICEgKyAtICogJSAmIHwgXiAvXG5cbiAgICAgICAgaWYgKCc8Pj0hKy0qJSZ8Xi8nLmluZGV4T2YoY2gxKSA+PSAwKSB7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjaDEsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgfVxuXG4gICAgLy8gNy44LjMgTnVtZXJpYyBMaXRlcmFsc1xuXG4gICAgZnVuY3Rpb24gc2NhbkhleExpdGVyYWwoc3RhcnQpIHtcbiAgICAgICAgdmFyIG51bWJlciA9ICcnO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFpc0hleERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG51bWJlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludCgnMHgnICsgbnVtYmVyLCAxNiksXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbkJpbmFyeUxpdGVyYWwoc3RhcnQpIHtcbiAgICAgICAgdmFyIGNoLCBudW1iZXI7XG5cbiAgICAgICAgbnVtYmVyID0gJyc7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoY2ggIT09ICcwJyAmJiBjaCAhPT0gJzEnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG51bWJlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIG9ubHkgMGIgb3IgMEJcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjaCkgfHwgaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW1iZXIsIDIpLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5PY3RhbExpdGVyYWwocHJlZml4LCBzdGFydCkge1xuICAgICAgICB2YXIgbnVtYmVyLCBvY3RhbDtcblxuICAgICAgICBpZiAoaXNPY3RhbERpZ2l0KHByZWZpeCkpIHtcbiAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgIG51bWJlciA9ICcwJyArIHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9jdGFsID0gZmFsc2U7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgbnVtYmVyID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvY3RhbCAmJiBudW1iZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBvbmx5IDBvIG9yIDBPXG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkgfHwgaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW1iZXIsIDgpLFxuICAgICAgICAgICAgb2N0YWw6IG9jdGFsLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSW1wbGljaXRPY3RhbExpdGVyYWwoKSB7XG4gICAgICAgIHZhciBpLCBjaDtcblxuICAgICAgICAvLyBJbXBsaWNpdCBvY3RhbCwgdW5sZXNzIHRoZXJlIGlzIGEgbm9uLW9jdGFsIGRpZ2l0LlxuICAgICAgICAvLyAoQW5uZXggQi4xLjEgb24gTnVtZXJpYyBMaXRlcmFscylcbiAgICAgICAgZm9yIChpID0gaW5kZXggKyAxOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2ldO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnOCcgfHwgY2ggPT09ICc5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2Nhbk51bWVyaWNMaXRlcmFsKCkge1xuICAgICAgICB2YXIgbnVtYmVyLCBzdGFydCwgY2g7XG5cbiAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBhc3NlcnQoaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkgfHwgKGNoID09PSAnLicpLFxuICAgICAgICAgICAgJ051bWVyaWMgbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBkZWNpbWFsIGRpZ2l0IG9yIGEgZGVjaW1hbCBwb2ludCcpO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXg7XG4gICAgICAgIG51bWJlciA9ICcnO1xuICAgICAgICBpZiAoY2ggIT09ICcuJykge1xuICAgICAgICAgICAgbnVtYmVyID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuXG4gICAgICAgICAgICAvLyBIZXggbnVtYmVyIHN0YXJ0cyB3aXRoICcweCcuXG4gICAgICAgICAgICAvLyBPY3RhbCBudW1iZXIgc3RhcnRzIHdpdGggJzAnLlxuICAgICAgICAgICAgLy8gT2N0YWwgbnVtYmVyIGluIEVTNiBzdGFydHMgd2l0aCAnMG8nLlxuICAgICAgICAgICAgLy8gQmluYXJ5IG51bWJlciBpbiBFUzYgc3RhcnRzIHdpdGggJzBiJy5cbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09ICcwJykge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3gnIHx8IGNoID09PSAnWCcpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5IZXhMaXRlcmFsKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnYicgfHwgY2ggPT09ICdCJykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhbkJpbmFyeUxpdGVyYWwoc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdvJyB8fCBjaCA9PT0gJ08nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuT2N0YWxMaXRlcmFsKGNoLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW1wbGljaXRPY3RhbExpdGVyYWwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5PY3RhbExpdGVyYWwoY2gsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoY2ggPT09ICcrJyB8fCBjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KG51bWJlciksXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gNy44LjQgU3RyaW5nIExpdGVyYWxzXG5cbiAgICBmdW5jdGlvbiBzY2FuU3RyaW5nTGl0ZXJhbCgpIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnLCBxdW90ZSwgc3RhcnQsIGNoLCBjb2RlLCB1bmVzY2FwZWQsIHJlc3RvcmUsIG9jdGFsID0gZmFsc2UsIHN0YXJ0TGluZU51bWJlciwgc3RhcnRMaW5lU3RhcnQ7XG4gICAgICAgIHN0YXJ0TGluZU51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICAgIHN0YXJ0TGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuXG4gICAgICAgIHF1b3RlID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgYXNzZXJ0KChxdW90ZSA9PT0gJ1xcJycgfHwgcXVvdGUgPT09ICdcIicpLFxuICAgICAgICAgICAgJ1N0cmluZyBsaXRlcmFsIG11c3Qgc3RhcnRzIHdpdGggYSBxdW90ZScpO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICsraW5kZXg7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xuICAgICAgICAgICAgICAgIHF1b3RlID0gJyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoIHx8ICFpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RvcmUgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWQgPSBzY2FuSGV4RXNjYXBlKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSB1bmVzY2FwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN0b3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHgwQic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gJzAxMjM0NTY3Jy5pbmRleE9mKGNoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFxcMCBpcyBub3Qgb2N0YWwgZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyAnMDEyMzQ1NjcnLmluZGV4T2Yoc291cmNlW2luZGV4KytdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzIGRpZ2l0cyBhcmUgb25seSBhbGxvd2VkIHdoZW4gc3RyaW5nIHN0YXJ0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIDAsIDEsIDIsIDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCcwMTIzJy5pbmRleE9mKGNoKSA+PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPCBsZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArICcwMTIzNDU2NycuaW5kZXhPZihzb3VyY2VbaW5kZXgrK10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHF1b3RlICE9PSAnJykge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5TdHJpbmdMaXRlcmFsLFxuICAgICAgICAgICAgdmFsdWU6IHN0cixcbiAgICAgICAgICAgIG9jdGFsOiBvY3RhbCxcbiAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlcjogc3RhcnRMaW5lTnVtYmVyLFxuICAgICAgICAgICAgc3RhcnRMaW5lU3RhcnQ6IHN0YXJ0TGluZVN0YXJ0LFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RSZWdFeHAocGF0dGVybiwgZmxhZ3MpIHtcbiAgICAgICAgdmFyIHRtcCA9IHBhdHRlcm4sXG4gICAgICAgICAgICB2YWx1ZTtcblxuICAgICAgICBpZiAoZmxhZ3MuaW5kZXhPZigndScpID49IDApIHtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgZWFjaCBhc3RyYWwgc3ltYm9sIGFuZCBldmVyeSBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZSB3aXRoIGEgc2luZ2xlIEFTQ0lJIHN5bWJvbCB0byBhdm9pZCB0aHJvd2luZyBvblxuICAgICAgICAgICAgLy8gcmVndWxhciBleHByZXNzaW9ucyB0aGF0IGFyZSBvbmx5IHZhbGlkIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlXG4gICAgICAgICAgICAvLyBgL3VgIGZsYWcuXG4gICAgICAgICAgICAvLyBOb3RlOiByZXBsYWNpbmcgd2l0aCB0aGUgQVNDSUkgc3ltYm9sIGB4YCBtaWdodCBjYXVzZSBmYWxzZVxuICAgICAgICAgICAgLy8gbmVnYXRpdmVzIGluIHVubGlrZWx5IHNjZW5hcmlvcy4gRm9yIGV4YW1wbGUsIGBbXFx1ezYxfS1iXWAgaXMgYVxuICAgICAgICAgICAgLy8gcGVyZmVjdGx5IHZhbGlkIHBhdHRlcm4gdGhhdCBpcyBlcXVpdmFsZW50IHRvIGBbYS1iXWAsIGJ1dCBpdFxuICAgICAgICAgICAgLy8gd291bGQgYmUgcmVwbGFjZWQgYnkgYFt4LWJdYCB3aGljaCB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICAgICAgICB0bXAgPSB0bXBcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXHVcXHsoWzAtOWEtZkEtRl0rKVxcfS9nLCBmdW5jdGlvbiAoJDAsICQxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZUludCgkMSwgMTYpIDw9IDB4MTBGRkZGKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3gnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nLCAneCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QsIGRldGVjdCBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBSZWdFeHAodG1wKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbnZhbGlkUmVnRXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QgZm9yIHRoaXMgcGF0dGVybi1mbGFnIHBhaXIsIG9yXG4gICAgICAgIC8vIGBudWxsYCBpbiBjYXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZmxhZ3MgaXRcbiAgICAgICAgLy8gdXNlcy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5SZWdFeHBCb2R5KCkge1xuICAgICAgICB2YXIgY2gsIHN0ciwgY2xhc3NNYXJrZXIsIHRlcm1pbmF0ZWQsIGJvZHk7XG5cbiAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBhc3NlcnQoY2ggPT09ICcvJywgJ1JlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIHNsYXNoJyk7XG4gICAgICAgIHN0ciA9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICBjbGFzc01hcmtlciA9IGZhbHNlO1xuICAgICAgICB0ZXJtaW5hdGVkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIC8vIEVDTUEtMjYyIDcuOC41XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTWFya2VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGVybWluYXRlZCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhjbHVkZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cbiAgICAgICAgYm9keSA9IHN0ci5zdWJzdHIoMSwgc3RyLmxlbmd0aCAtIDIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGJvZHksXG4gICAgICAgICAgICBsaXRlcmFsOiBzdHJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuUmVnRXhwRmxhZ3MoKSB7XG4gICAgICAgIHZhciBjaCwgc3RyLCBmbGFncywgcmVzdG9yZTtcblxuICAgICAgICBzdHIgPSAnJztcbiAgICAgICAgZmxhZ3MgPSAnJztcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RvcmUgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSBzY2FuSGV4RXNjYXBlKCd1Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHN0ciArPSAnXFxcXHUnOyByZXN0b3JlIDwgaW5kZXg7ICsrcmVzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBzb3VyY2VbcmVzdG9yZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3RvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFncyArPSAndSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFx1JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbGFncyArPSBjaDtcbiAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGZsYWdzLFxuICAgICAgICAgICAgbGl0ZXJhbDogc3RyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhblJlZ0V4cCgpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBib2R5LCBmbGFncywgdmFsdWU7XG5cbiAgICAgICAgbG9va2FoZWFkID0gbnVsbDtcbiAgICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgICAgc3RhcnQgPSBpbmRleDtcblxuICAgICAgICBib2R5ID0gc2NhblJlZ0V4cEJvZHkoKTtcbiAgICAgICAgZmxhZ3MgPSBzY2FuUmVnRXhwRmxhZ3MoKTtcbiAgICAgICAgdmFsdWUgPSB0ZXN0UmVnRXhwKGJvZHkudmFsdWUsIGZsYWdzLnZhbHVlKTtcblxuICAgICAgICBpZiAoZXh0cmEudG9rZW5pemUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUmVndWxhckV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGJvZHkudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzOiBmbGFncy52YWx1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaXRlcmFsOiBib2R5LmxpdGVyYWwgKyBmbGFncy5saXRlcmFsLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgcmVnZXg6IHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBib2R5LnZhbHVlLFxuICAgICAgICAgICAgICAgIGZsYWdzOiBmbGFncy52YWx1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2xsZWN0UmVnZXgoKSB7XG4gICAgICAgIHZhciBwb3MsIGxvYywgcmVnZXgsIHRva2VuO1xuXG4gICAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgICAgcG9zID0gaW5kZXg7XG4gICAgICAgIGxvYyA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnZXggPSBzY2FuUmVnRXhwKCk7XG5cbiAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgIH07XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKCFleHRyYS50b2tlbml6ZSkge1xuICAgICAgICAgICAgLy8gUG9wIHRoZSBwcmV2aW91cyB0b2tlbiwgd2hpY2ggaXMgbGlrZWx5ICcvJyBvciAnLz0nXG4gICAgICAgICAgICBpZiAoZXh0cmEudG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnJhbmdlWzBdID09PSBwb3MgJiYgdG9rZW4udHlwZSA9PT0gJ1B1bmN0dWF0b3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJy8nIHx8IHRva2VuLnZhbHVlID09PSAnLz0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYS50b2tlbnMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4dHJhLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUmVndWxhckV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZWdleC5saXRlcmFsLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiByZWdleC5yZWdleCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3BvcywgaW5kZXhdLFxuICAgICAgICAgICAgICAgIGxvYzogbG9jXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJOYW1lKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyIHx8XG4gICAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkIHx8XG4gICAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5Cb29sZWFuTGl0ZXJhbCB8fFxuICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uTnVsbExpdGVyYWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWR2YW5jZVNsYXNoKCkge1xuICAgICAgICB2YXIgcHJldlRva2VuLFxuICAgICAgICAgICAgY2hlY2tUb2tlbjtcbiAgICAgICAgLy8gVXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXG4gICAgICAgIHByZXZUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICghcHJldlRva2VuKSB7XG4gICAgICAgICAgICAvLyBOb3RoaW5nIGJlZm9yZSB0aGF0OiBpdCBjYW5ub3QgYmUgYSBkaXZpc2lvbi5cbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlRva2VuLnR5cGUgPT09ICdQdW5jdHVhdG9yJykge1xuICAgICAgICAgICAgaWYgKHByZXZUb2tlbi52YWx1ZSA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICBjaGVja1Rva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5QYXJlblRva2VuIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrVG9rZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udHlwZSA9PT0gJ0tleXdvcmQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ2lmJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udmFsdWUgPT09ICd3aGlsZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuLnZhbHVlID09PSAnZm9yJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udmFsdWUgPT09ICd3aXRoJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICd9Jykge1xuICAgICAgICAgICAgICAgIC8vIERpdmlkaW5nIGEgZnVuY3Rpb24gYnkgYW55dGhpbmcgbWFrZXMgbGl0dGxlIHNlbnNlLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIHRvIGNoZWNrIGZvciB0aGF0LlxuICAgICAgICAgICAgICAgIGlmIChleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSAzXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gM10udHlwZSA9PT0gJ0tleXdvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFub255bW91cyBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA0XSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNF0udHlwZSA9PT0gJ0tleXdvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5hbWVkIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNoZWNrVG9rZW4gZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmdW5jdGlvbiBpc1xuICAgICAgICAgICAgICAgIC8vIGEgZGVjbGFyYXRpb24gb3IgYW4gZXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgICBpZiAoRm5FeHByVG9rZW5zLmluZGV4T2YoY2hlY2tUb2tlbi52YWx1ZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJdCBpcyBhbiBleHByZXNzaW9uLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSXQgaXMgYSBkZWNsYXJhdGlvbi5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZUb2tlbi50eXBlID09PSAnS2V5d29yZCcgJiYgcHJldlRva2VuLnZhbHVlICE9PSAndGhpcycpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZHZhbmNlKCkge1xuICAgICAgICB2YXIgY2g7XG5cbiAgICAgICAgc2tpcENvbW1lbnQoKTtcblxuICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLkVPRixcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBpbmRleCxcbiAgICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjYW5JZGVudGlmaWVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWZXJ5IGNvbW1vbjogKCBhbmQgKSBhbmQgO1xuICAgICAgICBpZiAoY2ggPT09IDB4MjggfHwgY2ggPT09IDB4MjkgfHwgY2ggPT09IDB4M0IpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RyaW5nIGxpdGVyYWwgc3RhcnRzIHdpdGggc2luZ2xlIHF1b3RlIChVKzAwMjcpIG9yIGRvdWJsZSBxdW90ZSAoVSswMDIyKS5cbiAgICAgICAgaWYgKGNoID09PSAweDI3IHx8IGNoID09PSAweDIyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NhblN0cmluZ0xpdGVyYWwoKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gRG90ICguKSBVKzAwMkUgY2FuIGFsc28gc3RhcnQgYSBmbG9hdGluZy1wb2ludCBudW1iZXIsIGhlbmNlIHRoZSBuZWVkXG4gICAgICAgIC8vIHRvIGNoZWNrIHRoZSBuZXh0IGNoYXJhY3Rlci5cbiAgICAgICAgaWYgKGNoID09PSAweDJFKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNsYXNoICgvKSBVKzAwMkYgY2FuIGFsc28gc3RhcnQgYSByZWdleC5cbiAgICAgICAgaWYgKGV4dHJhLnRva2VuaXplICYmIGNoID09PSAweDJGKSB7XG4gICAgICAgICAgICByZXR1cm4gYWR2YW5jZVNsYXNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2xsZWN0VG9rZW4oKSB7XG4gICAgICAgIHZhciBsb2MsIHRva2VuLCB2YWx1ZSwgZW50cnk7XG5cbiAgICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgICAgbG9jID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0b2tlbiA9IGFkdmFuY2UoKTtcbiAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgdmFsdWUgPSBzb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQsIHRva2VuLmVuZCk7XG4gICAgICAgICAgICBlbnRyeSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbk5hbWVbdG9rZW4udHlwZV0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbdG9rZW4uc3RhcnQsIHRva2VuLmVuZF0sXG4gICAgICAgICAgICAgICAgbG9jOiBsb2NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodG9rZW4ucmVnZXgpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS5yZWdleCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogdG9rZW4ucmVnZXgucGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IHRva2VuLnJlZ2V4LmZsYWdzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4dHJhLnRva2Vucy5wdXNoKGVudHJ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsZXgoKSB7XG4gICAgICAgIHZhciB0b2tlbjtcblxuICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgaW5kZXggPSB0b2tlbi5lbmQ7XG4gICAgICAgIGxpbmVOdW1iZXIgPSB0b2tlbi5saW5lTnVtYmVyO1xuICAgICAgICBsaW5lU3RhcnQgPSB0b2tlbi5saW5lU3RhcnQ7XG5cbiAgICAgICAgbG9va2FoZWFkID0gKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSA/IGNvbGxlY3RUb2tlbigpIDogYWR2YW5jZSgpO1xuXG4gICAgICAgIGluZGV4ID0gdG9rZW4uZW5kO1xuICAgICAgICBsaW5lTnVtYmVyID0gdG9rZW4ubGluZU51bWJlcjtcbiAgICAgICAgbGluZVN0YXJ0ID0gdG9rZW4ubGluZVN0YXJ0O1xuXG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWVrKCkge1xuICAgICAgICB2YXIgcG9zLCBsaW5lLCBzdGFydDtcblxuICAgICAgICBwb3MgPSBpbmRleDtcbiAgICAgICAgbGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICAgIHN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICBsb29rYWhlYWQgPSAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpID8gY29sbGVjdFRva2VuKCkgOiBhZHZhbmNlKCk7XG4gICAgICAgIGluZGV4ID0gcG9zO1xuICAgICAgICBsaW5lTnVtYmVyID0gbGluZTtcbiAgICAgICAgbGluZVN0YXJ0ID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUG9zaXRpb24oKSB7XG4gICAgICAgIHRoaXMubGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMuY29sdW1uID0gaW5kZXggLSBsaW5lU3RhcnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gU291cmNlTG9jYXRpb24oKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBuZXcgUG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5lbmQgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdyYXBwaW5nU291cmNlTG9jYXRpb24oc3RhcnRUb2tlbikge1xuICAgICAgICBpZiAoc3RhcnRUb2tlbi50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0ge1xuICAgICAgICAgICAgICAgIGxpbmU6IHN0YXJ0VG9rZW4uc3RhcnRMaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogc3RhcnRUb2tlbi5zdGFydCAtIHN0YXJ0VG9rZW4uc3RhcnRMaW5lU3RhcnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0ge1xuICAgICAgICAgICAgICAgIGxpbmU6IHN0YXJ0VG9rZW4ubGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBjb2x1bW46IHN0YXJ0VG9rZW4uc3RhcnQgLSBzdGFydFRva2VuLmxpbmVTdGFydFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVuZCA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTm9kZSgpIHtcbiAgICAgICAgLy8gU2tpcCBjb21tZW50LlxuICAgICAgICBpbmRleCA9IGxvb2thaGVhZC5zdGFydDtcbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgICBsaW5lTnVtYmVyID0gbG9va2FoZWFkLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgIGxpbmVTdGFydCA9IGxvb2thaGVhZC5zdGFydExpbmVTdGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmVOdW1iZXIgPSBsb29rYWhlYWQubGluZU51bWJlcjtcbiAgICAgICAgICAgIGxpbmVTdGFydCA9IGxvb2thaGVhZC5saW5lU3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gW2luZGV4LCAwXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pIHtcbiAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gW3N0YXJ0VG9rZW4uc3RhcnQsIDBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgIHRoaXMubG9jID0gbmV3IFdyYXBwaW5nU291cmNlTG9jYXRpb24oc3RhcnRUb2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBXcmFwcGluZ05vZGUucHJvdG90eXBlID0gTm9kZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgcHJvY2Vzc0NvbW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsYXN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMsXG4gICAgICAgICAgICAgICAgYm90dG9tUmlnaHQgPSBleHRyYS5ib3R0b21SaWdodFN0YWNrLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgY29tbWVudCxcbiAgICAgICAgICAgICAgICBsYXN0ID0gYm90dG9tUmlnaHRbYm90dG9tUmlnaHQubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFN5bnRheC5Qcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHRyYS50cmFpbGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gZXh0cmEudHJhaWxpbmdDb21tZW50cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gZXh0cmEudHJhaWxpbmdDb21tZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQucmFuZ2VbMF0gPj0gdGhpcy5yYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdDb21tZW50cy51bnNoaWZ0KGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEudHJhaWxpbmdDb21tZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXh0cmEudHJhaWxpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0LnRyYWlsaW5nQ29tbWVudHMgJiYgbGFzdC50cmFpbGluZ0NvbW1lbnRzWzBdLnJhbmdlWzBdID49IHRoaXMucmFuZ2VbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdDb21tZW50cyA9IGxhc3QudHJhaWxpbmdDb21tZW50cztcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxhc3QudHJhaWxpbmdDb21tZW50cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVhdGluZyB0aGUgc3RhY2suXG4gICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChsYXN0ICYmIGxhc3QucmFuZ2VbMF0gPj0gdGhpcy5yYW5nZVswXSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q2hpbGQgPSBsYXN0O1xuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gYm90dG9tUmlnaHQucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGFzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHMgJiYgbGFzdENoaWxkLmxlYWRpbmdDb21tZW50c1tsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCAtIDFdLnJhbmdlWzFdIDw9IHRoaXMucmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWFkaW5nQ29tbWVudHMgPSBsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXh0cmEubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZWFkaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBleHRyYS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGV4dHJhLmxlYWRpbmdDb21tZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQucmFuZ2VbMV0gPD0gdGhpcy5yYW5nZVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzLnVuc2hpZnQoY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYS5sZWFkaW5nQ29tbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGlmIChsZWFkaW5nQ29tbWVudHMgJiYgbGVhZGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlYWRpbmdDb21tZW50cyA9IGxlYWRpbmdDb21tZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFpbGluZ0NvbW1lbnRzICYmIHRyYWlsaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhaWxpbmdDb21tZW50cyA9IHRyYWlsaW5nQ29tbWVudHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJvdHRvbVJpZ2h0LnB1c2godGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlWzFdID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2MuZW5kID0gbmV3IFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYy5zb3VyY2UgPSBleHRyYS5zb3VyY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXh0cmEuYXR0YWNoQ29tbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0NvbW1lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hBcnJheUV4cHJlc3Npb246IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkFycmF5RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogZnVuY3Rpb24gKHBhcmFtcywgZGVmYXVsdHMsIGJvZHksIGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5yZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbiAob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEJpbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uIChvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IChvcGVyYXRvciA9PT0gJ3x8JyB8fCBvcGVyYXRvciA9PT0gJyYmJykgPyBTeW50YXguTG9naWNhbEV4cHJlc3Npb24gOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQmxvY2tTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQmxvY2tTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEJyZWFrU3RhdGVtZW50OiBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5CcmVha1N0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24gKGNhbGxlZSwgYXJncykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNhbGxFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5jYWxsZWUgPSBjYWxsZWU7XG4gICAgICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoQ2F0Y2hDbGF1c2U6IGZ1bmN0aW9uIChwYXJhbSwgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNhdGNoQ2xhdXNlO1xuICAgICAgICAgICAgdGhpcy5wYXJhbSA9IHBhcmFtO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hDb25kaXRpb25hbEV4cHJlc3Npb246IGZ1bmN0aW9uICh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Db25kaXRpb25hbEV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcbiAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaENvbnRpbnVlU3RhdGVtZW50OiBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Db250aW51ZVN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hEZWJ1Z2dlclN0YXRlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkRlYnVnZ2VyU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaERvV2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChib2R5LCB0ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRG9XaGlsZVN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEVtcHR5U3RhdGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRW1wdHlTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoRXhwcmVzc2lvblN0YXRlbWVudDogZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hGb3JTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChpbml0LCB0ZXN0LCB1cGRhdGUsIGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Gb3JTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmluaXQgPSBpbml0O1xuICAgICAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hGb3JJblN0YXRlbWVudDogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCBib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRm9ySW5TdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZWFjaCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uIChpZCwgcGFyYW1zLCBkZWZhdWx0cywgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb247XG4gICAgICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICB0aGlzLnJlc3QgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaEZ1bmN0aW9uRXhwcmVzc2lvbjogZnVuY3Rpb24gKGlkLCBwYXJhbXMsIGRlZmF1bHRzLCBib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5yZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hJZGVudGlmaWVyOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LklkZW50aWZpZXI7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaElmU3RhdGVtZW50OiBmdW5jdGlvbiAodGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguSWZTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcbiAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaExhYmVsZWRTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChsYWJlbCwgYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkxhYmVsZWRTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaExpdGVyYWw6IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkxpdGVyYWw7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgICB0aGlzLnJhdyA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi5yZWdleCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVnZXggPSB0b2tlbi5yZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hNZW1iZXJFeHByZXNzaW9uOiBmdW5jdGlvbiAoYWNjZXNzb3IsIG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlZCA9IGFjY2Vzc29yID09PSAnWyc7XG4gICAgICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hOZXdFeHByZXNzaW9uOiBmdW5jdGlvbiAoY2FsbGVlLCBhcmdzKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguTmV3RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuY2FsbGVlID0gY2FsbGVlO1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudHMgPSBhcmdzO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaE9iamVjdEV4cHJlc3Npb246IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguT2JqZWN0RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoUG9zdGZpeEV4cHJlc3Npb246IGZ1bmN0aW9uIChvcGVyYXRvciwgYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5VcGRhdGVFeHByZXNzaW9uO1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgICAgICAgICAgdGhpcy5wcmVmaXggPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hQcm9ncmFtOiBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlByb2dyYW07XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFByb3BlcnR5OiBmdW5jdGlvbiAoa2luZCwga2V5LCB2YWx1ZSwgbWV0aG9kLCBzaG9ydGhhbmQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Qcm9wZXJ0eTtcbiAgICAgICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAgICAgICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICAgICAgdGhpcy5zaG9ydGhhbmQgPSBzaG9ydGhhbmQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoUmV0dXJuU3RhdGVtZW50OiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoU2VxdWVuY2VFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoU3dpdGNoQ2FzZTogZnVuY3Rpb24gKHRlc3QsIGNvbnNlcXVlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Td2l0Y2hDYXNlO1xuICAgICAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcbiAgICAgICAgICAgIHRoaXMuY29uc2VxdWVudCA9IGNvbnNlcXVlbnQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoU3dpdGNoU3RhdGVtZW50OiBmdW5jdGlvbiAoZGlzY3JpbWluYW50LCBjYXNlcykge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlN3aXRjaFN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMuZGlzY3JpbWluYW50ID0gZGlzY3JpbWluYW50O1xuICAgICAgICAgICAgdGhpcy5jYXNlcyA9IGNhc2VzO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFRoaXNFeHByZXNzaW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVGhpc0V4cHJlc3Npb247XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoVGhyb3dTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlRocm93U3RhdGVtZW50O1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFRyeVN0YXRlbWVudDogZnVuY3Rpb24gKGJsb2NrLCBndWFyZGVkSGFuZGxlcnMsIGhhbmRsZXJzLCBmaW5hbGl6ZXIpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5UcnlTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2s7XG4gICAgICAgICAgICB0aGlzLmd1YXJkZWRIYW5kbGVycyA9IGd1YXJkZWRIYW5kbGVycztcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMgPSBoYW5kbGVycztcbiAgICAgICAgICAgIHRoaXMuZmluYWxpemVyID0gZmluYWxpemVyO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmlzaFVuYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBhcmd1bWVudCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gKG9wZXJhdG9yID09PSAnKysnIHx8IG9wZXJhdG9yID09PSAnLS0nKSA/IFN5bnRheC5VcGRhdGVFeHByZXNzaW9uIDogU3ludGF4LlVuYXJ5RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICAgICAgICAgIHRoaXMucHJlZml4ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hWYXJpYWJsZURlY2xhcmF0aW9uOiBmdW5jdGlvbiAoZGVjbGFyYXRpb25zLCBraW5kKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb25zO1xuICAgICAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hWYXJpYWJsZURlY2xhcmF0b3I6IGZ1bmN0aW9uIChpZCwgaW5pdCkge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvcjtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluaXNoV2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uICh0ZXN0LCBib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguV2hpbGVTdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5pc2hXaXRoU3RhdGVtZW50OiBmdW5jdGlvbiAob2JqZWN0LCBib2R5KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguV2l0aFN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGVyZSBpcyBhIGxpbmUgdGVybWluYXRvciBiZWZvcmUgdGhlIG5leHQgdG9rZW4uXG5cbiAgICBmdW5jdGlvbiBwZWVrTGluZVRlcm1pbmF0b3IoKSB7XG4gICAgICAgIHZhciBwb3MsIGxpbmUsIHN0YXJ0LCBmb3VuZDtcblxuICAgICAgICBwb3MgPSBpbmRleDtcbiAgICAgICAgbGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICAgIHN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgICBmb3VuZCA9IGxpbmVOdW1iZXIgIT09IGxpbmU7XG4gICAgICAgIGluZGV4ID0gcG9zO1xuICAgICAgICBsaW5lTnVtYmVyID0gbGluZTtcbiAgICAgICAgbGluZVN0YXJ0ID0gc3RhcnQ7XG5cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVycm9yKGxpbmUsIHBvcywgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdMaW5lICcgKyBsaW5lICsgJzogJyArIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgZXJyb3IuaW5kZXggPSBwb3M7XG4gICAgICAgIGVycm9yLmxpbmVOdW1iZXIgPSBsaW5lO1xuICAgICAgICBlcnJvci5jb2x1bW4gPSBwb3MgLSBsaW5lU3RhcnQgKyAxO1xuICAgICAgICBlcnJvci5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uXG5cbiAgICBmdW5jdGlvbiB0aHJvd0Vycm9yKG1lc3NhZ2VGb3JtYXQpIHtcbiAgICAgICAgdmFyIGFyZ3MsIG1zZztcblxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgbXNnID0gbWVzc2FnZUZvcm1hdC5yZXBsYWNlKC8lKFxcZCkvZyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICh3aG9sZSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGlkeCA8IGFyZ3MubGVuZ3RoLCAnTWVzc2FnZSByZWZlcmVuY2UgbXVzdCBiZSBpbiByYW5nZScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW2lkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IobGluZU51bWJlciwgaW5kZXgsIG1zZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9sZXJhdGVFcnJvcihtZXNzYWdlRm9ybWF0KSB7XG4gICAgICAgIHZhciBhcmdzLCBtc2csIGVycm9yO1xuXG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBtc2cgPSBtZXNzYWdlRm9ybWF0LnJlcGxhY2UoLyUoXFxkKS9nLFxuICAgICAgICAgICAgZnVuY3Rpb24gKHdob2xlLCBpZHgpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQoaWR4IDwgYXJncy5sZW5ndGgsICdNZXNzYWdlIHJlZmVyZW5jZSBtdXN0IGJlIGluIHJhbmdlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbaWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBlcnJvciA9IGNyZWF0ZUVycm9yKGxpbmVOdW1iZXIsIGluZGV4LCBtc2cpO1xuICAgICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgICBleHRyYS5lcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIG9mIHRoZSB0b2tlbi5cblxuICAgIGZ1bmN0aW9uIHVuZXhwZWN0ZWRUb2tlbkVycm9yKHRva2VuLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciBtc2cgPSBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW47XG5cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBtc2cgPSBtZXNzYWdlID8gbWVzc2FnZSA6XG4gICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IFRva2VuLkVPRikgPyBNZXNzYWdlcy5VbmV4cGVjdGVkRU9TIDpcbiAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikgPyBNZXNzYWdlcy5VbmV4cGVjdGVkSWRlbnRpZmllciA6XG4gICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSA/IE1lc3NhZ2VzLlVuZXhwZWN0ZWROdW1iZXIgOlxuICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSA/IE1lc3NhZ2VzLlVuZXhwZWN0ZWRTdHJpbmcgOlxuICAgICAgICAgICAgICAgIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbjtcblxuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNGdXR1cmVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IE1lc3NhZ2VzLlVuZXhwZWN0ZWRSZXNlcnZlZDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtc2cgPSBtc2cucmVwbGFjZSgnJTAnLCB0b2tlbiA/IHRva2VuLnZhbHVlIDogJ0lMTEVHQUwnKTtcblxuICAgICAgICByZXR1cm4gKHRva2VuICYmIHR5cGVvZiB0b2tlbi5saW5lTnVtYmVyID09PSAnbnVtYmVyJykgP1xuICAgICAgICAgICAgY3JlYXRlRXJyb3IodG9rZW4ubGluZU51bWJlciwgdG9rZW4uc3RhcnQsIG1zZykgOlxuICAgICAgICAgICAgY3JlYXRlRXJyb3IobGluZU51bWJlciwgaW5kZXgsIG1zZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgdW5leHBlY3RlZFRva2VuRXJyb3IodG9rZW4sIG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHVuZXhwZWN0ZWRUb2tlbkVycm9yKHRva2VuLCBtZXNzYWdlKTtcbiAgICAgICAgaWYgKGV4dHJhLmVycm9ycykge1xuICAgICAgICAgICAgZXh0cmEuZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuICAgIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuXG4gICAgZnVuY3Rpb24gZXhwZWN0KHZhbHVlKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxleCgpO1xuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvciB8fCB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGV4cGVjdENvbW1hU2VwYXJhdG9yXG4gICAgICogQGRlc2NyaXB0aW9uIFF1aWV0bHkgZXhwZWN0IGEgY29tbWEgd2hlbiBpbiB0b2xlcmFudCBtb2RlLCBvdGhlcndpc2UgZGVsZWdhdGVzXG4gICAgICogdG8gPGNvZGU+ZXhwZWN0KHZhbHVlKTwvY29kZT5cbiAgICAgKiBAc2luY2UgMi4wXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXhwZWN0Q29tbWFTZXBhcmF0b3IoKSB7XG4gICAgICAgIHZhciB0b2tlbjtcblxuICAgICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnZhbHVlID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvciAmJiB0b2tlbi52YWx1ZSA9PT0gJzsnKSB7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQga2V5d29yZC5cbiAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblxuICAgIGZ1bmN0aW9uIGV4cGVjdEtleXdvcmQoa2V5d29yZCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLktleXdvcmQgfHwgdG9rZW4udmFsdWUgIT09IGtleXdvcmQpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuXG4gICAgZnVuY3Rpb24gbWF0Y2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleXdvcmRcblxuICAgIGZ1bmN0aW9uIG1hdGNoS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uS2V5d29yZCAmJiBsb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gaXMgYW4gYXNzaWdubWVudCBvcGVyYXRvclxuXG4gICAgZnVuY3Rpb24gbWF0Y2hBc3NpZ24oKSB7XG4gICAgICAgIHZhciBvcDtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBvcCA9IGxvb2thaGVhZC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG9wID09PSAnPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnKj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJy89JyB8fFxuICAgICAgICAgICAgb3AgPT09ICclPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnKz0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJy09JyB8fFxuICAgICAgICAgICAgb3AgPT09ICc8PD0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJz4+PScgfHxcbiAgICAgICAgICAgIG9wID09PSAnPj4+PScgfHxcbiAgICAgICAgICAgIG9wID09PSAnJj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJ149JyB8fFxuICAgICAgICAgICAgb3AgPT09ICd8PSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uc3VtZVNlbWljb2xvbigpIHtcbiAgICAgICAgdmFyIGxpbmUsIG9sZEluZGV4ID0gaW5kZXgsIG9sZExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgb2xkTGluZVN0YXJ0ID0gbGluZVN0YXJ0LCBvbGRMb29rYWhlYWQgPSBsb29rYWhlYWQ7XG5cbiAgICAgICAgLy8gQ2F0Y2ggdGhlIHZlcnkgY29tbW9uIGNhc2UgZmlyc3Q6IGltbWVkaWF0ZWx5IGEgc2VtaWNvbG9uIChVKzAwM0IpLlxuICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDNCIHx8IG1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICAgIGlmIChsaW5lTnVtYmVyICE9PSBsaW5lKSB7XG4gICAgICAgICAgICBpbmRleCA9IG9sZEluZGV4O1xuICAgICAgICAgICAgbGluZU51bWJlciA9IG9sZExpbmVOdW1iZXI7XG4gICAgICAgICAgICBsaW5lU3RhcnQgPSBvbGRMaW5lU3RhcnQ7XG4gICAgICAgICAgICBsb29rYWhlYWQgPSBvbGRMb29rYWhlYWQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRiAmJiAhbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiB0cnVlIGlmIHByb3ZpZGVkIGV4cHJlc3Npb24gaXMgTGVmdEhhbmRTaWRlRXhwcmVzc2lvblxuXG4gICAgZnVuY3Rpb24gaXNMZWZ0SGFuZFNpZGUoZXhwcikge1xuICAgICAgICByZXR1cm4gZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllciB8fCBleHByLnR5cGUgPT09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xuICAgIH1cblxuICAgIC8vIDExLjEuNCBBcnJheSBJbml0aWFsaXNlclxuXG4gICAgZnVuY3Rpb24gcGFyc2VBcnJheUluaXRpYWxpc2VyKCkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXSwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgZXhwZWN0KCdbJyk7XG5cbiAgICAgICAgd2hpbGUgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpKTtcblxuICAgICAgICAgICAgICAgIGlmICghbWF0Y2goJ10nKSkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXgoKTtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hBcnJheUV4cHJlc3Npb24oZWxlbWVudHMpO1xuICAgIH1cblxuICAgIC8vIDExLjEuNSBPYmplY3QgSW5pdGlhbGlzZXJcblxuICAgIGZ1bmN0aW9uIHBhcnNlUHJvcGVydHlGdW5jdGlvbihwYXJhbSwgZmlyc3QpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0LCBib2R5LCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgYm9keSA9IHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xuICAgICAgICBpZiAoZmlyc3QgJiYgc3RyaWN0ICYmIGlzUmVzdHJpY3RlZFdvcmQocGFyYW1bMF0ubmFtZSkpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGZpcnN0LCBNZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hGdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgcGFyYW0sIFtdLCBib2R5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcmV2aW91c1N0cmljdCwgcGFyYW0sIG1ldGhvZDtcblxuICAgICAgICBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgcGFyYW0gPSBwYXJzZVBhcmFtcygpO1xuICAgICAgICBtZXRob2QgPSBwYXJzZVByb3BlcnR5RnVuY3Rpb24ocGFyYW0ucGFyYW1zKTtcbiAgICAgICAgc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIG1ldGhvZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCkge1xuICAgICAgICB2YXIgdG9rZW4sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIHRva2VuID0gbGV4KCk7XG5cbiAgICAgICAgLy8gTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBmcm9tIHBhcnNlT2JqZWN0UHJvcGVydHkoKSwgd2hlcmVcbiAgICAgICAgLy8gRU9GIGFuZCBQdW5jdHVhdG9yIHRva2VucyBhcmUgYWxyZWFkeSBmaWx0ZXJlZCBvdXQuXG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW4uTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgdG9rZW4ub2N0YWwpIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaExpdGVyYWwodG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSWRlbnRpZmllcih0b2tlbi52YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPYmplY3RQcm9wZXJ0eSgpIHtcbiAgICAgICAgdmFyIHRva2VuLCBrZXksIGlkLCB2YWx1ZSwgcGFyYW0sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG5cbiAgICAgICAgICAgIGlkID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eSBBc3NpZ25tZW50OiBHZXR0ZXIgYW5kIFNldHRlci5cblxuICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnZ2V0JyAmJiAhKG1hdGNoKCc6JykgfHwgbWF0Y2goJygnKSkpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcoJyk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcpJyk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZVByb3BlcnR5RnVuY3Rpb24oW10pO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdnZXQnLCBrZXksIHZhbHVlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnc2V0JyAmJiAhKG1hdGNoKCc6JykgfHwgbWF0Y2goJygnKSkpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcoJyk7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KCcpJyk7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZVByb3BlcnR5RnVuY3Rpb24oW10pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtID0gWyBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpIF07XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnKScpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlUHJvcGVydHlGdW5jdGlvbihwYXJhbSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnc2V0Jywga2V5LCB2YWx1ZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaCgnOicpKSB7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoJ2luaXQnLCBpZCwgdmFsdWUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2goJygnKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VQcm9wZXJ0eU1ldGhvZEZ1bmN0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoJ2luaXQnLCBpZCwgdmFsdWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSBpZDtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdpbml0JywgaWQsIHZhbHVlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLkVPRiB8fCB0b2tlbi50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgICBpZiAobWF0Y2goJzonKSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdpbml0Jywga2V5LCB2YWx1ZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnaW5pdCcsIGtleSwgdmFsdWUsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKGxleCgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0SW5pdGlhbGlzZXIoKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gW10sIHByb3BlcnR5LCBuYW1lLCBrZXksIGtpbmQsIG1hcCA9IHt9LCB0b1N0cmluZyA9IFN0cmluZywgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgZXhwZWN0KCd7Jyk7XG5cbiAgICAgICAgd2hpbGUgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlT2JqZWN0UHJvcGVydHkoKTtcblxuICAgICAgICAgICAgaWYgKHByb3BlcnR5LmtleS50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBwcm9wZXJ0eS5rZXkubmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IHRvU3RyaW5nKHByb3BlcnR5LmtleS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBraW5kID0gKHByb3BlcnR5LmtpbmQgPT09ICdpbml0JykgPyBQcm9wZXJ0eUtpbmQuRGF0YSA6IChwcm9wZXJ0eS5raW5kID09PSAnZ2V0JykgPyBQcm9wZXJ0eUtpbmQuR2V0IDogUHJvcGVydHlLaW5kLlNldDtcblxuICAgICAgICAgICAga2V5ID0gJyQnICsgbmFtZTtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcFtrZXldID09PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGtpbmQgPT09IFByb3BlcnR5S2luZC5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLlN0cmljdER1cGxpY2F0ZVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChraW5kICE9PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5BY2Nlc3NvckRhdGFQcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2luZCA9PT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuQWNjZXNzb3JEYXRhUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hcFtrZXldICYga2luZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5BY2Nlc3NvckdldFNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFwW2tleV0gfD0ga2luZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFwW2tleV0gPSBraW5kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuXG4gICAgICAgICAgICBpZiAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgICAgICBleHBlY3RDb21tYVNlcGFyYXRvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCd9Jyk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoT2JqZWN0RXhwcmVzc2lvbihwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICAvLyAxMS4xLjYgVGhlIEdyb3VwaW5nIE9wZXJhdG9yXG5cbiAgICBmdW5jdGlvbiBwYXJzZUdyb3VwRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHI7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgcmV0dXJuIFBsYWNlSG9sZGVycy5BcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgKytzdGF0ZS5wYXJlbnRoZXNpc0NvdW50O1xuXG4gICAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cblxuICAgIC8vIDExLjEgUHJpbWFyeSBFeHByZXNzaW9uc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIHR5cGUsIHRva2VuLCBleHByLCBub2RlO1xuXG4gICAgICAgIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VHcm91cEV4cHJlc3Npb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VBcnJheUluaXRpYWxpc2VyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJ3snKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlT2JqZWN0SW5pdGlhbGlzZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHR5cGUgPSBsb29rYWhlYWQudHlwZTtcbiAgICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaElkZW50aWZpZXIobGV4KCkudmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwgfHwgdHlwZSA9PT0gVG9rZW4uTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgbG9va2FoZWFkLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbChsZXgoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgndGhpcycpKSB7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoVGhpc0V4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obGV4KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLkJvb2xlYW5MaXRlcmFsKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgdG9rZW4udmFsdWUgPSAodG9rZW4udmFsdWUgPT09ICd0cnVlJyk7XG4gICAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hMaXRlcmFsKHRva2VuKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5OdWxsTGl0ZXJhbCkge1xuICAgICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICAgIHRva2VuLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwodG9rZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCcvJykgfHwgbWF0Y2goJy89JykpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwoY29sbGVjdFJlZ2V4KCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hMaXRlcmFsKHNjYW5SZWdFeHAoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZWVrKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihsZXgoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyAxMS4yIExlZnQtSGFuZC1TaWRlIEV4cHJlc3Npb25zXG5cbiAgICBmdW5jdGlvbiBwYXJzZUFyZ3VtZW50cygpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICBpZiAoIW1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCkpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3RDb21tYVNlcGFyYXRvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCkge1xuICAgICAgICB2YXIgdG9rZW4sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIHRva2VuID0gbGV4KCk7XG5cbiAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJOYW1lKHRva2VuKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSWRlbnRpZmllcih0b2tlbi52YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VOb25Db21wdXRlZE1lbWJlcigpIHtcbiAgICAgICAgZXhwZWN0KCcuJyk7XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ29tcHV0ZWRNZW1iZXIoKSB7XG4gICAgICAgIHZhciBleHByO1xuXG4gICAgICAgIGV4cGVjdCgnWycpO1xuXG4gICAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBleHBlY3QoJ10nKTtcblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU5ld0V4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBjYWxsZWUsIGFyZ3MsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ25ldycpO1xuICAgICAgICBjYWxsZWUgPSBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24oKTtcbiAgICAgICAgYXJncyA9IG1hdGNoKCcoJykgPyBwYXJzZUFyZ3VtZW50cygpIDogW107XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoTmV3RXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCgpIHtcbiAgICAgICAgdmFyIGV4cHIsIGFyZ3MsIHByb3BlcnR5LCBzdGFydFRva2VuLCBwcmV2aW91c0FsbG93SW4gPSBzdGF0ZS5hbGxvd0luO1xuXG4gICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgIHN0YXRlLmFsbG93SW4gPSB0cnVlO1xuICAgICAgICBleHByID0gbWF0Y2hLZXl3b3JkKCduZXcnKSA/IHBhcnNlTmV3RXhwcmVzc2lvbigpIDogcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnLicpKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignLicsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJygnKSkge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBwYXJzZUFyZ3VtZW50cygpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaENhbGxFeHByZXNzaW9uKGV4cHIsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZUNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignWycsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBleHByLCBwcm9wZXJ0eSwgc3RhcnRUb2tlbjtcbiAgICAgICAgYXNzZXJ0KHN0YXRlLmFsbG93SW4sICdjYWxsZWUgb2YgbmV3IGV4cHJlc3Npb24gYWx3YXlzIGFsbG93IGluIGtleXdvcmQuJyk7XG5cbiAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgICBleHByID0gbWF0Y2hLZXl3b3JkKCduZXcnKSA/IHBhcnNlTmV3RXhwcmVzc2lvbigpIDogcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZUNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignWycsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJy4nKSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VOb25Db21wdXRlZE1lbWJlcigpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaE1lbWJlckV4cHJlc3Npb24oJy4nLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjMgUG9zdGZpeCBFeHByZXNzaW9uc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIsIHRva2VuLCBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICAgIGV4cHIgPSBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKTtcblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICAgIGlmICgobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpICYmICFwZWVrTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgICAgICAgICAgIC8vIDExLjMuMSwgMTEuMy4yXG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBleHByLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIGlzUmVzdHJpY3RlZFdvcmQoZXhwci5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLlN0cmljdExIU1Bvc3RmaXgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaXNMZWZ0SGFuZFNpZGUoZXhwcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaFBvc3RmaXhFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjQgVW5hcnkgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIHRva2VuLCBleHByLCBzdGFydFRva2VuO1xuXG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvciAmJiBsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgICAgZXhwciA9IHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnKysnKSB8fCBtYXRjaCgnLS0nKSkge1xuICAgICAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICBleHByID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIC8vIDExLjQuNCwgMTEuNC41XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgaXNSZXN0cmljdGVkV29yZChleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5TdHJpY3RMSFNQcmVmaXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzTGVmdEhhbmRTaWRlKGV4cHIpKSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnKycpIHx8IG1hdGNoKCctJykgfHwgbWF0Y2goJ34nKSB8fCBtYXRjaCgnIScpKSB7XG4gICAgICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaEtleXdvcmQoJ2RlbGV0ZScpIHx8IG1hdGNoS2V5d29yZCgndm9pZCcpIHx8IG1hdGNoS2V5d29yZCgndHlwZW9mJykpIHtcbiAgICAgICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hVbmFyeUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBleHByLm9wZXJhdG9yID09PSAnZGVsZXRlJyAmJiBleHByLmFyZ3VtZW50LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5TdHJpY3REZWxldGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwciA9IHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpbmFyeVByZWNlZGVuY2UodG9rZW4sIGFsbG93SW4pIHtcbiAgICAgICAgdmFyIHByZWMgPSAwO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnR5cGUgIT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICBjYXNlICd8fCc6XG4gICAgICAgICAgICBwcmVjID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJyYmJzpcbiAgICAgICAgICAgIHByZWMgPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgICBwcmVjID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgICAgcHJlYyA9IDQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICAgIHByZWMgPSA1O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICBjYXNlICchPSc6XG4gICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICBwcmVjID0gNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgIGNhc2UgJ2luc3RhbmNlb2YnOlxuICAgICAgICAgICAgcHJlYyA9IDc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdpbic6XG4gICAgICAgICAgICBwcmVjID0gYWxsb3dJbiA/IDcgOiAwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnPDwnOlxuICAgICAgICBjYXNlICc+Pic6XG4gICAgICAgIGNhc2UgJz4+Pic6XG4gICAgICAgICAgICBwcmVjID0gODtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgIHByZWMgPSA5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgIGNhc2UgJy8nOlxuICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgIHByZWMgPSAxMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcmVjO1xuICAgIH1cblxuICAgIC8vIDExLjUgTXVsdGlwbGljYXRpdmUgT3BlcmF0b3JzXG4gICAgLy8gMTEuNiBBZGRpdGl2ZSBPcGVyYXRvcnNcbiAgICAvLyAxMS43IEJpdHdpc2UgU2hpZnQgT3BlcmF0b3JzXG4gICAgLy8gMTEuOCBSZWxhdGlvbmFsIE9wZXJhdG9yc1xuICAgIC8vIDExLjkgRXF1YWxpdHkgT3BlcmF0b3JzXG4gICAgLy8gMTEuMTAgQmluYXJ5IEJpdHdpc2UgT3BlcmF0b3JzXG4gICAgLy8gMTEuMTEgQmluYXJ5IExvZ2ljYWwgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZUJpbmFyeUV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBtYXJrZXIsIG1hcmtlcnMsIGV4cHIsIHRva2VuLCBwcmVjLCBzdGFjaywgcmlnaHQsIG9wZXJhdG9yLCBsZWZ0LCBpO1xuXG4gICAgICAgIG1hcmtlciA9IGxvb2thaGVhZDtcbiAgICAgICAgbGVmdCA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG4gICAgICAgIGlmIChsZWZ0ID09PSBQbGFjZUhvbGRlcnMuQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgcHJlYyA9IGJpbmFyeVByZWNlZGVuY2UodG9rZW4sIHN0YXRlLmFsbG93SW4pO1xuICAgICAgICBpZiAocHJlYyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4ucHJlYyA9IHByZWM7XG4gICAgICAgIGxleCgpO1xuXG4gICAgICAgIG1hcmtlcnMgPSBbbWFya2VyLCBsb29rYWhlYWRdO1xuICAgICAgICByaWdodCA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgc3RhY2sgPSBbbGVmdCwgdG9rZW4sIHJpZ2h0XTtcblxuICAgICAgICB3aGlsZSAoKHByZWMgPSBiaW5hcnlQcmVjZWRlbmNlKGxvb2thaGVhZCwgc3RhdGUuYWxsb3dJbikpID4gMCkge1xuXG4gICAgICAgICAgICAvLyBSZWR1Y2U6IG1ha2UgYSBiaW5hcnkgZXhwcmVzc2lvbiBmcm9tIHRoZSB0aHJlZSB0b3Btb3N0IGVudHJpZXMuXG4gICAgICAgICAgICB3aGlsZSAoKHN0YWNrLmxlbmd0aCA+IDIpICYmIChwcmVjIDw9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdLnByZWMpKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBvcGVyYXRvciA9IHN0YWNrLnBvcCgpLnZhbHVlO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBtYXJrZXJzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKG1hcmtlcnNbbWFya2Vycy5sZW5ndGggLSAxXSkuZmluaXNoQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goZXhwcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNoaWZ0LlxuICAgICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICAgIHRva2VuLnByZWMgPSBwcmVjO1xuICAgICAgICAgICAgc3RhY2sucHVzaCh0b2tlbik7XG4gICAgICAgICAgICBtYXJrZXJzLnB1c2gobG9va2FoZWFkKTtcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChleHByKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsIHJlZHVjZSB0byBjbGVhbi11cCB0aGUgc3RhY2suXG4gICAgICAgIGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBleHByID0gc3RhY2tbaV07XG4gICAgICAgIG1hcmtlcnMucG9wKCk7XG4gICAgICAgIHdoaWxlIChpID4gMSkge1xuICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUobWFya2Vycy5wb3AoKSkuZmluaXNoQmluYXJ5RXhwcmVzc2lvbihzdGFja1tpIC0gMV0udmFsdWUsIHN0YWNrW2kgLSAyXSwgZXhwcik7XG4gICAgICAgICAgICBpIC09IDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cblxuICAgIC8vIDExLjEyIENvbmRpdGlvbmFsIE9wZXJhdG9yXG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIsIHByZXZpb3VzQWxsb3dJbiwgY29uc2VxdWVudCwgYWx0ZXJuYXRlLCBzdGFydFRva2VuO1xuXG4gICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgICAgZXhwciA9IHBhcnNlQmluYXJ5RXhwcmVzc2lvbigpO1xuICAgICAgICBpZiAoZXhwciA9PT0gUGxhY2VIb2xkZXJzLkFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCgnPycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG4gICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNlcXVlbnQgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuICAgICAgICAgICAgZXhwZWN0KCc6Jyk7XG4gICAgICAgICAgICBhbHRlcm5hdGUgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaENvbmRpdGlvbmFsRXhwcmVzc2lvbihleHByLCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gW0VTNl0gMTQuMiBBcnJvdyBGdW5jdGlvblxuXG4gICAgZnVuY3Rpb24gcGFyc2VDb25jaXNlQm9keSgpIHtcbiAgICAgICAgaWYgKG1hdGNoKCd7JykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlaW50ZXJwcmV0QXNDb3ZlckZvcm1hbHNMaXN0KGV4cHJlc3Npb25zKSB7XG4gICAgICAgIHZhciBpLCBsZW4sIHBhcmFtLCBwYXJhbXMsIGRlZmF1bHRzLCBkZWZhdWx0Q291bnQsIG9wdGlvbnMsIHJlc3QsIHRva2VuO1xuXG4gICAgICAgIHBhcmFtcyA9IFtdO1xuICAgICAgICBkZWZhdWx0cyA9IFtdO1xuICAgICAgICBkZWZhdWx0Q291bnQgPSAwO1xuICAgICAgICByZXN0ID0gbnVsbDtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHBhcmFtU2V0OiB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGV4cHJlc3Npb25zLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBwYXJhbSA9IGV4cHJlc3Npb25zW2ldO1xuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVQYXJhbShvcHRpb25zLCBwYXJhbSwgcGFyYW0ubmFtZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtLmxlZnQpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRzLnB1c2gocGFyYW0ucmlnaHQpO1xuICAgICAgICAgICAgICAgICsrZGVmYXVsdENvdW50O1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlUGFyYW0ob3B0aW9ucywgcGFyYW0ubGVmdCwgcGFyYW0ubGVmdC5uYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5tZXNzYWdlID09PSBNZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGUpIHtcbiAgICAgICAgICAgIHRva2VuID0gc3RyaWN0ID8gb3B0aW9ucy5zdHJpY3RlZCA6IG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkO1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG9wdGlvbnMubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmYXVsdENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBkZWZhdWx0cyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuICAgICAgICAgICAgcmVzdDogcmVzdCxcbiAgICAgICAgICAgIHN0cmljdGVkOiBvcHRpb25zLnN0cmljdGVkLFxuICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24ob3B0aW9ucywgbm9kZSkge1xuICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QsIGJvZHk7XG5cbiAgICAgICAgZXhwZWN0KCc9PicpO1xuICAgICAgICBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcblxuICAgICAgICBib2R5ID0gcGFyc2VDb25jaXNlQm9keSgpO1xuXG4gICAgICAgIGlmIChzdHJpY3QgJiYgb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZFRva2VuKG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkLCBvcHRpb25zLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpY3QgJiYgb3B0aW9ucy5zdHJpY3RlZCkge1xuICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4ob3B0aW9ucy5zdHJpY3RlZCwgb3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEFycm93RnVuY3Rpb25FeHByZXNzaW9uKG9wdGlvbnMucGFyYW1zLCBvcHRpb25zLmRlZmF1bHRzLCBib2R5LCBib2R5LnR5cGUgIT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCk7XG4gICAgfVxuXG4gICAgLy8gMTEuMTMgQXNzaWdubWVudCBPcGVyYXRvcnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBvbGRQYXJlbnRoZXNpc0NvdW50LCB0b2tlbiwgZXhwciwgcmlnaHQsIGxpc3QsIHN0YXJ0VG9rZW47XG5cbiAgICAgICAgb2xkUGFyZW50aGVzaXNDb3VudCA9IHN0YXRlLnBhcmVudGhlc2lzQ291bnQ7XG5cbiAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgICAgZXhwciA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgaWYgKGV4cHIgPT09IFBsYWNlSG9sZGVycy5BcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyIHx8IG1hdGNoKCc9PicpKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUucGFyZW50aGVzaXNDb3VudCA9PT0gb2xkUGFyZW50aGVzaXNDb3VudCB8fFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wYXJlbnRoZXNpc0NvdW50ID09PSAob2xkUGFyZW50aGVzaXNDb3VudCArIDEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IHJlaW50ZXJwcmV0QXNDb3ZlckZvcm1hbHNMaXN0KFsgZXhwciBdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QgPSByZWludGVycHJldEFzQ292ZXJGb3JtYWxzTGlzdChbIGV4cHIgXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHByLnR5cGUgPT09IFN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IHJlaW50ZXJwcmV0QXNDb3ZlckZvcm1hbHNMaXN0KGV4cHIuZXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwciA9PT0gUGxhY2VIb2xkZXJzLkFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IHJlaW50ZXJwcmV0QXNDb3ZlckZvcm1hbHNMaXN0KFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24obGlzdCwgbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoQXNzaWduKCkpIHtcbiAgICAgICAgICAgIC8vIExlZnRIYW5kU2lkZUV4cHJlc3Npb25cbiAgICAgICAgICAgIGlmICghaXNMZWZ0SGFuZFNpZGUoZXhwcikpIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZUVycm9yKE1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAxMS4xMy4xXG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgaXNSZXN0cmljdGVkV29yZChleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIE1lc3NhZ2VzLlN0cmljdExIU0Fzc2lnbm1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgICAgcmlnaHQgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hBc3NpZ25tZW50RXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwciwgcmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gMTEuMTQgQ29tbWEgT3BlcmF0b3JcblxuICAgIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIsIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQsIGV4cHJlc3Npb25zO1xuXG4gICAgICAgIGV4cHIgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb25zID0gW2V4cHJdO1xuXG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2gocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoU2VxdWVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDEyLjEgQmxvY2tcblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50TGlzdCgpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXSxcbiAgICAgICAgICAgIHN0YXRlbWVudDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdC5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUJsb2NrKCkge1xuICAgICAgICB2YXIgYmxvY2ssIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuXG4gICAgICAgIGJsb2NrID0gcGFyc2VTdGF0ZW1lbnRMaXN0KCk7XG5cbiAgICAgICAgZXhwZWN0KCd9Jyk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQmxvY2tTdGF0ZW1lbnQoYmxvY2spO1xuICAgIH1cblxuICAgIC8vIDEyLjIgVmFyaWFibGUgU3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpIHtcbiAgICAgICAgdmFyIHRva2VuLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICB0b2tlbiA9IGxleCgpO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIHRva2VuLnR5cGUgPT09IFRva2VuLktleXdvcmQgJiYgaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hJZGVudGlmaWVyKHRva2VuLnZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24oa2luZCkge1xuICAgICAgICB2YXIgaW5pdCA9IG51bGwsIGlkLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBpZCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgLy8gMTIuMi4xXG4gICAgICAgIGlmIChzdHJpY3QgJiYgaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xuICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5TdHJpY3RWYXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChraW5kID09PSAnY29uc3QnKSB7XG4gICAgICAgICAgICBleHBlY3QoJz0nKTtcbiAgICAgICAgICAgIGluaXQgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJz0nKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBpbml0ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoVmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KGtpbmQpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBsaXN0LnB1c2gocGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uKGtpbmQpKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgIH0gd2hpbGUgKGluZGV4IDwgbGVuZ3RoKTtcblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucztcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCd2YXInKTtcblxuICAgICAgICBkZWNsYXJhdGlvbnMgPSBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KCk7XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCAndmFyJyk7XG4gICAgfVxuXG4gICAgLy8ga2luZCBtYXkgYmUgYGNvbnN0YCBvciBgbGV0YFxuICAgIC8vIEJvdGggYXJlIGV4cGVyaW1lbnRhbCBhbmQgbm90IGluIHRoZSBzcGVjaWZpY2F0aW9uIHlldC5cbiAgICAvLyBzZWUgaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTpjb25zdFxuICAgIC8vIGFuZCBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmxldFxuICAgIGZ1bmN0aW9uIHBhcnNlQ29uc3RMZXREZWNsYXJhdGlvbihraW5kKSB7XG4gICAgICAgIHZhciBkZWNsYXJhdGlvbnMsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoa2luZCk7XG5cbiAgICAgICAgZGVjbGFyYXRpb25zID0gcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChraW5kKTtcblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpO1xuICAgIH1cblxuICAgIC8vIDEyLjMgRW1wdHkgU3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUVtcHR5U3RhdGVtZW50KCkge1xuICAgICAgICB2YXIgbm9kZSA9IG5ldyBOb2RlKCk7XG4gICAgICAgIGV4cGVjdCgnOycpO1xuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hFbXB0eVN0YXRlbWVudCgpO1xuICAgIH1cblxuICAgIC8vIDEyLjQgRXhwcmVzc2lvbiBTdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwcmVzc2lvblN0YXRlbWVudChleHByKTtcbiAgICB9XG5cbiAgICAvLyAxMi41IElmIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VJZlN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciB0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGU7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnaWYnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgY29uc2VxdWVudCA9IHBhcnNlU3RhdGVtZW50KCk7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZWxzZScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGFsdGVybmF0ZSA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbHRlcm5hdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSWZTdGF0ZW1lbnQodGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKTtcbiAgICB9XG5cbiAgICAvLyAxMi42IEl0ZXJhdGlvbiBTdGF0ZW1lbnRzXG5cbiAgICBmdW5jdGlvbiBwYXJzZURvV2hpbGVTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgYm9keSwgdGVzdCwgb2xkSW5JdGVyYXRpb247XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnZG8nKTtcblxuICAgICAgICBvbGRJbkl0ZXJhdGlvbiA9IHN0YXRlLmluSXRlcmF0aW9uO1xuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IHRydWU7XG5cbiAgICAgICAgYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG5cbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSBvbGRJbkl0ZXJhdGlvbjtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCd3aGlsZScpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIHRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBpZiAobWF0Y2goJzsnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hEb1doaWxlU3RhdGVtZW50KGJvZHksIHRlc3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgdGVzdCwgYm9keSwgb2xkSW5JdGVyYXRpb247XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnd2hpbGUnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgb2xkSW5JdGVyYXRpb24gPSBzdGF0ZS5pbkl0ZXJhdGlvbjtcbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSB0cnVlO1xuXG4gICAgICAgIGJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gb2xkSW5JdGVyYXRpb247XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoV2hpbGVTdGF0ZW1lbnQodGVzdCwgYm9keSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGb3JWYXJpYWJsZURlY2xhcmF0aW9uKCkge1xuICAgICAgICB2YXIgdG9rZW4sIGRlY2xhcmF0aW9ucywgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgZGVjbGFyYXRpb25zID0gcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCgpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCB0b2tlbi52YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGb3JTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgaW5pdCwgdGVzdCwgdXBkYXRlLCBsZWZ0LCByaWdodCwgYm9keSwgb2xkSW5JdGVyYXRpb24sIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG5cbiAgICAgICAgaW5pdCA9IHRlc3QgPSB1cGRhdGUgPSBudWxsO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2ZvcicpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnOycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ3ZhcicpIHx8IG1hdGNoS2V5d29yZCgnbGV0JykpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaW5pdCA9IHBhcnNlRm9yVmFyaWFibGVEZWNsYXJhdGlvbigpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5pdC5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIG1hdGNoS2V5d29yZCgnaW4nKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGluaXQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnaW4nKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBMZWZ0SGFuZFNpZGVFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNMZWZ0SGFuZFNpZGUoaW5pdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuSW52YWxpZExIU0luRm9ySW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoJzsnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaCgnOycpKSB7XG4gICAgICAgICAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwZWN0KCc7Jyk7XG5cbiAgICAgICAgICAgIGlmICghbWF0Y2goJyknKSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgb2xkSW5JdGVyYXRpb24gPSBzdGF0ZS5pbkl0ZXJhdGlvbjtcbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSB0cnVlO1xuXG4gICAgICAgIGJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gb2xkSW5JdGVyYXRpb247XG5cbiAgICAgICAgcmV0dXJuICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpID9cbiAgICAgICAgICAgICAgICBub2RlLmZpbmlzaEZvclN0YXRlbWVudChpbml0LCB0ZXN0LCB1cGRhdGUsIGJvZHkpIDpcbiAgICAgICAgICAgICAgICBub2RlLmZpbmlzaEZvckluU3RhdGVtZW50KGxlZnQsIHJpZ2h0LCBib2R5KTtcbiAgICB9XG5cbiAgICAvLyAxMi43IFRoZSBjb250aW51ZSBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlQ29udGludWVTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgbGFiZWwgPSBudWxsLCBrZXk7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnY29udGludWUnKTtcblxuICAgICAgICAvLyBPcHRpbWl6ZSB0aGUgbW9zdCBjb21tb24gZm9ybTogJ2NvbnRpbnVlOycuXG4gICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4M0IpIHtcbiAgICAgICAgICAgIGxleCgpO1xuXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmluSXRlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5JbGxlZ2FsQ29udGludWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hDb250aW51ZVN0YXRlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwZWVrTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pbkl0ZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQ29udGludWVTdGF0ZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGxhYmVsID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcblxuICAgICAgICAgICAga2V5ID0gJyQnICsgbGFiZWwubmFtZTtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLmxhYmVsU2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5Vbmtub3duTGFiZWwsIGxhYmVsLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIGlmIChsYWJlbCA9PT0gbnVsbCAmJiAhc3RhdGUuaW5JdGVyYXRpb24pIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaENvbnRpbnVlU3RhdGVtZW50KGxhYmVsKTtcbiAgICB9XG5cbiAgICAvLyAxMi44IFRoZSBicmVhayBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlQnJlYWtTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgbGFiZWwgPSBudWxsLCBrZXk7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnYnJlYWsnKTtcblxuICAgICAgICAvLyBDYXRjaCB0aGUgdmVyeSBjb21tb24gY2FzZSBmaXJzdDogaW1tZWRpYXRlbHkgYSBzZW1pY29sb24gKFUrMDAzQikuXG4gICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4M0IpIHtcbiAgICAgICAgICAgIGxleCgpO1xuXG4gICAgICAgICAgICBpZiAoIShzdGF0ZS5pbkl0ZXJhdGlvbiB8fCBzdGF0ZS5pblN3aXRjaCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLklsbGVnYWxCcmVhayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaEJyZWFrU3RhdGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBlZWtMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICAgICAgICBpZiAoIShzdGF0ZS5pbkl0ZXJhdGlvbiB8fCBzdGF0ZS5pblN3aXRjaCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLklsbGVnYWxCcmVhayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaEJyZWFrU3RhdGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBsYWJlbCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgICAgIGtleSA9ICckJyArIGxhYmVsLm5hbWU7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS5sYWJlbFNldCwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuVW5rbm93bkxhYmVsLCBsYWJlbC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICBpZiAobGFiZWwgPT09IG51bGwgJiYgIShzdGF0ZS5pbkl0ZXJhdGlvbiB8fCBzdGF0ZS5pblN3aXRjaCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuSWxsZWdhbEJyZWFrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEJyZWFrU3RhdGVtZW50KGxhYmVsKTtcbiAgICB9XG5cbiAgICAvLyAxMi45IFRoZSByZXR1cm4gc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVJldHVyblN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBhcmd1bWVudCA9IG51bGw7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgncmV0dXJuJyk7XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5pbkZ1bmN0aW9uQm9keSkge1xuICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5JbGxlZ2FsUmV0dXJuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICdyZXR1cm4nIGZvbGxvd2VkIGJ5IGEgc3BhY2UgYW5kIGFuIGlkZW50aWZpZXIgaXMgdmVyeSBjb21tb24uXG4gICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4MjApIHtcbiAgICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpKSkge1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFJldHVyblN0YXRlbWVudChhcmd1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGVla0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFJldHVyblN0YXRlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWF0Y2goJzsnKSkge1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnfScpICYmIGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgICAgICBhcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFJldHVyblN0YXRlbWVudChhcmd1bWVudCk7XG4gICAgfVxuXG4gICAgLy8gMTIuMTAgVGhlIHdpdGggc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgb2JqZWN0LCBib2R5O1xuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIC8vIFRPRE8oaWthcmllbmF0b3IpOiBTaG91bGQgd2UgdXBkYXRlIHRoZSB0ZXN0IGNhc2VzIGluc3RlYWQ/XG4gICAgICAgICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgICAgICAgdG9sZXJhdGVFcnJvcihNZXNzYWdlcy5TdHJpY3RNb2RlV2l0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3RLZXl3b3JkKCd3aXRoJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgb2JqZWN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoV2l0aFN0YXRlbWVudChvYmplY3QsIGJvZHkpO1xuICAgIH1cblxuICAgIC8vIDEyLjEwIFRoZSBzd2l0aCBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlU3dpdGNoQ2FzZSgpIHtcbiAgICAgICAgdmFyIHRlc3QsIGNvbnNlcXVlbnQgPSBbXSwgc3RhdGVtZW50LCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgdGVzdCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHBlY3RLZXl3b3JkKCdjYXNlJyk7XG4gICAgICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwZWN0KCc6Jyk7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ30nKSB8fCBtYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSB8fCBtYXRjaEtleXdvcmQoJ2Nhc2UnKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGVtZW50ID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNvbnNlcXVlbnQucHVzaChzdGF0ZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoU3dpdGNoQ2FzZSh0ZXN0LCBjb25zZXF1ZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVN3aXRjaFN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHZhciBkaXNjcmltaW5hbnQsIGNhc2VzLCBjbGF1c2UsIG9sZEluU3dpdGNoLCBkZWZhdWx0Rm91bmQ7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnc3dpdGNoJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgZGlzY3JpbWluYW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgZXhwZWN0KCd7Jyk7XG5cbiAgICAgICAgY2FzZXMgPSBbXTtcblxuICAgICAgICBpZiAobWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hTd2l0Y2hTdGF0ZW1lbnQoZGlzY3JpbWluYW50LCBjYXNlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBvbGRJblN3aXRjaCA9IHN0YXRlLmluU3dpdGNoO1xuICAgICAgICBzdGF0ZS5pblN3aXRjaCA9IHRydWU7XG4gICAgICAgIGRlZmF1bHRGb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsYXVzZSA9IHBhcnNlU3dpdGNoQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGNsYXVzZS50ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLk11bHRpcGxlRGVmYXVsdHNJblN3aXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlcy5wdXNoKGNsYXVzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5pblN3aXRjaCA9IG9sZEluU3dpdGNoO1xuXG4gICAgICAgIGV4cGVjdCgnfScpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFN3aXRjaFN0YXRlbWVudChkaXNjcmltaW5hbnQsIGNhc2VzKTtcbiAgICB9XG5cbiAgICAvLyAxMi4xMyBUaGUgdGhyb3cgc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVRocm93U3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50O1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3Rocm93Jyk7XG5cbiAgICAgICAgaWYgKHBlZWtMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKE1lc3NhZ2VzLk5ld2xpbmVBZnRlclRocm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ3VtZW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaFRocm93U3RhdGVtZW50KGFyZ3VtZW50KTtcbiAgICB9XG5cbiAgICAvLyAxMi4xNCBUaGUgdHJ5IHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VDYXRjaENsYXVzZSgpIHtcbiAgICAgICAgdmFyIHBhcmFtLCBib2R5LCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdjYXRjaCcpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuICAgICAgICBpZiAobWF0Y2goJyknKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgLy8gMTIuMTQuMVxuICAgICAgICBpZiAoc3RyaWN0ICYmIGlzUmVzdHJpY3RlZFdvcmQocGFyYW0ubmFtZSkpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlRXJyb3IoTWVzc2FnZXMuU3RyaWN0Q2F0Y2hWYXJpYWJsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJyknKTtcbiAgICAgICAgYm9keSA9IHBhcnNlQmxvY2soKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQ2F0Y2hDbGF1c2UocGFyYW0sIGJvZHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGJsb2NrLCBoYW5kbGVycyA9IFtdLCBmaW5hbGl6ZXIgPSBudWxsO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3RyeScpO1xuXG4gICAgICAgIGJsb2NrID0gcGFyc2VCbG9jaygpO1xuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2NhdGNoJykpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gocGFyc2VDYXRjaENsYXVzZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2ZpbmFsbHknKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBmaW5hbGl6ZXIgPSBwYXJzZUJsb2NrKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFuZGxlcnMubGVuZ3RoID09PSAwICYmICFmaW5hbGl6ZXIpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoTWVzc2FnZXMuTm9DYXRjaE9yRmluYWxseSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hUcnlTdGF0ZW1lbnQoYmxvY2ssIFtdLCBoYW5kbGVycywgZmluYWxpemVyKTtcbiAgICB9XG5cbiAgICAvLyAxMi4xNSBUaGUgZGVidWdnZXIgc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZURlYnVnZ2VyU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgZXhwZWN0S2V5d29yZCgnZGVidWdnZXInKTtcblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRGVidWdnZXJTdGF0ZW1lbnQoKTtcbiAgICB9XG5cbiAgICAvLyAxMiBTdGF0ZW1lbnRzXG5cbiAgICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBsb29rYWhlYWQudHlwZSxcbiAgICAgICAgICAgIGV4cHIsXG4gICAgICAgICAgICBsYWJlbGVkQm9keSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIG5vZGU7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkVG9rZW4obG9va2FoZWFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gJ3snKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VCbG9jaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobG9va2FoZWFkLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICc7JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VFbXB0eVN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobG9va2FoZWFkLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdicmVhayc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQnJlYWtTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICdjb250aW51ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQ29udGludWVTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICdkZWJ1Z2dlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICdkbyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRG9XaGlsZVN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ2Zvcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRm9yU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgICAgICBjYXNlICdpZic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSWZTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICdyZXR1cm4nOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVJldHVyblN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ3N3aXRjaCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAndGhyb3cnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVRocm93U3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAndHJ5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUcnlTdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgICBjYXNlICd2YXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVZhcmlhYmxlU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnd2hpbGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVdoaWxlU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnd2l0aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlV2l0aFN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgLy8gMTIuMTIgTGFiZWxsZWQgU3RhdGVtZW50c1xuICAgICAgICBpZiAoKGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpICYmIG1hdGNoKCc6JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuXG4gICAgICAgICAgICBrZXkgPSAnJCcgKyBleHByLm5hbWU7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLmxhYmVsU2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihNZXNzYWdlcy5SZWRlY2xhcmF0aW9uLCAnTGFiZWwnLCBleHByLm5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5sYWJlbFNldFtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIGxhYmVsZWRCb2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5sYWJlbFNldFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoTGFiZWxlZFN0YXRlbWVudChleHByLCBsYWJlbGVkQm9keSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwcmVzc2lvblN0YXRlbWVudChleHByKTtcbiAgICB9XG5cbiAgICAvLyAxMyBGdW5jdGlvbiBEZWZpbml0aW9uXG5cbiAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKSB7XG4gICAgICAgIHZhciBzb3VyY2VFbGVtZW50LCBzb3VyY2VFbGVtZW50cyA9IFtdLCB0b2tlbiwgZGlyZWN0aXZlLCBmaXJzdFJlc3RyaWN0ZWQsXG4gICAgICAgICAgICBvbGRMYWJlbFNldCwgb2xkSW5JdGVyYXRpb24sIG9sZEluU3dpdGNoLCBvbGRJbkZ1bmN0aW9uQm9keSwgb2xkUGFyZW50aGVzaXNDb3VudCxcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICAgIGV4cGVjdCgneycpO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgICAgICAgc291cmNlRWxlbWVudCA9IHBhcnNlU291cmNlRWxlbWVudCgpO1xuICAgICAgICAgICAgc291cmNlRWxlbWVudHMucHVzaChzb3VyY2VFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VFbGVtZW50LmV4cHJlc3Npb24udHlwZSAhPT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBkaXJlY3RpdmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpcmVjdGl2ZSA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCArIDEsIHRva2VuLmVuZCAtIDEpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZSA9PT0gJ3VzZSBzdHJpY3QnKSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGZpcnN0UmVzdHJpY3RlZCwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZmlyc3RSZXN0cmljdGVkICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9sZExhYmVsU2V0ID0gc3RhdGUubGFiZWxTZXQ7XG4gICAgICAgIG9sZEluSXRlcmF0aW9uID0gc3RhdGUuaW5JdGVyYXRpb247XG4gICAgICAgIG9sZEluU3dpdGNoID0gc3RhdGUuaW5Td2l0Y2g7XG4gICAgICAgIG9sZEluRnVuY3Rpb25Cb2R5ID0gc3RhdGUuaW5GdW5jdGlvbkJvZHk7XG4gICAgICAgIG9sZFBhcmVudGhlc2lzQ291bnQgPSBzdGF0ZS5wYXJlbnRoZXNpemVkQ291bnQ7XG5cbiAgICAgICAgc3RhdGUubGFiZWxTZXQgPSB7fTtcbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuaW5Td2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuaW5GdW5jdGlvbkJvZHkgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5wYXJlbnRoZXNpemVkQ291bnQgPSAwO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZUVsZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZUVsZW1lbnRzLnB1c2goc291cmNlRWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICBzdGF0ZS5sYWJlbFNldCA9IG9sZExhYmVsU2V0O1xuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IG9sZEluSXRlcmF0aW9uO1xuICAgICAgICBzdGF0ZS5pblN3aXRjaCA9IG9sZEluU3dpdGNoO1xuICAgICAgICBzdGF0ZS5pbkZ1bmN0aW9uQm9keSA9IG9sZEluRnVuY3Rpb25Cb2R5O1xuICAgICAgICBzdGF0ZS5wYXJlbnRoZXNpemVkQ291bnQgPSBvbGRQYXJlbnRoZXNpc0NvdW50O1xuXG4gICAgICAgIHJldHVybiBub2RlLmZpbmlzaEJsb2NrU3RhdGVtZW50KHNvdXJjZUVsZW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVBhcmFtKG9wdGlvbnMsIHBhcmFtLCBuYW1lKSB7XG4gICAgICAgIHZhciBrZXkgPSAnJCcgKyBuYW1lO1xuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZChuYW1lKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RyaWN0ZWQgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMucGFyYW1TZXQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0cmljdGVkID0gcGFyYW07XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtTmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLnBhcmFtU2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQgPSBwYXJhbTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5wYXJhbVNldFtrZXldID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVBhcmFtKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRva2VuLCBwYXJhbSwgZGVmO1xuXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICBwYXJhbSA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgIHZhbGlkYXRlUGFyYW0ob3B0aW9ucywgdG9rZW4sIHRva2VuLnZhbHVlKTtcbiAgICAgICAgaWYgKG1hdGNoKCc9JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgZGVmID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgKytvcHRpb25zLmRlZmF1bHRDb3VudDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMucGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgICBvcHRpb25zLmRlZmF1bHRzLnB1c2goZGVmKTtcblxuICAgICAgICByZXR1cm4gIW1hdGNoKCcpJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQYXJhbXMoZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgIHZhciBvcHRpb25zO1xuXG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICAgICAgZGVmYXVsdENvdW50OiAwLFxuICAgICAgICAgICAgZGVmYXVsdHM6IFtdLFxuICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBmaXJzdFJlc3RyaWN0ZWRcbiAgICAgICAgfTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICBpZiAoIW1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucGFyYW1TZXQgPSB7fTtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VQYXJhbShvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdHMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXJhbXM6IG9wdGlvbnMucGFyYW1zLFxuICAgICAgICAgICAgZGVmYXVsdHM6IG9wdGlvbnMuZGVmYXVsdHMsXG4gICAgICAgICAgICBzdHJpY3RlZDogb3B0aW9ucy5zdHJpY3RlZCxcbiAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZDogb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQsXG4gICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKSB7XG4gICAgICAgIHZhciBpZCwgcGFyYW1zID0gW10sIGRlZmF1bHRzID0gW10sIGJvZHksIHRva2VuLCBzdHJpY3RlZCwgdG1wLCBmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2UsIHByZXZpb3VzU3RyaWN0LCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdmdW5jdGlvbicpO1xuICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgaWQgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdG1wID0gcGFyc2VQYXJhbXMoZmlyc3RSZXN0cmljdGVkKTtcbiAgICAgICAgcGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICAgICAgZGVmYXVsdHMgPSB0bXAuZGVmYXVsdHM7XG4gICAgICAgIHN0cmljdGVkID0gdG1wLnN0cmljdGVkO1xuICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0bXAuZmlyc3RSZXN0cmljdGVkO1xuICAgICAgICBpZiAodG1wLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0bXAubWVzc2FnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzU3RyaWN0ID0gc3RyaWN0O1xuICAgICAgICBib2R5ID0gcGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpY3QgJiYgc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHN0cmljdGVkLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hGdW5jdGlvbkRlY2xhcmF0aW9uKGlkLCBwYXJhbXMsIGRlZmF1bHRzLCBib2R5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIHRva2VuLCBpZCA9IG51bGwsIHN0cmljdGVkLCBmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2UsIHRtcCxcbiAgICAgICAgICAgIHBhcmFtcyA9IFtdLCBkZWZhdWx0cyA9IFtdLCBib2R5LCBwcmV2aW91c1N0cmljdCwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnZnVuY3Rpb24nKTtcblxuICAgICAgICBpZiAoIW1hdGNoKCcoJykpIHtcbiAgICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgICAgaWQgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdG1wID0gcGFyc2VQYXJhbXMoZmlyc3RSZXN0cmljdGVkKTtcbiAgICAgICAgcGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICAgICAgZGVmYXVsdHMgPSB0bXAuZGVmYXVsdHM7XG4gICAgICAgIHN0cmljdGVkID0gdG1wLnN0cmljdGVkO1xuICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0bXAuZmlyc3RSZXN0cmljdGVkO1xuICAgICAgICBpZiAodG1wLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0bXAubWVzc2FnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzU3RyaWN0ID0gc3RyaWN0O1xuICAgICAgICBib2R5ID0gcGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWRUb2tlbihmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpY3QgJiYgc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHN0cmljdGVkLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcblxuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hGdW5jdGlvbkV4cHJlc3Npb24oaWQsIHBhcmFtcywgZGVmYXVsdHMsIGJvZHkpO1xuICAgIH1cblxuICAgIC8vIDE0IFByb2dyYW1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU291cmNlRWxlbWVudCgpIHtcbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnY29uc3QnOlxuICAgICAgICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VDb25zdExldERlY2xhcmF0aW9uKGxvb2thaGVhZC52YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU291cmNlRWxlbWVudHMoKSB7XG4gICAgICAgIHZhciBzb3VyY2VFbGVtZW50LCBzb3VyY2VFbGVtZW50cyA9IFtdLCB0b2tlbiwgZGlyZWN0aXZlLCBmaXJzdFJlc3RyaWN0ZWQ7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNvdXJjZUVsZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIHNvdXJjZUVsZW1lbnRzLnB1c2goc291cmNlRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoc291cmNlRWxlbWVudC5leHByZXNzaW9uLnR5cGUgIT09IFN5bnRheC5MaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgZGlyZWN0aXZlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXJlY3RpdmUgPSBzb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQgKyAxLCB0b2tlbi5lbmQgLSAxKTtcbiAgICAgICAgICAgIGlmIChkaXJlY3RpdmUgPT09ICd1c2Ugc3RyaWN0Jykge1xuICAgICAgICAgICAgICAgIHN0cmljdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihmaXJzdFJlc3RyaWN0ZWQsIE1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0UmVzdHJpY3RlZCAmJiB0b2tlbi5vY3RhbCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHNvdXJjZUVsZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VFbGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlRWxlbWVudHMucHVzaChzb3VyY2VFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlRWxlbWVudHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQcm9ncmFtKCkge1xuICAgICAgICB2YXIgYm9keSwgbm9kZTtcblxuICAgICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgICBwZWVrKCk7XG4gICAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuICAgICAgICBzdHJpY3QgPSBmYWxzZTtcblxuICAgICAgICBib2R5ID0gcGFyc2VTb3VyY2VFbGVtZW50cygpO1xuICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9ncmFtKGJvZHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbHRlclRva2VuTG9jYXRpb24oKSB7XG4gICAgICAgIHZhciBpLCBlbnRyeSwgdG9rZW4sIHRva2VucyA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBleHRyYS50b2tlbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gZXh0cmEudG9rZW5zW2ldO1xuICAgICAgICAgICAgdG9rZW4gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogZW50cnkudHlwZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZW50cnkudmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZW50cnkucmVnZXgpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi5yZWdleCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogZW50cnkucmVnZXgucGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IGVudHJ5LnJlZ2V4LmZsYWdzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgICAgIHRva2VuLnJhbmdlID0gZW50cnkucmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4ubG9jID0gZW50cnkubG9jO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgZXh0cmEudG9rZW5zID0gdG9rZW5zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuaXplKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRvU3RyaW5nLFxuICAgICAgICAgICAgdG9rZW5zO1xuXG4gICAgICAgIHRvU3RyaW5nID0gU3RyaW5nO1xuICAgICAgICBpZiAodHlwZW9mIGNvZGUgIT09ICdzdHJpbmcnICYmICEoY29kZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICAgICAgICAgIGNvZGUgPSB0b1N0cmluZyhjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNvdXJjZSA9IGNvZGU7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgbGluZU51bWJlciA9IChzb3VyY2UubGVuZ3RoID4gMCkgPyAxIDogMDtcbiAgICAgICAgbGluZVN0YXJ0ID0gMDtcbiAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgbG9va2FoZWFkID0gbnVsbDtcbiAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgbGFiZWxTZXQ6IHt9LFxuICAgICAgICAgICAgaW5GdW5jdGlvbkJvZHk6IGZhbHNlLFxuICAgICAgICAgICAgaW5JdGVyYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgaW5Td2l0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgbGFzdENvbW1lbnRTdGFydDogLTFcbiAgICAgICAgfTtcblxuICAgICAgICBleHRyYSA9IHt9O1xuXG4gICAgICAgIC8vIE9wdGlvbnMgbWF0Y2hpbmcuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8vIE9mIGNvdXJzZSB3ZSBjb2xsZWN0IHRva2VucyBoZXJlLlxuICAgICAgICBvcHRpb25zLnRva2VucyA9IHRydWU7XG4gICAgICAgIGV4dHJhLnRva2VucyA9IFtdO1xuICAgICAgICBleHRyYS50b2tlbml6ZSA9IHRydWU7XG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgdHdvIGZpZWxkcyBhcmUgbmVjZXNzYXJ5IHRvIGNvbXB1dGUgdGhlIFJlZ2V4IHRva2Vucy5cbiAgICAgICAgZXh0cmEub3BlblBhcmVuVG9rZW4gPSAtMTtcbiAgICAgICAgZXh0cmEub3BlbkN1cmx5VG9rZW4gPSAtMTtcblxuICAgICAgICBleHRyYS5yYW5nZSA9ICh0eXBlb2Ygb3B0aW9ucy5yYW5nZSA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnJhbmdlO1xuICAgICAgICBleHRyYS5sb2MgPSAodHlwZW9mIG9wdGlvbnMubG9jID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMubG9jO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5jb21tZW50KSB7XG4gICAgICAgICAgICBleHRyYS5jb21tZW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcbiAgICAgICAgICAgIGV4dHJhLmVycm9ycyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBlZWsoKTtcbiAgICAgICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dHJhLnRva2VucztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICB3aGlsZSAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGxleEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLmVycm9ycy5wdXNoKGxleEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gYnJlYWsgb24gdGhlIGZpcnN0IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBpbmZpbml0ZSBsb29wcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbGV4RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpbHRlclRva2VuTG9jYXRpb24oKTtcbiAgICAgICAgICAgIHRva2VucyA9IGV4dHJhLnRva2VucztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEuY29tbWVudHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLmNvbW1lbnRzID0gZXh0cmEuY29tbWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmVycm9ycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMuZXJyb3JzID0gZXh0cmEuZXJyb3JzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHByb2dyYW0sIHRvU3RyaW5nO1xuXG4gICAgICAgIHRvU3RyaW5nID0gU3RyaW5nO1xuICAgICAgICBpZiAodHlwZW9mIGNvZGUgIT09ICdzdHJpbmcnICYmICEoY29kZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICAgICAgICAgIGNvZGUgPSB0b1N0cmluZyhjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNvdXJjZSA9IGNvZGU7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgbGluZU51bWJlciA9IChzb3VyY2UubGVuZ3RoID4gMCkgPyAxIDogMDtcbiAgICAgICAgbGluZVN0YXJ0ID0gMDtcbiAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgbG9va2FoZWFkID0gbnVsbDtcbiAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgbGFiZWxTZXQ6IHt9LFxuICAgICAgICAgICAgcGFyZW50aGVzaXNDb3VudDogMCxcbiAgICAgICAgICAgIGluRnVuY3Rpb25Cb2R5OiBmYWxzZSxcbiAgICAgICAgICAgIGluSXRlcmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIGluU3dpdGNoOiBmYWxzZSxcbiAgICAgICAgICAgIGxhc3RDb21tZW50U3RhcnQ6IC0xXG4gICAgICAgIH07XG5cbiAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZXh0cmEucmFuZ2UgPSAodHlwZW9mIG9wdGlvbnMucmFuZ2UgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5yYW5nZTtcbiAgICAgICAgICAgIGV4dHJhLmxvYyA9ICh0eXBlb2Ygb3B0aW9ucy5sb2MgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5sb2M7XG4gICAgICAgICAgICBleHRyYS5hdHRhY2hDb21tZW50ID0gKHR5cGVvZiBvcHRpb25zLmF0dGFjaENvbW1lbnQgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5hdHRhY2hDb21tZW50O1xuXG4gICAgICAgICAgICBpZiAoZXh0cmEubG9jICYmIG9wdGlvbnMuc291cmNlICE9PSBudWxsICYmIG9wdGlvbnMuc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5zb3VyY2UgPSB0b1N0cmluZyhvcHRpb25zLnNvdXJjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2tlbnMgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLnRva2Vucykge1xuICAgICAgICAgICAgICAgIGV4dHJhLnRva2VucyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbW1lbnQgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5jb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRvbGVyYW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy50b2xlcmFudCkge1xuICAgICAgICAgICAgICAgIGV4dHJhLmVycm9ycyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dHJhLmF0dGFjaENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5yYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXh0cmEuY29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBleHRyYS5ib3R0b21SaWdodFN0YWNrID0gW107XG4gICAgICAgICAgICAgICAgZXh0cmEudHJhaWxpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGV4dHJhLmxlYWRpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb2dyYW0gPSBwYXJzZVByb2dyYW0oKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEuY29tbWVudHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS5jb21tZW50cyA9IGV4dHJhLmNvbW1lbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyVG9rZW5Mb2NhdGlvbigpO1xuICAgICAgICAgICAgICAgIHByb2dyYW0udG9rZW5zID0gZXh0cmEudG9rZW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS5lcnJvcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS5lcnJvcnMgPSBleHRyYS5lcnJvcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBleHRyYSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfVxuXG4gICAgLy8gU3luYyB3aXRoICouanNvbiBtYW5pZmVzdHMuXG4gICAgZXhwb3J0cy52ZXJzaW9uID0gJzIuMC4wJztcblxuICAgIGV4cG9ydHMudG9rZW5pemUgPSB0b2tlbml6ZTtcblxuICAgIGV4cG9ydHMucGFyc2UgPSBwYXJzZTtcblxuICAgIC8vIERlZXAgY29weS5cbiAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZXhwb3J0cy5TeW50YXggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmFtZSwgdHlwZXMgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHR5cGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobmFtZSBpbiBTeW50YXgpIHtcbiAgICAgICAgICAgIGlmIChTeW50YXguaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0eXBlc1tuYW1lXSA9IFN5bnRheFtuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmZyZWV6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0eXBlcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgfSgpKTtcblxufSkpO1xuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiIsIi8qXHJcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcclxuKlxyXG4qIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcclxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcbiovXHJcbihmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcclxuICAgIH1cclxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc2VsZiA9IHt9O1xyXG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xyXG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFdlIGNhbid0IGJ1aWxkIGEgcmVhbCBtZXRob2Qgd2l0aG91dCBhIGNvbnNvbGUgdG8gbG9nIHRvXHJcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcclxuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZ1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lLCBsZXZlbCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGxldmVsKTtcclxuICAgICAgICAgICAgICAgIHNlbGZbbWV0aG9kTmFtZV0uYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXHJcbiAgICAgICAgXCJ0cmFjZVwiLFxyXG4gICAgICAgIFwiZGVidWdcIixcclxuICAgICAgICBcImluZm9cIixcclxuICAgICAgICBcIndhcm5cIixcclxuICAgICAgICBcImVycm9yXCJcclxuICAgIF07XHJcblxyXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGxldmVsKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcclxuICAgICAgICAgICAgc2VsZlttZXRob2ROYW1lXSA9IChpIDwgbGV2ZWwpID8gbm9vcCA6IHNlbGYubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcclxuICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xyXG5cclxuICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2VbJ2xvZ2xldmVsJ10gPSBsZXZlbE5hbWU7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XHJcblxyXG4gICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPSBcImxvZ2xldmVsPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XHJcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxvYWRQZXJzaXN0ZWRMZXZlbCgpIHtcclxuICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVsnbG9nbGV2ZWwnXTtcclxuICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL2xvZ2xldmVsPShbXjtdKykvLmV4ZWMod2luZG93LmRvY3VtZW50LmNvb2tpZSlbMV07XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHN0b3JlZExldmVsID0gXCJXQVJOXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgICAqXHJcbiAgICAgKiBQdWJsaWMgQVBJXHJcbiAgICAgKlxyXG4gICAgICovXHJcblxyXG4gICAgc2VsZi5sZXZlbHMgPSB7IFwiVFJBQ0VcIjogMCwgXCJERUJVR1wiOiAxLCBcIklORk9cIjogMiwgXCJXQVJOXCI6IDMsXHJcbiAgICAgICAgXCJFUlJPUlwiOiA0LCBcIlNJTEVOVFwiOiA1fTtcclxuXHJcbiAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgbGV2ZWwpIHtcclxuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxyXG4gICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsKTtcclxuICAgIH07XHJcblxyXG4gICAgc2VsZi5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwic3RyaW5nXCIgJiYgc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7XHJcbiAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWwpO1xyXG4gICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxyXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xyXG4gICAgc2VsZi5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcclxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gc2VsZikge1xyXG4gICAgICAgICAgICB3aW5kb3cubG9nID0gX2xvZztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfTtcclxuXHJcbiAgICBsb2FkUGVyc2lzdGVkTGV2ZWwoKTtcclxuICAgIHJldHVybiBzZWxmO1xyXG59KSk7XHJcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHdoaXRlTGlzdCA9IFsnbm90JywgJ2FueScsICdhbGwnLCAnbm9uZSddO1xuXG5cbmZ1bmN0aW9uIG5vdE51bGwoeCkgIHsgcmV0dXJuIHggIT0gbnVsbDsgfVxuZnVuY3Rpb24gdG9TdHJpbmcoeCkgeyByZXR1cm4geC50b1N0cmluZygpOyB9XG5mdW5jdGlvbiB3cmFwKHgpICAgICB7IHJldHVybiAnKCcgKyB4ICsgJyknO31cblxuZnVuY3Rpb24gbWF5YmVRdW90ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAnXCInICsgdmFsdWUgKyAnXCInO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGxvb2tVcChrZXkpIHtcbiAgICBpZiAoa2V5Lmxhc3RJbmRleE9mKCckJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuICdjb250ZXh0LicgKyBrZXkuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICByZXR1cm4gJ2NvbnRleHQuZmVhdHVyZS5wcm9wZXJ0aWVzLicgKyBrZXk7XG59XG5cbmZ1bmN0aW9uIG51bGxWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ251bGxWYWx1ZScsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICcgdHJ1ZSAnO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlFcXVhbChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3Byb3BlcnR5RXF1YWwnLFxuICAgICAgICBvcHQ6ICc9PT0nICxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwKG1heWJlUXVvdGUodGhpcy52YWx1ZSkgKyAnICcgKyB0aGlzLm9wdCArICcgJyArIGxvb2tVcChrZXkpKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5T3Ioa2V5LCB2YWx1ZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAncHJvcGVydHlPcicsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZXM6IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHByb3BlcnR5RXF1YWwoa2V5LCB4KTsgfSksXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcCh0aGlzLnZhbHVlcy5tYXAodG9TdHJpbmcpLmpvaW4oJyB8fCAnKSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBub3Qoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdub3RQcm9wZXJ0eScsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogcGFyc2VGaWx0ZXIodmFsdWUpLFxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICchJyArIHdyYXAodGhpcy52YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIG5vbmUoa2V5LCB2YWx1ZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnbm9uZScsXG4gICAgICAgIHZhbHVlczogYW55KG51bGwsIHZhbHVlcyksXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyEnICsgd3JhcCh0aGlzLnZhbHVlcy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHByaW50TmVzdGVkKHZhbHVlcywgam9pbmVyKSB7XG4gICAgcmV0dXJuIHdyYXAodmFsdWVzLmZpbHRlcihub3ROdWxsKS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHdyYXAoeC5qb2luKCcgJiYgJykpO1xuICAgIH0pLmpvaW4oJyAnICsgam9pbmVyICsgJyAnKSk7XG59XG5cbmZ1bmN0aW9uIGFueShfLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnYW55JyxcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMubWFwKHBhcnNlRmlsdGVyKSxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmludE5lc3RlZCh0aGlzLnZhbHVlcywgJ3x8Jyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBhbGwoXywgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2FsbCcsXG4gICAgICAgIHZhbHVlczogdmFsdWVzLmZpbHRlcihub3ROdWxsKS5tYXAocGFyc2VGaWx0ZXIpLFxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByaW50TmVzdGVkKHRoaXMudmFsdWVzLCAnJiYnKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5TWF0Y2hlc0Jvb2xlYW4oa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdwcm9wZXJ0eU1hdGNoZXNCb29sZWFuJyxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwKGxvb2tVcCh0aGlzLmtleSkgKyAodGhpcy52YWx1ZSA/ICcgIT0gJyA6ICcgPT0gJykgICsgJ251bGwnKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHJhbmdlTWF0Y2goa2V5LCB2YWx1ZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAncmFuZ2VNYXRjaCcsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xuXG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZXMubWF4KSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCgnJyArIGxvb2tVcChrZXkpICsgJyA8ICcgKyB0aGlzLnZhbHVlcy5tYXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZXMubWluKSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCgnJyArIGxvb2tVcChrZXkpICsgJyA+PSAnICsgdGhpcy52YWx1ZXMubWluKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHdyYXAoZXhwcmVzc2lvbnMuam9pbignICYmICcpKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlRmlsdGVyKGZpbHRlcikge1xuICAgIHZhciBmaWx0ZXJBU1QgPSBbXSxcbiAgICAgICAga2V5cyAgICAgID0gT2JqZWN0LmtleXMoZmlsdGVyKTtcblxuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpZHgpIHtcblxuICAgICAgICB2YXIgdmFsdWUgPSBmaWx0ZXJba2V5XSxcbiAgICAgICAgICAgIHR5cGUgID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGZpbHRlckFTVC5wdXNoKHByb3BlcnR5RXF1YWwoa2V5LCB2YWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgZmlsdGVyQVNULnB1c2gocHJvcGVydHlNYXRjaGVzQm9vbGVhbihrZXksIHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZmlsdGVyQVNULnB1c2gobnVsbFZhbHVlKGtleSwgdmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmICh3aGl0ZUxpc3QuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdub3QnOlxuICAgICAgICAgICAgICAgIGZpbHRlckFTVC5wdXNoKG5vdChrZXksIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhbnknOlxuICAgICAgICAgICAgICAgIGZpbHRlckFTVC5wdXNoKGFueShrZXksIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhbGwnOlxuICAgICAgICAgICAgICAgIGZpbHRlckFTVC5wdXNoKGFsbChrZXksIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChub25lKGtleSwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmhhbmRsZWQgV2hpdGVMaXN0ZWQgcHJvcGVydHk6ICcgKyBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChwcm9wZXJ0eU9yKGtleSwgdmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubWF4IHx8IHZhbHVlLm1pbikge1xuICAgICAgICAgICAgICAgIGZpbHRlckFTVC5wdXNoKHJhbmdlTWF0Y2goa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIFF1ZXJ5IHN5dG5heDogJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGtleXMubGVuZ3RoID09PSAwID8gWyd0cnVlJ10gOiBmaWx0ZXJBU1Q7XG59XG5cbmZ1bmN0aW9uIGZpbHRlclRvU3RyaW5nKGZpbHRlckFTVCkge1xuICAgIHJldHVybiB3cmFwKGZpbHRlckFTVC5qb2luKCcgJiYgJykpO1xufVxuXG5mdW5jdGlvbiBtYXRjaChmaWx0ZXIpIHtcbiAgICBpZiAoZmlsdGVyID09IG51bGwpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07IH1cbiAgICAvLyBqc2hpbnQgZXZpbDogdHJ1ZVxuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ2NvbnRleHQnLCAncmV0dXJuICcgKyBmaWx0ZXJUb1N0cmluZyhwYXJzZUZpbHRlcihmaWx0ZXIpKSArICc7Jyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG1hdGNoOiBtYXRjaCxcbiAgICBmaWx0ZXJUb1N0cmluZzogZmlsdGVyVG9TdHJpbmcsXG4gICAgcGFyc2VGaWx0ZXI6IHBhcnNlRmlsdGVyXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBsaWdodHdlaWdodCBCdWZmZXIgc2hpbSBmb3IgcGJmIGJyb3dzZXIgYnVpbGRcbi8vIGJhc2VkIG9uIGNvZGUgZnJvbSBnaXRodWIuY29tL2Zlcm9zcy9idWZmZXIgKE1JVC1saWNlbnNlZClcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXI7XG5cbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpO1xuXG5mdW5jdGlvbiBCdWZmZXIobGVuZ3RoKSB7XG4gICAgdmFyIGFycjtcbiAgICBpZiAobGVuZ3RoICYmIGxlbmd0aC5sZW5ndGgpIHtcbiAgICAgICAgYXJyID0gbGVuZ3RoO1xuICAgICAgICBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoIHx8IDApO1xuICAgIGlmIChhcnIpIGJ1Zi5zZXQoYXJyKTtcblxuICAgIGJ1Zi5yZWFkVUludDMyTEUgPSBCdWZmZXJNZXRob2RzLnJlYWRVSW50MzJMRTtcbiAgICBidWYud3JpdGVVSW50MzJMRSA9IEJ1ZmZlck1ldGhvZHMud3JpdGVVSW50MzJMRTtcbiAgICBidWYucmVhZEludDMyTEUgPSBCdWZmZXJNZXRob2RzLnJlYWRJbnQzMkxFO1xuICAgIGJ1Zi53cml0ZUludDMyTEUgPSBCdWZmZXJNZXRob2RzLndyaXRlSW50MzJMRTtcbiAgICBidWYucmVhZEZsb2F0TEUgPSBCdWZmZXJNZXRob2RzLnJlYWRGbG9hdExFO1xuICAgIGJ1Zi53cml0ZUZsb2F0TEUgPSBCdWZmZXJNZXRob2RzLndyaXRlRmxvYXRMRTtcbiAgICBidWYucmVhZERvdWJsZUxFID0gQnVmZmVyTWV0aG9kcy5yZWFkRG91YmxlTEU7XG4gICAgYnVmLndyaXRlRG91YmxlTEUgPSBCdWZmZXJNZXRob2RzLndyaXRlRG91YmxlTEU7XG4gICAgYnVmLnRvU3RyaW5nID0gQnVmZmVyTWV0aG9kcy50b1N0cmluZztcbiAgICBidWYud3JpdGUgPSBCdWZmZXJNZXRob2RzLndyaXRlO1xuICAgIGJ1Zi5zbGljZSA9IEJ1ZmZlck1ldGhvZHMuc2xpY2U7XG4gICAgYnVmLmNvcHkgPSBCdWZmZXJNZXRob2RzLmNvcHk7XG5cbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZTtcbiAgICByZXR1cm4gYnVmO1xufVxuXG52YXIgbGFzdFN0ciwgbGFzdFN0ckVuY29kZWQ7XG5cbnZhciBCdWZmZXJNZXRob2RzID0ge1xuICAgIHJlYWRVSW50MzJMRTogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXNbcG9zXSkgfFxuICAgICAgICAgICAgKHRoaXNbcG9zICsgMV0gPDwgOCkgfFxuICAgICAgICAgICAgKHRoaXNbcG9zICsgMl0gPDwgMTYpKSArXG4gICAgICAgICAgICAodGhpc1twb3MgKyAzXSAqIDB4MTAwMDAwMCk7XG4gICAgfSxcblxuICAgIHdyaXRlVUludDMyTEU6IGZ1bmN0aW9uKHZhbCwgcG9zKSB7XG4gICAgICAgIHRoaXNbcG9zXSA9IHZhbDtcbiAgICAgICAgdGhpc1twb3MgKyAxXSA9ICh2YWwgPj4+IDgpO1xuICAgICAgICB0aGlzW3BvcyArIDJdID0gKHZhbCA+Pj4gMTYpO1xuICAgICAgICB0aGlzW3BvcyArIDNdID0gKHZhbCA+Pj4gMjQpO1xuICAgIH0sXG5cbiAgICByZWFkSW50MzJMRTogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXNbcG9zXSkgfFxuICAgICAgICAgICAgKHRoaXNbcG9zICsgMV0gPDwgOCkgfFxuICAgICAgICAgICAgKHRoaXNbcG9zICsgMl0gPDwgMTYpKSArXG4gICAgICAgICAgICAodGhpc1twb3MgKyAzXSA8PCAyNCk7XG4gICAgfSxcblxuICAgIHJlYWRGbG9hdExFOiAgZnVuY3Rpb24ocG9zKSB7IHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgcG9zLCB0cnVlLCAyMywgNCk7IH0sXG4gICAgcmVhZERvdWJsZUxFOiBmdW5jdGlvbihwb3MpIHsgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBwb3MsIHRydWUsIDUyLCA4KTsgfSxcblxuICAgIHdyaXRlRmxvYXRMRTogIGZ1bmN0aW9uKHZhbCwgcG9zKSB7IHJldHVybiBpZWVlNzU0LndyaXRlKHRoaXMsIHZhbCwgcG9zLCB0cnVlLCAyMywgNCk7IH0sXG4gICAgd3JpdGVEb3VibGVMRTogZnVuY3Rpb24odmFsLCBwb3MpIHsgcmV0dXJuIGllZWU3NTQud3JpdGUodGhpcywgdmFsLCBwb3MsIHRydWUsIDUyLCA4KTsgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgc3RyID0gJycsXG4gICAgICAgICAgICB0bXAgPSAnJztcblxuICAgICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgICAgIGVuZCA9IE1hdGgubWluKHRoaXMubGVuZ3RoLCBlbmQgfHwgdGhpcy5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSB0aGlzW2ldO1xuICAgICAgICAgICAgaWYgKGNoIDw9IDB4N0YpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gZGVjb2RlVVJJQ29tcG9uZW50KHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgICAgICAgICB0bXAgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG1wICs9ICclJyArIGNoLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciArPSBkZWNvZGVVUklDb21wb25lbnQodG1wKTtcblxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cbiAgICB3cml0ZTogZnVuY3Rpb24oc3RyLCBwb3MpIHtcbiAgICAgICAgdmFyIGJ5dGVzID0gc3RyID09PSBsYXN0U3RyID8gbGFzdFN0ckVuY29kZWQgOiBlbmNvZGVTdHJpbmcoc3RyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpc1twb3MgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNsaWNlOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpO1xuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbihidWYsIHBvcykge1xuICAgICAgICBwb3MgPSBwb3MgfHwgMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBidWZbcG9zICsgaV0gPSB0aGlzW2ldO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuQnVmZmVyTWV0aG9kcy53cml0ZUludDMyTEUgPSBCdWZmZXJNZXRob2RzLndyaXRlVUludDMyTEU7XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgbGFzdFN0ciA9IHN0cjtcbiAgICBsYXN0U3RyRW5jb2RlZCA9IGVuY29kZVN0cmluZyhzdHIpO1xuICAgIHJldHVybiBsYXN0U3RyRW5jb2RlZC5sZW5ndGg7XG59O1xuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbihidWYpIHtcbiAgICByZXR1cm4gISEoYnVmICYmIGJ1Zi5faXNCdWZmZXIpO1xufTtcblxuZnVuY3Rpb24gZW5jb2RlU3RyaW5nKHN0cikge1xuICAgIHZhciBsZW5ndGggPSBzdHIubGVuZ3RoLFxuICAgICAgICBieXRlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGMsIGxlYWQ7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7IC8vIGNvZGUgcG9pbnRcblxuICAgICAgICBpZiAoYyA+IDB4RDdGRiAmJiBjIDwgMHhFMDAwKSB7XG5cbiAgICAgICAgICAgIGlmIChsZWFkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPCAweERDMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICAgICAgICAgICAgbGVhZCA9IGM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGxlYWQgLSAweEQ4MDAgPDwgMTAgfCBjIC0gMHhEQzAwIHwgMHgxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgbGVhZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjID4gMHhEQkZGIHx8IChpICsgMSA9PT0gbGVuZ3RoKSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICAgICAgICBlbHNlIGxlYWQgPSBjO1xuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChsZWFkKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgICAgbGVhZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4ODApIGJ5dGVzLnB1c2goYyk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGMgPCAweDgwMCkgYnl0ZXMucHVzaChjID4+IDB4NiB8IDB4QzAsIGMgJiAweDNGIHwgMHg4MCk7XG4gICAgICAgICAgICBlbHNlIGlmIChjIDwgMHgxMDAwMCkgYnl0ZXMucHVzaChjID4+IDB4QyB8IDB4RTAsIGMgPj4gMHg2ICYgMHgzRiB8IDB4ODAsIGMgJiAweDNGIHwgMHg4MCk7XG4gICAgICAgICAgICBlbHNlIGJ5dGVzLnB1c2goYyA+PiAweDEyIHwgMHhGMCwgYyA+PiAweEMgJiAweDNGIHwgMHg4MCwgYyA+PiAweDYgJiAweDNGIHwgMHg4MCwgYyAmIDB4M0YgfCAweDgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGJmO1xuXG52YXIgQnVmZmVyID0gZ2xvYmFsLkJ1ZmZlciB8fCByZXF1aXJlKCcuL2J1ZmZlcicpO1xuXG5mdW5jdGlvbiBQYmYoYnVmKSB7XG4gICAgdGhpcy5idWYgPSAhQnVmZmVyLmlzQnVmZmVyKGJ1ZikgPyBuZXcgQnVmZmVyKGJ1ZiB8fCAwKSA6IGJ1ZjtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLmJ1Zi5sZW5ndGg7XG59XG5cblBiZi5WYXJpbnQgID0gMDsgLy8gdmFyaW50OiBpbnQzMiwgaW50NjQsIHVpbnQzMiwgdWludDY0LCBzaW50MzIsIHNpbnQ2NCwgYm9vbCwgZW51bVxuUGJmLkZpeGVkNjQgPSAxOyAvLyA2NC1iaXQ6IGRvdWJsZSwgZml4ZWQ2NCwgc2ZpeGVkNjRcblBiZi5CeXRlcyAgID0gMjsgLy8gbGVuZ3RoLWRlbGltaXRlZDogc3RyaW5nLCBieXRlcywgZW1iZWRkZWQgbWVzc2FnZXMsIHBhY2tlZCByZXBlYXRlZCBmaWVsZHNcblBiZi5GaXhlZDMyID0gNTsgLy8gMzItYml0OiBmbG9hdCwgZml4ZWQzMiwgc2ZpeGVkMzJcblxudmFyIFNISUZUX0xFRlRfMzIgPSAoMSA8PCAxNikgKiAoMSA8PCAxNiksXG4gICAgU0hJRlRfUklHSFRfMzIgPSAxIC8gU0hJRlRfTEVGVF8zMjtcblxuUGJmLnByb3RvdHlwZSA9IHtcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJ1ZiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8vID09PSBSRUFESU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICByZWFkRmllbGRzOiBmdW5jdGlvbihyZWFkRmllbGQsIHJlc3VsdCwgZW5kKSB7XG4gICAgICAgIGVuZCA9IGVuZCB8fCB0aGlzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLnJlYWRWYXJpbnQoKSxcbiAgICAgICAgICAgICAgICB0YWcgPSB2YWwgPj4gMyxcbiAgICAgICAgICAgICAgICBzdGFydFBvcyA9IHRoaXMucG9zO1xuXG4gICAgICAgICAgICByZWFkRmllbGQodGFnLCByZXN1bHQsIHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0UG9zKSB0aGlzLnNraXAodmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICByZWFkTWVzc2FnZTogZnVuY3Rpb24ocmVhZEZpZWxkLCByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZpZWxkcyhyZWFkRmllbGQsIHJlc3VsdCwgdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcyk7XG4gICAgfSxcblxuICAgIHJlYWRGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRTRml4ZWQzMjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkSW50MzJMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIC8vIDY0LWJpdCBpbnQgaGFuZGxpbmcgaXMgYmFzZWQgb24gZ2l0aHViLmNvbS9kcHcvbm9kZS1idWZmZXItbW9yZS1pbnRzIChNSVQtbGljZW5zZWQpXG5cbiAgICByZWFkRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MpICsgdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zICsgNCkgKiBTSElGVF9MRUZUXzMyO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkU0ZpeGVkNjQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zKSArIHRoaXMuYnVmLnJlYWRJbnQzMkxFKHRoaXMucG9zICsgNCkgKiBTSElGVF9MRUZUXzMyO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkRmxvYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZEZsb2F0TEUodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkRG91YmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWREb3VibGVMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYnVmID0gdGhpcy5idWYsXG4gICAgICAgICAgICB2YWwsIGIsIGIwLCBiMSwgYjIsIGIzO1xuXG4gICAgICAgIGIwID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjAgPCAweDgwKSByZXR1cm4gYjA7ICAgICAgICAgICAgICAgICBiMCA9IGIwICYgMHg3ZjtcbiAgICAgICAgYjEgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMSA8IDB4ODApIHJldHVybiBiMCB8IGIxIDw8IDc7ICAgICAgIGIxID0gKGIxICYgMHg3ZikgPDwgNztcbiAgICAgICAgYjIgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMiA8IDB4ODApIHJldHVybiBiMCB8IGIxIHwgYjIgPDwgMTQ7IGIyID0gKGIyICYgMHg3ZikgPDwgMTQ7XG4gICAgICAgIGIzID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjMgPCAweDgwKSByZXR1cm4gYjAgfCBiMSB8IGIyIHwgYjMgPDwgMjE7XG5cbiAgICAgICAgdmFsID0gYjAgfCBiMSB8IGIyIHwgKGIzICYgMHg3ZikgPDwgMjE7XG5cbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDEwMDAwMDAwOyAgICAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDgwMDAwMDAwMDsgICAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDQwMDAwMDAwMDAwOyAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDIwMDAwMDAwMDAwMDA7ICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDEwMDAwMDAwMDAwMDAwMDsgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDgwMDAwMDAwMDAwMDAwMDA7IGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHZhcmludCBub3QgbW9yZSB0aGFuIDEwIGJ5dGVzJyk7XG4gICAgfSxcblxuICAgIHJlYWRTVmFyaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG51bSA9IHRoaXMucmVhZFZhcmludCgpO1xuICAgICAgICByZXR1cm4gbnVtICUgMiA9PT0gMSA/IChudW0gKyAxKSAvIC0yIDogbnVtIC8gMjsgLy8gemlnemFnIGVuY29kaW5nXG4gICAgfSxcblxuICAgIHJlYWRCb29sZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5yZWFkVmFyaW50KCkpO1xuICAgIH0sXG5cbiAgICByZWFkU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsXG4gICAgICAgICAgICBzdHIgPSB0aGlzLmJ1Zi50b1N0cmluZygndXRmOCcsIHRoaXMucG9zLCBlbmQpO1xuICAgICAgICB0aGlzLnBvcyA9IGVuZDtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG4gICAgcmVhZEJ5dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsXG4gICAgICAgICAgICBidWZmZXIgPSB0aGlzLmJ1Zi5zbGljZSh0aGlzLnBvcywgZW5kKTtcbiAgICAgICAgdGhpcy5wb3MgPSBlbmQ7XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfSxcblxuICAgIC8vIHZlcmJvc2UgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM7IGRvZXNuJ3QgYWZmZWN0IGd6aXBwZWQgc2l6ZVxuXG4gICAgcmVhZFBhY2tlZFZhcmludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRWYXJpbnQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkU1ZhcmludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRTVmFyaW50KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZEJvb2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkQm9vbGVhbigpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRGbG9hdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRGbG9hdCgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWREb3VibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkRG91YmxlKCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZEZpeGVkMzI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkRml4ZWQzMigpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRTRml4ZWQzMjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRTRml4ZWQzMigpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRGaXhlZDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEZpeGVkNjQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkU0ZpeGVkNjQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU0ZpeGVkNjQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcblxuICAgIHNraXA6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB2YXIgdHlwZSA9IHZhbCAmIDB4NztcbiAgICAgICAgaWYgKHR5cGUgPT09IFBiZi5WYXJpbnQpIHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA+IDB4N2YpO1xuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBQYmYuQnl0ZXMpIHRoaXMucG9zID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcztcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gUGJmLkZpeGVkMzIpIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFBiZi5GaXhlZDY0KSB0aGlzLnBvcyArPSA4O1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCB0eXBlOiAnICsgdHlwZSk7XG4gICAgfSxcblxuICAgIC8vID09PSBXUklUSU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICB3cml0ZVRhZzogZnVuY3Rpb24odGFnLCB0eXBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoKHRhZyA8PCAzKSB8IHR5cGUpO1xuICAgIH0sXG5cbiAgICByZWFsbG9jOiBmdW5jdGlvbihtaW4pIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDE2O1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGggPCB0aGlzLnBvcyArIG1pbikgbGVuZ3RoICo9IDI7XG5cbiAgICAgICAgaWYgKGxlbmd0aCAhPSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIobGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuYnVmLmNvcHkoYnVmKTtcbiAgICAgICAgICAgIHRoaXMuYnVmID0gYnVmO1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcy5idWYuc2xpY2UoMCwgdGhpcy5sZW5ndGgpO1xuICAgIH0sXG5cbiAgICB3cml0ZUZpeGVkMzI6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlVUludDMyTEUodmFsLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgfSxcblxuICAgIHdyaXRlU0ZpeGVkMzI6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlSW50MzJMRSh2YWwsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICB9LFxuXG4gICAgd3JpdGVGaXhlZDY0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDgpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUodmFsICYgLTEsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVVSW50MzJMRShNYXRoLmZsb29yKHZhbCAqIFNISUZUX1JJR0hUXzMyKSwgdGhpcy5wb3MgKyA0KTtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICB9LFxuXG4gICAgd3JpdGVTRml4ZWQ2NDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVJbnQzMkxFKHZhbCAmIC0xLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlSW50MzJMRShNYXRoLmZsb29yKHZhbCAqIFNISUZUX1JJR0hUXzMyKSwgdGhpcy5wb3MgKyA0KTtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICB9LFxuXG4gICAgd3JpdGVWYXJpbnQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB2YWwgPSArdmFsO1xuXG4gICAgICAgIGlmICh2YWwgPD0gMHg3Zikge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDEpO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSB2YWw7XG5cbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPD0gMHgzZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMik7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAwKSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gICh2YWwgPj4+IDcpICYgMHg3ZjtcblxuICAgICAgICB9IGVsc2UgaWYgKHZhbCA8PSAweDFmZmZmZikge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDMpO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gIDApICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gIDcpICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAgKHZhbCA+Pj4gMTQpICYgMHg3ZjtcblxuICAgICAgICB9IGVsc2UgaWYgKHZhbCA8PSAweGZmZmZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbGxvYyg0KTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+ICAwKSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+ICA3KSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDE0KSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gICh2YWwgPj4+IDIxKSAmIDB4N2Y7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgICAgIHdoaWxlICh2YWwgPj0gMHg4MCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICh2YWwgJiAweGZmKSB8IDB4ODA7XG4gICAgICAgICAgICAgICAgdmFsIC89IDB4ODA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMSk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IHZhbCB8IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgLSBwb3MgPiAxMCkgdGhyb3cgbmV3IEVycm9yKFwiR2l2ZW4gdmFyaW50IGRvZXNuJ3QgZml0IGludG8gMTAgYnl0ZXNcIik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd3JpdGVTVmFyaW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh2YWwgPCAwID8gLXZhbCAqIDIgLSAxIDogdmFsICogMik7XG4gICAgfSxcblxuICAgIHdyaXRlQm9vbGVhbjogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoQm9vbGVhbih2YWwpKTtcbiAgICB9LFxuXG4gICAgd3JpdGVTdHJpbmc6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgICAgdmFyIGJ5dGVzID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyKTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChieXRlcyk7XG4gICAgICAgIHRoaXMucmVhbGxvYyhieXRlcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlKHN0ciwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSBieXRlcztcbiAgICB9LFxuXG4gICAgd3JpdGVGbG9hdDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg0KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVGbG9hdExFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZURvdWJsZTogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVEb3VibGVMRSh2YWwsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICB9LFxuXG4gICAgd3JpdGVCeXRlczogZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgIHZhciBsZW4gPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7XG4gICAgICAgIHRoaXMucmVhbGxvYyhsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IGJ1ZmZlcltpXTtcbiAgICB9LFxuXG4gICAgd3JpdGVNZXNzYWdlOiBmdW5jdGlvbih0YWcsIGZuLCBvYmopIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5CeXRlcyk7XG5cbiAgICAgICAgdGhpcy5wb3MrKzsgLy8gcmVzZXJ2ZSAxIGJ5dGUgZm9yIHNob3J0IG1lc3NhZ2UgbGVuZ3RoXG5cbiAgICAgICAgLy8gd3JpdGUgdGhlIG1lc3NhZ2UgZGlyZWN0bHkgdG8gdGhlIGJ1ZmZlciBhbmQgc2VlIGhvdyBtdWNoIHdhcyB3cml0dGVuXG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zO1xuICAgICAgICBmbihvYmosIHRoaXMpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5wb3MgLSBzdGFydFBvcztcblxuICAgICAgICB2YXIgdmFyaW50TGVuID1cbiAgICAgICAgICAgIGxlbiA8PSAweDdmID8gMSA6XG4gICAgICAgICAgICBsZW4gPD0gMHgzZmZmID8gMiA6XG4gICAgICAgICAgICBsZW4gPD0gMHgxZmZmZmYgPyAzIDpcbiAgICAgICAgICAgIGxlbiA8PSAweGZmZmZmZmYgPyA0IDogTWF0aC5jZWlsKE1hdGgubG9nKGxlbikgLyAoTWF0aC5MTjIgKiA3KSk7XG5cbiAgICAgICAgLy8gaWYgMSBieXRlIGlzbid0IGVub3VnaCBmb3IgZW5jb2RpbmcgbWVzc2FnZSBsZW5ndGgsIHNoaWZ0IHRoZSBkYXRhIHRvIHRoZSByaWdodFxuICAgICAgICBpZiAodmFyaW50TGVuID4gMSkge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKHZhcmludExlbiAtIDEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucG9zIC0gMTsgaSA+PSBzdGFydFBvczsgaS0tKSB0aGlzLmJ1ZltpICsgdmFyaW50TGVuIC0gMV0gPSB0aGlzLmJ1ZltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmFsbHksIHdyaXRlIHRoZSBtZXNzYWdlIGxlbmd0aCBpbiB0aGUgcmVzZXJ2ZWQgcGxhY2UgYW5kIHJlc3RvcmUgdGhlIHBvc2l0aW9uXG4gICAgICAgIHRoaXMucG9zID0gc3RhcnRQb3MgLSAxO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbjtcbiAgICB9LFxuXG4gICAgd3JpdGVQYWNrZWRWYXJpbnQ6ICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFZhcmludCwgYXJyKTsgICB9LFxuICAgIHdyaXRlUGFja2VkU1ZhcmludDogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRTVmFyaW50LCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZEJvb2xlYW46ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkQm9vbGVhbiwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRGbG9hdDogICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEZsb2F0LCBhcnIpOyAgICB9LFxuICAgIHdyaXRlUGFja2VkRG91YmxlOiAgIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWREb3VibGUsIGFycik7ICAgfSxcbiAgICB3cml0ZVBhY2tlZEZpeGVkMzI6ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRml4ZWQzMiwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRTRml4ZWQzMjogZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFNGaXhlZDMyLCBhcnIpOyB9LFxuICAgIHdyaXRlUGFja2VkRml4ZWQ2NDogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRGaXhlZDY0LCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkU0ZpeGVkNjQsIGFycik7IH0sXG5cbiAgICB3cml0ZUJ5dGVzRmllbGQ6IGZ1bmN0aW9uKHRhZywgYnVmZmVyKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuICAgICAgICB0aGlzLndyaXRlQnl0ZXMoYnVmZmVyKTtcbiAgICB9LFxuICAgIHdyaXRlRml4ZWQzMkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlRml4ZWQzMih2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTRml4ZWQzMkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlU0ZpeGVkMzIodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuICAgICAgICB0aGlzLndyaXRlRml4ZWQ2NCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuICAgICAgICB0aGlzLndyaXRlU0ZpeGVkNjQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlVmFyaW50RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuVmFyaW50KTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTVmFyaW50RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuVmFyaW50KTtcbiAgICAgICAgdGhpcy53cml0ZVNWYXJpbnQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU3RyaW5nRmllbGQ6IGZ1bmN0aW9uKHRhZywgc3RyKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuICAgICAgICB0aGlzLndyaXRlU3RyaW5nKHN0cik7XG4gICAgfSxcbiAgICB3cml0ZUZsb2F0RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQzMik7XG4gICAgICAgIHRoaXMud3JpdGVGbG9hdCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVEb3VibGVGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDY0KTtcbiAgICAgICAgdGhpcy53cml0ZURvdWJsZSh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVCb29sZWFuRmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnRGaWVsZCh0YWcsIEJvb2xlYW4odmFsKSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVQYWNrZWRWYXJpbnQoYXJyLCBwYmYpICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlVmFyaW50KGFycltpXSk7ICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTVmFyaW50KGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU1ZhcmludChhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGbG9hdChhcnIsIHBiZikgICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRmxvYXQoYXJyW2ldKTsgICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWREb3VibGUoYXJyLCBwYmYpICAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRG91YmxlKGFycltpXSk7ICAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRCb29sZWFuKGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlQm9vbGVhbihhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDMyKGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRml4ZWQzMihhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTRml4ZWQzMihhcnIsIHBiZikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU0ZpeGVkMzIoYXJyW2ldKTsgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDY0KGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRml4ZWQ2NChhcnJbaV0pOyAgfVxuZnVuY3Rpb24gd3JpdGVQYWNrZWRTRml4ZWQ2NChhcnIsIHBiZikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU0ZpeGVkNjQoYXJyW2ldKTsgfVxuIiwiLyohXG4gKiBzdHJpcC1jb21tZW50cyA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvc3RyaXAtY29tbWVudHM+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IEpvbiBTY2hsaW5rZXJ0LCBjb250cmlidXRvcnMuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpYyc7XG5cbnZhciByZUJsb2NrID0gJ1xcXFwvXFxcXConO1xudmFyIHJlQmxvY2tJZ25vcmUgPSAnXFxcXC9cXFxcKig/IVxcXFwqP1xcXFwhKSc7XG52YXIgcmVCbG9ja0VuZCA9ICcoLnxbXFxcXHJcXFxcbl18XFxcXG4pKj9cXFxcKlxcXFwvXFxcXG4/XFxcXG4/JztcbnZhciByZUxpbmUgPSAvKF58W15cXFNcXG5dKSg/OlxcL1xcLykoW1xcc1xcU10rPykkL2dtO1xudmFyIHJlTGluZUlnbm9yZSA9IC8oXnxbXlxcU1xcbl0pKD86XFwvXFwvW14hXSkoW1xcc1xcU10rPykkL2dtO1xuXG5cbi8qKlxuICogU3RyaXAgYWxsIGNvbW1lbnRzXG4gKlxuICogeyU9IGRvY3MoXCJzdHJpcFwiKSAlfVxuICpcbiAqIEBwYXJhbSAgIHtTdHJpbmd9IGBzdHJgICBmaWxlIGNvbnRlbnRzIG9yIHN0cmluZyB0byBzdHJpcC5cbiAqIEBwYXJhbSAgIHtPYmplY3R9IGBvcHRzYCAgb3B0aW9ucyBhcmUgcGFzc2VkIHRvIGAuYmxvY2tgLCBhbmQgYC5saW5lYFxuICogQHJldHVybiAge1N0cmluZ30gU3RyaW5nIHdpdGhvdXQgY29tbWVudHMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnZhciBzdHJpcCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3RyLCBvcHRzKSB7XG4gIHJldHVybiBzdHIgPyBzdHJpcC5ibG9jayhzdHJpcC5saW5lKHN0ciwgb3B0cyksIG9wdHMpIDogJyc7XG59O1xuXG5cbi8qKlxuICogU3RyaXAgb25seSBibG9jayBjb21tZW50cywgb3B0aW9uYWxseSBsZWF2aW5nIHByb3RlY3RlZCBjb21tZW50c1xuICogKGUuZy4gYC8qIWApIGludGFjdC5cbiAqXG4gKiB7JT0gZG9jcyhcImJsb2NrXCIpICV9XG4gKlxuICogQHBhcmFtICAge1N0cmluZ30gYHN0cmAgIGZpbGUgY29udGVudCBvciBzdHJpbmcgdG8gc3RyaXAgdG9cbiAqIEBwYXJhbSAgIHtPYmplY3R9IGBvcHRzYCAgaWYgYHNhZmU6dHJ1ZWAsIHN0cmlwIG9ubHkgY29tbWVudHMgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCBgLyohYCBvciBgLyoqIWBcbiAqIEByZXR1cm4gIHtTdHJpbmd9IFN0cmluZyB3aXRob3V0IGJsb2NrIGNvbW1lbnRzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5zdHJpcC5ibG9jayA9IGZ1bmN0aW9uKHN0ciwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdmFyIHJlID0gbmV3IFJlZ0V4cChyZUJsb2NrICsgcmVCbG9ja0VuZCwgJ2dtJyk7XG4gIGlmKG9wdHMuc2FmZSkge1xuICAgIHJlID0gbmV3IFJlZ0V4cChyZUJsb2NrSWdub3JlICsgcmVCbG9ja0VuZCwgJ2dtJyk7XG4gIH1cbiAgcmV0dXJuIHN0ciA/IHN0ci5yZXBsYWNlKHJlLCAnJykgOiAnJztcbn07XG5cblxuLyoqXG4gKiBTdHJpcCBvbmx5IGxpbmUgY29tbWVudHNcbiAqXG4gKiB7JT0gZG9jcyhcImxpbmVcIikgJX1cbiAqXG4gKiBAcGFyYW0gICB7U3RyaW5nfSBgc3RyYCAgZmlsZSBjb250ZW50IG9yIHN0cmluZyB0byBzdHJpcCB0b1xuICogQHBhcmFtICAge09iamVjdH0gYG9wdHNgICBpZiBgc2FmZTp0cnVlYCwgc3RyaXAgYWxsIHRoYXQgbm90IHN0YXJ0cyB3aXRoIGAvLyFgXG4gKiBAcmV0dXJuICB7U3RyaW5nfSBTdHJpbmcgd2l0aG91dCBsaW5lIGNvbW1lbnRzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5zdHJpcC5saW5lID0gZnVuY3Rpb24oc3RyLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB2YXIgcmUgPSByZUxpbmU7XG4gIGlmKG9wdHMuc2FmZSkge1xuICAgIHJlID0gcmVMaW5lSWdub3JlO1xuICB9XG4gIHJldHVybiBzdHIgPyBzdHIucmVwbGFjZShyZSwgJycpIDogJyc7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyB2YXIgX2FyciA9IFtdOyBmb3IgKHZhciBfaXRlcmF0b3IgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmU7KSB7IF9hcnIucHVzaChfc3RlcC52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSByZXR1cm4gX2FycjsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTtcblxudmFyIF90b0NvbnN1bWFibGVBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9O1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MgJiYgZGVzYy53cml0YWJsZSkgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHsgdmFyIHByb3AgPSBwcm9wc1trZXldOyBwcm9wLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChwcm9wLnZhbHVlKSBwcm9wLndyaXRhYmxlID0gdHJ1ZTsgfSBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKTsgfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH07XG5cbmV4cG9ydHMubWVyZ2VUcmVlcyA9IG1lcmdlVHJlZXM7XG5leHBvcnRzLndhbGtVcCA9IHdhbGtVcDtcbmV4cG9ydHMud2Fsa0Rvd24gPSB3YWxrRG93bjtcbmV4cG9ydHMuZ3JvdXBQcm9wcyA9IGdyb3VwUHJvcHM7XG5leHBvcnRzLmNhbGN1bGF0ZVN0eWxlID0gY2FsY3VsYXRlU3R5bGU7XG5leHBvcnRzLm1lcmdlT2JqZWN0cyA9IG1lcmdlT2JqZWN0cztcbmV4cG9ydHMuY2FsY3VsYXRlT3JkZXIgPSBjYWxjdWxhdGVPcmRlcjtcbmV4cG9ydHMucGFyc2VSdWxlVHJlZSA9IHBhcnNlUnVsZVRyZWU7XG5leHBvcnRzLnBhcnNlUnVsZXMgPSBwYXJzZVJ1bGVzO1xuZXhwb3J0cy5tYXRjaEZlYXR1cmUgPSBtYXRjaEZlYXR1cmU7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCJtYXRjaC1mZWF0dXJlXCIpO1xuXG52YXIgbWF0Y2ggPSBfcmVxdWlyZS5tYXRjaDtcbnZhciB3aGl0ZUxpc3QgPSBleHBvcnRzLndoaXRlTGlzdCA9IFtcImZpbHRlclwiLCBcInN0eWxlXCIsIFwiZ2VvbWV0cnlcIiwgXCJwcm9wZXJ0aWVzXCJdO1xuXG52YXIgcnVsZUNhY2hlID0gZXhwb3J0cy5ydWxlQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gY2FjaGVLZXkocnVsZXMpIHtcbiAgICByZXR1cm4gcnVsZXMubWFwKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiByLmlkO1xuICAgIH0pLmpvaW4oXCIvXCIpO1xufVxuXG5mdW5jdGlvbiBtZXJnZVRyZWVzKG1hdGNoaW5nVHJlZXMsIGNvbnRleHQpIHtcbiAgICB2YXIgc3R5bGUgPSB7fTtcbiAgICB2YXIgZGVlcGVzdE9yZGVyID0gdW5kZWZpbmVkLFxuICAgICAgICBvcmRlclJlc2V0ID0gdW5kZWZpbmVkO1xuICAgIHZhciB2aXNpYmxlID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gRmluZCBkZWVwZXN0IHRyZWVcbiAgICBtYXRjaGluZ1RyZWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID4gYi5sZW5ndGggPyAtMSA6IGIubGVuZ3RoID4gYS5sZW5ndGggPyAxIDogMDtcbiAgICB9KTtcbiAgICB2YXIgbGVuID0gbWF0Y2hpbmdUcmVlc1swXS5sZW5ndGg7XG5cbiAgICAvLyBJdGVyYXRlIHRyZWVzIGluIHBhcmFsbGVsXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBsZW47IHgrKykge1xuICAgICAgICAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZXMgPSBtYXRjaGluZ1RyZWVzLm1hcChmdW5jdGlvbiAodHJlZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmVlW3hdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtZXJnZU9iamVjdHMuYXBwbHkodW5kZWZpbmVkLCBbc3R5bGVdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoc3R5bGVzKSkpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghc3R5bGVzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGB2aXNpYmxlYCBwcm9wZXJ0eSBpcyBvbmx5IHRydWUgaWYgYWxsIG1hdGNoaW5nIHJ1bGVzIGFyZSB2aXNpYmxlXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlc1tpXS52aXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2aXNpYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBub3RlIG9mIHRoZSBzdHlsZSBwb3NpdGlvbnMgb2Ygb3JkZXItcmVsYXRlZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlc1tpXS5vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZXBlc3RPcmRlciA9IGk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlc1tpXS5vcmRlclJlc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJSZXNldCA9IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSh4KTtcbiAgICB9XG5cbiAgICBpZiAodmlzaWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHN0eWxlLnZpc2libGUgPSB2aXNpYmxlO1xuXG4gICAgLy8gT3JkZXIgbXVzdCBiZSBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBkZWVwZXN0IHRyZWUgdGhhdCBoYWQgYW4gb3JkZXIgcHJvcGVydHlcbiAgICBpZiAoZGVlcGVzdE9yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG9yZGVyVHJlZSA9IG1hdGNoaW5nVHJlZXNbZGVlcGVzdE9yZGVyXTtcblxuICAgICAgICBpZiAob3JkZXJUcmVlLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICBzdHlsZS5vcmRlciA9IG9yZGVyVHJlZVswXS5vcmRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlLm9yZGVyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gb3JkZXJSZXNldCB8fCAwOyB4IDwgb3JkZXJUcmVlLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9yZGVyVHJlZVt4XSAmJiBvcmRlclRyZWVbeF0ub3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUub3JkZXIucHVzaChvcmRlclRyZWVbeF0ub3JkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3JkZXIgY2FuIGJlIGNhY2hlZCBpZiBpdCBpcyBvbmx5IGEgc2luZ2xlIHZhbHVlXG4gICAgICAgICAgICBpZiAoc3R5bGUub3JkZXIubGVuZ3RoID09PSAxICYmIHR5cGVvZiBzdHlsZS5vcmRlclswXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHN0eWxlLm9yZGVyID0gc3R5bGUub3JkZXJbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPciBpZiB0aGVyZSBhcmUgbm8gZnVuY3Rpb24gZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICBlbHNlIGlmICghc3R5bGUub3JkZXIuc29tZShmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5vcmRlciA9IGNhbGN1bGF0ZU9yZGVyKHN0eWxlLm9yZGVyLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbn1cblxudmFyIFJ1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJ1bGUobmFtZSwgcGFyZW50LCBzdHlsZSwgZmlsdGVyLCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSdWxlKTtcblxuICAgICAgICB0aGlzLmlkID0gUnVsZS5pZCsrO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5idWlsZEZpbHRlcigpO1xuICAgICAgICB0aGlzLmJ1aWxkU3R5bGUoKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUnVsZSwge1xuICAgICAgICBidWlsZFN0eWxlOiB7XG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRTdHlsZSgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZWRTdHlsZSA9IGNhbGN1bGF0ZVN0eWxlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBidWlsZEZpbHRlcjoge1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkRmlsdGVyKCkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHRoaXMuZmlsdGVyO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyID0gbWF0Y2godGhpcy5maWx0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdG9KU09OOiB7XG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc3l0bGU6IHRoaXMuc3R5bGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gUnVsZTtcbn0pKCk7XG5cblJ1bGUuaWQgPSAwO1xuXG52YXIgUnVsZUxlYWYgPSBleHBvcnRzLlJ1bGVMZWFmID0gKGZ1bmN0aW9uIChfUnVsZSkge1xuICAgIGZ1bmN0aW9uIFJ1bGVMZWFmKF9yZWYpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSBfcmVmLnBhcmVudDtcbiAgICAgICAgdmFyIHN0eWxlID0gX3JlZi5zdHlsZTtcbiAgICAgICAgdmFyIGZpbHRlciA9IF9yZWYuZmlsdGVyO1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IF9yZWYucHJvcGVydGllcztcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUnVsZUxlYWYpO1xuXG4gICAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFJ1bGVMZWFmLnByb3RvdHlwZSksIFwiY29uc3RydWN0b3JcIiwgdGhpcykuY2FsbCh0aGlzLCBuYW1lLCBwYXJlbnQsIHN0eWxlLCBmaWx0ZXIsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIF9pbmhlcml0cyhSdWxlTGVhZiwgX1J1bGUpO1xuXG4gICAgcmV0dXJuIFJ1bGVMZWFmO1xufSkoUnVsZSk7XG5cbnZhciBSdWxlVHJlZSA9IGV4cG9ydHMuUnVsZVRyZWUgPSAoZnVuY3Rpb24gKF9SdWxlMikge1xuICAgIGZ1bmN0aW9uIFJ1bGVUcmVlKF9yZWYpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSBfcmVmLnBhcmVudDtcbiAgICAgICAgdmFyIHN0eWxlID0gX3JlZi5zdHlsZTtcbiAgICAgICAgdmFyIHJ1bGVzID0gX3JlZi5ydWxlcztcbiAgICAgICAgdmFyIGZpbHRlciA9IF9yZWYuZmlsdGVyO1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IF9yZWYucHJvcGVydGllcztcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUnVsZVRyZWUpO1xuXG4gICAgICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFJ1bGVUcmVlLnByb3RvdHlwZSksIFwiY29uc3RydWN0b3JcIiwgdGhpcykuY2FsbCh0aGlzLCBuYW1lLCBwYXJlbnQsIHN0eWxlLCBmaWx0ZXIsIHByb3BlcnRpZXMpO1xuICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXMgfHwgW107XG4gICAgfVxuXG4gICAgX2luaGVyaXRzKFJ1bGVUcmVlLCBfUnVsZTIpO1xuXG4gICAgX2NyZWF0ZUNsYXNzKFJ1bGVUcmVlLCB7XG4gICAgICAgIGFkZFJ1bGU6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSdWxlKHJ1bGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmRNYXRjaGluZ1J1bGVzOiB7XG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZmluZE1hdGNoaW5nUnVsZXMoY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBydWxlcyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vVE9ETywgc2hvdWxkIHRoaXMgZnVuY3Rpb24gdGFrZSBhIFJ1bGVUcmVlXG4gICAgICAgICAgICAgICAgbWF0Y2hGZWF0dXJlKGNvbnRleHQsIFt0aGlzXSwgcnVsZXMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGVzLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gY2FjaGVLZXkocnVsZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJ1bGVDYWNoZVtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlQ2FjaGVba2V5XSA9IG1lcmdlVHJlZXMocnVsZXMubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggJiYgeC5jYWxjdWxhdGVkU3R5bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGVDYWNoZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFJ1bGVUcmVlO1xufSkoUnVsZSk7XG5cbmZ1bmN0aW9uIGlzV2hpdGVMaXN0ZWQoa2V5KSB7XG4gICAgcmV0dXJuIHdoaXRlTGlzdC5pbmRleE9mKGtleSkgPiAtMTtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59XG5cbmZ1bmN0aW9uIHdhbGtVcChydWxlLCBjYikge1xuXG4gICAgaWYgKHJ1bGUucGFyZW50KSB7XG4gICAgICAgIHdhbGtVcChydWxlLnBhcmVudCwgY2IpO1xuICAgIH1cblxuICAgIGNiKHJ1bGUpO1xufVxuXG5mdW5jdGlvbiB3YWxrRG93bihydWxlLCBjYikge1xuXG4gICAgaWYgKHJ1bGUucnVsZXMpIHtcbiAgICAgICAgcnVsZS5ydWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICB3YWxrRG93bihyLCBjYik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNiKHJ1bGUpO1xufVxuXG5mdW5jdGlvbiBncm91cFByb3BzKG9iaikge1xuICAgIHZhciB3aGl0ZUxpc3RlZCA9IHt9LFxuICAgICAgICBub25XaGl0ZUxpc3RlZCA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoaXNXaGl0ZUxpc3RlZChrZXkpKSB7XG4gICAgICAgICAgICB3aGl0ZUxpc3RlZFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub25XaGl0ZUxpc3RlZFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFt3aGl0ZUxpc3RlZCwgbm9uV2hpdGVMaXN0ZWRdO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVTdHlsZShydWxlKSB7XG5cbiAgICB2YXIgc3R5bGVzID0gW107XG5cbiAgICBpZiAocnVsZS5wYXJlbnQpIHtcbiAgICAgICAgdmFyIGNzID0gcnVsZS5wYXJlbnQuY2FsY3VsYXRlZFN0eWxlIHx8IFtdO1xuICAgICAgICBzdHlsZXMucHVzaC5hcHBseShzdHlsZXMsIF90b0NvbnN1bWFibGVBcnJheShjcykpO1xuICAgIH1cblxuICAgIHN0eWxlcy5wdXNoKHJ1bGUuc3R5bGUpO1xuICAgIHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhuZXdPYmopIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgc291cmNlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG5cbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gc291cmNlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IG1lcmdlT2JqZWN0cyhuZXdPYmpba2V5XSB8fCB7fSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3JbXCJyZXR1cm5cIl0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld09iajtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlT3JkZXIob3JkZXJzKSB7XG4gICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMV07XG4gICAgdmFyIGRlZmF1bHRPcmRlciA9IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1syXTtcblxuICAgIHZhciBzdW0gPSBkZWZhdWx0T3JkZXI7XG5cbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gb3JkZXJzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG9yZGVyID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JkZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG9yZGVyID0gb3JkZXIoY29udGV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9yZGVyID0gcGFyc2VGbG9hdChvcmRlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb3JkZXIgfHwgaXNOYU4ob3JkZXIpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdW0gKz0gb3JkZXI7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvcltcInJldHVyblwiXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VtO1xufVxuXG5mdW5jdGlvbiBwYXJzZVJ1bGVUcmVlKG5hbWUsIHJ1bGUsIHBhcmVudCkge1xuXG4gICAgdmFyIHByb3BlcnRpZXMgPSB7IG5hbWU6IG5hbWUsIHBhcmVudDogcGFyZW50IH07XG5cbiAgICB2YXIgX2dyb3VwUHJvcHMgPSBncm91cFByb3BzKHJ1bGUpO1xuXG4gICAgdmFyIF9ncm91cFByb3BzMiA9IF9zbGljZWRUb0FycmF5KF9ncm91cFByb3BzLCAyKTtcblxuICAgIHZhciB3aGl0ZUxpc3RlZCA9IF9ncm91cFByb3BzMlswXTtcbiAgICB2YXIgbm9uV2hpdGVMaXN0ZWQgPSBfZ3JvdXBQcm9wczJbMV07XG5cbiAgICB2YXIgZW1wdHkgPSBpc0VtcHR5KG5vbldoaXRlTGlzdGVkKTtcbiAgICB2YXIgQ3JlYXRlID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGVtcHR5ICYmIHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIENyZWF0ZSA9IFJ1bGVMZWFmO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIENyZWF0ZSA9IFJ1bGVUcmVlO1xuICAgIH1cblxuICAgIHZhciByID0gbmV3IENyZWF0ZShPYmplY3QuYXNzaWduKHByb3BlcnRpZXMsIHdoaXRlTGlzdGVkKSk7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5hZGRSdWxlKHIpO1xuICAgIH1cblxuICAgIGlmICghZW1wdHkpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG5vbldoaXRlTGlzdGVkKSB7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBub25XaGl0ZUxpc3RlZFtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHBhcnNlUnVsZVRyZWUoa2V5LCBwcm9wZXJ0eSwgcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQcm9wZXJ0eSBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBwYXJzZVJ1bGVzKHJ1bGVzKSB7XG4gICAgdmFyIHJ1bGVUcmVlcyA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIHJ1bGVzKSB7XG4gICAgICAgIHZhciBydWxlID0gcnVsZXNba2V5XTtcbiAgICAgICAgcnVsZVRyZWVzW2tleV0gPSBwYXJzZVJ1bGVUcmVlKGtleSwgcnVsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bGVUcmVlcztcbn1cblxuZnVuY3Rpb24gZG9lc01hdGNoKGZpbHRlciwgY29udGV4dCkge1xuICAgIHJldHVybiB0eXBlb2YgZmlsdGVyID09PSBcImZ1bmN0aW9uXCIgJiYgZmlsdGVyKGNvbnRleHQpIHx8IGZpbHRlciA9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBtYXRjaEZlYXR1cmUoY29udGV4dCwgcnVsZXMsIGNvbGxlY3RlZFJ1bGVzKSB7XG4gICAgdmFyIG1hdGNoZWQgPSBmYWxzZTtcbiAgICB2YXIgY2hpbGRNYXRjaGVkID0gZmFsc2U7XG5cbiAgICBpZiAocnVsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciByID0gMDsgciA8IHJ1bGVzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gcnVsZXNbcl07XG4gICAgICAgIGNvbnRleHQucHJvcGVydGllcyA9IGN1cnJlbnQucHJvcGVydGllcztcblxuICAgICAgICBpZiAoY3VycmVudCBpbnN0YW5jZW9mIFJ1bGVMZWFmKSB7XG5cbiAgICAgICAgICAgIGlmIChkb2VzTWF0Y2goY3VycmVudC5maWx0ZXIsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29sbGVjdGVkUnVsZXMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50IGluc3RhbmNlb2YgUnVsZVRyZWUpIHtcbiAgICAgICAgICAgIGlmIChkb2VzTWF0Y2goY3VycmVudC5maWx0ZXIsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBjaGlsZE1hdGNoZWQgPSBtYXRjaEZlYXR1cmUoY29udGV4dCwgY3VycmVudC5ydWxlcywgY29sbGVjdGVkUnVsZXMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZE1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkUnVsZXMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LnByb3BlcnRpZXMgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVkO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbiIsIm1vZHVsZS5leHBvcnRzLlZlY3RvclRpbGUgPSByZXF1aXJlKCcuL2xpYi92ZWN0b3J0aWxlLmpzJyk7XG5tb2R1bGUuZXhwb3J0cy5WZWN0b3JUaWxlRmVhdHVyZSA9IHJlcXVpcmUoJy4vbGliL3ZlY3RvcnRpbGVmZWF0dXJlLmpzJyk7XG5tb2R1bGUuZXhwb3J0cy5WZWN0b3JUaWxlTGF5ZXIgPSByZXF1aXJlKCcuL2xpYi92ZWN0b3J0aWxlbGF5ZXIuanMnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZlY3RvclRpbGVMYXllciA9IHJlcXVpcmUoJy4vdmVjdG9ydGlsZWxheWVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmVjdG9yVGlsZTtcblxuZnVuY3Rpb24gVmVjdG9yVGlsZShwYmYsIGVuZCkge1xuICAgIHRoaXMubGF5ZXJzID0gcGJmLnJlYWRGaWVsZHMocmVhZFRpbGUsIHt9LCBlbmQpO1xufVxuXG5mdW5jdGlvbiByZWFkVGlsZSh0YWcsIGxheWVycywgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMykge1xuICAgICAgICB2YXIgbGF5ZXIgPSByZWFkTGF5ZXIocGJmKTtcbiAgICAgICAgaWYgKGxheWVyLmxlbmd0aCkgbGF5ZXJzW2xheWVyLm5hbWVdID0gbGF5ZXI7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWFkTGF5ZXIocGJmKSB7XG4gICAgdmFyIGJ5dGVzID0gcGJmLnJlYWRWYXJpbnQoKSxcbiAgICAgICAgZW5kID0gcGJmLnBvcyArIGJ5dGVzLFxuICAgICAgICBsYXllciA9IG5ldyBWZWN0b3JUaWxlTGF5ZXIocGJmLCBlbmQpO1xuICAgIHBiZi5wb3MgPSBlbmQ7XG4gICAgcmV0dXJuIGxheWVyO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGVGZWF0dXJlO1xuXG5mdW5jdGlvbiBWZWN0b3JUaWxlRmVhdHVyZShwYmYsIGVuZCwgZXh0ZW50LCBrZXlzLCB2YWx1ZXMpIHtcbiAgICAvLyBQdWJsaWNcbiAgICB0aGlzLnByb3BlcnRpZXMgPSB7fTtcbiAgICB0aGlzLmV4dGVudCA9IGV4dGVudDtcbiAgICB0aGlzLnR5cGUgPSAwO1xuXG4gICAgLy8gUHJpdmF0ZVxuICAgIHRoaXMuX3BiZiA9IHBiZjtcbiAgICB0aGlzLl9nZW9tZXRyeSA9IC0xO1xuICAgIHRoaXMuX2tleXMgPSBrZXlzO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcblxuICAgIHBiZi5yZWFkRmllbGRzKHJlYWRGZWF0dXJlLCB0aGlzLCBlbmQpO1xufVxuXG5mdW5jdGlvbiByZWFkRmVhdHVyZSh0YWcsIGZlYXR1cmUsIHBiZikge1xuICAgIGlmICh0YWcgPT0gMSkgZmVhdHVyZS5faWQgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PSAyKSByZWFkVGFnKHBiZiwgZmVhdHVyZSk7XG4gICAgZWxzZSBpZiAodGFnID09IDMpIGZlYXR1cmUudHlwZSA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09IDQpIGZlYXR1cmUuX2dlb21ldHJ5ID0gcGJmLnBvcztcbn1cblxuZnVuY3Rpb24gcmVhZFRhZyhwYmYsIGZlYXR1cmUpIHtcbiAgICB2YXIgYnl0ZXMgPSBwYmYucmVhZFZhcmludCgpLFxuICAgICAgICBlbmQgPSBwYmYucG9zICsgYnl0ZXM7XG5cbiAgICB3aGlsZSAocGJmLnBvcyA8IGVuZCkge1xuICAgICAgICB2YXIga2V5ID0gZmVhdHVyZS5fa2V5c1twYmYucmVhZFZhcmludCgpXSxcbiAgICAgICAgICAgIHZhbHVlID0gZmVhdHVyZS5fdmFsdWVzW3BiZi5yZWFkVmFyaW50KCldO1xuICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbn1cblxuVmVjdG9yVGlsZUZlYXR1cmUudHlwZXMgPSBbJ1Vua25vd24nLCAnUG9pbnQnLCAnTGluZVN0cmluZycsICdQb2x5Z29uJ107XG5cblZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS5sb2FkR2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGJmID0gdGhpcy5fcGJmO1xuICAgIHBiZi5wb3MgPSB0aGlzLl9nZW9tZXRyeTtcblxuICAgIHZhciBieXRlcyA9IHBiZi5yZWFkVmFyaW50KCksXG4gICAgICAgIGVuZCA9IHBiZi5wb3MgKyBieXRlcyxcbiAgICAgICAgY21kID0gMSxcbiAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICBsaW5lcyA9IFtdLFxuICAgICAgICBsaW5lO1xuXG4gICAgd2hpbGUgKHBiZi5wb3MgPCBlbmQpIHtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjbWRMZW4gPSBwYmYucmVhZFZhcmludCgpO1xuICAgICAgICAgICAgY21kID0gY21kTGVuICYgMHg3O1xuICAgICAgICAgICAgbGVuZ3RoID0gY21kTGVuID4+IDM7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGgtLTtcblxuICAgICAgICBpZiAoY21kID09PSAxIHx8IGNtZCA9PT0gMikge1xuICAgICAgICAgICAgeCArPSBwYmYucmVhZFNWYXJpbnQoKTtcbiAgICAgICAgICAgIHkgKz0gcGJmLnJlYWRTVmFyaW50KCk7XG5cbiAgICAgICAgICAgIGlmIChjbWQgPT09IDEpIHsgLy8gbW92ZVRvXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUpIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgbGluZSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaW5lLnB1c2gobmV3IFBvaW50KHgsIHkpKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNtZCA9PT0gNykge1xuICAgICAgICAgICAgbGluZS5wdXNoKGxpbmVbMF0uY2xvbmUoKSk7IC8vIGNsb3NlUG9seWdvblxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY29tbWFuZCAnICsgY21kKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsaW5lKSBsaW5lcy5wdXNoKGxpbmUpO1xuXG4gICAgcmV0dXJuIGxpbmVzO1xufTtcblxuVmVjdG9yVGlsZUZlYXR1cmUucHJvdG90eXBlLmJib3ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGJmID0gdGhpcy5fcGJmO1xuICAgIHBiZi5wb3MgPSB0aGlzLl9nZW9tZXRyeTtcblxuICAgIHZhciBieXRlcyA9IHBiZi5yZWFkVmFyaW50KCksXG4gICAgICAgIGVuZCA9IHBiZi5wb3MgKyBieXRlcyxcblxuICAgICAgICBjbWQgPSAxLFxuICAgICAgICBsZW5ndGggPSAwLFxuICAgICAgICB4ID0gMCxcbiAgICAgICAgeSA9IDAsXG4gICAgICAgIHgxID0gSW5maW5pdHksXG4gICAgICAgIHgyID0gLUluZmluaXR5LFxuICAgICAgICB5MSA9IEluZmluaXR5LFxuICAgICAgICB5MiA9IC1JbmZpbml0eTtcblxuICAgIHdoaWxlIChwYmYucG9zIDwgZW5kKSB7XG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY21kTGVuID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgICAgIGNtZCA9IGNtZExlbiAmIDB4NztcbiAgICAgICAgICAgIGxlbmd0aCA9IGNtZExlbiA+PiAzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoLS07XG5cbiAgICAgICAgaWYgKGNtZCA9PT0gMSB8fCBjbWQgPT09IDIpIHtcbiAgICAgICAgICAgIHggKz0gcGJmLnJlYWRTVmFyaW50KCk7XG4gICAgICAgICAgICB5ICs9IHBiZi5yZWFkU1ZhcmludCgpO1xuICAgICAgICAgICAgaWYgKHggPCB4MSkgeDEgPSB4O1xuICAgICAgICAgICAgaWYgKHggPiB4MikgeDIgPSB4O1xuICAgICAgICAgICAgaWYgKHkgPCB5MSkgeTEgPSB5O1xuICAgICAgICAgICAgaWYgKHkgPiB5MikgeTIgPSB5O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY21kICE9PSA3KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY29tbWFuZCAnICsgY21kKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbeDEsIHkxLCB4MiwgeTJdO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZlY3RvclRpbGVGZWF0dXJlID0gcmVxdWlyZSgnLi92ZWN0b3J0aWxlZmVhdHVyZS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGVMYXllcjtcblxuZnVuY3Rpb24gVmVjdG9yVGlsZUxheWVyKHBiZiwgZW5kKSB7XG4gICAgLy8gUHVibGljXG4gICAgdGhpcy52ZXJzaW9uID0gMTtcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW50ID0gNDA5NjtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBQcml2YXRlXG4gICAgdGhpcy5fcGJmID0gcGJmO1xuICAgIHRoaXMuX2tleXMgPSBbXTtcbiAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICB0aGlzLl9mZWF0dXJlcyA9IFtdO1xuXG4gICAgcGJmLnJlYWRGaWVsZHMocmVhZExheWVyLCB0aGlzLCBlbmQpO1xuXG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLl9mZWF0dXJlcy5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIHJlYWRMYXllcih0YWcsIGxheWVyLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAxNSkgbGF5ZXIudmVyc2lvbiA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAxKSBsYXllci5uYW1lID0gcGJmLnJlYWRTdHJpbmcoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDUpIGxheWVyLmV4dGVudCA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAyKSBsYXllci5fZmVhdHVyZXMucHVzaChwYmYucG9zKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDMpIGxheWVyLl9rZXlzLnB1c2gocGJmLnJlYWRTdHJpbmcoKSk7XG4gICAgZWxzZSBpZiAodGFnID09PSA0KSBsYXllci5fdmFsdWVzLnB1c2gocmVhZFZhbHVlTWVzc2FnZShwYmYpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFZhbHVlTWVzc2FnZShwYmYpIHtcbiAgICB2YXIgdmFsdWUgPSBudWxsLFxuICAgICAgICBieXRlcyA9IHBiZi5yZWFkVmFyaW50KCksXG4gICAgICAgIGVuZCA9IHBiZi5wb3MgKyBieXRlcztcblxuICAgIHdoaWxlIChwYmYucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhciB0YWcgPSBwYmYucmVhZFZhcmludCgpID4+IDM7XG5cbiAgICAgICAgdmFsdWUgPSB0YWcgPT09IDEgPyBwYmYucmVhZFN0cmluZygpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gMiA/IHBiZi5yZWFkRmxvYXQoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDMgPyBwYmYucmVhZERvdWJsZSgpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gNCB8fCB0YWcgPT09IDUgPyBwYmYucmVhZFZhcmludCgpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gNiA/IHBiZi5yZWFkU1ZhcmludCgpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gNyA/IEJvb2xlYW4ocGJmLnJlYWRWYXJpbnQoKSkgOiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gcmV0dXJuIGZlYXR1cmUgYGlgIGZyb20gdGhpcyBsYXllciBhcyBhIGBWZWN0b3JUaWxlRmVhdHVyZWBcblZlY3RvclRpbGVMYXllci5wcm90b3R5cGUuZmVhdHVyZSA9IGZ1bmN0aW9uKGkpIHtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLl9mZWF0dXJlcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignZmVhdHVyZSBpbmRleCBvdXQgb2YgYm91bmRzJyk7XG5cbiAgICB0aGlzLl9wYmYucG9zID0gdGhpcy5fZmVhdHVyZXNbaV07XG4gICAgdmFyIGVuZCA9IHRoaXMuX3BiZi5yZWFkVmFyaW50KCkgKyB0aGlzLl9wYmYucG9zO1xuXG4gICAgcmV0dXJuIG5ldyBWZWN0b3JUaWxlRmVhdHVyZSh0aGlzLl9wYmYsIGVuZCwgdGhpcy5leHRlbnQsIHRoaXMuX2tleXMsIHRoaXMuX3ZhbHVlcyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xuXG5mdW5jdGlvbiBQb2ludCh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xufVxuXG5Qb2ludC5wcm90b3R5cGUgPSB7XG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTsgfSxcblxuICAgIGFkZDogICAgIGZ1bmN0aW9uKHApIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKHApOyAgICAgfSxcbiAgICBzdWI6ICAgICBmdW5jdGlvbihwKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3N1YihwKTsgICAgIH0sXG4gICAgbXVsdDogICAgZnVuY3Rpb24oaykgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0KGspOyAgICB9LFxuICAgIGRpdjogICAgIGZ1bmN0aW9uKGspIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2KGspOyAgICAgfSxcbiAgICByb3RhdGU6ICBmdW5jdGlvbihhKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3JvdGF0ZShhKTsgIH0sXG4gICAgbWF0TXVsdDogZnVuY3Rpb24obSkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9tYXRNdWx0KG0pOyB9LFxuICAgIHVuaXQ6ICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl91bml0KCk7IH0sXG4gICAgcGVycDogICAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3BlcnAoKTsgfSxcbiAgICByb3VuZDogICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTsgfSxcblxuICAgIG1hZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPT09IHAueCAmJlxuICAgICAgICAgICAgICAgdGhpcy55ID09PSBwLnk7XG4gICAgfSxcblxuICAgIGRpc3Q6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RTcXIocCkpO1xuICAgIH0sXG5cbiAgICBkaXN0U3FyOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHZhciBkeCA9IHAueCAtIHRoaXMueCxcbiAgICAgICAgICAgIGR5ID0gcC55IC0gdGhpcy55O1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfSxcblxuICAgIGFuZ2xlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xuICAgIH0sXG5cbiAgICBhbmdsZVRvOiBmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSAtIGIueSwgdGhpcy54IC0gYi54KTtcbiAgICB9LFxuXG4gICAgYW5nbGVXaXRoOiBmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuZ2xlV2l0aFNlcChiLngsIGIueSk7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgdGhlIGFuZ2xlIG9mIHRoZSB0d28gdmVjdG9ycywgc29sdmluZyB0aGUgZm9ybXVsYSBmb3IgdGhlIGNyb3NzIHByb2R1Y3QgYSB4IGIgPSB8YXx8YnxzaW4ozrgpIGZvciDOuC5cbiAgICBhbmdsZVdpdGhTZXA6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIoXG4gICAgICAgICAgICB0aGlzLnggKiB5IC0gdGhpcy55ICogeCxcbiAgICAgICAgICAgIHRoaXMueCAqIHggKyB0aGlzLnkgKiB5KTtcbiAgICB9LFxuXG4gICAgX21hdE11bHQ6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgdmFyIHggPSBtWzBdICogdGhpcy54ICsgbVsxXSAqIHRoaXMueSxcbiAgICAgICAgICAgIHkgPSBtWzJdICogdGhpcy54ICsgbVszXSAqIHRoaXMueTtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9hZGQ6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdGhpcy54ICs9IHAueDtcbiAgICAgICAgdGhpcy55ICs9IHAueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9zdWI6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdGhpcy54IC09IHAueDtcbiAgICAgICAgdGhpcy55IC09IHAueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9tdWx0OiBmdW5jdGlvbihrKSB7XG4gICAgICAgIHRoaXMueCAqPSBrO1xuICAgICAgICB0aGlzLnkgKj0gaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9kaXY6IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgdGhpcy54IC89IGs7XG4gICAgICAgIHRoaXMueSAvPSBrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3VuaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9kaXYodGhpcy5tYWcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcGVycDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xuICAgICAgICB0aGlzLnkgPSB0aGlzLng7XG4gICAgICAgIHRoaXMueCA9IC15O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3JvdGF0ZTogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgIHggPSBjb3MgKiB0aGlzLnggLSBzaW4gKiB0aGlzLnksXG4gICAgICAgICAgICB5ID0gc2luICogdGhpcy54ICsgY29zICogdGhpcy55O1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3JvdW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xuICAgICAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbi8vIGNvbnN0cnVjdHMgUG9pbnQgZnJvbSBhbiBhcnJheSBpZiBuZWNlc3NhcnlcblBvaW50LmNvbnZlcnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIGlmIChhIGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoYVswXSwgYVsxXSk7XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcbiIsIi8qZ2xvYmFsIENhbWVyYSAqL1xuaW1wb3J0IEdlbyBmcm9tICcuL2dlbyc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscy91dGlscyc7XG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tICcuL2dsL3NoYWRlcl9wcm9ncmFtJztcblxuaW1wb3J0IGdsTWF0cml4IGZyb20gJ2dsLW1hdHJpeCc7XG52YXIgbWF0NCA9IGdsTWF0cml4Lm1hdDQ7XG52YXIgdmVjMyA9IGdsTWF0cml4LnZlYzM7XG5cbi8vIEFic3RyYWN0IGJhc2UgY2xhc3NcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbWVyYSB7XG5cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBzY2VuZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XG4gICAgICAgIHRoaXMuem9vbSA9IG9wdGlvbnMuem9vbTtcbiAgICAgICAgLy8gdGhpcy51cGRhdGVTY2VuZSgpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIGNhbWVyYSBieSB0eXBlIG5hbWUsIGZhY3Rvcnktc3R5bGVcbiAgICBzdGF0aWMgY3JlYXRlKG5hbWUsIHNjZW5lLCBjb25maWcpIHtcbiAgICAgICAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnaXNvbWV0cmljJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IElzb21ldHJpY0NhbWVyYShuYW1lLCBzY2VuZSwgY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgJ2ZsYXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmxhdENhbWVyYShuYW1lLCBzY2VuZSwgY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgJ3BlcnNwZWN0aXZlJzpcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShuYW1lLCBzY2VuZSwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBtZXRob2QgY2FsbGVkIG9uY2UgcGVyIGZyYW1lXG4gICAgdXBkYXRlKCkge1xuICAgICAgICAvLyB0aGlzLnVwZGF0ZVNjZW5lKCk7XG4gICAgfVxuXG4gICAgLy8gQ2FsbGVkIG9uY2UgcGVyIGZyYW1lIHBlciBwcm9ncmFtIChlLmcuIGZvciBtYWluIHJlbmRlciBwYXNzLCB0aGVuIGZvciBlYWNoIGFkZGl0aW9uYWwgcGFzcyBmb3IgZmVhdHVyZSBzZWxlY3Rpb24sIGV0Yy4pXG4gICAgc2V0dXBQcm9ncmFtKHByb2dyYW0pIHtcbiAgICB9XG5cbiAgICAvLyBTeW5jIGNhbWVyYSBwb3NpdGlvbiBhbmQvb3Igem9vbSB0byBzY2VuZVxuICAgIHVwZGF0ZVNjZW5lICgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gfHwgdGhpcy56b29tKSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB2aWV3ID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnpvb20pIHtcbiAgICAgICAgICAgICAgICB2aWV3Lnpvb20gPSB0aGlzLnpvb207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNjZW5lLnNldFZpZXcodmlldyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuLyoqXG4gICAgUGVyc3BlY3RpdmUgbWF0cml4IHByb2plY3Rpb25cblxuICAgIFRoaXMgaXMgYSBzcGVjaWFsaXplZCBwZXJzcGVjdGl2ZSBjYW1lcmEgdGhhdCwgZ2l2ZW4gYSBkZXNpcmVkIGNhbWVyYSBmb2NhbCBsZW5ndGggKHdoaWNoIGNhbiBhbHNvIHZhcnkgYnkgem9vbSBsZXZlbCksXG4gICAgY29uc3RyYWlucyB0aGUgY2FtZXJhIGhlaWdodCBhYm92ZSB0aGUgZ3JvdW5kIHBsYW5lIHN1Y2ggdGhhdCB0aGUgZGlzcGxheWVkIGdyb3VuZCBhcmVhIG9mIHRoZSBtYXAgbWF0Y2hlcyB0aGF0IG9mXG4gICAgYSB0cmFkaXRpb25hbCB3ZWIgbWVyY2F0b3IgbWFwLiBUaGlzIG1lYW5zIHlvdSBjYW4gc2V0IHRoZSBjYW1lcmEgbG9jYXRpb24gYnkgW2xhdCwgbG5nLCB6b29tXSBhcyB5b3Ugd291bGQgYSB0eXBpY2FsXG4gICAgd2ViIG1lcmNhdG9yIG1hcCwgdGhlbiBhZGp1c3QgdGhlIGZvY2FsIGxlbmd0aCBhcyBuZWVkZWQuXG5cbiAgICBWYW5pc2hpbmcgcG9pbnQgY2FuIGFsc28gYmUgYWRqdXN0ZWQgdG8gYWNoaWV2ZSBkaWZmZXJlbnQgXCJ2aWV3aW5nIGFuZ2xlc1wiLCBlLmcuIGluc3RlYWQgb2YgbG9va2luZyBzdHJhaWdodCBkb3duIGludG9cbiAgICB0aGUgY2VudGVyIG9mIHRoZSB2aWV3cG9ydCwgdGhlIGNhbWVyYSBhcHBlYXJzIHRvIGJlIHRpbHRlZCBhdCBhbiBhbmdsZS4gRm9yIGV4YW1wbGU6XG5cbiAgICBbMCwgMF0gPSBsb29raW5nIHRvd2FyZHMgY2VudGVyIG9mIHZpZXdwb3J0XG4gICAgWy0yNTAsIC0yNTBdID0gbG9va2luZyAyNTAgcGl4ZWxzIGZyb20gdGhlIHZpZXdwb3J0IGNlbnRlciB0byB0aGUgbG93ZXItbGVmdCBjb3JuZXJcbiAgICBbNDAwLCAwXSA9IGxvb2tpbmcgNDAwIHBpeGVscyB0byB0aGUgcmlnaHQgb2YgdGhlIHZpZXdwb3J0IGNlbnRlclxuKi9cbmNsYXNzIFBlcnNwZWN0aXZlQ2FtZXJhIGV4dGVuZHMgQ2FtZXJhIHtcblxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHNjZW5lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIobmFtZSwgc2NlbmUsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAncGVyc3BlY3RpdmUnO1xuXG4gICAgICAgIC8vIGEgc2luZ2xlIHNjYWxhciwgb3IgcGFpcnMgb2Ygc3RvcHMgbWFwcGluZyB6b29tIGxldmVscywgZS5nLiBbem9vbSwgZm9jYWwgbGVuZ3RoXVxuICAgICAgICB0aGlzLmZvY2FsX2xlbmd0aCA9IG9wdGlvbnMuZm9jYWxfbGVuZ3RoO1xuICAgICAgICB0aGlzLmZvdiA9IG9wdGlvbnMuZm92O1xuICAgICAgICBpZiAoIXRoaXMuZm9jYWxfbGVuZ3RoICYmICF0aGlzLmZvdikge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBmb2NhbCBsZW5ndGggcmFuZ2VzIGJ5IHpvb21cbiAgICAgICAgICAgIHRoaXMuZm9jYWxfbGVuZ3RoID0gW1sxNiwgMl0sIFsxNywgMi41XSwgWzE4LCAzXSwgWzE5LCA0XSwgWzIwLCA2XV07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZhbmlzaGluZ19wb2ludCA9IG9wdGlvbnMudmFuaXNoaW5nX3BvaW50IHx8IFswLCAwXTsgLy8gW3gsIHldXG4gICAgICAgIHRoaXMudmFuaXNoaW5nX3BvaW50X3NrZXcgPSBbXTtcblxuICAgICAgICB0aGlzLnBvc2l0aW9uX21ldGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMudmlld01hdHJpeCA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICAgICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcblxuICAgICAgICAvLyAnY2FtZXJhJyBpcyB0aGUgbmFtZSBvZiB0aGUgc2hhZGVyIHRyYW5zZm9ybSwgZS5nLiBkZXRlcm1pbmVzIHdoZXJlIGluIHRoZSBzaGFkZXIgdGhpcyBjb2RlIGlzIGluamVjdGVkXG4gICAgICAgIFNoYWRlclByb2dyYW0ucmVwbGFjZVRyYW5zZm9ybSgnY2FtZXJhJywgYFxuICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHVfcHJvamVjdGlvbjtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjMyB1X2V5ZTtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjMiB1X3ZhbmlzaGluZ19wb2ludDtcblxuICAgICAgICAgICAgdm9pZCBjYW1lcmFQcm9qZWN0aW9uIChpbm91dCB2ZWM0IHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSB1X3Byb2plY3Rpb24gKiBwb3NpdGlvbjtcbiAgICAgICAgICAgIH1gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQ29uc3RyYWlucyB0aGUgY2FtZXJhIHNvIHRoYXQgdGhlIHZpZXdhYmxlIGFyZWEgbWF0Y2hlcyBnaXZlbiB0aGUgdmlld3BvcnQgaGVpZ2h0XG4gICAgLy8gKGluIHdvcmxkIHNwYWNlLCBlLmcuIG1ldGVycyksIGdpdmVuIGVpdGhlciBhIGNhbWVyYSBmb2NhbCBsZW5ndGggb3IgZmllbGQtb2Ytdmlld1xuICAgIC8vIChmb2NhbCBsZW5ndGggaXMgdXNlZCBpZiBib3RoIGFyZSBwYXNzZWQpLlxuICAgIGNvbnN0cmFpbkNhbWVyYSh7IHZpZXdfaGVpZ2h0LCBoZWlnaHQsIGZvY2FsX2xlbmd0aCwgZm92IH0pIHtcbiAgICAgICAgLy8gU29sdmUgZm9yIGNhbWVyYSBoZWlnaHRcbiAgICAgICAgaWYgKCFoZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgZm9jYWwgbGVuZ3RoLCBjYWxjdWxhdGUgRk9WXG4gICAgICAgICAgICBpZiAoZm9jYWxfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm92ID0gTWF0aC5hdGFuKDEgLyBmb2NhbF9sZW5ndGgpICogMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGhhdmUgRk9WLCBjYWxjdWxhdGUgZm9jYWwgbGVuZ3RoXG4gICAgICAgICAgICBlbHNlIGlmIChmb3YpIHtcbiAgICAgICAgICAgICAgICBmb3YgPSBmb3YgKiBNYXRoLlBJIC8gMTgwOyAvLyBjb252ZXJ0IEZPViBkZWdyZWVzIHRvIHJhZGlhbnNcbiAgICAgICAgICAgICAgICBmb2NhbF9sZW5ndGggPSAxIC8gTWF0aC50YW4oZm92IC8gMik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc3RhbmNlIHRoYXQgY2FtZXJhIHNob3VsZCBiZSBmcm9tIGdyb3VuZCBzdWNoIHRoYXQgaXQgZml0cyB0aGUgZmllbGQgb2YgdmlldyBleHBlY3RlZFxuICAgICAgICAgICAgLy8gZm9yIGEgY29udmVudGlvbmFsIHdlYiBtZXJjYXRvciBtYXAgYXQgdGhlIGN1cnJlbnQgem9vbSBsZXZlbCBhbmQgY2FtZXJhIGZvY2FsIGxlbmd0aFxuICAgICAgICAgICAgaGVpZ2h0ID0gdmlld19oZWlnaHQgLyAyICogZm9jYWxfbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbHZlIGZvciBjYW1lcmEgZm9jYWwgbGVuZ3RoIC8gZmllbGQtb2Ytdmlld1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvY2FsX2xlbmd0aCA9IDIgKiBoZWlnaHQgLyB2aWV3X2hlaWdodDtcbiAgICAgICAgICAgIGZvdiA9IE1hdGguYXRhbigxIC8gZm9jYWxfbGVuZ3RoKSAqIDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB2aWV3X2hlaWdodCwgaGVpZ2h0LCBmb2NhbF9sZW5ndGgsIGZvdiB9O1xuICAgIH1cblxuICAgIHVwZGF0ZU1hdHJpY2VzKCkge1xuICAgICAgICAvLyBUT0RPOiBvbmx5IHJlLWNhbGN1bGF0ZSB0aGVzZSB2YXJzIHdoZW4gbmVjZXNzYXJ5XG5cbiAgICAgICAgLy8gSGVpZ2h0IG9mIHRoZSB2aWV3cG9ydCBpbiBtZXRlcnMgYXQgY3VycmVudCB6b29tXG4gICAgICAgIHZhciB2aWV3cG9ydF9oZWlnaHQgPSB0aGlzLnNjZW5lLmNzc19zaXplLmhlaWdodCAqIEdlby5tZXRlcnNQZXJQaXhlbCh0aGlzLnNjZW5lLnpvb20pO1xuXG4gICAgICAgIC8vIENvbXB1dGUgY2FtZXJhIHByb3BlcnRpZXMgdG8gZml0IGRlc2lyZWQgdmlld1xuICAgICAgICB2YXIgeyBoZWlnaHQsIGZvdiB9ID0gdGhpcy5jb25zdHJhaW5DYW1lcmEoe1xuICAgICAgICAgICAgdmlld19oZWlnaHQ6IHZpZXdwb3J0X2hlaWdodCxcbiAgICAgICAgICAgIGZvY2FsX2xlbmd0aDogVXRpbHMuaW50ZXJwb2xhdGUodGhpcy5zY2VuZS56b29tLCB0aGlzLmZvY2FsX2xlbmd0aCksXG4gICAgICAgICAgICBmb3Y6IFV0aWxzLmludGVycG9sYXRlKHRoaXMuc2NlbmUuem9vbSwgdGhpcy5mb3YpXG4gICAgICAgICB9KTtcblxuICAgICAgICAvLyBWaWV3IG1hdHJpeFxuICAgICAgICB2YXIgcG9zaXRpb24gPSBbdGhpcy5zY2VuZS5jZW50ZXJfbWV0ZXJzLngsIHRoaXMuc2NlbmUuY2VudGVyX21ldGVycy55LCBoZWlnaHRdO1xuICAgICAgICB0aGlzLnBvc2l0aW9uX21ldGVycyA9IHBvc2l0aW9uO1xuXG4gICAgICAgIC8vIG1hdDQubG9va0F0KHRoaXMudmlld01hdHJpeCxcbiAgICAgICAgLy8gICAgIHZlYzMuZnJvbVZhbHVlcyguLi5wb3NpdGlvbiksXG4gICAgICAgIC8vICAgICB2ZWMzLmZyb21WYWx1ZXMocG9zaXRpb25bMF0sIHBvc2l0aW9uWzFdLCBoZWlnaHQgLSAxKSxcbiAgICAgICAgLy8gICAgIHZlYzMuZnJvbVZhbHVlcygwLCAxLCAwKSk7XG4gICAgICAgIC8vIEV4Y2x1ZGUgY2FtZXJhIGhlaWdodCBmcm9tIHZpZXcgbWF0cml4XG4gICAgICAgIG1hdDQubG9va0F0KHRoaXMudmlld01hdHJpeCxcbiAgICAgICAgICAgIHZlYzMuZnJvbVZhbHVlcyhwb3NpdGlvblswXSwgcG9zaXRpb25bMV0sIDApLFxuICAgICAgICAgICAgdmVjMy5mcm9tVmFsdWVzKHBvc2l0aW9uWzBdLCBwb3NpdGlvblsxXSwgLTEpLFxuICAgICAgICAgICAgdmVjMy5mcm9tVmFsdWVzKDAsIDEsIDApKTtcblxuICAgICAgICAvLyBQcm9qZWN0aW9uIG1hdHJpeFxuICAgICAgICBtYXQ0LnBlcnNwZWN0aXZlKHRoaXMucHJvamVjdGlvbk1hdHJpeCwgZm92LCB0aGlzLnNjZW5lLnZpZXdfYXNwZWN0LCAxLCBoZWlnaHQgKyAxKTtcblxuICAgICAgICAvLyBDb252ZXJ0IHZhbmlzaGluZyBwb2ludCBmcm9tIHBpeGVscyB0byB2aWV3cG9ydCBzcGFjZVxuICAgICAgICB0aGlzLnZhbmlzaGluZ19wb2ludF9za2V3WzBdID0gdGhpcy52YW5pc2hpbmdfcG9pbnRbMF0gLyB0aGlzLnNjZW5lLmNzc19zaXplLndpZHRoO1xuICAgICAgICB0aGlzLnZhbmlzaGluZ19wb2ludF9za2V3WzFdID0gdGhpcy52YW5pc2hpbmdfcG9pbnRbMV0gLyB0aGlzLnNjZW5lLmNzc19zaXplLmhlaWdodDtcblxuICAgICAgICAvLyBBZGp1c3QgcHJvamVjdGlvbiBtYXRyaXggdG8gaW5jbHVkZSB2YW5pc2hpbmcgcG9pbnQgc2tld1xuICAgICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXhbOF0gPSAtdGhpcy52YW5pc2hpbmdfcG9pbnRfc2tld1swXTsgLy8geiBjb2x1bW4gb2YgeCByb3csIGUuZy4gYW1vdW50IHogc2tld3MgeFxuICAgICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXhbOV0gPSAtdGhpcy52YW5pc2hpbmdfcG9pbnRfc2tld1sxXTsgLy8geiBjb2x1bW4gb2YgeSByb3csIGUuZy4gYW1vdW50IHogc2tld3MgeVxuXG4gICAgICAgIC8vIFRyYW5zbGF0ZSBnZW9tZXRyeSBpbnRvIHRoZSBkaXN0YW5jZSBzbyB0aGF0IGNhbWVyYSBpcyBhcHByb3ByaWF0ZSBoZWlnaHQgYWJvdmUgZ3JvdW5kXG4gICAgICAgIC8vIEFkZGl0aW9uYWxseSwgYWRqdXN0IHh5IHRvIGNvbXBlbnNhdGUgZm9yIGFueSB2YW5pc2hpbmcgcG9pbnQgc2tldywgZS5nLiBtb3ZlIGdlb21ldHJ5IHNvIHRoYXQgdGhlIGRpc3BsYXllZCBnXG4gICAgICAgIC8vIHBsYW5lIG9mIHRoZSBtYXAgbWF0Y2hlcyB0aGF0IGV4cGVjdGVkIGJ5IGEgdHJhZGl0aW9uYWwgd2ViIG1lcmNhdG9yIG1hcCBhdCB0aGlzIFtsYXQsIGxuZywgem9vbV0uXG4gICAgICAgIG1hdDQudHJhbnNsYXRlKHRoaXMucHJvamVjdGlvbk1hdHJpeCwgdGhpcy5wcm9qZWN0aW9uTWF0cml4LFxuICAgICAgICAgICAgdmVjMy5mcm9tVmFsdWVzKFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0X2hlaWdodC8yICogdGhpcy5zY2VuZS52aWV3X2FzcGVjdCAqIC10aGlzLnZhbmlzaGluZ19wb2ludF9za2V3WzBdLFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0X2hlaWdodC8yICogLXRoaXMudmFuaXNoaW5nX3BvaW50X3NrZXdbMV0sXG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEluY2x1ZGUgY2FtZXJhIGhlaWdodCBpbiBwcm9qZWN0aW9uIG1hdHJpeFxuICAgICAgICBtYXQ0LnRyYW5zbGF0ZSh0aGlzLnByb2plY3Rpb25NYXRyaXgsIHRoaXMucHJvamVjdGlvbk1hdHJpeCwgdmVjMy5mcm9tVmFsdWVzKDAsIDAsIC1oZWlnaHQpKTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpY2VzKCk7XG4gICAgfVxuXG4gICAgc2V0dXBQcm9ncmFtKHByb2dyYW0pIHtcbiAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCdNYXRyaXg0ZnYnLCAndV9wcm9qZWN0aW9uJywgZmFsc2UsIHRoaXMucHJvamVjdGlvbk1hdHJpeCk7XG4gICAgICAgIHByb2dyYW0udW5pZm9ybSgnM2YnLCAndV9leWUnLCAwLCAwLCB0aGlzLnBvc2l0aW9uX21ldGVyc1syXSk7XG4gICAgICAgIHByb2dyYW0udW5pZm9ybSgnMmZ2JywgJ3VfdmFuaXNoaW5nX3BvaW50JywgdGhpcy52YW5pc2hpbmdfcG9pbnRfc2tldyk7XG4gICAgfVxuXG59XG5cbi8vIElzb21ldHJpYy1zdHlsZSBwcm9qZWN0aW9uXG4vLyBOb3RlOiB0aGlzIGlzIGFjdHVhbGx5IGFuIFwiYXhvbm9tZXRyaWNcIiBwcm9qZWN0aW9uLCBidXQgSSdtIHVzaW5nIHRoZSBjb2xsb3F1aWFsIHRlcm0gaXNvbWV0cmljIGJlY2F1c2UgaXQgaXMgbW9yZSByZWNvZ25pemFibGUuXG4vLyBBbiBpc29tZXRyaWMgcHJvamVjdGlvbiBpcyBhIHNwZWNpZmljIHN1YnNldCBvZiBheG9ub21ldHJpYyBwcm9qZWN0aW9ucy5cbi8vICdheGlzJyBkZXRlcm1pbmVzIHRoZSB4eSBza2V3IGFwcGxpZWQgdG8gYSB2ZXJ0ZXggYmFzZWQgb24gaXRzIHogY29vcmRpbmF0ZSwgZS5nLiBbMCwgMV0gYXhpcyBjYXVzZXMgYnVpbGRpbmdzIHRvIGJlIGRyYXduXG4vLyBzdHJhaWdodCB1cHdhcmRzIG9uIHNjcmVlbiBhdCB0aGVpciB0cnVlIGhlaWdodCwgWzAsIC41XSB3b3VsZCBkcmF3IHRoZW0gdXAgYXQgaGFsZi1oZWlnaHQsIFsxLCAwXSB3b3VsZCBiZSBzaWRld2F5cywgZXRjLlxuY2xhc3MgSXNvbWV0cmljQ2FtZXJhIGV4dGVuZHMgQ2FtZXJhIHtcblxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHNjZW5lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIobmFtZSwgc2NlbmUsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnaXNvbWV0cmljJztcbiAgICAgICAgdGhpcy5heGlzID0gb3B0aW9ucy5heGlzIHx8IHsgeDogMCwgeTogMSB9O1xuICAgICAgICBpZiAodGhpcy5heGlzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdGhpcy5heGlzID0geyB4OiB0aGlzLmF4aXNbMF0sIHk6IHRoaXMuYXhpc1sxXSB9OyAvLyBhbGxvdyBheGlzIHRvIGFsc28gYmUgcGFzc2VkIGFzIDItZWxlbSBhcnJheVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52aWV3TWF0cml4ID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuXG4gICAgICAgIC8vICdjYW1lcmEnIGlzIHRoZSBuYW1lIG9mIHRoZSBzaGFkZXIgdHJhbnNmb3JtLCBlLmcuIGRldGVybWluZXMgd2hlcmUgaW4gdGhlIHNoYWRlciB0aGlzIGNvZGUgaXMgaW5qZWN0ZWRcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5yZXBsYWNlVHJhbnNmb3JtKCdjYW1lcmEnLCBgXG4gICAgICAgICAgICB1bmlmb3JtIG1hdDQgdV9wcm9qZWN0aW9uO1xuICAgICAgICAgICAgdW5pZm9ybSB2ZWMzIHVfZXllO1xuICAgICAgICAgICAgdW5pZm9ybSB2ZWMyIHVfdmFuaXNoaW5nX3BvaW50O1xuXG4gICAgICAgICAgICB2b2lkIGNhbWVyYVByb2plY3Rpb24gKGlub3V0IHZlYzQgcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHVfcHJvamVjdGlvbiAqIHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9uLnh5ICs9IHBvc2l0aW9uLnogKiB1X2lzb21ldHJpY19heGlzO1xuXG4gICAgICAgICAgICAgICAgLy8gUmV2ZXJzZSB6IGZvciBkZXB0aCBidWZmZXIgc28gdXAgaXMgbmVnYXRpdmUsXG4gICAgICAgICAgICAgICAgLy8gYW5kIHNjYWxlIGRvd24gdmFsdWVzIHNvIG9iamVjdHMgaGlnaGVyIHRoYW4gb25lIHNjcmVlbiBoZWlnaHQgd2lsbCBub3QgZ2V0IGNsaXBwZWRcbiAgICAgICAgICAgICAgICAvLyBwdWxsIGZvcndhcmQgc2xpZ2h0bHkgdG8gYXZvaWQgZ29pbmcgcGFzdCBmYXIgY2xpcHBpbmcgcGxhbmVcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi56ID0gLXBvc2l0aW9uLnogLyAxMDAuICsgMS4gLSAwLjAwMTtcbiAgICAgICAgICAgIH1gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBzdXBlci51cGRhdGUoKTtcblxuICAgICAgICAvLyBWaWV3XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IFt0aGlzLnNjZW5lLmNlbnRlcl9tZXRlcnMueCwgdGhpcy5zY2VuZS5jZW50ZXJfbWV0ZXJzLnldO1xuICAgICAgICBtYXQ0LmlkZW50aXR5KHRoaXMudmlld01hdHJpeCk7XG4gICAgICAgIG1hdDQudHJhbnNsYXRlKHRoaXMudmlld01hdHJpeCwgdGhpcy52aWV3TWF0cml4LCB2ZWMzLmZyb21WYWx1ZXMoLXBvc2l0aW9uWzBdLCAtcG9zaXRpb25bMV0sIDApKTtcblxuICAgICAgICAvLyBQcm9qZWN0aW9uXG4gICAgICAgIG1hdDQuaWRlbnRpdHkodGhpcy5wcm9qZWN0aW9uTWF0cml4KTtcblxuICAgICAgICAvLyBhcHBseSBpc29tZXRyaWMgc2tld1xuICAgICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXhbOF0gPSB0aGlzLmF4aXMueCAvIHRoaXMuc2NlbmUudmlld19hc3BlY3Q7ICAgIC8vIHogY29sdW1uIG9mIHggcm93LCBlLmcuIGFtb3VudCB6IHNrZXdzIHhcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4WzldID0gdGhpcy5heGlzLnk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB6IGNvbHVtbiBvZiB4IHJvdywgZS5nLiBhbW91bnQgeiBza2V3cyB5XG5cbiAgICAgICAgLy8gY29udmVydCBtZXRlcnMgdG8gdmlld3BvcnRcbiAgICAgICAgbWF0NC5zY2FsZSh0aGlzLnByb2plY3Rpb25NYXRyaXgsIHRoaXMucHJvamVjdGlvbk1hdHJpeCxcbiAgICAgICAgICAgIHZlYzMuZnJvbVZhbHVlcyhcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy5zY2VuZS52aWV3cG9ydF9tZXRlcnMueCxcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy5zY2VuZS52aWV3cG9ydF9tZXRlcnMueSxcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy5zY2VuZS52aWV3cG9ydF9tZXRlcnMueVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHNldHVwUHJvZ3JhbShwcm9ncmFtKSB7XG4gICAgICAgIHByb2dyYW0udW5pZm9ybSgnTWF0cml4NGZ2JywgJ3VfcHJvamVjdGlvbicsIGZhbHNlLCB0aGlzLnByb2plY3Rpb25NYXRyaXgpO1xuXG4gICAgICAgIHZhciB2aWV3cG9ydF9oZWlnaHQgPSB0aGlzLnNjZW5lLmNzc19zaXplLmhlaWdodCAqIEdlby5tZXRlcnNQZXJQaXhlbCh0aGlzLnNjZW5lLnpvb20pO1xuICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzNmJywgJ3VfZXllJywgMCwgMCwgdmlld3BvcnRfaGVpZ2h0KTtcbiAgICAgICAgLy8gcHJvZ3JhbS51bmlmb3JtKCczZicsICd1X2V5ZScsIHZpZXdwb3J0X2hlaWdodCAqIHRoaXMuYXhpcy54LCB2aWV3cG9ydF9oZWlnaHQgKiB0aGlzLmF4aXMueSwgdmlld3BvcnRfaGVpZ2h0KTtcbiAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCcyZicsICd1X3ZhbmlzaGluZ19wb2ludCcsIDAsIDApO1xuICAgIH1cblxufVxuXG4vLyBGbGF0IHByb2plY3Rpb24gKGUuZy4ganVzdCB0b3AtZG93biwgbm8gcGVyc3BlY3RpdmUpIC0gYSBkZWdlbmVyYXRlIGlzb21ldHJpYyBjYW1lcmFcbmNsYXNzIEZsYXRDYW1lcmEgZXh0ZW5kcyBJc29tZXRyaWNDYW1lcmEge1xuXG4gICAgY29uc3RydWN0b3IobmFtZSwgc2NlbmUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcihuYW1lLCBzY2VuZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdmbGF0JztcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIC8vIEF4aXMgaXMgZml4ZWQgdG8gKDAsIDApIGZvciBmbGF0IGNhbWVyYVxuICAgICAgICB0aGlzLmF4aXMueCA9IDA7XG4gICAgICAgIHRoaXMuYXhpcy55ID0gMDtcblxuICAgICAgICBzdXBlci51cGRhdGUoKTtcbiAgICB9XG5cbn1cbiIsIi8vIE1pc2NlbGxhbmVvdXMgZ2VvIGZ1bmN0aW9uc1xuXG52YXIgR2VvO1xuZXhwb3J0IGRlZmF1bHQgR2VvID0ge307XG5cbi8vIFByb2plY3Rpb24gY29uc3RhbnRzXG5HZW8udGlsZV9zaXplID0gMjU2O1xuR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnMgPSAyMDAzNzUwOC4zNDI3ODkyNDQ7XG5HZW8ubWluX3pvb21fbWV0ZXJzX3Blcl9waXhlbCA9IEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzICogMiAvIEdlby50aWxlX3NpemU7IC8vIG1pbiB6b29tIGRyYXdzIHdvcmxkIGFzIDIgdGlsZXMgd2lkZVxuR2VvLm1ldGVyc19wZXJfcGl4ZWwgPSBbXTtcbkdlby5tYXhfem9vbSA9IDIwO1xuZm9yICh2YXIgej0wOyB6IDw9IEdlby5tYXhfem9vbTsgeisrKSB7XG4gICAgR2VvLm1ldGVyc19wZXJfcGl4ZWxbel0gPSBHZW8ubWluX3pvb21fbWV0ZXJzX3Blcl9waXhlbCAvIE1hdGgucG93KDIsIHopO1xufVxuXG5HZW8ubWV0ZXJzUGVyUGl4ZWwgPSBmdW5jdGlvbiAoem9vbSkge1xuICAgIHJldHVybiBHZW8ubWluX3pvb21fbWV0ZXJzX3Blcl9waXhlbCAvIE1hdGgucG93KDIsIHpvb20pO1xufTtcblxuLy8gQ29udmVyc2lvbiBmdW5jdGlvbnMgYmFzZWQgb24gYW4gZGVmaW5lZCB0aWxlIHNjYWxlXG5HZW8udW5pdHNfcGVyX21ldGVyID0gW107XG5HZW8uc2V0VGlsZVNjYWxlID0gZnVuY3Rpb24oc2NhbGUpIHtcbiAgICBHZW8udGlsZV9zY2FsZSA9IHNjYWxlO1xuICAgIEdlby51bml0c19wZXJfcGl4ZWwgPSBHZW8udGlsZV9zY2FsZSAvIEdlby50aWxlX3NpemU7XG5cbiAgICBmb3IgKHZhciB6PTA7IHogPD0gR2VvLm1heF96b29tOyB6KyspIHtcbiAgICAgICAgR2VvLnVuaXRzX3Blcl9tZXRlclt6XSA9IEdlby50aWxlX3NjYWxlIC8gKEdlby50aWxlX3NpemUgKiBHZW8ubWV0ZXJzX3Blcl9waXhlbFt6XSk7XG4gICAgfVxufTtcblxuLy8gQ29udmVydCB0aWxlIGxvY2F0aW9uIHRvIG1lcmNhdG9yIG1ldGVycyAtIG11bHRpcGx5IGJ5IHBpeGVscyBwZXIgdGlsZSwgdGhlbiBieSBtZXRlcnMgcGVyIHBpeGVsLCBhZGp1c3QgZm9yIG1hcCBvcmlnaW5cbkdlby5tZXRlcnNGb3JUaWxlID0gZnVuY3Rpb24gKHRpbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB0aWxlLnggKiBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycyAqIDIgLyBNYXRoLnBvdygyLCB0aWxlLnopIC0gR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnMsXG4gICAgICAgIHk6IC0odGlsZS55ICogR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnMgKiAyIC8gTWF0aC5wb3coMiwgdGlsZS56KSAtIEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzKVxuICAgIH07XG59O1xuXG4vKipcbiAgIEdpdmVuIGEgcG9pbnQgaW4gbWVyY2F0b3IgbWV0ZXJzIGFuZCBhIHpvb20gbGV2ZWwsIHJldHVybiB0aGUgdGlsZSBYL1kvWiB0aGF0IHRoZSBwb2ludCBsaWVzIGluXG4qL1xuR2VvLnRpbGVGb3JNZXRlcnMgPSBmdW5jdGlvbiAoW3gsIHldLCB6b29tKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogTWF0aC5mbG9vcigoeCArIEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzKSAvIChHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycyAqIDIgLyBNYXRoLnBvdygyLCB6b29tKSkpLFxuICAgICAgICB5OiBNYXRoLmZsb29yKCgteSArIEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzKSAvIChHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycyAqIDIgLyBNYXRoLnBvdygyLCB6b29tKSkpLFxuICAgICAgICB6OiB6b29tXG4gICAgfTtcbn07XG5cbi8qKlxuICAgQ29udmVydCBtZXJjYXRvciBtZXRlcnMgdG8gbGF0LWxuZ1xuKi9cbkdlby5tZXRlcnNUb0xhdExuZyA9IGZ1bmN0aW9uIChbeCwgeV0pIHtcblxuICAgIHggLz0gR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnM7XG4gICAgeSAvPSBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycztcblxuICAgIHkgPSAoMiAqIE1hdGguYXRhbihNYXRoLmV4cCh5ICogTWF0aC5QSSkpIC0gKE1hdGguUEkgLyAyKSkgLyBNYXRoLlBJO1xuXG4gICAgeCAqPSAxODA7XG4gICAgeSAqPSAxODA7XG5cbiAgICByZXR1cm4gW3gsIHldO1xufTtcblxuLyoqXG4gIENvbnZlcnQgbGF0LWxuZyB0byBtZXJjYXRvciBtZXRlcnNcbiovXG5HZW8ubGF0TG5nVG9NZXRlcnMgPSBmdW5jdGlvbihbeCwgeV0pIHtcblxuICAgIC8vIExhdGl0dWRlXG4gICAgeSA9IE1hdGgubG9nKE1hdGgudGFuKHkqTWF0aC5QSS8zNjAgKyBNYXRoLlBJLzQpKSAvIE1hdGguUEk7XG4gICAgeSAqPSBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycztcblxuICAgIC8vIExvbmdpdHVkZVxuICAgIHggKj0gR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnMgLyAxODA7XG5cbiAgICByZXR1cm4gW3gsIHldO1xufTtcblxuLy8gUnVuIGFuIGluLXBsYWNlIHRyYW5zZm9ybSBmdW5jdGlvbiBvbiBlYWNoIGNvb29yZGluYXRlIGluIGEgR2VvSlNPTiBnZW9tZXRyeVxuR2VvLnRyYW5zZm9ybUdlb21ldHJ5ID0gZnVuY3Rpb24gKGdlb21ldHJ5LCB0cmFuc2Zvcm0pIHtcbiAgICBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ1BvaW50Jykge1xuICAgICAgICB0cmFuc2Zvcm0oZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgfHwgZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XG4gICAgICAgIGdlb21ldHJ5LmNvb3JkaW5hdGVzLmZvckVhY2godHJhbnNmb3JtKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nIHx8IGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnKSB7XG4gICAgICAgIGdlb21ldHJ5LmNvb3JkaW5hdGVzLmZvckVhY2goY29vcmRpbmF0ZXMgPT4gY29vcmRpbmF0ZXMuZm9yRWFjaCh0cmFuc2Zvcm0pKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgZ2VvbWV0cnkuY29vcmRpbmF0ZXMuZm9yRWFjaChwb2x5Z29uID0+IHtcbiAgICAgICAgICAgIHBvbHlnb24uZm9yRWFjaChjb29yZGluYXRlcyA9PiBjb29yZGluYXRlcy5mb3JFYWNoKHRyYW5zZm9ybSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVE9ETzogc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb25cbn07XG5cbkdlby5ib3hJbnRlcnNlY3QgPSBmdW5jdGlvbiAoYjEsIGIyKSB7XG4gICAgcmV0dXJuICEoXG4gICAgICAgIGIyLnN3LnggPiBiMS5uZS54IHx8XG4gICAgICAgIGIyLm5lLnggPCBiMS5zdy54IHx8XG4gICAgICAgIGIyLnN3LnkgPiBiMS5uZS55IHx8XG4gICAgICAgIGIyLm5lLnkgPCBiMS5zdy55XG4gICAgKTtcbn07XG5cbi8vIEZpbmRzIHRoZSBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94IGZvciBhIHBvbHlnb25cbkdlby5maW5kQm91bmRpbmdCb3ggPSBmdW5jdGlvbiAocG9seWdvbikge1xuICAgIHZhciBtaW5feCA9IEluZmluaXR5LFxuICAgICAgICBtYXhfeCA9IC1JbmZpbml0eSxcbiAgICAgICAgbWluX3kgPSBJbmZpbml0eSxcbiAgICAgICAgbWF4X3kgPSAtSW5maW5pdHk7XG5cbiAgICAvLyBPbmx5IG5lZWQgdG8gZXhhbWluZSBvdXRlciByaW5nIChwb2x5Z29uWzBdKVxuICAgIHZhciBudW1fY29vcmRzID0gcG9seWdvblswXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgYz0wOyBjIDwgbnVtX2Nvb3JkczsgYysrKSB7XG4gICAgICAgIHZhciBjb29yZCA9IHBvbHlnb25bMF1bY107XG5cbiAgICAgICAgaWYgKGNvb3JkWzBdIDwgbWluX3gpIHtcbiAgICAgICAgICAgIG1pbl94ID0gY29vcmRbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvb3JkWzFdIDwgbWluX3kpIHtcbiAgICAgICAgICAgIG1pbl95ID0gY29vcmRbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvb3JkWzBdID4gbWF4X3gpIHtcbiAgICAgICAgICAgIG1heF94ID0gY29vcmRbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvb3JkWzFdID4gbWF4X3kpIHtcbiAgICAgICAgICAgIG1heF95ID0gY29vcmRbMV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW21pbl94LCBtaW5feSwgbWF4X3gsIG1heF95XTtcbn07XG4iLCIvLyBXZWJHTCBjb25zdGFudHMgLSBuZWVkIHRvIGltcG9ydCB0aGVzZSBzZXBhcmF0ZWx5IHRvIG1ha2UgdGhlbSBhdmFpbGFibGUgaW4gdGhlIHdlYiB3b3JrZXJcblxudmFyIGdsO1xuZXhwb3J0IGRlZmF1bHQgZ2wgPSB7fTtcblxuLyogRGF0YVR5cGUgKi9cbmdsLkJZVEUgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwMDtcbmdsLlVOU0lHTkVEX0JZVEUgICAgICAgICAgICAgICAgICA9IDB4MTQwMTtcbmdsLlNIT1JUICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwMjtcbmdsLlVOU0lHTkVEX1NIT1JUICAgICAgICAgICAgICAgICA9IDB4MTQwMztcbmdsLklOVCAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwNDtcbmdsLlVOU0lHTkVEX0lOVCAgICAgICAgICAgICAgICAgICA9IDB4MTQwNTtcbmdsLkZMT0FUICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwNjtcbiIsIi8vIFdlYkdMIGNvbnRleHQgd3JhcHBlclxuXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcblxudmFyIENvbnRleHQ7XG5leHBvcnQgZGVmYXVsdCBDb250ZXh0ID0ge307XG5cbi8vIFNldHVwIGEgV2ViR0wgY29udGV4dFxuLy8gSWYgbm8gY2FudmFzIGVsZW1lbnQgaXMgcHJvdmlkZWQsIG9uZSBpcyBjcmVhdGVkIGFuZCBhZGRlZCB0byB0aGUgZG9jdW1lbnQgYm9keVxuQ29udGV4dC5nZXRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q29udGV4dCAoY2FudmFzLCBvcHRpb25zKVxue1xuXG4gICAgdmFyIGZ1bGxzY3JlZW4gPSBmYWxzZTtcbiAgICBpZiAoY2FudmFzID09IG51bGwpIHtcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSAwO1xuICAgICAgICBjYW52YXMuc3R5bGUubGVmdCA9IDA7XG4gICAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAtMTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICBmdWxsc2NyZWVuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBvcHRpb25zKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgb3B0aW9ucyk7XG4gICAgaWYgKCFnbCkge1xuICAgICAgICBsb2cuZXJyb3IoXCJDb3VsZG4ndCBjcmVhdGUgV2ViR0wgY29udGV4dC4gWW91ciBicm93c2VyIHByb2JhYmx5IGRvZXNuJ3Qgc3VwcG9ydCBXZWJHTCBvciBpdCdzIHR1cm5lZCBvZmY/XCIpO1xuICAgICAgICBhbGVydChcIkNvdWxkbid0IGNyZWF0ZSBXZWJHTCBjb250ZXh0LiBZb3VyIGJyb3dzZXIgcHJvYmFibHkgZG9lc24ndCBzdXBwb3J0IFdlYkdMIG9yIGl0J3MgdHVybmVkIG9mZj9cIik7XG4gICAgICAgIHRocm93IFwiQ291bGRuJ3QgY3JlYXRlIFdlYkdMIGNvbnRleHRcIjtcbiAgICB9XG5cbiAgICBDb250ZXh0LnJlc2l6ZShnbCwgd2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgaWYgKGZ1bGxzY3JlZW4gPT09IHRydWUpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIENvbnRleHQucmVzaXplKGdsLCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdsO1xufTtcblxuQ29udGV4dC5yZXNpemUgPSBmdW5jdGlvbiAoZ2wsIHdpZHRoLCBoZWlnaHQpXG57XG4gICAgdmFyIGRldmljZV9waXhlbF9yYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgZ2wuY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIGdsLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIGdsLmNhbnZhcy53aWR0aCA9IE1hdGgucm91bmQoZ2wuY2FudmFzLnN0eWxlLndpZHRoICogZGV2aWNlX3BpeGVsX3JhdGlvKTtcbiAgICBnbC5jYW52YXMuaGVpZ2h0ID0gTWF0aC5yb3VuZChnbC5jYW52YXMuc3R5bGUud2lkdGggKiBkZXZpY2VfcGl4ZWxfcmF0aW8pO1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7XG59O1xuIiwidmFyIEdMU0wgPSB7fTtcbmV4cG9ydCBkZWZhdWx0IEdMU0w7XG5cbi8qKlxuICAgIFBhcnNlIHVuaWZvcm1zIGZyb20gYSBKUyBvYmplY3QsIGluZmVycyB0eXBlcyBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggdGhlXG4gICAgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIHRvIHNldCB1bmlmb3JtIHZhbHVlcyBvbiBhIEdMIHByb2dyYW0uIEVhY2ggb2JqZWN0IGluIHRoZSByZXR1cm5lZFxuICAgIGFycmF5IGhhcyB0aGUgZm9ybTpcbiAgICB7IHR5cGUsIG1ldGhvZCwgbmFtZSwgdmFsdWUgfVxuXG4gICAgdHlwZTogdGhlIEdMIHVuaWZvcm0gdHlwZSwgc3VjaCBhcyAndmVjMycsICdmbG9hdCcsIGV0Yy5cbiAgICBtZXRob2Q6IHRoZSBHTCB1bmlmb3JtIHNldHRlciBtZXRob2QgdG8gdXNlLCBzdWNoIGFzICcxZicsICczZnYnLCBldGMuXG4gICAgbmFtZTogdGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIG9mIHRoZSBHTCB1bmlmb3JtIGxvY2F0aW9uLCBlLmcuICdhcnJheVswXS5maWVsZCcsIGV0Yy5cbiAgICB2YWx1ZTogdGhlIHZhbHVlIHRvIGJlIHBhc3NlZCB0byB0aGUgR0wgdW5pZm9ybSBzZXR0ZXIgZm9yIHRoYXQgdHlwZSwgZS5nLiBbMSwgMiwgM10gZm9yIGEgdmVjM1xuXG4gICAgVGV4dHVyZXMgaGF2ZSBzcGVjaWFsIGJlaGF2aW9yOiB1bmlmb3JtcyB3aXRoIHN0cmluZyB2YWx1ZXMgYXJlIHRyZWF0ZWQgYXMgdGV4dHVyZXMsIGFuZFxuICAgIHRoZSBzdHJpbmcgaXMgdXNlZCBhcyBhIHVuaXF1ZSB0ZXh0dXJlICdrZXknIHRvIGJlIGludGVycHJldGVkIGJ5IHRoZSBjYWxsZXIgKHdoaWNoIGlzIHJlc3BvbnNpYmxlXG4gICAgZm9yIGFjdHVhbGx5IHNldHRpbmcgdGhlIHVuaWZvcm1zKS4gRm9yIGV4YW1wbGUsIHRoaXMgY291bGQgYmUgdXNlZCBhcyBhIGtleSBpbnRvIGEgZGljdGlvbmFyeSBvZlxuICAgIGtub3duIHRleHR1cmUgbmFtZXMsIG9yIGl0IGNvdWxkIHNpbXBseSBiZSB1c2VkIGFzIGEgVVJMIHRvIGR5bmFtaWNhbGx5IGxvYWQgdGhlIHRleHR1cmUgZnJvbS5cbiovXG5HTFNMLnBhcnNlVW5pZm9ybXMgPSBmdW5jdGlvbiAodW5pZm9ybXMsIHByZWZpeCA9IG51bGwpIHtcbiAgICB2YXIgcGFyc2VkID0gW107XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHVuaWZvcm1zKSB7XG4gICAgICAgIHZhciB1bmlmb3JtID0gdW5pZm9ybXNbbmFtZV07XG4gICAgICAgIHZhciB1O1xuXG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIG5hbWUgPSBwcmVmaXggKyAnLicgKyBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2luZ2xlIGZsb2F0XG4gICAgICAgIGlmICh0eXBlb2YgdW5pZm9ybSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJzFmJyxcbiAgICAgICAgICAgICAgICBuYW1lLCB2YWx1ZTpcbiAgICAgICAgICAgICAgICB1bmlmb3JtXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheTogdmVjdG9yLCBhcnJheSBvZiBmbG9hdHMsIGFycmF5IG9mIHRleHR1cmVzLCBvciBhcnJheSBvZiBzdHJ1Y3RzXG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodW5pZm9ybSkpIHtcbiAgICAgICAgICAgIC8vIE51bWVyaWMgdmFsdWVzXG4gICAgICAgICAgICBpZiAodHlwZW9mIHVuaWZvcm1bMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gZmxvYXQgdmVjdG9ycyAodmVjMiwgdmVjMywgdmVjNClcbiAgICAgICAgICAgICAgICBpZiAodW5pZm9ybS5sZW5ndGggPj0gMiAmJiB1bmlmb3JtLmxlbmd0aCA8PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd2ZWMnICsgdW5pZm9ybS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHVuaWZvcm0ubGVuZ3RoICsgJ2Z2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5pZm9ybVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZmxvYXQgYXJyYXlcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh1bmlmb3JtLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Zsb2F0W10nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnMWZ2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgKyAnWzBdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmlmb3JtXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhc3N1bWUgbWF0cml4IGZvciAodHlwZW9mID09IEZsb2F0MzJBcnJheSAmJiBsZW5ndGggPT0gMTYpP1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXJyYXkgb2YgdGV4dHVyZXNcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB1bmlmb3JtWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGZvciAodT0wOyB1IDwgdW5pZm9ybS5sZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc2FtcGxlcjJEJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJzFpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgKyAnWycgKyB1ICsgJ10nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuaWZvcm1bdV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXJyYXkgb2YgYXJyYXlzIC0gYnV0IG9ubHkgYXJyYXlzIG9mIHZlY3RvcnMgYXJlIGFsbG93ZWQgaW4gdGhpcyBjYXNlXG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHVuaWZvcm1bMF0pICYmIHR5cGVvZiB1bmlmb3JtWzBdWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIGZsb2F0IHZlY3RvcnMgKHZlYzIsIHZlYzMsIHZlYzQpXG4gICAgICAgICAgICAgICAgaWYgKHVuaWZvcm1bMF0ubGVuZ3RoID49IDIgJiYgdW5pZm9ybVswXS5sZW5ndGggPD0gNCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGZvciAodT0wOyB1IDwgdW5pZm9ybS5sZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd2ZWMnICsgdW5pZm9ybVswXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiB1bmlmb3JtW3VdLmxlbmd0aCArICdmdicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSArICdbJyArIHUgKyAnXScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuaWZvcm1bdV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVsc2UgZXJyb3I/XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBcnJheSBvZiBzdHJ1Y3R1cmVzXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdW5pZm9ybVswXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHU9MDsgdSA8IHVuaWZvcm0ubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGVhY2ggc3RydWN0IGluIHRoZSBhcnJheVxuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucHVzaCguLi5HTFNMLnBhcnNlVW5pZm9ybXModW5pZm9ybVt1XSwgbmFtZSArICdbJyArIHUgKyAnXScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQm9vbGVhblxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdW5pZm9ybSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBwYXJzZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJzFpJyxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmlmb3JtXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXh0dXJlXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB1bmlmb3JtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzYW1wbGVyMkQnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJzFpJyxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmlmb3JtXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJ1Y3R1cmVcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHVuaWZvcm0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBTZXQgZWFjaCBmaWVsZCBpbiB0aGUgc3RydWN0XG4gICAgICAgICAgICBwYXJzZWQucHVzaCguLi5HTFNMLnBhcnNlVW5pZm9ybXModW5pZm9ybSwgbmFtZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBvdGhlciBub24tZmxvYXQgdHlwZXM/IChpbnQsIGV0Yy4pXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbi8qKlxuICAgIEdlbmVyYXRlIGEgR0xTTCB2YXJpYWJsZSBkZWZpbml0aW9uIGZyb20gYSBKUyBvYmplY3RcbiovXG5HTFNMLmRlZmluZVZhcmlhYmxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBwcmVmaXggPSBudWxsKSB7XG4gICAgdmFyIHR5cGUsIGFycmF5O1xuICAgIHZhciBzdHJ1Y3RzID0gJyc7XG4gICAgcHJlZml4ID0gcHJlZml4ID8gcHJlZml4ICsgJ18nICsgbmFtZSA6IG5hbWU7XG5cbiAgICAvLyBTaW5nbGUgZmxvYXRcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICB0eXBlID0gJ2Zsb2F0JztcbiAgICB9XG4gICAgLy8gTXVsdGlwbGUgZmxvYXRzIC0gdmVjdG9yIG9yIGFycmF5XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgLy8gTnVtZXJpYyB2YWx1ZXNcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVswXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGZsb2F0IHZlY3RvcnMgKHZlYzIsIHZlYzMsIHZlYzQpXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID49IDIgJiYgdmFsdWUubGVuZ3RoIDw9IDQpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ3ZlYycgKyB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmbG9hdCBhcnJheVxuICAgICAgICAgICAgZWxzZSB7IC8vaWYgKHZhbHVlLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2Zsb2F0JztcbiAgICAgICAgICAgICAgICBhcnJheSA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IGFzc3VtZSBtYXRyaXggZm9yICh0eXBlb2YgPT0gRmxvYXQzMkFycmF5ICYmIGxlbmd0aCA9PSAxNik/XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXkgb2YgdGV4dHVyZXNcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHlwZSA9ICdzYW1wbGVyMkQnO1xuICAgICAgICAgICAgYXJyYXkgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXkgb2YgYXJyYXlzIC0gYnV0IG9ubHkgYXJyYXlzIG9mIHZlY3RvcnMgYXJlIGFsbG93ZWQgaW4gdGhpcyBjYXNlXG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVbMF0pICYmIHR5cGVvZiB2YWx1ZVswXVswXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGZsb2F0IHZlY3RvcnMgKHZlYzIsIHZlYzMsIHZlYzQpXG4gICAgICAgICAgICBpZiAodmFsdWVbMF0ubGVuZ3RoID49IDIgJiYgdmFsdWVbMF0ubGVuZ3RoIDw9IDQpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ3ZlYycgKyB2YWx1ZVswXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlIGVycm9yP1xuICAgICAgICAgICAgYXJyYXkgPSB2YWx1ZVswXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXkgb2Ygc3RydWN0dXJlc1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWVbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0eXBlID0gJ190eXBlXycgKyBwcmVmaXg7IC8vIGN1c3RvbSBzdHJ1Y3QgbmFtZVxuICAgICAgICAgICAgYXJyYXkgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBzdHJ1Y3RzICs9IEdMU0wuZGVmaW5lU3RydWN0KHR5cGUsIHZhbHVlWzBdLCBwcmVmaXgpICsgJ1xcbic7IC8vIGJ1aWxkICYgYWRkIHRvIGxpc3Qgb2YgZGVwZW5kZW50IHN0cnVjdHNcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBCb29sZWFuXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdHlwZSA9ICdib29sJztcbiAgICB9XG4gICAgLy8gVGV4dHVyZVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHlwZSA9ICdzYW1wbGVyMkQnO1xuICAgIH1cbiAgICAvLyBTdHJ1Y3R1cmVcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHR5cGUgPSAnX3R5cGVfJyArIHByZWZpeDsgLy8gY3VzdG9tIHN0cnVjdCBuYW1lXG4gICAgICAgIHN0cnVjdHMgKz0gR0xTTC5kZWZpbmVTdHJ1Y3QodHlwZSwgdmFsdWUsIHByZWZpeCkgKyAnXFxuJzsgLy8gYnVpbGQgJiBhZGQgdG8gbGlzdCBvZiBkZXBlbmRlbnQgc3RydWN0c1xuICAgIH1cblxuICAgIC8vIENvbnN0cnVjdCB2YXJpYWJsZSBkZWZpbml0aW9uXG4gICAgdmFyIHZhcmlhYmxlID0gJyc7XG4gICAgdmFyaWFibGUgKz0gYCR7dHlwZX0gJHtuYW1lfWA7XG4gICAgaWYgKGFycmF5KSB7XG4gICAgICAgIHZhcmlhYmxlICs9IGBbJHthcnJheX1dYDtcbiAgICB9XG4gICAgdmFyaWFibGUgKz0gJztcXG4nO1xuXG4gICAgLy8gUmV0dXJuIHRoZSB2YXJpYWJsZSBkZWZpbml0aW9uIGl0c2VsZiwgYW5kIGFueSBkZXBlbmRlbnQgc3RydWN0IGRlZmluaXRpb25zXG4gICAgcmV0dXJuIHsgdmFyaWFibGUsIHN0cnVjdHMgfTtcbn07XG5cbi8qKlxuICAgIEdlbmVyYXRlIGEgR0xTTCBzdHJ1Y3R1cmUgZGVmaW5pdGlvbiBmcm9tIGEgSlMgb2JqZWN0XG4qL1xuR0xTTC5kZWZpbmVTdHJ1Y3QgPSBmdW5jdGlvbiAodHlwZSwgdmFsdWUsIHByZWZpeCA9IG51bGwpIHtcbiAgICB2YXIgc3RydWN0ID0gYHN0cnVjdCAke3R5cGV9IHtcXG5gO1xuICAgIHZhciBkZXBlbmRlbnRzID0gJyc7XG4gICAgZm9yICh2YXIgZmllbGQgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFyIHN1YnZhciA9IEdMU0wuZGVmaW5lVmFyaWFibGUoZmllbGQsIHZhbHVlW2ZpZWxkXSwgcHJlZml4KTtcbiAgICAgICAgc3RydWN0ICs9ICcgICAgJyArIHN1YnZhci52YXJpYWJsZTtcbiAgICAgICAgZGVwZW5kZW50cyArPSBzdWJ2YXIuc3RydWN0cztcbiAgICB9XG4gICAgc3RydWN0ICs9ICd9O1xcbic7XG4gICAgc3RydWN0ID0gZGVwZW5kZW50cyArIHN0cnVjdDtcbiAgICByZXR1cm4gc3RydWN0O1xufTtcblxuLyoqXG4gICAgR2VuZXJhdGUgYSBHTFNMIHVuaWZvcm0gZGVmaW5pdGlvbiBmcm9tIGEgSlMgb2JqZWN0XG4qL1xuR0xTTC5kZWZpbmVVbmlmb3JtID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGRlZiA9IEdMU0wuZGVmaW5lVmFyaWFibGUobmFtZSwgdmFsdWUpO1xuICAgIGRlZiA9IGRlZi5zdHJ1Y3RzICsgJ3VuaWZvcm0gJyArIGRlZi52YXJpYWJsZTtcbiAgICByZXR1cm4gZGVmO1xufTtcblxuLyoqXG4gICAgQ2hlY2sgZm9yIGEgdW5pZm9ybSBkZWZpbml0aW9uIG9mICduYW1lJyBpbiB0aGUgcHJvdmlkZWQgR0xTTCBzb3VyY2VcbiAgICBTaW1wbGUgcmVnZXggY2hlY2sgZm9yICd1bmlmb3JtJyBrZXl3b3JkIGFuZCB2YXIgbmFtZSwgZG9lcyBub3QgYXR0ZW1wdCB0byBwYXJzZS9leHRyYWN0IEdMU0xcbiAgICBOT1RFOiBhc3N1bWVzIGNvbW1lbnRzIGhhdmUgYmVlbiBzdHJpcHBlZCBmcm9tIHNvdXJjZVxuKi9cbkdMU0wuaXNVbmlmb3JtRGVmaW5lZCA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2UpIHtcbiAgICAvLyBNYXRjaCwgaW4gb3JkZXI6XG4gICAgLy8gLSB0aGUga2V5d29yZCAndW5pZm9ybSdcbiAgICAvLyAtIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgdGhhdCBpcyBhbnl0aGluZyBleGNlcHQgYSBzZW1pY29sb24sIDtcbiAgICAvLyAtIG9wdGlvbmFsbHksIGFueXRoaW5nIGVuY2xvc2VkIGluIGN1cmx5IGJyYWNlcywgeyAuLi4gfSAoYW4gaW5saW5lIHN0cnVjdHVyZSBkZWZpbml0aW9uIGNhbiBnbyBoZXJlKVxuICAgIC8vIC0gb3B0aW9uYWxseSwgYW55ICMgb2YgY2hhcmFjdGVycyB0aGF0IGlzIG5vdCBhIHNlbWljb2xvbiwgO1xuICAgIC8vIC0gdGhlIG5hbWUgb2YgdGhlIHVuaWZvcm1cblxuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoJ3VuaWZvcm1bXjtdKyg/OntbXFxcXHNcXFxcU10qfSk/W147XSpcXFxcYicgKyBuYW1lICsgJ1xcXFxiJywgJ2cnKTtcbiAgICBpZiAoc291cmNlLm1hdGNoKHJlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gICAgQ2hlY2sgdGhhdCBhIHN5bWJvbCBpcyByZWZlcmVuY2VkIGluIHRoZSBHTFNMIHNvdXJjZVxuICAgIE5PVEU6IGFzc3VtZXMgY29tbWVudHMgaGF2ZSBiZWVuIHN0cmlwcGVkIGZyb20gc291cmNlXG4qL1xuR0xTTC5pc1N5bWJvbFJlZmVyZW5jZWQgPSBmdW5jdGlvbiAobmFtZSwgc291cmNlKSB7XG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgbmFtZSArICdcXFxcYicsICdnJyk7XG4gICAgaWYgKHNvdXJjZS5zZWFyY2gocmUpID49IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICAgIEV4cGFuZCBhIHNpbmdsZSB2YWx1ZSBvciAzLWVsZW1lbnQgYXJyYXkgaW50byBhIDQtZWxlbWVudCBhcnJheSwgd2l0aCB0aGUgbGFzdCAoZS5nLiB3IG9yIGEpXG4gICAgY29vcmRpbmF0ZSBkZWZhdWx0aW5nIHRvIDEgKHdpdGggb3B0aW9uIHRvIHNwZWNpZnkpLiBBbHNvIHJ1bnMgcGFyc2VGbG9hdCB0byB0cnkgdG8gbWFpbnRhaW5cbiAgICBkYXRhIGludGVncml0eS4gUmV0dXJucyBudWxsIGlmIGlucHV0IGNvdWxkbid0IGJlIHBhcnNlZC5cbiovXG5HTFNMLmV4cGFuZFZlYzQgPSBmdW5jdGlvbiAodiwgdyA9IDEpIHtcbiAgICBsZXQgeDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSAmJiB2Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICB4ID0gWy4uLnYsIHddLm1hcChwYXJzZUZsb2F0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHggPSBbdiwgdiwgdiwgd10ubWFwKHBhcnNlRmxvYXQpO1xuICAgIH1cblxuICAgIGlmICh4ICYmIHguZXZlcnkobiA9PiB0eXBlb2YgbiA9PT0gJ251bWJlcicgJiYgIWlzTmFOKG4pKSkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG59O1xuIiwiLyogZ2xvYmFsIFNoYWRlclByb2dyYW0gKi9cbi8vIEdMIHByb2dyYW0gd3JhcHBlciB0byBjYWNoZSB1bmlmb3JtIGxvY2F0aW9ucy92YWx1ZXMsIGRvIGNvbXBpbGUtdGltZSBwcmUtcHJvY2Vzc2luZ1xuLy8gKGluamVjdGluZyAjZGVmaW5lcyBhbmQgI3ByYWdtYSB0cmFuc2Zvcm1zIGludG8gc2hhZGVycyksIGV0Yy5cblxuaW1wb3J0IEdMU0wgZnJvbSAnLi9nbHNsJztcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4vdGV4dHVyZSc7XG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHN0cmlwIGZyb20gJ3N0cmlwLWNvbW1lbnRzJztcblxuU2hhZGVyUHJvZ3JhbS5pZCA9IDA7IC8vIGFzc2lnbiBlYWNoIHByb2dyYW0gYSB1bmlxdWUgaWRcblNoYWRlclByb2dyYW0ucHJvZ3JhbXMgPSB7fTsgLy8gcHJvZ3JhbXMsIGJ5IGlkXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNoYWRlclByb2dyYW0gKGdsLCB2ZXJ0ZXhfc291cmNlLCBmcmFnbWVudF9zb3VyY2UsIG9wdGlvbnMpXG57XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICB0aGlzLmNvbXBpbGVkID0gZmFsc2U7XG4gICAgdGhpcy5jb21waWxpbmcgPSBmYWxzZTtcblxuICAgIC8vIGtleS92YWx1ZXMgaW5zZXJ0ZWQgYXMgI2RlZmluZXMgaW50byBzaGFkZXJzIGF0IGNvbXBpbGUtdGltZVxuICAgIHRoaXMuZGVmaW5lcyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuZGVmaW5lc3x8e30pO1xuXG4gICAgLy8ga2V5L3ZhbHVlcyBmb3IgYmxvY2tzIHRoYXQgY2FuIGJlIGluamVjdGVkIGludG8gc2hhZGVycyBhdCBjb21waWxlLXRpbWVcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnRyYW5zZm9ybXN8fHt9KTtcblxuICAgIC8vIEpTLW9iamVjdCB1bmlmb3JtcyB0aGF0IGFyZSBleHBlY3RlZCBieSB0aGlzIHByb2dyYW1cbiAgICAvLyBJZiB0aGV5IGFyZSBub3QgZm91bmQgaW4gdGhlIGV4aXN0aW5nIHNoYWRlciBzb3VyY2UsIHRoZWlyIHR5cGVzIHdpbGwgYmUgaW5mZXJyZWQgYW5kIGRlZmluaXRpb25zXG4gICAgLy8gZm9yIGVhY2ggd2lsbCBiZSBpbmplY3RlZC5cbiAgICB0aGlzLmRlcGVuZGVudF91bmlmb3JtcyA9IG9wdGlvbnMudW5pZm9ybXM7XG5cbiAgICB0aGlzLnVuaWZvcm1zID0ge307IC8vIHByb2dyYW0gbG9jYXRpb25zIG9mIHVuaWZvcm1zLCBsYXppbHkgYWRkZWQgYXMgZWFjaCB1bmlmb3JtIGlzIHNldFxuICAgIHRoaXMuYXR0cmlicyA9IHt9OyAvLyBwcm9ncmFtIGxvY2F0aW9ucyBvZiB2ZXJ0ZXggYXR0cmlidXRlcywgbGF6aWx5IGFkZGVkIGFzIGVhY2ggYXR0cmlidXRlIGlzIGFjY2Vzc2VkXG5cbiAgICB0aGlzLnZlcnRleF9zb3VyY2UgPSB2ZXJ0ZXhfc291cmNlO1xuICAgIHRoaXMuZnJhZ21lbnRfc291cmNlID0gZnJhZ21lbnRfc291cmNlO1xuXG4gICAgdGhpcy5pZCA9IFNoYWRlclByb2dyYW0uaWQrKztcbiAgICBTaGFkZXJQcm9ncmFtLnByb2dyYW1zW3RoaXMuaWRdID0gdGhpcztcbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7IC8vIGNhbiBwcm92aWRlIGEgcHJvZ3JhbSBuYW1lICh1c2VmdWwgZm9yIGRlYnVnZ2luZylcblxuICAgIHRoaXMuY29tcGlsZSgpO1xufVxuXG5TaGFkZXJQcm9ncmFtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZ2wudXNlUHJvZ3JhbShudWxsKTtcbiAgICB0aGlzLmdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgIHRoaXMudW5pZm9ybXMgPSB7fTtcbiAgICB0aGlzLmF0dHJpYnMgPSB7fTtcbiAgICBkZWxldGUgU2hhZGVyUHJvZ3JhbS5wcm9ncmFtc1t0aGlzLmlkXTtcbiAgICB0aGlzLmNvbXBpbGVkID0gZmFsc2U7XG59O1xuXG4vLyBVc2UgcHJvZ3JhbSB3cmFwcGVyIHdpdGggc2ltcGxlIHN0YXRlIGNhY2hlXG5TaGFkZXJQcm9ncmFtLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICghdGhpcy5jb21waWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFNoYWRlclByb2dyYW0uY3VycmVudCAhPT0gdGhpcykge1xuICAgICAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICB9XG4gICAgU2hhZGVyUHJvZ3JhbS5jdXJyZW50ID0gdGhpcztcbn07XG5TaGFkZXJQcm9ncmFtLmN1cnJlbnQgPSBudWxsO1xuXG4vLyBHbG9iYWwgY29uZmlnIGFwcGxpZWQgdG8gYWxsIHByb2dyYW1zIChkdXBsaWNhdGUgcHJvcGVydGllcyBmb3IgYSBzcGVjaWZpYyBwcm9ncmFtIHdpbGwgdGFrZSBwcmVjZWRlbmNlKVxuU2hhZGVyUHJvZ3JhbS5kZWZpbmVzID0ge307XG5TaGFkZXJQcm9ncmFtLnRyYW5zZm9ybXMgPSB7fTtcblxuU2hhZGVyUHJvZ3JhbS5hZGRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoa2V5LCAuLi50cmFuc2Zvcm1zKSB7XG4gICAgU2hhZGVyUHJvZ3JhbS50cmFuc2Zvcm1zW2tleV0gPSBTaGFkZXJQcm9ncmFtLnRyYW5zZm9ybXNba2V5XSB8fCBbXTtcbiAgICBTaGFkZXJQcm9ncmFtLnRyYW5zZm9ybXNba2V5XS5wdXNoKC4uLnRyYW5zZm9ybXMpO1xufTtcblxuLy8gUmVtb3ZlIGFsbCBnbG9iYWwgc2hhZGVyIHRyYW5zZm9ybXMgZm9yIGEgZ2l2ZW4ga2V5XG5TaGFkZXJQcm9ncmFtLnJlbW92ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBTaGFkZXJQcm9ncmFtLnRyYW5zZm9ybXNba2V5XSA9IFtdO1xufTtcblxuU2hhZGVyUHJvZ3JhbS5yZXBsYWNlVHJhbnNmb3JtID0gZnVuY3Rpb24gKGtleSwgLi4udHJhbnNmb3Jtcykge1xuICAgIFNoYWRlclByb2dyYW0ucmVtb3ZlVHJhbnNmb3JtKGtleSk7XG4gICAgU2hhZGVyUHJvZ3JhbS5hZGRUcmFuc2Zvcm0oa2V5LCAuLi50cmFuc2Zvcm1zKTtcbn07XG5cblNoYWRlclByb2dyYW0ucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAodGhpcy5jb21waWxpbmcpIHtcbiAgICAgICAgdGhyb3cobmV3IEVycm9yKGBTaGFkZXJQcm9ncmFtLmNvbXBpbGUoKTogc2tpcHBpbmcgZm9yICR7dGhpcy5pZH0gKCR7dGhpcy5uYW1lfSkgYmVjYXVzZSBhbHJlYWR5IGNvbXBpbGluZ2ApKTtcbiAgICB9XG4gICAgdGhpcy5jb21waWxpbmcgPSB0cnVlO1xuICAgIHRoaXMuY29tcGlsZWQgPSBmYWxzZTtcblxuICAgIC8vIENvcHkgc291cmNlcyBmcm9tIHByZS1tb2RpZmllZCB0ZW1wbGF0ZVxuICAgIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZSA9IHRoaXMudmVydGV4X3NvdXJjZTtcbiAgICB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZSA9IHRoaXMuZnJhZ21lbnRfc291cmNlO1xuXG4gICAgLy8gTWFrZSBsaXN0IG9mIGRlZmluZXMgdG8gYmUgaW5qZWN0ZWQgbGF0ZXJcbiAgICB2YXIgZGVmaW5lcyA9IHRoaXMuYnVpbGREZWZpbmVMaXN0KCk7XG5cbiAgICAvLyBJbmplY3QgdXNlci1kZWZpbmVkIHRyYW5zZm9ybXMgKGFyYml0cmFyeSBjb2RlIHBvaW50cyBtYXRjaGluZyBuYW1lZCAjcHJhZ21hcylcbiAgICAvLyBSZXBsYWNlIGFjY29yZGluZyB0byB0aGlzIHBhdHRlcm46XG4gICAgLy8gI3ByYWdtYSB0YW5ncmFtOiBba2V5XVxuICAgIC8vIGUuZy4gI3ByYWdtYSB0YW5ncmFtOiBnbG9iYWxzXG5cbiAgICAvLyBHYXRoZXIgYWxsIHRyYW5zZm9ybSBjb2RlIHNuaXBwZXRzXG4gICAgdmFyIHRyYW5zZm9ybXMgPSB0aGlzLmJ1aWxkU2hhZGVyVHJhbnNmb3JtTGlzdCgpO1xuICAgIHZhciByZWdleHA7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdHJhbnNmb3Jtcykge1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gdHJhbnNmb3Jtc1trZXldO1xuICAgICAgICBpZiAoIXRyYW5zZm9ybSB8fCAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm0pICYmIHRyYW5zZm9ybS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpcnN0IGZpbmQgY29kZSByZXBsYWNlIHBvaW50cyBpbiBzaGFkZXJzXG4gICAgICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJ15cXFxccyojcHJhZ21hXFxcXHMrdGFuZ3JhbTpcXFxccysnICsga2V5ICsgJ1xcXFxzKiQnLCAnbScpO1xuICAgICAgICB2YXIgaW5qZWN0X3ZlcnRleCA9IHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZS5tYXRjaChyZWdleHApO1xuICAgICAgICB2YXIgaW5qZWN0X2ZyYWdtZW50ID0gdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2UubWF0Y2gocmVnZXhwKTtcblxuICAgICAgICAvLyBBdm9pZCBuZXR3b3JrIHJlcXVlc3QgaWYgbm90aGluZyB0byByZXBsYWNlXG4gICAgICAgIGlmIChpbmplY3RfdmVydGV4ID09IG51bGwgJiYgaW5qZWN0X2ZyYWdtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRWFjaCBrZXkgY2FuIGJlIGEgc2luZ2xlIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzXG4gICAgICAgIHZhciBzb3VyY2UgPSB0cmFuc2Zvcm07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybSkpIHtcbiAgICAgICAgICAgIC8vIENvbWJpbmUgYWxsIHRyYW5zZm9ybXMgaW50byBvbmUgc3RyaW5nXG4gICAgICAgICAgICBzb3VyY2UgPSB0cmFuc2Zvcm0ucmVkdWNlKChwcmV2LCBjdXIpID0+IGAke3ByZXZ9XFxuJHtjdXJ9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbmplY3RcbiAgICAgICAgaWYgKGluamVjdF92ZXJ0ZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlID0gdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlLnJlcGxhY2UocmVnZXhwLCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmplY3RfZnJhZ21lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2UgPSB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZS5yZXBsYWNlKHJlZ2V4cCwgc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBhICNkZWZpbmUgZm9yIHRoaXMgaW5qZWN0aW9uIHBvaW50XG4gICAgICAgIGRlZmluZXNbJ1RBTkdSQU1fVFJBTlNGT1JNXycgKyBrZXkucmVwbGFjZSgnICcsICdfJykudG9VcHBlckNhc2UoKV0gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIENsZWFuLXVwIGFueSAjcHJhZ21hcyB0aGF0IHdlcmVuJ3QgcmVwbGFjZWQgKHRvIHByZXZlbnQgY29tcGlsZXIgd2FybmluZ3MpXG4gICAgcmVnZXhwID0gbmV3IFJlZ0V4cCgnXlxcXFxzKiNwcmFnbWFcXFxccyt0YW5ncmFtOlxcXFxzK1xcXFx3K1xcXFxzKiQnLCAnZ20nKTtcbiAgICB0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2UgPSB0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2UucmVwbGFjZShyZWdleHAsICcnKTtcbiAgICB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZSA9IHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlLnJlcGxhY2UocmVnZXhwLCAnJyk7XG5cbiAgICAvLyBCdWlsZCAmIGluamVjdCBkZWZpbmVzXG4gICAgLy8gVGhpcyBpcyBkb25lICphZnRlciogY29kZSBpbmplY3Rpb24gc28gdGhhdCB3ZSBjYW4gYWRkIGRlZmluZXMgZm9yIHdoaWNoIGNvZGUgcG9pbnRzIHdlcmUgaW5qZWN0ZWRcbiAgICB2YXIgZGVmaW5lX3N0ciA9IFNoYWRlclByb2dyYW0uYnVpbGREZWZpbmVTdHJpbmcoZGVmaW5lcyk7XG4gICAgdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlID0gZGVmaW5lX3N0ciArIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZTtcbiAgICB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZSA9IGRlZmluZV9zdHIgKyB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZTtcblxuICAgIC8vIERldGVjdCB1bmlmb3JtIGRlZmluaXRpb25zLCBpbmplY3QgYW55IG1pc3Npbmcgb25lc1xuICAgIHRoaXMuZW5zdXJlVW5pZm9ybXModGhpcy5kZXBlbmRlbnRfdW5pZm9ybXMpO1xuXG4gICAgLy8gSW5jbHVkZSBwcm9ncmFtIGluZm8gdXNlZnVsIGZvciBkZWJ1Z2dpbmdcbiAgICB2YXIgaW5mbyA9ICh0aGlzLm5hbWUgPyAodGhpcy5uYW1lICsgJyAvIGlkICcgKyB0aGlzLmlkKSA6ICgnaWQgJyArIHRoaXMuaWQpKTtcbiAgICB0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2UgPSAnLy8gUHJvZ3JhbTogJyArIGluZm8gKyAnXFxuJyArIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZTtcbiAgICB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZSA9ICcvLyBQcm9ncmFtOiAnICsgaW5mbyArICdcXG4nICsgdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2U7XG5cbiAgICAvLyBDb21waWxlICYgc2V0IHVuaWZvcm1zIHRvIGNhY2hlZCB2YWx1ZXNcbiAgICB0cnkge1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBTaGFkZXJQcm9ncmFtLnVwZGF0ZVByb2dyYW0odGhpcy5nbCwgdGhpcy5wcm9ncmFtLCB0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2UsIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlKTtcbiAgICAgICAgdGhpcy5jb21waWxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY29tcGlsaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGNhdGNoKGVycm9yKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tcGlsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb21waWxpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhyb3cobmV3IEVycm9yKGBTaGFkZXJQcm9ncmFtLmNvbXBpbGUoKTogcHJvZ3JhbSAke3RoaXMuaWR9ICgke3RoaXMubmFtZX0pIGVycm9yOmAsIGVycm9yKSk7XG4gICAgfVxuXG4gICAgdGhpcy51c2UoKTtcbiAgICB0aGlzLnJlZnJlc2hVbmlmb3JtcygpO1xuICAgIHRoaXMucmVmcmVzaEF0dHJpYnV0ZXMoKTtcbn07XG5cbi8vIE1ha2UgbGlzdCBvZiBkZWZpbmVzIChnbG9iYWwsIHRoZW4gcHJvZ3JhbS1zcGVjaWZpYylcblNoYWRlclByb2dyYW0ucHJvdG90eXBlLmJ1aWxkRGVmaW5lTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZCwgZGVmaW5lcyA9IHt9O1xuICAgIGZvciAoZCBpbiBTaGFkZXJQcm9ncmFtLmRlZmluZXMpIHtcbiAgICAgICAgZGVmaW5lc1tkXSA9IFNoYWRlclByb2dyYW0uZGVmaW5lc1tkXTtcbiAgICB9XG4gICAgZm9yIChkIGluIHRoaXMuZGVmaW5lcykge1xuICAgICAgICBkZWZpbmVzW2RdID0gdGhpcy5kZWZpbmVzW2RdO1xuICAgIH1cbiAgICByZXR1cm4gZGVmaW5lcztcbn07XG5cbi8vIE1ha2UgbGlzdCBvZiBzaGFkZXIgdHJhbnNmb3JtcyAoZ2xvYmFsLCB0aGVuIHByb2dyYW0tc3BlY2lmaWMpXG5TaGFkZXJQcm9ncmFtLnByb3RvdHlwZS5idWlsZFNoYWRlclRyYW5zZm9ybUxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGQsIHRyYW5zZm9ybXMgPSB7fTtcbiAgICBmb3IgKGQgaW4gU2hhZGVyUHJvZ3JhbS50cmFuc2Zvcm1zKSB7XG4gICAgICAgIHRyYW5zZm9ybXNbZF0gPSBbXTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShTaGFkZXJQcm9ncmFtLnRyYW5zZm9ybXNbZF0pKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1zW2RdLnB1c2goLi4uU2hhZGVyUHJvZ3JhbS50cmFuc2Zvcm1zW2RdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybXNbZF0gPSBbU2hhZGVyUHJvZ3JhbS50cmFuc2Zvcm1zW2RdXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGQgaW4gdGhpcy50cmFuc2Zvcm1zKSB7XG4gICAgICAgIHRyYW5zZm9ybXNbZF0gPSB0cmFuc2Zvcm1zW2RdIHx8IFtdO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMudHJhbnNmb3Jtc1tkXSkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybXNbZF0ucHVzaCguLi50aGlzLnRyYW5zZm9ybXNbZF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJhbnNmb3Jtc1tkXS5wdXNoKHRoaXMudHJhbnNmb3Jtc1tkXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZm9ybXM7XG59O1xuXG4vLyBUdXJuICNkZWZpbmVzIGludG8gYSBjb21iaW5lZCBzdHJpbmdcblNoYWRlclByb2dyYW0uYnVpbGREZWZpbmVTdHJpbmcgPSBmdW5jdGlvbiAoZGVmaW5lcykge1xuICAgIHZhciBkZWZpbmVfc3RyID0gXCJcIjtcbiAgICBmb3IgKHZhciBkIGluIGRlZmluZXMpIHtcbiAgICAgICAgaWYgKGRlZmluZXNbZF0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lc1tkXSA9PT0gJ2Jvb2xlYW4nICYmIGRlZmluZXNbZF0gPT09IHRydWUpIHsgLy8gYm9vbGVhbnMgYXJlIHNpbXBsZSBkZWZpbmVzIHdpdGggbm8gdmFsdWVcbiAgICAgICAgICAgIGRlZmluZV9zdHIgKz0gXCIjZGVmaW5lIFwiICsgZCArIFwiXFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZXNbZF0gPT09ICdudW1iZXInICYmIE1hdGguZmxvb3IoZGVmaW5lc1tkXSkgPT09IGRlZmluZXNbZF0pIHsgLy8gaW50IHRvIGZsb2F0IGNvbnZlcnNpb24gdG8gc2F0aXNmeSBHTFNMIGZsb2F0c1xuICAgICAgICAgICAgZGVmaW5lX3N0ciArPSBcIiNkZWZpbmUgXCIgKyBkICsgXCIgXCIgKyBkZWZpbmVzW2RdLnRvRml4ZWQoMSkgKyBcIlxcblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBhbnkgb3RoZXIgZmxvYXQgb3Igc3RyaW5nIHZhbHVlXG4gICAgICAgICAgICBkZWZpbmVfc3RyICs9IFwiI2RlZmluZSBcIiArIGQgKyBcIiBcIiArIGRlZmluZXNbZF0gKyBcIlxcblwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWZpbmVfc3RyO1xufTtcblxuLy8gRGV0ZWN0IHVuaWZvcm0gZGVmaW5pdGlvbnMsIGluamVjdCBhbnkgbWlzc2luZyBvbmVzXG5TaGFkZXJQcm9ncmFtLnByb3RvdHlwZS5lbnN1cmVVbmlmb3JtcyA9IGZ1bmN0aW9uICh1bmlmb3Jtcykge1xuICAgIGlmICghdW5pZm9ybXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB2cyA9IHN0cmlwKHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZSk7XG4gICAgdmFyIGZzID0gc3RyaXAodGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2UpO1xuICAgIHZhciBpbmplY3QsIHZzX2luamVjdGlvbnMgPSBbXSwgZnNfaW5qZWN0aW9ucyA9IFtdO1xuXG4gICAgLy8gQ2hlY2sgZm9yIG1pc3NpbmcgdW5pZm9ybSBkZWZpbml0aW9uc1xuICAgIGZvciAodmFyIG5hbWUgaW4gdW5pZm9ybXMpIHtcbiAgICAgICAgaW5qZWN0ID0gbnVsbDtcblxuICAgICAgICAvLyBDaGVjayB2ZXJ0ZXggc2hhZGVyXG4gICAgICAgIGlmICghR0xTTC5pc1VuaWZvcm1EZWZpbmVkKG5hbWUsIHZzKSAmJiBHTFNMLmlzU3ltYm9sUmVmZXJlbmNlZChuYW1lLCB2cykpIHtcbiAgICAgICAgICAgIGlmICghaW5qZWN0KSB7XG4gICAgICAgICAgICAgICAgaW5qZWN0ID0gR0xTTC5kZWZpbmVVbmlmb3JtKG5hbWUsIHVuaWZvcm1zW25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZy50cmFjZShgUHJvZ3JhbSAke3RoaXMubmFtZX06ICR7bmFtZX0gbm90IGRlZmluZWQgaW4gdmVydGV4IHNoYWRlciwgaW5qZWN0aW5nOiAnJHtpbmplY3R9J2ApO1xuICAgICAgICAgICAgdnNfaW5qZWN0aW9ucy5wdXNoKGluamVjdCk7XG5cbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmcmFnbWVudCBzaGFkZXJcbiAgICAgICAgaWYgKCFHTFNMLmlzVW5pZm9ybURlZmluZWQobmFtZSwgZnMpICYmIEdMU0wuaXNTeW1ib2xSZWZlcmVuY2VkKG5hbWUsIGZzKSkge1xuICAgICAgICAgICAgaWYgKCFpbmplY3QpIHtcbiAgICAgICAgICAgICAgICBpbmplY3QgPSBHTFNMLmRlZmluZVVuaWZvcm0obmFtZSwgdW5pZm9ybXNbbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nLnRyYWNlKGBQcm9ncmFtICR7dGhpcy5uYW1lfTogJHtuYW1lfSBub3QgZGVmaW5lZCBpbiBmcmFnbWVudCBzaGFkZXIsIGluamVjdGluZzogJyR7aW5qZWN0fSdgKTtcbiAgICAgICAgICAgIGZzX2luamVjdGlvbnMucHVzaChpbmplY3QpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW5qZWN0IG1pc3NpbmcgdW5pZm9ybXNcbiAgICAvLyBOT1RFOiB0aGVzZSBhcmUgaW5qZWN0ZWQgYXQgdGhlIHZlcnkgdG9wIG9mIHRoZSBzaGFkZXJzLCBldmVuIGJlZm9yZSBhbnkgI2RlZmluZXMgb3IgI3ByYWdtYXMgYXJlIGFkZGVkXG4gICAgLy8gdGhpcyBjb3VsZCBjYXVzZSBzb21lIGlzc3VlcyB3aXRoIGNlcnRhaW4gI3ByYWdtYXMsIG9yIG90aGVyIGZ1bmN0aW9ucyB0aGF0IG1pZ2h0IGV4cGVjdCAjZGVmaW5lc1xuICAgIGlmICh2c19pbmplY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlID0gdnNfaW5qZWN0aW9ucy5qb2luKCdcXG4nKSArIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZTtcbiAgICB9XG5cbiAgICBpZiAoZnNfaW5qZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlID0gZnNfaW5qZWN0aW9ucy5qb2luKCdcXG4nKSArIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlO1xuICAgIH1cbn07XG5cbi8vIFNldCB1bmlmb3JtcyBmcm9tIGEgSlMgb2JqZWN0LCB3aXRoIGluZmVycmVkIHR5cGVzXG5TaGFkZXJQcm9ncmFtLnByb3RvdHlwZS5zZXRVbmlmb3JtcyA9IGZ1bmN0aW9uICh1bmlmb3JtcywgcmVzZXRfdGV4dHVyZV91bml0ID0gdHJ1ZSkge1xuICAgIGlmICghdGhpcy5jb21waWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVE9ETzogb25seSB1cGRhdGUgdW5pZm9ybXMgd2hlbiBjaGFuZ2VkXG5cbiAgICAvLyBUZXh0dXJlIHVuaXRzIG11c3QgYmUgdHJhY2tlZCBhbmQgaW5jcmVtZW50ZWQgZWFjaCB0aW1lIGEgdGV4dHVyZSBzYW1wbGVyIHVuaWZvcm0gaXMgc2V0LlxuICAgIC8vIEJ5IGRlZmF1bHQsIHRoZSB0ZXh0dXJlIHVuaXQgaXMgcmVzZXQgdG8gMCBlYWNoIHRpbWUgc2V0VW5pZm9ybXMgaXMgY2FsbGVkLCBidXQgdGhleSBjYW5cbiAgICAvLyBhbHNvIGJlIHByZXNlcnZlZCwgZm9yIGV4YW1wbGUgaW4gY2FzZXMgd2hlcmUgbXVsdGlwbGUgY2FsbHMgdG8gc2V0VW5pZm9ybXMgYXJlIGV4cGVjdGVkXG4gICAgLy8gKGUuZy4gcHJvZ3JhbS1zcGVjaWZpYyB1bmlmb3JtcyBmb2xsb3dlZCBieSBtZXNoLXNwZWNpZmljIG9uZXMpLlxuICAgIGlmIChyZXNldF90ZXh0dXJlX3VuaXQpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlX3VuaXQgPSAwO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIHVuaWZvcm0gdHlwZXMgYW5kIHZhbHVlcyBmcm9tIHRoZSBKUyBvYmplY3RcbiAgICB2YXIgcGFyc2VkID0gR0xTTC5wYXJzZVVuaWZvcm1zKHVuaWZvcm1zKTtcblxuICAgIC8vIFNldCBlYWNoIHVuaWZvcm1cbiAgICBmb3IgKHZhciB1bmlmb3JtIG9mIHBhcnNlZCkge1xuICAgICAgICBpZiAodW5pZm9ybS50eXBlID09PSAnc2FtcGxlcjJEJykge1xuICAgICAgICAgICAgLy8gRm9yIHRleHR1cmVzLCB3ZSBuZWVkIHRvIHRyYWNrIHRleHR1cmUgdW5pdHMsIHNvIHdlIGhhdmUgYSBzcGVjaWFsIHNldHRlclxuICAgICAgICAgICAgdGhpcy5zZXRUZXh0dXJlVW5pZm9ybSh1bmlmb3JtLm5hbWUsIHVuaWZvcm0udmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bmlmb3JtKHVuaWZvcm0ubWV0aG9kLCB1bmlmb3JtLm5hbWUsIHVuaWZvcm0udmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gQ2FjaGUgc29tZSBvciBhbGwgdW5pZm9ybSB2YWx1ZXMgc28gdGhleSBjYW4gYmUgcmVzdG9yZWRcblNoYWRlclByb2dyYW0ucHJvdG90eXBlLnNhdmVVbmlmb3JtcyA9IGZ1bmN0aW9uIChzdWJzZXQpIHtcbiAgICBsZXQgdW5pZm9ybXMgPSBzdWJzZXQgfHwgdGhpcy51bmlmb3JtcztcbiAgICBmb3IgKGxldCB1IGluIHVuaWZvcm1zKSB7XG4gICAgICAgIGxldCB1bmlmb3JtID0gdGhpcy51bmlmb3Jtc1t1XTtcbiAgICAgICAgaWYgKHVuaWZvcm0pIHtcbiAgICAgICAgICAgIHVuaWZvcm0uc2F2ZWRfdmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2F2ZWRfdGV4dHVyZV91bml0ID0gdGhpcy50ZXh0dXJlX3VuaXQgfHwgMDtcbn07XG5cbi8vIFJlc3RvcmUgc29tZSBvciBhbGwgdW5pZm9ybXMgdG8gc2F2ZWQgdmFsdWVzXG5TaGFkZXJQcm9ncmFtLnByb3RvdHlwZS5yZXN0b3JlVW5pZm9ybXMgPSBmdW5jdGlvbiAoc3Vic2V0KSB7XG4gICAgbGV0IHVuaWZvcm1zID0gc3Vic2V0IHx8IHRoaXMudW5pZm9ybXM7XG4gICAgZm9yIChsZXQgdSBpbiB1bmlmb3Jtcykge1xuICAgICAgICBsZXQgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNbdV07XG4gICAgICAgIGlmICh1bmlmb3JtICYmIHVuaWZvcm0uc2F2ZWRfdmFsdWUpIHtcbiAgICAgICAgICAgIHVuaWZvcm0udmFsdWUgPSB1bmlmb3JtLnNhdmVkX3ZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVVbmlmb3JtKHUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMudGV4dHVyZV91bml0ID0gdGhpcy5zYXZlZF90ZXh0dXJlX3VuaXQgfHwgMDtcbn07XG5cbi8vIFNldCBhIHRleHR1cmUgdW5pZm9ybSwgZmluZHMgdGV4dHVyZSBieSBuYW1lIG9yIGNyZWF0ZXMgYSBuZXcgb25lXG5TaGFkZXJQcm9ncmFtLnByb3RvdHlwZS5zZXRUZXh0dXJlVW5pZm9ybSA9IGZ1bmN0aW9uICh1bmlmb3JtX25hbWUsIHRleHR1cmVfbmFtZSkge1xuICAgIHZhciB0ZXh0dXJlID0gVGV4dHVyZS50ZXh0dXJlc1t0ZXh0dXJlX25hbWVdO1xuICAgIGlmICh0ZXh0dXJlID09IG51bGwpIHtcbiAgICAgICAgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKHRoaXMuZ2wsIHRleHR1cmVfbmFtZSk7XG4gICAgICAgIHRleHR1cmUubG9hZCh0ZXh0dXJlX25hbWUpO1xuICAgIH1cblxuICAgIHRleHR1cmUuYmluZCh0aGlzLnRleHR1cmVfdW5pdCk7XG4gICAgdGhpcy51bmlmb3JtKCcxaScsIHVuaWZvcm1fbmFtZSwgdGhpcy50ZXh0dXJlX3VuaXQpO1xuICAgIHRoaXMudGV4dHVyZV91bml0Kys7IC8vIFRPRE86IHRyYWNrIG1heCB0ZXh0dXJlIHVuaXRzIGFuZCBsb2cvdGhyb3cgZXJyb3JzXG59O1xuXG4vLyBleDogcHJvZ3JhbS51bmlmb3JtKCczZicsICdwb3NpdGlvbicsIHgsIHksIHopO1xuLy8gVE9ETzogb25seSB1cGRhdGUgdW5pZm9ybXMgd2hlbiBjaGFuZ2VkXG5TaGFkZXJQcm9ncmFtLnByb3RvdHlwZS51bmlmb3JtID0gZnVuY3Rpb24gKG1ldGhvZCwgbmFtZSwgLi4udmFsdWUpIC8vICd2YWx1ZScgaXMgYSBtZXRob2QtYXBwcm9wcmlhdGUgYXJndW1lbnRzIGxpc3RcbntcbiAgICBpZiAoIXRoaXMuY29tcGlsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudW5pZm9ybXNbbmFtZV0gPSB0aGlzLnVuaWZvcm1zW25hbWVdIHx8IHt9O1xuICAgIGxldCB1bmlmb3JtID0gdGhpcy51bmlmb3Jtc1tuYW1lXTtcbiAgICB1bmlmb3JtLm5hbWUgPSBuYW1lO1xuICAgIGlmICh1bmlmb3JtLmxvY2F0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdW5pZm9ybS5sb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgbmFtZSk7XG4gICAgfVxuICAgIHVuaWZvcm0ubWV0aG9kID0gJ3VuaWZvcm0nICsgbWV0aG9kO1xuICAgIHVuaWZvcm0udmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZVVuaWZvcm0obmFtZSk7XG59O1xuXG4vLyBTZXQgYSBzaW5nbGUgdW5pZm9ybVxuU2hhZGVyUHJvZ3JhbS5wcm90b3R5cGUudXBkYXRlVW5pZm9ybSA9IGZ1bmN0aW9uIChuYW1lKVxue1xuICAgIGlmICghdGhpcy5jb21waWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHVuaWZvcm0gPSB0aGlzLnVuaWZvcm1zW25hbWVdO1xuICAgIGlmICghdW5pZm9ybSB8fCB1bmlmb3JtLmxvY2F0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudXNlKCk7XG4gICAgdGhpcy5nbFt1bmlmb3JtLm1ldGhvZF0uYXBwbHkodGhpcy5nbCwgW3VuaWZvcm0ubG9jYXRpb25dLmNvbmNhdCh1bmlmb3JtLnZhbHVlKSk7IC8vIGNhbGwgYXBwcm9wcmlhdGUgR0wgdW5pZm9ybSBtZXRob2QgYW5kIHBhc3MgdGhyb3VnaCBhcmd1bWVudHNcbn07XG5cbi8vIFJlZnJlc2ggdW5pZm9ybSBsb2NhdGlvbnMgYW5kIHNldCB0byBsYXN0IGNhY2hlZCB2YWx1ZXNcblNoYWRlclByb2dyYW0ucHJvdG90eXBlLnJlZnJlc2hVbmlmb3JtcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKCF0aGlzLmNvbXBpbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciB1IGluIHRoaXMudW5pZm9ybXMpIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtc1t1XS5sb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgdSk7XG4gICAgICAgIHRoaXMudXBkYXRlVW5pZm9ybSh1KTtcbiAgICB9XG59O1xuXG5TaGFkZXJQcm9ncmFtLnByb3RvdHlwZS5yZWZyZXNoQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgLy8gdmFyIGxlbiA9IHRoaXMuZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLnByb2dyYW0sIHRoaXMuZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xuICAgIC8vIGZvciAodmFyIGk9MDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgLy8gICAgIHZhciBhID0gdGhpcy5nbC5nZXRBY3RpdmVBdHRyaWIodGhpcy5wcm9ncmFtLCBpKTtcbiAgICAvLyB9XG4gICAgdGhpcy5hdHRyaWJzID0ge307XG59O1xuXG4vLyBHZXQgdGhlIGxvY2F0aW9uIG9mIGEgdmVydGV4IGF0dHJpYnV0ZVxuU2hhZGVyUHJvZ3JhbS5wcm90b3R5cGUuYXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUpXG57XG4gICAgaWYgKCF0aGlzLmNvbXBpbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYXR0cmliID0gKHRoaXMuYXR0cmlic1tuYW1lXSA9IHRoaXMuYXR0cmlic1tuYW1lXSB8fCB7fSk7XG4gICAgaWYgKGF0dHJpYi5sb2NhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWI7XG4gICAgfVxuXG4gICAgYXR0cmliLm5hbWUgPSBuYW1lO1xuICAgIGF0dHJpYi5sb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCBuYW1lKTtcblxuICAgIC8vIHZhciBpbmZvID0gdGhpcy5nbC5nZXRBY3RpdmVBdHRyaWIodGhpcy5wcm9ncmFtLCBhdHRyaWIubG9jYXRpb24pO1xuICAgIC8vIGF0dHJpYi50eXBlID0gaW5mby50eXBlO1xuICAgIC8vIGF0dHJpYi5zaXplID0gaW5mby5zaXplO1xuXG4gICAgcmV0dXJuIGF0dHJpYjtcbn07XG5cbi8vIENvbXBpbGUgJiBsaW5rIGEgV2ViR0wgcHJvZ3JhbSBmcm9tIHByb3ZpZGVkIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVyIHNvdXJjZXNcbi8vIHVwZGF0ZSBhIHByb2dyYW0gaWYgb25lIGlzIHBhc3NlZCBpbi4gQ3JlYXRlIG9uZSBpZiBub3QuIEFsZXJ0IGFuZCBkb24ndCB1cGRhdGUgYW55dGhpbmcgaWYgdGhlIHNoYWRlcnMgZG9uJ3QgY29tcGlsZS5cblNoYWRlclByb2dyYW0udXBkYXRlUHJvZ3JhbSA9IGZ1bmN0aW9uIChnbCwgcHJvZ3JhbSwgdmVydGV4X3NoYWRlcl9zb3VyY2UsIGZyYWdtZW50X3NoYWRlcl9zb3VyY2UpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgdmVydGV4X3NoYWRlciA9IFNoYWRlclByb2dyYW0uY3JlYXRlU2hhZGVyKGdsLCB2ZXJ0ZXhfc2hhZGVyX3NvdXJjZSwgZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgICAgIHZhciBmcmFnbWVudF9zaGFkZXIgPSBTaGFkZXJQcm9ncmFtLmNyZWF0ZVNoYWRlcihnbCwgJyNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZW5kaWZcXG5cXG4nICsgZnJhZ21lbnRfc2hhZGVyX3NvdXJjZSwgZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICB9XG4gICAgY2F0Y2goZXJyKSB7XG4gICAgICAgIGxvZy5lcnJvcihlcnIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgZ2wudXNlUHJvZ3JhbShudWxsKTtcbiAgICBpZiAocHJvZ3JhbSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBvbGRfc2hhZGVycyA9IGdsLmdldEF0dGFjaGVkU2hhZGVycyhwcm9ncmFtKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG9sZF9zaGFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBnbC5kZXRhY2hTaGFkZXIocHJvZ3JhbSwgb2xkX3NoYWRlcnNbaV0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICB9XG5cbiAgICBpZiAodmVydGV4X3NoYWRlciA9PSBudWxsIHx8IGZyYWdtZW50X3NoYWRlciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cblxuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhfc2hhZGVyKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRfc2hhZGVyKTtcblxuICAgIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhfc2hhZGVyKTtcbiAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRfc2hhZGVyKTtcblxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgICB2YXIgcHJvZ3JhbV9lcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBXZWJHTCBwcm9ncmFtIGVycm9yOlxuICAgICAgICAgICAgVkFMSURBVEVfU1RBVFVTOiAke2dsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTKX1cbiAgICAgICAgICAgIEVSUk9SOiAke2dsLmdldEVycm9yKCl9XG4gICAgICAgICAgICAtLS0gVmVydGV4IFNoYWRlciAtLS1cbiAgICAgICAgICAgICR7dmVydGV4X3NoYWRlcl9zb3VyY2V9XG4gICAgICAgICAgICAtLS0gRnJhZ21lbnQgU2hhZGVyIC0tLVxuICAgICAgICAgICAgJHtmcmFnbWVudF9zaGFkZXJfc291cmNlfWApO1xuICAgICAgICBsb2cuZXJyb3IocHJvZ3JhbV9lcnJvcik7XG4gICAgICAgIHRocm93IHByb2dyYW1fZXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2dyYW07XG59O1xuXG4vLyBDb21waWxlIGEgdmVydGV4IG9yIGZyYWdtZW50IHNoYWRlciBmcm9tIHByb3ZpZGVkIHNvdXJjZVxuU2hhZGVyUHJvZ3JhbS5jcmVhdGVTaGFkZXIgPSBmdW5jdGlvbiAoZ2wsIHNvdXJjZSwgdHlwZSkge1xuICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG5cbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblxuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgIHZhciBzaGFkZXJfZXJyb3IgPVxuICAgICAgICAgICAgXCJXZWJHTCBzaGFkZXIgZXJyb3I6XFxuXCIgK1xuICAgICAgICAgICAgKHR5cGUgPT09IGdsLlZFUlRFWF9TSEFERVIgPyBcIlZFUlRFWFwiIDogXCJGUkFHTUVOVFwiKSArIFwiIFNIQURFUjpcXG5cIiArXG4gICAgICAgICAgICBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XG4gICAgICAgIHRocm93IHNoYWRlcl9lcnJvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhZGVyO1xufTtcbiIsIi8vIEdlbmVyYXRlZCBmcm9tIEdMU0wgZmlsZXMsIGRvbid0IGVkaXQhXG52YXIgc2hhZGVyU291cmNlcyA9IHt9O1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL21hdGVyaWFsJ10gPVxuXCIvLyBNQVRFUklBTFNcXG5cIiArXG5cIi8vXFxuXCIgK1xuXCJzdHJ1Y3QgTWF0ZXJpYWwge1xcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0VNSVNTSU9OXFxuXCIgK1xuXCIgICAgICAgIHZlYzQgZW1pc3Npb247XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9BTUJJRU5UXFxuXCIgK1xuXCIgICAgICAgIHZlYzQgYW1iaWVudDtcXG5cIiArXG5cIiAgICAjZW5kaWYgXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFXFxuXCIgK1xuXCIgICAgICAgIHZlYzQgZGlmZnVzZTtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSXFxuXCIgK1xuXCIgICAgICAgIHZlYzQgc3BlY3VsYXI7XFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IHNoaW5pbmVzcztcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIn07XFxuXCIgK1xuXCJcXG5cIiArXG5cIi8vIE5vdGU6IHVuaWZvcm1zICh1X1tuYW1lXSkgYW5kIHZhcnlpbmdzICh2X1tuYW1lXSkgYXJlIFxcblwiICtcblwiLy8gICAgICBjb3B5IHRvIGdsb2JhbCBpbnN0YW5jZXMgKCBnX1tuYW1lXSApIHRvIGFsbG93IFxcblwiICtcblwiLy8gICAgICBtb2RpZmljYXRpb25zXFxuXCIgK1xuXCIvL1xcblwiICtcblwidW5pZm9ybSBNYXRlcmlhbCB1X21hdGVyaWFsO1xcblwiICtcblwiTWF0ZXJpYWwgZ19tYXRlcmlhbCA9IHVfbWF0ZXJpYWw7XFxuXCIgK1xuXCJcXG5cIiArXG5cIi8vIEdMT0JBTCBMSUdIVFMgQUNDVU1VTEFUT1JTIGZvciBlYWNoIGVuYWJsZSBNQVRFUklBTCBwcm9wZXJ0eVxcblwiICtcblwiLy9cXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0FNQklFTlRcXG5cIiArXG5cIiAgICB2ZWM0IGdfbGlnaHRfYWNjdW11bGF0b3JfYW1iaWVudCA9IHZlYzQoMC4wKTtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRVxcblwiICtcblwiICAgIHZlYzQgZ19saWdodF9hY2N1bXVsYXRvcl9kaWZmdXNlID0gdmVjNCgwLjApO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUlxcblwiICtcblwiICAgIHZlYzQgZ19saWdodF9hY2N1bXVsYXRvcl9zcGVjdWxhciA9IHZlYzQoMC4wKTtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvc3BvdExpZ2h0J10gPVxuXCJzdHJ1Y3QgU3BvdExpZ2h0IHtcXG5cIiArXG5cIiAgICB2ZWM0IGFtYmllbnQ7XFxuXCIgK1xuXCIgICAgdmVjNCBkaWZmdXNlO1xcblwiICtcblwiICAgIHZlYzQgc3BlY3VsYXI7XFxuXCIgK1xuXCIgICAgdmVjNCBwb3NpdGlvbjtcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9FWFBPTkVOVFxcblwiICtcblwiICAgIGZsb2F0IGF0dGVudWF0aW9uRXhwb25lbnQ7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9JTk5FUl9SQURJVVNcXG5cIiArXG5cIiAgICBmbG9hdCBpbm5lclJhZGl1cztcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX09VVEVSX1JBRElVU1xcblwiICtcblwiICAgIGZsb2F0IG91dGVyUmFkaXVzO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICB2ZWMzIGRpcmVjdGlvbjtcXG5cIiArXG5cIiAgICBmbG9hdCBzcG90Q29zQ3V0b2ZmO1xcblwiICtcblwiICAgIGZsb2F0IHNwb3RFeHBvbmVudDtcXG5cIiArXG5cIn07XFxuXCIgK1xuXCJcXG5cIiArXG5cInZvaWQgY2FsY3VsYXRlTGlnaHQoaW4gU3BvdExpZ2h0IF9saWdodCwgaW4gdmVjMyBfZXllVG9Qb2ludCwgaW4gdmVjMyBfbm9ybWFsKSB7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKF9saWdodC5wb3NpdGlvbi54eXogLSBfZXllVG9Qb2ludCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBDb21wdXRlIHZlY3RvciBmcm9tIHN1cmZhY2UgdG8gbGlnaHQgcG9zaXRpb25cXG5cIiArXG5cIiAgICB2ZWMzIFZQID0gKF9saWdodC5wb3NpdGlvbi54eXogLSBfZXllVG9Qb2ludCkgLyBkaXN0O1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gbm9ybWFsIC4gbGlnaHQgZGlyZWN0aW9uXFxuXCIgK1xuXCIgICAgZmxvYXQgbkRvdFZQID0gY2xhbXAoZG90KF9ub3JtYWwsIFZQKSwgMC4wLCAxLjApO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gQXR0ZW51YXRpb24gZGVmYXVsdHNcXG5cIiArXG5cIiAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IDEuMDtcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0VYUE9ORU5UXFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IFJpbiA9IDEuMDtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgZSA9IF9saWdodC5hdHRlbnVhdGlvbkV4cG9uZW50O1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fSU5ORVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICBSaW4gPSBfbGlnaHQuaW5uZXJSYWRpdXM7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fT1VURVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICBmbG9hdCBSZGlmZiA9IF9saWdodC5vdXRlclJhZGl1cy1SaW47XFxuXCIgK1xuXCIgICAgICAgICAgICBmbG9hdCBkID0gY2xhbXAobWF4KDAuMCxkaXN0LVJpbikvUmRpZmYsIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgIGF0dGVudWF0aW9uID0gMS4wLShwb3coZCxlKSk7XFxuXCIgK1xuXCIgICAgICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgICAgICAvLyBJZiBubyBvdXRlciBpcyBwcm92aWRlIGJlaGF2ZXMgbGlrZTpcXG5cIiArXG5cIiAgICAgICAgICAgIC8vIGh0dHBzOi8vaW1kb2luZ2l0d3Jvbmcud29yZHByZXNzLmNvbS8yMDExLzAxLzMxL2xpZ2h0LWF0dGVudWF0aW9uL1xcblwiICtcblwiICAgICAgICAgICAgZmxvYXQgZCA9IG1heCgwLjAsZGlzdC1SaW4pL1JpbisxLjA7XFxuXCIgK1xuXCIgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IGNsYW1wKDEuMC8ocG93KGQsZSkpLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IFJpbiA9IDAuMDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0lOTkVSX1JBRElVU1xcblwiICtcblwiICAgICAgICAgICAgUmluID0gX2xpZ2h0LmlubmVyUmFkaXVzO1xcblwiICtcblwiICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBSZGlmZiA9IF9saWdodC5vdXRlclJhZGl1cy1SaW47XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgZmxvYXQgZCA9IGNsYW1wKG1heCgwLjAsZGlzdC1SaW4pL1JkaWZmLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgYXR0ZW51YXRpb24gPSAxLjAtZCpkO1xcblwiICtcblwiICAgICAgICAgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgICAgICAgICAvLyBJZiBubyBvdXRlciBpcyBwcm92aWRlIGJlaGF2ZXMgbGlrZTpcXG5cIiArXG5cIiAgICAgICAgICAgICAgICAvLyBodHRwczovL2ltZG9pbmdpdHdyb25nLndvcmRwcmVzcy5jb20vMjAxMS8wMS8zMS9saWdodC1hdHRlbnVhdGlvbi9cXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBkID0gbWF4KDAuMCxkaXN0LVJpbikvUmluKzEuMDtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IGNsYW1wKDEuMC9kLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fT1VURVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgZmxvYXQgZCA9IGNsYW1wKGRpc3QvX2xpZ2h0Lm91dGVyUmFkaXVzLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgYXR0ZW51YXRpb24gPSAxLjAtZCpkO1xcblwiICtcblwiICAgICAgICAgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IDEuMDtcXG5cIiArXG5cIiAgICAgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIHNwb3RsaWdodCBhdHRlbnVhdGlvbiBmYWN0b3JcXG5cIiArXG5cIiAgICBmbG9hdCBzcG90QXR0ZW51YXRpb24gPSAwLjA7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBTZWUgaWYgcG9pbnQgb24gc3VyZmFjZSBpcyBpbnNpZGUgY29uZSBvZiBpbGx1bWluYXRpb25cXG5cIiArXG5cIiAgICBmbG9hdCBzcG90RG90ID0gY2xhbXAoZG90KC1WUCwgbm9ybWFsaXplKF9saWdodC5kaXJlY3Rpb24pKSwgMC4wLCAxLjApO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgaWYgKHNwb3REb3QgPj0gX2xpZ2h0LnNwb3RDb3NDdXRvZmYpIHtcXG5cIiArXG5cIiAgICAgICAgc3BvdEF0dGVudWF0aW9uID0gcG93KHNwb3REb3QsIF9saWdodC5zcG90RXhwb25lbnQpO1xcblwiICtcblwiICAgIH1cXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0FNQklFTlRcXG5cIiArXG5cIiAgICAgICAgZ19saWdodF9hY2N1bXVsYXRvcl9hbWJpZW50ICs9IF9saWdodC5hbWJpZW50ICogYXR0ZW51YXRpb24gKiBzcG90QXR0ZW51YXRpb247XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFXFxuXCIgK1xuXCIgICAgICAgIGdfbGlnaHRfYWNjdW11bGF0b3JfZGlmZnVzZSArPSBfbGlnaHQuZGlmZnVzZSAqIG5Eb3RWUCAqIGF0dGVudWF0aW9uICogc3BvdEF0dGVudWF0aW9uO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJcXG5cIiArXG5cIiAgICAgICAgLy8gUG93ZXIgZmFjdG9yIGZvciBzaGlueSBzcGVjdWxhcnNcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgcGYgPSAwLjA7XFxuXCIgK1xuXCIgICAgICAgIGlmIChuRG90VlAgPiAwLjApIHtcXG5cIiArXG5cIiAgICAgICAgICAgIHZlYzMgcmVmbGVjdFZlY3RvciA9IHJlZmxlY3QoLVZQLCBfbm9ybWFsKTtcXG5cIiArXG5cIiAgICAgICAgICAgIGZsb2F0IGV5ZURvdFIgPSBtYXgoZG90KC1ub3JtYWxpemUoX2V5ZVRvUG9pbnQpLCByZWZsZWN0VmVjdG9yKSwgMC4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgIHBmID0gcG93KGV5ZURvdFIsIGdfbWF0ZXJpYWwuc2hpbmluZXNzKTtcXG5cIiArXG5cIiAgICAgICAgfVxcblwiICtcblwiICAgICAgICBnX2xpZ2h0X2FjY3VtdWxhdG9yX3NwZWN1bGFyICs9IF9saWdodC5zcGVjdWxhciAqIHBmICogYXR0ZW51YXRpb24gKiBzcG90QXR0ZW51YXRpb247XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9hbWJpZW50TGlnaHQnXSA9XG5cInN0cnVjdCBBbWJpZW50TGlnaHQge1xcblwiICtcblwiICAgIHZlYzQgYW1iaWVudDtcXG5cIiArXG5cIn07XFxuXCIgK1xuXCJcXG5cIiArXG5cInZvaWQgY2FsY3VsYXRlTGlnaHQoaW4gQW1iaWVudExpZ2h0IF9saWdodCwgaW4gdmVjMyBfZXllVG9Qb2ludCwgaW4gdmVjMyBfbm9ybWFsKXtcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9BTUJJRU5UXFxuXCIgK1xuXCIgICAgICAgIGdfbGlnaHRfYWNjdW11bGF0b3JfYW1iaWVudCArPSBfbGlnaHQuYW1iaWVudDtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIn1cXG5cIiArXCJcIjtcblxuc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9zcGhlcmljYWxfZW52aXJvbm1lbnRfbWFwJ10gPVxuXCIvLyBTcGhlcmljYWwgZW52aXJvbm1lbnQgbWFwXFxuXCIgK1xuXCIvLyBCYXNlZCBvbjogaHR0cDovL3d3dy5jbGlja3RvcmVsZWFzZS5jb20vYmxvZy9jcmVhdGluZy1zcGhlcmljYWwtZW52aXJvbm1lbnQtbWFwcGluZy1zaGFkZXJcXG5cIiArXG5cIlxcblwiICtcblwiLy8gdmlldzogbG9jYXRpb24gb2YgY2FtZXJhXFxuXCIgK1xuXCIvLyBwb3NpdGlvbjogbG9jYXRpb24gb2YgY3VycmVudCBwb2ludCBvbiBzdXJmYWNlXFxuXCIgK1xuXCIvLyBub3JtYWw6IG5vcm1hbCBvZiBjdXJyZW50IHBvaW50IG9uIHN1cmZhY2VcXG5cIiArXG5cIi8vIHNrZXc6IHNrZXdpbmcgZmFjdG9yICh1c2VkIHRvIGNvbXBlbnNhdGUgZm9yIGFsdGVyZWQgdmFuaXNoaW5nIHBvaW50KVxcblwiICtcblwiLy8gZW52bWFwOiBzcGhlcmljYWwgZW52aXJvbm1lbnQgbWFwIHRleHR1cmVcXG5cIiArXG5cIlxcblwiICtcblwidmVjNCBzcGhlcmljYWxFbnZpcm9ubWVudE1hcCh2ZWMzIHZpZXcsIHZlYzMgcG9zaXRpb24sIHZlYzMgbm9ybWFsLCB2ZWMyIHNrZXcsIHNhbXBsZXIyRCBlbnZtYXApIHtcXG5cIiArXG5cIiAgICAvLyBOb3JtYWxpemVkIHZlY3RvciBmcm9tIGNhbWVyYSB0byBzdXJmYWNlXFxuXCIgK1xuXCIgICAgdmVjMyBleWUgPSBub3JtYWxpemUocG9zaXRpb24ueHl6IC0gdmlldy54eXopO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gU2tld1xcblwiICtcblwiICAgIGV5ZS54eSAtPSBza2V3O1xcblwiICtcblwiICAgIGV5ZSA9IG5vcm1hbGl6ZShleWUpO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gUmVmbGVjdGlvbiBvZiBleWUgb2ZmIG9mIHN1cmZhY2Ugbm9ybWFsXFxuXCIgK1xuXCIgICAgdmVjMyByID0gcmVmbGVjdChleWUsIG5vcm1hbCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBNYXAgcmVmbGVjdGVkIHZlY3RvciBvbnRvIHRoZSBzdXJmYWNlIG9mIGEgc3BoZXJlXFxuXCIgK1xuXCIgICAgci56ICs9IDEuO1xcblwiICtcblwiICAgIGZsb2F0IG0gPSAyLiAqIGxlbmd0aChyKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIEFkanVzdCB4eSB0byBhY2NvdW50IGZvciBzcGhlcmljYWwgc2hhcGUsIGFuZCBjZW50ZXIgaW4gbWlkZGxlIG9mIHRleHR1cmVcXG5cIiArXG5cIiAgICB2ZWMyIHV2ID0gci54eSAvIG0gKyAuNTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFNhbXBsZSB0aGUgZW52aXJvbm1lbnQgbWFwXFxuXCIgK1xuXCIgICAgcmV0dXJuIHRleHR1cmUyRChlbnZtYXAsIHV2KTtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3BvaW50TGlnaHQnXSA9XG5cInN0cnVjdCBQb2ludExpZ2h0IHtcXG5cIiArXG5cIiAgICB2ZWM0IGFtYmllbnQ7XFxuXCIgK1xuXCIgICAgdmVjNCBkaWZmdXNlO1xcblwiICtcblwiICAgIHZlYzQgc3BlY3VsYXI7XFxuXCIgK1xuXCIgICAgdmVjNCBwb3NpdGlvbjtcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9FWFBPTkVOVFxcblwiICtcblwiICAgIGZsb2F0IGF0dGVudWF0aW9uRXhwb25lbnQ7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9JTk5FUl9SQURJVVNcXG5cIiArXG5cIiAgICBmbG9hdCBpbm5lclJhZGl1cztcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX09VVEVSX1JBRElVU1xcblwiICtcblwiICAgIGZsb2F0IG91dGVyUmFkaXVzO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJ9O1xcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIGNhbGN1bGF0ZUxpZ2h0KGluIFBvaW50TGlnaHQgX2xpZ2h0LCBpbiB2ZWMzIF9leWVUb1BvaW50LCBpbiB2ZWMzIF9ub3JtYWwpIHtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgoX2xpZ2h0LnBvc2l0aW9uLnh5eiAtIF9leWVUb1BvaW50KTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIENvbXB1dGUgdmVjdG9yIGZyb20gc3VyZmFjZSB0byBsaWdodCBwb3NpdGlvblxcblwiICtcblwiICAgIHZlYzMgVlAgPSAoX2xpZ2h0LnBvc2l0aW9uLnh5eiAtIF9leWVUb1BvaW50KSAvIGRpc3Q7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBOb3JtYWxpemUgdGhlIHZlY3RvciBmcm9tIHN1cmZhY2UgdG8gbGlnaHQgcG9zaXRpb25cXG5cIiArXG5cIiAgICBmbG9hdCBuRG90VlAgPSBjbGFtcChkb3QoVlAsIF9ub3JtYWwpLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBBdHRlbnVhdGlvbiBkZWZhdWx0c1xcblwiICtcblwiICAgIGZsb2F0IGF0dGVudWF0aW9uID0gMS4wO1xcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fRVhQT05FTlRcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgUmluID0gMS4wO1xcblwiICtcblwiICAgICAgICBmbG9hdCBlID0gX2xpZ2h0LmF0dGVudWF0aW9uRXhwb25lbnQ7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9JTk5FUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgIFJpbiA9IF9saWdodC5pbm5lclJhZGl1cztcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgIGZsb2F0IFJkaWZmID0gX2xpZ2h0Lm91dGVyUmFkaXVzLVJpbjtcXG5cIiArXG5cIiAgICAgICAgICAgIGZsb2F0IGQgPSBjbGFtcChtYXgoMC4wLGRpc3QtUmluKS9SZGlmZiwgMC4wLCAxLjApO1xcblwiICtcblwiICAgICAgICAgICAgYXR0ZW51YXRpb24gPSAxLjAtKHBvdyhkLGUpKTtcXG5cIiArXG5cIiAgICAgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgICAgIC8vIElmIG5vIG91dGVyIGlzIHByb3ZpZGUgYmVoYXZlcyBsaWtlOlxcblwiICtcblwiICAgICAgICAgICAgLy8gaHR0cHM6Ly9pbWRvaW5naXR3cm9uZy53b3JkcHJlc3MuY29tLzIwMTEvMDEvMzEvbGlnaHQtYXR0ZW51YXRpb24vXFxuXCIgK1xuXCIgICAgICAgICAgICBmbG9hdCBkID0gbWF4KDAuMCxkaXN0LVJpbikvUmluKzEuMDtcXG5cIiArXG5cIiAgICAgICAgICAgIGF0dGVudWF0aW9uID0gY2xhbXAoMS4wLyhwb3coZCxlKSksIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgUmluID0gMC4wO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fSU5ORVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICBSaW4gPSBfbGlnaHQuaW5uZXJSYWRpdXM7XFxuXCIgK1xuXCIgICAgICAgICAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX09VVEVSX1JBRElVU1xcblwiICtcblwiICAgICAgICAgICAgICAgIGZsb2F0IFJkaWZmID0gX2xpZ2h0Lm91dGVyUmFkaXVzLVJpbjtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBkID0gY2xhbXAobWF4KDAuMCxkaXN0LVJpbikvUmRpZmYsIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IDEuMC1kKmQ7XFxuXCIgK1xuXCIgICAgICAgICAgICAjZWxzZVxcblwiICtcblwiICAgICAgICAgICAgICAgIC8vIElmIG5vIG91dGVyIGlzIHByb3ZpZGUgYmVoYXZlcyBsaWtlOlxcblwiICtcblwiICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaW1kb2luZ2l0d3Jvbmcud29yZHByZXNzLmNvbS8yMDExLzAxLzMxL2xpZ2h0LWF0dGVudWF0aW9uL1xcblwiICtcblwiICAgICAgICAgICAgICAgIGZsb2F0IGQgPSBtYXgoMC4wLGRpc3QtUmluKS9SaW4rMS4wO1xcblwiICtcblwiICAgICAgICAgICAgICAgIGF0dGVudWF0aW9uID0gY2xhbXAoMS4wL2QsIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICAgICAjZWxzZVxcblwiICtcblwiICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBmbG9hdCBkID0gY2xhbXAoZGlzdC9fbGlnaHQub3V0ZXJSYWRpdXMsIDAuMCwgMS4wKTtcXG5cIiArXG5cIiAgICAgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IDEuMC1kKmQ7XFxuXCIgK1xuXCIgICAgICAgICAgICAjZWxzZVxcblwiICtcblwiICAgICAgICAgICAgICAgIGF0dGVudWF0aW9uID0gMS4wO1xcblwiICtcblwiICAgICAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gQWN1bW11bGF0b3JzIGNvbXB1dGVcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9BTUJJRU5UXFxuXCIgK1xuXCIgICAgICAgIGdfbGlnaHRfYWNjdW11bGF0b3JfYW1iaWVudCArPSBfbGlnaHQuYW1iaWVudCAqIGF0dGVudWF0aW9uO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRVxcblwiICtcblwiICAgICAgICBnX2xpZ2h0X2FjY3VtdWxhdG9yX2RpZmZ1c2UgKz0gX2xpZ2h0LmRpZmZ1c2UgKiBuRG90VlAgKiBhdHRlbnVhdGlvbjtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSXFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IHBmID0gMC4wOyAvLyBwb3dlciBmYWN0b3IgZm9yIHNoaW55IHNwZWN1bGFyc1xcblwiICtcblwiICAgICAgICBpZiAobkRvdFZQID4gMC4wKSB7XFxuXCIgK1xuXCIgICAgICAgICAgICB2ZWMzIHJlZmxlY3RWZWN0b3IgPSByZWZsZWN0KC1WUCwgX25vcm1hbCk7XFxuXCIgK1xuXCIgICAgICAgICAgICBmbG9hdCBleWVEb3RSID0gbWF4KDAuMCwgZG90KC1ub3JtYWxpemUoX2V5ZVRvUG9pbnQpLCByZWZsZWN0VmVjdG9yKSk7XFxuXCIgK1xuXCIgICAgICAgICAgICBwZiA9IHBvdyhleWVEb3RSLCBnX21hdGVyaWFsLnNoaW5pbmVzcyk7XFxuXCIgK1xuXCIgICAgICAgIH1cXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICBnX2xpZ2h0X2FjY3VtdWxhdG9yX3NwZWN1bGFyICs9IF9saWdodC5zcGVjdWxhciAqIHBmICogYXR0ZW51YXRpb247XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9zZWxlY3Rpb25fZnJhZ21lbnQnXSA9XG5cIi8vIEZyYWdtZW50IHNoYWRlciBmb3IgZmVhdHVyZSBzZWxlY3Rpb24gcGFzc2VzXFxuXCIgK1xuXCIvLyBSZW5kZXJzIGluIHNpbGhvdWV0dGUgYWNjb3JkaW5nIHRvIHNlbGVjdGlvbiAocGlja2luZykgY29sb3IsIG9yIGJsYWNrIGlmIG5vbmUgZGVmaW5lZFxcblwiICtcblwiXFxuXCIgK1xuXCIjaWYgZGVmaW5lZChGRUFUVVJFX1NFTEVDVElPTilcXG5cIiArXG5cIiAgICB2YXJ5aW5nIHZlYzQgdl9zZWxlY3Rpb25fY29sb3I7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBtYWluICh2b2lkKSB7XFxuXCIgK1xuXCIgICAgI2lmIGRlZmluZWQoRkVBVFVSRV9TRUxFQ1RJT04pXFxuXCIgK1xuXCIgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZfc2VsZWN0aW9uX2NvbG9yO1xcblwiICtcblwiICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4sIDAuLCAwLiwgMS4pO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvZGlyZWN0aW9uYWxMaWdodCddID1cblwic3RydWN0IERpcmVjdGlvbmFsTGlnaHQge1xcblwiICtcblwiICAgIHZlYzQgYW1iaWVudDtcXG5cIiArXG5cIiAgICB2ZWM0IGRpZmZ1c2U7XFxuXCIgK1xuXCIgICAgdmVjNCBzcGVjdWxhcjtcXG5cIiArXG5cIiAgICB2ZWMzIGRpcmVjdGlvbjtcXG5cIiArXG5cIn07XFxuXCIgK1xuXCJcXG5cIiArXG5cInZvaWQgY2FsY3VsYXRlTGlnaHQoaW4gRGlyZWN0aW9uYWxMaWdodCBfbGlnaHQsIGluIHZlYzMgX2V5ZVRvUG9pbnQsIGluIHZlYzMgX25vcm1hbCl7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9BTUJJRU5UXFxuXCIgK1xuXCIgICAgICAgIGdfbGlnaHRfYWNjdW11bGF0b3JfYW1iaWVudCArPSBfbGlnaHQuYW1iaWVudDtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGZsb2F0IG5Eb3RWUCA9IGNsYW1wKGRvdChfbm9ybWFsLCAtbm9ybWFsaXplKF9saWdodC5kaXJlY3Rpb24pKSwgMC4wLCAxLjApO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRVxcblwiICtcblwiICAgICAgICBnX2xpZ2h0X2FjY3VtdWxhdG9yX2RpZmZ1c2UgKz0gX2xpZ2h0LmRpZmZ1c2UgKiBuRG90VlA7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUlxcblwiICtcblwiICAgICAgICBmbG9hdCBwZiA9IDAuMDtcXG5cIiArXG5cIiAgICAgICAgaWYgKG5Eb3RWUCA+IDAuMCkge1xcblwiICtcblwiICAgICAgICAgICAgdmVjMyByZWZsZWN0VmVjdG9yID0gcmVmbGVjdChub3JtYWxpemUoX2xpZ2h0LmRpcmVjdGlvbiksIF9ub3JtYWwpO1xcblwiICtcblwiICAgICAgICAgICAgZmxvYXQgZXllRG90UiA9IG1heChkb3Qobm9ybWFsaXplKF9leWVUb1BvaW50KSwgcmVmbGVjdFZlY3RvciksIDAuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICBwZiA9IHBvdyhleWVEb3RSLCBnX21hdGVyaWFsLnNoaW5pbmVzcyk7XFxuXCIgK1xuXCIgICAgICAgIH1cXG5cIiArXG5cIiAgICAgICAgZ19saWdodF9hY2N1bXVsYXRvcl9zcGVjdWxhciArPSBfbGlnaHQuc3BlY3VsYXIgKiBwZjtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3Jlb3JkZXJfbGF5ZXJzJ10gPVxuXCIvLyBSZS1vcmRlcnMgZGVwdGggc28gdGhhdCBoaWdoZXIgbnVtYmVyZWQgbGF5ZXJzIGFyZSBcXFwiZm9yY2VcXFwiLWRyYXduIG92ZXIgbG93ZXIgb25lc1xcblwiICtcblwidm9pZCByZW9yZGVyTGF5ZXJzIChmbG9hdCBsYXllciwgZmxvYXQgbnVtX2xheWVycywgaW5vdXQgdmVjNCBwb3NpdGlvbikge1xcblwiICtcblwiICAgIGZsb2F0IGxheWVyX29yZGVyID0gKChsYXllciArIDEuKSAvIChudW1fbGF5ZXJzICsgMS4pKSArIDEuO1xcblwiICtcblwiICAgIHBvc2l0aW9uLnogLz0gbGF5ZXJfb3JkZXI7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snc3R5bGVzL3BvaW50cy9wb2ludHMudmVydGV4J10gPVxuXCJ1bmlmb3JtIG1hdDQgdV9tb2RlbFZpZXc7XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfbnVtX2xheWVycztcXG5cIiArXG5cIlxcblwiICtcblwiYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcXG5cIiArXG5cImF0dHJpYnV0ZSB2ZWMyIGFfdGV4Y29vcmQ7XFxuXCIgK1xuXCJhdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcblwiICtcblwiYXR0cmlidXRlIGZsb2F0IGFfbGF5ZXI7XFxuXCIgK1xuXCJcXG5cIiArXG5cInZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblwiICtcblwidmFyeWluZyB2ZWMyIHZfdGV4Y29vcmQ7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZiBkZWZpbmVkKEZFQVRVUkVfU0VMRUNUSU9OKVxcblwiICtcblwiICAgIGF0dHJpYnV0ZSB2ZWM0IGFfc2VsZWN0aW9uX2NvbG9yO1xcblwiICtcblwiICAgIHZhcnlpbmcgdmVjNCB2X3NlbGVjdGlvbl9jb2xvcjtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGdsb2JhbHNcXG5cIiArXG5cIiNwcmFnbWEgdGFuZ3JhbTogY2FtZXJhXFxuXCIgK1xuXCJcXG5cIiArXG5cInZvaWQgbWFpbigpIHtcXG5cIiArXG5cIiAgICAjaWYgZGVmaW5lZChGRUFUVVJFX1NFTEVDVElPTilcXG5cIiArXG5cIiAgICAgICAgaWYgKGFfc2VsZWN0aW9uX2NvbG9yLnJnYiA9PSB2ZWMzKDAuKSkge1xcblwiICtcblwiICAgICAgICAgICAgLy8gRGlzY2FyZCBieSBmb3JjaW5nIGludmFsaWQgdHJpYW5nbGUgaWYgd2VcXCdyZSBpbiB0aGUgZmVhdHVyZVxcblwiICtcblwiICAgICAgICAgICAgLy8gc2VsZWN0aW9uIHBhc3MgYnV0IGhhdmUgbm8gc2VsZWN0aW9uIGluZm9cXG5cIiArXG5cIiAgICAgICAgICAgIC8vIFRPRE86IGluIHNvbWUgY2FzZXMgd2UgbWF5IGFjdHVhbGx5IHdhbnQgbm9uLXNlbGVjdGFibGUgZmVhdHVyZXMgdG8gb2NjbHVkZSBzZWxlY3RhYmxlIG9uZXM/XFxuXCIgK1xuXCIgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoMC4sIDAuLCAwLiwgMS4pO1xcblwiICtcblwiICAgICAgICAgICAgcmV0dXJuO1xcblwiICtcblwiICAgICAgICB9XFxuXCIgK1xuXCIgICAgICAgIHZfc2VsZWN0aW9uX2NvbG9yID0gYV9zZWxlY3Rpb25fY29sb3I7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICB2ZWM0IHBvc2l0aW9uID0gdV9tb2RlbFZpZXcgKiB2ZWM0KGFfcG9zaXRpb24sIDEuKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFRPRE86IGxlZ2FjeSwgcmVwbGFjZSBpbiBleGlzdGluZyBzdHlsZXNcXG5cIiArXG5cIiAgICAvLyAjcHJhZ21hIHRhbmdyYW06IHZlcnRleFxcblwiICtcblwiICAgICNwcmFnbWEgdGFuZ3JhbTogcG9zaXRpb25cXG5cIiArXG5cIlxcblwiICtcblwiICAgIHZfY29sb3IgPSBhX2NvbG9yO1xcblwiICtcblwiICAgIHZfdGV4Y29vcmQgPSBhX3RleGNvb3JkO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgY2FtZXJhUHJvamVjdGlvbihwb3NpdGlvbik7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBSZS1vcmRlcnMgZGVwdGggc28gdGhhdCBoaWdoZXIgbnVtYmVyZWQgbGF5ZXJzIGFyZSBcXFwiZm9yY2VcXFwiLWRyYXduIG92ZXIgbG93ZXIgb25lc1xcblwiICtcblwiICAgIHJlb3JkZXJMYXllcnMoYV9sYXllciwgdV9udW1fbGF5ZXJzLCBwb3NpdGlvbik7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBnbF9Qb3NpdGlvbiA9IHBvc2l0aW9uO1xcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ3N0eWxlcy9wb2ludHMvcG9pbnRzLmZyYWdtZW50J10gPVxuXCJ1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cIiArXG5cInZhcnlpbmcgdmVjMiB2X3RleGNvb3JkO1xcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIG1haW4gKHZvaWQpIHtcXG5cIiArXG5cIiAgICB2ZWM0IGNvbG9yID0gdl9jb2xvcjtcXG5cIiArXG5cIiAgICB2ZWMzIGxpZ2h0aW5nID0gdmVjMygxLik7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBTaW1wbGUgdGhyZXNob2xkIGF0IGRvdCByYWRpdXNcXG5cIiArXG5cIiAgICB2ZWMyIHV2ID0gdl90ZXhjb29yZCAqIDIuIC0gMS47XFxuXCIgK1xuXCIgICAgZmxvYXQgbGVuID0gbGVuZ3RoKHV2KTtcXG5cIiArXG5cIiAgICBpZiAobGVuID4gMS4pIHtcXG5cIiArXG5cIiAgICAgICAgZGlzY2FyZDtcXG5cIiArXG5cIiAgICB9XFxuXCIgK1xuXCIgICAgY29sb3IucmdiICo9ICgxLiAtIHNtb290aHN0ZXAoLjI1LCAxLiwgbGVuKSkgKyAwLjU7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjcHJhZ21hIHRhbmdyYW06IGNvbG9yXFxuXCIgK1xuXCIgICAgI3ByYWdtYSB0YW5ncmFtOiBmaWx0ZXJcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFRPRE86IGxlZ2FjeSwgcmVwbGFjZSBpbiBleGlzdGluZyBzdHlsZXNcXG5cIiArXG5cIiAgICAvLyAjcHJhZ21hIHRhbmdyYW06IGZyYWdtZW50XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydzdHlsZXMvc3ByaXRlcy9zcHJpdGVzX2ZyYWdtZW50J10gPVxuXCJ1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xcblwiICtcblwidW5pZm9ybSB2ZWMyIHVfYXNwZWN0O1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X21ldGVyc19wZXJfcGl4ZWw7XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfdGltZTtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV9tYXBfem9vbTtcXG5cIiArXG5cInVuaWZvcm0gdmVjMiB1X21hcF9jZW50ZXI7XFxuXCIgK1xuXCJ1bmlmb3JtIHZlYzIgdV90aWxlX29yaWdpbjtcXG5cIiArXG5cIlxcblwiICtcblwidmFyeWluZyB2ZWMyIHZfdGV4Y29vcmQ7XFxuXCIgK1xuXCJcXG5cIiArXG5cIi8vIGJ1aWx0LWluIHVuaWZvcm1zIGZvciB0ZXh0dXJlIG1hcHNcXG5cIiArXG5cIiNpZiBkZWZpbmVkKE5VTV9URVhUVVJFUylcXG5cIiArXG5cIiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVzW05VTV9URVhUVVJFU107XFxuXCIgK1xuXCIjZWxzZVxcblwiICtcblwiICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZXNbMV07XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBnbG9iYWxzXFxuXCIgK1xuXCJcXG5cIiArXG5cInZvaWQgbWFpbiAodm9pZCkge1xcblwiICtcblwiICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlc1swXSwgdl90ZXhjb29yZCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjcHJhZ21hIHRhbmdyYW06IGNvbG9yXFxuXCIgK1xuXCIgICAgI3ByYWdtYSB0YW5ncmFtOiBmaWx0ZXJcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFRPRE86IGxlZ2FjeSwgcmVwbGFjZSBpbiBleGlzdGluZyBzdHlsZXNcXG5cIiArXG5cIiAgICAvLyAjcHJhZ21hIHRhbmdyYW06IGZyYWdtZW50XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydzdHlsZXMvc3ByaXRlcy9zcHJpdGVzX3ZlcnRleCddID1cblwidW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcXG5cIiArXG5cInVuaWZvcm0gdmVjMiB1X2FzcGVjdDtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV90aW1lO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X21hcF96b29tO1xcblwiICtcblwidW5pZm9ybSB2ZWMyIHVfbWFwX2NlbnRlcjtcXG5cIiArXG5cInVuaWZvcm0gdmVjMiB1X3RpbGVfb3JpZ2luO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X21ldGVyc19wZXJfcGl4ZWw7XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfb3JkZXJfbWluO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X29yZGVyX3JhbmdlO1xcblwiICtcblwiXFxuXCIgK1xuXCJ1bmlmb3JtIG1hdDQgdV9tb2RlbDtcXG5cIiArXG5cInVuaWZvcm0gbWF0NCB1X21vZGVsVmlldztcXG5cIiArXG5cIlxcblwiICtcblwiYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcXG5cIiArXG5cImF0dHJpYnV0ZSB2ZWM0IGFfc2hhcGU7XFxuXCIgK1xuXCJhdHRyaWJ1dGUgdmVjMiBhX3RleGNvb3JkO1xcblwiICtcblwiYXR0cmlidXRlIGZsb2F0IGFfbGF5ZXI7XFxuXCIgK1xuXCJcXG5cIiArXG5cInZhcnlpbmcgdmVjMiB2X3RleGNvb3JkO1xcblwiICtcblwiXFxuXCIgK1xuXCIjaWYgZGVmaW5lZChGRUFUVVJFX1NFTEVDVElPTilcXG5cIiArXG5cIiAgICBhdHRyaWJ1dGUgdmVjNCBhX3NlbGVjdGlvbl9jb2xvcjtcXG5cIiArXG5cIiAgICB2YXJ5aW5nIHZlYzQgdl9zZWxlY3Rpb25fY29sb3I7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBnbG9iYWxzXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGNhbWVyYVxcblwiICtcblwiXFxuXCIgK1xuXCJ2ZWMyIHJvdGF0ZTJEKHZlYzIgX3N0LCBmbG9hdCBfYW5nbGUpIHtcXG5cIiArXG5cIiAgICByZXR1cm4gbWF0Mihjb3MoX2FuZ2xlKSwtc2luKF9hbmdsZSksXFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgc2luKF9hbmdsZSksY29zKF9hbmdsZSkpICogX3N0O1xcblwiICtcblwifVxcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIG1haW4oKSB7XFxuXCIgK1xuXCIgICAgLy8gU2VsZWN0aW9uIHBhc3Mtc3BlY2lmaWMgcmVuZGVyaW5nXFxuXCIgK1xuXCIgICAgI2lmIGRlZmluZWQoRkVBVFVSRV9TRUxFQ1RJT04pXFxuXCIgK1xuXCIgICAgICAgIGlmIChhX3NlbGVjdGlvbl9jb2xvci5yZ2IgPT0gdmVjMygwLikpIHtcXG5cIiArXG5cIiAgICAgICAgICAgIC8vIERpc2NhcmQgYnkgZm9yY2luZyBpbnZhbGlkIHRyaWFuZ2xlIGlmIHdlXFwncmUgaW4gdGhlIGZlYXR1cmVcXG5cIiArXG5cIiAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBwYXNzIGJ1dCBoYXZlIG5vIHNlbGVjdGlvbiBpbmZvXFxuXCIgK1xuXCIgICAgICAgICAgICAvLyBUT0RPOiBpbiBzb21lIGNhc2VzIHdlIG1heSBhY3R1YWxseSB3YW50IG5vbi1zZWxlY3RhYmxlIGZlYXR1cmVzIHRvIG9jY2x1ZGUgc2VsZWN0YWJsZSBvbmVzP1xcblwiICtcblwiICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KDAuLCAwLiwgMC4sIDEuKTtcXG5cIiArXG5cIiAgICAgICAgICAgIHJldHVybjtcXG5cIiArXG5cIiAgICAgICAgfVxcblwiICtcblwiICAgICAgICB2X3NlbGVjdGlvbl9jb2xvciA9IGFfc2VsZWN0aW9uX2NvbG9yO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgdl90ZXhjb29yZCA9IGFfdGV4Y29vcmQ7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBQb3NpdGlvblxcblwiICtcblwiICAgIHZlYzQgcG9zaXRpb24gPSB1X21vZGVsVmlldyAqIHZlYzQoYV9wb3NpdGlvbiwgMS4pO1xcblwiICtcblwiICAgIHZlYzQgc2hhcGUgPSBhX3NoYXBlO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gVE9ETzogbGVnYWN5LCByZXBsYWNlIGluIGV4aXN0aW5nIHN0eWxlc1xcblwiICtcblwiICAgIC8vICNwcmFnbWEgdGFuZ3JhbTogdmVydGV4XFxuXCIgK1xuXCIgICAgI3ByYWdtYSB0YW5ncmFtOiBwb3NpdGlvblxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgY2FtZXJhUHJvamVjdGlvbihwb3NpdGlvbik7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBBcHBseSBzY2FsaW5nIGluIHNjcmVlbiBzcGFjZVxcblwiICtcblwiICAgIGZsb2F0IHpzY2FsZSA9IGZyYWN0KHVfbWFwX3pvb20pICogKHNoYXBlLncgKiAyNTYuIC0gMS4pICsgMS47XFxuXCIgK1xuXCIgICAgLy8gZmxvYXQgenNjYWxlID0gbG9nKGZyYWN0KHVfbWFwX3pvb20pICsgMS4pIC8gbG9nKDIuKSAqIChzaGFwZS53IC0gMS4pICsgMS47XFxuXCIgK1xuXCIgICAgcG9zaXRpb24ueHkgKz0gcm90YXRlMkQoc2hhcGUueHkgKiAxMjguICogenNjYWxlLCByYWRpYW5zKHNoYXBlLnogKiAzNjAuKSkgKiAyLiAqIHBvc2l0aW9uLncgLyB1X3Jlc29sdXRpb247XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBSZS1vcmRlcnMgZGVwdGggc28gdGhhdCBoaWdoZXIgbnVtYmVyZWQgbGF5ZXJzIGFyZSBcXFwiZm9yY2VcXFwiLWRyYXduIG92ZXIgbG93ZXIgb25lc1xcblwiICtcblwiICAgIC8vIHJlb3JkZXJMYXllcnMoYV9sYXllciArIHVfb3JkZXJfbWluLCB1X29yZGVyX3JhbmdlLCBwb3NpdGlvbik7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBnbF9Qb3NpdGlvbiA9IHBvc2l0aW9uO1xcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ3N0eWxlcy9wb2x5Z29ucy9wb2x5Z29ucy5mcmFnbWVudCddID1cblwidW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcXG5cIiArXG5cInVuaWZvcm0gdmVjMiB1X2FzcGVjdDtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV9tZXRlcnNfcGVyX3BpeGVsO1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X3RpbWU7XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfbWFwX3pvb207XFxuXCIgK1xuXCJ1bmlmb3JtIHZlYzIgdV9tYXBfY2VudGVyO1xcblwiICtcblwidW5pZm9ybSB2ZWMyIHVfdGlsZV9vcmlnaW47XFxuXCIgK1xuXCJcXG5cIiArXG5cInZhcnlpbmcgdmVjNCB2X3Bvc2l0aW9uO1xcblwiICtcblwidmFyeWluZyB2ZWMzIHZfbm9ybWFsO1xcblwiICtcblwidmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzQgdl93b3JsZF9wb3NpdGlvbjtcXG5cIiArXG5cIlxcblwiICtcblwiLy8gYnVpbHQtaW4gdW5pZm9ybXMgZm9yIHRleHR1cmUgbWFwc1xcblwiICtcblwiI2lmIGRlZmluZWQoTlVNX1RFWFRVUkVTKVxcblwiICtcblwiICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZXNbTlVNX1RFWFRVUkVTXTtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWYgZGVmaW5lZChURVhUVVJFX0NPT1JEUylcXG5cIiArXG5cIiAgICB2YXJ5aW5nIHZlYzIgdl90ZXhjb29yZDtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIvLyBEZWZpbmUgYSB3cmFwIHZhbHVlIGZvciB3b3JsZCBjb29yZGluYXRlcyAoYWxsb3dzIG1vcmUgcHJlY2lzaW9uIGF0IGhpZ2hlciB6b29tcylcXG5cIiArXG5cIi8vIGUuZy4gYXQgd3JhcCAxMDAwLCB0aGUgd29ybGQgc3BhY2Ugd2lsbCB3cmFwIGV2ZXJ5IDEwMDAgbWV0ZXJzXFxuXCIgK1xuXCIjaWYgZGVmaW5lZChXT1JMRF9QT1NJVElPTl9XUkFQKVxcblwiICtcblwiICAgIHZlYzIgd29ybGRfcG9zaXRpb25fYW5jaG9yID0gdmVjMihmbG9vcih1X3RpbGVfb3JpZ2luIC8gV09STERfUE9TSVRJT05fV1JBUCkgKiBXT1JMRF9QT1NJVElPTl9XUkFQKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIENvbnZlcnQgYmFjayB0byBhYnNvbHV0ZSB3b3JsZCBwb3NpdGlvbiBpZiBuZWVkZWRcXG5cIiArXG5cIiAgICB2ZWM0IGFic29sdXRlV29ybGRQb3NpdGlvbiAoKSB7XFxuXCIgK1xuXCIgICAgICAgIHJldHVybiB2ZWM0KHZfd29ybGRfcG9zaXRpb24ueHkgKyB3b3JsZF9wb3NpdGlvbl9hbmNob3IsIHZfd29ybGRfcG9zaXRpb24ueiwgdl93b3JsZF9wb3NpdGlvbi53KTtcXG5cIiArXG5cIiAgICB9XFxuXCIgK1xuXCIjZWxzZVxcblwiICtcblwiICAgIHZlYzQgYWJzb2x1dGVXb3JsZFBvc2l0aW9uICgpIHtcXG5cIiArXG5cIiAgICAgICAgcmV0dXJuIHZfd29ybGRfcG9zaXRpb247XFxuXCIgK1xuXCIgICAgfVxcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZiBkZWZpbmVkKExJR0hUSU5HX0VOVklST05NRU5UKVxcblwiICtcblwiICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfZW52X21hcDtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWYgZGVmaW5lZChUQU5HUkFNX0xJR0hUSU5HX1ZFUlRFWClcXG5cIiArXG5cIiAgICB2YXJ5aW5nIHZlYzQgdl9saWdodGluZztcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGdsb2JhbHNcXG5cIiArXG5cIiNwcmFnbWEgdGFuZ3JhbTogY2FtZXJhXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IG1hdGVyaWFsXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGxpZ2h0aW5nXFxuXCIgK1xuXCJcXG5cIiArXG5cInZvaWQgbWFpbiAodm9pZCkge1xcblwiICtcblwiICAgIHZlYzQgY29sb3I7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBNb2RpZnkgbm9ybWFsIGJlZm9yZSBsaWdodGluZ1xcblwiICtcblwiICAgICNwcmFnbWEgdGFuZ3JhbTogbm9ybWFsXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWYgZGVmaW5lZChURVhUVVJFX0NPT1JEUykgJiYgZGVmaW5lZChIQVNfREVGQVVMVF9URVhUVVJFKVxcblwiICtcblwiICAgICAgICBjb2xvciA9IHRleHR1cmUyRCh0ZXh0dXJlX2RlZmF1bHQsIHZfdGV4Y29vcmQpO1xcblwiICtcblwiICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgIGNvbG9yID0gdl9jb2xvcjtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZiBkZWZpbmVkKExJR0hUSU5HX0VOVklST05NRU5UKVxcblwiICtcblwiICAgICAgICAvLyBSZXBsYWNlIG9iamVjdCBjb2xvciB3aXRoIGVudmlyb25tZW50IG1hcFxcblwiICtcblwiICAgICAgICBjb2xvci5yZ2IgPSBzcGhlcmljYWxFbnZpcm9ubWVudE1hcCh1X2V5ZSwgdl9wb3NpdGlvbi54eXosIHZfbm9ybWFsLCB1X3ZhbmlzaGluZ19wb2ludCwgdV9lbnZfbWFwKS5yZ2I7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBNb2RpZnkgY29sb3IgYW5kIG1hdGVyaWFsIHByb3BlcnRpZXMgYmVmb3JlIGxpZ2h0aW5nXFxuXCIgK1xuXCIgICAgI2lmICFkZWZpbmVkKFRBTkdSQU1fTElHSFRJTkdfVkVSVEVYKVxcblwiICtcblwiICAgICNwcmFnbWEgdGFuZ3JhbTogY29sb3JcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZiBkZWZpbmVkKFRBTkdSQU1fTElHSFRJTkdfRlJBR01FTlQpXFxuXCIgK1xuXCIgICAgICAgIGNvbG9yID0gY2FsY3VsYXRlTGlnaHRpbmcodl9wb3NpdGlvbi54eXogLSB1X2V5ZSwgdl9ub3JtYWwsIGNvbG9yKTtcXG5cIiArXG5cIiAgICAjZWxpZiBkZWZpbmVkKFRBTkdSQU1fTElHSFRJTkdfVkVSVEVYKVxcblwiICtcblwiICAgICAgICBjb2xvciA9IHZfbGlnaHRpbmc7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBNb2RpZnkgY29sb3IgYWZ0ZXIgbGlnaHRpbmcgKGZpbHRlci1saWtlIGVmZmVjdHMgdGhhdCBkb25cXCd0IHJlcXVpcmUgYSBhZGRpdGlvbmFsIHJlbmRlciBwYXNzZXMpXFxuXCIgK1xuXCIgICAgI3ByYWdtYSB0YW5ncmFtOiBmaWx0ZXJcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFRPRE86IGxlZ2FjeSwgcmVwbGFjZSBpbiBleGlzdGluZyBzdHlsZXNcXG5cIiArXG5cIiAgICAvLyAjcHJhZ21hIHRhbmdyYW06IGZyYWdtZW50XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydzdHlsZXMvcG9seWdvbnMvcG9seWdvbnMudmVydGV4J10gPVxuXCJ1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xcblwiICtcblwidW5pZm9ybSB2ZWMyIHVfYXNwZWN0O1xcblwiICtcblwidW5pZm9ybSBmbG9hdCB1X3RpbWU7XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfbWFwX3pvb207XFxuXCIgK1xuXCJ1bmlmb3JtIHZlYzIgdV9tYXBfY2VudGVyO1xcblwiICtcblwidW5pZm9ybSB2ZWMyIHVfdGlsZV9vcmlnaW47XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfbWV0ZXJzX3Blcl9waXhlbDtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV9vcmRlcl9taW47XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfb3JkZXJfcmFuZ2U7XFxuXCIgK1xuXCJcXG5cIiArXG5cInVuaWZvcm0gbWF0NCB1X21vZGVsO1xcblwiICtcblwidW5pZm9ybSBtYXQ0IHVfbW9kZWxWaWV3O1xcblwiICtcblwidW5pZm9ybSBtYXQzIHVfbm9ybWFsTWF0cml4O1xcblwiICtcblwiXFxuXCIgK1xuXCJhdHRyaWJ1dGUgdmVjMyBhX3Bvc2l0aW9uO1xcblwiICtcblwiYXR0cmlidXRlIHZlYzMgYV9ub3JtYWw7XFxuXCIgK1xuXCJhdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcblwiICtcblwiYXR0cmlidXRlIGZsb2F0IGFfbGF5ZXI7XFxuXCIgK1xuXCJcXG5cIiArXG5cInZhcnlpbmcgdmVjNCB2X3Bvc2l0aW9uO1xcblwiICtcblwidmFyeWluZyB2ZWMzIHZfbm9ybWFsO1xcblwiICtcblwidmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzQgdl93b3JsZF9wb3NpdGlvbjtcXG5cIiArXG5cIlxcblwiICtcblwiLy8gT3B0aW9uYWwgdGV4dHVyZSBVVnNcXG5cIiArXG5cIiNpZiBkZWZpbmVkKFRFWFRVUkVfQ09PUkRTKVxcblwiICtcblwiICAgIGF0dHJpYnV0ZSB2ZWMyIGFfdGV4Y29vcmQ7XFxuXCIgK1xuXCIgICAgdmFyeWluZyB2ZWMyIHZfdGV4Y29vcmQ7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiLy8gRGVmaW5lIGEgd3JhcCB2YWx1ZSBmb3Igd29ybGQgY29vcmRpbmF0ZXMgKGFsbG93cyBtb3JlIHByZWNpc2lvbiBhdCBoaWdoZXIgem9vbXMpXFxuXCIgK1xuXCIvLyBlLmcuIGF0IHdyYXAgMTAwMCwgdGhlIHdvcmxkIHNwYWNlIHdpbGwgd3JhcCBldmVyeSAxMDAwIG1ldGVyc1xcblwiICtcblwiI2lmIGRlZmluZWQoV09STERfUE9TSVRJT05fV1JBUClcXG5cIiArXG5cIiAgICB2ZWMyIHdvcmxkX3Bvc2l0aW9uX2FuY2hvciA9IHZlYzIoZmxvb3IodV90aWxlX29yaWdpbiAvIFdPUkxEX1BPU0lUSU9OX1dSQVApICogV09STERfUE9TSVRJT05fV1JBUCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBDb252ZXJ0IGJhY2sgdG8gYWJzb2x1dGUgd29ybGQgcG9zaXRpb24gaWYgbmVlZGVkXFxuXCIgK1xuXCIgICAgdmVjNCBhYnNvbHV0ZVdvcmxkUG9zaXRpb24gKCkge1xcblwiICtcblwiICAgICAgICByZXR1cm4gdmVjNCh2X3dvcmxkX3Bvc2l0aW9uLnh5ICsgd29ybGRfcG9zaXRpb25fYW5jaG9yLCB2X3dvcmxkX3Bvc2l0aW9uLnosIHZfd29ybGRfcG9zaXRpb24udyk7XFxuXCIgK1xuXCIgICAgfVxcblwiICtcblwiI2Vsc2VcXG5cIiArXG5cIiAgICB2ZWM0IGFic29sdXRlV29ybGRQb3NpdGlvbiAoKSB7XFxuXCIgK1xuXCIgICAgICAgIHJldHVybiB2X3dvcmxkX3Bvc2l0aW9uO1xcblwiICtcblwiICAgIH1cXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWYgZGVmaW5lZChGRUFUVVJFX1NFTEVDVElPTilcXG5cIiArXG5cIiAgICBhdHRyaWJ1dGUgdmVjNCBhX3NlbGVjdGlvbl9jb2xvcjtcXG5cIiArXG5cIiAgICB2YXJ5aW5nIHZlYzQgdl9zZWxlY3Rpb25fY29sb3I7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI2lmIGRlZmluZWQoVEFOR1JBTV9MSUdIVElOR19WRVJURVgpXFxuXCIgK1xuXCIgICAgdmFyeWluZyB2ZWM0IHZfbGlnaHRpbmc7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBnbG9iYWxzXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGNhbWVyYVxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBtYXRlcmlhbFxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBsaWdodGluZ1xcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIG1haW4oKSB7XFxuXCIgK1xuXCIgICAgLy8gU2VsZWN0aW9uIHBhc3Mtc3BlY2lmaWMgcmVuZGVyaW5nXFxuXCIgK1xuXCIgICAgI2lmIGRlZmluZWQoRkVBVFVSRV9TRUxFQ1RJT04pXFxuXCIgK1xuXCIgICAgICAgIGlmIChhX3NlbGVjdGlvbl9jb2xvci5yZ2IgPT0gdmVjMygwLikpIHtcXG5cIiArXG5cIiAgICAgICAgICAgIC8vIERpc2NhcmQgYnkgZm9yY2luZyBpbnZhbGlkIHRyaWFuZ2xlIGlmIHdlXFwncmUgaW4gdGhlIGZlYXR1cmVcXG5cIiArXG5cIiAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBwYXNzIGJ1dCBoYXZlIG5vIHNlbGVjdGlvbiBpbmZvXFxuXCIgK1xuXCIgICAgICAgICAgICAvLyBUT0RPOiBpbiBzb21lIGNhc2VzIHdlIG1heSBhY3R1YWxseSB3YW50IG5vbi1zZWxlY3RhYmxlIGZlYXR1cmVzIHRvIG9jY2x1ZGUgc2VsZWN0YWJsZSBvbmVzP1xcblwiICtcblwiICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KDAuLCAwLiwgMC4sIDEuKTtcXG5cIiArXG5cIiAgICAgICAgICAgIHJldHVybjtcXG5cIiArXG5cIiAgICAgICAgfVxcblwiICtcblwiICAgICAgICB2X3NlbGVjdGlvbl9jb2xvciA9IGFfc2VsZWN0aW9uX2NvbG9yO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gVGV4dHVyZSBVVnNcXG5cIiArXG5cIiAgICAjaWYgZGVmaW5lZChURVhUVVJFX0NPT1JEUylcXG5cIiArXG5cIiAgICAgICAgdl90ZXhjb29yZCA9IGFfdGV4Y29vcmQ7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBXb3JsZCBjb29yZGluYXRlcyBmb3IgM2QgcHJvY2VkdXJhbCB0ZXh0dXJlc1xcblwiICtcblwiICAgIHZfd29ybGRfcG9zaXRpb24gPSB1X21vZGVsICogdmVjNChhX3Bvc2l0aW9uLCAxLik7XFxuXCIgK1xuXCIgICAgI2lmIGRlZmluZWQoV09STERfUE9TSVRJT05fV1JBUClcXG5cIiArXG5cIiAgICAgICAgdl93b3JsZF9wb3NpdGlvbi54eSAtPSB3b3JsZF9wb3NpdGlvbl9hbmNob3I7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBQb3NpdGlvblxcblwiICtcblwiICAgIHZlYzQgcG9zaXRpb24gPSB1X21vZGVsVmlldyAqIHZlYzQoYV9wb3NpdGlvbiwgMS4pO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gVE9ETzogbGVnYWN5LCByZXBsYWNlIGluIGV4aXN0aW5nIHN0eWxlc1xcblwiICtcblwiICAgIC8vICNwcmFnbWEgdGFuZ3JhbTogdmVydGV4XFxuXCIgK1xuXCIgICAgI3ByYWdtYSB0YW5ncmFtOiBwb3NpdGlvblxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgdl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xcblwiICtcblwiICAgIHZfbm9ybWFsID0gbm9ybWFsaXplKHVfbm9ybWFsTWF0cml4ICogYV9ub3JtYWwpO1xcblwiICtcblwiICAgIHZfY29sb3IgPSBhX2NvbG9yO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gU2hhZGluZ1xcblwiICtcblwiICAgICNpZiBkZWZpbmVkKFRBTkdSQU1fTElHSFRJTkdfVkVSVEVYKVxcblwiICtcblwiICAgICAgICB2ZWM0IGNvbG9yID0gYV9jb2xvcjtcXG5cIiArXG5cIiAgICAgICAgdmVjMyBub3JtYWwgPSBhX25vcm1hbDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAvLyBNb2RpZnkgbm9ybWFsIGJlZm9yZSBsaWdodGluZ1xcblwiICtcblwiICAgICAgICAjcHJhZ21hIHRhbmdyYW06IG5vcm1hbFxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIC8vIE1vZGlmeSBjb2xvciBhbmQgbWF0ZXJpYWwgcHJvcGVydGllcyBiZWZvcmUgbGlnaHRpbmdcXG5cIiArXG5cIiAgICAgICAgI3ByYWdtYSB0YW5ncmFtOiBjb2xvclxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIHZfbGlnaHRpbmcgPSBjYWxjdWxhdGVMaWdodGluZyhwb3NpdGlvbi54eXosIG5vcm1hbCwgY29sb3IpO1xcblwiICtcblwiICAgICAgICB2X2NvbG9yID0gY29sb3I7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBDYW1lcmFcXG5cIiArXG5cIiAgICBjYW1lcmFQcm9qZWN0aW9uKHBvc2l0aW9uKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFJlLW9yZGVycyBkZXB0aCBzbyB0aGF0IGhpZ2hlciBudW1iZXJlZCBsYXllcnMgYXJlIFxcXCJmb3JjZVxcXCItZHJhd24gb3ZlciBsb3dlciBvbmVzXFxuXCIgK1xuXCIgICAgcmVvcmRlckxheWVycyhhX2xheWVyICsgdV9vcmRlcl9taW4sIHVfb3JkZXJfcmFuZ2UsIHBvc2l0aW9uKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGdsX1Bvc2l0aW9uID0gcG9zaXRpb247XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBzaGFkZXJTb3VyY2VzO1xuIiwiLypnbG9iYWwgVGV4dHVyZSAqL1xuLy8gVGV4dHVyZSBtYW5hZ2VtZW50XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IHN1YnNjcmliZU1peGluIGZyb20gJy4uL3V0aWxzL3N1YnNjcmliZSc7XG5pbXBvcnQgV29ya2VyQnJva2VyIGZyb20gJy4uL3V0aWxzL3dvcmtlcl9icm9rZXInO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbi8vIEdsb2JhbCBzZXQgb2YgdGV4dHVyZXMsIGJ5IG5hbWVcblRleHR1cmUudGV4dHVyZXMgPSB7fTtcblxuc3Vic2NyaWJlTWl4aW4oVGV4dHVyZSk7XG5cbi8vIEdMIHRleHR1cmUgd3JhcHBlciBvYmplY3QgZm9yIGtlZXBpbmcgdHJhY2sgb2YgYSBnbG9iYWwgc2V0IG9mIHRleHR1cmVzLCBrZXllZCBieSBhIHVuaXF1ZSB1c2VyLWRlZmluZWQgbmFtZVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVGV4dHVyZSAoZ2wsIG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgaWYgKHRoaXMudGV4dHVyZSkge1xuICAgICAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5iaW5kKCk7XG4gICAgdGhpcy5pbWFnZSA9IG51bGw7ICAgICAgLy8gYW4gSW1hZ2Ugb2JqZWN0L2VsZW1lbnQgdGhhdCBpcyB0aGUgc291cmNlIGZvciB0aGlzIHRleHR1cmVcbiAgICB0aGlzLmNhbnZhcyA9IG51bGw7ICAgICAvLyBhIENhbnZhcyBvYmplY3QvZWxlbWVudCB0aGF0IGlzIHRoZSBzb3VyY2UgZm9yIHRoaXMgdGV4dHVyZVxuICAgIHRoaXMubG9hZGluZyA9IG51bGw7ICAgIC8vIGEgUHJvbWlzZSBvYmplY3QgdG8gdHJhY2sgdGhlIGxvYWRpbmcgc3RhdGUgb2YgdGhpcyB0ZXh0dXJlXG5cbiAgICAvLyBEZWZhdWx0IHRvIGEgMS1waXhlbCBibGFjayB0ZXh0dXJlIHNvIHdlIGNhbiBzYWZlbHkgcmVuZGVyIHdoaWxlIHdlIHdhaXQgZm9yIGFuIGltYWdlIHRvIGxvYWRcbiAgICAvLyBTZWU6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTk3MjIyNDcvd2ViZ2wtd2FpdC1mb3ItdGV4dHVyZS10by1sb2FkXG4gICAgdGhpcy5zZXREYXRhKDEsIDEsIG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAyNTVdKSwgeyBmaWx0ZXJpbmc6ICduZWFyZXN0JyB9KTtcblxuICAgIC8vIFRPRE86IGJldHRlciBzdXBwb3J0IGZvciBub24tVVJMIHNvdXJjZXM6IGNhbnZhcy92aWRlbyBlbGVtZW50cywgcmF3IHBpeGVsIGJ1ZmZlcnNcblxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5maWx0ZXJpbmcgPSBvcHRpb25zLmZpbHRlcmluZztcblxuICAgIC8vIERlc3Ryb3kgcHJldmlvdXMgdGV4dHVyZSBpZiBwcmVzZW50XG4gICAgaWYgKFRleHR1cmUudGV4dHVyZXNbdGhpcy5uYW1lXSkge1xuICAgICAgICBUZXh0dXJlLnRleHR1cmVzW3RoaXMubmFtZV0uZGVzdHJveSgpO1xuICAgIH1cblxuICAgIFRleHR1cmUudGV4dHVyZXNbdGhpcy5uYW1lXSA9IHRoaXM7XG5cbiAgICB0aGlzLnNwcml0ZXMgPSBvcHRpb25zLnNwcml0ZXM7XG59XG5cbi8vIERlc3Ryb3kgYSBzaW5nbGUgdGV4dHVyZSBpbnN0YW5jZVxuVGV4dHVyZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMudmFsaWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlKTtcbiAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuICAgIGRlbGV0ZSB0aGlzLmRhdGE7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICBkZWxldGUgVGV4dHVyZS50ZXh0dXJlc1t0aGlzLm5hbWVdO1xuICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbn07XG5cbi8vIERlc3Ryb3kgYWxsIHRleHR1cmUgaW5zdGFuY2VzIGZvciBhIGdpdmVuIEdMIGNvbnRleHRcblRleHR1cmUuZGVzdHJveSA9IGZ1bmN0aW9uIChnbCkge1xuICAgIHZhciB0ZXh0dXJlcyA9IE9iamVjdC5rZXlzKFRleHR1cmUudGV4dHVyZXMpO1xuICAgIGZvciAodmFyIHQgb2YgdGV4dHVyZXMpIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSBUZXh0dXJlLnRleHR1cmVzW3RdO1xuICAgICAgICBpZiAodGV4dHVyZS5nbCA9PT0gZ2wpIHtcbiAgICAgICAgICAgIGxvZy50cmFjZShgZGVzdHJveWluZyBUZXh0dXJlICR7dGV4dHVyZS5uYW1lfWApO1xuICAgICAgICAgICAgdGV4dHVyZS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5UZXh0dXJlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgICBpZiAoIXRoaXMudmFsaWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodW5pdCkge1xuICAgICAgICB0aGlzLmdsLmFjdGl2ZVRleHR1cmUodGhpcy5nbC5URVhUVVJFMCArIHVuaXQpO1xuICAgIH1cbiAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbn07XG5cblRleHR1cmUucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG59O1xuXG4vLyBMb2FkcyBhIHRleHR1cmUgZnJvbSBhIFVSTFxuVGV4dHVyZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGhpcy52YWxpZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkaW5nID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLmltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIHRoaXMuaW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUob3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnNldFRleHR1cmVGaWx0ZXJpbmcob3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDsgLy8gbXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggb3RoZXIgdHlwZXNcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XG5cbiAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW1hZ2Uuc3JjID0gdXJsO1xuICAgICAgICAvLyBUT0RPOiBlcnJvci9wcm9taXNlIHJlamVjdFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmxvYWRpbmc7XG59O1xuXG4vLyBTZXRzIHRleHR1cmUgdG8gYSByYXcgaW1hZ2UgYnVmZmVyXG5UZXh0dXJlLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuXG4gICAgdGhpcy5pbWFnZSA9IG51bGw7IC8vIG11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIG90aGVyIHR5cGVzXG4gICAgdGhpcy5jYW52YXMgPSBudWxsO1xuXG4gICAgdGhpcy51cGRhdGUob3B0aW9ucyk7XG4gICAgdGhpcy5zZXRUZXh0dXJlRmlsdGVyaW5nKG9wdGlvbnMpO1xufTtcblxuLy8gU2V0cyB0aGUgdGV4dHVyZSB0byB0cmFjayBhIGNhbnZhcyBlbGVtZW50XG5UZXh0dXJlLnByb3RvdHlwZS5zZXRDYW52YXMgPSBmdW5jdGlvbiAoY2FudmFzLCBvcHRpb25zKSB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy51cGRhdGUob3B0aW9ucyk7XG4gICAgdGhpcy5zZXRUZXh0dXJlRmlsdGVyaW5nKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5pbWFnZSA9IG51bGw7IC8vIG11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIG90aGVyIHR5cGVzXG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbn07XG5cbi8vIFVwbG9hZHMgY3VycmVudCBpbWFnZSBvciBidWZmZXIgdG8gdGhlIEdQVSAoY2FuIGJlIHVzZWQgdG8gdXBkYXRlIGFuaW1hdGVkIHRleHR1cmVzIG9uIHRoZSBmbHkpXG5UZXh0dXJlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLnZhbGlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmJpbmQoKTtcbiAgICB0aGlzLmdsLnBpeGVsU3RvcmVpKHRoaXMuZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgKG9wdGlvbnMuVU5QQUNLX0ZMSVBfWV9XRUJHTCA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWUpKTtcbiAgICB0aGlzLmdsLnBpeGVsU3RvcmVpKHRoaXMuZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBvcHRpb25zLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCB8fCBmYWxzZSk7XG5cbiAgICAvLyBJbWFnZSBlbGVtZW50XG4gICAgaWYgKHRoaXMuaW1hZ2UgJiYgdGhpcy5pbWFnZS5jb21wbGV0ZSkge1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5pbWFnZS53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmltYWdlLmhlaWdodDtcbiAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuVU5TSUdORURfQllURSwgdGhpcy5pbWFnZSk7XG4gICAgfVxuICAgIC8vIENhbnZhcyBlbGVtZW50XG4gICAgZWxzZSBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodDtcbiAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuVU5TSUdORURfQllURSwgdGhpcy5jYW52YXMpO1xuICAgIH1cbiAgICAvLyBSYXcgaW1hZ2UgYnVmZmVyXG4gICAgZWxzZSBpZiAodGhpcy53aWR0aCAmJiB0aGlzLmhlaWdodCkgeyAvLyBOT1RFOiB0aGlzLmRhdGEgY2FuIGJlIG51bGwsIHRvIHplcm8gb3V0IHRleHR1cmVcbiAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuZGF0YSk7XG4gICAgfVxuXG4gICAgVGV4dHVyZS50cmlnZ2VyKCd1cGRhdGUnLCB0aGlzKTtcbn07XG5cbi8vIERldGVybWluZXMgYXBwcm9wcmlhdGUgZmlsdGVyaW5nIG1vZGVcblRleHR1cmUucHJvdG90eXBlLnNldFRleHR1cmVGaWx0ZXJpbmcgPSBmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLnZhbGlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvcHRpb25zLmZpbHRlcmluZyA9IG9wdGlvbnMuZmlsdGVyaW5nIHx8IHRoaXMuZmlsdGVyaW5nIHx8ICdtaXBtYXAnOyAvLyBkZWZhdWx0IHRvIG1pcG1hcHMgZm9yIHBvd2VyLW9mLTIgdGV4dHVyZXNcblxuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgdGhpcy5iaW5kKCk7XG5cbiAgICAvLyBGb3IgcG93ZXItb2YtMiB0ZXh0dXJlcywgdGhlIGZvbGxvd2luZyBwcmVzZXRzIGFyZSBhdmFpbGFibGU6XG4gICAgLy8gbWlwbWFwOiBsaW5lYXIgYmxlbmQgZnJvbSBuZWFyZXN0IG1pcFxuICAgIC8vIGxpbmVhcjogbGluZWFyIGJsZW5kIGZyb20gb3JpZ2luYWwgaW1hZ2UgKG5vIG1pcHMpXG4gICAgLy8gbmVhcmVzdDogbmVhcmVzdCBwaXhlbCBmcm9tIG9yaWdpbmFsIGltYWdlIChubyBtaXBzLCAnYmxvY2t5JyBsb29rKVxuICAgIGlmIChVdGlscy5pc1Bvd2VyT2YyKHRoaXMud2lkdGgpICYmIFV0aWxzLmlzUG93ZXJPZjIodGhpcy5oZWlnaHQpKSB7XG4gICAgICAgIHRoaXMucG93ZXJfb2ZfMiA9IHRydWU7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIG9wdGlvbnMuVEVYVFVSRV9XUkFQX1MgfHwgKG9wdGlvbnMucmVwZWF0ICYmIGdsLlJFUEVBVCkgfHwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIG9wdGlvbnMuVEVYVFVSRV9XUkFQX1QgfHwgKG9wdGlvbnMucmVwZWF0ICYmIGdsLlJFUEVBVCkgfHwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZmlsdGVyaW5nID09PSAnbWlwbWFwJykge1xuICAgICAgICAgICAgbG9nLnRyYWNlKCdwb3dlci1vZi0yIE1JUE1BUCcpO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJpbmcgPSAnbWlwbWFwJztcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1QpOyAvLyBUT0RPOiB1c2UgdHJpbGluZWFyIGZpbHRlcmluZyBieSBkZWZ1YWx0IGluc3RlYWQ/XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZmlsdGVyaW5nID09PSAnbGluZWFyJykge1xuICAgICAgICAgICAgbG9nLnRyYWNlKCdwb3dlci1vZi0yIExJTkVBUicpO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJpbmcgPSAnbGluZWFyJztcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5maWx0ZXJpbmcgPT09ICduZWFyZXN0Jykge1xuICAgICAgICAgICAgbG9nLnRyYWNlKCdwb3dlci1vZi0yIE5FQVJFU1QnKTtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyaW5nID0gJ25lYXJlc3QnO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBXZWJHTCBoYXMgc3RyaWN0IHJlcXVpcmVtZW50cyBvbiBub24tcG93ZXItb2YtMiB0ZXh0dXJlczpcbiAgICAgICAgLy8gTm8gbWlwbWFwcyBhbmQgbXVzdCBjbGFtcCB0byBlZGdlXG4gICAgICAgIHRoaXMucG93ZXJfb2ZfMiA9IGZhbHNlO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZmlsdGVyaW5nID09PSAnbmVhcmVzdCcpIHtcbiAgICAgICAgICAgIGxvZy50cmFjZSgncG93ZXItb2YtMiBORUFSRVNUJyk7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcmluZyA9ICduZWFyZXN0JztcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gZGVmYXVsdCB0byBsaW5lYXIgZm9yIG5vbi1wb3dlci1vZi0yIHRleHR1cmVzXG4gICAgICAgICAgICBsb2cudHJhY2UoJ3Bvd2VyLW9mLTIgTElORUFSJyk7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcmluZyA9ICdsaW5lYXInO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudW5iaW5kKCk7XG4gICAgVGV4dHVyZS50cmlnZ2VyKCd1cGRhdGUnLCB0aGlzKTtcbn07XG5cbi8vIFN0YXRpYy9jbGFzcyBtZXRob2RzXG5cbi8vIEdldCBtZXRhZGF0YSBmb3IgYSB0ZXh0dXJlIGJ5IG5hbWVcbi8vIFJldHVybnMgdmlhIHByb21pc2UsIGluIGNhc2UgdGV4dHVyZSBpcyBzdGlsbCBsb2FkaW5nXG4vLyBDYW4gYmUgY2FsbGVkIG9uIG1haW4gdGhyZWFkIGZyb20gd29ya2VyLCB0byBzeW5jIHRleHR1cmUgaW5mbyB0byB3b3JrZXJcblRleHR1cmUuZ2V0SW5mbyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgLy8gR2V0IGluZm8gZm9yIGFsbCB0ZXh0dXJlcyBieSBkZWZhdWx0XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBPYmplY3Qua2V5cyhUZXh0dXJlLnRleHR1cmVzKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgbXVsdGlwbGUgdGV4dHVyZXNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobmFtZS5tYXAobiA9PiBUZXh0dXJlLmdldEluZm8obikpKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgc2luZ2xlIHRleHR1cmVcbiAgICB2YXIgdGV4ID0gVGV4dHVyZS50ZXh0dXJlc1tuYW1lXTtcbiAgICBpZiAodGV4KSB7XG4gICAgICAgIC8vIFdhaXQgZm9yIHRoaXMgdGV4dHVyZSB0byBmaW5pc2ggbG9hZGluZywgb3IgcmV0dXJuIGltbWVkaWF0ZWx5XG4gICAgICAgIHZhciBsb2FkaW5nID0gdGV4LmxvYWRpbmcgfHwgUHJvbWlzZS5yZXNvbHZlKHRleCk7XG4gICAgICAgIHJldHVybiBsb2FkaW5nLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGEgc3Vic2V0IG9mIHRleHR1cmUgaW5mb1xuICAgICAgICAgICAgLy8gKGNvbXBhdGlibGUgdy9zdHJ1Y3R1cmVkIGNsb25pbmcsIHN1aXRhYmxlIGZvciBwYXNzaW5nIHRvIGEgd29ya2VyKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0ZXgubmFtZSxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGV4LndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGV4LmhlaWdodCxcbiAgICAgICAgICAgICAgICBzcHJpdGVzOiB0ZXguc3ByaXRlcyxcbiAgICAgICAgICAgICAgICBmaWx0ZXJpbmc6IHRleC5maWx0ZXJpbmcsXG4gICAgICAgICAgICAgICAgcG93ZXJfb2ZfMjogdGV4LnBvd2VyX29mXzIsXG4gICAgICAgICAgICAgICAgdmFsaWQ6IHRleC52YWxpZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBObyB0ZXh0dXJlIGZvdW5kXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgfVxufTtcblxuLy8gU3luYyB0ZXh0dXJlIGluZm8gdG8gd29ya2VyXG4vLyBDYWxsZWQgZnJvbSB3b3JrZXIsIGdldHMgaW5mbyBvbiBvbmUgb3IgbW9yZSB0ZXh0dXJlcyBpbmZvIGZyb20gbWFpbiB0aHJlYWQgdmlhIHJlbW90ZSBjYWxsLCB0aGVuIHN0b3JlcyBpdFxuLy8gbG9jYWxseSBpbiB3b3JrZXIuICd0ZXh0dXJlcycgY2FuIGJlIGFuIGFycmF5IG9mIHRleHR1cmUgbmFtZXMgdG8gc3luYywgb3IgaWYgbnVsbCwgYWxsIHRleHR1cmVzIGFyZSBzeW5jZWQuXG5UZXh0dXJlLnN5bmNUZXh0dXJlc1RvV29ya2VyID0gZnVuY3Rpb24gKG5hbWVzKSB7XG4gICAgcmV0dXJuIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSgnVGV4dHVyZScsICdnZXRJbmZvJywgbmFtZXMpLlxuICAgICAgICB0aGVuKHRleHR1cmVzID0+IHtcbiAgICAgICAgICAgIGZvciAodmFyIHRleCBvZiB0ZXh0dXJlcykge1xuICAgICAgICAgICAgICAgIFRleHR1cmUudGV4dHVyZXNbdGV4Lm5hbWVdID0gdGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUudGV4dHVyZXM7XG4gICAgICAgIH0pO1xufTtcbiIsIi8qIGdsb2JhbCBWQk9NZXNoICovXG4vLyBNYW5hZ2UgcmVuZGVyaW5nIGZvciBwcmltaXRpdmVzXG5pbXBvcnQgR0xTTCBmcm9tICcuL2dsc2wnO1xuaW1wb3J0IFNoYWRlclByb2dyYW0gZnJvbSAnLi9zaGFkZXJfcHJvZ3JhbSc7XG5pbXBvcnQgVGV4dHVyZSBmcm9tICcuL3RleHR1cmUnO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbi8vIEEgc2luZ2xlIG1lc2gvVkJPLCBkZXNjcmliZWQgYnkgYSB2ZXJ0ZXggbGF5b3V0LCB0aGF0IGNhbiBiZSBkcmF3biB3aXRoIG9uZSBvciBtb3JlIHByb2dyYW1zXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBWQk9NZXNoIChnbCwgdmVydGV4X2RhdGEsIHZlcnRleF9sYXlvdXQsIG9wdGlvbnMpXG57XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy52ZXJ0ZXhfZGF0YSA9IHZlcnRleF9kYXRhOyAvLyB0eXBlZCBhcnJheVxuICAgIHRoaXMudmVydGV4X2xheW91dCA9IHZlcnRleF9sYXlvdXQ7XG4gICAgdGhpcy5idWZmZXIgPSB0aGlzLmdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMuZHJhd19tb2RlID0gb3B0aW9ucy5kcmF3X21vZGUgfHwgdGhpcy5nbC5UUklBTkdMRVM7XG4gICAgdGhpcy5kYXRhX3VzYWdlID0gb3B0aW9ucy5kYXRhX3VzYWdlIHx8IHRoaXMuZ2wuU1RBVElDX0RSQVc7XG4gICAgdGhpcy52ZXJ0aWNlc19wZXJfZ2VvbWV0cnkgPSAzOyAvLyBUT0RPOiBzdXBwb3J0IGxpbmVzLCBzdHJpcCwgZmFuLCBldGMuXG4gICAgdGhpcy51bmlmb3JtcyA9IG9wdGlvbnMudW5pZm9ybXM7XG5cbiAgICB0aGlzLnZlcnRleF9jb3VudCA9IHRoaXMudmVydGV4X2RhdGEuYnl0ZUxlbmd0aCAvIHRoaXMudmVydGV4X2xheW91dC5zdHJpZGU7XG4gICAgdGhpcy5nZW9tZXRyeV9jb3VudCA9IHRoaXMudmVydGV4X2NvdW50IC8gdGhpcy52ZXJ0aWNlc19wZXJfZ2VvbWV0cnk7XG5cbiAgICAvLyBUT0RPOiBkaXNhYmxpbmcgVkFPcyBmb3Igbm93IGJlY2F1c2Ugd2UgbmVlZCB0byBzdXBwb3J0IGRpZmZlcmVudCB2ZXJ0ZXggbGF5b3V0ICsgcHJvZ3JhbSBjb21iaW5hdGlvbnMsXG4gICAgLy8gd2hlcmUgbm90IGFsbCBwcm9ncmFtcyB3aWxsIHJlY29nbml6ZSBhbGwgYXR0cmlidXRlcyAoZS5nLiBmZWF0dXJlIHNlbGVjdGlvbiBzaGFkZXJzIGluY2x1ZGUgZXh0cmEgYXR0cmliKS5cbiAgICAvLyBUbyBzdXBwb3J0IFZBT3MgaGVyZSwgd291bGQgbmVlZCB0byBzdXBwb3J0IG11bHRpcGxlIHBlciBnZW9tZXRyeSwga2V5ZWQgYnkgR0wgcHJvZ3JhbT9cbiAgICAvLyB0aGlzLnZhbyA9IFZlcnRleEFycmF5T2JqZWN0LmNyZWF0ZShmdW5jdGlvbigpIHtcbiAgICAvLyAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XG4gICAgLy8gICAgIHRoaXMuc2V0dXAoKTtcbiAgICAvLyB9LmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcik7XG4gICAgdGhpcy5nbC5idWZmZXJEYXRhKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRleF9kYXRhLCB0aGlzLmRhdGFfdXNhZ2UpO1xuICAgIHRoaXMudmFsaWQgPSB0cnVlO1xufVxuXG4vLyBSZW5kZXIsIGJ5IGRlZmF1bHQgd2l0aCBjdXJyZW50bHkgYm91bmQgcHJvZ3JhbSwgb3Igb3RoZXJ3aXNlIHdpdGggb3B0aW9uYWxseSBwcm92aWRlZCBvbmVcblZCT01lc2gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChvcHRpb25zID0ge30pXG57XG4gICAgaWYgKCF0aGlzLnZhbGlkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBWZXJ0ZXhBcnJheU9iamVjdC5iaW5kKHRoaXMudmFvKTtcblxuICAgIGlmICh0eXBlb2YgdGhpcy5fcmVuZGVyX3NldHVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcl9zZXR1cCgpO1xuICAgIH1cblxuICAgIHZhciBwcm9ncmFtID0gb3B0aW9ucy5wcm9ncmFtIHx8IFNoYWRlclByb2dyYW0uY3VycmVudDtcbiAgICBwcm9ncmFtLnVzZSgpO1xuXG4gICAgaWYgKHRoaXMudW5pZm9ybXMpIHtcbiAgICAgICAgcHJvZ3JhbS5zYXZlVW5pZm9ybXModGhpcy51bmlmb3Jtcyk7XG4gICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybXModGhpcy51bmlmb3JtcywgZmFsc2UpOyAvLyBkb24ndCByZXNldCB0ZXh0dXJlIHVuaXRcbiAgICB9XG5cbiAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcbiAgICB0aGlzLnZlcnRleF9sYXlvdXQuZW5hYmxlKHRoaXMuZ2wsIHByb2dyYW0pO1xuXG4gICAgLy8gVE9ETzogc3VwcG9ydCBlbGVtZW50IGFycmF5IG1vZGVcbiAgICB0aGlzLmdsLmRyYXdBcnJheXModGhpcy5kcmF3X21vZGUsIDAsIHRoaXMudmVydGV4X2NvdW50KTtcbiAgICAvLyBWZXJ0ZXhBcnJheU9iamVjdC5iaW5kKG51bGwpO1xuXG4gICAgaWYgKHRoaXMudW5pZm9ybXMpIHtcbiAgICAgICAgcHJvZ3JhbS5yZXN0b3JlVW5pZm9ybXModGhpcy51bmlmb3Jtcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5WQk9NZXNoLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAoIXRoaXMudmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG5cbiAgICBsb2cudHJhY2UoJ1ZCT01lc2guZGVzdHJveTogZGVsZXRlIGJ1ZmZlciBvZiBzaXplICcgKyB0aGlzLnZlcnRleF9kYXRhLmJ5dGVMZW5ndGgpO1xuXG4gICAgdGhpcy5nbC5kZWxldGVCdWZmZXIodGhpcy5idWZmZXIpO1xuICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICBkZWxldGUgdGhpcy52ZXJ0ZXhfZGF0YTtcblxuICAgIC8vIEZyZWUgdGV4dHVyZSB1bmlmb3JtcyB0aGF0IGFyZSBvd25lZCBieSB0aGlzIG1lc2hcbiAgICBmb3IgKGxldCB7dHlwZSwgdmFsdWV9IG9mIEdMU0wucGFyc2VVbmlmb3Jtcyh0aGlzLnVuaWZvcm1zKSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3NhbXBsZXIyRCcgJiYgVGV4dHVyZS50ZXh0dXJlc1t2YWx1ZV0pIHtcbiAgICAgICAgICAgIFRleHR1cmUudGV4dHVyZXNbdmFsdWVdLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcbiIsIi8qIGdsb2JhbCBWZXJ0ZXhEYXRhICovXG5cbmltcG9ydCBnbCBmcm9tICcuL2NvbnN0YW50cyc7IC8vIHdlYiB3b3JrZXJzIGRvbid0IGhhdmUgYWNjZXNzIHRvIEdMIGNvbnRleHQsIHNvIGltcG9ydCBhbGwgR0wgY29uc3RhbnRzXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcblxuLy8gQW4gaW50ZXJtZWRpYXJ5IG9iamVjdCB0aGF0IGhvbGRzIHZlcnRleCBkYXRhIGluIHR5cGVkIGFycmF5cywgYWNjb3JkaW5nIHRvIGEgZ2l2ZW4gdmVydGV4IGxheW91dFxuLy8gVXNlZCB0byBjb25zdHJ1Y3QgYSBtZXNoL1ZCTyBmb3IgcmVuZGVyaW5nXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZXJ0ZXhEYXRhIHtcblxuICAgIGNvbnN0cnVjdG9yICh2ZXJ0ZXhfbGF5b3V0KSB7XG4gICAgICAgIHRoaXMudmVydGV4X2xheW91dCA9IHZlcnRleF9sYXlvdXQ7XG4gICAgICAgIHRoaXMuYmxvY2tfc2l6ZSA9IDUwMDAwOyAgICAgLy8gYmxvY2sgc2l6ZSBpbiB3aGljaCB0byBhbGxvY2F0ZVxuICAgICAgICB0aGlzLmJsb2NrX251bSA9IDE7ICAgICAgICAgLy8gaW5pdGlhbCAjIG9mIGFsbG9jYXRlZCBibG9ja3NcbiAgICAgICAgdGhpcy5idWZmZXJfb2Zmc2V0ID0gMDsgICAgICAvLyBieXRlIG9mZnNldCBpbnRvIGN1cnJlbnRseSBhbGxvY2F0ZWQgYnVmZmVyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMudmVydGV4X2xheW91dC5zdHJpZGUgKiB0aGlzLmJsb2NrX3NpemUgKiB0aGlzLmJsb2NrX251bSk7XG4gICAgICAgIC8vIHRoaXMuY29tcG9uZW50cyA9IFtmb3IgKGNvbXBvbmVudCBvZiB0aGlzLnZlcnRleF9sYXlvdXQuY29tcG9uZW50cykgWy4uLmNvbXBvbmVudF1dOyAvLyBUT0RPOiB0dXJuIG9uIGFycmF5IGNvbXByZWhlbnNpb24gaW4gdHJhY2V1cj9cbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0gW107XG4gICAgICAgIGZvciAodmFyIGNvbXBvbmVudCBvZiB0aGlzLnZlcnRleF9sYXlvdXQuY29tcG9uZW50cykge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLnB1c2goWy4uLmNvbXBvbmVudF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVydGV4X2NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5zZXRCdWZmZXJWaWV3cygpO1xuICAgIH1cblxuICAgIC8vIChSZS0pYWxsb2NhdGUgdHlwZWQgdmlld3MgaW50byB0aGUgbWFpbiBidWZmZXIgLSBvbmx5IGNyZWF0ZSB0aGUgdHlwZXMgd2UgbmVlZCBmb3IgdGhpcyBsYXlvdXRcbiAgICBzZXRCdWZmZXJWaWV3cyAoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyX3ZpZXdzID0ge307XG4gICAgICAgIGZvciAodmFyIGF0dHJpYiBvZiB0aGlzLnZlcnRleF9sYXlvdXQuYXR0cmlicykge1xuICAgICAgICAgICAgLy8gTmVlZCB2aWV3IGZvciB0aGlzIHR5cGU/XG4gICAgICAgICAgICBpZiAodGhpcy5idWZmZXJfdmlld3NbYXR0cmliLnR5cGVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXlfdHlwZSA9IHRoaXMuYXJyYXlfdHlwZXNbYXR0cmliLnR5cGVdO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyX3ZpZXdzW2F0dHJpYi50eXBlXSA9IG5ldyBhcnJheV90eXBlKHRoaXMuYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBjb21wb25lbnQgYnVmZmVyIHBvaW50ZXJzXG4gICAgICAgIGZvciAodmFyIGNvbXBvbmVudCBvZiB0aGlzLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFsxXSA9IHRoaXMuYnVmZmVyX3ZpZXdzW2NvbXBvbmVudFswXV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBhbGxvY2F0ZWQgYnVmZmVyIHNpemUsIGV4cGFuZC9yZWFsbG9jIGJ1ZmZlciBpZiBuZWVkZWRcbiAgICAvLyBjaGVja0J1ZmZlclNpemUgKG51bSA9IDEpIHtcbiAgICAvLyAgICAgaWYgKCh0aGlzLmJ1ZmZlcl9vZmZzZXQgKyAobnVtICogdGhpcy52ZXJ0ZXhfbGF5b3V0LnN0cmlkZSkpID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIC8vICAgICAgICAgdGhpcy5ibG9ja19udW0gKz0gTWF0aC5jZWlsKG51bSAvIHRoaXMuYmxvY2tfc2l6ZSk7XG4gICAgY2hlY2tCdWZmZXJTaXplICgpIHtcbiAgICAgICAgaWYgKCh0aGlzLmJ1ZmZlcl9vZmZzZXQgKyB0aGlzLnZlcnRleF9sYXlvdXQuc3RyaWRlKSA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYmxvY2tfbnVtKys7XG4gICAgICAgICAgICB2YXIgbmV3X2Jsb2NrID0gbmV3IEFycmF5QnVmZmVyKHRoaXMudmVydGV4X2xheW91dC5zdHJpZGUgKiB0aGlzLmJsb2NrX3NpemUgKiB0aGlzLmJsb2NrX251bSk7XG4gICAgICAgICAgICB2YXIgbmV3X3ZpZXcgPSBuZXcgVWludDhBcnJheShuZXdfYmxvY2spO1xuICAgICAgICAgICAgbmV3X3ZpZXcuc2V0KG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKSk7IC8vIGNvcHkgZXhpc3RpbmcgZGF0YSB0byBuZXcgYnVmZmVyXG5cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3X2Jsb2NrO1xuICAgICAgICAgICAgdGhpcy5zZXRCdWZmZXJWaWV3cygpO1xuICAgICAgICAgICAgbG9nLmluZm8oYFZlcnRleERhdGE6IGV4cGFuZGVkIHZlcnRleCBibG9jayB0byAke3RoaXMuYmxvY2tfc2l6ZSAqIHRoaXMuYmxvY2tfbnVtfSB2ZXJ0aWNlc2ApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGEgdmVydGV4LCBjb3BpZWQgZnJvbSBhIHBsYWluIEpTIGFycmF5IG9mIGVsZW1lbnRzIG1hdGNoaW5nIHRoZSBvcmRlciBvZiB0aGUgdmVydGV4IGxheW91dC5cbiAgICAvLyBOb3RlOiB1c2VzIHByZS1jYWxjdWxhdGVkIGluZm8gYWJvdXQgZWFjaCBhdHRyaWJ1dGUsIGluY2x1ZGluZyBwb2ludGVyIHRvIGFwcHJvcHJpYXRlIHR5cGVkIGFycmF5XG4gICAgLy8gdmlldyBhbmQgb2Zmc2V0IGludG8gaXQuIFRoaXMgd2FzIHRoZSBmYXN0ZXN0IG1ldGhvZCBwcm9maWxlZCBzbyBmYXIgZm9yIGZpbGxpbmcgYSBtaXhlZC10eXBlXG4gICAgLy8gdmVydGV4IGxheW91dCAodGhvdWdoIHN0aWxsIHNsb3dlciB0aGFuIHRoZSBwcmV2aW91cyBtZXRob2QgdGhhdCBvbmx5IHN1cHBvcnRlZCBGbG9hdDMyQXJyYXkgYXR0cmlidXRlcykuXG4gICAgYWRkVmVydGV4ICh2ZXJ0ZXgpIHtcbiAgICAgICAgdGhpcy5jaGVja0J1ZmZlclNpemUoKTtcbiAgICAgICAgdmFyIGk9MDtcblxuICAgICAgICAvLyBFUzYtc3R5bGUgZGVzdHJ1Y3R1cmluZyBhbmQgaXRlcmF0aW9uIC0gY29vbCBidXQgbm90aWNlYWJseSBzbG93ZXIgKGF0IGxlYXN0IHcvdHJhY2V1ciBjb21waWxlZCBjb2RlKVxuICAgICAgICAvLyBmb3IgKHZhciBbLCBidWZmZXIsIHNoaWZ0LCBvZmZzZXRdIG9mIHRoaXMuY29tcG9uZW50cykge1xuICAgICAgICAvLyAgICAgYnVmZmVyWyh0aGlzLmJ1ZmZlcl9vZmZzZXQgPj4gc2hpZnQpICsgb2Zmc2V0XSA9IHZlcnRleFtpKytdO1xuXG4gICAgICAgIHZhciBjbGVuID0gdGhpcy5jb21wb25lbnRzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgYz0wOyBjIDwgY2xlbjsgYysrKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRzW2NdO1xuICAgICAgICAgICAgY29tcG9uZW50WzFdWyh0aGlzLmJ1ZmZlcl9vZmZzZXQgPj4gY29tcG9uZW50WzJdKSArIGNvbXBvbmVudFszXV0gPSB2ZXJ0ZXhbaSsrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYnVmZmVyX29mZnNldCArPSB0aGlzLnZlcnRleF9sYXlvdXQuc3RyaWRlO1xuICAgICAgICB0aGlzLnZlcnRleF9jb3VudCsrO1xuICAgIH1cblxuICAgIC8vIEZpbmFsaXplIHZlcnRleCBidWZmZXIgZm9yIHVzZSBpbiBjb25zdHJ1Y3RpbmcgYSBtZXNoXG4gICAgZW5kICgpIHtcbiAgICAgICAgLy8gQ2xpcCB0aGUgYWxsb2NhdGVkIGJsb2NrIHRvIGZyZWUgdW51c2VkIG1lbW9yeVxuICAgICAgICBpZiAodGhpcy5idWZmZXJfb2Zmc2V0IDwgdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG5ld19ibG9jayA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmJ1ZmZlcl9vZmZzZXQpO1xuICAgICAgICAgICAgdmFyIG5ld192aWV3ID0gbmV3IFVpbnQ4QXJyYXkobmV3X2Jsb2NrKTtcbiAgICAgICAgICAgIG5ld192aWV3LnNldChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlciwgMCwgdGhpcy5idWZmZXJfb2Zmc2V0KSk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ld19ibG9jaztcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyX3ZpZXdzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG59XG5cbi8vIE1hcHMgR0wgdHlwZXMgdG8gSlMgYXJyYXkgdHlwZXNcblZlcnRleERhdGEucHJvdG90eXBlLmFycmF5X3R5cGVzID0ge1xuICAgIFtnbC5GTE9BVF06IEZsb2F0MzJBcnJheSxcbiAgICBbZ2wuQllURV06IEludDhBcnJheSxcbiAgICBbZ2wuVU5TSUdORURfQllURV06IFVpbnQ4QXJyYXksXG4gICAgW2dsLklOVF06IEludDMyQXJyYXksXG4gICAgW2dsLlVOU0lHTkVEX0lOVF06IFVpbnQzMkFycmF5LFxuICAgIFtnbC5TSE9SVF06IEludDE2QXJyYXksXG4gICAgW2dsLlVOU0lHTkVEX1NIT1JUXTogVWludDE2QXJyYXlcbn07XG4iLCIvKiBnbG9iYWwgVmVydGV4TGF5b3V0ICovXG5cbmltcG9ydCBnbCBmcm9tICcuL2NvbnN0YW50cyc7IC8vIHdlYiB3b3JrZXJzIGRvbid0IGhhdmUgYWNjZXNzIHRvIEdMIGNvbnRleHQsIHNvIGltcG9ydCBhbGwgR0wgY29uc3RhbnRzXG5pbXBvcnQgVmVydGV4RGF0YSBmcm9tICcuL3ZlcnRleF9kYXRhJztcblxuLy8gRGVzY3JpYmVzIGEgdmVydGV4IGxheW91dCB0aGF0IGNhbiBiZSB1c2VkIHdpdGggbWFueSBkaWZmZXJlbnQgR0wgcHJvZ3JhbXMuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZXJ0ZXhMYXlvdXQge1xuICAgIC8vIEF0dHJpYnMgYXJlIGFuIGFycmF5LCBpbiBsYXlvdXQgb3JkZXIsIG9mOiBuYW1lLCBzaXplLCB0eXBlLCBub3JtYWxpemVkXG4gICAgLy8gZXg6IHsgbmFtZTogJ3Bvc2l0aW9uJywgc2l6ZTogMywgdHlwZTogZ2wuRkxPQVQsIG5vcm1hbGl6ZWQ6IGZhbHNlIH1cbiAgICBjb25zdHJ1Y3RvciAoYXR0cmlicykge1xuICAgICAgICB0aGlzLmF0dHJpYnMgPSBhdHRyaWJzOyAvLyBkaWN0aW9uYXJ5IG9mIGF0dHJpYnV0ZXMsIHNwZWNpZmllZCBhcyBzdGFuZGFyZCBHTCBhdHRyaWIgb3B0aW9uc1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSBbXTsgICAvLyBsaXN0IG9mIHR5cGUgYW5kIG9mZnNldCBpbmZvIGFib3V0IGVhY2ggYXR0cmlidXRlIGNvbXBvbmVudFxuICAgICAgICB0aGlzLmluZGV4ID0ge307ICAgICAgICAvLyBsaW5lYXIgYnVmZmVyIGluZGV4IG9mIGVhY2ggYXR0cmlidXRlIGNvbXBvbmVudCwgZS5nLiB0aGlzLmluZGV4LnBvc2l0aW9uLnhcblxuICAgICAgICAvLyBDYWxjIHZlcnRleCBzdHJpZGVcbiAgICAgICAgdGhpcy5zdHJpZGUgPSAwO1xuXG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIGF0dHJpYiBvZiB0aGlzLmF0dHJpYnMpIHtcbiAgICAgICAgICAgIGF0dHJpYi5vZmZzZXQgPSB0aGlzLnN0cmlkZTtcbiAgICAgICAgICAgIGF0dHJpYi5ieXRlX3NpemUgPSBhdHRyaWIuc2l6ZTtcbiAgICAgICAgICAgIHZhciBzaGlmdCA9IDA7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoYXR0cmliLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIGdsLkZMT0FUOlxuICAgICAgICAgICAgICAgIGNhc2UgZ2wuSU5UOlxuICAgICAgICAgICAgICAgIGNhc2UgZ2wuVU5TSUdORURfSU5UOlxuICAgICAgICAgICAgICAgICAgICBhdHRyaWIuYnl0ZV9zaXplICo9IDQ7XG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBnbC5TSE9SVDpcbiAgICAgICAgICAgICAgICBjYXNlIGdsLlVOU0lHTkVEX1NIT1JUOlxuICAgICAgICAgICAgICAgICAgICBhdHRyaWIuYnl0ZV9zaXplICo9IDI7XG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvcmNlIDQtYnl0ZSBhbGlnbm1lbnQgb24gYXR0cmlidXRlc1xuICAgICAgICAgICAgdGhpcy5zdHJpZGUgKz0gYXR0cmliLmJ5dGVfc2l6ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmlkZSAmIDMpIHsgLy8gcGFkIHRvIG11bHRpcGxlIG9mIDQgYnl0ZXNcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmlkZSArPSA0IC0gKHRoaXMuc3RyaWRlICYgMyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCBpbmZvIHRvIGxpc3Qgb2YgYXR0cmlidXRlIGNvbXBvbmVudHNcbiAgICAgICAgICAgIC8vIFVzZWQgdG8gYnVpbGQgdGhlIHZlcnRleCBkYXRhLCBwcm92aWRlcyBwb2ludGVycyBhbmQgb2Zmc2V0cyBpbnRvIGVhY2ggdHlwZWQgYXJyYXkgdmlld1xuICAgICAgICAgICAgLy8gRWFjaCBjb21wb25lbnQgaXMgYW4gYXJyYXkgb2Y6XG4gICAgICAgICAgICAvLyBbR0wgYXR0cmliIHR5cGUsIHBvaW50ZXIgdG8gdHlwZWQgYXJyYXkgdmlldywgYml0cyB0byBzaGlmdCByaWdodCB0byBkZXRlcm1pbmUgYnVmZmVyIG9mZnNldCwgYWRkaXRpb25hbCBidWZmZXIgb2Zmc2V0IGZvciB0aGUgY29tcG9uZW50XVxuICAgICAgICAgICAgdmFyIG9mZnNldF90eXBlZCA9IGF0dHJpYi5vZmZzZXQgPj4gc2hpZnQ7XG4gICAgICAgICAgICBpZiAoYXR0cmliLnNpemUgPiAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYT0wOyBhIDwgYXR0cmliLnNpemU7IGErKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMucHVzaChbYXR0cmliLnR5cGUsIG51bGwsIHNoaWZ0LCBvZmZzZXRfdHlwZWQrK10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5wdXNoKFthdHRyaWIudHlwZSwgbnVsbCwgc2hpZnQsIG9mZnNldF90eXBlZF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcm92aWRlIGFuIGluZGV4IGludG8gdGhlIHZlcnRleCBkYXRhIGJ1ZmZlciBmb3IgZWFjaCBhdHRyaWJ1dGUgY29tcG9uZW50XG4gICAgICAgICAgICB0aGlzLmluZGV4W2F0dHJpYi5uYW1lXSA9IGNvdW50O1xuICAgICAgICAgICAgY291bnQgKz0gYXR0cmliLnNpemU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXR1cCBhIHZlcnRleCBsYXlvdXQgZm9yIGEgc3BlY2lmaWMgR0wgcHJvZ3JhbVxuICAgIC8vIEFzc3VtZXMgdGhhdCB0aGUgZGVzaXJlZCB2ZXJ0ZXggYnVmZmVyIChWQk8pIGlzIGFscmVhZHkgYm91bmRcbiAgICAvLyBJZiBhIGdpdmVuIHByb2dyYW0gZG9lc24ndCBpbmNsdWRlIGFsbCBhdHRyaWJ1dGVzLCBpdCBjYW4gc3RpbGwgdXNlIHRoZSB2ZXJ0ZXggbGF5b3V0XG4gICAgLy8gdG8gcmVhZCB0aG9zZSBhdHRyaWJzIHRoYXQgaXQgZG9lcyByZWNvZ25pemUsIHVzaW5nIHRoZSBhdHRyaWIgb2Zmc2V0cyB0byBza2lwIG90aGVycy5cbiAgICBlbmFibGUgKGdsLCBwcm9ncmFtKVxuICAgIHtcbiAgICAgICAgdmFyIGF0dHJpYiwgbG9jYXRpb247XG5cbiAgICAgICAgLy8gRW5hYmxlIGFsbCBhdHRyaWJ1dGVzIGZvciB0aGlzIGxheW91dFxuICAgICAgICBmb3IgKHZhciBhPTA7IGEgPCB0aGlzLmF0dHJpYnMubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICAgIGF0dHJpYiA9IHRoaXMuYXR0cmlic1thXTtcbiAgICAgICAgICAgIGxvY2F0aW9uID0gcHJvZ3JhbS5hdHRyaWJ1dGUoYXR0cmliLm5hbWUpLmxvY2F0aW9uO1xuXG4gICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobG9jYXRpb24sIGF0dHJpYi5zaXplLCBhdHRyaWIudHlwZSwgYXR0cmliLm5vcm1hbGl6ZWQsIHRoaXMuc3RyaWRlLCBhdHRyaWIub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBWZXJ0ZXhMYXlvdXQuZW5hYmxlZF9hdHRyaWJzW2xvY2F0aW9uXSA9IHByb2dyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEaXNhYmxlIGFueSBwcmV2aW91c2x5IGJvdW5kIGF0dHJpYnV0ZXMgdGhhdCBhcmVuJ3QgZm9yIHRoaXMgbGF5b3V0XG4gICAgICAgIGZvciAobG9jYXRpb24gaW4gVmVydGV4TGF5b3V0LmVuYWJsZWRfYXR0cmlicykge1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlVW51c2VkQXR0cmlidXRlKGdsLCBsb2NhdGlvbiwgcHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEaXNhYmxlIGFuIGF0dHJpYnV0ZSBpZiBpdCB3YXMgbm90IGVuYWJsZWQgZm9yIHRoZSBzcGVjaWZpZWQgcHJvZ3JhbVxuICAgIC8vIE5PVEU6IHRoaXMgd2FzIG1vdmVkIG91dCBvZiB0aGUgaW5uZXIgbG9vcCBpbiBlbmFibGUoKSB0byBhc3Npc3Qgdy9WTSBvcHRpbWl6YXRpb25cbiAgICBkaXNhYmxlVW51c2VkQXR0cmlidXRlIChnbCwgbG9jYXRpb24sIHByb2dyYW0pIHtcbiAgICAgICAgaWYgKFZlcnRleExheW91dC5lbmFibGVkX2F0dHJpYnNbbG9jYXRpb25dICE9PSBwcm9ncmFtKSB7XG4gICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pO1xuICAgICAgICAgICAgZGVsZXRlIFZlcnRleExheW91dC5lbmFibGVkX2F0dHJpYnNbbG9jYXRpb25dO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlVmVydGV4RGF0YSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVydGV4RGF0YSh0aGlzKTtcbiAgICB9XG5cbn1cblxuLy8gVHJhY2sgY3VycmVudGx5IGVuYWJsZWQgYXR0cmlicywgYnkgdGhlIHByb2dyYW0gdGhleSBhcmUgYm91bmQgdG9cbi8vIFN0YXRpYyBjbGFzcyBwcm9wZXJ0eSB0byByZWZsZWN0IGdsb2JhbCBHTCBzdGF0ZVxuVmVydGV4TGF5b3V0LmVuYWJsZWRfYXR0cmlicyA9IHt9O1xuIiwiaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IFNjZW5lIGZyb20gJy4vc2NlbmUnO1xuXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcblxuLy8gRXhwb3J0cyBtdXN0IGFwcGVhciBvdXRzaWRlIGEgZnVuY3Rpb24sIGJ1dCB3aWxsIG9ubHkgYmUgZGVmaW5lZCBpbiBtYWluIHRocmVhZCAoYmVsb3cpXG5leHBvcnQgdmFyIExlYWZsZXRMYXllcjtcbmV4cG9ydCBmdW5jdGlvbiBsZWFmbGV0TGF5ZXIob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgTGVhZmxldExheWVyKG9wdGlvbnMpO1xufVxuXG4vLyBMZWFmbGV0IGxheWVyIGZ1bmN0aW9uYWxpdHkgaXMgb25seSBkZWZpbmVkIGluIG1haW4gdGhyZWFkXG5cbmlmIChVdGlscy5pc01haW5UaHJlYWQpIHtcblxuICAgIExlYWZsZXRMYXllciA9IEwuR3JpZExheWVyLmV4dGVuZCh7XG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHRzXG4gICAgICAgICAgICBvcHRpb25zLnNob3dEZWJ1ZyA9ICghb3B0aW9ucy5zaG93RGVidWcgPyBmYWxzZSA6IHRydWUpO1xuXG4gICAgICAgICAgICBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVNjZW5lKCk7XG4gICAgICAgICAgICB0aGlzLmhvb2tzID0ge307XG4gICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIEZvcmNlIGxlYWZsZXQgem9vbSBhbmltYXRpb25zIG9mZlxuICAgICAgICAgICAgdGhpcy5fem9vbUFuaW1hdGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlU2NlbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUgPSBTY2VuZS5jcmVhdGUoXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNjZW5lLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtV29ya2VyczogdGhpcy5vcHRpb25zLm51bVdvcmtlcnMsXG4gICAgICAgICAgICAgICAgICAgIHByZVVwZGF0ZTogdGhpcy5vcHRpb25zLnByZVVwZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgcG9zdFVwZGF0ZTogdGhpcy5vcHRpb25zLnBvc3RVcGRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGxvZ0xldmVsOiB0aGlzLm9wdGlvbnMubG9nTGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkdmFuY2VkIG9wdGlvbiwgYXBwIHdpbGwgaGF2ZSB0byBtYW51YWxseSBjYWxsZWQgc2NlbmUudXBkYXRlKCkgcGVyIGZyYW1lXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVSZW5kZXJMb29wOiB0aGlzLm9wdGlvbnMuZGlzYWJsZVJlbmRlckxvb3AsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkdmFuY2VkIG9wdGlvbiwgd2lsbCByZXF1aXJlIGxpYnJhcnkgdG8gYmUgc2VydmVkIGFzIHNhbWUgaG9zdCBhcyBwYWdlXG4gICAgICAgICAgICAgICAgICAgIGFsbG93Q3Jvc3NEb21haW5Xb3JrZXJzOiB0aGlzLm9wdGlvbnMuYWxsb3dDcm9zc0RvbWFpbldvcmtlcnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBGaW5pc2ggaW5pdGlhbGl6aW5nIHNjZW5lIGFuZCBzZXR1cCBldmVudHMgd2hlbiBsYXllciBpcyBhZGRlZCB0byBtYXBcbiAgICAgICAgb25BZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zY2VuZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlU2NlbmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgTC5HcmlkTGF5ZXIucHJvdG90eXBlLm9uQWRkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHRoaXMuaG9va3MucmVzaXplID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5fbWFwLmdldFNpemUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnJlc2l6ZU1hcChzaXplLngsIHNpemUueSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5vbigncmVzaXplJywgdGhpcy5ob29rcy5yZXNpemUpO1xuXG4gICAgICAgICAgICB0aGlzLmhvb2tzLm1vdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xuICAgICAgICAgICAgICAgIHZpZXcuem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZCA9IHRoaXMuc2NlbmUuc2V0Vmlldyh2aWV3KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmltbWVkaWF0ZVJlZHJhdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9uKCdtb3ZlJywgdGhpcy5ob29rcy5tb3ZlKTtcblxuICAgICAgICAgICAgdGhpcy5ob29rcy56b29tc3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuc3RhcnRab29tKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5vbignem9vbXN0YXJ0JywgdGhpcy5ob29rcy56b29tc3RhcnQpO1xuXG4gICAgICAgICAgICB0aGlzLmhvb2tzLmRyYWdzdGFydCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnBhbm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5vbignZHJhZ3N0YXJ0JywgdGhpcy5ob29rcy5kcmFnc3RhcnQpO1xuXG4gICAgICAgICAgICB0aGlzLmhvb2tzLmRyYWdlbmQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5wYW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9uKCdkcmFnZW5kJywgdGhpcy5ob29rcy5kcmFnZW5kKTtcblxuICAgICAgICAgICAgLy8gRm9yY2UgbGVhZmxldCB6b29tIGFuaW1hdGlvbnMgb2ZmXG4gICAgICAgICAgICB0aGlzLl9tYXAuX3pvb21BbmltYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBDYW52YXMgZWxlbWVudCB3aWxsIGJlIGluc2VydGVkIGFmdGVyIG1hcCBjb250YWluZXIgKGxlYWZsZXQgdHJhbnNmb3JtcyBzaG91bGRuJ3QgYmUgYXBwbGllZCB0byB0aGUgR0wgY2FudmFzKVxuICAgICAgICAgICAgLy8gVE9ETzogZmluZCBhIGJldHRlciB3YXkgdG8gZGVhbCB3aXRoIHRoaXM/IHJpZ2h0IG5vdyBHTCBtYXAgb25seSByZW5kZXJzIGNvcnJlY3RseSBhcyB0aGUgYm90dG9tIGxheWVyXG4gICAgICAgICAgICB0aGlzLnNjZW5lLmNvbnRhaW5lciA9IHRoaXMuX21hcC5nZXRDb250YWluZXIoKTtcblxuICAgICAgICAgICAgLy8gSW5pdGlhbCB2aWV3XG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMuX21hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgICAgIHZpZXcuem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG4gICAgICAgICAgICB0aGlzLnNjZW5lLnNldFZpZXcodmlldyk7XG5cbiAgICAgICAgICAgIC8vIFN1YnNjcmliZSB0byB0YW5ncmFtIGV2ZW50c1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgIG1vdmU6IHRoaXMub25UYW5ncmFtVmlld1VwZGF0ZS5iaW5kKHRoaXMpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVXNlIGxlYWZsZXQncyBleGlzdGluZyBldmVudCBzeXN0ZW0gYXMgdGhlIGNhbGxiYWNrIG1lY2hhbmlzbVxuICAgICAgICAgICAgdGhpcy5zY2VuZS5pbml0KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nLmRlYnVnKCdTY2VuZS5pbml0KCkgc3VjY2VlZGVkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdpbml0Jyk7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBsb2cuZXJyb3IoJ1NjZW5lLmluaXQoKSBmYWlsZWQgd2l0aCBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgTC5HcmlkTGF5ZXIucHJvdG90eXBlLm9uUmVtb3ZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHRoaXMuX21hcC5vZmYoJ3Jlc2l6ZScsIHRoaXMuaG9va3MucmVzaXplKTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5vZmYoJ21vdmUnLCB0aGlzLmhvb2tzLm1vdmUpO1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9mZignem9vbXN0YXJ0JywgdGhpcy5ob29rcy56b29tc3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9mZignZHJhZ3N0YXJ0JywgdGhpcy5ob29rcy5kcmFnc3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9mZignZHJhZ2VuZCcsIHRoaXMuaG9va3MuZHJhZ2VuZCk7XG4gICAgICAgICAgICB0aGlzLmhvb2tzID0ge307XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlVGlsZTogZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGNvb3Jkcy54ICsgJy8nICsgY29vcmRzLnkgKyAnLycgKyBjb29yZHMuejtcbiAgICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGlsZS1rZXknLCBrZXkpO1xuICAgICAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gJzI1NnB4JztcbiAgICAgICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSAnMjU2cHgnO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNob3dEZWJ1Zykge1xuICAgICAgICAgICAgICAgIHZhciBkZWJ1Z19vdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgZGVidWdfb3ZlcmxheS50ZXh0Q29udGVudCA9IGtleTtcbiAgICAgICAgICAgICAgICBkZWJ1Z19vdmVybGF5LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgICAgICBkZWJ1Z19vdmVybGF5LnN0eWxlLmxlZnQgPSAwO1xuICAgICAgICAgICAgICAgIGRlYnVnX292ZXJsYXkuc3R5bGUudG9wID0gMDtcbiAgICAgICAgICAgICAgICBkZWJ1Z19vdmVybGF5LnN0eWxlLmNvbG9yID0gJ3doaXRlJztcbiAgICAgICAgICAgICAgICBkZWJ1Z19vdmVybGF5LnN0eWxlLmZvbnRTaXplID0gJzE2cHgnO1xuICAgICAgICAgICAgICAgIGRlYnVnX292ZXJsYXkuc3R5bGUudGV4dE91dGxpbmUgPSAnMXB4ICMwMDAwMDAnO1xuICAgICAgICAgICAgICAgIGRlYnVnX292ZXJsYXkuc3R5bGUucGFkZGluZyA9ICc4cHgnO1xuXG4gICAgICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKGRlYnVnX292ZXJsYXkpO1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5ib3JkZXJTdHlsZSA9ICdzb2xpZCc7XG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLmJvcmRlckNvbG9yID0gJ3doaXRlJztcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUuYm9yZGVyV2lkdGggPSAnMXB4JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRpdjtcbiAgICAgICAgfSxcblxuICAgICAgICBvblRhbmdyYW1WaWV3VXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl91cGRhdGluZ190YW5ncmFtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9tYXAuc2V0VmlldyhbdGhpcy5zY2VuZS5jZW50ZXIubGF0LCB0aGlzLnNjZW5lLmNlbnRlci5sbmddLCB0aGlzLnNjZW5lLnpvb20sIHsgYW5pbWF0ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2NlbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNjZW5lLnVwZGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICB9KTtcbn1cbiIsIi8qZ2xvYmFsIExpZ2h0ICovXG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tICcuL2dsL3NoYWRlcl9wcm9ncmFtJztcbmltcG9ydCBzaGFkZXJTb3VyY2VzIGZyb20gJy4vZ2wvc2hhZGVyX3NvdXJjZXMnOyAvLyBidWlsdC1pbiBzaGFkZXJzXG5pbXBvcnQgR0xTTCBmcm9tICcuL2dsL2dsc2wnO1xuaW1wb3J0IEdlbyBmcm9tICcuL2dlbyc7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9wYXJzZXInO1xuXG4vLyBBYnN0cmFjdCBsaWdodFxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlnaHQge1xuXG4gICAgY29uc3RydWN0b3IgKHNjZW5lLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcblxuICAgICAgICBpZiAoY29uZmlnLmFtYmllbnQgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnLmFtYmllbnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmFtYmllbnQgPSBHTFNMLmV4cGFuZFZlYzQoY29uZmlnLmFtYmllbnQgfHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFtYmllbnQgPSBTdHlsZVBhcnNlci5wYXJzZUNvbG9yKGNvbmZpZy5hbWJpZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuZGlmZnVzZSA9PSBudWxsIHx8IHR5cGVvZiBjb25maWcuZGlmZnVzZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuZGlmZnVzZSA9IEdMU0wuZXhwYW5kVmVjNChjb25maWcuZGlmZnVzZSAhPSBudWxsID8gY29uZmlnLmRpZmZ1c2UgOiAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlmZnVzZSA9IFN0eWxlUGFyc2VyLnBhcnNlQ29sb3IoY29uZmlnLmRpZmZ1c2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5zcGVjdWxhciA9PSBudWxsIHx8IHR5cGVvZiBjb25maWcuc3BlY3VsYXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLnNwZWN1bGFyID0gR0xTTC5leHBhbmRWZWM0KGNvbmZpZy5zcGVjdWxhciB8fCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3BlY3VsYXIgPSBTdHlsZVBhcnNlci5wYXJzZUNvbG9yKGNvbmZpZy5zcGVjdWxhcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBsaWdodCBieSB0eXBlIG5hbWUsIGZhY3Rvcnktc3R5bGVcbiAgICAvLyAnY29uZmlnJyBtdXN0IGluY2x1ZGUgJ25hbWUnIGFuZCAndHlwZScsIGFsb25nIHdpdGggYW55IG90aGVyIHR5cGUtc3BlY2lmaWMgcHJvcGVydGllc1xuICAgIHN0YXRpYyBjcmVhdGUgKHNjZW5lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKExpZ2h0LnR5cGVzW2NvbmZpZy50eXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaWdodC50eXBlc1tjb25maWcudHlwZV0oc2NlbmUsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgbGlnaHQgZm9yIGEgc3R5bGU6IGZyYWdtZW50IGxpZ2h0aW5nLCB2ZXJ0ZXggbGlnaHRpbmcsIG9yIG5vbmVcbiAgICBzdGF0aWMgc2V0TW9kZSAobW9kZSwgc3R5bGUpIHtcbiAgICAgICAgbW9kZSA9IExpZ2h0LmVuYWJsZWQgJiYgKChtb2RlICE9IG51bGwpID8gbW9kZSA6ICdmcmFnbWVudCcpOyAvLyBkZWZhdWx0IHRvIGZyYWdtZW50IGxpZ2h0aW5nXG4gICAgICAgIHN0eWxlLmRlZmluZXNbJ1RBTkdSQU1fTElHSFRJTkdfRlJBR01FTlQnXSA9IChtb2RlID09PSAnZnJhZ21lbnQnKTtcbiAgICAgICAgc3R5bGUuZGVmaW5lc1snVEFOR1JBTV9MSUdIVElOR19WRVJURVgnXSA9IChtb2RlID09PSAndmVydGV4Jyk7XG4gICAgfVxuXG4gICAgLy8gSW5qZWN0IGFsbCBwcm92aWRlZCBsaWdodCBkZWZpbml0aW9ucywgYW5kIGNhbGN1bGF0ZSBjdW11bGF0aXZlIGxpZ2h0IGZ1bmN0aW9uXG4gICAgc3RhdGljIGluamVjdCAobGlnaHRzKSB7XG4gICAgICAgIC8vIENsZWFyIHByZXZpb3VzIGluamVjdGlvbnNcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5yZW1vdmVUcmFuc2Zvcm0oTGlnaHQudHJhbnNmb3JtKTtcblxuICAgICAgICAvLyBJZiBsaWdodGluZyBpcyBnbG9iYWxseSBkaXNhYmxlZCwgbm90aGluZyBpcyBpbmplY3RlZCAobW9zdGx5IGZvciBkZWJ1Z2dpbmcgb3IgbGl2ZSBlZGl0aW5nKVxuICAgICAgICBpZiAoIUxpZ2h0LmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnN0cnVjdCBjb2RlIHRvIGNhbGN1bGF0ZSBlYWNoIGxpZ2h0IGluc3RhbmNlXG4gICAgICAgIGxldCBjYWxjdWxhdGVMaWdodHMgPSBcIlwiO1xuICAgICAgICBpZiAobGlnaHRzICYmIE9iamVjdC5rZXlzKGxpZ2h0cykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gQ29sbGVjdCB1bmlxdWVzIHR5cGVzIG9mIGxpZ2h0c1xuICAgICAgICAgICAgbGV0IHR5cGVzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBsaWdodF9uYW1lIGluIGxpZ2h0cykge1xuICAgICAgICAgICAgICAgIHR5cGVzW2xpZ2h0c1tsaWdodF9uYW1lXS50eXBlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluamVjdCBlYWNoIHR5cGUgb2YgbGlnaHRcbiAgICAgICAgICAgIGZvciAobGV0IHR5cGUgaW4gdHlwZXMpIHtcbiAgICAgICAgICAgICAgICBMaWdodC50eXBlc1t0eXBlXS5pbmplY3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5qZWN0IHBlci1pbnN0YW5jZSBibG9ja3MgYW5kIGNvbnN0cnVjdCB0aGUgbGlzdCBvZiBmdW5jdGlvbnMgdG8gY2FsY3VsYXRlIGVhY2ggbGlnaHRcbiAgICAgICAgICAgIGZvciAobGV0IGxpZ2h0X25hbWUgaW4gbGlnaHRzKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVmaW5lIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgbGlnaHRzW2xpZ2h0X25hbWVdLmluamVjdCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBjYWxjdWxhdGlvbiBmdW5jdGlvbiB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZUxpZ2h0cyArPSBgY2FsY3VsYXRlTGlnaHQoZ18ke2xpZ2h0X25hbWV9LCBfZXllVG9Qb2ludCwgX25vcm1hbCk7XFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIG5vIGxpZ2h0IGlzIGRlZmluZWQsIHVzZSAxMDAlIG9tbmlkaXJlY3Rpb25hbCBkaWZmdXNlIGxpZ2h0XG4gICAgICAgICAgICBjYWxjdWxhdGVMaWdodHMgPSBgXG4gICAgICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRVxuICAgICAgICAgICAgICAgICAgICBnX2xpZ2h0X2FjY3VtdWxhdG9yX2RpZmZ1c2UgPSB2ZWM0KDEuKTtcbiAgICAgICAgICAgICAgICAjZW5kaWZcbiAgICAgICAgICAgIGA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHbHVlIHRvZ2V0aGVyIHRoZSBmaW5hbCBsaWdodGluZyBmdW5jdGlvbiB0aGF0IHN1bXMgYWxsIHRoZSBsaWdodHNcbiAgICAgICAgbGV0IGNhbGN1bGF0ZUZ1bmN0aW9uID0gYFxuICAgICAgICAgICAgdmVjNCBjYWxjdWxhdGVMaWdodGluZyhpbiB2ZWMzIF9leWVUb1BvaW50LCBpbiB2ZWMzIF9ub3JtYWwsIGluIHZlYzQgX2NvbG9yKSB7XG5cbiAgICAgICAgICAgICAgICAke2NhbGN1bGF0ZUxpZ2h0c31cblxuICAgICAgICAgICAgICAgIC8vICBGaW5hbCBsaWdodCBpbnRlbnNpdHkgY2FsY3VsYXRpb25cbiAgICAgICAgICAgICAgICB2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xuXG4gICAgICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRU1JU1NJT05cbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBnX21hdGVyaWFsLmVtaXNzaW9uO1xuICAgICAgICAgICAgICAgICNlbmRpZlxuXG4gICAgICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfQU1CSUVOVFxuICAgICAgICAgICAgICAgICAgICBjb2xvciArPSBnX2xpZ2h0X2FjY3VtdWxhdG9yX2FtYmllbnQgKiBfY29sb3IgKiBnX21hdGVyaWFsLmFtYmllbnQ7XG4gICAgICAgICAgICAgICAgI2VuZGlmXG5cbiAgICAgICAgICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yICs9IGdfbGlnaHRfYWNjdW11bGF0b3JfZGlmZnVzZSAqIF9jb2xvciAqIGdfbWF0ZXJpYWwuZGlmZnVzZTtcbiAgICAgICAgICAgICAgICAjZW5kaWZcblxuICAgICAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yICs9IGdfbGlnaHRfYWNjdW11bGF0b3Jfc3BlY3VsYXIgKiBnX21hdGVyaWFsLnNwZWN1bGFyO1xuICAgICAgICAgICAgICAgICNlbmRpZlxuXG4gICAgICAgICAgICAgICAgLy8gQ2xhbXAgZmluYWwgY29sb3JcbiAgICAgICAgICAgICAgICBjb2xvciA9IGNsYW1wKGNvbG9yLCAwLjAsIDEuMCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgICAgICB9YDtcblxuICAgICAgICBTaGFkZXJQcm9ncmFtLmFkZFRyYW5zZm9ybShMaWdodC50cmFuc2Zvcm0sIGNhbGN1bGF0ZUZ1bmN0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBDb21tb24gaW5zdGFuY2UgZGVmaW5pdGlvblxuICAgIGluamVjdCAoKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9ICBgXG4gICAgICAgICAgICB1bmlmb3JtICR7dGhpcy5zdHJ1Y3RfbmFtZX0gdV8ke3RoaXMubmFtZX07XG4gICAgICAgICAgICAke3RoaXMuc3RydWN0X25hbWV9IGdfJHt0aGlzLm5hbWV9ID0gdV8ke3RoaXMubmFtZX07XFxuYDtcblxuICAgICAgICBTaGFkZXJQcm9ncmFtLmFkZFRyYW5zZm9ybShMaWdodC50cmFuc2Zvcm0sIGluc3RhbmNlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgbWV0aG9kIGNhbGxlZCBvbmNlIHBlciBmcmFtZVxuICAgIHVwZGF0ZSAoKSB7XG4gICAgfVxuXG4gICAgLy8gQ2FsbGVkIG9uY2UgcGVyIGZyYW1lIHBlciBwcm9ncmFtIChlLmcuIGZvciBtYWluIHJlbmRlciBwYXNzLCB0aGVuIGZvciBlYWNoIGFkZGl0aW9uYWxcbiAgICAvLyBwYXNzIGZvciBmZWF0dXJlIHNlbGVjdGlvbiwgZXRjLilcbiAgICBzZXR1cFByb2dyYW0gKF9wcm9ncmFtKSB7XG4gICAgICAgIC8vICBUaHJlZSBjb21tb24gbGlnaHQgcHJvcGVydGllc1xuICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCc0ZnYnLCBgdV8ke3RoaXMubmFtZX0uYW1iaWVudGAsIHRoaXMuYW1iaWVudCk7XG4gICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzRmdicsIGB1XyR7dGhpcy5uYW1lfS5kaWZmdXNlYCwgdGhpcy5kaWZmdXNlKTtcbiAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnNGZ2JywgYHVfJHt0aGlzLm5hbWV9LnNwZWN1bGFyYCwgdGhpcy5zcGVjdWxhcik7XG4gICAgfVxuXG59XG5cbkxpZ2h0LnR5cGVzID0ge307IC8vIHJlZmVyZW5jZXMgdG8gc3ViY2xhc3NlcyBieSBzaG9ydCBuYW1lXG5MaWdodC50cmFuc2Zvcm0gPSAnbGlnaHRpbmcnOyAvLyBzaGFkZXIgdHJhbnNmb3JtIG5hbWVcbkxpZ2h0LmVuYWJsZWQgPSB0cnVlOyAvLyBsaWdodGluZyBjYW4gYmUgZ2xvYmFsbHkgZW5hYmxlZC9kaXNhYmxlZFxuXG5cbi8vIExpZ2h0IHN1YmNsYXNzZXNcbmNsYXNzIEFtYmllbnRMaWdodCBleHRlbmRzIExpZ2h0IHtcblxuICAgIGNvbnN0cnVjdG9yKHNjZW5lLCBjb25maWcpIHtcbiAgICAgICAgc3VwZXIoc2NlbmUsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdhbWJpZW50JztcbiAgICAgICAgdGhpcy5zdHJ1Y3RfbmFtZSA9ICdBbWJpZW50TGlnaHQnO1xuICAgIH1cblxuICAgIC8vIEluamVjdCBzdHJ1Y3QgYW5kIGNhbGN1bGF0ZSBmdW5jdGlvblxuICAgIHN0YXRpYyBpbmplY3QoKSB7XG4gICAgICAgIFNoYWRlclByb2dyYW0uYWRkVHJhbnNmb3JtKExpZ2h0LnRyYW5zZm9ybSwgc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9hbWJpZW50TGlnaHQnXSk7XG4gICAgfVxuXG4gICAgc2V0dXBQcm9ncmFtIChfcHJvZ3JhbSkge1xuICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCc0ZnYnLCBgdV8ke3RoaXMubmFtZX0uYW1iaWVudGAsIHRoaXMuYW1iaWVudCk7XG4gICAgfVxuXG59XG5MaWdodC50eXBlc1snYW1iaWVudCddID0gQW1iaWVudExpZ2h0O1xuXG5jbGFzcyBEaXJlY3Rpb25hbExpZ2h0IGV4dGVuZHMgTGlnaHQge1xuXG4gICAgY29uc3RydWN0b3Ioc2NlbmUsIGNvbmZpZykge1xuICAgICAgICBzdXBlcihzY2VuZSwgY29uZmlnKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2RpcmVjdGlvbmFsJztcbiAgICAgICAgdGhpcy5zdHJ1Y3RfbmFtZSA9ICdEaXJlY3Rpb25hbExpZ2h0JztcblxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IChjb25maWcuZGlyZWN0aW9uIHx8IFswLjIsIDAuNywgLTAuNV0pLm1hcChwYXJzZUZsb2F0KTsgLy8gW3gsIHksIHpdXG4gICAgfVxuXG4gICAgLy8gSW5qZWN0IHN0cnVjdCBhbmQgY2FsY3VsYXRlIGZ1bmN0aW9uXG4gICAgc3RhdGljIGluamVjdCgpIHtcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5hZGRUcmFuc2Zvcm0oTGlnaHQudHJhbnNmb3JtLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL2RpcmVjdGlvbmFsTGlnaHQnXSk7XG4gICAgfVxuXG4gICAgc2V0dXBQcm9ncmFtIChfcHJvZ3JhbSkge1xuICAgICAgICBzdXBlci5zZXR1cFByb2dyYW0oX3Byb2dyYW0pO1xuICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCczZnYnLCBgdV8ke3RoaXMubmFtZX0uZGlyZWN0aW9uYCwgdGhpcy5kaXJlY3Rpb24pO1xuICAgIH1cblxufVxuTGlnaHQudHlwZXNbJ2RpcmVjdGlvbmFsJ10gPSBEaXJlY3Rpb25hbExpZ2h0O1xuXG5cbmNsYXNzIFBvaW50TGlnaHQgZXh0ZW5kcyBMaWdodCB7XG5cbiAgICBjb25zdHJ1Y3RvciAoc2NlbmUsIGNvbmZpZykge1xuICAgICAgICBzdXBlcihzY2VuZSwgY29uZmlnKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3BvaW50JztcbiAgICAgICAgdGhpcy5zdHJ1Y3RfbmFtZSA9ICdQb2ludExpZ2h0JztcblxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gY29uZmlnLnBvc2l0aW9uIHx8IFswLCAwLCAwXTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbl9leWUgPSBbXTsgLy8gcG9zaXRpb24gaW4gZXllc3BhY2VcbiAgICAgICAgdGhpcy5vcmlnaW4gPSBjb25maWcub3JpZ2luIHx8ICd3b3JsZCc7XG4gICAgICAgIHRoaXMuYXR0ZW51YXRpb24gPSAhaXNOYU4ocGFyc2VGbG9hdChjb25maWcuYXR0ZW51YXRpb24pKSA/IHBhcnNlRmxvYXQoY29uZmlnLmF0dGVudWF0aW9uKSA6IDA7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5yYWRpdXMpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy5yYWRpdXMpICYmIGNvbmZpZy5yYWRpdXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSBjb25maWcucmFkaXVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSBbbnVsbCwgY29uZmlnLnJhZGl1c107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJhZGl1cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbmplY3Qgc3RydWN0IGFuZCBjYWxjdWxhdGUgZnVuY3Rpb25cbiAgICBzdGF0aWMgaW5qZWN0ICgpIHtcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5hZGRUcmFuc2Zvcm0oTGlnaHQudHJhbnNmb3JtLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3BvaW50TGlnaHQnXSk7XG4gICAgfVxuXG4gICAgLy8gSW5qZWN0IGlzbnRhbmNlLXNwZWNpZmljIHNldHRpbmdzXG4gICAgaW5qZWN0KCkge1xuICAgICAgICBzdXBlci5pbmplY3QoKTtcblxuICAgICAgICBTaGFkZXJQcm9ncmFtLmRlZmluZXNbJ1RBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9FWFBPTkVOVCddID0gKHRoaXMuYXR0ZW51YXRpb24gIT09IDApO1xuICAgICAgICBTaGFkZXJQcm9ncmFtLmRlZmluZXNbJ1RBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9JTk5FUl9SQURJVVMnXSA9ICh0aGlzLnJhZGl1cyAhPSBudWxsICYmIHRoaXMucmFkaXVzWzBdICE9IG51bGwpO1xuICAgICAgICBTaGFkZXJQcm9ncmFtLmRlZmluZXNbJ1RBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVMnXSA9ICh0aGlzLnJhZGl1cyAhPSBudWxsKTtcbiAgICB9XG5cbiAgICB1cGRhdGUgKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUV5ZVBvc2l0aW9uKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlRXllUG9zaXRpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vcmlnaW4gPT09ICd3b3JsZCcpIHtcbiAgICAgICAgICAgIC8vIEZvciB3b3JsZCBvcmlnaW4sIGZvcm1hdCBpczogW2xvbmdpdHVkZSwgbGF0aXR1ZGUsIG1ldGVycyAoZGVmYXVsdCkgb3IgcGl4ZWxzIHcvcHggdW5pdHNdXG5cbiAgICAgICAgICAgIC8vIE1vdmUgbGlnaHQncyB3b3JsZCBwb3NpdGlvbiBpbnRvIGNhbWVyYSBzcGFjZVxuICAgICAgICAgICAgbGV0IFt4LCB5XSA9IEdlby5sYXRMbmdUb01ldGVycyh0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25fZXllWzBdID0geCAtIHRoaXMuc2NlbmUuY2FtZXJhLnBvc2l0aW9uX21ldGVyc1swXTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25fZXllWzFdID0geSAtIHRoaXMuc2NlbmUuY2FtZXJhLnBvc2l0aW9uX21ldGVyc1sxXTtcblxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbl9leWVbMl0gPSBTdHlsZVBhcnNlci5jb252ZXJ0VW5pdHModGhpcy5wb3NpdGlvblsyXSwgeyB6b29tOiB0aGlzLnNjZW5lLnpvb20gfSk7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uX2V5ZVsyXSA9IHRoaXMucG9zaXRpb25fZXllWzJdIC0gdGhpcy5zY2VuZS5jYW1lcmEucG9zaXRpb25fbWV0ZXJzWzJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2dyb3VuZCcgfHwgdGhpcy5vcmlnaW4gPT09ICdjYW1lcmEnKSB7XG4gICAgICAgICAgICAvLyBGb3IgY2FtZXJhIG9yIGdyb3VuZCBvcmlnaW4sIGZvcm1hdCBpczogW3gsIHksIHpdIGluIG1ldGVycyAoZGVmYXVsdCkgb3IgcGl4ZWxzIHcvcHggdW5pdHNcblxuICAgICAgICAgICAgLy8gTGlnaHQgaXMgaW4gY2FtZXJhIHNwYWNlIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25fZXllID0gU3R5bGVQYXJzZXIuY29udmVydFVuaXRzKHRoaXMucG9zaXRpb24sIHsgem9vbTogdGhpcy5zY2VuZS56b29tIH0pO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdncm91bmQnKSB7XG4gICAgICAgICAgICAgICAgLy8gTGVhdmUgbGlnaHQncyB4eSBpbiBjYW1lcmEgc3BhY2UsIGJ1dCB6IG5lZWRzIHRvIGJlIG1vdmVkIHJlbGF0aXZlIHRvIGdyb3VuZCBwbGFuZVxuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25fZXllWzJdID0gdGhpcy5wb3NpdGlvbl9leWVbMl0gLSB0aGlzLnNjZW5lLmNhbWVyYS5wb3NpdGlvbl9tZXRlcnNbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXR1cFByb2dyYW0gKF9wcm9ncmFtKSB7XG4gICAgICAgIHN1cGVyLnNldHVwUHJvZ3JhbShfcHJvZ3JhbSk7XG5cbiAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnNGYnLCBgdV8ke3RoaXMubmFtZX0ucG9zaXRpb25gLFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbl9leWVbMF0sIHRoaXMucG9zaXRpb25fZXllWzFdLCB0aGlzLnBvc2l0aW9uX2V5ZVsyXSwgMSk7XG5cbiAgICAgICAgaWYoU2hhZGVyUHJvZ3JhbS5kZWZpbmVzWydUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fRVhQT05FTlQnXSkge1xuICAgICAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnMWYnLCBgdV8ke3RoaXMubmFtZX0uYXR0ZW51YXRpb25FeHBvbmVudGAsIHRoaXMuYXR0ZW51YXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoU2hhZGVyUHJvZ3JhbS5kZWZpbmVzWydUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fSU5ORVJfUkFESVVTJ10pIHtcbiAgICAgICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzFmJywgYHVfJHt0aGlzLm5hbWV9LmlubmVyUmFkaXVzYCxcbiAgICAgICAgICAgICAgICBTdHlsZVBhcnNlci5jb252ZXJ0VW5pdHModGhpcy5yYWRpdXNbMF0sIHsgem9vbTogdGhpcy5zY2VuZS56b29tIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKFNoYWRlclByb2dyYW0uZGVmaW5lc1snVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX09VVEVSX1JBRElVUyddKSB7XG4gICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCcxZicsIGB1XyR7dGhpcy5uYW1lfS5vdXRlclJhZGl1c2AsXG4gICAgICAgICAgICAgICAgU3R5bGVQYXJzZXIuY29udmVydFVuaXRzKHRoaXMucmFkaXVzWzFdLCB7IHpvb206IHRoaXMuc2NlbmUuem9vbSB9KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5MaWdodC50eXBlc1sncG9pbnQnXSA9IFBvaW50TGlnaHQ7XG5cblxuY2xhc3MgU3BvdExpZ2h0IGV4dGVuZHMgUG9pbnRMaWdodCB7XG5cbiAgICBjb25zdHJ1Y3RvciAoc2NlbmUsIGNvbmZpZykge1xuICAgICAgICBzdXBlcihzY2VuZSwgY29uZmlnKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3Nwb3RsaWdodCc7XG4gICAgICAgIHRoaXMuc3RydWN0X25hbWUgPSAnU3BvdExpZ2h0JztcblxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IChjb25maWcuZGlyZWN0aW9uIHx8IFswLCAwLCAtMV0pLm1hcChwYXJzZUZsb2F0KTsgLy8gW3gsIHksIHpdXG4gICAgICAgIHRoaXMuZXhwb25lbnQgPSBjb25maWcuZXhwb25lbnQgPyBwYXJzZUZsb2F0KGNvbmZpZy5leHBvbmVudCkgOiAwLjI7XG4gICAgICAgIHRoaXMuYW5nbGUgPSBjb25maWcuYW5nbGUgPyBwYXJzZUZsb2F0KGNvbmZpZy5hbmdsZSkgOiAyMDtcbiAgICB9XG5cbiAgICAvLyBJbmplY3Qgc3RydWN0IGFuZCBjYWxjdWxhdGUgZnVuY3Rpb25cbiAgICBzdGF0aWMgaW5qZWN0ICgpIHtcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5hZGRUcmFuc2Zvcm0oTGlnaHQudHJhbnNmb3JtLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3Nwb3RMaWdodCddKTtcbiAgICB9XG5cbiAgICBzZXR1cFByb2dyYW0gKF9wcm9ncmFtKSB7XG4gICAgICAgIHN1cGVyLnNldHVwUHJvZ3JhbShfcHJvZ3JhbSk7XG5cbiAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnM2Z2JywgYHVfJHt0aGlzLm5hbWV9LmRpcmVjdGlvbmAsIHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnMWYnLCBgdV8ke3RoaXMubmFtZX0uc3BvdENvc0N1dG9mZmAsIE1hdGguY29zKHRoaXMuYW5nbGUgKiAzLjE0MTU5IC8gMTgwKSk7XG4gICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzFmJywgYHVfJHt0aGlzLm5hbWV9LnNwb3RFeHBvbmVudGAsIHRoaXMuZXhwb25lbnQpO1xuICAgIH1cblxufVxuTGlnaHQudHlwZXNbJ3Nwb3RsaWdodCddID0gU3BvdExpZ2h0O1xuIiwiLypnbG9iYWwgTWF0ZXJpYWwgKi9cbmltcG9ydCBzaGFkZXJTb3VyY2VzIGZyb20gJy4vZ2wvc2hhZGVyX3NvdXJjZXMnOyAvLyBidWlsdC1pbiBzaGFkZXJzXG5pbXBvcnQgR0xTTCBmcm9tICcuL2dsL2dsc2wnO1xuaW1wb3J0IHtTdHlsZVBhcnNlcn0gZnJvbSAnLi9zdHlsZXMvc3R5bGVfcGFyc2VyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF0ZXJpYWwge1xuICAgIGNvbnN0cnVjdG9yIChjb25maWcpIHtcbiAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gICAgICAgIGlmIChjb25maWcuZW1pc3Npb24gPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnLmVtaXNzaW9uID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5lbWlzc2lvbiA9IEdMU0wuZXhwYW5kVmVjNChjb25maWcuZW1pc3Npb24gfHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVtaXNzaW9uID0gU3R5bGVQYXJzZXIucGFyc2VDb2xvcihjb25maWcuZW1pc3Npb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5hbWJpZW50ID09IG51bGwgfHwgdHlwZW9mIGNvbmZpZy5hbWJpZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5hbWJpZW50ID0gR0xTTC5leHBhbmRWZWM0KGNvbmZpZy5hbWJpZW50ICE9IG51bGwgPyBjb25maWcuYW1iaWVudCA6IDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hbWJpZW50ID0gU3R5bGVQYXJzZXIucGFyc2VDb2xvcihjb25maWcuYW1iaWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLmRpZmZ1c2UgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnLmRpZmZ1c2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmRpZmZ1c2UgPSBHTFNMLmV4cGFuZFZlYzQoY29uZmlnLmRpZmZ1c2UgIT0gbnVsbCA/IGNvbmZpZy5kaWZmdXNlIDogMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpZmZ1c2UgPSBTdHlsZVBhcnNlci5wYXJzZUNvbG9yKGNvbmZpZy5kaWZmdXNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuc3BlY3VsYXIgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnLnNwZWN1bGFyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5zcGVjdWxhciA9IEdMU0wuZXhwYW5kVmVjNChjb25maWcuc3BlY3VsYXIgfHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNwZWN1bGFyID0gU3R5bGVQYXJzZXIucGFyc2VDb2xvcihjb25maWcuc3BlY3VsYXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zaGluaW5lc3MgPSBjb25maWcuc2hpbmluZXNzID8gcGFyc2VGbG9hdChjb25maWcuc2hpbmluZXNzKSA6IDAuMjtcbiAgICB9XG5cbiAgICBpbmplY3QgKHN0eWxlKSB7XG4gICAgICAgIHN0eWxlLmRlZmluZXNbJ1RBTkdSQU1fTUFURVJJQUxfRU1JU1NJT04nXSA9ICh0aGlzLmVtaXNzaW9uICE9IG51bGwpO1xuICAgICAgICBzdHlsZS5kZWZpbmVzWydUQU5HUkFNX01BVEVSSUFMX0FNQklFTlQnXSA9ICh0aGlzLmFtYmllbnQgIT0gbnVsbCk7XG4gICAgICAgIHN0eWxlLmRlZmluZXNbJ1RBTkdSQU1fTUFURVJJQUxfRElGRlVTRSddID0gKHRoaXMuZGlmZnVzZSAhPSBudWxsKTtcbiAgICAgICAgc3R5bGUuZGVmaW5lc1snVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUiddID0gKHRoaXMuc3BlY3VsYXIgIT0gbnVsbCk7XG5cbiAgICAgICAgc3R5bGUucmVwbGFjZVNoYWRlclRyYW5zZm9ybShNYXRlcmlhbC50cmFuc2Zvcm0sIHNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvbWF0ZXJpYWwnXSk7XG4gICAgfVxuXG4gICAgc2V0dXBQcm9ncmFtIChfcHJvZ3JhbSkge1xuICAgICAgICBpZiAodGhpcy5lbWlzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCc0ZnYnLCAndV9tYXRlcmlhbC5lbWlzc2lvbicsIHRoaXMuZW1pc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFtYmllbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnNGZ2JywgJ3VfbWF0ZXJpYWwuYW1iaWVudCcsIHRoaXMuYW1iaWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlmZnVzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCc0ZnYnLCAndV9tYXRlcmlhbC5kaWZmdXNlJywgdGhpcy5kaWZmdXNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zcGVjdWxhciAhPSBudWxsKSB7XG4gICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCc0ZnYnLCAndV9tYXRlcmlhbC5zcGVjdWxhcicsIHRoaXMuc3BlY3VsYXIpO1xuICAgICAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnMWYnLCAndV9tYXRlcmlhbC5zaGluaW5lc3MnLCB0aGlzLnNoaW5pbmVzcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbk1hdGVyaWFsLnRyYW5zZm9ybSA9ICdtYXRlcmlhbCc7XG4iLCIvKmpzaGludCB3b3JrZXI6IHRydWUqL1xuXG4vLyBNb2R1bGVzIGFuZCBkZXBlbmRlbmNpZXMgdG8gZXhwb3NlIGluIHRoZSBwdWJsaWMgVGFuZ3JhbSBtb2R1bGVcbmltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzL3V0aWxzJztcblxuLy8gVGhlIGxlYWZsZXQgbGF5ZXIgcGx1Z2luIGlzIGN1cnJlbnRseSB0aGUgcHJpbWFyeSBwdWJsaWMgQVBJXG5pbXBvcnQge0xlYWZsZXRMYXllciwgbGVhZmxldExheWVyfSBmcm9tICcuL2xlYWZsZXRfbGF5ZXInO1xuXG4vLyBUaGUgc2NlbmUgd29ya2VyIGlzIG9ubHkgYWN0aXZhdGVkIHdoZW4gYSB3b3JrZXIgdGhyZWFkIGlzIGluc3RhbnRpYXRlZCwgYnV0IG11c3QgYWx3YXlzIGJlIGxvYWRlZFxuaW1wb3J0IHtTY2VuZVdvcmtlcn0gZnJvbSAnLi4vc3JjL3NjZW5lX3dvcmtlcic7XG5cbi8vIEFkZGl0aW9uYWwgbW9kdWxlcyBhcmUgZXhwb3NlZCBmb3IgZGVidWdnaW5nXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBHZW8gZnJvbSAnLi9nZW8nO1xuaW1wb3J0IEdMU0wgZnJvbSAnLi9nbC9nbHNsJztcbmltcG9ydCBTaGFkZXJQcm9ncmFtIGZyb20gJy4vZ2wvc2hhZGVyX3Byb2dyYW0nO1xuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi9nbC90ZXh0dXJlJztcbmltcG9ydCBNYXRlcmlhbCBmcm9tICcuL21hdGVyaWFsJztcbmltcG9ydCBMaWdodCBmcm9tICcuL2xpZ2h0JztcbmltcG9ydCBXb3JrZXJCcm9rZXIgZnJvbSAnLi91dGlscy93b3JrZXJfYnJva2VyJztcbmltcG9ydCB7cnVsZUNhY2hlfSBmcm9tICd1bnJ1bHknO1xuXG5pbXBvcnQgZ2xNYXRyaXggZnJvbSAnZ2wtbWF0cml4JztcblxuLy8gRGVmYXVsdCB0byA2NC1iaXQgYmVjYXVzZSB3ZSBuZWVkIHRoZSBleHRyYSBwcmVjaXNpb24gd2hlbiBtdWx0aXBseWluZyBtYXRyaWNlcyB3L21lcmNhdG9yIHByb2plY3RlZCB2YWx1ZXNcbmdsTWF0cml4LmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZShGbG9hdDY0QXJyYXkpO1xuXG4vLyBNYWtlIHNvbWUgbW9kdWxlcyBhY2Nlc3NpYmxlIGZvciBkZWJ1Z2dpbmdcbnZhciBkZWJ1ZyA9IHtcbiAgICBsb2csXG4gICAgVXRpbHMsXG4gICAgR2VvLFxuICAgIEdMU0wsXG4gICAgU2hhZGVyUHJvZ3JhbSxcbiAgICBUZXh0dXJlLFxuICAgIE1hdGVyaWFsLFxuICAgIExpZ2h0LFxuICAgIFNjZW5lV29ya2VyLFxuICAgIFdvcmtlckJyb2tlcixcbiAgICBydWxlQ2FjaGVcbn07XG5cbi8vIFdpbmRvdyBjYW4gb25seSBiZSBzZXQgaW4gbWFpbiB0aHJlYWRcbmlmIChVdGlscy5pc01haW5UaHJlYWQpIHtcbiAgICAvLyBNYWluIHRocmVhZCBvYmplY3RzIHRoYXQgY2FuIGJlIGNhbGxlZCBmcm9tIHdvcmtlcnNcbiAgICBXb3JrZXJCcm9rZXIuYWRkVGFyZ2V0KCdUZXh0dXJlJywgVGV4dHVyZSk7XG5cbiAgICB3aW5kb3cuVGFuZ3JhbSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBMZWFmbGV0TGF5ZXIsXG4gICAgICAgIGxlYWZsZXRMYXllcixcbiAgICAgICAgZGVidWdcbiAgICB9O1xuXG59XG5cbmlmIChVdGlscy5pc1dvcmtlclRocmVhZCkge1xuICAgIHNlbGYuVGFuZ3JhbSA9IHtcbiAgICAgICAgZGVidWdcbiAgICB9O1xufVxuIiwiLypnbG9iYWwgU2NlbmUgKi9cbmltcG9ydCBHZW8gZnJvbSAnLi9nZW8nO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IFdvcmtlckJyb2tlciBmcm9tICcuL3V0aWxzL3dvcmtlcl9icm9rZXInO1xuaW1wb3J0IHN1YnNjcmliZU1peGluIGZyb20gJy4vdXRpbHMvc3Vic2NyaWJlJztcbmltcG9ydCBDb250ZXh0IGZyb20gJy4vZ2wvY29udGV4dCc7XG5pbXBvcnQgQnVpbGRlcnMgZnJvbSAnLi9zdHlsZXMvYnVpbGRlcnMnO1xuaW1wb3J0IFNoYWRlclByb2dyYW0gZnJvbSAnLi9nbC9zaGFkZXJfcHJvZ3JhbSc7XG5pbXBvcnQgVGV4dHVyZSBmcm9tICcuL2dsL3RleHR1cmUnO1xuaW1wb3J0IHtTdHlsZU1hbmFnZXJ9IGZyb20gJy4vc3R5bGVzL3N0eWxlX21hbmFnZXInO1xuaW1wb3J0IHtTdHlsZVBhcnNlcn0gZnJvbSAnLi9zdHlsZXMvc3R5bGVfcGFyc2VyJztcbmltcG9ydCBDYW1lcmEgZnJvbSAnLi9jYW1lcmEnO1xuaW1wb3J0IExpZ2h0IGZyb20gJy4vbGlnaHQnO1xuaW1wb3J0IFRpbGUgZnJvbSAnLi90aWxlJztcbmltcG9ydCBUaWxlU291cmNlIGZyb20gJy4vdGlsZV9zb3VyY2UnO1xuaW1wb3J0IEZlYXR1cmVTZWxlY3Rpb24gZnJvbSAnLi9zZWxlY3Rpb24nO1xuXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBnbE1hdHJpeCBmcm9tICdnbC1tYXRyaXgnO1xubGV0IG1hdDQgPSBnbE1hdHJpeC5tYXQ0O1xubGV0IG1hdDMgPSBnbE1hdHJpeC5tYXQzO1xubGV0IHZlYzMgPSBnbE1hdHJpeC52ZWMzO1xuXG4vLyBHbG9iYWwgc2V0dXBcbmlmIChVdGlscy5pc01haW5UaHJlYWQpIHtcbiAgICAvLyBPbiBtYWluIHRocmVhZCBvbmx5IChza2lwIGluIHdlYiB3b3JrZXIpXG4gICAgVXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lUG9seWZpbGwoKTtcbn1cblxuU2NlbmUudGlsZV9zY2FsZSA9IDQwOTY7IC8vIGNvb3JkaW5hdGVzIGFyZSBsb2NhbGx5IHNjYWxlZCB0byB0aGUgcmFuZ2UgWzAsIHRpbGVfc2NhbGVdXG5HZW8uc2V0VGlsZVNjYWxlKFNjZW5lLnRpbGVfc2NhbGUpO1xuQnVpbGRlcnMuc2V0VGlsZVNjYWxlKFNjZW5lLnRpbGVfc2NhbGUpO1xuU2hhZGVyUHJvZ3JhbS5kZWZpbmVzLlRJTEVfU0NBTEUgPSBTY2VuZS50aWxlX3NjYWxlO1xuXG4vLyBMb2FkIHNjZW5lIGRlZmluaXRpb246IHBhc3MgYW4gb2JqZWN0IGRpcmVjdGx5LCBvciBhIFVSTCBhcyBzdHJpbmcgdG8gbG9hZCByZW1vdGVseVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2NlbmUoY29uZmlnX3NvdXJjZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHN1YnNjcmliZU1peGluKHRoaXMpO1xuXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgdGhpcy5zb3VyY2VzID0ge307XG5cbiAgICB0aGlzLnRpbGVzID0ge307XG4gICAgdGhpcy52aXNpYmxlX3RpbGVzID0ge307XG4gICAgdGhpcy5xdWV1ZWRfdGlsZXMgPSBbXTtcbiAgICB0aGlzLm51bV93b3JrZXJzID0gb3B0aW9ucy5udW1Xb3JrZXJzIHx8IDI7XG4gICAgdGhpcy5hbGxvd19jcm9zc19kb21haW5fd29ya2VycyA9IChvcHRpb25zLmFsbG93Q3Jvc3NEb21haW5Xb3JrZXJzID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZSk7XG4gICAgdGhpcy53b3JrZXJfdXJsID0gb3B0aW9ucy53b3JrZXJVcmw7XG5cbiAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgdGhpcy5jb25maWdfc291cmNlID0gY29uZmlnX3NvdXJjZTtcbiAgICB0aGlzLmNvbmZpZ19zZXJpYWxpemVkID0gbnVsbDtcblxuICAgIHRoaXMuc3R5bGVzID0gbnVsbDtcbiAgICB0aGlzLmFjdGl2ZV9zdHlsZXMgPSB7fTtcblxuICAgIHRoaXMuYnVpbGRpbmcgPSBudWxsOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyYWNrcyBjdXJyZW50IHNjZW5lIGJ1aWxkaW5nIHN0YXRlICh0aWxlcyBiZWluZyBidWlsdCwgZXRjLilcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IGEgcmVkcmF3XG4gICAgdGhpcy5hbmltYXRlZCA9IGZhbHNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVxdWVzdCByZWRyYXcgZXZlcnkgZnJhbWVcbiAgICB0aGlzLnByZVVwZGF0ZSA9IG9wdGlvbnMucHJlVXBkYXRlOyAgICAgICAgICAgICAvLyBvcHRpb25hbCBwcmUtcmVuZGVyIGxvb3AgaG9va1xuICAgIHRoaXMucG9zdFVwZGF0ZSA9IG9wdGlvbnMucG9zdFVwZGF0ZTsgICAgICAgICAgIC8vIG9wdGlvbmFsIHBvc3QtcmVuZGVyIGxvb3AgaG9va1xuICAgIHRoaXMucmVuZGVyX2xvb3AgPSAhb3B0aW9ucy5kaXNhYmxlUmVuZGVyTG9vcDsgIC8vIGRpc2FibGUgcmVuZGVyIGxvb3AgLSBhcHAgd2lsbCBoYXZlIHRvIG1hbnVhbGx5IGNhbGwgU2NlbmUucmVuZGVyKCkgcGVyIGZyYW1lXG4gICAgdGhpcy5mcmFtZSA9IDA7XG4gICAgdGhpcy5yZXNldFRpbWUoKTtcblxuICAgIHRoaXMuem9vbSA9IG51bGw7XG4gICAgdGhpcy5jZW50ZXIgPSBudWxsO1xuICAgIHRoaXMuZGV2aWNlX3BpeGVsX3JhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcblxuICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xuICAgIHRoaXMucGFubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG5cbiAgICB0aGlzLmNhbWVyYSA9IG51bGw7XG4gICAgdGhpcy5saWdodHMgPSBudWxsO1xuXG4gICAgLy8gTW9kZWwtdmlldyBtYXRyaWNlc1xuICAgIC8vIDY0LWJpdCB2ZXJzaW9ucyBhcmUgZm9yIENQVSBjYWxjdWF0aW9uc1xuICAgIC8vIDMyLWJpdCB2ZXJzaW9ucyBhcmUgZG93bnNhbXBsZWQgYW5kIHNlbnQgdG8gR1BVXG4gICAgdGhpcy5tb2RlbE1hdHJpeCA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICAgIHRoaXMubW9kZWxNYXRyaXgzMiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICAgIHRoaXMubW9kZWxWaWV3TWF0cml4ID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XG4gICAgdGhpcy5tb2RlbFZpZXdNYXRyaXgzMiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICAgIHRoaXMubm9ybWFsTWF0cml4ID0gbmV3IEZsb2F0NjRBcnJheSg5KTtcbiAgICB0aGlzLm5vcm1hbE1hdHJpeDMyID0gbmV3IEZsb2F0MzJBcnJheSg5KTtcblxuICAgIHRoaXMuc2VsZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLnRleHR1cmVfbGlzdGVuZXIgPSBudWxsO1xuXG4gICAgLy8gRGVidWcgY29uZmlnXG4gICAgdGhpcy5kZWJ1ZyA9IHtcbiAgICAgICAgcHJvZmlsZToge1xuICAgICAgICAgICAgZ2VvbWV0cnlfYnVpbGQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5sb2dMZXZlbCA9IG9wdGlvbnMubG9nTGV2ZWwgfHwgJ2luZm8nO1xuICAgIGxvZy5zZXRMZXZlbCh0aGlzLmxvZ0xldmVsKTtcbn1cblxuU2NlbmUuY3JlYXRlID0gZnVuY3Rpb24gKGNvbmZpZywgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBTY2VuZShjb25maWcsIG9wdGlvbnMpO1xufTtcblxuU2NlbmUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB0aGlzLmluaXRpYWxpemluZyA9IHRydWU7XG5cbiAgICAvLyBMb2FkIHNjZW5lIGRlZmluaXRpb24gKHNvdXJjZXMsIHN0eWxlcywgZXRjLiksIHRoZW4gY3JlYXRlIHN0eWxlcyAmIHdvcmtlcnNcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLmxvYWRTY2VuZSgpLnRoZW4oKCkgPT4ge1xuXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVdvcmtlcnMoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gbmV3IEZlYXR1cmVTZWxlY3Rpb24odGhpcy5nbCwgdGhpcy53b3JrZXJzKTtcblxuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZV9saXN0ZW5lciA9IHsgdXBkYXRlOiAoKSA9PiB0aGlzLmRpcnR5ID0gdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIFRleHR1cmUuc3Vic2NyaWJlKHRoaXMudGV4dHVyZV9saXN0ZW5lcik7XG5cbiAgICAgICAgICAgICAgICAvLyBMb2FkcyByZW5kZXJpbmcgc3R5bGVzIGZyb20gY29uZmlnLCBzZXRzIEdMIGNvbnRleHQgYW5kIGNvbXBpbGVzIHByb2dyYW1zXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDb25maWcoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyX2xvb3AgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBSZW5kZXJMb29wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goZSA9PiB7IHRocm93IGU7IH0pO1xuICAgICAgICB9KS5jYXRjaChlID0+IHsgcmVqZWN0KGUpOyB9KTtcbiAgICB9KTtcbn07XG5cblNjZW5lLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlckxvb3AgPSAoKSA9PiB7fTsgLy8gc2V0IHRvIG5vLW9wIGJlY2F1c2UgYSBudWxsIGNhbiBjYXVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdG8gdGhyb3dcblxuICAgIHRoaXMudW5zdWJzY3JpYmVBbGwoKTsgLy8gY2xlYXIgYWxsIGV2ZW50IGxpc3RlbmVyc1xuXG4gICAgVGV4dHVyZS51bnN1YnNjcmliZSh0aGlzLnRleHR1cmVfbGlzdGVuZXIpO1xuICAgIHRoaXMudGV4dHVyZV9saXN0ZW5lciA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzKTtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5nbCkge1xuICAgICAgICB0aGlzLmdsLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuZmJvKTtcbiAgICAgICAgdGhpcy5mYm8gPSBudWxsO1xuXG4gICAgICAgIFRleHR1cmUuZGVzdHJveSh0aGlzLmdsKTtcbiAgICAgICAgU3R5bGVNYW5hZ2VyLmRlc3Ryb3kodGhpcy5nbCk7XG4gICAgICAgIHRoaXMuc3R5bGVzID0ge307XG5cbiAgICAgICAgdGhpcy5nbCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy53b3JrZXJzKSkge1xuICAgICAgICB0aGlzLndvcmtlcnMuZm9yRWFjaCgod29ya2VyKSA9PiB7XG4gICAgICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndvcmtlcnMgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnNvdXJjZXMgPSB7fTtcbiAgICB0aGlzLnRpbGVzID0ge307IC8vIFRPRE86IHByb2JhYmx5IGRlc3Ryb3kgZWFjaCB0aWxlIHNlcGFyYXRlbHkgdG9vXG59O1xuXG5TY2VuZS5wcm90b3R5cGUuY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5jb250YWluZXIgfHwgZG9jdW1lbnQuYm9keTtcbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS50b3AgPSAwO1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLmxlZnQgPSAwO1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLnpJbmRleCA9IC0xO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcblxuICAgIHRoaXMuZ2wgPSBDb250ZXh0LmdldENvbnRleHQodGhpcy5jYW52YXMsIHsgYWxwaGE6IGZhbHNlIC8qcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSovIH0pO1xuICAgIHRoaXMucmVzaXplTWFwKHRoaXMuY29udGFpbmVyLmNsaWVudFdpZHRoLCB0aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQpO1xufTtcblxuU2NlbmUucHJvdG90eXBlLmNyZWF0ZU9iamVjdFVSTCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHdpbmRvdy5VUkwgJiYgd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwpIHx8ICh3aW5kb3cud2Via2l0VVJMICYmIHdpbmRvdy53ZWJraXRVUkwuY3JlYXRlT2JqZWN0VVJMKTtcbn07XG5cblNjZW5lLmxvYWRXb3JrZXJVcmwgPSBmdW5jdGlvbiAoc2NlbmUpIHtcbiAgICB2YXIgd29ya2VyX3VybCA9IHNjZW5lLndvcmtlcl91cmwgfHwgVXRpbHMuZmluZEN1cnJlbnRVUkwoJ3RhbmdyYW0uZGVidWcuanMnLCAndGFuZ3JhbS5taW4uanMnKSxcbiAgICAgICAgY3JlYXRlT2JqZWN0VVJMID0gc2NlbmUuY3JlYXRlT2JqZWN0VVJMKCk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBpZiAoIXdvcmtlcl91cmwpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJDYW4ndCBsb2FkIHdvcmtlciBiZWNhdXNlIGNvdWxkbid0IGZpbmQgYmFzZSBVUkwgdGhhdCBsaWJyYXJ5IHdhcyBsb2FkZWQgZnJvbVwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3JlYXRlT2JqZWN0VVJMICYmIHNjZW5lLmFsbG93X2Nyb3NzX2RvbWFpbl93b3JrZXJzKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGBpbXBvcnRTY3JpcHRzKCcke3dvcmtlcl91cmx9Jyk7YDtcbiAgICAgICAgICAgIHZhciB3b3JrZXJfbG9jYWxfdXJsID0gY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtib2R5XSwgeyB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcgfSkpO1xuICAgICAgICAgICAgcmVzb2x2ZSh3b3JrZXJfbG9jYWxfdXJsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUod29ya2VyX3VybCk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG59O1xuXG5cbi8vIFdlYiB3b3JrZXJzIGhhbmRsZSBoZWF2eSBkdXR5IHRpbGUgY29uc3RydWN0aW9uOiBuZXR3b3JraW5nLCBnZW9tZXRyeSBwcm9jZXNzaW5nLCBldGMuXG5TY2VuZS5wcm90b3R5cGUuY3JlYXRlV29ya2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBTY2VuZS5sb2FkV29ya2VyVXJsKHRoaXMpLnRoZW4oKHdvcmtlcl91cmwpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFrZVdvcmtlcnMod29ya2VyX3VybCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cblxuLy8gSW5zdGFudGlhdGUgd29ya2VycyBmcm9tIFVSTCwgaW5pdCBldmVudCBoYW5kbGVyc1xuU2NlbmUucHJvdG90eXBlLm1ha2VXb3JrZXJzID0gZnVuY3Rpb24gKHVybCkge1xuICAgIHZhciBxdWV1ZSA9IFtdO1xuXG4gICAgdGhpcy53b3JrZXJzID0gW107XG4gICAgZm9yICh2YXIgaWQ9MDsgaWQgPCB0aGlzLm51bV93b3JrZXJzOyBpZCsrKSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKHVybCk7XG4gICAgICAgIHRoaXMud29ya2Vyc1tpZF0gPSB3b3JrZXI7XG5cbiAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLndvcmtlckxvZ01lc3NhZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgIFdvcmtlckJyb2tlci5hZGRXb3JrZXIod29ya2VyKTtcblxuICAgICAgICBsb2cuZGVidWcoYFNjZW5lLm1ha2VXb3JrZXJzOiBpbml0aWFsaXppbmcgd29ya2VyICR7aWR9YCk7XG4gICAgICAgIGxldCBfaWQgPSBpZDtcbiAgICAgICAgcXVldWUucHVzaChXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2Uod29ya2VyLCAnaW5pdCcsIGlkKS50aGVuKFxuICAgICAgICAgICAgKGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nLmRlYnVnKGBTY2VuZS5tYWtlV29ya2VyczogaW5pdGlhbGl6ZWQgd29ya2VyICR7aWR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGxvZy5lcnJvcihgU2NlbmUubWFrZVdvcmtlcnM6IGZhaWxlZCB0byBpbml0aWFsaXplIHdvcmtlciAke19pZH06YCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHRoaXMubmV4dF93b3JrZXIgPSAwO1xuICAgIHRoaXMuc2VsZWN0aW9uX21hcF93b3JrZXJfc2l6ZSA9IHt9O1xuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHF1ZXVlKTtcbn07XG5cbi8vIFJvdW5kIHJvYmluIHNlbGVjdGlvbiBvZiBuZXh0IHdvcmtlclxuU2NlbmUucHJvdG90eXBlLm5leHRXb3JrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHdvcmtlciA9IHRoaXMud29ya2Vyc1t0aGlzLm5leHRfd29ya2VyXTtcbiAgICB0aGlzLm5leHRfd29ya2VyID0gKHRoaXMubmV4dF93b3JrZXIgKyAxKSAlIHRoaXMud29ya2Vycy5sZW5ndGg7XG4gICAgcmV0dXJuIHdvcmtlcjtcbn07XG5cbi8qKlxuICAgIFNldCB0aGUgbWFwIHZpZXcsIGNhbiBiZSBwYXNzZWQgYW4gb2JqZWN0IHdpdGggbGF0L2xuZyBhbmQvb3Igem9vbVxuKi9cblNjZW5lLnByb3RvdHlwZS5zZXRWaWV3ID0gZnVuY3Rpb24gKHsgbG5nLCBsYXQsIHpvb20gfSA9IHt9KSB7XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgIC8vIFNldCBjZW50ZXJcbiAgICBpZiAobG5nICYmIGxhdCkge1xuICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCAhdGhpcy5jZW50ZXIgfHwgbG5nICE9PSB0aGlzLmNlbnRlci5sbmcgfHwgbGF0ICE9PSB0aGlzLmNlbnRlci5sYXQ7XG4gICAgICAgIHRoaXMuY2VudGVyID0geyBsbmcsIGxhdCB9O1xuICAgIH1cblxuICAgIC8vIFNldCB6b29tXG4gICAgaWYgKHpvb20pIHtcbiAgICAgICAgY2hhbmdlZCA9IGNoYW5nZWQgfHwgem9vbSAhPT0gdGhpcy56b29tO1xuICAgICAgICB0aGlzLnNldFpvb20oem9vbSk7XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59O1xuXG5TY2VuZS5wcm90b3R5cGUuc3RhcnRab29tID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubGFzdF96b29tID0gdGhpcy56b29tO1xuICAgIHRoaXMuem9vbWluZyA9IHRydWU7XG59O1xuXG4vLyBDaG9vc2UgdGhlIGJhc2Ugem9vbSBsZXZlbCB0byB1c2UgZm9yIGEgZ2l2ZW4gZnJhY3Rpb25hbCB6b29tXG5TY2VuZS5wcm90b3R5cGUuYmFzZVpvb20gPSBmdW5jdGlvbiAoem9vbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHpvb20pO1xufTtcblxuU2NlbmUucHJvdG90eXBlLnByZXNlcnZlX3RpbGVzX3dpdGhpbl96b29tID0gMjtcblNjZW5lLnByb3RvdHlwZS5zZXRab29tID0gZnVuY3Rpb24gKHpvb20pIHtcbiAgICB0aGlzLnpvb21pbmcgPSBmYWxzZTtcbiAgICBsZXQgYmFzZSA9IHRoaXMuYmFzZVpvb20oem9vbSk7XG5cbiAgICBpZiAoYmFzZSAhPT0gdGhpcy5iYXNlWm9vbSh0aGlzLmxhc3Rfem9vbSkpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRpbGVzIG91dHNpZGUgYSBnaXZlbiByYW5nZSBhYm92ZSBhbmQgYmVsb3cgY3VycmVudCB6b29tXG4gICAgICAgIHZhciBiZWxvdyA9IGJhc2U7XG4gICAgICAgIHZhciBhYm92ZSA9IGJhc2U7XG5cbiAgICAgICAgbG9nLnRyYWNlKGBzY2VuZS5sYXN0X3pvb206ICR7dGhpcy5sYXN0X3pvb219YCk7XG4gICAgICAgIGlmIChNYXRoLmFicyh6b29tIC0gdGhpcy5sYXN0X3pvb20pIDw9IHRoaXMucHJlc2VydmVfdGlsZXNfd2l0aGluX3pvb20pIHtcbiAgICAgICAgICAgIGJlbG93IC09IHRoaXMucHJlc2VydmVfdGlsZXNfd2l0aGluX3pvb207XG4gICAgICAgICAgICBhYm92ZSArPSB0aGlzLnByZXNlcnZlX3RpbGVzX3dpdGhpbl96b29tO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9nLnRyYWNlKGByZW1vdmluZyB0aWxlcyBvdXRzaWRlIHJhbmdlIFske2JlbG93fSwgJHthYm92ZX1dYCk7XG4gICAgICAgIHRoaXMucmVtb3ZlVGlsZXNPdXRzaWRlWm9vbVJhbmdlKGJlbG93LCBhYm92ZSk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRpbGVzIG91dHNpZGUgY3VycmVudCB6b29tIHRoYXQgYXJlIHN0aWxsIGxvYWRpbmdcbiAgICAgICAgdGhpcy5yZW1vdmVUaWxlcyh0aWxlID0+IHtcbiAgICAgICAgICAgIGlmICh0aWxlLmxvYWRpbmcgJiYgdGhpcy5iYXNlWm9vbSh0aWxlLmNvb3Jkcy56KSAhPT0gYmFzZSkge1xuICAgICAgICAgICAgICAgIGxvZy50cmFjZShgcmVtb3ZlZCAke3RpbGUua2V5fSAod2FzIGxvYWRpbmcsIGJ1dCBvdXRzaWRlIGN1cnJlbnQgem9vbSlgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0X3pvb20gPSB0aGlzLnpvb207XG4gICAgdGhpcy56b29tID0gem9vbTtcblxuICAgIHRoaXMudXBkYXRlQm91bmRzKCk7XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbn07XG5cblNjZW5lLnByb3RvdHlwZS52aWV3UmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY3NzX3NpemUgPT0gbnVsbCB8fCB0aGlzLmNlbnRlciA9PSBudWxsIHx8IHRoaXMuem9vbSA9PSBudWxsIHx8IE9iamVjdC5rZXlzKHRoaXMuc291cmNlcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLy8gQ2FsY3VsYXRlIHZpZXdwb3J0IGJvdW5kcyBiYXNlZCBvbiBjdXJyZW50IGNlbnRlciBhbmQgem9vbVxuU2NlbmUucHJvdG90eXBlLnVwZGF0ZUJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPOiBiZXR0ZXIgY29uY2VwdCBvZiBcInJlYWRpbmVzc1wiIHN0YXRlP1xuICAgIGlmICghdGhpcy52aWV3UmVhZHkoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5tZXRlcnNfcGVyX3BpeGVsID0gR2VvLm1ldGVyc1BlclBpeGVsKHRoaXMuem9vbSk7XG5cbiAgICAvLyBTaXplIG9mIHRoZSBoYWxmLXZpZXdwb3J0IGluIG1ldGVycyBhdCBjdXJyZW50IHpvb21cbiAgICB0aGlzLnZpZXdwb3J0X21ldGVycyA9IHtcbiAgICAgICAgeDogdGhpcy5jc3Nfc2l6ZS53aWR0aCAqIHRoaXMubWV0ZXJzX3Blcl9waXhlbCxcbiAgICAgICAgeTogdGhpcy5jc3Nfc2l6ZS5oZWlnaHQgKiB0aGlzLm1ldGVyc19wZXJfcGl4ZWxcbiAgICB9O1xuXG4gICAgLy8gQ2VudGVyIG9mIHZpZXdwb3J0IGluIG1ldGVycywgYW5kIHRpbGVcbiAgICBsZXQgW3gsIHldID0gR2VvLmxhdExuZ1RvTWV0ZXJzKFt0aGlzLmNlbnRlci5sbmcsIHRoaXMuY2VudGVyLmxhdF0pO1xuICAgIHRoaXMuY2VudGVyX21ldGVycyA9IHsgeCwgeSB9O1xuXG4gICAgbGV0IHogPSB0aGlzLmJhc2Vab29tKHRoaXMuem9vbSk7XG4gICAgbGV0IG1heF96b29tID0gdGhpcy5maW5kTWF4Wm9vbSgpO1xuICAgIGlmICh6ID4gbWF4X3pvb20pIHtcbiAgICAgICAgeiA9IG1heF96b29tO1xuICAgIH1cbiAgICB0aGlzLmNlbnRlcl90aWxlID0gR2VvLnRpbGVGb3JNZXRlcnMoW3RoaXMuY2VudGVyX21ldGVycy54LCB0aGlzLmNlbnRlcl9tZXRlcnMueV0sIHopO1xuXG4gICAgdGhpcy5ib3VuZHNfbWV0ZXJzID0ge1xuICAgICAgICBzdzoge1xuICAgICAgICAgICAgeDogdGhpcy5jZW50ZXJfbWV0ZXJzLnggLSB0aGlzLnZpZXdwb3J0X21ldGVycy54IC8gMixcbiAgICAgICAgICAgIHk6IHRoaXMuY2VudGVyX21ldGVycy55IC0gdGhpcy52aWV3cG9ydF9tZXRlcnMueSAvIDJcbiAgICAgICAgfSxcbiAgICAgICAgbmU6IHtcbiAgICAgICAgICAgIHg6IHRoaXMuY2VudGVyX21ldGVycy54ICsgdGhpcy52aWV3cG9ydF9tZXRlcnMueCAvIDIsXG4gICAgICAgICAgICB5OiB0aGlzLmNlbnRlcl9tZXRlcnMueSArIHRoaXMudmlld3BvcnRfbWV0ZXJzLnkgLyAyXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRmluZCB2aXNpYmxlIHRpbGVzIGFuZCBsb2FkIG5ldyBvbmVzXG4gICAgdGhpcy52aXNpYmxlX3RpbGVzID0gdGhpcy5maW5kVmlzaWJsZVRpbGVzKCk7XG4gICAgZm9yIChsZXQga2V5IGluIHRoaXMudmlzaWJsZV90aWxlcykge1xuICAgICAgICB0aGlzLmxvYWRUaWxlKHRoaXMudmlzaWJsZV90aWxlc1trZXldKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGlsZSB2aXNpYmxlIGZsYWdzXG4gICAgZm9yIChsZXQga2V5IGluIHRoaXMudGlsZXMpIHtcbiAgICAgICAgdGhpcy50aWxlc1trZXldLnVwZGF0ZSh0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ21vdmUnKTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbn07XG5cblNjZW5lLnByb3RvdHlwZS5maW5kVmlzaWJsZVRpbGVzID0gZnVuY3Rpb24gKHsgYnVmZmVyIH0gPSB7fSkge1xuICAgIGxldCB6ID0gdGhpcy5iYXNlWm9vbSh0aGlzLnpvb20pO1xuICAgIGxldCBtYXhfem9vbSA9IHRoaXMuZmluZE1heFpvb20oKTtcbiAgICBpZiAoeiA+IG1heF96b29tKSB7XG4gICAgICAgIHogPSBtYXhfem9vbTtcbiAgICB9XG5cbiAgICBsZXQgc3cgPSBHZW8udGlsZUZvck1ldGVycyhbdGhpcy5ib3VuZHNfbWV0ZXJzLnN3LngsIHRoaXMuYm91bmRzX21ldGVycy5zdy55XSwgeik7XG4gICAgbGV0IG5lID0gR2VvLnRpbGVGb3JNZXRlcnMoW3RoaXMuYm91bmRzX21ldGVycy5uZS54LCB0aGlzLmJvdW5kc19tZXRlcnMubmUueV0sIHopO1xuICAgIGJ1ZmZlciA9IGJ1ZmZlciB8fCAwO1xuXG4gICAgbGV0IHRpbGVzID0ge307XG4gICAgZm9yIChsZXQgeCA9IHN3LnggLSBidWZmZXI7IHggPD0gbmUueCArIGJ1ZmZlcjsgeCsrKSB7XG4gICAgICAgIGZvciAobGV0IHkgPSBuZS55IC0gYnVmZmVyOyB5IDw9IHN3LnkgKyBidWZmZXI7IHkrKykge1xuICAgICAgICAgICAgbGV0IGNvb3JkcyA9IHsgeCwgeSwgeiB9O1xuICAgICAgICAgICAgdGlsZXNbVGlsZS5rZXkoY29vcmRzKV0gPSBjb29yZHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRpbGVzO1xufTtcblxuU2NlbmUucHJvdG90eXBlLnJlbW92ZVRpbGVzT3V0c2lkZVpvb21SYW5nZSA9IGZ1bmN0aW9uIChiZWxvdywgYWJvdmUpIHtcbiAgICBiZWxvdyA9IE1hdGgubWluKGJlbG93LCB0aGlzLmZpbmRNYXhab29tKCkgfHwgYmVsb3cpO1xuICAgIGFib3ZlID0gTWF0aC5taW4oYWJvdmUsIHRoaXMuZmluZE1heFpvb20oKSB8fCBhYm92ZSk7XG5cbiAgICB0aGlzLnJlbW92ZVRpbGVzKHRpbGUgPT4ge1xuICAgICAgICBpZiAodGlsZS5jb29yZHMueiA8IGJlbG93IHx8IHRpbGUuY29vcmRzLnogPiBhYm92ZSkge1xuICAgICAgICAgICAgbG9nLnRyYWNlKGByZW1vdmVkICR7dGlsZS5rZXl9IChvdXRzaWRlIHJhbmdlIFske2JlbG93fSwgJHthYm92ZX1dKWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cblNjZW5lLnByb3RvdHlwZS5yZW1vdmVUaWxlcyA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICBsZXQgcmVtb3ZlX3RpbGVzID0gW107XG4gICAgZm9yIChsZXQgdCBpbiB0aGlzLnRpbGVzKSB7XG4gICAgICAgIGxldCB0aWxlID0gdGhpcy50aWxlc1t0XTtcbiAgICAgICAgaWYgKGZpbHRlcih0aWxlKSkge1xuICAgICAgICAgICAgcmVtb3ZlX3RpbGVzLnB1c2godCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgcj0wOyByIDwgcmVtb3ZlX3RpbGVzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgIGxldCBrZXkgPSByZW1vdmVfdGlsZXNbcl07XG4gICAgICAgIHRoaXMucmVtb3ZlVGlsZShrZXkpO1xuICAgIH1cbn07XG5cblNjZW5lLnByb3RvdHlwZS5yZXNpemVNYXAgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgdGhpcy5jc3Nfc2l6ZSA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xuICAgIHRoaXMuZGV2aWNlX3NpemUgPSB7IHdpZHRoOiBNYXRoLnJvdW5kKHRoaXMuY3NzX3NpemUud2lkdGggKiB0aGlzLmRldmljZV9waXhlbF9yYXRpbyksIGhlaWdodDogTWF0aC5yb3VuZCh0aGlzLmNzc19zaXplLmhlaWdodCAqIHRoaXMuZGV2aWNlX3BpeGVsX3JhdGlvKSB9O1xuICAgIHRoaXMudmlld19hc3BlY3QgPSB0aGlzLmNzc19zaXplLndpZHRoIC8gdGhpcy5jc3Nfc2l6ZS5oZWlnaHQ7XG4gICAgdGhpcy51cGRhdGVCb3VuZHMoKTtcblxuICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9IHRoaXMuY3NzX3NpemUud2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSB0aGlzLmNzc19zaXplLmhlaWdodCArICdweCc7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5kZXZpY2Vfc2l6ZS53aWR0aDtcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5kZXZpY2Vfc2l6ZS5oZWlnaHQ7XG5cbiAgICAgICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgfVxufTtcblxuLy8gUmVxdWVzdCBzY2VuZSBiZSByZWRyYXduIGF0IG5leHQgYW5pbWF0aW9uIGxvb3BcblNjZW5lLnByb3RvdHlwZS5yZXF1ZXN0UmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufTtcblxuLy8gUmVkcmF3IHNjZW5lIGltbWVkaWF0ZWx5IC0gZG9uJ3Qgd2FpdCBmb3IgYW5pbWF0aW9uIGxvb3Bcbi8vIFVzZSBzcGFyaW5nbHksIGJ1dCBmb3IgY2FzZXMgd2hlcmUgeW91IG5lZWQgdGhlIGNsb3Nlc3QgcG9zc2libGUgc3luYyB3aXRoIG90aGVyIFVJIGVsZW1lbnRzLFxuLy8gc3VjaCBhcyBvdGhlciwgbm9uLVdlYkdMIG1hcCBsYXllcnMgKGUuZy4gTGVhZmxldCByYXN0ZXIgbGF5ZXJzLCBtYXJrZXJzLCBldGMuKVxuU2NlbmUucHJvdG90eXBlLmltbWVkaWF0ZVJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlcigpO1xufTtcblxuLy8gU2V0dXAgdGhlIHJlbmRlciBsb29wXG5TY2VuZS5wcm90b3R5cGUuc2V0dXBSZW5kZXJMb29wID0gZnVuY3Rpb24gKHsgcHJlX3JlbmRlciwgcG9zdF9yZW5kZXIgfSA9IHt9KSB7XG4gICAgdGhpcy5yZW5kZXJMb29wID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSBzY2VuZVxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlcXVlc3QgdGhlIG5leHQgZnJhbWVcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlckxvb3ApO1xuICAgIH07XG4gICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMucmVuZGVyTG9vcCgpOyB9LCAwKTsgLy8gZGVsYXkgc3RhcnQgYnkgb25lIHRpY2tcbn07XG5cblNjZW5lLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5sb2FkUXVldWVkVGlsZXMoKTtcblxuICAgIC8vIFJlbmRlciBvbiBkZW1hbmRcbiAgICB2YXIgd2lsbF9yZW5kZXIgPSAhKHRoaXMuZGlydHkgPT09IGZhbHNlIHx8IHRoaXMuaW5pdGlhbGl6ZWQgPT09IGZhbHNlIHx8IHRoaXMudmlld1JlYWR5KCkgPT09IGZhbHNlKTtcblxuICAgIC8vIFByZS1yZW5kZXIgbG9vcCBob29rXG4gICAgaWYgKHR5cGVvZiB0aGlzLnByZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnByZVVwZGF0ZSh3aWxsX3JlbmRlcik7XG4gICAgfVxuXG4gICAgLy8gQmFpbCBpZiBubyBuZWVkIHRvIHJlbmRlclxuICAgIGlmICghd2lsbF9yZW5kZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7IC8vIHN1YmNsYXNzZXMgY2FuIHNldCB0aGlzIGJhY2sgdG8gdHJ1ZSB3aGVuIGFuaW1hdGlvbiBpcyBuZWVkZWRcblxuICAgIC8vIFJlbmRlciB0aGUgc2NlbmVcbiAgICB0aGlzLnJlbmRlcigpO1xuXG4gICAgLy8gUG9zdC1yZW5kZXIgbG9vcCBob29rXG4gICAgaWYgKHR5cGVvZiB0aGlzLnBvc3RVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5wb3N0VXBkYXRlKHdpbGxfcmVuZGVyKTtcbiAgICB9XG5cbiAgICAvLyBSZWRyYXcgZXZlcnkgZnJhbWUgaWYgYW5pbWF0aW5nXG4gICAgaWYgKHRoaXMuYW5pbWF0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFtZSsrO1xuICAgIGxvZy50cmFjZSgnU2NlbmUucmVuZGVyKCknKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblNjZW5lLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIC8vIE1hcCB0cmFuc2Zvcm1zXG4gICAgaWYgKCF0aGlzLmNlbnRlcl9tZXRlcnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzdHlsZXMsIGNhbWVyYSwgbGlnaHRzXG4gICAgdGhpcy5jYW1lcmEudXBkYXRlKCk7XG4gICAgT2JqZWN0LmtleXModGhpcy5hY3RpdmVfc3R5bGVzKS5mb3JFYWNoKGkgPT4gdGhpcy5zdHlsZXNbaV0udXBkYXRlKCkpO1xuICAgIE9iamVjdC5rZXlzKHRoaXMubGlnaHRzKS5mb3JFYWNoKGkgPT4gdGhpcy5saWdodHNbaV0udXBkYXRlKCkpO1xuXG4gICAgLy8gUmVuZGVyYWJsZSB0aWxlIGxpc3RcbiAgICB0aGlzLnJlbmRlcmFibGVfdGlsZXMgPSBbXTtcbiAgICBmb3IgKHZhciB0IGluIHRoaXMudGlsZXMpIHtcbiAgICAgICAgdmFyIHRpbGUgPSB0aGlzLnRpbGVzW3RdO1xuICAgICAgICBpZiAodGlsZS52aXNpYmxlICYmIHRpbGUubG9hZGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmFibGVfdGlsZXMucHVzaCh0aWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbmRlcmFibGVfdGlsZXNfY291bnQgPSB0aGlzLnJlbmRlcmFibGVfdGlsZXMubGVuZ3RoO1xuXG4gICAgLy8gRmluZCBtaW4vbWF4IG9yZGVyIGZvciBjdXJyZW50IHRpbGVzXG4gICAgdGhpcy5vcmRlciA9IHRoaXMuY2FsY09yZGVyUmFuZ2UodGhpcy5yZW5kZXJhYmxlX3RpbGVzKTtcblxuICAgIC8vIFJlbmRlciBtYWluIHBhc3NcbiAgICB0aGlzLnJlbmRlcl9jb3VudCA9IHRoaXMucmVuZGVyUGFzcygpO1xuXG4gICAgLy8gUmVuZGVyIHNlbGVjdGlvbiBwYXNzIChpZiBuZWVkZWQpXG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uLnBlbmRpbmdSZXF1ZXN0cygpKSB7XG4gICAgICAgIGlmICh0aGlzLnBhbm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLmJpbmQoKTsgICAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggdG8gRkJPXG4gICAgICAgIHRoaXMucmVuZGVyUGFzcyhcbiAgICAgICAgICAgICdzZWxlY3Rpb25fcHJvZ3JhbScsICAgICAgICAgICAgICAgIC8vIHJlbmRlciB3L2FsdGVybmF0ZSBwcm9ncmFtXG4gICAgICAgICAgICB7IGFsbG93X2FscGhhX2JsZW5kOiBmYWxzZSB9KTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ucmVhZCgpOyAgICAgICAgICAgICAgICAgIC8vIHJlYWQgcmVzdWx0cyBmcm9tIHNlbGVjdGlvbiBidWZmZXJcblxuICAgICAgICAvLyBSZXNldCB0byBzY3JlZW4gYnVmZmVyXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlbmRlcl9jb3VudCAhPT0gdGhpcy5sYXN0X3JlbmRlcl9jb3VudCkge1xuICAgICAgICBsb2cuaW5mbyhgU2NlbmU6IHJlbmRlcmVkICR7dGhpcy5yZW5kZXJfY291bnR9IHByaW1pdGl2ZXNgKTtcbiAgICB9XG4gICAgdGhpcy5sYXN0X3JlbmRlcl9jb3VudCA9IHRoaXMucmVuZGVyX2NvdW50O1xuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8vIFJlbmRlciBhbGwgYWN0aXZlIHN0eWxlcywgZ3JvdXBlZCBieSBibGVuZC9kZXB0aCB0eXBlIChvcGFxdWUsIG92ZXJsYXksIGV0Yy4pIGFuZCBieSBwcm9ncmFtIChzdHlsZSlcbi8vIENhbGxlZCBib3RoIGZvciBtYWluIHJlbmRlciBwYXNzLCBhbmQgZm9yIHNlY29uZGFyeSBwYXNzZXMgbGlrZSBzZWxlY3Rpb24gYnVmZmVyXG5TY2VuZS5wcm90b3R5cGUucmVuZGVyUGFzcyA9IGZ1bmN0aW9uIChwcm9ncmFtX2tleSA9ICdwcm9ncmFtJywgeyBhbGxvd19hbHBoYV9ibGVuZCB9ID0ge30pIHtcbiAgICBsZXQgc3R5bGVzO1xuICAgIGxldCBjb3VudCA9IDA7IC8vIGhvdyBtYW55IHByaW1pdGl2ZXMgd2VyZSByZW5kZXJlZFxuXG4gICAgLy8gb3B0aW9uYWxseSBmb3JjZSBhbHBoYSBvZmYgKGUuZy4gZm9yIHNlbGVjdGlvbiBwYXNzKVxuICAgIGFsbG93X2FscGhhX2JsZW5kID0gKGFsbG93X2FscGhhX2JsZW5kID09IG51bGwpID8gdHJ1ZSA6IGFsbG93X2FscGhhX2JsZW5kO1xuXG4gICAgdGhpcy5jbGVhckZyYW1lKHsgY2xlYXJfY29sb3I6IHRydWUsIGNsZWFyX2RlcHRoOiB0cnVlIH0pO1xuXG4gICAgLy8gT3BhcXVlIHN0eWxlczogZGVwdGggdGVzdCBvbiwgZGVwdGggd3JpdGUgb24sIGJsZW5kaW5nIG9mZlxuICAgIHN0eWxlcyA9IE9iamVjdC5rZXlzKHRoaXMuYWN0aXZlX3N0eWxlcykuZmlsdGVyKHMgPT4gdGhpcy5zdHlsZXNbc10uYmxlbmQgPT09ICdvcGFxdWUnKTtcbiAgICB0aGlzLnNldFJlbmRlclN0YXRlKHsgZGVwdGhfdGVzdDogdHJ1ZSwgZGVwdGhfd3JpdGU6IHRydWUsIGFscGhhX2JsZW5kOiBmYWxzZSB9KTtcbiAgICBjb3VudCArPSB0aGlzLnJlbmRlclN0eWxlcyhzdHlsZXMsIHByb2dyYW1fa2V5KTtcblxuICAgIC8vIFRyYW5zcGFyZW50IHN0eWxlczogZGVwdGggdGVzdCBvZmYsIGRlcHRoIHdyaXRlIG9uLCBjdXN0b20gYmxlbmRpbmdcbiAgICBzdHlsZXMgPSBPYmplY3Qua2V5cyh0aGlzLmFjdGl2ZV9zdHlsZXMpLmZpbHRlcihzID0+IHRoaXMuc3R5bGVzW3NdLmJsZW5kID09PSAnYWRkJyk7XG4gICAgdGhpcy5zZXRSZW5kZXJTdGF0ZSh7IGRlcHRoX3Rlc3Q6IHRydWUsIGRlcHRoX3dyaXRlOiBmYWxzZSwgYWxwaGFfYmxlbmQ6IChhbGxvd19hbHBoYV9ibGVuZCAmJiAnYWRkJykgfSk7XG4gICAgY291bnQgKz0gdGhpcy5yZW5kZXJTdHlsZXMoc3R5bGVzLCBwcm9ncmFtX2tleSk7XG5cbiAgICBzdHlsZXMgPSBPYmplY3Qua2V5cyh0aGlzLmFjdGl2ZV9zdHlsZXMpLmZpbHRlcihzID0+IHRoaXMuc3R5bGVzW3NdLmJsZW5kID09PSAnbXVsdGlwbHknKTtcbiAgICB0aGlzLnNldFJlbmRlclN0YXRlKHsgZGVwdGhfdGVzdDogdHJ1ZSwgZGVwdGhfd3JpdGU6IGZhbHNlLCBhbHBoYV9ibGVuZDogKGFsbG93X2FscGhhX2JsZW5kICYmICdtdWx0aXBseScpIH0pO1xuICAgIGNvdW50ICs9IHRoaXMucmVuZGVyU3R5bGVzKHN0eWxlcywgcHJvZ3JhbV9rZXkpO1xuXG4gICAgLy8gT3ZlcmxheSBzdHlsZXM6IGRlcHRoIHRlc3Qgb2ZmLCBkZXB0aCB3cml0ZSBvZmYsIGJsZW5kaW5nIG9uXG4gICAgc3R5bGVzID0gT2JqZWN0LmtleXModGhpcy5zdHlsZXMpLmZpbHRlcihzID0+IHRoaXMuc3R5bGVzW3NdLmJsZW5kID09PSAnb3ZlcmxheScpO1xuICAgIHRoaXMuc2V0UmVuZGVyU3RhdGUoeyBkZXB0aF90ZXN0OiBmYWxzZSwgZGVwdGhfd3JpdGU6IGZhbHNlLCBhbHBoYV9ibGVuZDogYWxsb3dfYWxwaGFfYmxlbmQgfSk7XG4gICAgY291bnQgKz0gdGhpcy5yZW5kZXJTdHlsZXMoc3R5bGVzLCBwcm9ncmFtX2tleSk7XG5cbiAgICByZXR1cm4gY291bnQ7XG59O1xuXG5TY2VuZS5wcm90b3R5cGUucmVuZGVyU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcywgcHJvZ3JhbV9rZXkpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAobGV0IHN0eWxlIG9mIHN0eWxlcykge1xuICAgICAgICBsZXQgcHJvZ3JhbSA9IHRoaXMuc3R5bGVzW3N0eWxlXVtwcm9ncmFtX2tleV07XG4gICAgICAgIGlmICghcHJvZ3JhbSB8fCAhcHJvZ3JhbS5jb21waWxlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY291bnQgKz0gdGhpcy5yZW5kZXJTdHlsZShzdHlsZSwgcHJvZ3JhbSk7XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbn07XG5cblNjZW5lLnByb3RvdHlwZS5yZW5kZXJTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSwgcHJvZ3JhbSkge1xuICAgIHZhciBmaXJzdF9mb3Jfc3R5bGUgPSB0cnVlO1xuICAgIHZhciByZW5kZXJfY291bnQgPSAwO1xuXG4gICAgLy8gUmVuZGVyIHRpbGUgR0wgZ2VvbWV0cmllc1xuICAgIGZvciAodmFyIHQgaW4gdGhpcy5yZW5kZXJhYmxlX3RpbGVzKSB7XG4gICAgICAgIHZhciB0aWxlID0gdGhpcy5yZW5kZXJhYmxlX3RpbGVzW3RdO1xuXG4gICAgICAgIGlmICh0aWxlLm1lc2hlc1tzdHlsZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gU2V0dXAgc3R5bGUgaWYgZW5jb3VudGVyaW5nIGZvciBmaXJzdCB0aW1lIHRoaXMgZnJhbWVcbiAgICAgICAgICAgIC8vIChsYXp5IGluaXQsIG5vdCBhbGwgc3R5bGVzIHdpbGwgYmUgdXNlZCBpbiBhbGwgc2NyZWVuIHZpZXdzOyBzb21lIHN0eWxlcyBtaWdodCBiZSBkZWZpbmVkIGJ1dCBuZXZlciB1c2VkKVxuICAgICAgICAgICAgaWYgKGZpcnN0X2Zvcl9zdHlsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGZpcnN0X2Zvcl9zdHlsZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgcHJvZ3JhbS51c2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlc1tzdHlsZV0uc2V0dXAoKTtcblxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGRvbid0IHNldCB1bmlmb3JtcyB3aGVuIHRoZXkgaGF2ZW4ndCBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCcyZicsICd1X3Jlc29sdXRpb24nLCB0aGlzLmRldmljZV9zaXplLndpZHRoLCB0aGlzLmRldmljZV9zaXplLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCcyZicsICd1X2FzcGVjdCcsIHRoaXMudmlld19hc3BlY3QsIDEuMCk7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCcxZicsICd1X3RpbWUnLCAoKCtuZXcgRGF0ZSgpKSAtIHRoaXMuc3RhcnRfdGltZSkgLyAxMDAwKTtcbiAgICAgICAgICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzFmJywgJ3VfbWFwX3pvb20nLCB0aGlzLnpvb20pOyAvLyBNYXRoLmZsb29yKHRoaXMuem9vbSkgKyAoTWF0aC5sb2coKHRoaXMuem9vbSAlIDEpICsgMSkgLyBNYXRoLkxOMiAvLyBzY2FsZSBmcmFjdGlvbmFsIHpvb20gYnkgbG9nXG4gICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCcyZicsICd1X21hcF9jZW50ZXInLCB0aGlzLmNlbnRlcl9tZXRlcnMueCwgdGhpcy5jZW50ZXJfbWV0ZXJzLnkpO1xuICAgICAgICAgICAgICAgIHByb2dyYW0udW5pZm9ybSgnMWYnLCAndV9vcmRlcl9taW4nLCB0aGlzLm9yZGVyLm1pbik7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCcxZicsICd1X29yZGVyX3JhbmdlJywgdGhpcy5vcmRlci5yYW5nZSk7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCcxZicsICd1X21ldGVyc19wZXJfcGl4ZWwnLCB0aGlzLm1ldGVyc19wZXJfcGl4ZWwpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmEuc2V0dXBQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5saWdodHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saWdodHNbaV0uc2V0dXBQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETzogY2FsYyB0aGVzZSBvbmNlIHBlciB0aWxlIChjdXJyZW50bHkgYmVpbmcgbmVlZGxlc3NseSByZS1jYWxjdWxhdGVkIHBlci10aWxlLXBlci1zdHlsZSlcblxuICAgICAgICAgICAgLy8gVGlsZSBvcmlnaW5cbiAgICAgICAgICAgIHByb2dyYW0udW5pZm9ybSgnMmYnLCAndV90aWxlX29yaWdpbicsIHRpbGUubWluLngsIHRpbGUubWluLnkpO1xuXG4gICAgICAgICAgICAvLyBNb2RlbCBtYXRyaXggLSB0cmFuc2Zvcm0gdGlsZSBzcGFjZSBpbnRvIHdvcmxkIHNwYWNlIChtZXRlcnMsIGFic29sdXRlIG1lcmNhdG9yIHBvc2l0aW9uKVxuICAgICAgICAgICAgbWF0NC5pZGVudGl0eSh0aGlzLm1vZGVsTWF0cml4KTtcbiAgICAgICAgICAgIG1hdDQudHJhbnNsYXRlKHRoaXMubW9kZWxNYXRyaXgsIHRoaXMubW9kZWxNYXRyaXgsIHZlYzMuZnJvbVZhbHVlcyh0aWxlLm1pbi54LCB0aWxlLm1pbi55LCAwKSk7XG4gICAgICAgICAgICBtYXQ0LnNjYWxlKHRoaXMubW9kZWxNYXRyaXgsIHRoaXMubW9kZWxNYXRyaXgsIHZlYzMuZnJvbVZhbHVlcyh0aWxlLnNwYW4ueCAvIFNjZW5lLnRpbGVfc2NhbGUsIC0xICogdGlsZS5zcGFuLnkgLyBTY2VuZS50aWxlX3NjYWxlLCAxKSk7IC8vIHNjYWxlIHRpbGUgbG9jYWwgY29vcmRzIHRvIG1ldGVyc1xuICAgICAgICAgICAgbWF0NC5jb3B5KHRoaXMubW9kZWxNYXRyaXgzMiwgdGhpcy5tb2RlbE1hdHJpeCk7XG4gICAgICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJ01hdHJpeDRmdicsICd1X21vZGVsJywgZmFsc2UsIHRoaXMubW9kZWxNYXRyaXgzMik7XG5cbiAgICAgICAgICAgIC8vIE1vZGVsIHZpZXcgbWF0cml4IC0gdHJhbnNmb3JtIHRpbGUgc3BhY2UgaW50byB2aWV3IHNwYWNlIChtZXRlcnMsIHJlbGF0aXZlIHRvIGNhbWVyYSlcbiAgICAgICAgICAgIG1hdDQubXVsdGlwbHkodGhpcy5tb2RlbFZpZXdNYXRyaXgzMiwgdGhpcy5jYW1lcmEudmlld01hdHJpeCwgdGhpcy5tb2RlbE1hdHJpeCk7XG4gICAgICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJ01hdHJpeDRmdicsICd1X21vZGVsVmlldycsIGZhbHNlLCB0aGlzLm1vZGVsVmlld01hdHJpeDMyKTtcblxuICAgICAgICAgICAgLy8gTm9ybWFsIG1hdHJpeCAtIHRyYW5zZm9ybXMgc3VyZmFjZSBub3JtYWxzIGludG8gdmlldyBzcGFjZVxuICAgICAgICAgICAgbWF0My5ub3JtYWxGcm9tTWF0NCh0aGlzLm5vcm1hbE1hdHJpeDMyLCB0aGlzLm1vZGVsVmlld01hdHJpeDMyKTtcbiAgICAgICAgICAgIHByb2dyYW0udW5pZm9ybSgnTWF0cml4M2Z2JywgJ3Vfbm9ybWFsTWF0cml4JywgZmFsc2UsIHRoaXMubm9ybWFsTWF0cml4MzIpO1xuXG4gICAgICAgICAgICAvLyBSZW5kZXIgdGlsZVxuICAgICAgICAgICAgdGlsZS5tZXNoZXNbc3R5bGVdLnJlbmRlcigpO1xuICAgICAgICAgICAgcmVuZGVyX2NvdW50ICs9IHRpbGUubWVzaGVzW3N0eWxlXS5nZW9tZXRyeV9jb3VudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJfY291bnQ7XG59O1xuXG5TY2VuZS5wcm90b3R5cGUuY2xlYXJGcmFtZSA9IGZ1bmN0aW9uICh7IGNsZWFyX2NvbG9yLCBjbGVhcl9kZXB0aCB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHRzXG4gICAgY2xlYXJfY29sb3IgPSAoY2xlYXJfY29sb3IgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZTsgLy8gZGVmYXVsdCB0cnVlXG4gICAgY2xlYXJfZGVwdGggPSAoY2xlYXJfZGVwdGggPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZTsgLy8gZGVmYXVsdCB0cnVlXG5cbiAgICAvLyBSZXNldCBmcmFtZSBzdGF0ZVxuICAgIGxldCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBpZiAoY2xlYXJfY29sb3IpIHtcbiAgICAgICAgZ2wuY2xlYXJDb2xvcigwLjAsIDAuMCwgMC4wLCAxLjApO1xuICAgIH1cblxuICAgIGlmIChjbGVhcl9kZXB0aCkge1xuICAgICAgICBnbC5kZXB0aE1hc2sodHJ1ZSk7IC8vIGFsd2F5cyBjbGVhciBkZXB0aCBpZiByZXF1ZXN0ZWQsIGV2ZW4gaWYgZGVwdGggd3JpdGUgd2lsbCBiZSB0dXJuZWQgb2ZmXG4gICAgfVxuXG4gICAgaWYgKGNsZWFyX2NvbG9yIHx8IGNsZWFyX2RlcHRoKSB7XG4gICAgICAgIGxldCBtYXNrID0gKGNsZWFyX2NvbG9yICYmIGdsLkNPTE9SX0JVRkZFUl9CSVQpIHwgKGNsZWFyX2RlcHRoICYmIGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuICAgICAgICBnbC5jbGVhcihtYXNrKTtcbiAgICB9XG59O1xuXG5TY2VuZS5wcm90b3R5cGUuc2V0UmVuZGVyU3RhdGUgPSBmdW5jdGlvbiAoeyBkZXB0aF90ZXN0LCBkZXB0aF93cml0ZSwgY3VsbF9mYWNlLCBhbHBoYV9ibGVuZCB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHRzXG4gICAgLy8gVE9ETzogd2hlbiB3ZSBhYnN0cmFjdCBvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgcmVuZGVyIHBhc3NlcywgdGhlc2UgY2FuIGJlIHBlci1wYXNzIGNvbmZpZyBvcHRpb25zXG4gICAgZGVwdGhfdGVzdCA9IChkZXB0aF90ZXN0ID09PSBmYWxzZSkgPyBmYWxzZSA6IHRydWU7ICAgICAgICAgLy8gZGVmYXVsdCB0cnVlXG4gICAgZGVwdGhfd3JpdGUgPSAoZGVwdGhfd3JpdGUgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZTsgICAgICAgLy8gZGVmYXVsdCB0cnVlXG4gICAgY3VsbF9mYWNlID0gKGN1bGxfZmFjZSA9PT0gZmFsc2UpID8gZmFsc2UgOiB0cnVlOyAgICAgICAgICAgLy8gZGVmYXVsdCB0cnVlXG4gICAgYWxwaGFfYmxlbmQgPSAoYWxwaGFfYmxlbmQgIT0gbnVsbCkgPyBhbHBoYV9ibGVuZCA6IGZhbHNlOyAgLy8gZGVmYXVsdCBmYWxzZVxuXG4gICAgLy8gUmVzZXQgZnJhbWUgc3RhdGVcbiAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuXG4gICAgaWYgKGRlcHRoX3Rlc3QpIHtcbiAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgICAgICBnbC5kZXB0aEZ1bmMoZ2wuTEVRVUFMKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgfVxuXG4gICAgZ2wuZGVwdGhNYXNrKGRlcHRoX3dyaXRlKTtcblxuICAgIGlmIChjdWxsX2ZhY2UpIHtcbiAgICAgICAgZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSk7XG4gICAgICAgIGdsLmN1bGxGYWNlKGdsLkJBQ0spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgIH1cblxuICAgIGlmIChhbHBoYV9ibGVuZCkge1xuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuXG4gICAgICAgIC8vIFRyYWRpdGlvbmFsIGJsZW5kaW5nXG4gICAgICAgIGlmIChhbHBoYV9ibGVuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkaXRpdmUgYmxlbmRpbmdcbiAgICAgICAgZWxzZSBpZiAoYWxwaGFfYmxlbmQgPT09ICdhZGQnKSB7XG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpcGxpY2F0aXZlIGJsZW5kaW5nXG4gICAgICAgIGVsc2UgaWYgKGFscGhhX2JsZW5kID09PSAnbXVsdGlwbHknKSB7XG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuWkVSTywgZ2wuU1JDX0NPTE9SKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG4gICAgfVxufTtcblxuLy8gRmluZCBtaW4vbWF4IG9yZGVyIGZvciBhIHNldCBvZiB0aWxlc1xuU2NlbmUucHJvdG90eXBlLmNhbGNPcmRlclJhbmdlID0gZnVuY3Rpb24gKHRpbGVzKSB7XG4gICAgbGV0IG9yZGVyID0geyBtaW46IEluZmluaXR5LCBtYXg6IC1JbmZpbml0eSB9O1xuICAgIGZvciAobGV0IHQgb2YgdGlsZXMpIHtcbiAgICAgICAgaWYgKHQub3JkZXIubWluIDwgb3JkZXIubWluKSB7XG4gICAgICAgICAgICBvcmRlci5taW4gPSB0Lm9yZGVyLm1pbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodC5vcmRlci5tYXggPiBvcmRlci5tYXgpIHtcbiAgICAgICAgICAgIG9yZGVyLm1heCA9IHQub3JkZXIubWF4O1xuICAgICAgICB9XG4gICAgfVxuICAgIG9yZGVyLm1heCArPSAxO1xuICAgIG9yZGVyLnJhbmdlID0gb3JkZXIubWF4IC0gb3JkZXIubWluO1xuICAgIHJldHVybiBvcmRlcjtcbn07XG5cblxuLy8gUmVxdWVzdCBmZWF0dXJlIHNlbGVjdGlvbiBhdCBnaXZlbiBwaXhlbC4gUnVucyBhc3luYyBhbmQgcmV0dXJucyByZXN1bHRzIHZpYSBhIHByb21pc2UuXG5TY2VuZS5wcm90b3R5cGUuZ2V0RmVhdHVyZUF0ID0gZnVuY3Rpb24gKHBpeGVsKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJTY2VuZS5nZXRGZWF0dXJlQXQoKSBjYWxsZWQgYmVmb3JlIHNjZW5lIHdhcyBpbml0aWFsaXplZFwiKSk7XG4gICAgfVxuXG4gICAgLy8gUG9pbnQgc2NhbGVkIHRvIFswLi4xXSByYW5nZVxuICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgeDogcGl4ZWwueCAqIHRoaXMuZGV2aWNlX3BpeGVsX3JhdGlvIC8gdGhpcy5kZXZpY2Vfc2l6ZS53aWR0aCxcbiAgICAgICAgeTogcGl4ZWwueSAqIHRoaXMuZGV2aWNlX3BpeGVsX3JhdGlvIC8gdGhpcy5kZXZpY2Vfc2l6ZS5oZWlnaHRcbiAgICB9O1xuXG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7IC8vIG5lZWQgdG8gbWFrZSBzdXJlIHRoZSBzY2VuZSByZS1yZW5kZXJzIGZvciB0aGVzZSB0byBiZSBwcm9jZXNzZWRcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uZ2V0RmVhdHVyZUF0KHBvaW50KTtcbn07XG5cbi8vIFF1ZXVlIGEgdGlsZSBmb3IgbG9hZFxuU2NlbmUucHJvdG90eXBlLmxvYWRUaWxlID0gZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgIHRoaXMucXVldWVkX3RpbGVzW3RoaXMucXVldWVkX3RpbGVzLmxlbmd0aF0gPSBjb29yZHM7XG59O1xuXG4vLyBMb2FkIGFsbCBxdWV1ZWQgdGlsZXNcblNjZW5lLnByb3RvdHlwZS5sb2FkUXVldWVkVGlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5xdWV1ZWRfdGlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTb3J0IHF1ZXVlZCB0aWxlcyBmcm9tIGNlbnRlciB0aWxlXG4gICAgdGhpcy5xdWV1ZWRfdGlsZXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBsZXQgYWQgPSBNYXRoLmFicyh0aGlzLmNlbnRlcl90aWxlLnggLSBhLngpICsgTWF0aC5hYnModGhpcy5jZW50ZXJfdGlsZS55IC0gYS55KTtcbiAgICAgICAgbGV0IGJkID0gTWF0aC5hYnModGhpcy5jZW50ZXJfdGlsZS54IC0gYi54KSArIE1hdGguYWJzKHRoaXMuY2VudGVyX3RpbGUueSAtIGIueSk7XG4gICAgICAgIHJldHVybiAoYmQgPiBhZCA/IC0xIDogKGJkID09PSBhZCA/IDAgOiAxKSk7XG4gICAgfSk7XG4gICAgdGhpcy5xdWV1ZWRfdGlsZXMuZm9yRWFjaChjb29yZHMgPT4gdGhpcy5fbG9hZFRpbGUoY29vcmRzKSk7XG4gICAgdGhpcy5xdWV1ZWRfdGlsZXMgPSBbXTtcbn07XG5cbi8vIExvYWQgYSBzaW5nbGUgdGlsZVxuU2NlbmUucHJvdG90eXBlLl9sb2FkVGlsZSA9IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAvLyBTa2lwIGlmIG5vdCBhdCBjdXJyZW50IHNjZW5lIHpvb21cbiAgICBpZiAoY29vcmRzLnogIT09IHRoaXMuY2VudGVyX3RpbGUueikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGtleSA9IFRpbGUua2V5KGNvb3Jkcyk7XG4gICAgbGV0IHRpbGU7XG4gICAgaWYgKCF0aGlzLmhhc1RpbGUoa2V5KSkge1xuICAgICAgICB0aWxlID0gVGlsZS5jcmVhdGUoe1xuICAgICAgICAgICAgY29vcmRzOiBjb29yZHMsXG4gICAgICAgICAgICBtYXhfem9vbTogdGhpcy5maW5kTWF4Wm9vbSgpLFxuICAgICAgICAgICAgd29ya2VyOiB0aGlzLm5leHRXb3JrZXIoKVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmNhY2hlVGlsZSh0aWxlKTtcbiAgICAgICAgdGlsZS5sb2FkKHRoaXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGlsZSA9IHRoaXMudGlsZXNba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbGU7XG59O1xuXG4vLyB0aWxlIG1hbmFnZXJcblNjZW5lLnByb3RvdHlwZS5jYWNoZVRpbGUgPSBmdW5jdGlvbiAodGlsZSkge1xuICAgIHRoaXMudGlsZXNbdGlsZS5rZXldID0gdGlsZTtcbn07XG5cblNjZW5lLnByb3RvdHlwZS5oYXNUaWxlID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLnRpbGVzW2tleV0gIT09IHVuZGVmaW5lZDtcbn07XG5cblNjZW5lLnByb3RvdHlwZS5mb3JnZXRUaWxlID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbGV0ZSB0aGlzLnRpbGVzW2tleV07XG5cbiAgICBpZiAodGhpcy5idWlsZGluZyAmJiB0aGlzLmJ1aWxkaW5nLnRpbGVzKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmJ1aWxkaW5nLnRpbGVzW2tleV07XG4gICAgfVxufTtcblxuU2NlbmUucHJvdG90eXBlLmZpbmRNYXhab29tID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtYXhfem9vbSA9IHRoaXMubWF4X3pvb20gfHwgR2VvLm1heF96b29tO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLnNvdXJjZXMpIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IHRoaXMuc291cmNlc1tuYW1lXTtcbiAgICAgICAgaWYgKHNvdXJjZS5tYXhfem9vbSA8IG1heF96b29tKSB7XG4gICAgICAgICAgICBtYXhfem9vbSA9IHNvdXJjZS5tYXhfem9vbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4X3pvb207XG59O1xuXG4vLyBUT0RPOiBkZXRlY3Qgd2hpY2ggZWxlbWVudHMgbmVlZCB0byBiZSByZWZyZXNoZWQvcmVidWlsdCAoc3R5bGVzaGVldCBjaGFuZ2VzLCBldGMuKVxuU2NlbmUucHJvdG90eXBlLnJlYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVidWlsZEdlb21ldHJ5KCk7XG59O1xuXG4vLyBSZWJ1aWxkIGFsbCB0aWxlc1xuU2NlbmUucHJvdG90eXBlLnJlYnVpbGRHZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignU2NlbmUucmVidWlsZEdlb21ldHJ5OiBzY2VuZSBpcyBub3QgaW5pdGlhbGl6ZWQnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgLy8gU2tpcCByZWJ1aWxkIGlmIGFscmVhZHkgaW4gcHJvZ3Jlc3NcbiAgICAgICAgaWYgKHRoaXMuYnVpbGRpbmcpIHtcbiAgICAgICAgICAgIC8vIFF1ZXVlIHVwIHRvIG9uZSByZWJ1aWxkIGNhbGwgYXQgYSB0aW1lLCBvbmx5IHNhdmUgbGFzdCByZXF1ZXN0XG4gICAgICAgICAgICBpZiAodGhpcy5idWlsZGluZy5xdWV1ZWQgJiYgdGhpcy5idWlsZGluZy5xdWV1ZWQucmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gbm90aWZ5IHByZXZpb3VzIHJlcXVlc3QgdGhhdCBpdCBkaWQgbm90IGNvbXBsZXRlXG4gICAgICAgICAgICAgICAgbG9nLmRlYnVnKCdTY2VuZS5yZWJ1aWxkR2VvbWV0cnk6IHJlcXVlc3Qgc3VwZXJjZWRlZCBieSBhIG5ld2VyIGNhbGwnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkaW5nLnF1ZXVlZC5yZXNvbHZlKGZhbHNlKTsgLy8gZmFsc2UgZmxhZyBpbmRpY2F0ZXMgcmVidWlsZCByZXF1ZXN0IHdhcyBzdXBlcmNlZGVkXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNhdmUgcXVldWVkIHJlcXVlc3RcbiAgICAgICAgICAgIHRoaXMuYnVpbGRpbmcucXVldWVkID0geyByZXNvbHZlLCByZWplY3QgfTtcbiAgICAgICAgICAgIGxvZy50cmFjZShgU2NlbmUucmVidWlsZEdlb21ldHJ5KCk6IHF1ZXVpbmcgcmVxdWVzdGApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhY2sgdGlsZSBidWlsZCBzdGF0ZVxuICAgICAgICB0aGlzLmJ1aWxkaW5nID0geyByZXNvbHZlLCByZWplY3QsIHRpbGVzOiB7fSB9O1xuXG4gICAgICAgIC8vIFByb2ZpbGluZ1xuICAgICAgICBpZiAodGhpcy5kZWJ1Zy5wcm9maWxlLmdlb21ldHJ5X2J1aWxkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9maWxlKCdyZWJ1aWxkR2VvbWV0cnknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBjb25maWcgKGluIGNhc2UgSlMgb2JqZWN0cyB3ZXJlIG1hbmlwdWxhdGVkIGRpcmVjdGx5KVxuICAgICAgICB0aGlzLnN5bmNDb25maWdUb1dvcmtlcigpO1xuXG4gICAgICAgIC8vIFJlYnVpbGQgdmlzaWJsZSB0aWxlcywgc29ydGVkIGZyb20gY2VudGVyXG4gICAgICAgIGxldCBidWlsZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0aWxlIG9mIFV0aWxzLnZhbHVlcyh0aGlzLnRpbGVzKSkge1xuICAgICAgICAgICAgaWYgKHRpbGUudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGJ1aWxkLnB1c2godGlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRpbGUodGlsZS5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFRpbGUuc29ydChidWlsZCkuZm9yRWFjaCh0aWxlID0+IHRpbGUuYnVpbGQodGhpcykpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlQWN0aXZlU3R5bGVzKCk7XG4gICAgICAgIHRoaXMucmVzZXRUaW1lKCk7XG5cbiAgICAgICAgLy8gRWRnZSBjYXNlOiBpZiBub3RoaW5nIGlzIGJlaW5nIHJlYnVpbHQsIGltbWVkaWF0ZWx5IHJlc29sdmUgcHJvbWlzZSBhbmQgZG9uJ3QgbG9jayBmdXJ0aGVyIHJlYnVpbGRzXG4gICAgICAgIGlmICh0aGlzLmJ1aWxkaW5nICYmIE9iamVjdC5rZXlzKHRoaXMuYnVpbGRpbmcudGlsZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIEFub3RoZXIgcmVidWlsZCBxdWV1ZWQ/XG4gICAgICAgICAgICB2YXIgcXVldWVkID0gdGhpcy5idWlsZGluZy5xdWV1ZWQ7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkaW5nID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChxdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoYFNjZW5lOiBzdGFydGluZyBxdWV1ZWQgcmVidWlsZEdlb21ldHJ5KCkgcmVxdWVzdGApO1xuICAgICAgICAgICAgICAgIHRoaXMucmVidWlsZEdlb21ldHJ5KCkudGhlbihxdWV1ZWQucmVzb2x2ZSwgcXVldWVkLnJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgLy8gUHJvZmlsaW5nXG4gICAgICAgIGlmICh0aGlzLmRlYnVnLnByb2ZpbGUuZ2VvbWV0cnlfYnVpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2ZpbGVFbmQoJ3JlYnVpbGRHZW9tZXRyeScpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vLyBUT0RPOiBtb3ZlIHRvIFRpbGUgY2xhc3Ncbi8vIENhbGxlZCBvbiBtYWluIHRocmVhZCB3aGVuIGEgd2ViIHdvcmtlciBjb21wbGV0ZXMgcHJvY2Vzc2luZyBmb3IgYSBzaW5nbGUgdGlsZSAoaW5pdGlhbCBsb2FkLCBvciByZWJ1aWxkKVxuU2NlbmUucHJvdG90eXBlLmJ1aWxkVGlsZUNvbXBsZXRlZCA9IGZ1bmN0aW9uICh7IHRpbGUsIHdvcmtlcl9pZCwgc2VsZWN0aW9uX21hcF9zaXplIH0pIHtcbiAgICAvLyBUcmFjayBzZWxlY3Rpb24gbWFwIHNpemUgKGZvciBzdGF0cy9kZWJ1ZykgLSB1cGRhdGUgcGVyIHdvcmtlciBhbmQgc3VtIGFjcm9zcyB3b3JrZXJzXG4gICAgdGhpcy5zZWxlY3Rpb25fbWFwX3dvcmtlcl9zaXplW3dvcmtlcl9pZF0gPSBzZWxlY3Rpb25fbWFwX3NpemU7XG4gICAgdGhpcy5zZWxlY3Rpb25fbWFwX3NpemUgPSAwO1xuICAgIGZvciAodmFyIHdpZCBpbiB0aGlzLnNlbGVjdGlvbl9tYXBfd29ya2VyX3NpemUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25fbWFwX3NpemUgKz0gdGhpcy5zZWxlY3Rpb25fbWFwX3dvcmtlcl9zaXplW3dpZF07XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlZCB0aGlzIHRpbGUgZHVyaW5nIGxvYWQ/XG4gICAgaWYgKHRoaXMudGlsZXNbdGlsZS5rZXldID09IG51bGwpIHtcbiAgICAgICAgbG9nLnRyYWNlKGBkaXNjYXJkZWQgdGlsZSAke3RpbGUua2V5fSBpbiBTY2VuZS5idWlsZFRpbGVDb21wbGV0ZWQgYmVjYXVzZSBwcmV2aW91c2x5IHJlbW92ZWRgKTtcbiAgICAgICAgVGlsZS5hYm9ydEJ1aWxkKHRpbGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGNhY2hlZCA9IHRoaXMudGlsZXNbdGlsZS5rZXldO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aWxlIHdpdGggcHJvcGVydGllcyBmcm9tIHdvcmtlclxuICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICB0aWxlID0gY2FjaGVkLm1lcmdlKHRpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aWxlLmVycm9yKSB7XG4gICAgICAgICAgICB0aWxlLmZpbmFsaXplQnVpbGQodGhpcy5zdHlsZXMpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2cuZXJyb3IoYG1haW4gdGhyZWFkIHRpbGUgbG9hZCBlcnJvciBmb3IgJHt0aWxlLmtleX06ICR7dGlsZS5lcnJvcn1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aWxlLnByaW50RGVidWcoKTtcbiAgICB9XG5cbiAgICB0aGlzLnRyYWNrVGlsZVNldExvYWRTdG9wKCk7XG4gICAgdGhpcy50cmFja1RpbGVCdWlsZFN0b3AodGlsZS5rZXkpO1xufTtcblxuLy8gVHJhY2sgdGlsZSBidWlsZCBzdGF0ZVxuU2NlbmUucHJvdG90eXBlLnRyYWNrVGlsZUJ1aWxkU3RhcnQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCF0aGlzLmJ1aWxkaW5nKSB7XG4gICAgICAgIHRoaXMuYnVpbGRpbmcgPSB7XG4gICAgICAgICAgICB0aWxlczoge31cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5idWlsZGluZy50aWxlc1trZXldID0gdHJ1ZTtcbiAgICBsb2cudHJhY2UoYHRyYWNrVGlsZUJ1aWxkU3RhcnQgZm9yICR7a2V5fTogJHtPYmplY3Qua2V5cyh0aGlzLmJ1aWxkaW5nLnRpbGVzKS5sZW5ndGh9YCk7XG59O1xuXG5TY2VuZS5wcm90b3R5cGUudHJhY2tUaWxlQnVpbGRTdG9wID0gZnVuY3Rpb24gKGtleSkge1xuICAgIC8vIERvbmUgYnVpbGRpbmc/XG4gICAgaWYgKHRoaXMuYnVpbGRpbmcpIHtcbiAgICAgICAgbG9nLnRyYWNlKGB0cmFja1RpbGVCdWlsZFN0b3AgZm9yICR7a2V5fTogJHtPYmplY3Qua2V5cyh0aGlzLmJ1aWxkaW5nLnRpbGVzKS5sZW5ndGh9YCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmJ1aWxkaW5nLnRpbGVzW2tleV07XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmJ1aWxkaW5nLnRpbGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvZy5pbmZvKGBTY2VuZTogYnVpbGQgZ2VvbWV0cnkgZmluaXNoZWRgKTtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhgU2NlbmU6IHVwZGF0ZWQgc2VsZWN0aW9uIG1hcDogJHt0aGlzLnNlbGVjdGlvbl9tYXBfc2l6ZX0gZmVhdHVyZXNgKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuYnVpbGRpbmcucmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRpbmcucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQW5vdGhlciByZWJ1aWxkIHF1ZXVlZD9cbiAgICAgICAgICAgIHZhciBxdWV1ZWQgPSB0aGlzLmJ1aWxkaW5nLnF1ZXVlZDtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRpbmcgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHF1ZXVlZCkge1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhgU2NlbmU6IHN0YXJ0aW5nIHF1ZXVlZCByZWJ1aWxkR2VvbWV0cnkoKSByZXF1ZXN0YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWJ1aWxkR2VvbWV0cnkoKS50aGVuKHF1ZXVlZC5yZXNvbHZlLCBxdWV1ZWQucmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblNjZW5lLnByb3RvdHlwZS5yZW1vdmVUaWxlID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZy50cmFjZShgdGlsZSB1bmxvYWQgZm9yICR7a2V5fWApO1xuXG4gICAgdmFyIHRpbGUgPSB0aGlzLnRpbGVzW2tleV07XG5cbiAgICBpZiAodGlsZSAhPSBudWxsKSB7XG4gICAgICAgIHRpbGUuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuZm9yZ2V0VGlsZSh0aWxlLmtleSk7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG59O1xuXG4vKipcbiAgIExvYWQgKG9yIHJlbG9hZCkgdGhlIHNjZW5lIGNvbmZpZ1xuICAgQHJldHVybiB7UHJvbWlzZX1cbiovXG5TY2VuZS5wcm90b3R5cGUubG9hZFNjZW5lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBVdGlscy5sb2FkUmVzb3VyY2UodGhpcy5jb25maWdfc291cmNlKS50aGVuKChjb25maWcpID0+IHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHJldHVybiB0aGlzLnByZVByb2Nlc3NTY2VuZUNvbmZpZygpLnRoZW4oKCkgPT4geyB0aGlzLnRyaWdnZXIoJ2xvYWRTY2VuZScsIHRoaXMuY29uZmlnKTsgfSk7XG4gICAgfSkuY2F0Y2goZSA9PiB7IHRocm93IGU7IH0pO1xufTtcblxuLy8gUmVsb2FkIHNjZW5lIGNvbmZpZyBhbmQgcmVidWlsZCB0aWxlc1xuU2NlbmUucHJvdG90eXBlLnJlbG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubG9hZFNjZW5lKCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlU3R5bGVzKHRoaXMuZ2wpO1xuICAgICAgICB0aGlzLnN5bmNDb25maWdUb1dvcmtlcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWJ1aWxkR2VvbWV0cnkoKTtcbiAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG59O1xuXG5TY2VuZS5wcm90b3R5cGUubG9hZERhdGFTb3VyY2VzID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5jb25maWcuc291cmNlcykge1xuICAgICAgICBsZXQgc291cmNlID0gdGhpcy5jb25maWcuc291cmNlc1tuYW1lXTtcbiAgICAgICAgc291cmNlLnVybCA9IFV0aWxzLmFkZEJhc2VVUkwoc291cmNlLnVybCk7XG4gICAgICAgIHRoaXMuc291cmNlc1tuYW1lXSA9IFRpbGVTb3VyY2UuY3JlYXRlKE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZSwge25hbWV9KSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlQm91bmRzKCk7XG59O1xuXG5TY2VuZS5wcm90b3R5cGUuc2V0U291cmNlTWF4ID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBtYXhfem9vbSA9IHRoaXMuZmluZE1heFpvb20oKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5zb3VyY2VzKSB7XG4gICAgICAgIGxldCBzb3VyY2UgPSB0aGlzLnNvdXJjZXNbbmFtZV07XG4gICAgICAgIHNvdXJjZS5tYXhfem9vbSA9IG1heF96b29tO1xuICAgIH1cbiAgICByZXR1cm4gbWF4X3pvb207XG59O1xuXG4vLyBOb3JtYWxpemUgc29tZSBzZXR0aW5ncyB0aGF0IG1heSBub3QgaGF2ZSBiZWVuIGV4cGxpY2l0bHkgc3BlY2lmaWVkIGluIHRoZSBzY2VuZSBkZWZpbml0aW9uXG5TY2VuZS5wcm90b3R5cGUucHJlUHJvY2Vzc1NjZW5lQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFByZS1wcm9jZXNzIHN0eWxlc1xuICAgIGZvciAodmFyIHJ1bGUgb2YgVXRpbHMucmVjdXJzZVZhbHVlcyh0aGlzLmNvbmZpZy5sYXllcnMpKSB7XG4gICAgICAgIGlmIChydWxlLnN0eWxlKSB7XG4gICAgICAgICAgICAvLyBTdHlsZXMgYXJlIHZpc2libGUgYnkgZGVmYXVsdFxuICAgICAgICAgICAgaWYgKHJ1bGUuc3R5bGUudmlzaWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBydWxlLnN0eWxlLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgb25seSBvbmUgY2FtZXJhIHNwZWNpZmllZCwgc2V0IGl0IGFzIGRlZmF1bHRcbiAgICB0aGlzLmNvbmZpZy5jYW1lcmFzID0gdGhpcy5jb25maWcuY2FtZXJhcyB8fCB7fTtcbiAgICBpZiAodGhpcy5jb25maWcuY2FtZXJhKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmNhbWVyYXMuZGVmYXVsdCA9IHRoaXMuY29uZmlnLmNhbWVyYTtcbiAgICB9XG4gICAgdmFyIGNhbWVyYV9uYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuY29uZmlnLmNhbWVyYXMpO1xuICAgIGlmIChjYW1lcmFfbmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmNhbWVyYXMuZGVmYXVsdCA9IHsgYWN0aXZlOiB0cnVlIH07XG5cbiAgICB9XG4gICAgZWxzZSBpZiAoIXRoaXMuX2FjdGl2ZV9jYW1lcmEpIHtcbiAgICAgICAgLy8gSWYgbm8gY2FtZXJhIHNldCBhcyBhY3RpdmUsIHVzZSBmaXJzdCBvbmVcbiAgICAgICAgdGhpcy5jb25maWcuY2FtZXJhc1tjYW1lcmFfbmFtZXNbMF1dLmFjdGl2ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5jb25maWcubGlnaHRzID0gdGhpcy5jb25maWcubGlnaHRzIHx8IHt9OyAvLyBlbnN1cmUgbGlnaHRzIG9iamVjdFxuXG4gICAgcmV0dXJuIFN0eWxlTWFuYWdlci5wcmVsb2FkKHRoaXMuY29uZmlnLnN0eWxlcyk7XG59O1xuXG4vLyBDYWxsZWQgKGN1cnJlbnRseSBtYW51YWxseSkgYWZ0ZXIgc3R5bGVzIGFyZSB1cGRhdGVkIGluIHN0eWxlc2hlZXRcblNjZW5lLnByb3RvdHlwZS51cGRhdGVTdHlsZXMgPSBmdW5jdGlvbiAoZ2wpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQgJiYgIXRoaXMuaW5pdGlhbGl6aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2NlbmUudXBkYXRlU3R5bGVzKCkgY2FsbGVkIGJlZm9yZSBzY2VuZSB3YXMgaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG5cbiAgICAvLyAoUmUpYnVpbGQgc3R5bGVzIGZyb20gY29uZmlnXG4gICAgU3R5bGVNYW5hZ2VyLmluaXQoKTtcbiAgICB0aGlzLnN0eWxlcyA9IFN0eWxlTWFuYWdlci5idWlsZCh0aGlzLmNvbmZpZy5zdHlsZXMpO1xuXG4gICAgLy8gT3B0aW9uYWxseSBzZXQgR0wgY29udGV4dCAodXNlZCB3aGVuIGluaXRpYWxpemluZyBvciByZS1pbml0aWFsaXppbmcgR0wgcmVzb3VyY2VzKVxuICAgIGlmIChnbCkge1xuICAgICAgICBmb3IgKHZhciBzdHlsZSBvZiBVdGlscy52YWx1ZXModGhpcy5zdHlsZXMpKSB7XG4gICAgICAgICAgICBzdHlsZS5zZXRHTChnbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb21waWxlIGFsbCBwcm9ncmFtc1xuICAgIFN0eWxlTWFuYWdlci5jb21waWxlKCk7XG5cbiAgICB0aGlzLnVwZGF0ZUFjdGl2ZVN0eWxlcygpO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufTtcblxuU2NlbmUucHJvdG90eXBlLnVwZGF0ZUFjdGl2ZVN0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBNYWtlIGEgc2V0IG9mIGN1cnJlbnRseSBhY3RpdmUgc3R5bGVzICh1c2VkIGluIGEgc3R5bGUgcnVsZSlcbiAgICAvLyBOb3RlOiBkb2Vzbid0IGFjdHVhbGx5IGNoZWNrIGlmIGFueSBnZW9tZXRyeSBtYXRjaGVzIHRoZSBydWxlLCBqdXN0IHRoYXQgdGhlIHN0eWxlIGlzIHBvdGVudGlhbGx5IHJlbmRlcmFibGVcbiAgICB0aGlzLmFjdGl2ZV9zdHlsZXMgPSB7fTtcbiAgICB2YXIgYW5pbWF0ZWQgPSBmYWxzZTsgLy8gaXMgYW55IGFjdGl2ZSBzdHlsZSBhbmltYXRlZD9cblxuICAgIGZvciAodmFyIHJ1bGUgb2YgVXRpbHMucmVjdXJzZVZhbHVlcyh0aGlzLmNvbmZpZy5sYXllcnMpKSB7XG4gICAgICAgIGlmIChydWxlLnN0eWxlICYmIHJ1bGUuc3R5bGUudmlzaWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlX3N0eWxlc1tydWxlLnN0eWxlLm5hbWUgfHwgU3R5bGVQYXJzZXIuZGVmYXVsdHMuc3R5bGUubmFtZV0gPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zdHlsZXNbcnVsZS5zdHlsZS5uYW1lIHx8IFN0eWxlUGFyc2VyLmRlZmF1bHRzLnN0eWxlLm5hbWVdLmFuaW1hdGVkKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0ZWQgPSBhbmltYXRlZDtcbn07XG5cbi8vIENyZWF0ZSBjYW1lcmFcblNjZW5lLnByb3RvdHlwZS5jcmVhdGVDYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYW1lcmEgPSBDYW1lcmEuY3JlYXRlKHRoaXMuX2FjdGl2ZV9jYW1lcmEsIHRoaXMsIHRoaXMuY29uZmlnLmNhbWVyYXNbdGhpcy5fYWN0aXZlX2NhbWVyYV0pO1xuXG4gICAgLy8gVE9ETzogcmVwbGFjZSB0aGlzIGFuZCBtb3ZlIGFsbCBwb3NpdGlvbiBpbmZvIHRvIGNhbWVyYVxuICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVNjZW5lKCk7XG59O1xuXG4vLyBHZXQgYWN0aXZlIGNhbWVyYSAtIGZvciBwdWJsaWMgQVBJXG5TY2VuZS5wcm90b3R5cGUuZ2V0QWN0aXZlQ2FtZXJhID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmVfY2FtZXJhO1xufTtcblxuLy8gU2V0IGFjdGl2ZSBjYW1lcmEgYW5kIHJlY29tcGlsZSAtIGZvciBwdWJsaWMgQVBJXG5TY2VuZS5wcm90b3R5cGUuc2V0QWN0aXZlQ2FtZXJhID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aGlzLl9hY3RpdmVfY2FtZXJhID0gbmFtZTtcbiAgICB0aGlzLnVwZGF0ZUNvbmZpZygpO1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmVfY2FtZXJhO1xufTtcblxuLy8gSW50ZXJuYWwgbWFuYWdlbWVudCBvZiBhY3RpdmUgY2FtZXJhXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NlbmUucHJvdG90eXBlLCAnX2FjdGl2ZV9jYW1lcmEnLCB7XG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMuY29uZmlnLmNhbWVyYXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5jYW1lcmFzW25hbWVdLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgcHJldiA9IHRoaXMuX2FjdGl2ZV9jYW1lcmE7XG5cbiAgICAgICAgLy8gU2V0IG5ldyBhY3RpdmUgY2FtZXJhXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5jYW1lcmFzW25hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5jYW1lcmFzW25hbWVdLmFjdGl2ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIENsZWFyIHByZXZpb3VzbHkgYWN0aXZlIGNhbWVyYVxuICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldiAhPT0gbmFtZSAmJiB0aGlzLmNvbmZpZy5jYW1lcmFzW3ByZXZdKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29uZmlnLmNhbWVyYXNbcHJldl0uYWN0aXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxuLy8gQ3JlYXRlIGxpZ2h0aW5nXG5TY2VuZS5wcm90b3R5cGUuY3JlYXRlTGlnaHRzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubGlnaHRzID0ge307XG4gICAgZm9yIChsZXQgaSBpbiB0aGlzLmNvbmZpZy5saWdodHMpIHtcbiAgICAgICAgdGhpcy5jb25maWcubGlnaHRzW2ldLm5hbWUgPSBpO1xuICAgICAgICB0aGlzLmxpZ2h0c1tpXSA9IExpZ2h0LmNyZWF0ZSh0aGlzLCB0aGlzLmNvbmZpZy5saWdodHNbaV0pO1xuICAgIH1cbiAgICBMaWdodC5pbmplY3QodGhpcy5saWdodHMpO1xufTtcblxuLy8gVXBkYXRlIHNjZW5lIGNvbmZpZ1xuU2NlbmUucHJvdG90eXBlLnVwZGF0ZUNvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNyZWF0ZUNhbWVyYSgpO1xuICAgIHRoaXMuY3JlYXRlTGlnaHRzKCk7XG4gICAgdGhpcy5sb2FkRGF0YVNvdXJjZXMoKTtcbiAgICB0aGlzLnNldFNvdXJjZU1heCgpO1xuXG4gICAgLy8gVE9ETzogZGV0ZWN0IGNoYW5nZXMgdG8gc3R5bGVzPyBhbHJlYWR5IChjdXJyZW50bHkpIG5lZWQgdG8gcmVjb21waWxlIGFueXdheSB3aGVuIGNhbWVyYSBvciBsaWdodHMgY2hhbmdlXG4gICAgdGhpcy51cGRhdGVTdHlsZXModGhpcy5nbCk7XG4gICAgdGhpcy5zeW5jQ29uZmlnVG9Xb3JrZXIoKTtcbn07XG5cbi8vIFNlcmlhbGl6ZSBjb25maWcgYW5kIHNlbmQgdG8gd29ya2VyXG5TY2VuZS5wcm90b3R5cGUuc3luY0NvbmZpZ1RvV29ya2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29uZmlnX3NlcmlhbGl6ZWQgPSBVdGlscy5zZXJpYWxpemVXaXRoRnVuY3Rpb25zKHRoaXMuY29uZmlnKTtcbiAgICB0aGlzLnNlbGVjdGlvbl9tYXBfd29ya2VyX3NpemUgPSB7fTtcbiAgICAvLyBUZWxsIHdvcmtlcnMgd2UncmUgYWJvdXQgdG8gcmVidWlsZCAoc28gdGhleSBjYW4gdXBkYXRlIHN0eWxlcywgZXRjLilcbiAgICB0aGlzLndvcmtlcnMuZm9yRWFjaCh3b3JrZXIgPT4ge1xuICAgICAgICBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2Uod29ya2VyLCAndXBkYXRlQ29uZmlnJywge1xuICAgICAgICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZ19zZXJpYWxpemVkXG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLy8gUmVzZXQgaW50ZXJuYWwgY2xvY2ssIG1vc3RseSB1c2VmdWwgZm9yIGNvbnNpc3RlbnQgZXhwZXJpZW5jZSB3aGVuIGNoYW5naW5nIHN0eWxlcy9kZWJ1Z2dpbmdcblNjZW5lLnByb3RvdHlwZS5yZXNldFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdGFydF90aW1lID0gK25ldyBEYXRlKCk7XG59O1xuXG5cbi8vIFN0YXRzL2RlYnVnL3Byb2ZpbGluZyBtZXRob2RzXG5cbi8vIFByb2ZpbGluZyBtZXRob2RzIHVzZWQgdG8gdHJhY2sgd2hlbiBzZXRzIG9mIHRpbGVzIHN0YXJ0L3N0b3AgbG9hZGluZyB0b2dldGhlclxuLy8gZS5nLiBpbml0aWFsIHBhZ2UgbG9hZCBpcyBvbmUgc2V0IG9mIHRpbGVzLCBuZXcgc2V0cyBvZiB0aWxlIGxvYWRzIGFyZSB0aGVuIGluaXRpYXRlZCBieSBhIG1hcCBwYW4gb3Igem9vbVxuU2NlbmUucHJvdG90eXBlLnRyYWNrVGlsZVNldExvYWRTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTdGFydCB0cmFja2luZyBuZXcgdGlsZSBzZXQgaWYgbm8gb3RoZXIgdGlsZXMgYWxyZWFkeSBsb2FkaW5nXG4gICAgaWYgKHRoaXMudGlsZV9zZXRfbG9hZGluZyA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMudGlsZV9zZXRfbG9hZGluZyA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICBsb2cuaW5mbygnU2NlbmU6IHRpbGUgc2V0IGxvYWQgc3RhcnQnKTtcbiAgICB9XG59O1xuXG5TY2VuZS5wcm90b3R5cGUudHJhY2tUaWxlU2V0TG9hZFN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gTm8gbW9yZSB0aWxlcyBhY3RpdmVseSBsb2FkaW5nP1xuICAgIGlmICh0aGlzLnRpbGVfc2V0X2xvYWRpbmcgIT0gbnVsbCkge1xuICAgICAgICB2YXIgZW5kX3RpbGVfc2V0ID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLnRpbGVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50aWxlc1t0XS5sb2FkaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZW5kX3RpbGVfc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kX3RpbGVfc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RfdGlsZV9zZXRfbG9hZCA9ICgrbmV3IERhdGUoKSkgLSB0aGlzLnRpbGVfc2V0X2xvYWRpbmc7XG4gICAgICAgICAgICB0aGlzLnRpbGVfc2V0X2xvYWRpbmcgPSBudWxsO1xuICAgICAgICAgICAgbG9nLmluZm8oYFNjZW5lOiB0aWxlIHNldCBsb2FkIGZpbmlzaGVkIGluICR7dGhpcy5sYXN0X3RpbGVfc2V0X2xvYWR9bXNgKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIFN1bSBvZiBhIGRlYnVnIHByb3BlcnR5IGFjcm9zcyB0aWxlc1xuU2NlbmUucHJvdG90eXBlLmdldERlYnVnU3VtID0gZnVuY3Rpb24gKHByb3AsIGZpbHRlcikge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIHQgaW4gdGhpcy50aWxlcykge1xuICAgICAgICBpZiAodGhpcy50aWxlc1t0XS5kZWJ1Z1twcm9wXSAhPSBudWxsICYmICh0eXBlb2YgZmlsdGVyICE9PSAnZnVuY3Rpb24nIHx8IGZpbHRlcih0aGlzLnRpbGVzW3RdKSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgIHN1bSArPSB0aGlzLnRpbGVzW3RdLmRlYnVnW3Byb3BdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59O1xuXG4vLyBBdmVyYWdlIG9mIGEgZGVidWcgcHJvcGVydHkgYWNyb3NzIHRpbGVzXG5TY2VuZS5wcm90b3R5cGUuZ2V0RGVidWdBdmVyYWdlID0gZnVuY3Rpb24gKHByb3AsIGZpbHRlcikge1xuICAgIHJldHVybiB0aGlzLmdldERlYnVnU3VtKHByb3AsIGZpbHRlcikgLyBPYmplY3Qua2V5cyh0aGlzLnRpbGVzKS5sZW5ndGg7XG59O1xuXG4vLyBMb2cgbWVzc2FnZXMgcGFzcyB0aHJvdWdoIGZyb20gd2ViIHdvcmtlcnNcblNjZW5lLnByb3RvdHlwZS53b3JrZXJMb2dNZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmRhdGEudHlwZSAhPT0gJ2xvZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB7IHdvcmtlcl9pZCwgbGV2ZWwsIG1zZyB9ID0gZXZlbnQuZGF0YTtcblxuICAgIGlmIChsb2dbbGV2ZWxdKSB7XG4gICAgICAgIGxvZ1tsZXZlbF0oYHdvcmtlciAke3dvcmtlcl9pZH06YCwgIC4uLm1zZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsb2cuZXJyb3IoYFNjZW5lLndvcmtlckxvZ01lc3NhZ2U6IHVucmVjb2duaXplZCBsb2cgbGV2ZWwgJHtsZXZlbH1gKTtcbiAgICB9XG59O1xuXG4vLyBQcm9maWxlIGhlbHBlcnMsIGlzc3VlcyBhIHByb2ZpbGUgb24gbWFpbiB0aHJlYWQgJiBhbGwgd29ya2Vyc1xuU2NlbmUucHJvdG90eXBlLl9wcm9maWxlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBjb25zb2xlLnByb2ZpbGUoYG1haW4gdGhyZWFkOiAke25hbWV9YCk7XG4gICAgdGhpcy53b3JrZXJzLmZvckVhY2godyA9PiBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UodywgJ3Byb2ZpbGUnLCBuYW1lKSk7XG59O1xuXG5TY2VuZS5wcm90b3R5cGUuX3Byb2ZpbGVFbmQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGNvbnNvbGUucHJvZmlsZUVuZChgbWFpbiB0aHJlYWQ6ICR7bmFtZX1gKTtcbiAgICB0aGlzLndvcmtlcnMuZm9yRWFjaCh3ID0+IFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSh3LCAncHJvZmlsZUVuZCcsIG5hbWUpKTtcbn07XG4iLCIvKmpzaGludCB3b3JrZXI6IHRydWUqL1xuaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IFdvcmtlckJyb2tlciBmcm9tICcuL3V0aWxzL3dvcmtlcl9icm9rZXInOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbmltcG9ydCBTY2VuZSAgZnJvbSAnLi9zY2VuZSc7XG5pbXBvcnQgVGlsZSBmcm9tICcuL3RpbGUnO1xuaW1wb3J0IFRpbGVTb3VyY2UgZnJvbSAnLi90aWxlX3NvdXJjZS5qcyc7XG5pbXBvcnQgRmVhdHVyZVNlbGVjdGlvbiBmcm9tICcuL3NlbGVjdGlvbic7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9wYXJzZXInO1xuaW1wb3J0IHtTdHlsZU1hbmFnZXJ9IGZyb20gJy4vc3R5bGVzL3N0eWxlX21hbmFnZXInO1xuaW1wb3J0IHtwYXJzZVJ1bGVzfSBmcm9tICcuL3N0eWxlcy9ydWxlJztcbmltcG9ydCBCdWlsZGVycyBmcm9tICcuL3N0eWxlcy9idWlsZGVycyc7XG5pbXBvcnQgVGV4dHVyZSBmcm9tICcuL2dsL3RleHR1cmUnO1xuXG5leHBvcnQgdmFyIFNjZW5lV29ya2VyID0ge1xuICAgIHNvdXJjZXM6IHt9LFxuICAgIHN0eWxlczoge30sXG4gICAgcnVsZXM6IHt9LFxuICAgIGxheWVyczoge30sXG4gICAgdGlsZXM6IHt9LFxuICAgIGNvbmZpZzoge31cbn07XG5cbi8vIFdvcmtlciBmdW5jdGlvbmFsaXR5IHdpbGwgb25seSBiZSBkZWZpbmVkIGluIHdvcmtlciB0aHJlYWRcblxuaWYgKFV0aWxzLmlzV29ya2VyVGhyZWFkKSB7XG5cbiAgICBTY2VuZVdvcmtlci53b3JrZXIgPSBzZWxmO1xuXG4gICAgLy8gVE9ETzogc3luYyByZW5kZXIgc3R5bGUgc3RhdGUgYmV0d2VlbiBtYWluIHRocmVhZCBhbmQgd29ya2VyXG4gICAgQnVpbGRlcnMuc2V0VGlsZVNjYWxlKFNjZW5lLnRpbGVfc2NhbGUpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB3b3JrZXJcbiAgICBTY2VuZVdvcmtlci53b3JrZXIuaW5pdCA9IGZ1bmN0aW9uICh3b3JrZXJfaWQpIHtcbiAgICAgICAgU2NlbmVXb3JrZXIud29ya2VyX2lkID0gd29ya2VyX2lkO1xuICAgICAgICBGZWF0dXJlU2VsZWN0aW9uLnNldFByZWZpeChTY2VuZVdvcmtlci53b3JrZXJfaWQpO1xuICAgICAgICByZXR1cm4gd29ya2VyX2lkO1xuICAgIH07XG5cbiAgICAvLyBTdGFydHMgYSBjb25maWcgcmVmcmVzaFxuICAgIFNjZW5lV29ya2VyLndvcmtlci51cGRhdGVDb25maWcgPSBmdW5jdGlvbiAoeyBjb25maWcgfSkge1xuICAgICAgICBTY2VuZVdvcmtlci5jb25maWcgPSBudWxsO1xuICAgICAgICBTY2VuZVdvcmtlci5zdHlsZXMgPSBudWxsO1xuICAgICAgICBGZWF0dXJlU2VsZWN0aW9uLnJlc2V0KCk7XG4gICAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UoY29uZmlnKTtcblxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGNvbmZpZy5zb3VyY2VzKSB7XG4gICAgICAgICAgICBsZXQgc291cmNlID0gY29uZmlnLnNvdXJjZXNbbmFtZV07XG4gICAgICAgICAgICBTY2VuZVdvcmtlci5zb3VyY2VzW25hbWVdID0gVGlsZVNvdXJjZS5jcmVhdGUoT2JqZWN0LmFzc2lnbihzb3VyY2UsIHtuYW1lfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VvbWV0cnkgYmxvY2sgZnVuY3Rpb25zIGFyZSBub3QgbWFjcm8nZWQgYW5kIHdyYXBwZWQgbGlrZSB0aGUgcmVzdCBvZiB0aGUgc3R5bGUgZnVuY3Rpb25zIGFyZVxuICAgICAgICAvLyBUT0RPOiBwcm9iYWJseSB3YW50IGEgY2xlYW5lciB3YXkgdG8gZXhjbHVkZSB0aGVzZVxuICAgICAgICBmb3IgKHZhciBsYXllciBpbiBjb25maWcubGF5ZXJzKSB7XG4gICAgICAgICAgICBjb25maWcubGF5ZXJzW2xheWVyXS5nZW9tZXRyeSA9IFV0aWxzLnN0cmluZ3NUb0Z1bmN0aW9ucyhjb25maWcubGF5ZXJzW2xheWVyXS5nZW9tZXRyeSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeHBhbmQgc3R5bGVzXG4gICAgICAgIFNjZW5lV29ya2VyLmNvbmZpZyA9IFV0aWxzLnN0cmluZ3NUb0Z1bmN0aW9ucyhTdHlsZVBhcnNlci5leHBhbmRNYWNyb3MoY29uZmlnKSwgU3R5bGVQYXJzZXIud3JhcEZ1bmN0aW9uKTtcbiAgICAgICAgU2NlbmVXb3JrZXIuc3R5bGVzID0gU3R5bGVNYW5hZ2VyLmJ1aWxkKFNjZW5lV29ya2VyLmNvbmZpZy5zdHlsZXMpO1xuXG4gICAgICAgIC8vIFBhcnNlIGVhY2ggdG9wLWxldmVsIGxheWVyIGFzIGEgc2VwYXJhdGUgcnVsZSB0cmVlXG4gICAgICAgIC8vIFRPRE86IGZpbmQgYSBtb3JlIGdyYWNlZnVsIHdheSB0byBpbmNvcnBvcmF0ZSB0aGlzXG5cbiAgICAgICAgU2NlbmVXb3JrZXIucnVsZXMgPSAgcGFyc2VSdWxlcyhTY2VuZVdvcmtlci5jb25maWcubGF5ZXJzKTtcblxuICAgICAgICAvLyBTeW5jIHRldHh1cmUgaW5mbyBmcm9tIG1haW4gdGhyZWFkXG4gICAgICAgIFNjZW5lV29ya2VyLnN5bmNpbmdfdGV4dHVyZXMgPSBTY2VuZVdvcmtlci5zeW5jVGV4dHVyZXMoKTtcblxuICAgICAgICAvLyBSZXR1cm4gcHJvbWlzZSBmb3Igd2hlbiBjb25maWcgcmVmcmVzaCBmaW5pc2hlc1xuICAgICAgICBTY2VuZVdvcmtlci5jb25maWd1cmluZyA9IFNjZW5lV29ya2VyLnN5bmNpbmdfdGV4dHVyZXMudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBTY2VuZVdvcmtlci5sb2coJ2RlYnVnJywgYHVwZGF0ZWQgY29uZmlnYCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdoZW4gY29uZmlnIHJlZnJlc2ggaXMgZmluaXNoZWRcbiAgICBTY2VuZVdvcmtlci5hd2FpdENvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBTY2VuZVdvcmtlci5jb25maWd1cmluZztcbiAgICB9O1xuXG4gICAgLy8gU2xpY2UgYSBzdWJzZXQgb2Yga2V5cyBvdXQgb2YgYSB0aWxlXG4gICAgLy8gSW5jbHVkZXMgYSBtaW5pbXVtIHNldCBvZiBwcmUtZGVmaW5lZCBrZXlzIGZvciBsb2FkIHN0YXRlLCBkZWJ1Zy4gZXRjLlxuICAgIC8vIFdlIHVzZSB0aGlzIHRvIHNlbmQgYSBzdWJzZXQgb2YgdGhlIHRpbGUgYmFjayB0byB0aGUgbWFpbiB0aHJlYWQsIHRvIG1pbmltaXplIHVubmVjZXNzYXJ5IGRhdGEgdHJhbnNmZXJcbiAgICAvLyAoZS5nLiB2ZXJ5IGxhcmdlIGl0ZW1zIGxpa2UgZmVhdHVyZSBnZW9tZXRyeSBhcmUgbm90IG5lZWRlZCBvbiB0aGUgbWFpbiB0aHJlYWQpXG4gICAgU2NlbmVXb3JrZXIuc2xpY2VUaWxlID0gZnVuY3Rpb24gKHRpbGUsIGtleXMpIHtcbiAgICAgICAga2V5cyA9IGtleXMgfHwge307XG4gICAgICAgIGtleXMua2V5ID0gdHJ1ZTtcbiAgICAgICAga2V5cy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAga2V5cy5sb2FkZWQgPSB0cnVlO1xuICAgICAgICBrZXlzLm9yZGVyID0gdHJ1ZTtcbiAgICAgICAga2V5cy5lcnJvciA9IHRydWU7XG4gICAgICAgIGtleXMuZGVidWcgPSB0cnVlO1xuXG4gICAgICAgIC8vIEJ1aWxkIHRoZSB0aWxlIHN1YnNldFxuICAgICAgICB2YXIgdGlsZV9zdWJzZXQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBrZXlzKSB7XG4gICAgICAgICAgICB0aWxlX3N1YnNldFtrXSA9IHRpbGVba107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGlsZV9zdWJzZXQ7XG4gICAgfTtcblxuICAgIC8vIEJ1aWxkIGEgdGlsZTogbG9hZCBmcm9tIHRpbGUgc291cmNlIGlmIGJ1aWxkaW5nIGZvciBmaXJzdCB0aW1lLCBvdGhlcndpc2UgcmVidWlsZCB3aXRoIGV4aXN0aW5nIGRhdGFcbiAgICBTY2VuZVdvcmtlci53b3JrZXIuYnVpbGRUaWxlID0gZnVuY3Rpb24gKHsgdGlsZSB9KSB7XG4gICAgICAgIC8vIFRpbGUgY2FjaGVkP1xuICAgICAgICBpZiAoU2NlbmVXb3JrZXIudGlsZXNbdGlsZS5rZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEFscmVhZHkgbG9hZGluZz9cbiAgICAgICAgICAgIGlmIChTY2VuZVdvcmtlci50aWxlc1t0aWxlLmtleV0ubG9hZGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aWxlIGNhY2hlXG4gICAgICAgIHRpbGUgPSBTY2VuZVdvcmtlci50aWxlc1t0aWxlLmtleV0gPSBPYmplY3QuYXNzaWduKFNjZW5lV29ya2VyLnRpbGVzW3RpbGUua2V5XSB8fCB7fSwgdGlsZSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGNvbmZpZyAoc3R5bGVzLCBldGMuKSwgdGhlbiBidWlsZCB0aWxlXG4gICAgICAgIHJldHVybiBTY2VuZVdvcmtlci5hd2FpdENvbmZpZ3VyYXRpb24oKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEZpcnN0IHRpbWUgYnVpbGRpbmcgdGhlIHRpbGVcbiAgICAgICAgICAgIGlmICh0aWxlLmxvYWRlZCAhPT0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICB0aWxlLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aWxlLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aWxlLmVycm9yID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChPYmplY3Qua2V5cyhTY2VuZVdvcmtlci5zb3VyY2VzKS5tYXAoeCA9PiBTY2VuZVdvcmtlci5zb3VyY2VzW3hdLmxvYWRUaWxlKHRpbGUpKSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGUubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhciBrZXlzID0gVGlsZS5idWlsZEdlb21ldHJ5KHRpbGUsIFNjZW5lV29ya2VyLmNvbmZpZy5sYXllcnMsIFNjZW5lV29ya2VyLnJ1bGVzLCBTY2VuZVdvcmtlci5zdHlsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgVGlsZS5idWlsZEdlb21ldHJ5KHRpbGUsIFNjZW5lV29ya2VyLmNvbmZpZy5sYXllcnMsIFNjZW5lV29ya2VyLnJ1bGVzLCBTY2VuZVdvcmtlci5zdHlsZXMpLnRoZW4oa2V5cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGU6IFNjZW5lV29ya2VyLnNsaWNlVGlsZSh0aWxlLCBrZXlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VyX2lkOiBTY2VuZVdvcmtlci53b3JrZXJfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbl9tYXBfc2l6ZTogRmVhdHVyZVNlbGVjdGlvbi5tYXBfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZS5lcnJvciA9IGVycm9yLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBTY2VuZVdvcmtlci5sb2coJ2Vycm9yJywgYHRpbGUgbG9hZCBlcnJvciBmb3IgJHt0aWxlLmtleX06ICR7ZXJyb3Iuc3RhY2t9YCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGU6IFNjZW5lV29ya2VyLnNsaWNlVGlsZSh0aWxlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXJfaWQ6IFNjZW5lV29ya2VyLndvcmtlcl9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25fbWFwX3NpemU6IEZlYXR1cmVTZWxlY3Rpb24ubWFwX3NpemVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRpbGUgYWxyZWFkeSBsb2FkZWQsIGp1c3QgcmVidWlsZFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgU2NlbmVXb3JrZXIubG9nKCd0cmFjZScsIGB1c2VkIHdvcmtlciBjYWNoZSBmb3IgdGlsZSAke3RpbGUua2V5fWApO1xuXG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgZ2VvbWV0cnlcbiAgICAgICAgICAgICAgICAvLyB2YXIga2V5cyA9IFRpbGUuYnVpbGRHZW9tZXRyeSh0aWxlLCBTY2VuZVdvcmtlci5jb25maWcubGF5ZXJzLCBTY2VuZVdvcmtlci5ydWxlcywgU2NlbmVXb3JrZXIuc3R5bGVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gVGlsZS5idWlsZEdlb21ldHJ5KHRpbGUsIFNjZW5lV29ya2VyLmNvbmZpZy5sYXllcnMsIFNjZW5lV29ya2VyLnJ1bGVzLCBTY2VuZVdvcmtlci5zdHlsZXMpLnRoZW4oa2V5cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlOiBTY2VuZVdvcmtlci5zbGljZVRpbGUodGlsZSwga2V5cyksXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXJfaWQ6IFNjZW5lV29ya2VyLndvcmtlcl9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbl9tYXBfc2l6ZTogRmVhdHVyZVNlbGVjdGlvbi5tYXBfc2l6ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gUmVtb3ZlIHRpbGVcbiAgICBTY2VuZVdvcmtlci53b3JrZXIucmVtb3ZlVGlsZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHRpbGUgPSBTY2VuZVdvcmtlci50aWxlc1trZXldO1xuXG4gICAgICAgIGlmICh0aWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENhbmNlbCBpZiBsb2FkaW5nXG4gICAgICAgICAgICBpZiAodGlsZS5sb2FkaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgU2NlbmVXb3JrZXIubG9nKCd0cmFjZScsIGBjYW5jZWwgdGlsZSBsb2FkIGZvciAke2tleX1gKTtcbiAgICAgICAgICAgICAgICB0aWxlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRpbGUucmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHRpbGUucmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBjYWNoZVxuICAgICAgICAgICAgZGVsZXRlIFNjZW5lV29ya2VyLnRpbGVzW2tleV07XG4gICAgICAgICAgICBTY2VuZVdvcmtlci5sb2coJ3RyYWNlJywgYHJlbW92ZSB0aWxlIGZyb20gY2FjaGUgZm9yICR7a2V5fWApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEdldCBhIGZlYXR1cmUgZnJvbSB0aGUgc2VsZWN0aW9uIG1hcFxuICAgIFNjZW5lV29ya2VyLndvcmtlci5nZXRGZWF0dXJlU2VsZWN0aW9uID0gZnVuY3Rpb24gKHsgaWQsIGtleSB9ID0ge30pIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IEZlYXR1cmVTZWxlY3Rpb24ubWFwW2tleV07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGZlYXR1cmU6IChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmZlYXR1cmUpXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIFRleHR1cmUgaW5mbyBuZWVkcyB0byBiZSBzeW5jZWQgZnJvbSBtYWluIHRocmVhZFxuICAgIFNjZW5lV29ya2VyLnN5bmNUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gV2UncmUgb25seSBzeW5jaW5nIHRoZSB0ZXh0dXJlcyB0aGF0IGhhdmUgc3ByaXRlcyBkZWZpbmVkLCBzaW5jZSB0aGVzZSBhcmUgKGN1cnJlbnRseSkgdGhlIG9ubHkgb25lcyB3ZVxuICAgICAgICAvLyBuZWVkIGluZm8gYWJvdXQgZm9yIGdlb21ldHJ5IGNvbnN0cnVjdGlvbiAod2UgbmVlZCB3aWR0aC9oZWlnaHQsIHdoaWNoIHdlIG9ubHkga25vdyBhZnRlciB0aGUgdGV4dHVyZSBsb2FkcylcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBhc3luYyBwcm9jZXNzLCBzbyBpdCByZXR1cm5zIGEgcHJvbWlzZVxuICAgICAgICB2YXIgdGV4dHVyZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgc3R5bGUgb2YgVXRpbHMudmFsdWVzKFNjZW5lV29ya2VyLnN0eWxlcykpIHtcbiAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0dXJlcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHQgaW4gc3R5bGUudGV4dHVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlLnRleHR1cmVzW3RdLnNwcml0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVzLnB1c2goc3R5bGUudGV4dHVyZU5hbWUodCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgU2NlbmVXb3JrZXIubG9nKCd0cmFjZScsICdzeW5jIHRleHR1cmVzIHRvIHdvcmtlcjonLCB0ZXh0dXJlcyk7XG4gICAgICAgIGlmICh0ZXh0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gVGV4dHVyZS5zeW5jVGV4dHVyZXNUb1dvcmtlcih0ZXh0dXJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG5cbiAgICAvLyBMb2cgd3JhcHBlciwgc2VuZHMgbWVzc2FnZSB0byBtYWluIHRocmVhZCBmb3IgZGlzcGxheSwgYW5kIGluY2x1ZGVzIHdvcmtlciBpZCAjXG4gICAgU2NlbmVXb3JrZXIubG9nID0gZnVuY3Rpb24gKGxldmVsLCAuLi5tc2cpIHtcbiAgICAgICAgU2NlbmVXb3JrZXIud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdsb2cnLFxuICAgICAgICAgICAgbGV2ZWw6IGxldmVsIHx8ICdpbmZvJyxcbiAgICAgICAgICAgIHdvcmtlcl9pZDogU2NlbmVXb3JrZXIud29ya2VyX2lkLFxuICAgICAgICAgICAgbXNnOiBtc2dcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFByb2ZpbGluZyBoZWxwZXJzXG4gICAgU2NlbmVXb3JrZXIud29ya2VyLnByb2ZpbGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBjb25zb2xlLnByb2ZpbGUoYHdvcmtlciAke1NjZW5lV29ya2VyLndvcmtlcl9pZH06ICR7bmFtZX1gKTtcbiAgICB9O1xuXG4gICAgU2NlbmVXb3JrZXIud29ya2VyLnByb2ZpbGVFbmQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBjb25zb2xlLnByb2ZpbGVFbmQoYHdvcmtlciAke1NjZW5lV29ya2VyLndvcmtlcl9pZH06ICR7bmFtZX1gKTtcbiAgICB9O1xuXG59XG4iLCJpbXBvcnQgVGV4dHVyZSBmcm9tICcuL2dsL3RleHR1cmUnO1xuaW1wb3J0IFdvcmtlckJyb2tlciBmcm9tICcuL3V0aWxzL3dvcmtlcl9icm9rZXInO1xuXG5jbGFzcyBGZWF0dXJlU2VsZWN0aW9uIHtcblxuICAgIGNvbnN0cnVjdG9yKGdsLCB3b3JrZXJzKSB7XG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgdGhpcy53b3JrZXJzID0gd29ya2VyczsgLy8gcG9vbCBvZiB3b3JrZXJzIHRvIHJlcXVlc3QgZmVhdHVyZSBsb29rLXVwcyBmcm9tLCBrZXllZCBieSBpZFxuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG5cbiAgICBpbml0KCkge1xuICAgICAgICAvLyBTZWxlY3Rpb24gc3RhdGUgdHJhY2tpbmdcbiAgICAgICAgdGhpcy5yZXF1ZXN0cyA9IHt9OyAvLyBwZW5kaW5nIHNlbGVjdGlvbiByZXF1ZXN0c1xuICAgICAgICB0aGlzLmZlYXR1cmUgPSBudWxsOyAvLyBjdXJyZW50bHkgc2VsZWN0ZWQgZmVhdHVyZVxuICAgICAgICB0aGlzLnJlYWRfZGVsYXkgPSA1OyAvLyBkZWxheSB0aW1lIGZyb20gc2VsZWN0aW9uIHJlbmRlciB0byBmcmFtZWJ1ZmZlciBzYW1wbGUsIHRvIGF2b2lkIENQVS9HUFUgc3luYyBsb2NrXG4gICAgICAgIHRoaXMucmVhZF9kZWxheV90aW1lciA9IG51bGw7IC8vIGN1cnJlbnQgdGltZXIgKHNldFRpbWVvdXQpIGZvciBkZWxheWVkIHNlbGVjdGlvbiByZWFkc1xuXG4gICAgICAgIHRoaXMucGl4ZWwgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgdGhpcy5waXhlbDMyID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnBpeGVsLmJ1ZmZlcik7XG5cbiAgICAgICAgLy8gRnJhbWUgYnVmZmVyIGZvciBzZWxlY3Rpb25cbiAgICAgICAgLy8gVE9ETzogaW5pdGlhdGUgbGF6aWx5IGluIGNhc2Ugd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnkgc2VsZWN0aW9uXG4gICAgICAgIHRoaXMuZmJvID0gdGhpcy5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgICB0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLmdsLkZSQU1FQlVGRkVSLCB0aGlzLmZibyk7XG4gICAgICAgIHRoaXMuZmJvX3NpemUgPSB7IHdpZHRoOiAyNTYsIGhlaWdodDogMjU2IH07IC8vIFRPRE86IG1ha2UgY29uZmlndXJhYmxlIC8gYWRhcHRpdmUgYmFzZWQgb24gY2FudmFzIHNpemVcbiAgICAgICAgdGhpcy5mYm9fc2l6ZS5hc3BlY3QgPSB0aGlzLmZib19zaXplLndpZHRoIC8gdGhpcy5mYm9fc2l6ZS5oZWlnaHQ7XG5cbiAgICAgICAgLy8gVGV4dHVyZSBmb3IgdGhlIEZCTyBjb2xvciBhdHRhY2htZW50XG4gICAgICAgIHZhciBmYm9fdGV4dHVyZSA9IG5ldyBUZXh0dXJlKHRoaXMuZ2wsICdzZWxlY3Rpb25fZmJvJyk7XG4gICAgICAgIGZib190ZXh0dXJlLnNldERhdGEodGhpcy5mYm9fc2l6ZS53aWR0aCwgdGhpcy5mYm9fc2l6ZS5oZWlnaHQsIG51bGwsIHsgZmlsdGVyaW5nOiAnbmVhcmVzdCcgfSk7XG4gICAgICAgIHRoaXMuZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQodGhpcy5nbC5GUkFNRUJVRkZFUiwgdGhpcy5nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgdGhpcy5nbC5URVhUVVJFXzJELCBmYm9fdGV4dHVyZS50ZXh0dXJlLCAwKTtcblxuICAgICAgICAvLyBSZW5kZXJidWZmZXIgZm9yIHRoZSBGQk8gZGVwdGggYXR0YWNobWVudFxuICAgICAgICB2YXIgZmJvX2RlcHRoX3JiID0gdGhpcy5nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgICAgdGhpcy5nbC5iaW5kUmVuZGVyYnVmZmVyKHRoaXMuZ2wuUkVOREVSQlVGRkVSLCBmYm9fZGVwdGhfcmIpO1xuICAgICAgICB0aGlzLmdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UodGhpcy5nbC5SRU5ERVJCVUZGRVIsIHRoaXMuZ2wuREVQVEhfQ09NUE9ORU5UMTYsIHRoaXMuZmJvX3NpemUud2lkdGgsIHRoaXMuZmJvX3NpemUuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcih0aGlzLmdsLkZSQU1FQlVGRkVSLCB0aGlzLmdsLkRFUFRIX0FUVEFDSE1FTlQsIHRoaXMuZ2wuUkVOREVSQlVGRkVSLCBmYm9fZGVwdGhfcmIpO1xuXG4gICAgICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIH1cblxuICAgIGJpbmQoKSB7XG4gICAgICAgIC8vIFN3aXRjaCB0byBGQk9cbiAgICAgICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgdGhpcy5mYm8pO1xuICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuZmJvX3NpemUud2lkdGgsIHRoaXMuZmJvX3NpemUuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvLyBSZXF1ZXN0IGZlYXR1cmUgc2VsZWN0aW9uXG4gICAgLy8gUnVucyBhc3luY2hyb25vdXNseSwgc2NoZWR1bGVzIHNlbGVjdGlvbiBidWZmZXIgdG8gYmUgdXBkYXRlZFxuICAgIGdldEZlYXR1cmVBdChwb2ludCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gUXVldWUgcmVxdWVzdHMgZm9yIGZlYXR1cmUgc2VsZWN0aW9uLCBhbmQgdGhleSB3aWxsIGJlIHBpY2tlZCB1cCBieSB0aGUgcmVuZGVyIGxvb3BcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uX3JlcXVlc3RfaWQgPSAodGhpcy5zZWxlY3Rpb25fcmVxdWVzdF9pZCArIDEpIHx8IDA7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RzW3RoaXMuc2VsZWN0aW9uX3JlcXVlc3RfaWRdID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdwb2ludCcsXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuc2VsZWN0aW9uX3JlcXVlc3RfaWQsXG4gICAgICAgICAgICAgICAgcG9pbnQsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQW55IHBlbmRpbmcgc2VsZWN0aW9uIHJlcXVlc3RzXG4gICAgcGVuZGluZ1JlcXVlc3RzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0cztcbiAgICB9XG5cbiAgICAvLyBSZWFkIHBlbmRpbmcgcmVzdWx0cyBmcm9tIHRoZSBzZWxlY3Rpb24gYnVmZmVyLiBDYWxsZWQgYWZ0ZXIgcmVuZGVyaW5nIHRvIHNlbGVjdGlvbiBidWZmZXIuXG4gICAgcmVhZCgpIHtcbiAgICAgICAgLy8gRGVsYXkgcmVhZGluZyB0aGUgcGl4ZWwgcmVzdWx0IGZyb20gdGhlIHNlbGVjdGlvbiBidWZmZXIgdG8gYXZvaWQgQ1BVL0dQVSBzeW5jIGxvY2suXG4gICAgICAgIC8vIENhbGxpbmcgcmVhZFBpeGVscyBzeW5jaHJvbm91c2x5IGNhdXNlZCBhIG1hc3NpdmUgcGVyZm9ybWFuY2UgaGl0LCBwcmVzdW1hYmx5IHNpbmNlIGl0XG4gICAgICAgIC8vIGZvcmNlZCB0aGlzIGZ1bmN0aW9uIHRvIHdhaXQgZm9yIHRoZSBHUFUgdG8gZmluaXNoIHJlbmRlcmluZyBhbmQgcmV0cmlldmUgdGhlIHRleHR1cmUgY29udGVudHMuXG4gICAgICAgIGlmICh0aGlzLnJlYWRfZGVsYXlfdGltZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVhZF9kZWxheV90aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFkX2RlbGF5X3RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZmJvKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgciBpbiB0aGlzLnJlcXVlc3RzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzW3JdO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyByZXF1ZXN0IHdhcyBhbHJlYWR5IHNlbnQgdG8gdGhlIHdvcmtlciwgd2UncmUganVzdCBhd2FpdGluZyBpdHMgcmVwbHlcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHN1cHBvcnQgb3RoZXIgc2VsZWN0aW9uIHR5cGVzLCBzdWNoIGFzIGZlYXR1cmVzIHdpdGhpbiBhIGJveFxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnR5cGUgIT09ICdwb2ludCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgc2VsZWN0aW9uIG1hcCBhZ2FpbnN0IEZCT1xuICAgICAgICAgICAgICAgIGdsLnJlYWRQaXhlbHMoXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IocmVxdWVzdC5wb2ludC54ICogdGhpcy5mYm9fc2l6ZS53aWR0aCksXG4gICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKDEgLSByZXF1ZXN0LnBvaW50LnkpICogdGhpcy5mYm9fc2l6ZS5oZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgICAxLCAxLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLnBpeGVsKTtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZV9rZXkgPSAodGhpcy5waXhlbFswXSArICh0aGlzLnBpeGVsWzFdIDw8IDgpICsgKHRoaXMucGl4ZWxbMl0gPDwgMTYpICsgKHRoaXMucGl4ZWxbM10gPDwgMjQpKSA+Pj4gMDtcblxuICAgICAgICAgICAgICAgIC8vIElmIGZlYXR1cmUgZm91bmQsIGFzayBhcHByb3ByaWF0ZSB3ZWIgd29ya2VyIHRvIGxvb2t1cCBmZWF0dXJlXG4gICAgICAgICAgICAgICAgdmFyIHdvcmtlcl9pZCA9IHRoaXMucGl4ZWxbM107XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtlcl9pZCAhPT0gMjU1KSB7IC8vIDI1NSBpbmRpY2F0ZXMgYW4gZW1wdHkgc2VsZWN0aW9uIGJ1ZmZlciBwaXhlbFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy53b3JrZXJzW3dvcmtlcl9pZF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud29ya2Vyc1t3b3JrZXJfaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdnZXRGZWF0dXJlU2VsZWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGlkOiByZXF1ZXN0LmlkLCBrZXk6IGZlYXR1cmVfa2V5IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaFJlYWQobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBObyBmZWF0dXJlIGZvdW5kLCBidXQgc3RpbGwgbmVlZCB0byByZXNvbHZlIHByb21pc2VcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5pc2hSZWFkKHsgaWQ6IHJlcXVlc3QuaWQsIGZlYXR1cmU6IG51bGwgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuICAgICAgICB9LCB0aGlzLnJlYWRfZGVsYXkpO1xuICAgIH1cblxuICAgIC8vIENhbGxlZCBvbiBtYWluIHRocmVhZCB3aGVuIGEgd2ViIHdvcmtlciBmaW5kcyBhIGZlYXR1cmUgaW4gdGhlIHNlbGVjdGlvbiBidWZmZXJcbiAgICBmaW5pc2hSZWFkIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0c1ttZXNzYWdlLmlkXTtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGZWF0dXJlU2VsZWN0aW9uLmZpbmlzaFJlYWQoKSBjYWxsZWQgd2l0aG91dCBhbnkgbWVzc2FnZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmZWF0dXJlID0gbWVzc2FnZS5mZWF0dXJlO1xuICAgICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoKGZlYXR1cmUgIT0gbnVsbCAmJiB0aGlzLmZlYXR1cmUgPT0gbnVsbCkgfHxcbiAgICAgICAgICAgIChmZWF0dXJlID09IG51bGwgJiYgdGhpcy5mZWF0dXJlICE9IG51bGwpIHx8XG4gICAgICAgICAgICAoZmVhdHVyZSAhPSBudWxsICYmIHRoaXMuZmVhdHVyZSAhPSBudWxsICYmIGZlYXR1cmUuaWQgIT09IHRoaXMuZmVhdHVyZS5pZCkpIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mZWF0dXJlID0gZmVhdHVyZTsgLy8gc3RvcmUgdGhlIG1vc3QgcmVjZW50bHkgc2VsZWN0ZWQgZmVhdHVyZVxuXG4gICAgICAgIC8vIFJlc29sdmUgdGhlIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdC5yZXNvbHZlKHsgZmVhdHVyZSwgY2hhbmdlZCwgcmVxdWVzdCB9KTtcbiAgICAgICAgZGVsZXRlIHRoaXMucmVxdWVzdHNbbWVzc2FnZS5pZF07IC8vIGRvbmUgcHJvY2Vzc2luZyB0aGlzIHJlcXVlc3RcbiAgICB9XG5cblxuICAgIC8vIFNlbGVjdGlvbiBtYXAgZ2VuZXJhdGlvblxuICAgIC8vIEVhY2ggd29ya2VyIHdpbGwgY3JlYXRlIGl0cyBvd24gaW5kZXBlbmRlbnQsICdsb2NhbCcgc2VsZWN0aW9uIG1hcFxuXG4gICAgLy8gQ3JlYXRlIGEgdW5pcXVlIDMyLWJpdCBjb2xvciB0byBpZGVudGlmeSBhIGZlYXR1cmVcbiAgICAvLyBXb3JrZXJzIGluZGVwZW5kZW50bHkgY3JlYXRlL21vZGlmeSBzZWxlY3Rpb24gY29sb3JzIGluIHRoZWlyIG93biB0aHJlYWRzLCBidXQgd2UgYWxzb1xuICAgIC8vIG5lZWQgdGhlIG1haW4gdGhyZWFkIHRvIGtub3cgd2hlcmUgZWFjaCBmZWF0dXJlIGNvbG9yIG9yaWdpbmF0ZWQuIFRvIGFjY29tcGxpc2ggdGhpcyxcbiAgICAvLyB3ZSBwYXJ0aXRpb24gdGhlIG1hcCBieSBzZXR0aW5nIHRoZSA0dGggY29tcG9uZW50IChhbHBoYSBjaGFubmVsKSB0byB0aGUgd29ya2VyJ3MgaWQuXG4gICAgc3RhdGljIG1ha2VFbnRyeSgpIHtcbiAgICAgICAgLy8gMzItYml0IGNvbG9yIGtleVxuICAgICAgICB0aGlzLm1hcF9zaXplKys7XG4gICAgICAgIHZhciBpciA9IHRoaXMubWFwX3NpemUgJiAyNTU7XG4gICAgICAgIHZhciBpZyA9ICh0aGlzLm1hcF9zaXplID4+IDgpICYgMjU1O1xuICAgICAgICB2YXIgaWIgPSAodGhpcy5tYXBfc2l6ZSA+PiAxNikgJiAyNTU7XG4gICAgICAgIHZhciBpYSA9IHRoaXMubWFwX3ByZWZpeDtcbiAgICAgICAgdmFyIHIgPSBpciAvIDI1NTtcbiAgICAgICAgdmFyIGcgPSBpZyAvIDI1NTtcbiAgICAgICAgdmFyIGIgPSBpYiAvIDI1NTtcbiAgICAgICAgdmFyIGEgPSBpYSAvIDI1NTtcbiAgICAgICAgdmFyIGtleSA9IChpciArIChpZyA8PCA4KSArIChpYiA8PCAxNikgKyAoaWEgPDwgMjQpKSA+Pj4gMDsgLy8gbmVlZCB1bnNpZ25lZCByaWdodCBzaGlmdCB0byBjb252ZXJ0IHRvIHBvc2l0aXZlICNcblxuICAgICAgICB0aGlzLm1hcFtrZXldID0ge1xuICAgICAgICAgICAgY29sb3I6IFtyLCBnLCBiLCBhXSxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5tYXBba2V5XTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbWFrZUNvbG9yKGZlYXR1cmUpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdGhpcy5tYWtlRW50cnkoKTtcbiAgICAgICAgc2VsZWN0b3IuZmVhdHVyZSA9IHtcbiAgICAgICAgICAgIGlkOiBmZWF0dXJlLmlkLFxuICAgICAgICAgICAgcHJvcGVydGllczogZmVhdHVyZS5wcm9wZXJ0aWVzXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLmNvbG9yO1xuICAgIH1cblxuICAgIHN0YXRpYyByZXNldCgpIHtcbiAgICAgICAgdGhpcy5tYXAgPSB7fTtcbiAgICAgICAgdGhpcy5tYXBfc2l6ZSA9IDE7XG4gICAgfVxuXG4gICAgc3RhdGljIHNldFByZWZpeChwcmVmaXgpIHtcbiAgICAgICAgdGhpcy5tYXBfcHJlZml4ID0gcHJlZml4O1xuICAgIH1cblxufVxuXG4vLyBqcyBoaW50IHJlcXVpcmVzIGV4cG9ydCBzdGF0ZW1lbnQgYmVsb3cgY2xhc3MgZGVmaW5pdGlvbiBpbiBvcmRlciB0byByZWNvZ25pemVcbi8vIGNsYXNzIG5hbWUgd2hlbiBzZXR0aW5nIHN0YXRpYyBwcm9wZXJ0aWVzIGJlbG93IChzaWdoKVxuZXhwb3J0IGRlZmF1bHQgRmVhdHVyZVNlbGVjdGlvbjtcblxuLy8gU3RhdGljIHByb3BlcnRpZXNcbkZlYXR1cmVTZWxlY3Rpb24ubWFwID0ge307IC8vIHRoaXMgd2lsbCBiZSB1bmlxdWUgcGVyIG1vZHVsZSBpbnN0YW5jZSAoc28gdW5pcXVlIHBlciB3b3JrZXIpXG5GZWF0dXJlU2VsZWN0aW9uLm1hcF9zaXplID0gMTsgLy8gc3RhcnQgYXQgMSBzaW5jZSAxIHdpbGwgYmUgZGl2aWRlZCBieSB0aGlzXG5GZWF0dXJlU2VsZWN0aW9uLm1hcF9wcmVmaXggPSAwOyAvLyBzZXQgYnkgd29ya2VyIHRvIHdvcmtlciBpZCAjXG5GZWF0dXJlU2VsZWN0aW9uLmRlZmF1bHRDb2xvciA9IFswLCAwLCAwLCAxXTtcbiIsIi8vIEdlb21ldHJ5IGJ1aWxkaW5nIGZ1bmN0aW9uc1xuXG5pbXBvcnQge1ZlY3Rvcn0gZnJvbSAnLi4vdmVjdG9yJztcbmltcG9ydCBHZW8gZnJvbSAnLi4vZ2VvJztcblxuaW1wb3J0IGVhcmN1dCBmcm9tICdlYXJjdXQnO1xuXG52YXIgQnVpbGRlcnM7XG5leHBvcnQgZGVmYXVsdCBCdWlsZGVycyA9IHt9O1xuXG5CdWlsZGVycy5kZWJ1ZyA9IGZhbHNlO1xuXG4vLyBSZS1zY2FsZSBVVnMgZnJvbSBbMCwgMV0gcmFuZ2UgdG8gYSBzbWFsbGVyIGFyZWEgd2l0aGluIHRoZSBpbWFnZVxuQnVpbGRlcnMuc2NhbGVUZXhjb29yZHNUb1Nwcml0ZSA9IGZ1bmN0aW9uICh1diwgYXJlYV9vcmlnaW4sIGFyZWFfc2l6ZSwgdGV4X3NpemUpIHtcbiAgICB2YXIgYXJlYV9vcmlnaW5feSA9IHRleF9zaXplWzFdIC0gYXJlYV9vcmlnaW5bMV0gLSBhcmVhX3NpemVbMV07XG4gICAgdmFyIHN1diA9IFtdO1xuICAgIHN1dlswXSA9ICh1dlswXSAqIGFyZWFfc2l6ZVswXSArIGFyZWFfb3JpZ2luWzBdKSAvIHRleF9zaXplWzBdO1xuICAgIHN1dlsxXSA9ICh1dlsxXSAqIGFyZWFfc2l6ZVsxXSArIGFyZWFfb3JpZ2luX3kpIC8gdGV4X3NpemVbMV07XG4gICAgcmV0dXJuIHN1djtcbn07XG5cbkJ1aWxkZXJzLmdldFRleGNvb3Jkc0ZvclNwcml0ZSA9IGZ1bmN0aW9uIChhcmVhX29yaWdpbiwgYXJlYV9zaXplLCB0ZXhfc2l6ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIEJ1aWxkZXJzLnNjYWxlVGV4Y29vcmRzVG9TcHJpdGUoWzAsIDBdLCBhcmVhX29yaWdpbiwgYXJlYV9zaXplLCB0ZXhfc2l6ZSksXG4gICAgICAgIEJ1aWxkZXJzLnNjYWxlVGV4Y29vcmRzVG9TcHJpdGUoWzEsIDFdLCBhcmVhX29yaWdpbiwgYXJlYV9zaXplLCB0ZXhfc2l6ZSlcbiAgICBdO1xufTtcblxuLy8gVGVzc2VsYXRlIGEgZmxhdCAyRCBwb2x5Z29uXG4vLyB4ICYgeSBjb29yZGluYXRlcyB3aWxsIGJlIHNldCBhcyBmaXJzdCB0d28gZWxlbWVudHMgb2YgcHJvdmlkZWQgdmVydGV4X3RlbXBsYXRlXG5CdWlsZGVycy5idWlsZFBvbHlnb25zID0gZnVuY3Rpb24gKFxuICAgIHBvbHlnb25zLFxuICAgIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsXG4gICAgeyB0ZXhjb29yZF9pbmRleCwgdGV4Y29vcmRfc2NhbGUgfSkge1xuXG4gICAgdmFyIFtbbWluX3UsIG1pbl92XSwgW21heF91LCBtYXhfdl1dID0gdGV4Y29vcmRfc2NhbGUgfHwgW1swLCAwXSwgWzEsIDFdXTtcbiAgICB2YXIgbnVtX3BvbHlnb25zID0gcG9seWdvbnMubGVuZ3RoO1xuICAgIGZvciAodmFyIHA9MDsgcCA8IG51bV9wb2x5Z29uczsgcCsrKSB7XG4gICAgICAgIHZhciBwb2x5Z29uID0gcG9seWdvbnNbcF07XG5cbiAgICAgICAgLy8gRmluZCBwb2x5Z29uIGV4dGVudHMgdG8gY2FsY3VsYXRlIFVWcywgZml0IHRoZW0gdG8gdGhlIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3hcbiAgICAgICAgaWYgKHRleGNvb3JkX2luZGV4KSB7XG4gICAgICAgICAgICB2YXIgW21pbl94LCBtaW5feSwgbWF4X3gsIG1heF95XSA9IEdlby5maW5kQm91bmRpbmdCb3gocG9seWdvbik7XG4gICAgICAgICAgICB2YXIgc3Bhbl94ID0gbWF4X3ggLSBtaW5feDtcbiAgICAgICAgICAgIHZhciBzcGFuX3kgPSBtYXhfeSAtIG1pbl95O1xuICAgICAgICAgICAgdmFyIHNjYWxlX3UgPSAobWF4X3UgLSBtaW5fdSkgLyBzcGFuX3g7XG4gICAgICAgICAgICB2YXIgc2NhbGVfdiA9IChtYXhfdiAtIG1pbl92KSAvIHNwYW5feTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlc3NlbGxhdGVcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gQnVpbGRlcnMudHJpYW5ndWxhdGVQb2x5Z29uKHBvbHlnb24pO1xuXG4gICAgICAgIC8vIEFkZCB2ZXJ0ZXggZGF0YVxuICAgICAgICB2YXIgbnVtX3ZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciB2PTA7IHYgPCBudW1fdmVydGljZXM7IHYrKykge1xuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzW3ZdO1xuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlWzBdID0gdmVydGV4WzBdO1xuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlWzFdID0gdmVydGV4WzFdO1xuXG4gICAgICAgICAgICAvLyBBZGQgVVZzXG4gICAgICAgICAgICBpZiAodGV4Y29vcmRfaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAwXSA9ICh2ZXJ0ZXhbMF0gLSBtaW5feCkgKiBzY2FsZV91ICsgbWluX3U7XG4gICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3RleGNvb3JkX2luZGV4ICsgMV0gPSAodmVydGV4WzFdIC0gbWluX3kpICogc2NhbGVfdiArIG1pbl92O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2ZXJ0ZXhfZGF0YS5hZGRWZXJ0ZXgodmVydGV4X3RlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIFRlc3NlbGF0ZSBhbmQgZXh0cnVkZSBhIGZsYXQgMkQgcG9seWdvbiBpbnRvIGEgc2ltcGxlIDNEIG1vZGVsIHdpdGggZml4ZWQgaGVpZ2h0IGFuZCBhZGQgdG8gR0wgdmVydGV4IGJ1ZmZlclxuQnVpbGRlcnMuYnVpbGRFeHRydWRlZFBvbHlnb25zID0gZnVuY3Rpb24gKFxuICAgIHBvbHlnb25zLFxuICAgIHosIGhlaWdodCwgbWluX2hlaWdodCxcbiAgICB2ZXJ0ZXhfZGF0YSwgdmVydGV4X3RlbXBsYXRlLFxuICAgIG5vcm1hbF9pbmRleCxcbiAgICB7IHRleGNvb3JkX2luZGV4LCB0ZXhjb29yZF9zY2FsZSB9KSB7XG5cbiAgICAvLyBUb3BcbiAgICB2YXIgbWluX3ogPSB6ICsgKG1pbl9oZWlnaHQgfHwgMCk7XG4gICAgdmFyIG1heF96ID0geiArIGhlaWdodDtcbiAgICB2ZXJ0ZXhfdGVtcGxhdGVbMl0gPSBtYXhfejtcbiAgICBCdWlsZGVycy5idWlsZFBvbHlnb25zKHBvbHlnb25zLCB2ZXJ0ZXhfZGF0YSwgdmVydGV4X3RlbXBsYXRlLCB7IHRleGNvb3JkX2luZGV4IH0pO1xuXG4gICAgLy8gV2FsbHNcbiAgICAvLyBGaXQgVVZzIHRvIHdhbGwgcXVhZFxuICAgIHZhciBbW21pbl91LCBtaW5fdl0sIFttYXhfdSwgbWF4X3ZdXSA9IHRleGNvb3JkX3NjYWxlIHx8IFtbMCwgMF0sIFsxLCAxXV07XG4gICAgaWYgKHRleGNvb3JkX2luZGV4KSB7XG4gICAgICAgIHZhciB0ZXhjb29yZHMgPSBbXG4gICAgICAgICAgICBbbWluX3UsIG1heF92XSxcbiAgICAgICAgICAgIFttaW5fdSwgbWluX3ZdLFxuICAgICAgICAgICAgW21heF91LCBtaW5fdl0sXG5cbiAgICAgICAgICAgIFttYXhfdSwgbWluX3ZdLFxuICAgICAgICAgICAgW21heF91LCBtYXhfdl0sXG4gICAgICAgICAgICBbbWluX3UsIG1heF92XVxuICAgICAgICBdO1xuICAgIH1cblxuICAgIHZhciBudW1fcG9seWdvbnMgPSBwb2x5Z29ucy5sZW5ndGg7XG4gICAgZm9yICh2YXIgcD0wOyBwIDwgbnVtX3BvbHlnb25zOyBwKyspIHtcbiAgICAgICAgdmFyIHBvbHlnb24gPSBwb2x5Z29uc1twXTtcblxuICAgICAgICBmb3IgKHZhciBxPTA7IHEgPCBwb2x5Z29uLmxlbmd0aDsgcSsrKSB7XG4gICAgICAgICAgICB2YXIgY29udG91ciA9IHBvbHlnb25bcV07XG5cbiAgICAgICAgICAgIGZvciAodmFyIHc9MDsgdyA8IGNvbnRvdXIubGVuZ3RoIC0gMTsgdysrKSB7XG4gICAgICAgICAgICAgICAgLy8gVHdvIHRyaWFuZ2xlcyBmb3IgdGhlIHF1YWQgZm9ybWVkIGJ5IGVhY2ggdmVydGV4IHBhaXIsIGdvaW5nIGZyb20gYm90dG9tIHRvIHRvcCBoZWlnaHRcbiAgICAgICAgICAgICAgICB2YXIgd2FsbF92ZXJ0aWNlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpYW5nbGVcbiAgICAgICAgICAgICAgICAgICAgW2NvbnRvdXJbdysxXVswXSwgY29udG91clt3KzFdWzFdLCBtYXhfel0sXG4gICAgICAgICAgICAgICAgICAgIFtjb250b3VyW3crMV1bMF0sIGNvbnRvdXJbdysxXVsxXSwgbWluX3pdLFxuICAgICAgICAgICAgICAgICAgICBbY29udG91clt3XVswXSwgY29udG91clt3XVsxXSwgbWluX3pdLFxuICAgICAgICAgICAgICAgICAgICAvLyBUcmlhbmdsZVxuICAgICAgICAgICAgICAgICAgICBbY29udG91clt3XVswXSwgY29udG91clt3XVsxXSwgbWluX3pdLFxuICAgICAgICAgICAgICAgICAgICBbY29udG91clt3XVswXSwgY29udG91clt3XVsxXSwgbWF4X3pdLFxuICAgICAgICAgICAgICAgICAgICBbY29udG91clt3KzFdWzBdLCBjb250b3VyW3crMV1bMV0sIG1heF96XVxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxjIHRoZSBub3JtYWwgb2YgdGhlIHdhbGwgZnJvbSB1cCB2ZWN0b3IgYW5kIG9uZSBzZWdtZW50IG9mIHRoZSB3YWxsIHRyaWFuZ2xlc1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWwgPSBWZWN0b3IuY3Jvc3MoXG4gICAgICAgICAgICAgICAgICAgIFswLCAwLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yLm5vcm1hbGl6ZShbY29udG91clt3KzFdWzBdIC0gY29udG91clt3XVswXSwgY29udG91clt3KzFdWzFdIC0gY29udG91clt3XVsxXSwgMF0pXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB2ZXJ0ZXggdGVtcGxhdGUgd2l0aCBjdXJyZW50IHN1cmZhY2Ugbm9ybWFsXG4gICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW25vcm1hbF9pbmRleCArIDBdID0gbm9ybWFsWzBdO1xuICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtub3JtYWxfaW5kZXggKyAxXSA9IG5vcm1hbFsxXTtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbbm9ybWFsX2luZGV4ICsgMl0gPSBub3JtYWxbMl07XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciB3dj0wOyB3diA8IHdhbGxfdmVydGljZXMubGVuZ3RoOyB3disrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVswXSA9IHdhbGxfdmVydGljZXNbd3ZdWzBdO1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbMV0gPSB3YWxsX3ZlcnRpY2VzW3d2XVsxXTtcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlWzJdID0gd2FsbF92ZXJ0aWNlc1t3dl1bMl07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleGNvb3JkX2luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAwXSA9IHRleGNvb3Jkc1t3dl1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAxXSA9IHRleGNvb3Jkc1t3dl1bMV07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhfZGF0YS5hZGRWZXJ0ZXgodmVydGV4X3RlbXBsYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBCdWlsZCB0ZXNzZWxsYXRlZCB0cmlhbmdsZXMgZm9yIGEgcG9seWxpbmVcbkJ1aWxkZXJzLmJ1aWxkUG9seWxpbmVzID0gZnVuY3Rpb24gKFxuICAgIGxpbmVzLFxuICAgIHdpZHRoLFxuICAgIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsXG4gICAge1xuICAgICAgICBjbG9zZWRfcG9seWdvbixcbiAgICAgICAgcmVtb3ZlX3RpbGVfZWRnZXMsXG4gICAgICAgIHRpbGVfZWRnZV90b2xlcmFuY2UsXG4gICAgICAgIHRleGNvb3JkX2luZGV4LFxuICAgICAgICB0ZXhjb29yZF9zY2FsZSxcbiAgICAgICAgc2NhbGluZ19pbmRleCxcbiAgICAgICAgam9pbiwgY2FwXG4gICAgfSkge1xuXG4gICAgdmFyIGNvcm5lcnNPbkNhcCA9IChjYXAgPT09IFwic3F1YXJlXCIpPyAyIDogKChjYXAgPT09IFwicm91bmRcIik/IDQgOiAwKTsgIC8vIEJ1dHQgaXMgdGhlIGltcGxpY2l0IGRlZmF1bHRcbiAgICB2YXIgdHJpYW5nbGVzT25Kb2luID0gKGpvaW4gPT09IFwiYmV2ZWxcIik/IDEgOiAoKGpvaW4gPT09IFwicm91bmRcIik/IDUgOiAwKTsgIC8vIE1pdGVyIGlzIHRoZSBpbXBsaWNpdCBkZWZhdWx0XG5cbiAgICAvLyBCdWlsZCB2YXJpYWJsZXNcbiAgICB2YXIgW1ttaW5fdSwgbWluX3ZdLCBbbWF4X3UsIG1heF92XV0gPSB0ZXhjb29yZF9zY2FsZSB8fCBbWzAsIDBdLCBbMSwgMV1dO1xuXG4gICAgLy8gVmFsdWVzIHRoYXQgYXJlIGNvbnN0YW50IGZvciBlYWNoIGxpbmUgYW5kIGFyZSBwYXNzZWQgdG8gaGVscGVyIGZ1bmN0aW9uc1xuICAgIHZhciBjb25zdGFudHMgPSB7XG4gICAgICAgIHZlcnRleF9kYXRhLFxuICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGUsXG4gICAgICAgIGhhbGZXaWR0aDogd2lkdGgvMixcbiAgICAgICAgdmVydGljZXM6IFtdLFxuICAgICAgICBzY2FsaW5nX2luZGV4LFxuICAgICAgICBzY2FsaW5nVmVjczogc2NhbGluZ19pbmRleCAmJiBbXSxcbiAgICAgICAgdGV4Y29vcmRfaW5kZXgsXG4gICAgICAgIHRleGNvb3JkczogdGV4Y29vcmRfaW5kZXggJiYgW10sXG4gICAgICAgIG1pbl91LCBtaW5fdiwgbWF4X3UsIG1heF92LFxuICAgICAgICBuUGFpcnM6IDBcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgbG4gPSAwOyBsbiA8IGxpbmVzLmxlbmd0aDsgbG4rKykge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2xuXTtcbiAgICAgICAgdmFyIGxpbmVTaXplID0gbGluZS5sZW5ndGg7XG5cbiAgICAgICAgLy8gSWdub3JlIG5vbi1saW5lc1xuICAgICAgICBpZiAobGluZVNpemUgPCAyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICBJbml0aWFsaXplIHZhcmlhYmxlc1xuICAgICAgICB2YXIgY29vcmRQcmV2ID0gWzAsIDBdLCAvLyBQcmV2aW91cyBwb2ludCBjb29yZGluYXRlc1xuICAgICAgICAgICAgY29vcmRDdXJyID0gWzAsIDBdLCAvLyBDdXJyZW50IHBvaW50IGNvb3JkaW5hdGVzXG4gICAgICAgICAgICBjb29yZE5leHQgPSBbMCwgMF07IC8vIE5leHQgcG9pbnQgY29vcmRpbmF0ZXNcblxuICAgICAgICB2YXIgbm9ybVByZXYgPSBbMCwgMF0sICAvLyBSaWdodCBub3JtYWwgdG8gc2VnbWVudCBiZXR3ZWVuIHByZXZpb3VzIGFuZCBjdXJyZW50IG1fcG9pbnRzXG4gICAgICAgICAgICBub3JtQ3VyciA9IFswLCAwXSwgIC8vIFJpZ2h0IG5vcm1hbCBhdCBjdXJyZW50IHBvaW50LCBzY2FsZWQgZm9yIG1pdGVyIGpvaW50XG4gICAgICAgICAgICBub3JtTmV4dCA9IFswLCAwXTsgIC8vIFJpZ2h0IG5vcm1hbCB0byBzZWdtZW50IGJldHdlZW4gY3VycmVudCBhbmQgbmV4dCBtX3BvaW50c1xuXG4gICAgICAgIHZhciBpc1ByZXYgPSBmYWxzZSxcbiAgICAgICAgICAgIGlzTmV4dCA9IHRydWU7XG5cbiAgICAgICAgLy8gQWRkIHZlcnRpY2VzIHRvIGJ1ZmZlciBhY29yZGluZyB0aGVpciBpbmRleFxuICAgICAgICBpbmRleFBhaXJzKGNvbnN0YW50cyk7XG5cbiAgICAgICAgLy8gRG8gdGhpcyB3aXRoIHRoZSByZXN0IChleGNlcHQgdGhlIGxhc3Qgb25lKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVTaXplIDsgaSsrKSB7XG5cbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgbmV4dCBvbmU/XG4gICAgICAgICAgICBpc05leHQgPSBpKzEgPCBsaW5lU2l6ZTtcblxuICAgICAgICAgICAgaWYgKGlzUHJldikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcHJldml1cyBvbmUsIGNvcHkgdGhlIGN1cnJlbnQgKHByZXZpb3VzKSB2YWx1ZXMgb24gKlByZXZcbiAgICAgICAgICAgICAgICBjb29yZFByZXYgPSBjb29yZEN1cnI7XG4gICAgICAgICAgICAgICAgbm9ybVByZXYgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5wZXJwKGNvb3JkUHJldiwgbGluZVtpXSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpID09PSAwICYmIGNsb3NlZF9wb2x5Z29uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXMgdGhlIGZpcnN0IHBvaW50IGFuZCBpcyBhIGNsb3NlIHBvbHlnb25cblxuICAgICAgICAgICAgICAgIHZhciBuZWVkVG9DbG9zZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZV90aWxlX2VkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKEJ1aWxkZXJzLmlzT25UaWxlRWRnZShsaW5lW2ldLCBsaW5lW2xpbmVTaXplLTJdLCB7IHRpbGVfZWRnZV90b2xlcmFuY2UgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRUb0Nsb3NlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobmVlZFRvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRQcmV2ID0gbGluZVtsaW5lU2l6ZS0yXTtcbiAgICAgICAgICAgICAgICAgICAgbm9ybVByZXYgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5wZXJwKGNvb3JkUHJldiwgbGluZVtpXSkpO1xuICAgICAgICAgICAgICAgICAgICBpc1ByZXYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXNzaWduIGN1cnJlbnQgY29vcmRpbmF0ZVxuICAgICAgICAgICAgY29vcmRDdXJyID0gbGluZVtpXTtcblxuICAgICAgICAgICAgaWYgKGlzTmV4dCkge1xuICAgICAgICAgICAgICAgIGNvb3JkTmV4dCA9IGxpbmVbaSsxXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xvc2VkX3BvbHlnb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpcyB0aGUgbGFzdCBwb2ludCBhIGNsb3NlIHBvbHlnb25cbiAgICAgICAgICAgICAgICBjb29yZE5leHQgPSBsaW5lWzFdO1xuICAgICAgICAgICAgICAgIGlzTmV4dCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc05leHQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpcyBub3QgdGhlIGxhc3Qgb25lIGdldCBuZXh0IGNvb3JkaW5hdGVzIGFuZCBjYWxjdWxhdGUgdGhlIHJpZ2h0IG5vcm1hbFxuXG4gICAgICAgICAgICAgICAgbm9ybU5leHQgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5wZXJwKGNvb3JkQ3VyciwgY29vcmROZXh0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZV90aWxlX2VkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChCdWlsZGVycy5pc09uVGlsZUVkZ2UoY29vcmRDdXJyLCBjb29yZE5leHQsIHsgdGlsZV9lZGdlX3RvbGVyYW5jZSB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybUN1cnIgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5wZXJwKGNvb3JkUHJldiwgY29vcmRDdXJyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4UGFpcihjb29yZEN1cnIsIG5vcm1DdXJyLCBpL2xpbmVTaXplLCBjb25zdGFudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50cy5uUGFpcnMrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB2ZXJ0aWNlcyB0byBidWZmZXIgYWNvcmRpbmcgdGhlaXIgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleFBhaXJzKGNvbnN0YW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXYgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAgQ29tcHV0ZSBjdXJyZW50IG5vcm1hbFxuICAgICAgICAgICAgaWYgKGlzUHJldikge1xuICAgICAgICAgICAgICAgIC8vICBJZiB0aGVyZSBpcyBhIFBSRVZJVVMgLi4uXG4gICAgICAgICAgICAgICAgaWYgKGlzTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyAuLi4gYW5kIGEgTkVYVCBPTkUsIGNvbXB1dGUgcHJldml1cyBhbmQgbmV4dCBub3JtYWxzIChzY2FsZWQgYnkgdGhlIGFuZ2xlIHdpdGggdGhlIGxhc3QgcHJldilcbiAgICAgICAgICAgICAgICAgICAgbm9ybUN1cnIgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5hZGQobm9ybVByZXYsIG5vcm1OZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IDIgLyAoMSArIE1hdGguYWJzKFZlY3Rvci5kb3Qobm9ybVByZXYsIG5vcm1DdXJyKSkpO1xuICAgICAgICAgICAgICAgICAgICBub3JtQ3VyciA9IFZlY3Rvci5tdWx0KG5vcm1DdXJyLHNjYWxlKnNjYWxlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyAuLi4gYW5kIHRoZXJlIGlzIE5PVCBhIE5FWFQgT05FLCBjb3B5IHRoZSBwcmV2aXVzIG5leHQgb25lICh3aGljaCBpcyB0aGUgY3VycmVudCBvbmUpXG4gICAgICAgICAgICAgICAgICAgIG5vcm1DdXJyID0gVmVjdG9yLm5vcm1hbGl6ZShWZWN0b3IucGVycChjb29yZFByZXYsIGNvb3JkQ3VycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXMgTk9UIGEgUFJFVklVUyAuLi5cbiAgICAgICAgICAgICAgICBpZiAoaXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLiBhbmQgYSBORVhUIE9ORSxcbiAgICAgICAgICAgICAgICAgICAgbm9ybU5leHQgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5wZXJwKGNvb3JkQ3VyciwgY29vcmROZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1DdXJyID0gbm9ybU5leHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uIGFuZCBOT1QgYSBORVhUIE9ORSwgbm90aGluZyB0byBkbyAod2l0aG91dCBwcmV2IG9yIG5leHQgb25lIHRoaXMgaXMganVzdCBhIHBvaW50KVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc1ByZXYgfHwgaXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXMgdGhlIEJFR0lOSU5HIG9mIGEgTElORVxuICAgICAgICAgICAgICAgIGlmIChpID09PSAwICYmICFpc1ByZXYgJiYgIWNsb3NlZF9wb2x5Z29uKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZENhcChjb29yZEN1cnIsIG5vcm1DdXJyLCBjb3JuZXJzT25DYXAsIHRydWUsIGNvbnN0YW50cyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgaXMgYSBKT0lOXG4gICAgICAgICAgICAgICAgaWYodHJpYW5nbGVzT25Kb2luICE9PSAwICYmIGlzUHJldiAmJiBpc05leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkSm9pbihbY29vcmRQcmV2LCBjb29yZEN1cnIsIGNvb3JkTmV4dF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW25vcm1QcmV2LG5vcm1DdXJyLCBub3JtTmV4dF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaS9saW5lU2l6ZSwgdHJpYW5nbGVzT25Kb2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50cyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkVmVydGV4UGFpcihjb29yZEN1cnIsIG5vcm1DdXJyLCBpLyhsaW5lU2l6ZS0xKSwgY29uc3RhbnRzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgY29uc3RhbnRzLm5QYWlycysrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlzUHJldiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdmVydGljZXMgdG8gYnVmZmVyIGFjb3JkaW5nIHRoZWlyIGluZGV4XG4gICAgICAgIGluZGV4UGFpcnMoY29uc3RhbnRzKTtcblxuICAgICAgICAgLy8gSWYgaXMgdGhlIEVORCBPRiBhIExJTkVcbiAgICAgICAgaWYoIWNsb3NlZF9wb2x5Z29uKSB7XG4gICAgICAgICAgICBhZGRDYXAoY29vcmRDdXJyLCBub3JtQ3VyciwgY29ybmVyc09uQ2FwICwgZmFsc2UsIGNvbnN0YW50cyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBBZGQgdG8gZXF1aWRpc3RhbnQgcGFpcnMgb2YgdmVydGljZXMgKGludGVybmFsIG1ldGhvZCBmb3IgcG9seWxpbmUgYnVpbGRlcilcbmZ1bmN0aW9uIGFkZFZlcnRleChjb29yZCwgbm9ybWFsLCB1diwgeyBoYWxmV2lkdGgsIHZlcnRpY2VzLCBzY2FsaW5nVmVjcywgdGV4Y29vcmRzIH0pIHtcbiAgICBpZiAoc2NhbGluZ1ZlY3MpIHtcbiAgICAgICAgLy8gIGEuIElmIHNjYWxpbmcgaXMgb24gYWRkIHRoZSB2ZXJ0ZXggKHRoZSBjdXJyQ29vcmQpIGFuZCB0aGUgc2NhbGluZyBWZWNzIChub3JtYWxzIHBvaW50aW5nIHdoZXJlIHRvIGV4dHJ1ZGUgdGhlIHZlcnRleGVzKVxuICAgICAgICB2ZXJ0aWNlcy5wdXNoKGNvb3JkKTtcbiAgICAgICAgc2NhbGluZ1ZlY3MucHVzaChub3JtYWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICBiLiBBZGQgdGhlIGV4dHJ1ZGVkIHZlcnRleGVzXG4gICAgICAgIHZlcnRpY2VzLnB1c2goW2Nvb3JkWzBdICsgbm9ybWFsWzBdICogaGFsZldpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICBjb29yZFsxXSArIG5vcm1hbFsxXSAqIGhhbGZXaWR0aF0pO1xuICAgIH1cblxuICAgIC8vIGMpIEFkZCB1didzIGlmIHRoZXkgYXJlIGVuYWJsZVxuICAgIGlmICh0ZXhjb29yZHMpIHtcbiAgICAgICAgdGV4Y29vcmRzLnB1c2godXYpO1xuICAgIH1cbn1cblxuLy8gIEFkZCB0byBlcXVpZGlzdGFudCBwYWlycyBvZiB2ZXJ0aWNlcyAoaW50ZXJuYWwgbWV0aG9kIGZvciBwb2x5bGluZSBidWlsZGVyKVxuZnVuY3Rpb24gYWRkVmVydGV4UGFpciAoY29vcmQsIG5vcm1hbCwgdl9wY3QsIGNvbnN0YW50cykge1xuICAgIGFkZFZlcnRleChjb29yZCwgbm9ybWFsLCBbY29uc3RhbnRzLm1heF91LCAoMS12X3BjdCkqY29uc3RhbnRzLm1pbl92ICsgdl9wY3QqY29uc3RhbnRzLm1heF92XSwgY29uc3RhbnRzKTtcbiAgICBhZGRWZXJ0ZXgoY29vcmQsIFZlY3Rvci5uZWcobm9ybWFsKSwgW2NvbnN0YW50cy5taW5fdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl0sIGNvbnN0YW50cyk7XG59XG5cbi8vICBUZXNzYWxhdGUgYSBGQU4gZ2VvbWV0cnkgYmV0d2VlbiBwb2ludHMgQSAgICAgICBCXG4vLyAgdXNpbmcgdGhlaXIgbm9ybWFscyBmcm9tIGEgY2VudGVyICAgICAgICBcXCAuIC4gL1xuLy8gIGFuZCBpbnRlcnBvbGF0aW5nIHRoZWlyIFVWcyAgICAgICAgICAgICAgIFxcIHAgL1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXC4vXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDXG5mdW5jdGlvbiBhZGRGYW4gKGNvb3JkLCBuQSwgbkMsIG5CLCB1QSwgdUMsIHVCLCBzaWduZWQsIG51bVRyaWFuZ2xlcywgY29uc3RhbnRzKSB7XG5cbiAgICBpZiAobnVtVHJpYW5nbGVzIDwgMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQWRkIHByZXZpdXMgdmVydGljZXMgdG8gYnVmZmVyIGFuZCBjbGVhbiB0aGUgYnVmZmVycyBhbmQgaW5kZXggcGFpcnNcbiAgICAvLyBCZWNhdXNlIHdlIGFyZSBnb2luZyB0byBhZGQgbW9yZSB0cmlhbmdsZXMuXG4gICAgaW5kZXhQYWlycyhjb25zdGFudHMpO1xuXG4gICAgdmFyIG5vcm1DdXJyID0gVmVjdG9yLnNldChuQSk7XG4gICAgdmFyIG5vcm1QcmV2ID0gWzAsMF07XG5cbiAgICB2YXIgYW5nbGVfZGVsdGEgPSBWZWN0b3IuZG90KG5BLCBuQik7XG4gICAgaWYgKGFuZ2xlX2RlbHRhIDwgLTEpIHtcbiAgICAgICAgYW5nbGVfZGVsdGEgPSAtMTtcbiAgICB9XG4gICAgYW5nbGVfZGVsdGEgPSBNYXRoLmFjb3MoYW5nbGVfZGVsdGEpL251bVRyaWFuZ2xlcztcblxuICAgIGlmICghc2lnbmVkKSB7XG4gICAgICAgIGFuZ2xlX2RlbHRhICo9IC0xO1xuICAgIH1cblxuICAgIHZhciB1dkN1cnIgPSBWZWN0b3Iuc2V0KHVBKTtcbiAgICB2YXIgdXZfZGVsdGEgPSBWZWN0b3IuZGl2KFZlY3Rvci5zdWIodUIsdUEpLCBudW1UcmlhbmdsZXMpO1xuXG4gICAgLy8gIEFkZCB0aGUgZmlyc3QgYW5kIENFTlRFUiB2ZXJ0ZXhcbiAgICAvLyAgVGhlIHRyaWFuZ2xlcyB3aWxsIGJlIGNvbXBvc2VkIG9uIEZBTiBzdHlsZSBhcnJvdW5kIGl0XG4gICAgYWRkVmVydGV4KGNvb3JkLCBuQywgdUMsIGNvbnN0YW50cyk7XG5cbiAgICAvLyAgQWRkIGZpcnN0IGNvcm5lclxuICAgIGFkZFZlcnRleChjb29yZCwgbm9ybUN1cnIsIHVBLCBjb25zdGFudHMpO1xuXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSByZXN0IG9mIHRoZSBjb29ybmVyc1xuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtVHJpYW5nbGVzOyB0KyspIHtcbiAgICAgICAgbm9ybVByZXYgPSBWZWN0b3Iubm9ybWFsaXplKG5vcm1DdXJyKTtcbiAgICAgICAgbm9ybUN1cnIgPSBWZWN0b3Iucm90KCBWZWN0b3Iubm9ybWFsaXplKG5vcm1DdXJyKSwgYW5nbGVfZGVsdGEpOyAgICAgLy8gIFJvdGF0ZSB0aGUgZXh0cnVzaW9uIG5vcm1hbFxuXG4gICAgICAgIGlmIChudW1UcmlhbmdsZXMgPT09IDQgJiYgKHQgPT09IDAgfHwgdCA9PT0gbnVtVHJpYW5nbGVzIC0gMikpIHtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IDIgLyAoMSArIE1hdGguYWJzKFZlY3Rvci5kb3Qobm9ybVByZXYsIG5vcm1DdXJyKSkpO1xuICAgICAgICAgICAgbm9ybUN1cnIgPSBWZWN0b3IubXVsdChub3JtQ3Vyciwgc2NhbGUqc2NhbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdXZDdXJyID0gVmVjdG9yLmFkZCh1dkN1cnIsdXZfZGVsdGEpO1xuXG4gICAgICAgIGFkZFZlcnRleChjb29yZCwgbm9ybUN1cnIsIHV2Q3VyciwgY29uc3RhbnRzKTsgICAgICAvLyAgQWRkIGNvbXB1dGVkIGNvcm5lclxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVHJpYW5nbGVzOyBpKyspIHtcbiAgICAgICAgaWYgKHNpZ25lZCkge1xuICAgICAgICAgICAgYWRkSW5kZXgoaSsyLCBjb25zdGFudHMpO1xuICAgICAgICAgICAgYWRkSW5kZXgoMCwgY29uc3RhbnRzKTtcbiAgICAgICAgICAgIGFkZEluZGV4KGkrMSwgY29uc3RhbnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZEluZGV4KGkrMSwgY29uc3RhbnRzKTtcbiAgICAgICAgICAgIGFkZEluZGV4KDAsIGNvbnN0YW50cyk7XG4gICAgICAgICAgICBhZGRJbmRleChpKzIsIGNvbnN0YW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDbGVhbiB0aGUgYnVmZmVyXG4gICAgY29uc3RhbnRzLnZlcnRpY2VzID0gW107XG4gICAgaWYgKGNvbnN0YW50cy5zY2FsaW5nVmVjcykge1xuICAgICAgICBjb25zdGFudHMuc2NhbGluZ1ZlY3MgPSBbXTtcbiAgICB9XG4gICAgaWYgKGNvbnN0YW50cy50ZXhjb29yZHMpIHtcbiAgICAgICAgY29uc3RhbnRzLnRleGNvb3JkcyA9IFtdO1xuICAgIH1cbn1cblxuLy8gIEFkZCBzcGVjY2lhbHMgam9pbnMgKG5vdCBtaXRlcikgdGlwZXMgdGhhdCByZXF1aXJlIEZBTiB0ZXNzYWxhdGlvbnNcbi8vICBVc2luZyB0aGlzICggaHR0cDovL3d3dy5jb2RlcHJvamVjdC5jb20vQXJ0aWNsZXMvMjI2NTY5L0RyYXdpbmctcG9seWxpbmVzLWJ5LXRlc3NlbGxhdGlvbiApIGFzIHJlZmVyZW5jZVxuZnVuY3Rpb24gYWRkSm9pbiAoY29vcmRzLCBub3JtYWxzLCB2X3BjdCwgblRyaWFuZ2xlcywgY29uc3RhbnRzKSB7XG5cbiAgICB2YXIgVCA9IFtWZWN0b3Iuc2V0KG5vcm1hbHNbMF0pLCBWZWN0b3Iuc2V0KG5vcm1hbHNbMV0pLCBWZWN0b3Iuc2V0KG5vcm1hbHNbMl0pXTtcbiAgICB2YXIgc2lnbmVkID0gVmVjdG9yLnNpZ25lZF9hcmVhKGNvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0pID4gMDtcblxuICAgIHZhciBuQSA9IFRbMF0sICAgICAgICAgICAgICAvLyBub3JtYWwgdG8gcG9pbnQgQSAoYVQpXG4gICAgICAgIG5DID0gVmVjdG9yLm5lZyhUWzFdKSwgIC8vIG5vcm1hbCB0byBjZW50ZXIgKC12UClcbiAgICAgICAgbkIgPSBUWzJdOyAgICAgICAgICAgICAgLy8gbm9ybWFsIHRvIHBvaW50IEIgKGJUKVxuXG4gICAgdmFyIHVBID0gW2NvbnN0YW50cy5tYXhfdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl0sXG4gICAgICAgIHVDID0gW2NvbnN0YW50cy5taW5fdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl0sXG4gICAgICAgIHVCID0gW2NvbnN0YW50cy5tYXhfdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl07XG5cbiAgICBpZiAoc2lnbmVkKSB7XG4gICAgICAgIGFkZFZlcnRleChjb29yZHNbMV0sIG5BLCB1QSwgY29uc3RhbnRzKTtcbiAgICAgICAgYWRkVmVydGV4KGNvb3Jkc1sxXSwgbkMsIHVDLCBjb25zdGFudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5BID0gVmVjdG9yLm5lZyhUWzBdKTtcbiAgICAgICAgbkMgPSBUWzFdO1xuICAgICAgICBuQiA9IFZlY3Rvci5uZWcoVFsyXSk7XG4gICAgICAgIHVBID0gW2NvbnN0YW50cy5taW5fdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl07XG4gICAgICAgIHVDID0gW2NvbnN0YW50cy5tYXhfdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl07XG4gICAgICAgIHVCID0gW2NvbnN0YW50cy5taW5fdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl07XG4gICAgICAgIGFkZFZlcnRleChjb29yZHNbMV0sIG5DLCB1QywgY29uc3RhbnRzKTtcbiAgICAgICAgYWRkVmVydGV4KGNvb3Jkc1sxXSwgbkEsIHVBLCBjb25zdGFudHMpO1xuICAgIH1cblxuICAgIGFkZEZhbihjb29yZHNbMV0sIG5BLCBuQywgbkIsIHVBLCB1QywgdUIsIHNpZ25lZCwgblRyaWFuZ2xlcywgY29uc3RhbnRzKTtcblxuICAgIGlmIChzaWduZWQpIHtcbiAgICAgICAgYWRkVmVydGV4KGNvb3Jkc1sxXSwgbkIsIHVCLCBjb25zdGFudHMpO1xuICAgICAgICBhZGRWZXJ0ZXgoY29vcmRzWzFdLCBuQywgdUMsIGNvbnN0YW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWRkVmVydGV4KGNvb3Jkc1sxXSwgbkMsIHVDLCBjb25zdGFudHMpO1xuICAgICAgICBhZGRWZXJ0ZXgoY29vcmRzWzFdLCBuQiwgdUIsIGNvbnN0YW50cyk7XG4gICAgfVxufVxuXG4vLyAgRnVuY3Rpb24gdG8gYWRkIHRoZSB2ZXJ0ZXggbmVlZCBmb3IgbGluZSBjYXBzLFxuLy8gIGJlY2F1c2UgcmUtdXNlIHRoZSBidWZmZXJzIG5lZWRzIHRvIGJlIGF0IHRoZSBlbmRcbmZ1bmN0aW9uIGFkZENhcCAoY29vcmQsIG5vcm1hbCwgbnVtQ29ybmVycywgaXNCZWdpbm5pbmcsIGNvbnN0YW50cykge1xuXG4gICAgaWYgKG51bUNvcm5lcnMgPCAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBVVnNcbiAgICB2YXIgdXZBID0gW2NvbnN0YW50cy5taW5fdSxjb25zdGFudHMubWluX3ZdLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJlZ2luaW5nIGFuZ2xlIFVWc1xuICAgICAgICB1dkMgPSBbY29uc3RhbnRzLm1pbl91Kyhjb25zdGFudHMubWF4X3UtY29uc3RhbnRzLm1pbl91KS8yLCBjb25zdGFudHMubWluX3ZdLCAgIC8vIGNlbnRlciBwb2ludCBVVnNcbiAgICAgICAgdXZCID0gW2NvbnN0YW50cy5tYXhfdSxjb25zdGFudHMubWluX3ZdOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZGluZyBhbmdsZSBVVnNcblxuICAgIGlmICghaXNCZWdpbm5pbmcpIHtcbiAgICAgICAgdXZBID0gW2NvbnN0YW50cy5taW5fdSxjb25zdGFudHMubWF4X3ZdLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJlZ2luaW5nIGFuZ2xlIFVWc1xuICAgICAgICB1dkMgPSBbY29uc3RhbnRzLm1pbl91Kyhjb25zdGFudHMubWF4X3UtY29uc3RhbnRzLm1pbl91KS8yLCBjb25zdGFudHMubWF4X3ZdLCAgIC8vIGNlbnRlciBwb2ludCBVVnNcbiAgICAgICAgdXZCID0gW2NvbnN0YW50cy5tYXhfdSxjb25zdGFudHMubWF4X3ZdO1xuICAgIH1cblxuICAgIGFkZEZhbiggY29vcmQsXG4gICAgICAgICAgICBWZWN0b3IubmVnKG5vcm1hbCksIFswLCAwXSwgbm9ybWFsLFxuICAgICAgICAgICAgdXZBLCB1dkMsIHV2QixcbiAgICAgICAgICAgIGlzQmVnaW5uaW5nLCBudW1Db3JuZXJzKjIsIGNvbnN0YW50cyk7XG59XG5cbi8vIEFkZCBhIHZlcnRleCBiYXNlZCBvbiB0aGUgaW5kZXggcG9zaXRpb24gaW50byB0aGUgVkJPIChpbnRlcm5hbCBtZXRob2QgZm9yIHBvbHlsaW5lIGJ1aWxkZXIpXG5mdW5jdGlvbiBhZGRJbmRleCAoaW5kZXgsIHsgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSwgaGFsZldpZHRoLCB2ZXJ0aWNlcywgc2NhbGluZ19pbmRleCwgc2NhbGluZ1ZlY3MsIHRleGNvb3JkX2luZGV4LCB0ZXhjb29yZHMgfSkge1xuICAgIC8vIFByZXZlbnQgYWNjZXNzIHRvIHVuZGVmaW5lZCB2ZXJ0aWNlc1xuICAgIGlmIChpbmRleCA+PSB2ZXJ0aWNlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNldCB2ZXJ0ZXggcG9zaXRpb25cbiAgICB2ZXJ0ZXhfdGVtcGxhdGVbMF0gPSB2ZXJ0aWNlc1tpbmRleF1bMF07XG4gICAgdmVydGV4X3RlbXBsYXRlWzFdID0gdmVydGljZXNbaW5kZXhdWzFdO1xuXG4gICAgLy8gc2V0IFVWc1xuICAgIGlmICh0ZXhjb29yZF9pbmRleCkge1xuICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAwXSA9IHRleGNvb3Jkc1tpbmRleF1bMF07XG4gICAgICAgIHZlcnRleF90ZW1wbGF0ZVt0ZXhjb29yZF9pbmRleCArIDFdID0gdGV4Y29vcmRzW2luZGV4XVsxXTtcbiAgICB9XG5cbiAgICAvLyBzZXQgU2NhbGluZyB2ZXJ0ZXggKFgsIFkgbm9ybWFsIGRpcmVjdGlvbiArIFogaGFsdHdpZHRoIGFzIGF0dHJpYnV0ZSlcbiAgICBpZiAoc2NhbGluZ19pbmRleCkge1xuICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbc2NhbGluZ19pbmRleCArIDBdID0gc2NhbGluZ1ZlY3NbaW5kZXhdWzBdO1xuICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbc2NhbGluZ19pbmRleCArIDFdID0gc2NhbGluZ1ZlY3NbaW5kZXhdWzFdO1xuICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbc2NhbGluZ19pbmRleCArIDJdID0gaGFsZldpZHRoO1xuICAgIH1cblxuICAgIC8vICBBZGQgdmVydGV4IHRvIFZCT1xuICAgIHZlcnRleF9kYXRhLmFkZFZlcnRleCh2ZXJ0ZXhfdGVtcGxhdGUpO1xufVxuXG4vLyBBZGQgdGhlIGluZGV4IHZlcnRleCB0byB0aGUgVkJPIGFuZCBjbGVhbiB0aGUgYnVmZmVyc1xuZnVuY3Rpb24gaW5kZXhQYWlycyAoY29uc3RhbnRzKSB7XG4gICAgLy8gQWRkIHZlcnRpY2VzIHRvIGJ1ZmZlciBhY29yZGluZyB0aGVpciBpbmRleFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uc3RhbnRzLm5QYWlyczsgaSsrKSB7XG4gICAgICAgIGFkZEluZGV4KDIqaSsyLCBjb25zdGFudHMpO1xuICAgICAgICBhZGRJbmRleCgyKmkrMSwgY29uc3RhbnRzKTtcbiAgICAgICAgYWRkSW5kZXgoMippKzAsIGNvbnN0YW50cyk7XG5cbiAgICAgICAgYWRkSW5kZXgoMippKzIsIGNvbnN0YW50cyk7XG4gICAgICAgIGFkZEluZGV4KDIqaSszLCBjb25zdGFudHMpO1xuICAgICAgICBhZGRJbmRleCgyKmkrMSwgY29uc3RhbnRzKTtcbiAgICB9XG5cbiAgICBjb25zdGFudHMublBhaXJzID0gMDtcblxuICAgIC8vIENsZWFuIHRoZSBidWZmZXJcbiAgICBjb25zdGFudHMudmVydGljZXMgPSBbXTtcbiAgICBpZiAoY29uc3RhbnRzLnNjYWxpbmdWZWNzKSB7XG4gICAgICAgIGNvbnN0YW50cy5zY2FsaW5nVmVjcyA9IFtdO1xuICAgIH1cbiAgICBpZiAoY29uc3RhbnRzLnRleGNvb3Jkcykge1xuICAgICAgICBjb25zdGFudHMudGV4Y29vcmRzID0gW107XG4gICAgfVxufVxuXG4vLyBCdWlsZCBhIHF1YWQgY2VudGVyZWQgb24gYSBwb2ludFxuQnVpbGRlcnMuYnVpbGRRdWFkc0ZvclBvaW50cyA9IGZ1bmN0aW9uIChcbiAgICBwb2ludHMsIHdpZHRoLCBoZWlnaHQsXG4gICAgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSxcbiAgICB7IHRleGNvb3JkX2luZGV4LCB0ZXhjb29yZF9zY2FsZSB9KSB7XG5cbiAgICBpZiAodGV4Y29vcmRfaW5kZXgpIHtcbiAgICAgICAgdmFyIFtbbWluX3UsIG1pbl92XSwgW21heF91LCBtYXhfdl1dID0gdGV4Y29vcmRfc2NhbGUgfHwgW1swLCAwXSwgWzEsIDFdXTtcbiAgICAgICAgdmFyIHRleGNvb3JkcyA9IFtcbiAgICAgICAgICAgIFttaW5fdSwgbWluX3ZdLFxuICAgICAgICAgICAgW21heF91LCBtaW5fdl0sXG4gICAgICAgICAgICBbbWF4X3UsIG1heF92XSxcblxuICAgICAgICAgICAgW21pbl91LCBtaW5fdl0sXG4gICAgICAgICAgICBbbWF4X3UsIG1heF92XSxcbiAgICAgICAgICAgIFttaW5fdSwgbWF4X3ZdXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgdmFyIG51bV9wb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgIGZvciAodmFyIHA9MDsgcCA8IG51bV9wb2ludHM7IHArKykge1xuICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbcF07XG5cbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IFtcbiAgICAgICAgICAgIFtwb2ludFswXSAtIHdpZHRoLzIsIHBvaW50WzFdIC0gaGVpZ2h0LzJdLFxuICAgICAgICAgICAgW3BvaW50WzBdICsgd2lkdGgvMiwgcG9pbnRbMV0gLSBoZWlnaHQvMl0sXG4gICAgICAgICAgICBbcG9pbnRbMF0gKyB3aWR0aC8yLCBwb2ludFsxXSArIGhlaWdodC8yXSxcblxuICAgICAgICAgICAgW3BvaW50WzBdIC0gd2lkdGgvMiwgcG9pbnRbMV0gLSBoZWlnaHQvMl0sXG4gICAgICAgICAgICBbcG9pbnRbMF0gKyB3aWR0aC8yLCBwb2ludFsxXSArIGhlaWdodC8yXSxcbiAgICAgICAgICAgIFtwb2ludFswXSAtIHdpZHRoLzIsIHBvaW50WzFdICsgaGVpZ2h0LzJdXG4gICAgICAgIF07XG5cbiAgICAgICAgZm9yICh2YXIgcG9zPTA7IHBvcyA8IDY7IHBvcysrKSB7XG4gICAgICAgICAgICAvLyBBZGQgdGV4Y29vcmRzXG4gICAgICAgICAgICBpZiAodGV4Y29vcmRfaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAwXSA9IHRleGNvb3Jkc1twb3NdWzBdO1xuICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVt0ZXhjb29yZF9pbmRleCArIDFdID0gdGV4Y29vcmRzW3Bvc11bMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVswXSA9IHBvc2l0aW9uc1twb3NdWzBdO1xuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlWzFdID0gcG9zaXRpb25zW3Bvc11bMV07XG4gICAgICAgICAgICB2ZXJ0ZXhfZGF0YS5hZGRWZXJ0ZXgodmVydGV4X3RlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIEJ1aWxkIGEgYmlsbGJvYXJkIHNwcml0ZSBxdWFkIGNlbnRlcmVkIG9uIGEgcG9pbnQuIFNwcml0ZXMgYXJlIGludGVuZGVkIHRvIGJlIGRyYXduIGluIHNjcmVlbnNwYWNlLCBhbmQgaGF2ZVxuLy8gcHJvcGVydGllcyBmb3Igd2lkdGgsIGhlaWdodCwgYW5nbGUsIGFuZCBhIHNjYWxlIGZhY3RvciB0aGF0IGNhbiBiZSB1c2VkIHRvIGludGVycG9sYXRlIHRoZSBzY3JlZW5zcGFjZSBzaXplXG4vLyBvZiBhIHNwcml0ZSBiZXR3ZWVuIHR3byB6b29tIGxldmVscy5cbkJ1aWxkZXJzLmJ1aWxkU3ByaXRlUXVhZHNGb3JQb2ludHMgPSBmdW5jdGlvbiAoXG4gICAgcG9pbnRzLFxuICAgIHdpZHRoLCBoZWlnaHQsIGFuZ2xlLCBzY2FsZSxcbiAgICB2ZXJ0ZXhfZGF0YSwgdmVydGV4X3RlbXBsYXRlLFxuICAgIHNjYWxpbmdfaW5kZXgsXG4gICAgeyB0ZXhjb29yZF9pbmRleCwgdGV4Y29vcmRfc2NhbGUgfSkge1xuXG4gICAgbGV0IHcyID0gd2lkdGggLyAyO1xuICAgIGxldCBoMiA9IGhlaWdodCAvIDI7XG4gICAgbGV0IHNjYWxpbmcgPSBbXG4gICAgICAgIFstdzIsIC1oMl0sXG4gICAgICAgIFt3MiwgLWgyXSxcbiAgICAgICAgW3cyLCBoMl0sXG5cbiAgICAgICAgWy13MiwgLWgyXSxcbiAgICAgICAgW3cyLCBoMl0sXG4gICAgICAgIFstdzIsIGgyXVxuICAgIF07XG5cbiAgICBsZXQgW1ttaW5fdSwgbWluX3ZdLCBbbWF4X3UsIG1heF92XV0gPSB0ZXhjb29yZF9zY2FsZSB8fCBbWzAsIDBdLCBbMSwgMV1dO1xuICAgIGxldCB0ZXhjb29yZHM7XG4gICAgaWYgKHRleGNvb3JkX2luZGV4KSB7XG4gICAgICAgIHRleGNvb3JkcyA9IFtcbiAgICAgICAgICAgIFttaW5fdSwgbWluX3ZdLFxuICAgICAgICAgICAgW21heF91LCBtaW5fdl0sXG4gICAgICAgICAgICBbbWF4X3UsIG1heF92XSxcblxuICAgICAgICAgICAgW21pbl91LCBtaW5fdl0sXG4gICAgICAgICAgICBbbWF4X3UsIG1heF92XSxcbiAgICAgICAgICAgIFttaW5fdSwgbWF4X3ZdXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgbGV0IG51bV9wb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgIGZvciAobGV0IHA9MDsgcCA8IG51bV9wb2ludHM7IHArKykge1xuICAgICAgICBsZXQgcG9pbnQgPSBwb2ludHNbcF07XG5cbiAgICAgICAgZm9yIChsZXQgcG9zPTA7IHBvcyA8IDY7IHBvcysrKSB7XG4gICAgICAgICAgICAvLyBBZGQgdGV4Y29vcmRzXG4gICAgICAgICAgICBpZiAodGV4Y29vcmRfaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAwXSA9IHRleGNvb3Jkc1twb3NdWzBdO1xuICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVt0ZXhjb29yZF9pbmRleCArIDFdID0gdGV4Y29vcmRzW3Bvc11bMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVswXSA9IHBvaW50WzBdO1xuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlWzFdID0gcG9pbnRbMV07XG5cbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtzY2FsaW5nX2luZGV4ICsgMF0gPSBzY2FsaW5nW3Bvc11bMF07XG4gICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbc2NhbGluZ19pbmRleCArIDFdID0gc2NhbGluZ1twb3NdWzFdO1xuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3NjYWxpbmdfaW5kZXggKyAyXSA9IGFuZ2xlO1xuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3NjYWxpbmdfaW5kZXggKyAzXSA9IHNjYWxlO1xuXG4gICAgICAgICAgICB2ZXJ0ZXhfZGF0YS5hZGRWZXJ0ZXgodmVydGV4X3RlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLyogVXRpbGl0eSBmdW5jdGlvbnMgKi9cblxuLy8gVHJpYW5ndWxhdGlvbiB1c2luZyBlYXJjdXRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvZWFyY3V0XG5CdWlsZGVycy50cmlhbmd1bGF0ZVBvbHlnb24gPSBmdW5jdGlvbiAoY29udG91cnMpXG57XG4gICAgcmV0dXJuIGVhcmN1dChjb250b3Vycyk7XG59O1xuXG4vLyBUZXN0cyBpZiBhIGxpbmUgc2VnbWVudCAoZnJvbSBwb2ludCBBIHRvIEIpIGlzIG5lYXJseSBjb2luY2lkZW50IHdpdGggdGhlIGVkZ2Ugb2YgYSB0aWxlXG5CdWlsZGVycy5pc09uVGlsZUVkZ2UgPSBmdW5jdGlvbiAocGEsIHBiLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgdG9sZXJhbmNlX2Z1bmN0aW9uID0gb3B0aW9ucy50b2xlcmFuY2VfZnVuY3Rpb24gfHwgQnVpbGRlcnMudmFsdWVzV2l0aGluVG9sZXJhbmNlO1xuICAgIHZhciB0b2xlcmFuY2UgPSBvcHRpb25zLnRvbGVyYW5jZSB8fCAzOyAvLyB0d2VhayB0aGlzIGFkanVzdCBpZiBjYXRjaGluZyB0b28gZmV3L21hbnkgbGluZSBzZWdtZW50cyBuZWFyIHRpbGUgZWRnZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogbWFrZSB0b2xlcmFuY2UgY29uZmlndXJhYmxlIGJ5IHNvdXJjZSBpZiBuZWNlc3NhcnlcbiAgICB2YXIgdGlsZV9taW4gPSBCdWlsZGVycy50aWxlX2JvdW5kc1swXTtcbiAgICB2YXIgdGlsZV9tYXggPSBCdWlsZGVycy50aWxlX2JvdW5kc1sxXTtcbiAgICB2YXIgZWRnZSA9IG51bGw7XG5cbiAgICBpZiAodG9sZXJhbmNlX2Z1bmN0aW9uKHBhWzBdLCB0aWxlX21pbi54LCB0b2xlcmFuY2UpICYmIHRvbGVyYW5jZV9mdW5jdGlvbihwYlswXSwgdGlsZV9taW4ueCwgdG9sZXJhbmNlKSkge1xuICAgICAgICBlZGdlID0gJ2xlZnQnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0b2xlcmFuY2VfZnVuY3Rpb24ocGFbMF0sIHRpbGVfbWF4LngsIHRvbGVyYW5jZSkgJiYgdG9sZXJhbmNlX2Z1bmN0aW9uKHBiWzBdLCB0aWxlX21heC54LCB0b2xlcmFuY2UpKSB7XG4gICAgICAgIGVkZ2UgPSAncmlnaHQnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0b2xlcmFuY2VfZnVuY3Rpb24ocGFbMV0sIHRpbGVfbWluLnksIHRvbGVyYW5jZSkgJiYgdG9sZXJhbmNlX2Z1bmN0aW9uKHBiWzFdLCB0aWxlX21pbi55LCB0b2xlcmFuY2UpKSB7XG4gICAgICAgIGVkZ2UgPSAndG9wJztcbiAgICB9XG4gICAgZWxzZSBpZiAodG9sZXJhbmNlX2Z1bmN0aW9uKHBhWzFdLCB0aWxlX21heC55LCB0b2xlcmFuY2UpICYmIHRvbGVyYW5jZV9mdW5jdGlvbihwYlsxXSwgdGlsZV9tYXgueSwgdG9sZXJhbmNlKSkge1xuICAgICAgICBlZGdlID0gJ2JvdHRvbSc7XG4gICAgfVxuICAgIHJldHVybiBlZGdlO1xufTtcblxuQnVpbGRlcnMuc2V0VGlsZVNjYWxlID0gZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgQnVpbGRlcnMudGlsZV9ib3VuZHMgPSBbXG4gICAgICAgIHsgeDogMCwgeTogMH0sXG4gICAgICAgIHsgeDogc2NhbGUsIHk6IC1zY2FsZSB9IC8vIFRPRE86IGNvcnJlY3QgZm9yIGZsaXBwZWQgeS1heGlzP1xuICAgIF07XG59O1xuXG5CdWlsZGVycy52YWx1ZXNXaXRoaW5Ub2xlcmFuY2UgPSBmdW5jdGlvbiAoYSwgYiwgdG9sZXJhbmNlKSB7XG4gICAgdG9sZXJhbmNlID0gdG9sZXJhbmNlIHx8IDE7XG4gICAgcmV0dXJuIChNYXRoLmFicyhhIC0gYikgPCB0b2xlcmFuY2UpO1xufTtcblxuLy8gQnVpbGQgYSB6aWd6YWcgbGluZSBwYXR0ZXJuIGZvciB0ZXN0aW5nIGpvaW5zIGFuZCBjYXBzXG5CdWlsZGVycy5idWlsZFppZ3phZ0xpbmVUZXN0UGF0dGVybiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWluID0geyB4OiAwLCB5OiAwfTsgLy8gIHRpbGUubWluO1xuICAgIHZhciBtYXggPSB7IHg6IDQwOTYsIHk6IDQwOTYgfTsgLy8gdGlsZS5tYXg7XG5cbiAgICB2YXIgZyA9IHtcbiAgICAgICAgaWQ6IDEyMyxcbiAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgW21pbi54ICogMC43NSArIG1heC54ICogMC4yNSwgbWluLnkgKiAwLjc1ICsgbWF4LnkgKiAwLjI1XSxcbiAgICAgICAgICAgICAgICBbbWluLnggKiAwLjc1ICsgbWF4LnggKiAwLjI1LCBtaW4ueSAqIDAuNSArIG1heC55ICogMC41XSxcbiAgICAgICAgICAgICAgICBbbWluLnggKiAwLjI1ICsgbWF4LnggKiAwLjc1LCBtaW4ueSAqIDAuNzUgKyBtYXgueSAqIDAuMjVdLFxuICAgICAgICAgICAgICAgIFttaW4ueCAqIDAuMjUgKyBtYXgueCAqIDAuNzUsIG1pbi55ICogMC4yNSArIG1heC55ICogMC43NV0sXG4gICAgICAgICAgICAgICAgW21pbi54ICogMC40ICsgbWF4LnggKiAwLjYsIG1pbi55ICogMC41ICsgbWF4LnkgKiAwLjVdLFxuICAgICAgICAgICAgICAgIFttaW4ueCAqIDAuNSArIG1heC54ICogMC41LCBtaW4ueSAqIDAuMjUgKyBtYXgueSAqIDAuNzVdLFxuICAgICAgICAgICAgICAgIFttaW4ueCAqIDAuNzUgKyBtYXgueCAqIDAuMjUsIG1pbi55ICogMC4yNSArIG1heC55ICogMC43NV0sXG4gICAgICAgICAgICAgICAgW21pbi54ICogMC43NSArIG1heC54ICogMC4yNSwgbWluLnkgKiAwLjQgKyBtYXgueSAqIDAuNl1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAga2luZDogJ2RlYnVnJ1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gZztcbn07XG4iLCIvLyBQb2ludHMgcmVuZGVyaW5nIHN0eWxlIHcvc2ltcGxlIGRpc3RhbmNlIGZpZWxkIHJlbmRlcmluZ1xuXG5pbXBvcnQge1N0eWxlfSBmcm9tICcuLi9zdHlsZSc7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuLi9zdHlsZV9wYXJzZXInO1xuaW1wb3J0IGdsIGZyb20gJy4uLy4uL2dsL2NvbnN0YW50cyc7IC8vIHdlYiB3b3JrZXJzIGRvbid0IGhhdmUgYWNjZXNzIHRvIEdMIGNvbnRleHQsIHNvIGltcG9ydCBhbGwgR0wgY29uc3RhbnRzXG5pbXBvcnQgVmVydGV4TGF5b3V0IGZyb20gJy4uLy4uL2dsL3ZlcnRleF9sYXlvdXQnO1xuaW1wb3J0IEJ1aWxkZXJzIGZyb20gJy4uL2J1aWxkZXJzJztcblxuZXhwb3J0IHZhciBQb2ludHMgPSBPYmplY3QuY3JlYXRlKFN0eWxlKTtcblxuT2JqZWN0LmFzc2lnbihQb2ludHMsIHtcbiAgICBuYW1lOiAncG9pbnRzJyxcbiAgICBidWlsdF9pbjogdHJ1ZSxcblxuICAgIGluaXQoKSB7XG4gICAgICAgIFN0eWxlLmluaXQuYXBwbHkodGhpcyk7XG5cbiAgICAgICAgLy8gQmFzZSBzaGFkZXJzXG4gICAgICAgIHRoaXMudmVydGV4X3NoYWRlcl9rZXkgPSAnc3R5bGVzL3BvaW50cy9wb2ludHMudmVydGV4JztcbiAgICAgICAgdGhpcy5mcmFnbWVudF9zaGFkZXJfa2V5ID0gJ3N0eWxlcy9wb2ludHMvcG9pbnRzLmZyYWdtZW50JztcblxuICAgICAgICAvLyBUdXJuIGZlYXR1cmUgc2VsZWN0aW9uIG9uXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdHJ1ZTtcblxuICAgICAgICAvLyBWZXJ0ZXggYXR0cmlidXRlc1xuICAgICAgICB0aGlzLnZlcnRleF9sYXlvdXQgPSBuZXcgVmVydGV4TGF5b3V0KFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfcG9zaXRpb24nLCBzaXplOiAzLCB0eXBlOiBnbC5GTE9BVCwgbm9ybWFsaXplZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfdGV4Y29vcmQnLCBzaXplOiAyLCB0eXBlOiBnbC5GTE9BVCwgbm9ybWFsaXplZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfY29sb3InLCBzaXplOiA0LCB0eXBlOiBnbC5VTlNJR05FRF9CWVRFLCBub3JtYWxpemVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX3NlbGVjdGlvbl9jb2xvcicsIHNpemU6IDQsIHR5cGU6IGdsLlVOU0lHTkVEX0JZVEUsIG5vcm1hbGl6ZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfbGF5ZXInLCBzaXplOiAxLCB0eXBlOiBnbC5GTE9BVCwgbm9ybWFsaXplZDogZmFsc2UgfVxuICAgICAgICBdKTtcbiAgICB9LFxuXG4gICAgX3BhcnNlRmVhdHVyZSAoZmVhdHVyZSwgcnVsZV9zdHlsZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmZlYXR1cmVfc3R5bGU7XG4gICAgICAgIHN0eWxlLmNvbG9yID0gcnVsZV9zdHlsZS5jb2xvciAmJiBTdHlsZVBhcnNlci5wYXJzZUNvbG9yKHJ1bGVfc3R5bGUuY29sb3IsIGNvbnRleHQpO1xuICAgICAgICBzdHlsZS5zaXplID0gcnVsZV9zdHlsZS5zaXplICYmIFN0eWxlUGFyc2VyLnBhcnNlRGlzdGFuY2UocnVsZV9zdHlsZS5zaXplLCBjb250ZXh0KTtcbiAgICAgICAgc3R5bGUueiA9IChydWxlX3N0eWxlLnogJiYgU3R5bGVQYXJzZXIucGFyc2VEaXN0YW5jZShydWxlX3N0eWxlLnogfHwgMCwgY29udGV4dCkpIHx8IFN0eWxlUGFyc2VyLmRlZmF1bHRzLno7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSBcInRlbXBsYXRlXCIgdGhhdCBzZXRzIGNvbnN0YW50IGF0dGlidXRlcyBmb3IgZWFjaCB2ZXJ0ZXgsIHdoaWNoIGlzIHRoZW4gbW9kaWZpZWQgcGVyIHZlcnRleCBvciBwZXIgZmVhdHVyZS5cbiAgICAgKiBBIHBsYWluIEpTIGFycmF5IG1hdGNoaW5nIHRoZSBvcmRlciBvZiB0aGUgdmVydGV4IGxheW91dC5cbiAgICAgKi9cbiAgICBtYWtlVmVydGV4VGVtcGxhdGUoc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIC0geCAmIHkgY29vcmRzIHdpbGwgYmUgZmlsbGVkIGluIHBlci12ZXJ0ZXggYmVsb3dcbiAgICAgICAgICAgIDAsIDAsIHN0eWxlLnosXG4gICAgICAgICAgICAvLyB0ZXh0dXJlIGNvb3Jkc1xuICAgICAgICAgICAgMCwgMCxcbiAgICAgICAgICAgIC8vIGNvbG9yXG4gICAgICAgICAgICAvLyBUT0RPOiBhdXRvbWF0ZSBtdWx0aXBsaWNhdGlvbiBmb3Igbm9ybWFsaXplZCBhdHRyaWJzP1xuICAgICAgICAgICAgc3R5bGUuY29sb3JbMF0gKiAyNTUsIHN0eWxlLmNvbG9yWzFdICogMjU1LCBzdHlsZS5jb2xvclsyXSAqIDI1NSwgc3R5bGUuY29sb3JbM10gKiAyNTUsXG4gICAgICAgICAgICAvLyBzZWxlY3Rpb24gY29sb3JcbiAgICAgICAgICAgIHN0eWxlLnNlbGVjdGlvbl9jb2xvclswXSAqIDI1NSwgc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzFdICogMjU1LCBzdHlsZS5zZWxlY3Rpb25fY29sb3JbMl0gKiAyNTUsIHN0eWxlLnNlbGVjdGlvbl9jb2xvclszXSAqIDI1NSxcbiAgICAgICAgICAgIC8vIGRyYXcgb3JkZXJcbiAgICAgICAgICAgIHN0eWxlLm9yZGVyXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIGJ1aWxkUG9pbnRzKHBvaW50cywgc3R5bGUsIHZlcnRleF9kYXRhKSB7XG4gICAgICAgIGlmICghc3R5bGUuY29sb3IgfHwgIXN0eWxlLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2ZXJ0ZXhfdGVtcGxhdGUgPSB0aGlzLm1ha2VWZXJ0ZXhUZW1wbGF0ZShzdHlsZSk7XG5cbiAgICAgICAgQnVpbGRlcnMuYnVpbGRRdWFkc0ZvclBvaW50cyhcbiAgICAgICAgICAgIHBvaW50cyxcbiAgICAgICAgICAgIHN0eWxlLnNpemVbMF0gfHwgc3R5bGUuc2l6ZSxcbiAgICAgICAgICAgIHN0eWxlLnNpemVbMV0gfHwgc3R5bGUuc2l6ZSxcbiAgICAgICAgICAgIHZlcnRleF9kYXRhLFxuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlLFxuICAgICAgICAgICAgeyB0ZXhjb29yZF9pbmRleDogdGhpcy52ZXJ0ZXhfbGF5b3V0LmluZGV4LmFfdGV4Y29vcmQgfVxuICAgICAgICApO1xuXG4gICAgfVxuXG59KTtcbiIsIi8vIFBvbHlnb24gcmVuZGVyaW5nIHN0eWxlXG5cbmltcG9ydCB7U3R5bGV9IGZyb20gJy4uL3N0eWxlJztcbmltcG9ydCB7U3R5bGVQYXJzZXJ9IGZyb20gJy4uL3N0eWxlX3BhcnNlcic7XG5pbXBvcnQgZ2wgZnJvbSAnLi4vLi4vZ2wvY29uc3RhbnRzJzsgLy8gd2ViIHdvcmtlcnMgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gR0wgY29udGV4dCwgc28gaW1wb3J0IGFsbCBHTCBjb25zdGFudHNcbmltcG9ydCBWZXJ0ZXhMYXlvdXQgZnJvbSAnLi4vLi4vZ2wvdmVydGV4X2xheW91dCc7XG5pbXBvcnQgQnVpbGRlcnMgZnJvbSAnLi4vYnVpbGRlcnMnO1xuXG5leHBvcnQgdmFyIFBvbHlnb25zID0gT2JqZWN0LmNyZWF0ZShTdHlsZSk7XG5cbk9iamVjdC5hc3NpZ24oUG9seWdvbnMsIHtcbiAgICBuYW1lOiAncG9seWdvbnMnLFxuICAgIGJ1aWx0X2luOiB0cnVlLFxuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgU3R5bGUuaW5pdC5hcHBseSh0aGlzKTtcblxuICAgICAgICAvLyBCYXNlIHNoYWRlcnNcbiAgICAgICAgdGhpcy52ZXJ0ZXhfc2hhZGVyX2tleSA9ICdzdHlsZXMvcG9seWdvbnMvcG9seWdvbnMudmVydGV4JztcbiAgICAgICAgdGhpcy5mcmFnbWVudF9zaGFkZXJfa2V5ID0gJ3N0eWxlcy9wb2x5Z29ucy9wb2x5Z29ucy5mcmFnbWVudCc7XG5cbiAgICAgICAgLy8gRGVmYXVsdCB3b3JsZCBjb29yZHMgdG8gd3JhcCBldmVyeSAxMDAsMDAwIG1ldGVycywgY2FuIHR1cm4gb2ZmIGJ5IHNldHRpbmcgdGhpcyB0byAnZmFsc2UnXG4gICAgICAgIHRoaXMuZGVmaW5lc1snV09STERfUE9TSVRJT05fV1JBUCddID0gMTAwMDAwO1xuXG4gICAgICAgIC8vIFR1cm4gZmVhdHVyZSBzZWxlY3Rpb24gb25cbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0cnVlO1xuXG4gICAgICAgIC8vIEJhc2ljIGF0dHJpYnV0ZXMsIG90aGVycyBjYW4gYmUgYWRkZWQgKHNlZSB0ZXh0dXJlIFVWcyBiZWxvdylcbiAgICAgICAgdmFyIGF0dHJpYnMgPSBbXG4gICAgICAgICAgICB7IG5hbWU6ICdhX3Bvc2l0aW9uJywgc2l6ZTogMywgdHlwZTogZ2wuRkxPQVQsIG5vcm1hbGl6ZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX25vcm1hbCcsIHNpemU6IDMsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgLy8geyBuYW1lOiAnYV9ub3JtYWwnLCBzaXplOiAzLCB0eXBlOiBnbC5CWVRFLCBub3JtYWxpemVkOiB0cnVlIH0sIC8vIGF0dHJpYiBpc24ndCBhIG11bHRpcGxlIG9mIDQhXG4gICAgICAgICAgICAvLyB7IG5hbWU6ICdhX2NvbG9yJywgc2l6ZTogMywgdHlwZTogZ2wuRkxPQVQsIG5vcm1hbGl6ZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX2NvbG9yJywgc2l6ZTogNCwgdHlwZTogZ2wuVU5TSUdORURfQllURSwgbm9ybWFsaXplZDogdHJ1ZSB9LFxuICAgICAgICAgICAgLy8geyBuYW1lOiAnYV9zZWxlY3Rpb25fY29sb3InLCBzaXplOiA0LCB0eXBlOiBnbC5GTE9BVCwgbm9ybWFsaXplZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2Ffc2VsZWN0aW9uX2NvbG9yJywgc2l6ZTogNCwgdHlwZTogZ2wuVU5TSUdORURfQllURSwgbm9ybWFsaXplZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYV9sYXllcicsIHNpemU6IDEsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9XG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gT3B0aW9uYWwgdGV4dHVyZSBVVnNcbiAgICAgICAgaWYgKHRoaXMudGV4Y29vcmRzKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmluZXNbJ1RFWFRVUkVfQ09PUkRTJ10gPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBBZGQgdmVydGV4IGF0dHJpYnV0ZSBmb3IgVVZzIG9ubHkgd2hlbiBuZWVkZWRcbiAgICAgICAgICAgIGF0dHJpYnMucHVzaCh7IG5hbWU6ICdhX3RleGNvb3JkJywgc2l6ZTogMiwgdHlwZTogZ2wuRkxPQVQsIG5vcm1hbGl6ZWQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52ZXJ0ZXhfbGF5b3V0ID0gbmV3IFZlcnRleExheW91dChhdHRyaWJzKTtcbiAgICB9LFxuXG4gICAgX3BhcnNlRmVhdHVyZSAoZmVhdHVyZSwgcnVsZV9zdHlsZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmZlYXR1cmVfc3R5bGU7XG5cbiAgICAgICAgc3R5bGUuY29sb3IgPSBydWxlX3N0eWxlLmNvbG9yICYmIFN0eWxlUGFyc2VyLnBhcnNlQ29sb3IocnVsZV9zdHlsZS5jb2xvciwgY29udGV4dCk7XG4gICAgICAgIHN0eWxlLndpZHRoID0gcnVsZV9zdHlsZS53aWR0aCAmJiBTdHlsZVBhcnNlci5wYXJzZURpc3RhbmNlKHJ1bGVfc3R5bGUud2lkdGgsIGNvbnRleHQpO1xuICAgICAgICBzdHlsZS56ID0gKHJ1bGVfc3R5bGUueiAmJiBTdHlsZVBhcnNlci5wYXJzZURpc3RhbmNlKHJ1bGVfc3R5bGUueiB8fCAwLCBjb250ZXh0KSkgfHwgU3R5bGVQYXJzZXIuZGVmYXVsdHMuejtcblxuICAgICAgICBzdHlsZS50ZXh0dXJlID0gcnVsZV9zdHlsZS50ZXh0dXJlO1xuICAgICAgICBzdHlsZS5zcHJpdGUgPSBydWxlX3N0eWxlLnNwcml0ZTtcbiAgICAgICAgc3R5bGUuc2l6ZSA9IHJ1bGVfc3R5bGUuc2l6ZSAmJiBTdHlsZVBhcnNlci5wYXJzZURpc3RhbmNlKHJ1bGVfc3R5bGUuc2l6ZSwgY29udGV4dCk7XG5cbiAgICAgICAgLy8gaGVpZ2h0IGRlZmF1bHRzIHRvIGZlYXR1cmUgaGVpZ2h0LCBidXQgZXh0cnVkZSBzdHlsZSBjYW4gZHluYW1pY2FsbHkgYWRqdXN0IGhlaWdodCBieSByZXR1cm5pbmcgYSBudW1iZXIgb3IgYXJyYXkgKGluc3RlYWQgb2YgYSBib29sZWFuKVxuICAgICAgICBzdHlsZS5oZWlnaHQgPSBmZWF0dXJlLnByb3BlcnRpZXMuaGVpZ2h0IHx8IFN0eWxlUGFyc2VyLmRlZmF1bHRzLmhlaWdodDtcbiAgICAgICAgc3R5bGUubWluX2hlaWdodCA9IGZlYXR1cmUucHJvcGVydGllcy5taW5faGVpZ2h0IHx8IFN0eWxlUGFyc2VyLmRlZmF1bHRzLm1pbl9oZWlnaHQ7XG4gICAgICAgIHN0eWxlLmV4dHJ1ZGUgPSBydWxlX3N0eWxlLmV4dHJ1ZGU7XG4gICAgICAgIGlmIChzdHlsZS5leHRydWRlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlLmV4dHJ1ZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5leHRydWRlID0gc3R5bGUuZXh0cnVkZShjb250ZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZS5leHRydWRlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IHN0eWxlLmV4dHJ1ZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHN0eWxlLmV4dHJ1ZGUpKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUubWluX2hlaWdodCA9IHN0eWxlLmV4dHJ1ZGVbMF07XG4gICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gc3R5bGUuZXh0cnVkZVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlLmNhcCA9IHJ1bGVfc3R5bGUuY2FwO1xuICAgICAgICBzdHlsZS5qb2luID0gcnVsZV9zdHlsZS5qb2luO1xuXG4gICAgICAgIHN0eWxlLm91dGxpbmUgPSBzdHlsZS5vdXRsaW5lIHx8IHt9O1xuICAgICAgICBpZiAocnVsZV9zdHlsZS5vdXRsaW5lKSB7XG4gICAgICAgICAgICBzdHlsZS5vdXRsaW5lLmNvbG9yID0gU3R5bGVQYXJzZXIucGFyc2VDb2xvcihydWxlX3N0eWxlLm91dGxpbmUuY29sb3IsIGNvbnRleHQpO1xuICAgICAgICAgICAgc3R5bGUub3V0bGluZS53aWR0aCA9IFN0eWxlUGFyc2VyLnBhcnNlRGlzdGFuY2UocnVsZV9zdHlsZS5vdXRsaW5lLndpZHRoLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUudGlsZV9lZGdlcyA9IHJ1bGVfc3R5bGUub3V0bGluZS50aWxlX2VkZ2VzO1xuICAgICAgICAgICAgc3R5bGUub3V0bGluZS5jYXAgPSBydWxlX3N0eWxlLm91dGxpbmUuY2FwIHx8IHJ1bGVfc3R5bGUuY2FwO1xuICAgICAgICAgICAgc3R5bGUub3V0bGluZS5qb2luID0gcnVsZV9zdHlsZS5vdXRsaW5lLmpvaW4gfHwgcnVsZV9zdHlsZS5qb2luO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3R5bGUub3V0bGluZS5jb2xvciA9IG51bGw7XG4gICAgICAgICAgICBzdHlsZS5vdXRsaW5lLndpZHRoID0gbnVsbDtcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUudGlsZV9lZGdlcyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0cyB0ZXhjb29yZCBzY2FsZSBpZiBuZWVkZWQgKGUuZy4gZm9yIHNwcml0ZSBzdWItYXJlYSlcbiAgICAgICAgaWYgKHRoaXMudGV4Y29vcmRzKSB7XG4gICAgICAgICAgICB0aGlzLnNldFRleGNvb3JkU2NhbGUoc3R5bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIFwidGVtcGxhdGVcIiB0aGF0IHNldHMgY29uc3RhbnQgYXR0aWJ1dGVzIGZvciBlYWNoIHZlcnRleCwgd2hpY2ggaXMgdGhlbiBtb2RpZmllZCBwZXIgdmVydGV4IG9yIHBlciBmZWF0dXJlLlxuICAgICAqIEEgcGxhaW4gSlMgYXJyYXkgbWF0Y2hpbmcgdGhlIG9yZGVyIG9mIHRoZSB2ZXJ0ZXggbGF5b3V0LlxuICAgICAqL1xuICAgIG1ha2VWZXJ0ZXhUZW1wbGF0ZShzdHlsZSkge1xuICAgICAgICAvLyBQbGFjZWhvbGRlciB2YWx1ZXNcbiAgICAgICAgdmFyIGNvbG9yID0gc3R5bGUuY29sb3IgfHwgWzAsIDAsIDAsIDFdO1xuXG4gICAgICAgIC8vIEJhc2ljIGF0dHJpYnV0ZXMsIG90aGVycyBjYW4gYmUgYWRkZWQgKHNlZSB0ZXh0dXJlIFVWcyBiZWxvdylcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gW1xuICAgICAgICAgICAgLy8gcG9zaXRpb24gLSB4ICYgeSBjb29yZHMgd2lsbCBiZSBmaWxsZWQgaW4gcGVyLXZlcnRleCBiZWxvd1xuICAgICAgICAgICAgMCwgMCwgc3R5bGUueiB8fCAwLFxuICAgICAgICAgICAgLy8gbm9ybWFsXG4gICAgICAgICAgICAwLCAwLCAxLFxuICAgICAgICAgICAgLy8gY29sb3JcbiAgICAgICAgICAgIC8vIFRPRE86IGF1dG9tYXRlIG11bHRpcGxpY2F0aW9uIGZvciBub3JtYWxpemVkIGF0dHJpYnM/XG4gICAgICAgICAgICBjb2xvclswXSAqIDI1NSwgY29sb3JbMV0gKiAyNTUsIGNvbG9yWzJdICogMjU1LCBjb2xvclszXSAqIDI1NSxcbiAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBjb2xvclxuICAgICAgICAgICAgc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzBdICogMjU1LCBzdHlsZS5zZWxlY3Rpb25fY29sb3JbMV0gKiAyNTUsIHN0eWxlLnNlbGVjdGlvbl9jb2xvclsyXSAqIDI1NSwgc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzNdICogMjU1LFxuICAgICAgICAgICAgLy8gZHJhdyBvcmRlclxuICAgICAgICAgICAgc3R5bGUub3JkZXJcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBBZGQgdGV4dHVyZSBVVnMgdG8gdGVtcGxhdGUgb25seSBpZiBuZWVkZWRcbiAgICAgICAgaWYgKHRoaXMudGV4Y29vcmRzKSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZS5wdXNoKDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuXG4gICAgfSxcblxuICAgIGJ1aWxkUG9seWdvbnMocG9seWdvbnMsIHN0eWxlLCB2ZXJ0ZXhfZGF0YSkge1xuICAgICAgICB2YXIgdmVydGV4X3RlbXBsYXRlID0gdGhpcy5tYWtlVmVydGV4VGVtcGxhdGUoc3R5bGUpO1xuXG4gICAgICAgIC8vIFBvbHlnb24gZmlsbFxuICAgICAgICBpZiAoc3R5bGUuY29sb3IpIHtcbiAgICAgICAgICAgIC8vIEV4dHJ1ZGVkIHBvbHlnb25zIChlLmcuIDNEIGJ1aWxkaW5ncylcbiAgICAgICAgICAgIGlmIChzdHlsZS5leHRydWRlICYmIHN0eWxlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIEJ1aWxkZXJzLmJ1aWxkRXh0cnVkZWRQb2x5Z29ucyhcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbnMsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnosIHN0eWxlLmhlaWdodCwgc3R5bGUubWluX2hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhfbGF5b3V0LmluZGV4LmFfbm9ybWFsLFxuICAgICAgICAgICAgICAgICAgICB7IHRleGNvb3JkX2luZGV4OiB0aGlzLnZlcnRleF9sYXlvdXQuaW5kZXguYV90ZXhjb29yZCwgdGV4Y29vcmRfc2NhbGU6IHRoaXMudGV4Y29vcmRfc2NhbGUgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZWd1bGFyIHBvbHlnb25zXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBCdWlsZGVycy5idWlsZFBvbHlnb25zKFxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29ucyxcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgeyB0ZXhjb29yZF9pbmRleDogdGhpcy52ZXJ0ZXhfbGF5b3V0LmluZGV4LmFfdGV4Y29vcmQsIHRleGNvb3JkX3NjYWxlOiB0aGlzLnRleGNvb3JkX3NjYWxlIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUG9seWdvbiBvdXRsaW5lc1xuICAgICAgICBpZiAoc3R5bGUub3V0bGluZSAmJiBzdHlsZS5vdXRsaW5lLmNvbG9yICYmIHN0eWxlLm91dGxpbmUud2lkdGgpIHtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgY29sb3IgaW4gdmVydGV4IHRlbXBsYXRlXG4gICAgICAgICAgICB2YXIgY29sb3JfaW5kZXggPSB0aGlzLnZlcnRleF9sYXlvdXQuaW5kZXguYV9jb2xvcjtcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtjb2xvcl9pbmRleCArIDBdID0gc3R5bGUub3V0bGluZS5jb2xvclswXSAqIDI1NTtcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtjb2xvcl9pbmRleCArIDFdID0gc3R5bGUub3V0bGluZS5jb2xvclsxXSAqIDI1NTtcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtjb2xvcl9pbmRleCArIDJdID0gc3R5bGUub3V0bGluZS5jb2xvclsyXSAqIDI1NTtcblxuICAgICAgICAgICAgLy8gUG9seWdvbiBvdXRsaW5lcyBzaXQgb3ZlciBjdXJyZW50IGxheWVyIGJ1dCB1bmRlcm5lYXRoIHRoZSBvbmUgYWJvdmVcbiAgICAgICAgICAgIC8vIFRPRE86IGFkZHJlc3MgaW5jb25zaXN0ZW5jeSB3aXRoIGxpbmUgb3V0bGluZXNcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVt0aGlzLnZlcnRleF9sYXlvdXQuaW5kZXguYV9sYXllcl0gKz0gMC4wMDAxO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBtcGM9MDsgbXBjIDwgcG9seWdvbnMubGVuZ3RoOyBtcGMrKykge1xuICAgICAgICAgICAgICAgIEJ1aWxkZXJzLmJ1aWxkUG9seWxpbmVzKFxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uc1ttcGNdLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZS5vdXRsaW5lLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhfZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luOiBzdHlsZS5vdXRsaW5lLmpvaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXhjb29yZF9pbmRleDogdGhpcy52ZXJ0ZXhfbGF5b3V0LmluZGV4LmFfdGV4Y29vcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXhjb29yZF9zY2FsZTogdGhpcy50ZXhjb29yZF9zY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlZF9wb2x5Z29uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlX3RpbGVfZWRnZXM6ICFzdHlsZS5vdXRsaW5lLnRpbGVfZWRnZXNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYnVpbGRMaW5lcyhsaW5lcywgc3R5bGUsIHZlcnRleF9kYXRhKSB7XG4gICAgICAgIHZhciB2ZXJ0ZXhfdGVtcGxhdGUgPSB0aGlzLm1ha2VWZXJ0ZXhUZW1wbGF0ZShzdHlsZSk7XG5cbiAgICAgICAgLy8gTWFpbiBsaW5lXG4gICAgICAgIGlmIChzdHlsZS5jb2xvciAmJiBzdHlsZS53aWR0aCkge1xuICAgICAgICAgICAgQnVpbGRlcnMuYnVpbGRQb2x5bGluZXMoXG4gICAgICAgICAgICAgICAgbGluZXMsXG4gICAgICAgICAgICAgICAgc3R5bGUud2lkdGgsXG4gICAgICAgICAgICAgICAgdmVydGV4X2RhdGEsXG4gICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2FwOiBzdHlsZS5jYXAsXG4gICAgICAgICAgICAgICAgICAgIGpvaW46IHN0eWxlLmpvaW4sXG4gICAgICAgICAgICAgICAgICAgIHRleGNvb3JkX2luZGV4OiB0aGlzLnZlcnRleF9sYXlvdXQuaW5kZXguYV90ZXhjb29yZCxcbiAgICAgICAgICAgICAgICAgICAgdGV4Y29vcmRfc2NhbGU6IHRoaXMudGV4Y29vcmRfc2NhbGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3V0bGluZVxuICAgICAgICBpZiAoc3R5bGUub3V0bGluZSAmJiBzdHlsZS5vdXRsaW5lLmNvbG9yICYmIHN0eWxlLm91dGxpbmUud2lkdGgpIHtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgY29sb3IgaW4gdmVydGV4IHRlbXBsYXRlXG4gICAgICAgICAgICB2YXIgY29sb3JfaW5kZXggPSB0aGlzLnZlcnRleF9sYXlvdXQuaW5kZXguYV9jb2xvcjtcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtjb2xvcl9pbmRleCArIDBdID0gc3R5bGUub3V0bGluZS5jb2xvclswXSAqIDI1NTtcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtjb2xvcl9pbmRleCArIDFdID0gc3R5bGUub3V0bGluZS5jb2xvclsxXSAqIDI1NTtcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVtjb2xvcl9pbmRleCArIDJdID0gc3R5bGUub3V0bGluZS5jb2xvclsyXSAqIDI1NTtcblxuICAgICAgICAgICAgLy8gTGluZSBvdXRsaW5lcyBzaXQgdW5kZXJuZWF0aCBjdXJyZW50IGxheWVyIGJ1dCBhYm92ZSB0aGUgb25lIGJlbG93XG4gICAgICAgICAgICAvLyBUT0RPOiBhZGRyZXNzIGluY29uc2lzdGVuY3kgd2l0aCBwb2x5Z29uIG91dGxpbmVzXG4gICAgICAgICAgICAvLyBUT0RPOiBuZWVkIG1vcmUgZmluZS1ncmFpbmVkIHN0eWxpbmcgY29udHJvbHMgZm9yIG91dGxpbmVzXG4gICAgICAgICAgICAvLyAoc2VlIGNvbXBsZXggcm9hZCBpbnRlcmNoYW5nZXMgd2hlcmUgY2FzaW5nIG91dGxpbmVzIHNob3VsZCBiZSBpbnRlcmxlYXZlZCBieSByb2FkIHR5cGUpXG4gICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGhpcy52ZXJ0ZXhfbGF5b3V0LmluZGV4LmFfbGF5ZXJdIC09IDAuMDAwMTtcblxuICAgICAgICAgICAgQnVpbGRlcnMuYnVpbGRQb2x5bGluZXMoXG4gICAgICAgICAgICAgICAgbGluZXMsXG4gICAgICAgICAgICAgICAgc3R5bGUud2lkdGggKyAyICogc3R5bGUub3V0bGluZS53aWR0aCxcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfZGF0YSxcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGUsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjYXA6IHN0eWxlLm91dGxpbmUuY2FwLFxuICAgICAgICAgICAgICAgICAgICBqb2luOiBzdHlsZS5vdXRsaW5lLmpvaW4sXG4gICAgICAgICAgICAgICAgICAgIHRleGNvb3JkX2luZGV4OiB0aGlzLnZlcnRleF9sYXlvdXQuaW5kZXguYV90ZXhjb29yZCxcbiAgICAgICAgICAgICAgICAgICAgdGV4Y29vcmRfc2NhbGU6IHRoaXMudGV4Y29vcmRfc2NhbGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGJ1aWxkUG9pbnRzKHBvaW50cywgc3R5bGUsIHZlcnRleF9kYXRhKSB7XG4gICAgICAgIGlmICghc3R5bGUuY29sb3IgfHwgIXN0eWxlLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2ZXJ0ZXhfdGVtcGxhdGUgPSB0aGlzLm1ha2VWZXJ0ZXhUZW1wbGF0ZShzdHlsZSk7XG5cbiAgICAgICAgQnVpbGRlcnMuYnVpbGRRdWFkc0ZvclBvaW50cyhcbiAgICAgICAgICAgIHBvaW50cyxcbiAgICAgICAgICAgIHN0eWxlLnNpemVbMF0gfHwgc3R5bGUuc2l6ZSxcbiAgICAgICAgICAgIHN0eWxlLnNpemVbMV0gfHwgc3R5bGUuc2l6ZSxcbiAgICAgICAgICAgIHZlcnRleF9kYXRhLFxuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlLFxuICAgICAgICAgICAgeyB0ZXhjb29yZF9pbmRleDogdGhpcy52ZXJ0ZXhfbGF5b3V0LmluZGV4LmFfdGV4Y29vcmQsIHRleGNvb3JkX3NjYWxlOiB0aGlzLnRleGNvb3JkX3NjYWxlIH1cbiAgICAgICAgKTtcblxuICAgIH1cblxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCB7bWF0Y2h9ID0gcmVxdWlyZSgnbWF0Y2gtZmVhdHVyZScpO1xuXG5leHBvcnQgY29uc3Qgd2hpdGVMaXN0ID0gWydmaWx0ZXInLCAnc3R5bGUnLCAnZ2VvbWV0cnknLCAncHJvcGVydGllcyddO1xuXG5leHBvcnQgbGV0IHJ1bGVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBjYWNoZUtleSAocnVsZXMpIHtcbiAgICByZXR1cm4gcnVsZXMubWFwKHIgPT4gci5pZCkuam9pbignLycpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VUcmVlcyhtYXRjaGluZ1RyZWVzLCBjb250ZXh0KSB7XG4gICAgbGV0IHN0eWxlID0ge307XG4gICAgbGV0IGRlZXBlc3RPcmRlciwgb3JkZXJSZXNldDtcbiAgICBsZXQgdmlzaWJsZTtcblxuICAgIC8vIEZpbmQgZGVlcGVzdCB0cmVlXG4gICAgbWF0Y2hpbmdUcmVlcy5zb3J0KChhLCBiKSA9PiBhLmxlbmd0aCA+IGIubGVuZ3RoID8gLTEgOiAoYi5sZW5ndGggPiBhLmxlbmd0aCA/IDEgOiAwKSk7XG4gICAgbGV0IGxlbiA9IG1hdGNoaW5nVHJlZXNbMF0ubGVuZ3RoO1xuXG4gICAgLy8gSXRlcmF0ZSB0cmVlcyBpbiBwYXJhbGxlbFxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgbGVuOyB4KyspIHtcbiAgICAgICAgbGV0IHN0eWxlcyA9IG1hdGNoaW5nVHJlZXMubWFwKHRyZWUgPT4gdHJlZVt4XSk7XG4gICAgICAgIG1lcmdlT2JqZWN0cyhzdHlsZSwgLi4uc3R5bGVzKTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVzW2ldKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGB2aXNpYmxlYCBwcm9wZXJ0eSBpcyBvbmx5IHRydWUgaWYgYWxsIG1hdGNoaW5nIHJ1bGVzIGFyZSB2aXNpYmxlXG4gICAgICAgICAgICBpZiAoc3R5bGVzW2ldLnZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2aXNpYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBub3RlIG9mIHRoZSBzdHlsZSBwb3NpdGlvbnMgb2Ygb3JkZXItcmVsYXRlZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBpZiAoc3R5bGVzW2ldLm9yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZWVwZXN0T3JkZXIgPSBpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3R5bGVzW2ldLm9yZGVyUmVzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9yZGVyUmVzZXQgPSB4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZpc2libGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzdHlsZS52aXNpYmxlID0gdmlzaWJsZTtcblxuICAgIC8vIE9yZGVyIG11c3QgYmUgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgZGVlcGVzdCB0cmVlIHRoYXQgaGFkIGFuIG9yZGVyIHByb3BlcnR5XG4gICAgaWYgKGRlZXBlc3RPcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBvcmRlclRyZWUgPSBtYXRjaGluZ1RyZWVzW2RlZXBlc3RPcmRlcl07XG5cbiAgICAgICAgaWYgKG9yZGVyVHJlZS5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgc3R5bGUub3JkZXIgPSBvcmRlclRyZWVbMF0ub3JkZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5vcmRlciA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IG9yZGVyUmVzZXQgfHwgMDsgeCA8IG9yZGVyVHJlZS5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGlmIChvcmRlclRyZWVbeF0gJiYgb3JkZXJUcmVlW3hdLm9yZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLm9yZGVyLnB1c2gob3JkZXJUcmVlW3hdLm9yZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9yZGVyIGNhbiBiZSBjYWNoZWQgaWYgaXQgaXMgb25seSBhIHNpbmdsZSB2YWx1ZVxuICAgICAgICAgICAgaWYgKHN0eWxlLm9yZGVyLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2Ygc3R5bGUub3JkZXJbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUub3JkZXIgPSBzdHlsZS5vcmRlclswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9yIGlmIHRoZXJlIGFyZSBubyBmdW5jdGlvbiBkZXBlbmRlbmNpZXNcbiAgICAgICAgICAgIGVsc2UgaWYgKCFzdHlsZS5vcmRlci5zb21lKHYgPT4gdHlwZW9mIHYgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUub3JkZXIgPSBjYWxjdWxhdGVPcmRlcihzdHlsZS5vcmRlciwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG59XG5cblxuY2xhc3MgUnVsZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwYXJlbnQsIHN0eWxlLCBmaWx0ZXIsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgdGhpcy5pZCA9IFJ1bGUuaWQrKztcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB0aGlzLmZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuYnVpbGRGaWx0ZXIoKTtcbiAgICAgICAgdGhpcy5idWlsZFN0eWxlKCk7XG4gICAgfVxuXG4gICAgYnVpbGRTdHlsZSgpIHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVkU3R5bGUgPSBjYWxjdWxhdGVTdHlsZSh0aGlzKTtcbiAgICB9XG5cbiAgICBidWlsZEZpbHRlcigpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdGhpcy5maWx0ZXI7XG4gICAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXIgPSBtYXRjaCh0aGlzLmZpbHRlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBzeXRsZTogdGhpcy5zdHlsZVxuICAgICAgICB9O1xuICAgIH1cblxufVxuXG5SdWxlLmlkID0gMDtcblxuXG5leHBvcnQgY2xhc3MgUnVsZUxlYWYgZXh0ZW5kcyBSdWxlIHtcbiAgICBjb25zdHJ1Y3Rvcih7bmFtZSwgcGFyZW50LCBzdHlsZSwgZmlsdGVyLCBwcm9wZXJ0aWVzfSkge1xuICAgICAgICBzdXBlcihuYW1lLCBwYXJlbnQsIHN0eWxlLCBmaWx0ZXIsIHByb3BlcnRpZXMpO1xuICAgIH1cblxufVxuXG5leHBvcnQgY2xhc3MgUnVsZVRyZWUgZXh0ZW5kcyBSdWxlIHtcbiAgICBjb25zdHJ1Y3Rvcih7bmFtZSwgcGFyZW50LCBzdHlsZSwgcnVsZXMsIGZpbHRlciwgcHJvcGVydGllc30pIHtcbiAgICAgICAgc3VwZXIobmFtZSwgcGFyZW50LCBzdHlsZSwgZmlsdGVyLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzIHx8IFtdO1xuICAgIH1cblxuICAgIGFkZFJ1bGUocnVsZSkge1xuICAgICAgICB0aGlzLnJ1bGVzLnB1c2gocnVsZSk7XG4gICAgfVxuXG4gICAgZmluZE1hdGNoaW5nUnVsZXMoY29udGV4dCkge1xuICAgICAgICBsZXQgcnVsZXMgID0gW107XG4gICAgICAgIC8vVE9ETywgc2hvdWxkIHRoaXMgZnVuY3Rpb24gdGFrZSBhIFJ1bGVUcmVlXG4gICAgICAgIG1hdGNoRmVhdHVyZShjb250ZXh0LCBbdGhpc10sIHJ1bGVzKTtcblxuICAgICAgICBpZiAocnVsZXMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICBsZXQga2V5ID0gY2FjaGVLZXkocnVsZXMpO1xuICAgICAgICAgICAgaWYgKCFydWxlQ2FjaGVba2V5XSkge1xuICAgICAgICAgICAgICAgIHJ1bGVDYWNoZVtrZXldID0gbWVyZ2VUcmVlcyhydWxlcy5tYXAoeCA9PiB4ICYmIHguY2FsY3VsYXRlZFN0eWxlKSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVsZUNhY2hlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gaXNXaGl0ZUxpc3RlZChrZXkpIHtcbiAgICByZXR1cm4gd2hpdGVMaXN0LmluZGV4T2Yoa2V5KSA+IC0xO1xufVxuXG5mdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhbGtVcChydWxlLCBjYikge1xuXG4gICAgaWYgKHJ1bGUucGFyZW50KSB7XG4gICAgICAgIHdhbGtVcChydWxlLnBhcmVudCwgY2IpO1xuICAgIH1cblxuICAgIGNiKHJ1bGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2Fsa0Rvd24ocnVsZSwgY2IpIHtcblxuICAgIGlmIChydWxlLnJ1bGVzKSB7XG4gICAgICAgIHJ1bGUucnVsZXMuZm9yRWFjaCgocikgPT4ge1xuICAgICAgICAgICAgd2Fsa0Rvd24ociwgY2IpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjYihydWxlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwUHJvcHMob2JqKSB7XG4gICAgbGV0IHdoaXRlTGlzdGVkID0ge30sIG5vbldoaXRlTGlzdGVkID0ge307XG5cbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChpc1doaXRlTGlzdGVkKGtleSkpIHtcbiAgICAgICAgICAgIHdoaXRlTGlzdGVkW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vbldoaXRlTGlzdGVkW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3doaXRlTGlzdGVkLCBub25XaGl0ZUxpc3RlZF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVTdHlsZShydWxlKSB7XG5cbiAgICBsZXQgc3R5bGVzICA9IFtdO1xuXG4gICAgaWYgKHJ1bGUucGFyZW50KSB7XG4gICAgICAgIGxldCBjcyA9IHJ1bGUucGFyZW50LmNhbGN1bGF0ZWRTdHlsZSB8fCBbXTtcbiAgICAgICAgc3R5bGVzLnB1c2goLi4uY3MpO1xuICAgIH1cblxuICAgIHN0eWxlcy5wdXNoKHJ1bGUuc3R5bGUpO1xuICAgIHJldHVybiBzdHlsZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZU9iamVjdHMobmV3T2JqLCAuLi5zb3VyY2VzKSB7XG5cbiAgICBmb3IgKGxldCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IG1lcmdlT2JqZWN0cyhuZXdPYmpba2V5XSB8fCB7fSwgdmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gICAgcmV0dXJuIG5ld09iajtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZU9yZGVyKG9yZGVycywgY29udGV4dCA9IG51bGwsIGRlZmF1bHRPcmRlciA9IDApIHtcbiAgICBsZXQgc3VtID0gZGVmYXVsdE9yZGVyO1xuXG4gICAgZm9yIChsZXQgb3JkZXIgb2Ygb3JkZXJzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3JkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9yZGVyID0gb3JkZXIoY29udGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcmRlciA9IHBhcnNlRmxvYXQob3JkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcmRlciB8fCBpc05hTihvcmRlcikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHN1bSArPSBvcmRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSdWxlVHJlZShuYW1lLCBydWxlLCBwYXJlbnQpIHtcblxuICAgIGxldCBwcm9wZXJ0aWVzID0ge25hbWUsIHBhcmVudH07XG4gICAgbGV0IFt3aGl0ZUxpc3RlZCwgbm9uV2hpdGVMaXN0ZWRdID0gZ3JvdXBQcm9wcyhydWxlKTtcbiAgICBsZXQgZW1wdHkgPSBpc0VtcHR5KG5vbldoaXRlTGlzdGVkKTtcbiAgICBsZXQgQ3JlYXRlO1xuXG4gICAgaWYgKGVtcHR5ICYmIHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIENyZWF0ZSA9IFJ1bGVMZWFmO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIENyZWF0ZSA9IFJ1bGVUcmVlO1xuICAgIH1cblxuICAgIGxldCByID0gbmV3IENyZWF0ZShPYmplY3QuYXNzaWduKHByb3BlcnRpZXMsIHdoaXRlTGlzdGVkKSk7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5hZGRSdWxlKHIpO1xuICAgIH1cblxuICAgIGlmICghZW1wdHkpIHtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIG5vbldoaXRlTGlzdGVkKSB7XG4gICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBub25XaGl0ZUxpc3RlZFtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBwYXJzZVJ1bGVUcmVlKGtleSwgcHJvcGVydHksIHIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQcm9wZXJ0eSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSdWxlcyhydWxlcykge1xuICAgIGxldCBydWxlVHJlZXMgPSB7fTtcblxuICAgIGZvciAobGV0IGtleSBpbiBydWxlcykge1xuICAgICAgICBsZXQgcnVsZSA9IHJ1bGVzW2tleV07XG4gICAgICAgIHJ1bGVUcmVlc1trZXldID0gcGFyc2VSdWxlVHJlZShrZXksIHJ1bGUpO1xuICAgIH1cblxuICAgIHJldHVybiBydWxlVHJlZXM7XG59XG5cblxuZnVuY3Rpb24gZG9lc01hdGNoKGZpbHRlciwgY29udGV4dCkge1xuICAgIHJldHVybiAoKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgJiYgZmlsdGVyKGNvbnRleHQpKSB8fCAoZmlsdGVyID09IG51bGwpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoRmVhdHVyZShjb250ZXh0LCBydWxlcywgY29sbGVjdGVkUnVsZXMpIHtcbiAgICBsZXQgbWF0Y2hlZCA9IGZhbHNlO1xuICAgIGxldCBjaGlsZE1hdGNoZWQgPSBmYWxzZTtcblxuICAgIGlmIChydWxlcy5sZW5ndGggPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgICBmb3IgKGxldCByPTA7IHIgPCBydWxlcy5sZW5ndGg7IHIrKykge1xuICAgICAgICBsZXQgY3VycmVudCA9IHJ1bGVzW3JdO1xuICAgICAgICBjb250ZXh0LnByb3BlcnRpZXMgPSBjdXJyZW50LnByb3BlcnRpZXM7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBSdWxlTGVhZikge1xuXG4gICAgICAgICAgICBpZiAoZG9lc01hdGNoKGN1cnJlbnQuZmlsdGVyLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbGxlY3RlZFJ1bGVzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50IGluc3RhbmNlb2YgUnVsZVRyZWUpIHtcbiAgICAgICAgICAgIGlmIChkb2VzTWF0Y2goY3VycmVudC5maWx0ZXIsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBjaGlsZE1hdGNoZWQgPSBtYXRjaEZlYXR1cmUoXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQucnVsZXMsXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZFJ1bGVzXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGlmICghY2hpbGRNYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZFJ1bGVzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5wcm9wZXJ0aWVzID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlZDtcbn1cbiIsIi8vIFNwcml0ZSByZW5kZXJpbmcgc3R5bGVcblxuaW1wb3J0IHtTdHlsZX0gZnJvbSAnLi4vc3R5bGUnO1xuaW1wb3J0IHtTdHlsZVBhcnNlcn0gZnJvbSAnLi4vc3R5bGVfcGFyc2VyJztcbmltcG9ydCBnbCBmcm9tICcuLi8uLi9nbC9jb25zdGFudHMnOyAvLyB3ZWIgd29ya2VycyBkb24ndCBoYXZlIGFjY2VzcyB0byBHTCBjb250ZXh0LCBzbyBpbXBvcnQgYWxsIEdMIGNvbnN0YW50c1xuaW1wb3J0IFZlcnRleExheW91dCBmcm9tICcuLi8uLi9nbC92ZXJ0ZXhfbGF5b3V0JztcbmltcG9ydCBCdWlsZGVycyBmcm9tICcuLi9idWlsZGVycyc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMnO1xuXG5cbmV4cG9ydCB2YXIgU3ByaXRlcyA9IE9iamVjdC5jcmVhdGUoU3R5bGUpO1xuXG5PYmplY3QuYXNzaWduKFNwcml0ZXMsIHtcbiAgICBuYW1lOiAnc3ByaXRlcycsXG4gICAgYnVpbHRfaW46IHRydWUsXG4gICAgc2VsZWN0aW9uOiB0cnVlLFxuXG4gICAgaW5pdCgpIHtcbiAgICAgICAgU3R5bGUuaW5pdC5hcHBseSh0aGlzKTtcblxuICAgICAgICAvLyBCYXNlIHNoYWRlcnNcbiAgICAgICAgdGhpcy52ZXJ0ZXhfc2hhZGVyX2tleSA9ICdzdHlsZXMvc3ByaXRlcy9zcHJpdGVzX3ZlcnRleCc7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRfc2hhZGVyX2tleSA9ICdzdHlsZXMvc3ByaXRlcy9zcHJpdGVzX2ZyYWdtZW50JztcblxuICAgICAgICB0aGlzLmJsZW5kID0gJ292ZXJsYXknOyAvLyBvdmVybGF5cyBkcmF3biBvbiB0b3Agb2YgYWxsIG90aGVyIHN0eWxlcywgd2l0aCBibGVuZGluZ1xuXG4gICAgICAgIHZhciBhdHRyaWJzID0gW1xuICAgICAgICAgICAgeyBuYW1lOiAnYV9wb3NpdGlvbicsIHNpemU6IDMsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYV9zaGFwZScsIHNpemU6IDQsIHR5cGU6IGdsLlNIT1JULCBub3JtYWxpemVkOiB0cnVlIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdhX3NlbGVjdGlvbl9jb2xvcicsIHNpemU6IDQsIHR5cGU6IGdsLlVOU0lHTkVEX0JZVEUsIG5vcm1hbGl6ZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfdGV4Y29vcmQnLCBzaXplOiAyLCB0eXBlOiBnbC5GTE9BVCwgbm9ybWFsaXplZDogZmFsc2UgfSwgLy8gVE9ETzogcGFjayBpbnRvIHNob3J0c1xuICAgICAgICAgICAgeyBuYW1lOiAnYV9sYXllcicsIHNpemU6IDEsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9XG4gICAgICAgIF07XG4gICAgICAgIHRoaXMudmVydGV4X2xheW91dCA9IG5ldyBWZXJ0ZXhMYXlvdXQoYXR0cmlicyk7XG4gICAgfSxcblxuICAgIF9wYXJzZUZlYXR1cmUgKGZlYXR1cmUsIHJ1bGVfc3R5bGUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5mZWF0dXJlX3N0eWxlO1xuXG4gICAgICAgIGxldCB0aWxlID0gY29udGV4dC50aWxlLmtleTtcblxuICAgICAgICBzdHlsZS56ID0gKHJ1bGVfc3R5bGUueiAmJiBTdHlsZVBhcnNlci5wYXJzZURpc3RhbmNlKHJ1bGVfc3R5bGUueiB8fCAwLCBjb250ZXh0KSkgfHwgU3R5bGVQYXJzZXIuZGVmYXVsdHMuejtcbiAgICAgICAgc3R5bGUudGV4dHVyZSA9IHJ1bGVfc3R5bGUudGV4dHVyZTtcbiAgICAgICAgc3R5bGUuc3ByaXRlID0gcnVsZV9zdHlsZS5zcHJpdGU7XG5cbiAgICAgICAgLy8gc3ByaXRlIHN0eWxlIG9ubHkgc3VwcG9ydHMgc2l6ZXMgaW4gcGl4ZWwgdW5pdHMsIHNvIHVuaXQgY29udmVyc2lvbiBmbGFnIGlzIG9mZlxuICAgICAgICBzdHlsZS5zaXplID0gcnVsZV9zdHlsZS5zaXplICYmIFN0eWxlUGFyc2VyLnBhcnNlRGlzdGFuY2UocnVsZV9zdHlsZS5zaXplLCBjb250ZXh0LCBmYWxzZSk7XG5cbiAgICAgICAgLy8gc2NhbGUgc2l6ZSB0byAxNi1iaXQgc2lnbmVkIGludCwgd2l0aCBhIG1heCBhbGxvd2VkIHdpZHRoICsgaGVpZ2h0IG9mIDEyOCBwaXhlbHNcbiAgICAgICAgc3R5bGUuc2l6ZSA9IFtcbiAgICAgICAgICAgIE1hdGgubWluKChzdHlsZS5zaXplWzBdIHx8IHN0eWxlLnNpemUpLCAyNTYpLFxuICAgICAgICAgICAgTWF0aC5taW4oKHN0eWxlLnNpemVbMV0gfHwgc3R5bGUuc2l6ZSksIDI1NilcbiAgICAgICAgXTtcblxuICAgICAgICBzdHlsZS5hbmdsZSA9IHJ1bGVfc3R5bGUuYW5nbGUgfHwgMDtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHlsZS5hbmdsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3R5bGUuYW5nbGUgPSBzdHlsZS5hbmdsZShjb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZhY3RvciBieSB3aGljaCBzcHJpdGVzIHNjYWxlcyBmcm9tIGN1cnJlbnQgem9vbSBsZXZlbCB0byBuZXh0IHpvb20gbGV2ZWxcbiAgICAgICAgc3R5bGUuc2NhbGUgPSBydWxlX3N0eWxlLnNjYWxlIHx8IDE7XG5cbiAgICAgICAgLy8gdG8gc3RvcmUgYmJveCBieSB0aWxlc1xuICAgICAgICBzdHlsZS50aWxlID0gdGlsZTtcblxuICAgICAgICB0aGlzLnNldFRleGNvb3JkU2NhbGUoc3R5bGUpO1xuXG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSBcInRlbXBsYXRlXCIgdGhhdCBzZXRzIGNvbnN0YW50IGF0dGlidXRlcyBmb3IgZWFjaCB2ZXJ0ZXgsIHdoaWNoIGlzIHRoZW4gbW9kaWZpZWQgcGVyIHZlcnRleCBvciBwZXIgZmVhdHVyZS5cbiAgICAgKiBBIHBsYWluIEpTIGFycmF5IG1hdGNoaW5nIHRoZSBvcmRlciBvZiB0aGUgdmVydGV4IGxheW91dC5cbiAgICAgKi9cbiAgICBtYWtlVmVydGV4VGVtcGxhdGUoc3R5bGUpIHtcbiAgICAgICAgLy8gQmFzaWMgYXR0cmlidXRlcywgb3RoZXJzIGNhbiBiZSBhZGRlZCAoc2VlIHRleHR1cmUgVVZzIGJlbG93KVxuICAgICAgICB2YXIgdGVtcGxhdGUgPSBbXG4gICAgICAgICAgICAvLyBwb3NpdGlvbiAtICh4LCB5KSBjb29yZHMgd2lsbCBiZSBmaWxsZWQgaW4gcGVyLXZlcnRleCBiZWxvd1xuICAgICAgICAgICAgMCwgMCwgc3R5bGUueiB8fCAwLFxuICAgICAgICAgICAgLy8gc2NhbGluZyB2ZWN0b3IgLSAoeCwgeSkgY29tcG9uZW50cyBwZXIgcGl4ZWwsIHogPSBhbmdsZSwgdyA9IHNjYWxpbmcgZmFjdG9yXG4gICAgICAgICAgICAwLCAwLCAwLCAwLFxuICAgICAgICAgICAgLy8gc2VsZWN0aW9uIGNvbG9yXG4gICAgICAgICAgICBzdHlsZS5zZWxlY3Rpb25fY29sb3JbMF0gKiAyNTUsIHN0eWxlLnNlbGVjdGlvbl9jb2xvclsxXSAqIDI1NSwgc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzJdICogMjU1LCBzdHlsZS5zZWxlY3Rpb25fY29sb3JbM10gKiAyNTUsXG4gICAgICAgICAgICAvLyB0ZXh0dXJlIGNvb3Jkc1xuICAgICAgICAgICAgMCwgMCxcbiAgICAgICAgICAgIC8vIGRyYXcgb3JkZXJcbiAgICAgICAgICAgIHN0eWxlLm9yZGVyXG4gICAgICAgIF07XG5cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH0sXG5cbiAgICBidWlsZFBvaW50cyAocG9pbnRzLCBzdHlsZSwgdmVydGV4X2RhdGEpIHtcbiAgICAgICAgaWYgKCFzdHlsZS5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmVydGV4X3RlbXBsYXRlID0gdGhpcy5tYWtlVmVydGV4VGVtcGxhdGUoc3R5bGUpO1xuXG4gICAgICAgIGxldCBzaXplID0gc3R5bGUuc2l6ZTtcbiAgICAgICAgbGV0IGFuZ2xlID0gc3R5bGUuYW5nbGU7XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IHBvaW50c1swXTtcblxuICAgICAgICBCdWlsZGVycy5idWlsZFNwcml0ZVF1YWRzRm9yUG9pbnRzKFxuICAgICAgICAgICAgWyBwb3NpdGlvbiBdLFxuICAgICAgICAgICAgVXRpbHMuc2NhbGVJbnQxNihzaXplWzBdLCAxMjgpLCBVdGlscy5zY2FsZUludDE2KHNpemVbMV0sIDEyOCksXG4gICAgICAgICAgICBVdGlscy5zY2FsZUludDE2KFV0aWxzLnJhZFRvRGVnKGFuZ2xlKSwgMzYwKSxcbiAgICAgICAgICAgIFV0aWxzLnNjYWxlSW50MTYoc3R5bGUuc2NhbGUsIDI1NiksXG4gICAgICAgICAgICB2ZXJ0ZXhfZGF0YSxcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZSxcbiAgICAgICAgICAgIHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX3NoYXBlLFxuICAgICAgICAgICAgeyB0ZXhjb29yZF9pbmRleDogdGhpcy52ZXJ0ZXhfbGF5b3V0LmluZGV4LmFfdGV4Y29vcmQsIHRleGNvb3JkX3NjYWxlOiB0aGlzLnRleGNvb3JkX3NjYWxlIH1cbiAgICAgICAgKTtcbiAgICB9XG5cbn0pO1xuIiwiLy8gUmVuZGVyaW5nIHN0eWxlc1xuXG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuL3N0eWxlX3BhcnNlcic7XG5pbXBvcnQgRmVhdHVyZVNlbGVjdGlvbiBmcm9tICcuLi9zZWxlY3Rpb24nO1xuaW1wb3J0IFNoYWRlclByb2dyYW0gZnJvbSAnLi4vZ2wvc2hhZGVyX3Byb2dyYW0nO1xuaW1wb3J0IFZCT01lc2ggZnJvbSAnLi4vZ2wvdmJvX21lc2gnO1xuaW1wb3J0IEJ1aWxkZXJzIGZyb20gJy4vYnVpbGRlcnMnO1xuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi4vZ2wvdGV4dHVyZSc7XG5pbXBvcnQgTWF0ZXJpYWwgZnJvbSAnLi4vbWF0ZXJpYWwnO1xuaW1wb3J0IExpZ2h0IGZyb20gJy4uL2xpZ2h0JztcbmltcG9ydCB7TWV0aG9kTm90SW1wbGVtZW50ZWR9IGZyb20gJy4uL3V0aWxzL2Vycm9ycyc7XG5pbXBvcnQgc2hhZGVyU291cmNlcyBmcm9tICcuLi9nbC9zaGFkZXJfc291cmNlcyc7IC8vIGJ1aWx0LWluIHNoYWRlcnNcblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbi8vIEJhc2UgY2xhc3NcblxuZXhwb3J0IHZhciBTdHlsZSA9IHtcbiAgICBpbml0ICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5pc0J1aWx0SW4oKSkge1xuICAgICAgICAgICAgdGhpcy5idWlsdF9pbiA9IGZhbHNlOyAvLyBleHBsaWNpdGx5IHNldCB0byBmYWxzZSB0byBhdm9pZCBhbnkgY29uZnVzaW9uXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJsZW5kID0gdGhpcy5ibGVuZCB8fCAnb3BhcXVlJzsgICAgICAgIC8vIGRlZmF1bHQ6IG9wYXF1ZSBzdHlsZXMgYXJlIGRyYXduIGZpcnN0LCB3aXRob3V0IGJsZW5kaW5nXG4gICAgICAgIHRoaXMuZGVmaW5lcyA9IHRoaXMuZGVmaW5lcyB8fCB7fTsgICAgICAgICAgLy8gI2RlZmluZXMgdG8gYmUgaW5qZWN0ZWQgaW50byB0aGUgc2hhZGVyc1xuICAgICAgICB0aGlzLnNoYWRlcnMgPSB0aGlzLnNoYWRlcnMgfHwge307ICAgICAgICAgIC8vIHNoYWRlciBjdXN0b21pemF0aW9uIHZpYSBzY2VuZSBkZWZpbml0aW9uICh1bmlmb3JtcywgZGVmaW5lcywgYmxvY2tzLCBldGMuKVxuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uIHx8IGZhbHNlOyAgIC8vIGZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIHN0eWxlIHN1cHBvcnRzIGZlYXR1cmUgc2VsZWN0aW9uXG4gICAgICAgIHRoaXMuY29tcGlsaW5nID0gZmFsc2U7ICAgICAgICAgICAgICAgICAgICAgLy8gcHJvZ3JhbXMgYXJlIGN1cnJlbnRseSBjb21waWxpbmdcbiAgICAgICAgdGhpcy5jb21waWxlZCA9IGZhbHNlOyAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9ncmFtcyBhcmUgZmluaXNoZWQgY29tcGlsaW5nXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gR0wgcHJvZ3JhbSByZWZlcmVuY2UgKGZvciBtYWluIHJlbmRlciBwYXNzKVxuICAgICAgICB0aGlzLnNlbGVjdGlvbl9wcm9ncmFtID0gbnVsbDsgICAgICAgICAgICAgIC8vIEdMIHByb2dyYW0gcmVmZXJlbmNlIGZvciBmZWF0dXJlIHNlbGVjdGlvbiByZW5kZXIgcGFzc1xuICAgICAgICB0aGlzLmZlYXR1cmVfc3R5bGUgPSB7fTsgICAgICAgICAgICAgICAgICAgIC8vIHN0eWxlIGZvciBmZWF0dXJlIGN1cnJlbnRseSBiZWluZyBwYXJzZWQsIHNoYXJlZCB0byBsZXNzZW4gR0MvbWVtb3J5IHRocmFzaFxuICAgICAgICB0aGlzLnRleHR1cmVzID0gdGhpcy50ZXh0dXJlcyB8fCB7fTtcblxuICAgICAgICAvLyBJZiB0aGUgc3R5bGUgZGVmaW5lcyBpdHMgb3duIG1hdGVyaWFsLCByZXBsYWNlIHRoZSBpbmhlcml0ZWQgbWF0ZXJpYWwgaW5zdGFuY2VcbiAgICAgICAgaWYgKCEodGhpcy5tYXRlcmlhbCBpbnN0YW5jZW9mIE1hdGVyaWFsKSkge1xuICAgICAgICAgICAgdGhpcy5tYXRlcmlhbCA9IG5ldyBNYXRlcmlhbCh0aGlzLm1hdGVyaWFsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hdGVyaWFsLmluamVjdCh0aGlzKTtcblxuICAgICAgICAvLyBTZXQgbGlnaHRpbmcgbW9kZTogZnJhZ21lbnQsIHZlcnRleCwgb3Igbm9uZSAoc3BlY2lmaWVkIGFzICdmYWxzZScpXG4gICAgICAgIExpZ2h0LnNldE1vZGUodGhpcy5saWdodGluZywgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfSxcblxuICAgIGRlc3Ryb3kgKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9ncmFtKSB7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW0uZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbl9wcm9ncmFtKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbl9wcm9ncmFtLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nbCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgaXNCdWlsdEluICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzT3duUHJvcGVydHkoJ2J1aWx0X2luJykgJiYgdGhpcy5idWlsdF9pbjtcbiAgICB9LFxuXG4gICAgLyoqKiBTdHlsZSBwYXJzaW5nIGFuZCBnZW9tZXRyeSBjb25zdHJ1Y3Rpb24gKioqL1xuXG4gICAgLy8gUmV0dXJucyBhbiBvYmplY3QgdG8gaG9sZCBmZWF0dXJlIGRhdGEgKGZvciBhIHRpbGUgb3Igb3RoZXIgb2JqZWN0KVxuICAgIHN0YXJ0RGF0YSAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJ0ZXhfZGF0YTogbnVsbCxcbiAgICAgICAgICAgIHVuaWZvcm1zOiBudWxsLFxuICAgICAgICAgICAgb3JkZXI6IHsgbWluOiBJbmZpbml0eSwgbWF4OiAtSW5maW5pdHkgfSAvLyByZXNldCB0byB0cmFjayBvcmRlciByYW5nZSB3aXRoaW4gdGlsZVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvLyBGaW5hbGl6ZXMgYW4gb2JqZWN0IGhvbGRpbmcgZmVhdHVyZSBkYXRhIChmb3IgYSB0aWxlIG9yIG90aGVyIG9iamVjdClcbiAgICBlbmREYXRhICh0aWxlX2RhdGEpIHtcbiAgICAgICAgaWYgKHRpbGVfZGF0YS52ZXJ0ZXhfZGF0YSkge1xuICAgICAgICAgICAgLy8gT25seSBrZWVwIGZpbmFsIGJ5dGUgYnVmZmVyXG4gICAgICAgICAgICB0aWxlX2RhdGEudmVydGV4X2RhdGEuZW5kKCk7XG4gICAgICAgICAgICB0aWxlX2RhdGEudmVydGV4X2RhdGEgPSB0aWxlX2RhdGEudmVydGV4X2RhdGEuYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGlsZV9kYXRhKTtcbiAgICB9LFxuXG4gICAgYWRkRmVhdHVyZSAoZmVhdHVyZSwgcnVsZSwgY29udGV4dCwgdGlsZV9kYXRhKSB7XG4gICAgICAgIGxldCBzdHlsZSA9IHRoaXMucGFyc2VGZWF0dXJlKGZlYXR1cmUsIHJ1bGUsIGNvbnRleHQpO1xuXG4gICAgICAgIC8vIFNraXAgZmVhdHVyZT9cbiAgICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhY2sgbWluL21heCBvcmRlciByYW5nZVxuICAgICAgICBpZiAoc3R5bGUub3JkZXIgPCB0aWxlX2RhdGEub3JkZXIubWluKSB7XG4gICAgICAgICAgICB0aWxlX2RhdGEub3JkZXIubWluID0gc3R5bGUub3JkZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlLm9yZGVyID4gdGlsZV9kYXRhLm9yZGVyLm1heCkge1xuICAgICAgICAgICAgdGlsZV9kYXRhLm9yZGVyLm1heCA9IHN0eWxlLm9yZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QgZmVhdHVyZSBpbiB0aGlzIHJlbmRlciBzdHlsZT9cbiAgICAgICAgaWYgKCF0aWxlX2RhdGEudmVydGV4X2RhdGEpIHtcbiAgICAgICAgICAgIHRpbGVfZGF0YS52ZXJ0ZXhfZGF0YSA9IHRoaXMudmVydGV4X2xheW91dC5jcmVhdGVWZXJ0ZXhEYXRhKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJ1aWxkR2VvbWV0cnkoZmVhdHVyZS5nZW9tZXRyeSwgc3R5bGUsIHRpbGVfZGF0YS52ZXJ0ZXhfZGF0YSk7XG4gICAgfSxcblxuICAgIGJ1aWxkR2VvbWV0cnkgKGdlb21ldHJ5LCBzdHlsZSwgdmVydGV4X2RhdGEpIHtcbiAgICAgICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICAgICAgdGhpcy5idWlsZFBvbHlnb25zKFtnZW9tZXRyeS5jb29yZGluYXRlc10sIHN0eWxlLCB2ZXJ0ZXhfZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRQb2x5Z29ucyhnZW9tZXRyeS5jb29yZGluYXRlcywgc3R5bGUsIHZlcnRleF9kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRMaW5lcyhbZ2VvbWV0cnkuY29vcmRpbmF0ZXNdLCBzdHlsZSwgdmVydGV4X2RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkTGluZXMoZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIHN0eWxlLCB2ZXJ0ZXhfZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ1BvaW50Jykge1xuICAgICAgICAgICAgdGhpcy5idWlsZFBvaW50cyhbZ2VvbWV0cnkuY29vcmRpbmF0ZXNdLCBzdHlsZSwgdmVydGV4X2RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xuICAgICAgICAgICAgdGhpcy5idWlsZFBvaW50cyhnZW9tZXRyeS5jb29yZGluYXRlcywgc3R5bGUsIHZlcnRleF9kYXRhKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwYXJzZUZlYXR1cmUgKGZlYXR1cmUsIHJ1bGVfc3R5bGUsIGNvbnRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuZmVhdHVyZV9zdHlsZTtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIG9yZGVyIGlmIGl0IHdhcyBub3QgY2FjaGVkXG4gICAgICAgICAgICBzdHlsZS5vcmRlciA9IHJ1bGVfc3R5bGUub3JkZXI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlLm9yZGVyICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHN0eWxlLm9yZGVyID0gU3R5bGVQYXJzZXIuY2FsY3VsYXRlT3JkZXIoc3R5bGUub3JkZXIsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGZWF0dXJlIHNlbGVjdGlvbiAob25seSBpZiBzdHlsZSBzdXBwb3J0cyBpdClcbiAgICAgICAgICAgIHZhciBzZWxlY3RhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBzdHlsZS5pbnRlcmFjdGl2ZSA9IHJ1bGVfc3R5bGUuaW50ZXJhY3RpdmU7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlLmludGVyYWN0aXZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGFibGUgPSBzdHlsZS5pbnRlcmFjdGl2ZShjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGFibGUgPSBzdHlsZS5pbnRlcmFjdGl2ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGZlYXR1cmUgaXMgbWFya2VkIGFzIHNlbGVjdGFibGVcbiAgICAgICAgICAgIGlmIChzZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuc2VsZWN0aW9uX2NvbG9yID0gRmVhdHVyZVNlbGVjdGlvbi5tYWtlQ29sb3IoZmVhdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5zZWxlY3Rpb25fY29sb3IgPSBGZWF0dXJlU2VsZWN0aW9uLmRlZmF1bHRDb2xvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3ViY2xhc3MgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgIHN0eWxlID0gdGhpcy5fcGFyc2VGZWF0dXJlKGZlYXR1cmUsIHJ1bGVfc3R5bGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcignU3R5bGUucGFyc2VGZWF0dXJlOiBzdHlsZSBwYXJzaW5nIGVycm9yJywgZmVhdHVyZSwgc3R5bGUsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcGFyc2VGZWF0dXJlIChmZWF0dXJlLCBydWxlX3N0eWxlLCBjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBNZXRob2ROb3RJbXBsZW1lbnRlZCgnX3BhcnNlRmVhdHVyZScpO1xuICAgIH0sXG5cbiAgICAvLyBCdWlsZCBmdW5jdGlvbnMgYXJlIG5vLW9wcyB1bnRpbCBvdmVycmlkZW5cbiAgICBidWlsZFBvbHlnb25zICgpIHt9LFxuICAgIGJ1aWxkTGluZXMgKCkge30sXG4gICAgYnVpbGRQb2ludHMgKCkge30sXG5cblxuICAgIC8qKiogVGV4dHVyZSBtYW5hZ2VtZW50ICoqKi9cblxuICAgIC8vIFByZWZpeCB0ZXh0dXJlIG5hbWUgd2l0aCBzdHlsZSBuYW1lXG4gICAgdGV4dHVyZU5hbWUgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArICdfJyArIG5hbWU7XG4gICAgfSxcblxuICAgIHNldHVwVGV4dHVyZVVuaWZvcm1zICgpIHtcbiAgICAgICAgdmFyIG51bV90ZXh0dXJlcyA9IE9iamVjdC5rZXlzKHRoaXMudGV4dHVyZXMpLmxlbmd0aDtcblxuICAgICAgICAvLyBTZXQgYSBkZWZhdWx0IHRleHR1cmUgZmxhZ1xuICAgICAgICBpZiAodGhpcy50ZXh0dXJlcy5kZWZhdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmRlZmluZXNbJ0hBU19ERUZBVUxUX1RFWFRVUkUnXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcm92aWRlIGEgYnVpbHQtaW4gdW5pZm9ybSBhcnJheSBvZiB0ZXh0dXJlc1xuICAgICAgICBpZiAobnVtX3RleHR1cmVzID4gMCkge1xuICAgICAgICAgICAgdmFyIHRleF9pZCA9IDA7XG4gICAgICAgICAgICB0aGlzLmRlZmluZXNbJ05VTV9URVhUVVJFUyddID0gbnVtX3RleHR1cmVzLnRvU3RyaW5nKCk7IC8vIGZvcmNlIHN0cmluZyB0byBhdm9pZCBhdXRvLWNvbnZlcnNpb24gdG8gZmxvYXRcbiAgICAgICAgICAgIHRoaXMuc2hhZGVycy51bmlmb3JtcyA9IHRoaXMuc2hhZGVycy51bmlmb3JtcyB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMuc2hhZGVycy51bmlmb3Jtcy51X3RleHR1cmVzID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy50ZXh0dXJlcykge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLm5hbWUgPSB0aGlzLnRleHR1cmVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgICAgIHRleHR1cmUuaWQgPSB0ZXhfaWQrKzsgLy8gZ2l2ZSBldmVyeSB0ZXh0dXJlIGEgdW5pcXVlIGlkIGxvY2FsIHRvIHRoaXMgc3R5bGVcblxuICAgICAgICAgICAgICAgIC8vIENvbnNpc3RlbnRseSBtYXAgbmFtZWQgdGV4dHVyZXMgdG8gdGhlIHNhbWUgYXJyYXkgaW5kZXggaW4gdGhlIHRleHR1cmUgdW5pZm9ybVxuICAgICAgICAgICAgICAgIHRoaXMuc2hhZGVycy51bmlmb3Jtcy51X3RleHR1cmVzW3RleHR1cmUuaWRdID0gdGV4dHVyZS5uYW1lO1xuXG4gICAgICAgICAgICAgICAgLy8gUHJvdmlkZSBhICNkZWZpbmUgbWFwcGluZyBlYWNoIHRleHR1cmUgYmFjayB0byBpdHMgbmFtZSBpbiB0aGUgc3R5bGVzaGVldFxuICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lc1tgdGV4dHVyZV8ke25hbWV9YF0gPSBgdV90ZXh0dXJlc1ske3RleHR1cmUuaWR9XWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gUHJlbG9hZCBhbnkgdGV4dHVyZXMgd2l0aCBleHBsaWNpdCBjb25maWd1cmF0aW9uIGluIHRoZSAndGV4dHVyZXMnIGZpZWxkXG4gICAgLy8gKHRleHR1cmVzIGNhbiBhbHNvIGJlIGluaXRpYWxpemVkIG9uIHRoZSBmbHkgdmlhIHVuaWZvcm0gc2V0dGVycyBpZiB0aGV5IGRvbid0IHJlcXVpcmUgYW55IGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbilcbiAgICAvLyBOT1RFOiB0aGlzIGlzIG9ubHkgcnVuIGluIHRoZSBtYWluIHRocmVhZCwgc2luY2Ugd29ya2VycyBkb24ndCB1c2UgYW55IEdMIHJlc291cmNlc1xuICAgIHByZWxvYWRUZXh0dXJlcyAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHR1cmVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMudGV4dHVyZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgeyB1cmwsIGZpbHRlcmluZywgcmVwZWF0LCBzcHJpdGVzIH0gPSB0aGlzLnRleHR1cmVzW25hbWVdO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gbmV3IFRleHR1cmUodGhpcy5nbCwgdGhpcy50ZXh0dXJlTmFtZShuYW1lKSwgeyBzcHJpdGVzIH0pO1xuXG4gICAgICAgICAgICAgICAgdGV4dHVyZS5sb2FkKHVybCwgeyBmaWx0ZXJpbmcsIHJlcGVhdCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBQcmUtY2FsYyBzcHJpdGUgcmVnaW9ucyBmb3IgYSB0ZXh0dXJlIHNwcml0ZSBpbiBVViBbMCwgMV0gc3BhY2VcbiAgICBjYWxjdWxhdGVUZXh0dXJlU3ByaXRlcyAobmFtZSkge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IFRleHR1cmUudGV4dHVyZXNbdGhpcy50ZXh0dXJlTmFtZShuYW1lKV07XG4gICAgICAgIGlmICh0ZXh0dXJlLnNwcml0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZV9zcHJpdGVzID0gdGhpcy50ZXh0dXJlX3Nwcml0ZXMgfHwge307XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVfc3ByaXRlc1tuYW1lXSA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBzIGluIHRleHR1cmUuc3ByaXRlcykge1xuICAgICAgICAgICAgICAgIHZhciBzcHJpdGUgPSB0ZXh0dXJlLnNwcml0ZXNbc107XG5cbiAgICAgICAgICAgICAgICAvLyBNYXAgWzAsIDBdIHRvIFsxLCAxXSBjb29yZHMgdG8gdGhlIGFwcHJvcHJpYXRlIHNwcml0ZSBzdWItYXJlYSBvZiB0aGUgdGV4dHVyZVxuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZV9zcHJpdGVzW25hbWVdW3NdID0gQnVpbGRlcnMuZ2V0VGV4Y29vcmRzRm9yU3ByaXRlKFxuICAgICAgICAgICAgICAgICAgICBbc3ByaXRlWzBdLCBzcHJpdGVbMV1dLFxuICAgICAgICAgICAgICAgICAgICBbc3ByaXRlWzJdLCBzcHJpdGVbM11dLFxuICAgICAgICAgICAgICAgICAgICBbdGV4dHVyZS53aWR0aCwgdGV4dHVyZS5oZWlnaHRdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBTZXQgb3B0aW9uYWwgc2NhbGUgdG8gdXNlIGZvciB0ZXh0dXJlIGNvb3JkaW5hdGVzIChkZWZhdWx0IGlzIFswLCAxXSlcbiAgICBzZXRUZXhjb29yZFNjYWxlIChzdHlsZSkge1xuICAgICAgICAvLyBHZXQgc3ByaXRlIHN1Yi1hcmVhIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAodGhpcy50ZXh0dXJlcyAmJiBzdHlsZS5zcHJpdGUpIHtcbiAgICAgICAgICAgIC8vIFVzZSBkZWZhdWx0IHRleHR1cmUgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdGV4dHVyZSBtdXN0IGJlIHNwZWNpZmllZFxuICAgICAgICAgICAgdmFyIHRleDtcbiAgICAgICAgICAgIGlmICh0aGlzLnRleHR1cmVzLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICB0ZXggPSAnZGVmYXVsdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXggPSBzdHlsZS50ZXh0dXJlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRleCkge1xuICAgICAgICAgICAgICAgIGxvZy5lcnJvcihgU3R5bGU6IGluIHN0eWxlICcke3RoaXMubmFtZX0nLCBtdXN0IHNwZWNpZnkgdGV4dHVyZSB0byB1c2UgZm9yIHNwcml0ZSAnJHtzdHlsZS5zcHJpdGV9JywgbXVzdCBiZSBvbmUgb2YgWyR7T2JqZWN0LmtleXModGhpcy50ZXh0dXJlcykuam9pbignLCAnKX1dYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMYXppbHkgY2FsY3VsYXRlIHNwcml0ZSBVVnMgdGhlIGZpcnN0IHRpbWUgdGhleSBhcmUgZW5jb3VudGVyZWRcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudGV4dHVyZV9zcHJpdGVzIHx8ICF0aGlzLnRleHR1cmVfc3ByaXRlc1t0ZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlVGV4dHVyZVNwcml0ZXModGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50ZXhjb29yZF9zY2FsZSA9IHRoaXMudGV4dHVyZV9zcHJpdGVzW3RleF0gJiYgdGhpcy50ZXh0dXJlX3Nwcml0ZXNbdGV4XVtzdHlsZS5zcHJpdGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuXG4gICAgLyoqKiBHTCBzdGF0ZSBhbmQgcmVuZGVyaW5nICoqKi9cblxuICAgIHNldEdMIChnbCkge1xuICAgICAgICB0aGlzLmdsID0gZ2w7XG4gICAgICAgIHRoaXMuc2V0dXBUZXh0dXJlVW5pZm9ybXMoKTtcbiAgICAgICAgdGhpcy5wcmVsb2FkVGV4dHVyZXMoKTtcbiAgICB9LFxuXG4gICAgbWFrZU1lc2ggKHZlcnRleF9kYXRhLCB7IHVuaWZvcm1zIH0gPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFZCT01lc2godGhpcy5nbCwgdmVydGV4X2RhdGEsIHRoaXMudmVydGV4X2xheW91dCwgeyB1bmlmb3JtcyB9KTtcbiAgICB9LFxuXG4gICAgY29tcGlsZSAoKSB7XG4gICAgICAgIGlmICghdGhpcy5nbCkge1xuICAgICAgICAgICAgdGhyb3cobmV3IEVycm9yKGBzdHlsZS5jb21waWxlKCk6IHNraXBwaW5nIGZvciAke3RoaXMubmFtZX0gYmVjYXVzZSBubyBHTCBjb250ZXh0YCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29tcGlsaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyhuZXcgRXJyb3IoYHN0eWxlLmNvbXBpbGUoKTogc2tpcHBpbmcgZm9yICR7dGhpcy5uYW1lfSBiZWNhdXNlIHN0eWxlIGlzIGFscmVhZHkgY29tcGlsaW5nYCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcGlsaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb21waWxlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEJ1aWxkIGRlZmluZXMgJiBmb3Igc2VsZWN0aW9uIChuZWVkIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3Qgc2luY2UgdGhlIGZpcnN0IGlzIHN0b3JlZCBhcyBhIHJlZmVyZW5jZSBieSB0aGUgcHJvZ3JhbSlcbiAgICAgICAgdmFyIGRlZmluZXMgPSB0aGlzLmJ1aWxkRGVmaW5lTGlzdCgpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25fZGVmaW5lcyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmluZXMpO1xuICAgICAgICAgICAgc2VsZWN0aW9uX2RlZmluZXNbJ0ZFQVRVUkVfU0VMRUNUSU9OJ10gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGFueSBjdXN0b20gY29kZSB0cmFuc2Zvcm1zLCB1bmlmb3JtIGRlcGVuZGVuY2llcywgZXRjLlxuICAgICAgICB2YXIgdHJhbnNmb3JtcyA9ICh0aGlzLnNoYWRlcnMgJiYgdGhpcy5zaGFkZXJzLnRyYW5zZm9ybXMpO1xuICAgICAgICB2YXIgdW5pZm9ybXMgPSAodGhpcy5zaGFkZXJzICYmIHRoaXMuc2hhZGVycy51bmlmb3Jtcyk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHNoYWRlcnNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbSA9IG5ldyBTaGFkZXJQcm9ncmFtKFxuICAgICAgICAgICAgICAgIHRoaXMuZ2wsXG4gICAgICAgICAgICAgICAgc2hhZGVyU291cmNlc1t0aGlzLnZlcnRleF9zaGFkZXJfa2V5XSxcbiAgICAgICAgICAgICAgICBzaGFkZXJTb3VyY2VzW3RoaXMuZnJhZ21lbnRfc2hhZGVyX2tleV0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZXMsXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1zXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25fcHJvZ3JhbSA9IG5ldyBTaGFkZXJQcm9ncmFtKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsLFxuICAgICAgICAgICAgICAgICAgICBzaGFkZXJTb3VyY2VzW3RoaXMudmVydGV4X3NoYWRlcl9rZXldLFxuICAgICAgICAgICAgICAgICAgICBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3NlbGVjdGlvbl9mcmFnbWVudCddLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAodGhpcy5uYW1lICsgJyAoc2VsZWN0aW9uKScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lczogc2VsZWN0aW9uX2RlZmluZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3JtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybXNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbl9wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5jb21waWxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY29tcGlsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcihgc3R5bGUuY29tcGlsZSgpOiBzdHlsZSAke3RoaXMubmFtZX0gZXJyb3I6YCwgZXJyb3IpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tcGlsaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcGlsZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBzaGFkZXIgdHJhbnNmb3JtXG4gICAgYWRkU2hhZGVyVHJhbnNmb3JtIChrZXksIC4uLnRyYW5zZm9ybXMpIHtcbiAgICAgICAgdGhpcy5zaGFkZXJzLnRyYW5zZm9ybXMgPSB0aGlzLnNoYWRlcnMudHJhbnNmb3JtcyB8fCB7fTtcbiAgICAgICAgdGhpcy5zaGFkZXJzLnRyYW5zZm9ybXNba2V5XSA9IHRoaXMuc2hhZGVycy50cmFuc2Zvcm1zW2tleV0gfHwgW107XG4gICAgICAgIHRoaXMuc2hhZGVycy50cmFuc2Zvcm1zW2tleV0ucHVzaCguLi50cmFuc2Zvcm1zKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGFsbCBzaGFkZXIgdHJhbnNmb3JtcyBmb3Iga2V5XG4gICAgcmVtb3ZlU2hhZGVyVHJhbnNmb3JtIChrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hhZGVycy50cmFuc2Zvcm1zKSB7XG4gICAgICAgICAgICB0aGlzLnNoYWRlcnMudHJhbnNmb3Jtc1trZXldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZXBsYWNlU2hhZGVyVHJhbnNmb3JtIChrZXksIC4uLnRyYW5zZm9ybXMpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVTaGFkZXJUcmFuc2Zvcm0oa2V5KTtcbiAgICAgICAgdGhpcy5hZGRTaGFkZXJUcmFuc2Zvcm0oa2V5LCAuLi50cmFuc2Zvcm1zKTtcbiAgICB9LFxuXG4gICAgLyoqIFRPRE86IGNvdWxkIHByb2JhYmx5IGNvbWJpbmUgYW5kIGdlbmVyYWxpemUgdGhpcyB3aXRoIHNpbWlsYXIgbWV0aG9kIGluIFNoYWRlclByb2dyYW1cbiAgICAgKiAobGlzdCBvZiBkZWZpbmUgb2JqZWN0cyB0aGF0IGluaGVyaXQgZnJvbSBlYWNoIG90aGVyKVxuICAgICAqL1xuICAgIGJ1aWxkRGVmaW5lTGlzdCAoKSB7XG4gICAgICAgIC8vIEFkZCBhbnkgY3VzdG9tIGRlZmluZXMgdG8gYnVpbHQtaW4gc3R5bGUgZGVmaW5lc1xuICAgICAgICB2YXIgZGVmaW5lcyA9IHt9OyAvLyBjcmVhdGUgYSBuZXcgb2JqZWN0IHRvIGF2b2lkIG11dGF0aW5nIGEgcHJvdG90eXBlIHZhbHVlIHRoYXQgbWF5IGJlIHNoYXJlZCB3aXRoIG90aGVyIHN0eWxlc1xuICAgICAgICBpZiAodGhpcy5kZWZpbmVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgaW4gdGhpcy5kZWZpbmVzKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lc1tkXSA9IHRoaXMuZGVmaW5lc1tkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaGFkZXJzICE9IG51bGwgJiYgdGhpcy5zaGFkZXJzLmRlZmluZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChkIGluIHRoaXMuc2hhZGVycy5kZWZpbmVzKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lc1tkXSA9IHRoaXMuc2hhZGVycy5kZWZpbmVzW2RdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZpbmVzO1xuXG4gICAgfSxcblxuICAgIC8vIFNldHVwIGFueSBHTCBzdGF0ZSBmb3IgcmVuZGVyaW5nXG4gICAgc2V0dXAgKCkge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm1zKCk7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwuc2V0dXBQcm9ncmFtKFNoYWRlclByb2dyYW0uY3VycmVudCk7XG4gICAgfSxcblxuICAgIC8vIFNldCBzdHlsZSB1bmlmb3JtcyBvbiBjdXJyZW50bHkgYm91bmQgcHJvZ3JhbVxuICAgIHNldFVuaWZvcm1zICgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBTaGFkZXJQcm9ncmFtLmN1cnJlbnQ7XG4gICAgICAgIGlmICghcHJvZ3JhbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvZ3JhbS5zZXRVbmlmb3Jtcyh0aGlzLnNoYWRlcnMgJiYgdGhpcy5zaGFkZXJzLnVuaWZvcm1zLCB0cnVlKTsgLy8gcmVzZXQgdGV4dHVyZSB1bml0IHRvIDBcbiAgICB9LFxuXG4gICAgdXBkYXRlICgpIHtcbiAgICAgICAgLy8gU3R5bGUtc3BlY2lmaWMgYW5pbWF0aW9uXG4gICAgICAgIC8vIGlmICh0eXBlb2YgdGhpcy5hbmltYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gICAgIHRoaXMuYW5pbWF0aW9uKCk7XG4gICAgICAgIC8vIH1cbiAgICB9XG59O1xuIiwiLy8gTWFuYWdlIHJlbmRlcmluZyBzdHlsZXNcblxuaW1wb3J0IFV0aWxzIGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBTaGFkZXJQcm9ncmFtIGZyb20gJy4uL2dsL3NoYWRlcl9wcm9ncmFtJztcbmltcG9ydCBzaGFkZXJTb3VyY2VzIGZyb20gJy4uL2dsL3NoYWRlcl9zb3VyY2VzJzsgLy8gYnVpbHQtaW4gc2hhZGVyc1xuXG5pbXBvcnQge1N0eWxlfSBmcm9tICcuL3N0eWxlJztcbmltcG9ydCB7UG9seWdvbnN9IGZyb20gJy4vcG9seWdvbnMvcG9seWdvbnMnO1xuaW1wb3J0IHtQb2ludHN9IGZyb20gJy4vcG9pbnRzL3BvaW50cyc7XG5pbXBvcnQge1Nwcml0ZXN9IGZyb20gJy4vc3ByaXRlcy9zcHJpdGVzJztcbmltcG9ydCB7VGV4dFN0eWxlfSBmcm9tICcuL3RleHQvdGV4dCc7XG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG5leHBvcnQgdmFyIFN0eWxlTWFuYWdlciA9IHt9O1xuZXhwb3J0IHZhciBTdHlsZXMgPSB7fTtcblxuLy8gU2V0IHRoZSBiYXNlIG9iamVjdCB1c2VkIHRvIGluc3RhbnRpYXRlIHN0eWxlc1xuU3R5bGVNYW5hZ2VyLmJhc2VTdHlsZSA9IFN0eWxlO1xuXG4vLyBHbG9iYWwgY29uZmlndXJhdGlvbiBmb3IgYWxsIHN0eWxlc1xuU3R5bGVNYW5hZ2VyLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFN0eWxlTWFuYWdlci5pbml0aWFsaXplZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgU2hhZGVyUHJvZ3JhbS5yZW1vdmVUcmFuc2Zvcm0oJ2dsb2JhbHMnKTtcblxuICAgIC8vIExheWVyIHJlLW9yZGVyaW5nIGZ1bmN0aW9uXG4gICAgU2hhZGVyUHJvZ3JhbS5hZGRUcmFuc2Zvcm0oJ2dsb2JhbHMnLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3Jlb3JkZXJfbGF5ZXJzJ10pO1xuXG4gICAgLy8gU3BoZXJpY2FsIGVudmlyb25tZW50IG1hcFxuICAgIFNoYWRlclByb2dyYW0uYWRkVHJhbnNmb3JtKCdnbG9iYWxzJywgYFxuICAgICAgICAjaWYgZGVmaW5lZChMSUdIVElOR19FTlZJUk9OTUVOVClcbiAgICAgICAgJHtzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3NwaGVyaWNhbF9lbnZpcm9ubWVudF9tYXAnXX1cbiAgICAgICAgI2VuZGlmXG4gICAgYCk7XG5cbiAgICBTdHlsZU1hbmFnZXIuaW5pdGlhbGl6ZWQgPSB0cnVlO1xufTtcblxuLy8gRGVzdHJveSBhbGwgc3R5bGVzIGZvciBhIGdpdmVuIEdMIGNvbnRleHRcblN0eWxlTWFuYWdlci5kZXN0cm95ID0gZnVuY3Rpb24gKGdsKSB7XG4gICAgT2JqZWN0LmtleXMoU3R5bGVzKS5mb3JFYWNoKChfbmFtZSkgPT4ge1xuICAgICAgICB2YXIgc3R5bGUgPSBTdHlsZXNbX25hbWVdO1xuICAgICAgICBpZiAoc3R5bGUuZ2wgPT09IGdsKSB7XG4gICAgICAgICAgICBsb2cudHJhY2UoYFN0eWxlTWFuYWdlci5kZXN0cm95OiBkZXN0cm95aW5nIHJlbmRlciBzdHlsZSAke3N0eWxlLm5hbWV9YCk7XG5cbiAgICAgICAgICAgIGlmICghc3R5bGUuaXNCdWlsdEluKCkpIHtcbiAgICAgICAgICAgICAgICBTdHlsZU1hbmFnZXIucmVtb3ZlKHN0eWxlLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGUuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vLyBSZWdpc3RlciBhIHN0eWxlXG5TdHlsZU1hbmFnZXIucmVnaXN0ZXIgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICBTdHlsZXNbc3R5bGUubmFtZV0gPSBzdHlsZTtcbn07XG5cbi8vIFJlbW92ZSBhIHN0eWxlXG5TdHlsZU1hbmFnZXIucmVtb3ZlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBkZWxldGUgU3R5bGVzW25hbWVdO1xufTtcblxuLy8gUHJlbG9hZHMgbmV0d29yayByZXNvdXJjZXMgaW4gdGhlIHN0eWxlc2hlZXQgKHNoYWRlcnMsIHRleHR1cmVzLCBldGMuKVxuU3R5bGVNYW5hZ2VyLnByZWxvYWQgPSBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gICAgaWYgKCFzdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIC8vIEZpcnN0IGxvYWQgcmVtb3RlIHN0eWxlcywgdGhlbiBsb2FkIHNoYWRlciBibG9ja3MgZnJvbSByZW1vdGUgVVJMc1xuICAgIC8vIFRPRE86IGFsc28gcHJlbG9hZCB0ZXh0dXJlc1xuICAgIFN0eWxlTWFuYWdlci5ub3JtYWxpemVUZXh0dXJlcyhzdHlsZXMpO1xuICAgIHJldHVybiBTdHlsZU1hbmFnZXIubG9hZFJlbW90ZVN0eWxlcyhzdHlsZXMpLnRoZW4oU3R5bGVNYW5hZ2VyLmxvYWRSZW1vdGVTaGFkZXJUcmFuc2Zvcm1zKTtcbn07XG5cbi8vIEhhbmRsZSBzaW5nbGUgb3IgbXVsdGktdGV4dHVyZSBzeW50YXgsIGZvciBzdHlsZXNoZWV0IGNvbnZlbmllbmNlXG5TdHlsZU1hbmFnZXIubm9ybWFsaXplVGV4dHVyZXMgPSBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gICAgZm9yICh2YXIgc3R5bGUgb2YgVXRpbHMudmFsdWVzKHN0eWxlcykpIHtcbiAgICAgICAgc3R5bGUudGV4dHVyZXMgPSBzdHlsZS50ZXh0dXJlcyB8fCB7fTtcblxuICAgICAgICAvLyBTdXBwb3J0IHNpbXBsZXIgc2luZ2xlIHRleHR1cmUgc3ludGF4XG4gICAgICAgIGlmIChzdHlsZS50ZXh0dXJlKSB7XG4gICAgICAgICAgICBzdHlsZS50ZXh0dXJlcy5kZWZhdWx0ID0gc3R5bGUudGV4dHVyZTsgLy8gYWxpYXMgc2luZ2xlIHRleHR1cmUgdG8gJ2RlZmF1bHQnXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlcztcbn07XG5cbi8vIExvYWQgc3R5bGUgZGVmaW5pdGlvbnMgZnJvbSBleHRlcm5hbCBVUkxzXG5TdHlsZU1hbmFnZXIubG9hZFJlbW90ZVN0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgICAvLyBDb2xsZWN0IFVSTHMgYW5kIG1vZGVzIHRvIGltcG9ydCBmcm9tIHRoZW1cbiAgICAvLyBUaGlzIGlzIGRvbmUgYXMgYSBzZXBhcmF0ZSBzdGVwIGJlY3Vhc2UgaXQgaXMgcG9zc2libGUgdG8gaW1wb3J0IG11bHRpcGxlIG1vZGVzIGZyb20gYSBzaW5nbGVcbiAgICAvLyBVUkwsIGFuZCB3ZSB3YW50IHRvIGF2b2lkIGR1cGxpY2F0ZSBjYWxscyBmb3IgdGhlIHNhbWUgZmlsZS5cbiAgICB2YXIgdXJscyA9IHt9O1xuICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHN0eWxlc1tuYW1lXTtcbiAgICAgICAgaWYgKHN0eWxlLnVybCkge1xuICAgICAgICAgICAgaWYgKCF1cmxzW3N0eWxlLnVybF0pIHtcbiAgICAgICAgICAgICAgICB1cmxzW3N0eWxlLnVybF0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBhIGxpc3Qgb2YgdGhlIHN0eWxlcyB0byBpbXBvcnQgZm9yIHRoaXMgVVJMXG4gICAgICAgICAgICB1cmxzW3N0eWxlLnVybF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0X25hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgc291cmNlX25hbWU6IHN0eWxlLm5hbWUgfHwgbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBcyBlYWNoIFVSTCBmaW5pc2hlcyBsb2FkaW5nLCByZXBsYWNlIHRoZSB0YXJnZXQgc3R5bGUocylcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoT2JqZWN0LmtleXModXJscykubWFwKHVybCA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBVdGlscy5sb2FkUmVzb3VyY2UodXJsKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdGFyZ2V0IG9mIHVybHNbdXJsXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhW3RhcmdldC5zb3VyY2VfbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1t0YXJnZXQudGFyZ2V0X25hbWVdID0gZGF0YVt0YXJnZXQuc291cmNlX25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0eWxlc1t0YXJnZXQudGFyZ2V0X25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYFN0eWxlTWFuYWdlci5wcmVsb2FkOiBlcnJvciBpbXBvcnRpbmcgc3R5bGUgJHt0YXJnZXQudGFyZ2V0X25hbWV9LCBjb3VsZCBub3QgZmluZCBzb3VyY2Ugc3R5bGUgJHt0YXJnZXQuc291cmNlX25hbWV9IGluICR7dXJsfWApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKGBTdHlsZU1hbmFnZXIucHJlbG9hZDogZXJyb3IgaW1wb3J0aW5nIHN0eWxlKHMpICR7SlNPTi5zdHJpbmdpZnkodXJsc1t1cmxdKX0gZnJvbSAke3VybH1gLCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSkpLnRoZW4oKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHN0eWxlcykpO1xufTtcblxuLy8gUHJlbG9hZCBzaGFkZXIgYmxvY2tzIGZyb20gZXh0ZXJuYWwgVVJMc1xuU3R5bGVNYW5hZ2VyLmxvYWRSZW1vdGVTaGFkZXJUcmFuc2Zvcm1zID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIGZvciAodmFyIHN0eWxlIG9mIFV0aWxzLnZhbHVlcyhzdHlsZXMpKSB7XG4gICAgICAgIGlmIChzdHlsZS5zaGFkZXJzICYmIHN0eWxlLnNoYWRlcnMudHJhbnNmb3Jtcykge1xuICAgICAgICAgICAgbGV0IF90cmFuc2Zvcm1zID0gc3R5bGUuc2hhZGVycy50cmFuc2Zvcm1zO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBba2V5LCB0cmFuc2Zvcm1dIG9mIFV0aWxzLmVudHJpZXMoc3R5bGUuc2hhZGVycy50cmFuc2Zvcm1zKSkge1xuICAgICAgICAgICAgICAgIGxldCBfa2V5ID0ga2V5O1xuXG4gICAgICAgICAgICAgICAgLy8gQXJyYXkgb2YgdHJhbnNmb3Jtc1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdD0wOyB0IDwgdHJhbnNmb3JtLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRyYW5zZm9ybVt0XSA9PT0gJ29iamVjdCcgJiYgdHJhbnNmb3JtW3RdLnVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfaW5kZXggPSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goVXRpbHMuaW8oVXRpbHMuY2FjaGVCdXN0ZXJGb3JVcmwodHJhbnNmb3JtW3RdLnVybCkpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RyYW5zZm9ybXNbX2tleV1bX2luZGV4XSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5lcnJvcihgU3R5bGVNYW5hZ2VyLmxvYWRSZW1vdGVTaGFkZXJUcmFuc2Zvcm1zOiBlcnJvciBsb2FkaW5nIHNoYWRlciB0cmFuc2Zvcm1gLCBfdHJhbnNmb3JtcywgX2tleSwgX2luZGV4LCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNpbmdsZSB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdHJhbnNmb3JtID09PSAnb2JqZWN0JyAmJiB0cmFuc2Zvcm0udXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goVXRpbHMuaW8oVXRpbHMuY2FjaGVCdXN0ZXJGb3JVcmwodHJhbnNmb3JtLnVybCkpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90cmFuc2Zvcm1zW19rZXldID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cuZXJyb3IoYFN0eWxlTWFuYWdlci5sb2FkUmVtb3RlU2hhZGVyVHJhbnNmb3JtczogZXJyb3IgbG9hZGluZyBzaGFkZXIgdHJhbnNmb3JtYCwgX3RyYW5zZm9ybXMsIF9rZXksIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocXVldWUpLnRoZW4oKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHN0eWxlcykpOyAvLyBUT0RPOiBhZGQgZXJyb3Jcbn07XG5cbi8vIFVwZGF0ZSBidWlsdC1pbiBzdHlsZSBvciBjcmVhdGUgYSBuZXcgb25lXG5TdHlsZU1hbmFnZXIudXBkYXRlID0gZnVuY3Rpb24gKG5hbWUsIHNldHRpbmdzKSB7XG4gICAgdmFyIGJhc2UgPSBTdHlsZXNbc2V0dGluZ3MuZXh0ZW5kc10gfHwgU3R5bGVNYW5hZ2VyLmJhc2VTdHlsZTtcbiAgICBTdHlsZXNbbmFtZV0gPSBTdHlsZXNbbmFtZV0gfHwgT2JqZWN0LmNyZWF0ZShiYXNlKTtcbiAgICBpZiAoU3R5bGVzW3NldHRpbmdzLmV4dGVuZHNdKSB7XG4gICAgICAgIFN0eWxlc1tuYW1lXS5zdXBlciA9IFN0eWxlc1tzZXR0aW5ncy5leHRlbmRzXTsgLy8gZXhwbGljaXQgJ3N1cGVyJyBjbGFzcyBhY2Nlc3NcbiAgICB9XG5cbiAgICBmb3IgKHZhciBzIGluIHNldHRpbmdzKSB7XG4gICAgICAgIFN0eWxlc1tuYW1lXVtzXSA9IHNldHRpbmdzW3NdO1xuICAgIH1cblxuICAgIFN0eWxlc1tuYW1lXS5uYW1lID0gbmFtZTtcbiAgICBTdHlsZXNbbmFtZV0uaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICBTdHlsZXNbbmFtZV0uZGVmaW5lcyA9IChiYXNlLmRlZmluZXMgJiYgT2JqZWN0LmNyZWF0ZShiYXNlLmRlZmluZXMpKSB8fCB7fTtcblxuICAgIC8vIE1lcmdlIHNoYWRlcnM6IGRlZmluZXMsIHVuaWZvcm1zLCB0cmFuc2Zvcm1zXG4gICAgbGV0IHNoYWRlcnMgPSB7fTtcbiAgICBsZXQgbWVyZ2UgPSBbYmFzZS5zaGFkZXJzLCBzZXR0aW5ncy5zaGFkZXJzXTsgLy8gZmlyc3QgbWVyZ2UgYmFzZSAoaW5oZXJpdGVkKSBzdHlsZSBzaGFkZXJzXG4gICAgbWVyZ2UgPSBtZXJnZS5maWx0ZXIoeCA9PiB4KTsgLy8gcmVtb3ZlIG51bGwgb2JqZWN0c1xuXG4gICAgc2hhZGVycy5kZWZpbmVzID0gT2JqZWN0LmFzc2lnbih7fSwgLi4ubWVyZ2UubWFwKHggPT4geC5kZWZpbmVzKS5maWx0ZXIoeCA9PiB4KSk7XG4gICAgc2hhZGVycy51bmlmb3JtcyA9IE9iamVjdC5hc3NpZ24oe30sIC4uLm1lcmdlLm1hcCh4ID0+IHgudW5pZm9ybXMpLmZpbHRlcih4ID0+IHgpKTtcblxuICAgIC8vIE1lcmdlIHRyYW5zZm9ybXNcbiAgICBtZXJnZS5tYXAoeCA9PiB4LnRyYW5zZm9ybXMpLmZpbHRlcih4ID0+IHgpLmZvckVhY2godHJhbnNmb3JtcyA9PiB7XG4gICAgICAgIHNoYWRlcnMudHJhbnNmb3JtcyA9IHNoYWRlcnMudHJhbnNmb3JtcyB8fCB7fTtcblxuICAgICAgICBmb3IgKGxldCBbdCwgdHJhbnNmb3JtXSBvZiBVdGlscy5lbnRyaWVzKHRyYW5zZm9ybXMpKSB7XG4gICAgICAgICAgICBzaGFkZXJzLnRyYW5zZm9ybXNbdF0gPSBzaGFkZXJzLnRyYW5zZm9ybXNbdF0gfHwgW107XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybSkpIHtcbiAgICAgICAgICAgICAgICBzaGFkZXJzLnRyYW5zZm9ybXNbdF0ucHVzaCguLi50cmFuc2Zvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hhZGVycy50cmFuc2Zvcm1zW3RdLnB1c2godHJhbnNmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgU3R5bGVzW25hbWVdLnNoYWRlcnMgPSBzaGFkZXJzO1xuXG4gICAgcmV0dXJuIFN0eWxlc1tuYW1lXTtcbn07XG5cbi8vIENhbGxlZCB0byBjcmVhdGUgb3IgdXBkYXRlIHN0eWxlcyBmcm9tIHN0eWxlc2hlZXRcblN0eWxlTWFuYWdlci5idWlsZCA9IGZ1bmN0aW9uIChzdHlsZXNoZWV0X3N0eWxlcykge1xuICAgIC8vIFN0eWxlc2hlZXQtZGVmaW5lZCBzdHlsZXNcbiAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlc2hlZXRfc3R5bGVzKSB7XG4gICAgICAgIFN0eWxlc1tuYW1lXSA9IFN0eWxlTWFuYWdlci51cGRhdGUobmFtZSwgc3R5bGVzaGVldF9zdHlsZXNbbmFtZV0pO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgYWxsXG4gICAgZm9yIChuYW1lIGluIFN0eWxlcykge1xuICAgICAgICBTdHlsZXNbbmFtZV0uaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgU3R5bGVzW25hbWVdLmluaXQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3R5bGVzO1xufTtcblxuLy8gQ29tcGlsZSBhbGwgc3R5bGVzXG5TdHlsZU1hbmFnZXIuY29tcGlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIFN0eWxlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgU3R5bGVzW25hbWVdLmNvbXBpbGUoKTtcbiAgICAgICAgICAgIGxvZy50cmFjZShgU3R5bGVNYW5hZ2VyLmNvbXBpbGUoKTogY29tcGlsZWQgc3R5bGUgJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgICBsb2cuZXJyb3IoYFN0eWxlTWFuYWdlci5jb21waWxlKCk6IGVycm9yIGNvbXBpbGluZyBzdHlsZSAke25hbWV9OmAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvZy5kZWJ1ZyhgU3R5bGVNYW5hZ2VyLmNvbXBpbGUoKTogY29tcGlsZWQgYWxsIHN0eWxlc2ApO1xufTtcblxuLy8gQWRkIGJ1aWx0LWluIHJlbmRlcmluZyBzdHlsZXNcblN0eWxlTWFuYWdlci5yZWdpc3RlcihQb2x5Z29ucyk7XG5TdHlsZU1hbmFnZXIucmVnaXN0ZXIoUG9pbnRzKTtcblN0eWxlTWFuYWdlci5yZWdpc3RlcihTcHJpdGVzKTtcblN0eWxlTWFuYWdlci5yZWdpc3RlcihUZXh0U3R5bGUpO1xuIiwiaW1wb3J0IFV0aWxzIGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCBHZW8gZnJvbSAnLi4vZ2VvJztcblxuaW1wb3J0IHBhcnNlQ1NTQ29sb3IgZnJvbSAnY3NzY29sb3JwYXJzZXInO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCB2YXIgU3R5bGVQYXJzZXIgPSB7fTtcblxuLy8gU3R5bGUgbWFjcm9zXG5cblN0eWxlUGFyc2VyLmV4cGFuZE1hY3JvcyA9IGZ1bmN0aW9uIGV4cGFuZE1hY3JvcyAob2JqKSB7XG4gICAgZm9yICh2YXIgcCBpbiBvYmopIHtcbiAgICAgICAgdmFyIHZhbCA9IG9ialtwXTtcblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBvYmpbcF0gPSBleHBhbmRNYWNyb3ModmFsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0IHN0cmluZ3MgYmFjayBpbnRvIGZ1bmN0aW9uc1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZm9yICh2YXIgbSBpbiBTdHlsZVBhcnNlci5tYWNyb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsLm1hdGNoKFN0eWxlUGFyc2VyLm1hY3Jvc1ttXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGY7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKmpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWwoJ2YgPSAnICsgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qanNoaW50IGlnbm9yZTplbmQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwXSA9IGY7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cudHJhY2UoYGV4cGFuZGVkIG1hY3JvICR7dmFsfSB0byAke2Z9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFsbC1iYWNrIHRvIG9yaWdpbmFsIHZhbHVlIGlmIHBhcnNpbmcgZmFpbGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cudHJhY2UoYGZhaWxlZCB0byBleHBhbmQgbWFjcm8gJHt2YWx9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuLy8gTGlzdCBvZiBtYWNyb3NcblN0eWxlUGFyc2VyLm1hY3JvcyA9IFtcbiAgICAnU3R5bGUuY29sb3IucHNldWRvUmFuZG9tQ29sb3InLFxuICAgICdTdHlsZS5jb2xvci5yYW5kb21Db2xvcicsXG4gICAgJ1N0eWxlLnBpeGVscydcbl07XG5cblxuXG52YXIgU3R5bGUgPSB7fTtcblxuU3R5bGUuY29sb3IgPSB7XG4gICAgLy8gcHNldWRvLXJhbmRvbSBncmF5c2NhbGUgYnkgZ2VvbWV0cnkgaWRcbiAgICBwc2V1ZG9SYW5kb21HcmF5c2NhbGUoKSB7XG4gICAgICAgIHZhciBmdW5jID0gYGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGMgPSBNYXRoLm1heCgocGFyc2VJbnQoZmVhdHVyZS5pZCwgMTYpICUgMTAwKSAvIDEwMCwgMC40KTtcbiAgICAgICAgICAgIHJldHVybiBbMC43ICogYywgMC43ICogYywgMC43ICogY107XG4gICAgICAgIH1gO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICB9LFxuXG4gICAgLy8gcHNldWRvLXJhbmRvbSBjb2xvciBieSBnZW9tZXRyeSBpZFxuICAgIHBzZXVkb1JhbmRvbUNvbG9yKCkge1xuICAgICAgICB2YXIgZnVuYyA9IGBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgMC43ICogKHBhcnNlSW50KGZlYXR1cmUuaWQsIDE2KSAvIDEwMCAlIDEpLFxuICAgICAgICAgICAgICAgIDAuNyAqIChwYXJzZUludChmZWF0dXJlLmlkLCAxNikgLyAxMDAwMCAlIDEpLFxuICAgICAgICAgICAgICAgIDAuNyAqIChwYXJzZUludChmZWF0dXJlLmlkLCAxNikgLyAxMDAwMDAwICUgMSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1gO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgICAgLy8gcmV0dXJuIGBmdW5jdGlvbigpIHsgcmV0dXJuIFswLjcgKiAocGFyc2VJbnQoZmVhdHVyZS5pZCwgMTYpIC8gMTAwICUgMSksIDAuNyAqIChwYXJzZUludChmZWF0dXJlLmlkLCAxNikgLyAxMDAwMCAlIDEpLCAwLjcgKiAocGFyc2VJbnQoZmVhdHVyZS5pZCwgMTYpIC8gMTAwMDAwMCAlIDEpXTsgfWA7XG4gICAgfSxcblxuICAgIC8vIHJhbmRvbSBjb2xvclxuICAgIHJhbmRvbUNvbG9yKCkge1xuICAgICAgICB2YXIgZnVuYyA9IGBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBbMC43ICogTWF0aC5yYW5kb20oKSwgMC43ICogTWF0aC5yYW5kb20oKSwgMC43ICogTWF0aC5yYW5kb20oKV07XG4gICAgICAgIH1gO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICB9XG59O1xuXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gKHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBkeW5hbWljIHN0eWxlKSB0aGF0IGNvbnZlcnRzIHBpeGVscyB0byBtZXRlcnMgZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwuXG4vLyBUaGUgcHJvdmlkZWQgcGl4ZWwgdmFsdWUgKCdwJykgY2FuIGl0c2VsZiBiZSBhIGZ1bmN0aW9uLCBpbiB3aGljaCBjYXNlIGl0IGlzIHdyYXBwZWQgYnkgdGhpcyBvbmUuXG5TdHlsZS5waXhlbHMgPSBmdW5jdGlvbiAocCkge1xuICAgIHZhciBmO1xuICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAvLyBldmFsKCdmID0gZnVuY3Rpb24oKSB7IHJldHVybiAnICsgKHR5cGVvZiBwID09PSAnZnVuY3Rpb24nID8gJygnICsgKHAudG9TdHJpbmcoKSArICcoKSknKSA6IHApICsgJyAqIG1ldGVyc19wZXJfcGl4ZWw7IH0nKTtcbiAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuICAgIGYgPSAnZnVuY3Rpb24oKSB7IHJldHVybiAnICsgKHR5cGVvZiBwID09PSAnZnVuY3Rpb24nID8gJygnICsgKHAudG9TdHJpbmcoKSArICcoKSknKSA6IHApICsgJyAqIG1ldGVyc19wZXJfcGl4ZWw7IH0nO1xuICAgIHJldHVybiBmO1xufTtcblxuLy8gV3JhcHMgc3R5bGUgZnVuY3Rpb25zIGFuZCBwcm92aWRlcyBhIHNjb3BlIG9mIGNvbW1vbmx5IGFjY2Vzc2libGUgZGF0YTpcbi8vIC0gZmVhdHVyZTogdGhlICdwcm9wZXJ0aWVzJyBvZiB0aGUgZmVhdHVyZSwgZS5nLiBhY2Nlc3NlZCBhcyAnZmVhdHVyZS5uYW1lJ1xuLy8gLSB6b29tOiB0aGUgY3VycmVudCBtYXAgem9vbSBsZXZlbFxuLy8gLSBtZXRlcnNfcGVyX3BpeGVsOiBjb252ZXJzaW9uIGZvciBtZXRlcnMvcGl4ZWxzIGF0IGN1cnJlbnQgbWFwIHpvb21cbi8vIC0gcHJvcGVydGllczogdXNlci1kZWZpbmVkIHByb3BlcnRpZXMgb24gdGhlIHN0eWxlLXJ1bGUgb2JqZWN0IGluIHRoZSBzdHlsZXNoZWV0XG5TdHlsZVBhcnNlci53cmFwRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIHZhciBmID0gYGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZSA9IGNvbnRleHQuZmVhdHVyZS5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgICAgIGZlYXR1cmUuaWQgPSBjb250ZXh0LmZlYXR1cmUuaWQ7XG4gICAgICAgICAgICAgICAgdmFyIHpvb20gPSBjb250ZXh0Lnpvb207XG4gICAgICAgICAgICAgICAgdmFyIG1ldGVyc19wZXJfcGl4ZWwgPSBjb250ZXh0Lm1ldGVyc19wZXJfcGl4ZWw7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBjb250ZXh0LnByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgke2Z1bmN9KCkpO1xuICAgICAgICAgICAgfWA7XG4gICAgcmV0dXJuIGY7XG59O1xuXG5cbi8vIFN0eWxlIHBhcnNpbmdcblxuLy8gU3R5bGUgZGVmYXVsdHNcblN0eWxlUGFyc2VyLmRlZmF1bHRzID0ge1xuICAgIGNvbG9yOiBbMS4wLCAwLCAwXSxcbiAgICB3aWR0aDogMSxcbiAgICBzaXplOiAxLFxuICAgIGV4dHJ1ZGU6IGZhbHNlLFxuICAgIGhlaWdodDogMjAsXG4gICAgbWluX2hlaWdodDogMCxcbiAgICBvcmRlcjogMCxcbiAgICB6OiAwLFxuICAgIHN0eWxlOiB7XG4gICAgICAgIG5hbWU6ICdwb2x5Z29ucydcbiAgICB9XG59O1xuXG5cbi8vIEEgY29udGV4dCBvYmplY3QgdGhhdCBpcyBwYXNzZWQgdG8gc3R5bGUgcGFyc2luZyBmdW5jdGlvbnMgdG8gcHJvdmlkZSBhIHNjb3BlIG9mIGNvbW1vbmx5IHVzZWQgdmFsdWVzXG5TdHlsZVBhcnNlci5nZXRGZWF0dXJlUGFyc2VDb250ZXh0ID0gZnVuY3Rpb24gKGZlYXR1cmUsIHRpbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmZWF0dXJlLFxuICAgICAgICB0aWxlLFxuICAgICAgICB6b29tOiB0aWxlLmNvb3Jkcy56LFxuICAgICAgICBtZXRlcnNfcGVyX3BpeGVsOiBHZW8ubWV0ZXJzUGVyUGl4ZWwodGlsZS5jb29yZHMueiksXG4gICAgICAgIHVuaXRzX3Blcl9tZXRlcjogR2VvLnVuaXRzX3Blcl9tZXRlclt0aWxlLmNvb3Jkcy56XVxuICAgIH07XG59O1xuXG5TdHlsZVBhcnNlci5jb252ZXJ0VW5pdHMgPSBmdW5jdGlvbih2YWwsIGNvbnRleHQsIGNvbnZlcnQgPSB0cnVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB1bml0cyA9IHZhbC5tYXRjaCgvKFswLTkuLV0rKShbYS16XSspLyk7XG4gICAgICAgIGlmICh1bml0cyAmJiB1bml0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQodW5pdHNbMV0pO1xuICAgICAgICAgICAgdW5pdHMgPSB1bml0c1syXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb252ZXJ0KSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGZyb20gcGl4ZWxzXG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICdweCcpIHtcbiAgICAgICAgICAgICAgICB2YWwgKj0gR2VvLm1ldGVyc1BlclBpeGVsKGNvbnRleHQuem9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGZyb20ga2lsb21ldGVyc1xuICAgICAgICAgICAgZWxzZSBpZiAodW5pdHMgPT09ICdrbScpIHtcbiAgICAgICAgICAgICAgICB2YWwgKj0gMTAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgLy8gQXJyYXkgb2YgYXJyYXlzLCBlLmcuIHpvb20taW50ZXJwb2xhdGVkIHN0b3BzXG4gICAgICAgIGlmICh2YWwuZXZlcnkodiA9PiB7IHJldHVybiBBcnJheS5pc0FycmF5KHYpOyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5tYXAodiA9PiB7IHJldHVybiBbdlswXSwgU3R5bGVQYXJzZXIuY29udmVydFVuaXRzKHZbMV0sIGNvbnRleHQsIGNvbnZlcnQpXTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXkgb2YgdmFsdWVzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5tYXAodiA9PiB7IHJldHVybiBTdHlsZVBhcnNlci5jb252ZXJ0VW5pdHModiwgY29udGV4dCwgY29udmVydCk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59O1xuXG5TdHlsZVBhcnNlci5wYXJzZURpc3RhbmNlID0gZnVuY3Rpb24odmFsLCBjb250ZXh0LCBjb252ZXJ0ID0gdHJ1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbCA9IHZhbChjb250ZXh0KTtcbiAgICB9XG4gICAgdmFsID0gU3R5bGVQYXJzZXIuY29udmVydFVuaXRzKHZhbCwgY29udGV4dCwgY29udmVydCk7XG4gICAgdmFsID0gVXRpbHMuaW50ZXJwb2xhdGUoY29udGV4dC56b29tLCB2YWwpO1xuXG4gICAgaWYgKGNvbnZlcnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YWwgKj0gY29udGV4dC51bml0c19wZXJfbWV0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICB2YWwuZm9yRWFjaCgodiwgaSkgPT4gdmFsW2ldICo9IGNvbnRleHQudW5pdHNfcGVyX21ldGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufTtcblxuU3R5bGVQYXJzZXIucGFyc2VDb2xvciA9IGZ1bmN0aW9uKHZhbCwgY29udGV4dCA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsID0gdmFsKGNvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIENTUy1zdHlsZSBjb2xvcnNcbiAgICAvLyBUT0RPOiBjaGFuZ2UgYWxsIGNvbG9ycyB0byB1c2UgMC0yNTUgcmFuZ2UgaW50ZXJuYWxseSB0byBhdm9pZCBkaXZpZGluZyBhbmQgdGhlbiByZS1tdWx0aXBseWluZyBpbiBnZW9tIGJ1aWxkZXJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsID0gcGFyc2VDU1NDb2xvci5wYXJzZUNTU0NvbG9yKHZhbCk7XG4gICAgICAgIGlmICh2YWwgJiYgdmFsLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgdmFsID0gdmFsLnNsaWNlKDAsIDMpLm1hcChjID0+IHsgcmV0dXJuIGMgLyAyNTU7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkgJiYgdmFsLmV2ZXJ5KHYgPT4geyByZXR1cm4gQXJyYXkuaXNBcnJheSh2KTsgfSkpIHtcbiAgICAgICAgLy8gQXJyYXkgb2Ygem9vbS1pbnRlcnBvbGF0ZWQgc3RvcHMsIGUuZy4gW3pvb20sIGNvbG9yXSBwYWlyc1xuICAgICAgICB2YWwgPSB2YWwubWFwKHYgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2WzFdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciB2YyA9IHBhcnNlQ1NTQ29sb3IucGFyc2VDU1NDb2xvcih2WzFdKTtcbiAgICAgICAgICAgICAgICBpZiAodmMgJiYgdmMubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZjID0gdmMuc2xpY2UoMCwgMykubWFwKGMgPT4geyByZXR1cm4gYyAvIDI1NTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbdlswXSwgdmNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjb250ZXh0Lnpvb20pIHtcbiAgICAgICAgdmFsID0gVXRpbHMuaW50ZXJwb2xhdGUoY29udGV4dC56b29tLCB2YWwpO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgYWxwaGFcbiAgICBpZiAoIXZhbFszXSkge1xuICAgICAgICB2YWxbM10gPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG59O1xuXG4vLyBPcmRlciBpcyBzdW1tZWQgZnJvbSB0b3AgdG8gYm90dG9tIGluIHRoZSBzdHlsZSBoaWVyYXJjaHk6XG4vLyBlYWNoIGNoaWxkIG9yZGVyIHZhbHVlIGlzIGFkZGVkIHRvIHRoZSBwYXJlbnQgb3JkZXIgdmFsdWVcblN0eWxlUGFyc2VyLmNhbGN1bGF0ZU9yZGVyID0gZnVuY3Rpb24ob3JkZXIsIGNvbnRleHQpIHtcbiAgICBpZiAodHlwZW9mIG9yZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9yZGVyID0gb3JkZXIoY29udGV4dCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3JkZXIpKSB7XG4gICAgICAgIG9yZGVyID0gb3JkZXIucmVkdWNlKChzdW0sIG9yZGVyKSA9PiB7XG4gICAgICAgICAgICBvcmRlciA9IG9yZGVyIHx8IFN0eWxlUGFyc2VyLmRlZmF1bHRzLm9yZGVyO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG9yZGVyID0gb3JkZXIoY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcmRlciA9IHBhcnNlRmxvYXQob3JkZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9yZGVyIHx8IGlzTmFOKG9yZGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3VtICsgb3JkZXI7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3JkZXIgPSBwYXJzZUZsb2F0KG9yZGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3JkZXI7XG59O1xuIiwiLypnbG9iYWwgTGFiZWwgKi9cblxuaW1wb3J0IEdlbyBmcm9tICcuLi8uLi9nZW8nO1xuaW1wb3J0IGJveEludGVyc2VjdCBmcm9tICdib3gtaW50ZXJzZWN0JztcbmltcG9ydCB7VmVjdG9yfSBmcm9tICcuLi8uLi92ZWN0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYWJlbCB7XG5cbiAgICBjb25zdHJ1Y3RvciAodGV4dCwgcG9zaXRpb24sIHNpemUsIGxpbmVzKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgICAgICAgbGluZXM6IG51bGwsXG4gICAgICAgICAgICBhbmdsZTogbnVsbCxcbiAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogW10sXG4gICAgICAgICAgICBzaXplOiBbXSxcbiAgICAgICAgICAgIGJib3g6IFtdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuaWQgPSBMYWJlbC5pZCsrO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuXG4gICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgdGhpcy5zZWdtZW50X2luZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgICAgICAgICAgIHRoaXMuYW5nbGUgPSB0aGlzLmFuZ2xlRm9yU2VnbWVudCh0aGlzLmN1cnJlbnRTZWdtZW50KCkpO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMubWlkZGxlU2VnbWVudCh0aGlzLmN1cnJlbnRTZWdtZW50KCkpO1xuICAgICAgICAgICAgdGhpcy5iYm94ID0gdGhpcy5jb21wdXRlT0JCb3goKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgIHRoaXMuYmJveCA9IHRoaXMuY29tcHV0ZUJCb3goKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1pZGRsZVNlZ21lbnQoc2VnbWVudCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgKHNlZ21lbnRbMF1bMF0gKyBzZWdtZW50WzFdWzBdKSAvIDIsXG4gICAgICAgICAgICAoc2VnbWVudFswXVsxXSArIHNlZ21lbnRbMV1bMV0pIC8gMixcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBvY2NsdWRlZCAoYmJveGVzKSB7XG4gICAgICAgIGxldCBpbnRlcnNlY3QgPSBmYWxzZTtcblxuICAgICAgICBpZiAoYmJveGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGJveEludGVyc2VjdChbdGhpcy5iYm94XSwgYmJveGVzLCAoaSwgaikgPT4ge1xuICAgICAgICAgICAgICAgIGludGVyc2VjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaW50ZXJzZWN0KSB7XG4gICAgICAgICAgICBMYWJlbC5iYm94X2xhYmVsc1tiYm94ZXMubGVuZ3RoXSA9IHRoaXM7XG4gICAgICAgICAgICBiYm94ZXMucHVzaCh0aGlzLmJib3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGludGVyc2VjdDtcbiAgICB9XG5cbiAgICBpblRpbGVCb3VuZHMgKCkge1xuICAgICAgICBsZXQgbWluID0gWyB0aGlzLmJib3hbMF0sIHRoaXMuYmJveFsxXSBdO1xuICAgICAgICBsZXQgbWF4ID0gWyB0aGlzLmJib3hbMl0sIHRoaXMuYmJveFszXSBdO1xuXG4gICAgICAgIGlmICghdGhpcy5wb2ludEluVGlsZShtaW4pIHx8ICF0aGlzLnBvaW50SW5UaWxlKG1heCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG1vdmVOZXh0U2VnbWVudCAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlZ21lbnRfaW5kZXggKyAxID49IHRoaXMubGluZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZWdtZW50X2luZGV4Kys7XG4gICAgICAgIGxldCBzZWdtZW50ID0gdGhpcy5jdXJyZW50U2VnbWVudCgpO1xuXG4gICAgICAgIHRoaXMuYW5nbGUgPSB0aGlzLmFuZ2xlRm9yU2VnbWVudChzZWdtZW50KTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMubWlkZGxlU2VnbWVudChzZWdtZW50KTtcbiAgICAgICAgdGhpcy5iYm94ID0gdGhpcy5jb21wdXRlT0JCb3goKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBhbmdsZUZvclNlZ21lbnQgKHNlZ21lbnQpIHtcbiAgICAgICAgbGV0IHAwcDEgPSBWZWN0b3Iuc3ViKHNlZ21lbnRbMF0sIHNlZ21lbnRbMV0pO1xuXG4gICAgICAgIHAwcDEgPSBWZWN0b3Iubm9ybWFsaXplKHAwcDEpO1xuXG4gICAgICAgIGxldCB0aGV0YSA9IE1hdGguYXRhbjIocDBwMVswXSwgcDBwMVsxXSkgKyBNYXRoLlBJIC8gMjtcblxuICAgICAgICBpZiAodGhldGEgPiBNYXRoLlBJIC8gMiB8fMKgdGhldGEgPCAtTWF0aC5QSSAvIDIpIHtcbiAgICAgICAgICAgIHRoZXRhICs9IE1hdGguUEk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhldGE7XG4gICAgfVxuXG4gICAgcG9pbnRJblRpbGUgKHBvaW50KSB7XG4gICAgICAgIGxldCB0aWxlX3BpeGVsX3NpemUgPSBHZW8udW5pdHNfcGVyX3BpeGVsICogR2VvLnRpbGVfc2l6ZTtcblxuICAgICAgICByZXR1cm4gcG9pbnRbMF0gPiAwICYmwqBwb2ludFsxXSA+IC10aWxlX3BpeGVsX3NpemUgJiYgcG9pbnRbMF0gPCB0aWxlX3BpeGVsX3NpemUgJiYgcG9pbnRbMV0gPCAwO1xuICAgIH1cblxuICAgIGZpdFRvU2VnbWVudCAoZXhjZWVkX2hldXJpc3RpYywgc2hvdWxkX2ZpdCA9IHRydWUpIHtcbiAgICAgICAgaWYgKCFzaG91bGRfZml0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzZWdtZW50ID0gdGhpcy5jdXJyZW50U2VnbWVudCgpO1xuICAgICAgICBsZXQgcDBwMSA9IFZlY3Rvci5zdWIoc2VnbWVudFswXSwgc2VnbWVudFsxXSk7XG4gICAgICAgIGxldCBsZW5ndGggPSBWZWN0b3IubGVuZ3RoKHAwcDEpO1xuXG4gICAgICAgIGxldCBsYWJlbF9sZW5ndGggPSB0aGlzLm1lcmNhdG9yTGVuZ3RoKCk7XG5cbiAgICAgICAgaWYgKGxhYmVsX2xlbmd0aCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgLy8gYW4gZXhjZWVkIGhldXJlc3RpYyBvZiAxMDAlIHdvdWxkIGxldCB0aGUgbGFiZWwgZml0IGluIGFueSBjYXNlc1xuICAgICAgICAgICAgbGV0IGV4Y2VlZCA9ICgxIC0gKGxlbmd0aCAvIGxhYmVsX2xlbmd0aCkpICogMTAwO1xuICAgICAgICAgICAgcmV0dXJuIGV4Y2VlZCA8IGV4Y2VlZF9oZXVyaXN0aWM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGFiZWxfbGVuZ3RoIDwgbGVuZ3RoO1xuICAgIH1cblxuICAgIG1lcmNhdG9yTGVuZ3RoICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZVswXSAqIEdlby51bml0c19wZXJfcGl4ZWw7XG4gICAgfVxuXG4gICAgbWVyY2F0b3JIZWlnaHQgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplWzFdICogR2VvLnVuaXRzX3Blcl9waXhlbDtcbiAgICB9XG5cbiAgICBjdXJyZW50U2VnbWVudCAoKSB7XG4gICAgICAgIGxldCBwMSA9IHRoaXMubGluZXNbdGhpcy5zZWdtZW50X2luZGV4XTtcbiAgICAgICAgbGV0IHAyID0gdGhpcy5saW5lc1t0aGlzLnNlZ21lbnRfaW5kZXggKyAxXTtcbiAgICAgICAgcmV0dXJuIFsgcDEsIHAyIF07XG4gICAgfVxuXG4gICAgZGlzY2FyZCAobW92ZV9pbl90aWxlLCBrZWVwX2luX3RpbGUsIGJib3hlcywgZXhjZWVkX2hldXJpc3RpYykge1xuICAgICAgICAvLyBmaXJzdCBtYWluIHJ1bGUgOiBkaXNjYXJkIGxpbmUgbGFiZWxzIHRoYXQgZG9lc24ndCBmaXQgaW4gdGhlIGxpbmUgdGhleSBhcmUgc3RpY2tpbmcgdG9cbiAgICAgICAgaWYgKHRoaXMubGluZXMgJiYgIXRoaXMuZml0VG9TZWdtZW50KGV4Y2VlZF9oZXVyaXN0aWMpKSB7XG4gICAgICAgICAgICB3aGlsZSAoIXRoaXMuZml0VG9TZWdtZW50KGV4Y2VlZF9oZXVyaXN0aWMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1vdmVOZXh0U2VnbWVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkaXNjYXJkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gcGVyZm9ybSBzcGVjaWZpYyBzdHlsaW5nIHJ1bGUsIHNob3VsZCB3ZSBrZWVwIHRoZSBsYWJlbCBpbiB0aWxlIGJvdW5kcz9cbiAgICAgICAgaWYgKGtlZXBfaW5fdGlsZSkge1xuICAgICAgICAgICAgbGV0IGluX3RpbGUgPSB0aGlzLmluVGlsZUJvdW5kcygpO1xuXG4gICAgICAgICAgICBpZiAoIWluX3RpbGUgJiYgdGhpcy5saW5lcyAmJiBtb3ZlX2luX3RpbGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgZml0c190b19zZWdtZW50ID0gdGhpcy5maXRUb1NlZ21lbnQoZXhjZWVkX2hldXJpc3RpYyk7XG5cbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRoaXMgbGFiZWwgdW50aWwgd2UgZm91bmQgYSBsaW5lIHdlIGNhbiBmaXQgaW5cbiAgICAgICAgICAgICAgICB3aGlsZSAoIWluX3RpbGUgJiYgIWZpdHNfdG9fc2VnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubW92ZU5leHRTZWdtZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbid0IG1vdmUgZnVydGhlciBpbiB0aGlzIGxpbmUsIGp1c3QgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaW5fdGlsZSA9IHRoaXMuaW5UaWxlQm91bmRzKCk7XG4gICAgICAgICAgICAgICAgICAgIGZpdHNfdG9fc2VnbWVudCA9IHRoaXMuZml0VG9TZWdtZW50KGV4Y2VlZF9oZXVyaXN0aWMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRpc2NhcmQgPSAhaW5fdGlsZSB8fMKgIWZpdHNfdG9fc2VnbWVudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWluX3RpbGUpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBkaWRuJ3Qgd2FudCB0byBtb3ZlIGF0IGFsbCwganVzdCBkaXNjYXJkIHNpbmNlIHdlJ3JlIG91dCBvZiB0aWxlIGJvdW5kc1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hvdWxkIHdlIGRpc2NhcmQ/IGlmIG5vdCwganVzdCBtYWtlIG9jY2x1c2lvbiB0ZXN0XG4gICAgICAgIHJldHVybiBkaXNjYXJkIHx8IHRoaXMub2NjbHVkZWQoYmJveGVzKTtcbiAgICB9XG5cbiAgICBjb21wdXRlQkJveCAoKSB7XG4gICAgICAgIGxldCBoYWxmX21lcmNfd2lkdGggPSB0aGlzLm1lcmNhdG9yTGVuZ3RoKCkgKiAwLjU7XG4gICAgICAgIGxldCBoYWxmX21lcmNfaGVpZ2h0ID0gdGhpcy5tZXJjYXRvckhlaWdodCgpICogMC41O1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzBdIC0gaGFsZl9tZXJjX3dpZHRoLFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvblsxXSAtIGhhbGZfbWVyY19oZWlnaHQsXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzBdICsgaGFsZl9tZXJjX3dpZHRoLFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvblsxXSArIGhhbGZfbWVyY19oZWlnaHRcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBjb21wdXRlT0JCb3ggKHNpemUpIHtcbiAgICAgICAgbGV0IHVwcCA9IEdlby51bml0c19wZXJfcGl4ZWw7XG5cbiAgICAgICAgbGV0IG1lcmNfd2lkdGggPSB0aGlzLnNpemVbMF0gKiB1cHA7XG4gICAgICAgIGxldCBtZXJjX2hlaWdodCA9IHRoaXMuc2l6ZVsxXSAqIHVwcDtcblxuICAgICAgICBsZXQgYyA9IE1hdGguY29zKHRoaXMuYW5nbGUpO1xuICAgICAgICBsZXQgcyA9IE1hdGguc2luKHRoaXMuYW5nbGUpO1xuXG4gICAgICAgIGxldCB4ID0gbWVyY193aWR0aCAqIGMgLSBtZXJjX2hlaWdodCAqIHM7XG4gICAgICAgIGxldCB5ID0gbWVyY193aWR0aCAqIHMgKyBtZXJjX2hlaWdodCAqIGM7XG5cbiAgICAgICAgbGV0IG1heCA9IE1hdGgubWF4KHgsIHkpICogMC41O1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzBdIC0gbWF4LFxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvblsxXSAtIG1heCxcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMF0gKyBtYXgsXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzFdICsgbWF4XG4gICAgICAgIF07XG4gICAgfVxufVxuXG5MYWJlbC5pZCA9IDA7XG5MYWJlbC5iYm94X2xhYmVscyA9IHt9OyAvLyBtYXAgYmJveCBpbmRleCB0byBsYWJlbCBvYmplY3RcblxuIiwiLy8gVGV4dCByZW5kZXJpbmcgc3R5bGVcblxuaW1wb3J0IEJ1aWxkZXJzIGZyb20gJy4uL2J1aWxkZXJzJztcbmltcG9ydCB7U3R5bGVQYXJzZXJ9IGZyb20gJy4uL3N0eWxlX3BhcnNlcic7XG5pbXBvcnQgVGV4dHVyZSBmcm9tICcuLi8uLi9nbC90ZXh0dXJlJztcbmltcG9ydCBXb3JrZXJCcm9rZXIgZnJvbSAnLi4vLi4vdXRpbHMvd29ya2VyX2Jyb2tlcic7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IHtTcHJpdGVzfSBmcm9tICcuLi9zcHJpdGVzL3Nwcml0ZXMnO1xuaW1wb3J0IExhYmVsIGZyb20gJy4vbGFiZWwnO1xuXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcblxuZXhwb3J0IGxldCBUZXh0U3R5bGUgPSBPYmplY3QuY3JlYXRlKFNwcml0ZXMpO1xuXG5PYmplY3QuYXNzaWduKFRleHRTdHlsZSwge1xuICAgIG5hbWU6ICd0ZXh0JyxcbiAgICBzdXBlcjogU3ByaXRlcyxcbiAgICBidWlsdF9pbjogdHJ1ZSxcbiAgICBzZWxlY3Rpb246IGZhbHNlLFxuXG4gICAgaW5pdCgpIHtcblxuICAgICAgICB0aGlzLnN1cGVyLmluaXQuYXBwbHkodGhpcyk7XG5cbiAgICAgICAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHRoaXMgb2JqZWN0IHRvIGJlIGNhbGxlZCBmcm9tIHdvcmtlciB0aHJlYWRzXG4gICAgICAgIGlmIChVdGlscy5pc01haW5UaHJlYWQpIHtcbiAgICAgICAgICAgIFdvcmtlckJyb2tlci5hZGRUYXJnZXQoJ1RleHRTdHlsZScsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50ZXh0cyA9IHt9OyAvLyB1bmlxdWUgdGV4dHMsIGtleWVkIGJ5IHRpbGVcbiAgICAgICAgdGhpcy50ZXh0dXJlID0ge307XG4gICAgICAgIHRoaXMuY2FudmFzID0ge307XG4gICAgICAgIHRoaXMuYmJveGVzID0ge307XG5cbiAgICAgICAgdGhpcy5mb250X3N0eWxlID0ge1xuICAgICAgICAgICAgdHlwZWZhY2U6ICdIZWx2ZXRpY2EnLFxuICAgICAgICAgICAgc2l6ZTogJzEycHgnLFxuICAgICAgICAgICAgZmlsbDogJ3doaXRlJ1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRlZmF1bHQgbGFiZWwgc3R5bGVcbiAgICAgICAgdGhpcy5sYWJlbF9zdHlsZSA9IHtcbiAgICAgICAgICAgIGxpbmVzOiB7IGV4Y2VlZDogNjAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvLyBTZXQgZm9udCBzdHlsZSBwYXJhbXMgZm9yIGNhbnZhcyBkcmF3aW5nXG4gICAgc2V0Rm9udCAodGlsZSwgeyBzaXplLCB0eXBlZmFjZSwgZmlsbCwgc3Ryb2tlIH0pIHtcbiAgICAgICAgdGhpcy5zaXplID0gcGFyc2VJbnQoc2l6ZSk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gNjsgLy8gcGl4ZWwgcGFkZGluZyBhcm91bmQgdGV4dFxuICAgICAgICBsZXQgY3R4ID0gdGhpcy5jYW52YXNbdGlsZV0uY29udGV4dDtcblxuICAgICAgICBjdHguZm9udCA9IHNpemUgKyAnICcgKyB0eXBlZmFjZTtcbiAgICAgICAgaWYgKHN0cm9rZSkge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gNDtcbiAgICAgICAgY3R4Lm1pdGVyTGltaXQgPSAyO1xuICAgIH0sXG5cbiAgICAvLyBXaWR0aCBhbmQgaGVpZ2h0IG9mIHRleHQgYmFzZWQgb24gY3VycmVudCBmb250IHN0eWxlXG4gICAgdGV4dFNpemUgKHRleHQsIHRpbGUpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIE1hdGguY2VpbCh0aGlzLmNhbnZhc1t0aWxlXS5jb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoKSArIHRoaXMuYnVmZmVyICogMixcbiAgICAgICAgICAgIHRoaXMuc2l6ZSArIHRoaXMuYnVmZmVyICogMlxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICAvLyBEcmF3IHRleHQgYXQgc3BlY2lmaWVkIGxvY2F0aW9uLCBhZGp1c3RpbmcgZm9yIGJ1ZmZlciBhbmQgYmFzZWxpbmVcbiAgICBkcmF3VGV4dCAodGV4dCwgW3gsIHldLCB0aWxlLCBzdHJva2UpIHtcbiAgICAgICAgaWYgKHN0cm9rZSkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXNbdGlsZV0uY29udGV4dC5zdHJva2VUZXh0KHRleHQsIHggKyB0aGlzLmJ1ZmZlciwgeSArIHRoaXMuYnVmZmVyICsgdGhpcy5zaXplKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbnZhc1t0aWxlXS5jb250ZXh0LmZpbGxUZXh0KHRleHQsIHggKyB0aGlzLmJ1ZmZlciwgeSArIHRoaXMuYnVmZmVyICsgdGhpcy5zaXplKTtcbiAgICB9LFxuXG4gICAgc2V0VGV4dHVyZVRleHRQb3NpdGlvbnMgKHRleHRzKSB7XG4gICAgICAgIC8vIEZpbmQgd2lkZXN0IGxhYmVsIGFuZCBzdW0gb2YgYWxsIGxhYmVsIGhlaWdodHNcbiAgICAgICAgbGV0IHdpZGVzdCA9IDAsIGhlaWdodCA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgc3R5bGUgaW4gdGV4dHMpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0X2luZm9zID0gdGV4dHNbc3R5bGVdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCB0ZXh0IGluIHRleHRfaW5mb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dF9pbmZvID0gdGV4dF9pbmZvc1t0ZXh0XTtcbiAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHRleHRfaW5mby5zaXplO1xuXG4gICAgICAgICAgICAgICAgdGV4dF9pbmZvLnBvc2l0aW9uID0gWzAsIGhlaWdodF07XG5cbiAgICAgICAgICAgICAgICBpZiAoc2l6ZVswXSA+IHdpZGVzdCkge1xuICAgICAgICAgICAgICAgICAgICB3aWRlc3QgPSBzaXplWzBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGhlaWdodCArPSBzaXplWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFsgd2lkZXN0LCBoZWlnaHQgXTtcbiAgICB9LFxuXG4gICAgZ2V0VGV4dFNpemVzICh0aWxlLCB0ZXh0cykge1xuICAgICAgICAvLyBjcmVhdGUgYSBjYW52YXNcbiAgICAgICAgaWYoIXRoaXMuY2FudmFzW3RpbGVdKSB7XG4gICAgICAgICAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICB0aGlzLmNhbnZhc1t0aWxlXSA9IHtcbiAgICAgICAgICAgICAgICBjYW52YXM6IGNhbnZhcyxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHN0eWxlIGluIHRleHRzKSB7XG4gICAgICAgICAgICBsZXQgdGV4dF9pbmZvcyA9IHRleHRzW3N0eWxlXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgdGV4dCBpbiB0ZXh0X2luZm9zKSB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRleHQgc2l6ZXNcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZvbnQodGlsZSwgdGV4dF9pbmZvc1t0ZXh0XS50ZXh0X3N0eWxlKTtcbiAgICAgICAgICAgICAgICB0ZXh0X2luZm9zW3RleHRdLnNpemUgPSB0aGlzLnRleHRTaXplKHRleHQsIHRpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0ZXh0cyk7XG4gICAgfSxcblxuICAgIC8vIENhbGxlZCBvbiBtYWluIHRocmVhZCB0byByZWxlYXNlIHRpbGUtc3BlY2lmaWMgcmVzb3VyY2VzXG4gICAgZnJlZVRpbGUgKHRpbGUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FudmFzW3RpbGVdO1xuICAgICAgICBkZWxldGUgdGhpcy50ZXh0dXJlW3RpbGVdO1xuICAgIH0sXG5cbiAgICByYXN0ZXJpemUgKHRpbGUsIHRleHRzLCB0ZXh0dXJlX3NpemUpIHtcbiAgICAgICAgZm9yIChsZXQgc3R5bGUgaW4gdGV4dHMpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0X2luZm9zID0gdGV4dHNbc3R5bGVdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCB0ZXh0IGluIHRleHRfaW5mb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5mbyA9IHRleHRfaW5mb3NbdGV4dF07XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNldEZvbnQodGlsZSwgaW5mby50ZXh0X3N0eWxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdUZXh0KHRleHQsIGluZm8ucG9zaXRpb24sIHRpbGUsIGluZm8udGV4dF9zdHlsZS5zdHJva2UpO1xuXG4gICAgICAgICAgICAgICAgaW5mby50ZXhjb29yZHMgPSBCdWlsZGVycy5nZXRUZXhjb29yZHNGb3JTcHJpdGUoXG4gICAgICAgICAgICAgICAgICAgIGluZm8ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGluZm8uc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZV9zaXplXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBDYWxsZWQgb24gbWFpbiB0aHJlYWQgZnJvbSB3b3JrZXIsIHRvIGNyZWF0ZSBhdGxhcyBvZiBsYWJlbHMgZm9yIGEgdGlsZVxuICAgIGFkZFRleHRzICh0aWxlLCB0ZXh0cykge1xuICAgICAgICB0aGlzLnRleHRzW3RpbGVdID0gdGV4dHM7XG5cbiAgICAgICAgbGV0IHRleHR1cmVfc2l6ZSA9IHRoaXMuc2V0VGV4dHVyZVRleHRQb3NpdGlvbnModGV4dHMpO1xuICAgICAgICBsZXQgY29udGV4dCA9IHRoaXMuY2FudmFzW3RpbGVdLmNvbnRleHQ7XG5cbiAgICAgICAgbG9nLnRyYWNlKGB0ZXh0IHN1bW1hcnkgZm9yIHRpbGUgJHt0aWxlfTogZml0cyBpbiAke3RleHR1cmVfc2l6ZVswXX14JHt0ZXh0dXJlX3NpemVbMV19cHhgKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGNhbnZhcyBcImNvbnRleHRcIlxuICAgICAgICB0aGlzLmNhbnZhc1t0aWxlXS5jYW52YXMud2lkdGggPSB0ZXh0dXJlX3NpemVbMF07XG4gICAgICAgIHRoaXMuY2FudmFzW3RpbGVdLmNhbnZhcy5oZWlnaHQgPSB0ZXh0dXJlX3NpemVbMV07XG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRleHR1cmVfc2l6ZVswXSwgdGV4dHVyZV9zaXplWzFdKTtcblxuICAgICAgICAvLyBjcmVhdGUgYSB0ZXh0dXJlXG4gICAgICAgIGxldCB0ZXh0dXJlID0gJ2xhYmVscy0nICsgdGlsZSArICctJyArIChUZXh0U3R5bGUudGV4dHVyZV9pZCsrKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlW3RpbGVdID0gbmV3IFRleHR1cmUodGhpcy5nbCwgdGV4dHVyZSwgeyBmaWx0ZXJpbmc6ICdsaW5lYXInIH0pO1xuICAgICAgICAvLyB0aGlzLnRleHR1cmVbdGlsZV0ub3duZXIgPSB7IHRpbGUgfTtcblxuICAgICAgICAvLyBhc2sgZm9yIHJhc3Rlcml6YXRpb24gZm9yIHRoZSB0ZXh0IHNldFxuICAgICAgICB0aGlzLnJhc3Rlcml6ZSh0aWxlLCB0ZXh0cywgdGV4dHVyZV9zaXplKTtcblxuICAgICAgICB0aGlzLnRleHR1cmVbdGlsZV0uc2V0Q2FudmFzKHRoaXMuY2FudmFzW3RpbGVdLmNhbnZhcyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRleHR1cmVbdGlsZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbnZhc1t0aWxlXTsgLy8gd2UgZG9uJ3QgbmVlZCBjYW52YXMgb25jZSBpdCBoYXMgYmVlbiBjb3BpZWQgdG8gR1BVIHRleHR1cmVcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgdGV4dHM6IHRoaXMudGV4dHNbdGlsZV0sIHRleHR1cmUgfSk7XG4gICAgfSxcblxuICAgIC8vIE92ZXJyaWRlXG4gICAgc3RhcnREYXRhICgpIHtcbiAgICAgICAgbGV0IHRpbGVfZGF0YSA9IHRoaXMuc3VwZXIuc3RhcnREYXRhLmFwcGx5KHRoaXMpO1xuICAgICAgICB0aWxlX2RhdGEucXVldWUgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRpbGVfZGF0YTtcbiAgICB9LFxuXG4gICAgLy8gT3ZlcnJpZGVcbiAgICBlbmREYXRhICh0aWxlX2RhdGEpIHtcbiAgICAgICAgLy8gQ291bnQgY29sbGVjdGVkIHRleHRcbiAgICAgICAgbGV0IHRpbGUsIGNvdW50O1xuICAgICAgICBpZiAodGlsZV9kYXRhLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRpbGUgPSB0aWxlX2RhdGEucXVldWVbMF1bMl0udGlsZS5rZXk7XG4gICAgICAgICAgICBjb3VudCA9IE9iamVjdC5rZXlzKHRoaXMudGV4dHNbdGlsZV18fHt9KS5sZW5ndGg7XG4gICAgICAgICAgICBsb2cudHJhY2UoYCMgdGV4dHMgZm9yIHRpbGUgJHt0aWxlfTogJHtjb3VudH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXJzdCBjYWxsIHRvIG1haW4gdGhyZWFkLCBhc2sgZm9yIHRleHQgcGl4ZWwgc2l6ZXNcbiAgICAgICAgcmV0dXJuIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSgnVGV4dFN0eWxlJywgJ2dldFRleHRTaXplcycsIHRpbGUsIHRoaXMudGV4dHNbdGlsZV0pLnRoZW4odGV4dHMgPT4ge1xuICAgICAgICAgICAgdGhpcy5iYm94ZXNbdGlsZV0gPSBbXTtcblxuICAgICAgICAgICAgLy8gY2xlYW51cCBvZiB0ZXh0cyB0aGF0IHNob3VsZCBiZSByZW1vdmVkIGFmdGVyIG9jY2x1c2lvbiB0ZXN0XG4gICAgICAgICAgICBmb3IgKGxldCBzdHlsZSBpbiB0ZXh0cykge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0X2luZm9zID0gdGV4dHNbc3R5bGVdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdGV4dCBpbiB0ZXh0X2luZm9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0X2luZm8gPSB0ZXh0X2luZm9zW3RleHRdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBrZWVwX2luX3RpbGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3ZlX2luX3RpbGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBnZW9tZXRyeSA9IHRoaXMudGV4dHNbdGlsZV1bc3R5bGVdW3RleHRdLmdlb21ldHJ5O1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXhjZWVkX2hldXJpc3RpYyA9IHRoaXMubGFiZWxfc3R5bGUubGluZXMuZXhjZWVkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSBcIkxpbmVTdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGluZSA9IFtsaW5lc1swXV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBfaW5fdGlsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlX2luX3RpbGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IG5ldyBMYWJlbCh0ZXh0LCBsaW5lWzBdLCB0ZXh0X2luZm8uc2l6ZSwgbGluZXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09IFwiUG9pbnRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50cyA9IFtnZW9tZXRyeS5jb29yZGluYXRlc107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBfaW5fdGlsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlX2luX3RpbGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBuZXcgTGFiZWwodGV4dCwgcG9pbnRzWzBdLCB0ZXh0X2luZm8uc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IE11bHRpTGluZVN0cmluZywgTXVsdGlQb2ludCwgUG9seWdvbiwgYW5kIE11bHRpUG9seWdvbiBsYWJlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsLmRpc2NhcmQobW92ZV9pbl90aWxlLCBrZWVwX2luX3RpbGUsIHRoaXMuYmJveGVzW3RpbGVdLCBleGNlZWRfaGV1cmlzdGljKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSB0ZXh0IGZyb20gdGhlIG1hcFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRleHRfaW5mb3NbdGV4dF07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0ZXh0X2luZm8ubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBObyBsYWJlbHMgZm9yIHRoaXMgc3R5bGVcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModGV4dF9pbmZvcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0ZXh0c1tzdHlsZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBObyBsYWJlbHMgZm9yIHRoaXMgdGlsZVxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRleHRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UoJ1RleHRTdHlsZScsICdmcmVlVGlsZScsIHRpbGUpO1xuICAgICAgICAgICAgICAgIC8vIGVhcmx5IGV4aXRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNlY29uZCBjYWxsIHRvIG1haW4gdGhyZWFkLCBmb3IgcmFzdGVyaXppbmcgdGhlIHNldCBvZiB0ZXh0c1xuICAgICAgICAgICAgcmV0dXJuIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSgnVGV4dFN0eWxlJywgJ2FkZFRleHRzJywgdGlsZSwgdGV4dHMpLnRoZW4oKHsgdGV4dHMsIHRleHR1cmUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dHNbdGlsZV0gPSB0ZXh0cztcblxuICAgICAgICAgICAgICAgIC8vIEF0dGFjaCB0aWxlLXNwZWNpZmljIGxhYmVsIGF0bGFzIHRvIG1lc2ggYXMgYSB0ZXh0dXJlIHVuaWZvcm1cbiAgICAgICAgICAgICAgICB0aWxlX2RhdGEudW5pZm9ybXMgPSB7IHVfdGV4dHVyZXM6IFt0ZXh0dXJlXSB9O1xuICAgICAgICAgICAgICAgIHRpbGVfZGF0YS50ZXh0dXJlcyA9IFt0ZXh0dXJlXTsgLy8gYXNzaWduIHRleHR1cmUgb3duZXJzaGlwIHRvIHRpbGVcblxuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIHF1ZXVlZCBmZWF0dXJlc1xuICAgICAgICAgICAgICAgIHRpbGVfZGF0YS5xdWV1ZS5mb3JFYWNoKHEgPT4gdGhpcy5zdXBlci5hZGRGZWF0dXJlLmFwcGx5KHRoaXMsIHEpKTtcbiAgICAgICAgICAgICAgICB0aWxlX2RhdGEucXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy50ZXh0c1t0aWxlXTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1cGVyLmVuZERhdGEuY2FsbCh0aGlzLCB0aWxlX2RhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBPdmVycmlkZSB0byBxdWV1ZSBmZWF0dXJlcyBpbnN0ZWFkIG9mIHByb2Nlc3NpbmcgaW1tZWRpYXRlbHlcbiAgICBhZGRGZWF0dXJlIChmZWF0dXJlLCBydWxlLCBjb250ZXh0LCB0aWxlX2RhdGEpIHtcbiAgICAgICAgLy8gQ29sbGVjdCB0ZXh0XG4gICAgICAgIGxldCB0ZXh0ID0gZmVhdHVyZS5wcm9wZXJ0aWVzLm5hbWU7XG5cbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIGxldCB0aWxlID0gY29udGV4dC50aWxlLmtleTtcbiAgICAgICAgICAgIGlmICghdGhpcy50ZXh0c1t0aWxlXSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dHNbdGlsZV0gPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHN0eWxlID0gdGhpcy5jb25zdHJ1Y3RGb250U3R5bGUocnVsZSwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgc3R5bGVfa2V5ID0gdGhpcy5jb25zdHJ1Y3RTdHlsZUtleShzdHlsZSk7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgZm9udCBzdHlsZSBpbmZvIG9uIGZlYXR1cmUgZm9yIGxhdGVyIHVzZSBkdXJpbmcgZ2VvbWV0cnkgY29uc3RydWN0aW9uXG4gICAgICAgICAgICBmZWF0dXJlLmZvbnRfc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgICAgIGZlYXR1cmUuZm9udF9zdHlsZV9rZXkgPSBzdHlsZV9rZXk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy50ZXh0c1t0aWxlXVtzdHlsZV9rZXldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0c1t0aWxlXVtzdHlsZV9rZXldID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudGV4dHNbdGlsZV1bc3R5bGVfa2V5XVt0ZXh0XSA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0X3N0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogZmVhdHVyZS5nZW9tZXRyeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbGVfZGF0YS5xdWV1ZS5wdXNoKFtmZWF0dXJlLCBydWxlLCBjb250ZXh0LCB0aWxlX2RhdGFdKTtcbiAgICB9LFxuXG4gICAgY29uc3RydWN0Rm9udFN0eWxlIChydWxlLCBjb250ZXh0KSB7XG4gICAgICAgIGxldCBzdHlsZTtcblxuICAgICAgICBpZiAocnVsZS5mb250KSB7XG4gICAgICAgICAgICBydWxlLmZvbnQuZmlsbCA9IHJ1bGUuZm9udC5maWxsICYmIFN0eWxlUGFyc2VyLnBhcnNlQ29sb3IocnVsZS5mb250LmZpbGwsIGNvbnRleHQpO1xuICAgICAgICAgICAgcnVsZS5mb250LnN0cm9rZSA9IHJ1bGUuZm9udC5zdHJva2UgJiYgU3R5bGVQYXJzZXIucGFyc2VDb2xvcihydWxlLmZvbnQuc3Ryb2tlLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgdHlwZWZhY2U6IHJ1bGUuZm9udC50eXBlZmFjZSB8fMKgdGhpcy5mb250X3N0eWxlLnR5cGVmYWNlLFxuICAgICAgICAgICAgICAgIHNpemU6IHJ1bGUuZm9udC5zaXplIHx8IHRoaXMuZm9udF9zdHlsZS5zaXplLFxuICAgICAgICAgICAgICAgIGZpbGw6ICFydWxlLmZvbnQuZmlsbCA/IHRoaXMuZm9udF9zdHlsZS5maWxsIDogVXRpbHMudG9DYW52YXNDb2xvcihydWxlLmZvbnQuZmlsbCksXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAhcnVsZS5mb250LnN0cm9rZSA/IHRoaXMuZm9udF9zdHlsZS5zdHJva2UgOiBVdGlscy50b0NhbnZhc0NvbG9yKHJ1bGUuZm9udC5zdHJva2UpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBjb25zdHJ1Y3RTdHlsZUtleSAoeyB0eXBlZmFjZSwgc2l6ZSwgZmlsbCwgc3Ryb2tlIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3R5cGVmYWNlfS8ke3NpemV9LyR7ZmlsbH0vJHtzdHJva2V9YDtcbiAgICB9LFxuXG4gICAgYnVpbGQgKHN0eWxlLCB2ZXJ0ZXhfZGF0YSkge1xuICAgICAgICBsZXQgdmVydGV4X3RlbXBsYXRlID0gdGhpcy5tYWtlVmVydGV4VGVtcGxhdGUoc3R5bGUpO1xuXG4gICAgICAgIEJ1aWxkZXJzLmJ1aWxkU3ByaXRlUXVhZHNGb3JQb2ludHMoXG4gICAgICAgICAgICBbIHN0eWxlLmxhYmVsLnBvc2l0aW9uIF0sXG4gICAgICAgICAgICBVdGlscy5zY2FsZUludDE2KHN0eWxlLmxhYmVsLnNpemVbMF0sIDEyOCksIFV0aWxzLnNjYWxlSW50MTYoc3R5bGUubGFiZWwuc2l6ZVsxXSwgMTI4KSxcbiAgICAgICAgICAgIFV0aWxzLnNjYWxlSW50MTYoVXRpbHMucmFkVG9EZWcoc3R5bGUubGFiZWwuYW5nbGUpLCAzNjApLFxuICAgICAgICAgICAgVXRpbHMuc2NhbGVJbnQxNigxLCAyNTYpLFxuICAgICAgICAgICAgdmVydGV4X2RhdGEsXG4gICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGUsXG4gICAgICAgICAgICB0aGlzLnZlcnRleF9sYXlvdXQuaW5kZXguYV9zaGFwZSxcbiAgICAgICAgICAgIHsgdGV4Y29vcmRfaW5kZXg6IHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX3RleGNvb3JkLCB0ZXhjb29yZF9zY2FsZTogdGhpcy50ZXhjb29yZF9zY2FsZSB9XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGJ1aWxkTGluZXMgKGxpbmVzLCBzdHlsZSwgdmVydGV4X2RhdGEpIHtcbiAgICAgICAgdGhpcy5idWlsZChzdHlsZSwgdmVydGV4X2RhdGEpO1xuICAgIH0sXG5cbiAgICBidWlsZFBvaW50cyAocG9pbnRzLCBzdHlsZSwgdmVydGV4X2RhdGEpIHtcbiAgICAgICAgdGhpcy5idWlsZChzdHlsZSwgdmVydGV4X2RhdGEpO1xuICAgIH0sXG5cbiAgICBfcGFyc2VGZWF0dXJlIChmZWF0dXJlLCBydWxlX3N0eWxlLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIGRlYnVnZ2VyO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhgbGFiZWwgJHtmZWF0dXJlLnByb3BlcnRpZXMubmFtZX0gdGlsZSAke2NvbnRleHQudGlsZS5rZXl9YCwgZmVhdHVyZSwgY29udGV4dC50aWxlKTtcblxuICAgICAgICBsZXQgc3R5bGUgPSB0aGlzLmZlYXR1cmVfc3R5bGU7XG4gICAgICAgIGxldCB0aWxlID0gY29udGV4dC50aWxlLmtleTtcbiAgICAgICAgbGV0IHRleHQgPSBmZWF0dXJlLnByb3BlcnRpZXMubmFtZTsgLy8gVE9ETzogbWFrZSBjb25maWd1cmFibGVcbiAgICAgICAgbGV0IHN0eWxlX2tleSA9IGZlYXR1cmUuZm9udF9zdHlsZV9rZXk7XG4gICAgICAgIGxldCB0ZXh0X2luZm8gPSB0aGlzLnRleHRzW3RpbGVdICYmIHRoaXMudGV4dHNbdGlsZV1bc3R5bGVfa2V5XSAmJiB0aGlzLnRleHRzW3RpbGVdW3N0eWxlX2tleV1bdGV4dF07XG5cbiAgICAgICAgaWYgKCF0ZXh0X2luZm8gfHwgIXRleHRfaW5mby5sYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50ZXhjb29yZF9zY2FsZSA9IHRleHRfaW5mby50ZXhjb29yZHM7XG4gICAgICAgIHN0eWxlLnRleHQgPSB0ZXh0O1xuICAgICAgICBzdHlsZS50aWxlID0gdGlsZTsgLy8gdG8gc3RvcmUgYmJveCBieSB0aWxlc1xuICAgICAgICBzdHlsZS5sYWJlbCA9IHRleHRfaW5mby5sYWJlbDtcblxuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuXG59KTtcblxuVGV4dFN0eWxlLnRleHR1cmVfaWQgPSAwO1xuIiwiLypnbG9iYWwgVGlsZSAqL1xuaW1wb3J0IEdlbyBmcm9tICcuL2dlbyc7XG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9wYXJzZXInO1xuaW1wb3J0IFdvcmtlckJyb2tlciBmcm9tICcuL3V0aWxzL3dvcmtlcl9icm9rZXInO1xuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi9nbC90ZXh0dXJlJztcblxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGUge1xuXG4gICAgLyoqXG4gICAgICAgIFRpbGVcbiAgICAgICAgQGNvbnN0cnVjdG9yXG4gICAgICAgIFJlcXVpcmVkIHByb3BlcnRpZXM6XG4gICAgICAgIGNvb3Jkczogb2JqZWN0IHdpdGgge3gsIHksIHp9IHByb3BlcnRpZXMgaWRlbnRpZnlpbmcgdGlsZSBjb29yZGluYXRlIGxvY2F0aW9uXG4gICAgICAgIHdvcmtlcjogd2ViIHdvcmtlciB0byBoYW5kbGUgdGlsZSBjb25zdHJ1Y3Rpb25cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgY29vcmRzLCB3b3JrZXIsIG1heF96b29tIH0pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7XG4gICAgICAgICAgICBjb29yZHM6IHtcbiAgICAgICAgICAgICAgICB4OiBudWxsLFxuICAgICAgICAgICAgICAgIHk6IG51bGwsXG4gICAgICAgICAgICAgICAgejogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlYnVnOiB7fSxcbiAgICAgICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgbG9hZGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgd29ya2VyOiBudWxsLFxuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBvcmRlcjoge1xuICAgICAgICAgICAgICAgIG1pbjogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgbWF4OiAtSW5maW5pdHlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjZW50ZXJfZGlzdDogMFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLndvcmtlciA9IHdvcmtlcjtcbiAgICAgICAgdGhpcy5tYXhfem9vbSA9IG1heF96b29tO1xuXG4gICAgICAgIHRoaXMuY29vcmRzID0gY29vcmRzO1xuICAgICAgICB0aGlzLmNvb3JkcyA9IFRpbGUuY2FsY3VsYXRlT3Zlclpvb20odGhpcy5jb29yZHMsIHRoaXMubWF4X3pvb20pO1xuICAgICAgICB0aGlzLmtleSA9IFRpbGUua2V5KHRoaXMuY29vcmRzKTtcbiAgICAgICAgdGhpcy5taW4gPSBHZW8ubWV0ZXJzRm9yVGlsZSh0aGlzLmNvb3Jkcyk7XG4gICAgICAgIHRoaXMubWF4ID0gR2VvLm1ldGVyc0ZvclRpbGUoe3g6IHRoaXMuY29vcmRzLnggKyAxLCB5OiB0aGlzLmNvb3Jkcy55ICsgMSwgejogdGhpcy5jb29yZHMueiB9KSxcbiAgICAgICAgdGhpcy5zcGFuID0geyB4OiAodGhpcy5tYXgueCAtIHRoaXMubWluLngpLCB5OiAodGhpcy5tYXgueSAtIHRoaXMubWluLnkpIH07XG4gICAgICAgIHRoaXMuYm91bmRzID0geyBzdzogeyB4OiB0aGlzLm1pbi54LCB5OiB0aGlzLm1heC55IH0sIG5lOiB7IHg6IHRoaXMubWF4LngsIHk6IHRoaXMubWluLnkgfSB9O1xuXG4gICAgICAgIHRoaXMubWVzaGVzID0ge307IC8vIHJlbmRlcmFibGUgVkJPIG1lc2hlcyBrZXllZCBieSBzdHlsZVxuICAgICAgICB0aGlzLnRleHR1cmVzID0gW107IC8vIHRleHR1cmVzIHRoYXQgdGhlIHRpbGUgb3ducyAobGFiZWxzLCBldGMuKVxuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGUoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IFRpbGUoc3BlYyk7XG4gICAgfVxuXG4gICAgc3RhdGljIGtleSh7eCwgeSwgen0pIHtcbiAgICAgICAgcmV0dXJuIFt4LCB5LCB6XS5qb2luKCcvJyk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNhbGN1bGF0ZU92ZXJab29tKHt4LCB5LCB6fSwgbWF4X3pvb20pIHtcbiAgICAgICAgbWF4X3pvb20gPSBtYXhfem9vbSB8fCB6O1xuXG4gICAgICAgIGlmICh6ID4gbWF4X3pvb20pIHtcbiAgICAgICAgICAgIGxldCB6ZGlmZiA9IHogLSBtYXhfem9vbTtcblxuICAgICAgICAgICAgeCA9IE1hdGguZmxvb3IoeCA+PiB6ZGlmZik7XG4gICAgICAgICAgICB5ID0gTWF0aC5mbG9vcih5ID4+IHpkaWZmKTtcbiAgICAgICAgICAgIHogLT0gemRpZmY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge3gsIHksIHp9O1xuICAgIH1cblxuICAgIC8vIFNvcnQgYSBzZXQgb2YgdGlsZSBpbnN0YW5jZXMgKHdoaWNoIGFscmVhZHkgaGF2ZSBhIGRpc3RhbmNlIGZyb20gY2VudGVyIHRpbGUgY29tcHV0ZWQpXG4gICAgc3RhdGljIHNvcnQodGlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRpbGVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGxldCBhZCA9IGEuY2VudGVyX2Rpc3Q7XG4gICAgICAgICAgICBsZXQgYmQgPSBiLmNlbnRlcl9kaXN0O1xuICAgICAgICAgICAgcmV0dXJuIChiZCA+IGFkID8gLTEgOiAoYmQgPT09IGFkID8gMCA6IDEpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnJlZVJlc291cmNlcygpIHtcbiAgICAgICAgaWYgKHRoaXMubWVzaGVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBtIGluIHRoaXMubWVzaGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNoZXNbbV0uZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50ZXh0dXJlcykge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0dXJlID0gVGV4dHVyZS50ZXh0dXJlc1t0XTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1lc2hlcyA9IHt9O1xuICAgICAgICB0aGlzLnRleHR1cmVzID0gW107XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy53b3JrZXJNZXNzYWdlKCdyZW1vdmVUaWxlJywgdGhpcy5rZXkpO1xuICAgICAgICB0aGlzLmZyZWVSZXNvdXJjZXMoKTtcbiAgICAgICAgdGhpcy53b3JrZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGJ1aWxkQXNNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgIGNvb3JkczogdGhpcy5jb29yZHMsXG4gICAgICAgICAgICBtaW46IHRoaXMubWluLFxuICAgICAgICAgICAgbWF4OiB0aGlzLm1heCxcbiAgICAgICAgICAgIG9yZGVyOiB0aGlzLm9yZGVyLFxuICAgICAgICAgICAgZGVidWc6IHRoaXMuZGVidWdcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB3b3JrZXJNZXNzYWdlICguLi5tZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UodGhpcy53b3JrZXIsIC4uLm1lc3NhZ2UpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSBzY2VuZSBkZXBlbmRlbmN5XG4gICAgYnVpbGQoc2NlbmUpIHtcbiAgICAgICAgc2NlbmUudHJhY2tUaWxlQnVpbGRTdGFydCh0aGlzLmtleSk7XG4gICAgICAgIHRoaXMud29ya2VyTWVzc2FnZShcbiAgICAgICAgICAgICdidWlsZFRpbGUnLFxuICAgICAgICAgICAgeyB0aWxlOiB0aGlzLmJ1aWxkQXNNZXNzYWdlKCkgfSlcbiAgICAgICAgLnRoZW4obWVzc2FnZSA9PiB7XG4gICAgICAgICAgICBzY2VuZS5idWlsZFRpbGVDb21wbGV0ZWQobWVzc2FnZSk7XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGdlb21ldHJ5IGZvciB0aWxlIC0gY2FsbGVkIGJ5IHdlYiB3b3JrZXJcbiAgICAvLyBSZXR1cm5zIGEgc2V0IG9mIHRpbGUga2V5cyB0aGF0IHNob3VsZCBiZSBzZW50IHRvIHRoZSBtYWluIHRocmVhZCAoc28gdGhhdCB3ZSBjYW4gbWluaW1pemUgZGF0YSBleGNoYW5nZSBiZXR3ZWVuIHdvcmtlciBhbmQgbWFpbiB0aHJlYWQpXG4gICAgc3RhdGljIGJ1aWxkR2VvbWV0cnkgKHRpbGUsIGxheWVycywgcnVsZXMsIHN0eWxlcykge1xuICAgICAgICB0aWxlLmRlYnVnLnJlbmRlcmluZyA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgICAgIGxldCB0aWxlX2RhdGEgPSB7fTtcblxuICAgICAgICBmb3IgKGxldCBzb3VyY2VOYW1lIGluIHRpbGUuc291cmNlcykge1xuICAgICAgICAgICAgbGV0IHNvdXJjZSA9IHRpbGUuc291cmNlc1tzb3VyY2VOYW1lXTtcbiAgICAgICAgICAgIHNvdXJjZS5kZWJ1Zy5yZW5kZXJpbmcgPSArbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHNvdXJjZS5kZWJ1Zy5mZWF0dXJlcyA9IDA7XG5cbiAgICAgICAgICAgIC8vIFRyZWF0IHRvcC1sZXZlbCBzdHlsZSBydWxlcyBhcyAnbGF5ZXJzJ1xuICAgICAgICAgICAgZm9yIChsZXQgbGF5ZXJfbmFtZSBpbiBsYXllcnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGF5ZXIgPSBsYXllcnNbbGF5ZXJfbmFtZV07XG4gICAgICAgICAgICAgICAgLy8gU2tpcCBsYXllcnMgd2l0aCBubyBnZW9tZXRyeSBkZWZpbmVkXG4gICAgICAgICAgICAgICAgaWYgKCFsYXllci5nZW9tZXRyeSkge1xuICAgICAgICAgICAgICAgICAgICBsb2cud2FybihgTGF5ZXIgJHtsYXllcn0gd2FzIGRlZmluZWQgd2l0aG91dCBhbiBnZW9tZXRyeSBjb25maWd1cmF0aW9uIGFuZCB3aWxsIG5vdCBiZSByZW5kZXJlZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGdlb20gPSBUaWxlLmdldEdlb21ldHJ5Rm9yU291cmNlKHNvdXJjZSwgbGF5ZXIuZ2VvbWV0cnkpO1xuICAgICAgICAgICAgICAgIGlmICghZ2VvbSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZW5kZXIgZmVhdHVyZXMgd2l0aGluIGVhY2ggbGF5ZXIsIGluIHJldmVyc2Ugb3JkZXIgLSBha2EgdG9wIHRvIGJvdHRvbVxuICAgICAgICAgICAgICAgIGxldCBudW1fZmVhdHVyZXMgPSBnZW9tLmZlYXR1cmVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBmID0gbnVtX2ZlYXR1cmVzLTE7IGYgPj0gMDsgZi0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmZWF0dXJlID0gZ2VvbS5mZWF0dXJlc1tmXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRleHQgPSBTdHlsZVBhcnNlci5nZXRGZWF0dXJlUGFyc2VDb250ZXh0KGZlYXR1cmUsIHRpbGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgbWF0Y2hpbmcgcnVsZXNcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxheWVyX3J1bGVzID0gcnVsZXNbbGF5ZXJfbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBydWxlID0gbGF5ZXJfcnVsZXMuZmluZE1hdGNoaW5nUnVsZXMoY29udGV4dCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgJiByZW5kZXIgc3R5bGVzXG4gICAgICAgICAgICAgICAgICAgIGlmICghcnVsZSB8fCAhcnVsZS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0byBzdHlsZVxuICAgICAgICAgICAgICAgICAgICBydWxlLm5hbWUgPSBydWxlLm5hbWUgfHwgU3R5bGVQYXJzZXIuZGVmYXVsdHMuc3R5bGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0eWxlID0gc3R5bGVzW3J1bGUubmFtZV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aWxlX2RhdGFbcnVsZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZV9kYXRhW3J1bGUubmFtZV0gPSBzdHlsZS5zdGFydERhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmFkZEZlYXR1cmUoZmVhdHVyZSwgcnVsZSwgY29udGV4dCwgdGlsZV9kYXRhW3J1bGUubmFtZV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZS5kZWJ1Zy5mZWF0dXJlcysrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzb3VyY2UuZGVidWcucmVuZGVyaW5nID0gK25ldyBEYXRlKCkgLSBzb3VyY2UuZGVidWcucmVuZGVyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluYWxpemUgYXJyYXkgYnVmZmVyIGZvciBlYWNoIHJlbmRlciBzdHlsZVxuICAgICAgICB0aWxlLm1lc2hfZGF0YSA9IHt9O1xuICAgICAgICBsZXQgcXVldWUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgc3R5bGVfbmFtZSBpbiB0aWxlX2RhdGEpIHtcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IHN0eWxlc1tzdHlsZV9uYW1lXTtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goc3R5bGUuZW5kRGF0YSh0aWxlX2RhdGFbc3R5bGVfbmFtZV0pLnRoZW4oKHN0eWxlX2RhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVfZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aWxlLm1lc2hfZGF0YVtzdHlsZV9uYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleF9kYXRhOiBzdHlsZV9kYXRhLnZlcnRleF9kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXM6IHN0eWxlX2RhdGEudW5pZm9ybXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlczogc3R5bGVfZGF0YS50ZXh0dXJlc1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyYWNrIG1pbi9tYXggb3JkZXIgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlX2RhdGEub3JkZXIubWluIDwgdGlsZS5vcmRlci5taW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGUub3JkZXIubWluID0gc3R5bGVfZGF0YS5vcmRlci5taW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlX2RhdGEub3JkZXIubWF4ID4gdGlsZS5vcmRlci5tYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGUub3JkZXIubWF4ID0gc3R5bGVfZGF0YS5vcmRlci5tYXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocXVldWUpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gQWdncmVnYXRlIGRlYnVnIGluZm9cbiAgICAgICAgICAgIHRpbGUuZGVidWcucmVuZGVyaW5nID0gK25ldyBEYXRlKCkgLSB0aWxlLmRlYnVnLnJlbmRlcmluZztcbiAgICAgICAgICAgIHRpbGUuZGVidWcucHJvamVjdGlvbiA9IDA7XG4gICAgICAgICAgICB0aWxlLmRlYnVnLmZlYXR1cmVzID0gMDtcbiAgICAgICAgICAgIHRpbGUuZGVidWcubmV0d29yayA9IDA7XG4gICAgICAgICAgICB0aWxlLmRlYnVnLnBhcnNpbmcgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpIGluIHRpbGUuc291cmNlcykge1xuICAgICAgICAgICAgICAgIHRpbGUuZGVidWcuZmVhdHVyZXMgICs9IHRpbGUuc291cmNlc1tpXS5kZWJ1Zy5mZWF0dXJlcztcbiAgICAgICAgICAgICAgICB0aWxlLmRlYnVnLnByb2plY3Rpb24gKz0gdGlsZS5zb3VyY2VzW2ldLmRlYnVnLnByb2plY3Rpb247XG4gICAgICAgICAgICAgICAgdGlsZS5kZWJ1Zy5uZXR3b3JrICs9IHRpbGUuc291cmNlc1tpXS5kZWJ1Zy5uZXR3b3JrO1xuICAgICAgICAgICAgICAgIHRpbGUuZGVidWcucGFyc2luZyArPSB0aWxlLnNvdXJjZXNbaV0uZGVidWcucGFyc2luZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmV0dXJuIGtleXMgdG8gYmUgdHJhbnNmZXJlZCB0byBtYWluIHRocmVhZFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtZXNoX2RhdGE6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICBSZXRyaWV2ZXMgZ2VvbWV0cnkgZnJvbSBhIHRpbGUgYWNjb3JkaW5nIHRvIGEgZGF0YSBzb3VyY2UgZGVmaW5pdGlvblxuICAgICovXG4gICAgc3RhdGljIGdldEdlb21ldHJ5Rm9yU291cmNlIChzb3VyY2VEYXRhLCBzb3VyY2VDb25maWcpIHtcbiAgICAgICAgdmFyIGdlb207XG5cbiAgICAgICAgaWYgKHNvdXJjZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBKdXN0IHBhc3MgdGhyb3VnaCBkYXRhIHVudG91Y2hlZCBpZiBubyBkYXRhIHRyYW5zZm9ybSBmdW5jdGlvbiBkZWZpbmVkXG4gICAgICAgICAgICAvLyBpZiAoIXNvdXJjZS5maWx0ZXIpIHtcbiAgICAgICAgICAgIC8vICAgICBnZW9tID0gdGlsZS5sYXllcnNbc291cmNlLmZpbHRlcl07XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyBQYXNzIHRocm91Z2ggZGF0YSBidXQgd2l0aCBkaWZmZXJlbnQgbGF5ZXIgbmFtZSBpbiB0aWxlIHNvdXJjZSBkYXRhXG4gICAgICAgICAgICAvKmVsc2UqLyBpZiAodHlwZW9mIHNvdXJjZUNvbmZpZy5maWx0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZ2VvbSA9IHNvdXJjZURhdGEubGF5ZXJzW3NvdXJjZUNvbmZpZy5maWx0ZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXBwbHkgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiBmb3IgcG9zdC1wcm9jZXNzaW5nXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc291cmNlQ29uZmlnLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGdlb20gPSBzb3VyY2VDb25maWcuZmlsdGVyKHNvdXJjZURhdGEubGF5ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZW9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgIENhbGxlZCBvbiBtYWluIHRocmVhZCB3aGVuIGEgd2ViIHdvcmtlciBjb21wbGV0ZXMgcHJvY2Vzc2luZ1xuICAgICAgIGZvciBhIHNpbmdsZSB0aWxlLlxuICAgICovXG4gICAgZmluYWxpemVCdWlsZChzdHlsZXMpIHtcbiAgICAgICAgLy8gQ2xlYW51cCBleGlzdGluZyBWQk9zXG4gICAgICAgIHRoaXMuZnJlZVJlc291cmNlcygpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBWQk9zXG4gICAgICAgIGxldCBtZXNoX2RhdGEgPSB0aGlzLm1lc2hfZGF0YTtcbiAgICAgICAgaWYgKG1lc2hfZGF0YSkge1xuICAgICAgICAgICAgZm9yICh2YXIgcyBpbiBtZXNoX2RhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzaF9kYXRhW3NdLnZlcnRleF9kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzaGVzW3NdID0gc3R5bGVzW3NdLm1ha2VNZXNoKG1lc2hfZGF0YVtzXS52ZXJ0ZXhfZGF0YSwgbWVzaF9kYXRhW3NdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBc3NpZ24gb3duZXJzaGlwIHRvIHRleHR1cmVzIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmIChtZXNoX2RhdGFbc10udGV4dHVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlcy5wdXNoKC4uLm1lc2hfZGF0YVtzXS50ZXh0dXJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kZWJ1Zy5nZW9tZXRyaWVzID0gMDtcbiAgICAgICAgdGhpcy5kZWJ1Zy5idWZmZXJfc2l6ZSA9IDA7XG4gICAgICAgIGZvciAodmFyIHAgaW4gdGhpcy5tZXNoZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcuZ2VvbWV0cmllcyArPSB0aGlzLm1lc2hlc1twXS5nZW9tZXRyeV9jb3VudDtcbiAgICAgICAgICAgIHRoaXMuZGVidWcuYnVmZmVyX3NpemUgKz0gdGhpcy5tZXNoZXNbcF0udmVydGV4X2RhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnLmdlb21fcmF0aW8gPSAodGhpcy5kZWJ1Zy5nZW9tZXRyaWVzIC8gdGhpcy5kZWJ1Zy5mZWF0dXJlcykudG9GaXhlZCgxKTtcblxuICAgICAgICB0aGlzLm1lc2hfZGF0YSA9IG51bGw7IC8vIFRPRE86IG1pZ2h0IHdhbnQgdG8gcHJlc2VydmUgdGhpcyBmb3IgcmVidWlsZGluZyBnZW9tZXRyaWVzIHdoZW4gc3R5bGVzL2V0Yy4gY2hhbmdlP1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICBDYWxsZWQgb24gbWFpbiB0aHJlYWQgd2hlbiB3ZWIgd29ya2VyIGNvbXBsZXRlcyBwcm9jZXNzaW5nLCBidXQgdGlsZSBoYXMgc2luY2UgYmVlbiBkaXNjYXJkZWRcbiAgICAgICAgRnJlZXMgcmVzb3VyY2VzIHRoYXQgd291bGQgaGF2ZSBiZWVuIHRyYW5zZmVycmVkIHRvIHRoZSB0aWxlIG9iamVjdC5cbiAgICAgICAgU3RhdGljIG1ldGhvZCBiZWNhdXNlIHRoZSB0aWxlIG9iamVjdCBubyBsb25nZXIgZXhpc3RzICh0aGUgdGlsZSBkYXRhIHJldHVybmVkIGJ5IHRoZSB3b3JrZXIgaXMgcGFzc2VkIGluc3RlYWQpLlxuICAgICovXG4gICAgc3RhdGljIGFib3J0QnVpbGQgKHRpbGUpIHtcbiAgICAgICAgaWYgKHRpbGUubWVzaF9kYXRhKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzIGluIHRpbGUubWVzaF9kYXRhKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHR1cmVzID0gdGlsZS5tZXNoX2RhdGFbc10udGV4dHVyZXM7XG4gICAgICAgICAgICAgICAgaWYgKHRleHR1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGV4dHVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0dXJlID0gVGV4dHVyZS50ZXh0dXJlc1t0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLnRyYWNlKGBkZXN0cm95aW5nIHRleHR1cmUgJHt0fSBmb3IgdGlsZSAke3RpbGUua2V5fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpbnREZWJ1ZyAoKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhgVGlsZTogZGVidWcgZm9yICR7dGhpcy5rZXl9OiBbICAke0pTT04uc3RyaW5naWZ5KHRoaXMuZGVidWcpfSBdYCk7XG4gICAgfVxuXG4gICAgdXBkYXRlKHNjZW5lKSB7XG4gICAgICAgIGlmICh0aGlzLmNvb3Jkcy56ID09PSBzY2VuZS5jZW50ZXJfdGlsZS56ICYmIHNjZW5lLnZpc2libGVfdGlsZXNbdGhpcy5rZXldKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBoYW5kbGUgdGlsZXMgb2YgbWlzbWF0Y2hpbmcgem9vbSBsZXZlbHNcbiAgICAgICAgaWYgKHRoaXMuY29vcmRzLnogPT09IHNjZW5lLmNlbnRlcl90aWxlLnopIHtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyX2Rpc3QgPSBNYXRoLmFicyhzY2VuZS5jZW50ZXJfdGlsZS54IC0gdGhpcy5jb29yZHMueCkgKyBNYXRoLmFicyhzY2VuZS5jZW50ZXJfdGlsZS55IC0gdGhpcy5jb29yZHMueSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNlbnRlcl9kaXN0ID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsb2FkKHNjZW5lKSB7XG4gICAgICAgIHNjZW5lLnRyYWNrVGlsZVNldExvYWRTdGFydCgpO1xuXG4gICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuYnVpbGQoc2NlbmUpO1xuICAgICAgICB0aGlzLnVwZGF0ZShzY2VuZSk7XG4gICAgfVxuXG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG90aGVyKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAna2V5Jykge1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IG90aGVyW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG59XG4iLCIvKmpzaGludCB3b3JrZXI6IHRydWUgKi9cbi8qZ2xvYmFscyBUaWxlU291cmNlLCB0b3BvanNvbiAqL1xuaW1wb3J0IEdlbyBmcm9tICcuL2dlbyc7XG5pbXBvcnQge01ldGhvZE5vdEltcGxlbWVudGVkfSBmcm9tICcuL3V0aWxzL2Vycm9ycyc7XG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscy91dGlscyc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlsZVNvdXJjZSB7XG5cbiAgICBjb25zdHJ1Y3RvciAoc291cmNlKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuICAgICAgICB0aGlzLnVybF90ZW1wbGF0ZSA9IHNvdXJjZS51cmw7XG4gICAgICAgIC8vIG92ZXJ6b29tIHdpbGwgYXBwbHkgZm9yIHpvb21zIGhpZ2hlciB0aGFuIHRoaXNcbiAgICAgICAgdGhpcy5tYXhfem9vbSA9IHNvdXJjZS5tYXhfem9vbSB8fCBHZW8ubWF4X3pvb207XG4gICAgfVxuXG4gICAgYnVpbGRBc01lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsX3RlbXBsYXRlLFxuICAgICAgICAgICAgbWF4X3pvb206IHRoaXMubWF4X3pvb21cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSB0aWxlIHNvdXJjZSBieSB0eXBlLCBmYWN0b3J5LXN0eWxlXG4gICAgc3RhdGljIGNyZWF0ZSAoc291cmNlKSB7XG4gICAgICAgIHN3aXRjaCAoc291cmNlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ1RvcG9KU09OVGlsZVNvdXJjZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUb3BvSlNPTlRpbGVTb3VyY2Uoc291cmNlKTtcbiAgICAgICAgICAgIGNhc2UgJ01hcGJveEZvcm1hdFRpbGVTb3VyY2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWFwYm94Rm9ybWF0VGlsZVNvdXJjZShzb3VyY2UpO1xuICAgICAgICAgICAgY2FzZSAnR2VvSlNPTlRpbGVTb3VyY2UnOlxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEdlb0pTT05UaWxlU291cmNlKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNZXJjYXRvciBwcm9qZWN0aW9uXG4gICAgc3RhdGljIHByb2plY3REYXRhIChzb3VyY2UpIHtcbiAgICAgICAgdmFyIHRpbWVyID0gK25ldyBEYXRlKCk7XG4gICAgICAgIGZvciAodmFyIHQgaW4gc291cmNlLmxheWVycykge1xuICAgICAgICAgICAgdmFyIG51bV9mZWF0dXJlcyA9IHNvdXJjZS5sYXllcnNbdF0uZmVhdHVyZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgZj0wOyBmIDwgbnVtX2ZlYXR1cmVzOyBmKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZSA9IHNvdXJjZS5sYXllcnNbdF0uZmVhdHVyZXNbZl07XG4gICAgICAgICAgICAgICAgR2VvLnRyYW5zZm9ybUdlb21ldHJ5KGZlYXR1cmUuZ2VvbWV0cnksIGNvb3JkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFt4LCB5XSA9IEdlby5sYXRMbmdUb01ldGVycyhjb29yZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkWzBdID0geDtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRbMV0gPSB5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvdXJjZS5kZWJ1ZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzb3VyY2UuZGVidWcucHJvamVjdGlvbiA9ICtuZXcgRGF0ZSgpIC0gdGltZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgUmUtc2NhbGUgZ2VvbWV0cmllcyB3aXRoaW4gZWFjaCBzb3VyY2UgdG8gdGhlIHJhbmdlIFswLCBzY2FsZV1cbiAgICAgVE9ETzogY2xpcCB2ZXJ0aWNlcyBhdCBlZGdlcz8gcmlnaHQgbm93IHZlcnRpY2VzIGNhbiBoYXZlXG4gICAgIHZhbHVlcyBvdXRzaWRlIFswLCBzY2FsZV0gKG92ZXIgb3IgdW5kZXIgYm91bmRzKTsgdGhpcyB3b3VsZFxuICAgICBwb3NlIGEgcHJvYmxlbSBpZiB3ZSB3YW50ZWQgdG8gYmluYXJ5IGVuY29kZSB0aGUgdmVydGljZXMgaW5cbiAgICAgZmV3ZXIgYml0cyAoZS5nLiAxMiBiaXRzIGVhY2ggZm9yIHNjYWxlIG9mIDQwOTYpXG4gICAgKi9cbiAgICBzdGF0aWMgc2NhbGVEYXRhIChzb3VyY2UsIHtjb29yZHM6IHt6fSwgbWlufSkge1xuICAgICAgICBmb3IgKHZhciB0IGluIHNvdXJjZS5sYXllcnMpIHtcbiAgICAgICAgICAgIHZhciBudW1fZmVhdHVyZXMgPSBzb3VyY2UubGF5ZXJzW3RdLmZlYXR1cmVzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGY9MDsgZiA8IG51bV9mZWF0dXJlczsgZisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBzb3VyY2UubGF5ZXJzW3RdLmZlYXR1cmVzW2ZdO1xuICAgICAgICAgICAgICAgIEdlby50cmFuc2Zvcm1HZW9tZXRyeShmZWF0dXJlLmdlb21ldHJ5LCBjb29yZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkWzBdID0gKGNvb3JkWzBdIC0gbWluLngpICogR2VvLnVuaXRzX3Blcl9tZXRlclt6XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyB3aWxsIGNyZWF0ZSBuZWdhdGl2ZSB5LWNvb3JkcywgZm9yY2UgcG9zaXRpdmUgYXMgYmVsb3cgaW5zdGVhZD8gb3IsIGlmIGxhdGVyIHN0b3JpbmcgcG9zaXRpdmUgY29vcmRzIGluIGJpdC1wYWNrZWQgdmFsdWVzLCBmbGlwIHRvIG5lZ2F0aXZlIGluIHBvc3QtcHJvY2Vzc2luZz9cbiAgICAgICAgICAgICAgICAgICAgY29vcmRbMV0gPSAoY29vcmRbMV0gLSBtaW4ueSkgKiBHZW8udW5pdHNfcGVyX21ldGVyW3pdO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb29yZFsxXSA9IChjb29yZFsxXSAtIHRpbGUubWF4LnkpICogR2VvLnVuaXRzX3Blcl9tZXRlclt0aWxlLmNvb3Jkcy56XTsgLy8gYWx0ZXJuYXRlIHRvIGZvcmNlIHktY29vcmRzIHRvIGJlIHBvc2l0aXZlLCBzdWJ0cmFjdCB0aWxlIG1heCBpbnN0ZWFkIG9mIG1pblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9hZFRpbGUodGlsZSkgeyB0aHJvdyBuZXcgTWV0aG9kTm90SW1wbGVtZW50ZWQoJ2xvYWRUaWxlJyk7IH1cbn1cblxuXG5cbi8qKiogR2VuZXJpYyBuZXR3b3JrIHRpbGUgbG9hZGluZyAtIGFic3RyYWN0IGNsYXNzICoqKi9cblxuZXhwb3J0IGNsYXNzIE5ldHdvcmtUaWxlU291cmNlIGV4dGVuZHMgVGlsZVNvdXJjZSB7XG5cblxuICAgIGNvbnN0cnVjdG9yIChzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoc291cmNlKTtcblxuICAgICAgICB0aGlzLnJlc3BvbnNlX3R5cGUgPSBcIlwiOyAvLyB1c2UgdG8gc2V0IGV4cGxpY2l0IFhIUiB0eXBlXG4gICAgICAgIHRoaXMudXJsX2hvc3RzID0gbnVsbDtcbiAgICAgICAgdmFyIGhvc3RfbWF0Y2ggPSB0aGlzLnVybF90ZW1wbGF0ZS5tYXRjaCgve3M6XFxbKFtefStdKylcXF19Lyk7XG4gICAgICAgIGlmIChob3N0X21hdGNoICE9IG51bGwgJiYgaG9zdF9tYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLnVybF9ob3N0cyA9IGhvc3RfbWF0Y2hbMV0uc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHRoaXMubmV4dF9ob3N0ID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvcm1hdFRpbGVVcmwodGlsZSkge1xuICAgICAgICB2YXIgdXJsID0gdGhpcy51cmxfdGVtcGxhdGUucmVwbGFjZSgne3h9JywgdGlsZS5jb29yZHMueCkucmVwbGFjZSgne3l9JywgdGlsZS5jb29yZHMueSkucmVwbGFjZSgne3p9JywgdGlsZS5jb29yZHMueik7XG5cbiAgICAgICAgaWYgKHRoaXMudXJsX2hvc3RzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKC97czpcXFsoW159K10rKVxcXX0vLCB0aGlzLnVybF9ob3N0c1t0aGlzLm5leHRfaG9zdF0pO1xuICAgICAgICAgICAgdGhpcy5uZXh0X2hvc3QgPSAodGhpcy5uZXh0X2hvc3QgKyAxKSAlIHRoaXMudXJsX2hvc3RzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cblxuICAgIGxvYWRUaWxlICh0aWxlKSB7XG4gICAgICAgIHZhciB1cmwgPSB0aGlzLmZvcm1hdFRpbGVVcmwodGlsZSk7XG5cbiAgICAgICAgaWYgKHRpbGUuc291cmNlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aWxlLnNvdXJjZXMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aWxlLnNvdXJjZXNbdGhpcy5uYW1lXSA9IHt9O1xuXG4gICAgICAgIHNvdXJjZS51cmwgPSB1cmw7XG4gICAgICAgIHNvdXJjZS5kZWJ1ZyA9IHt9O1xuICAgICAgICBzb3VyY2UuZGVidWcubmV0d29yayA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBzb3VyY2UuZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgLy8gRm9yIHRlc3RpbmcgbmV0d29yayBlcnJvcnNcbiAgICAgICAgICAgIC8vIHZhciBwcm9taXNlID0gVXRpbHMuaW8odXJsLCA2MCAqIDEwMCwgdGhpcy5yZXNwb25zZV90eXBlKTtcbiAgICAgICAgICAgIC8vIGlmIChNYXRoLnJhbmRvbSgpIDwgLjcpIHtcbiAgICAgICAgICAgIC8vICAgICBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QoRXJyb3IoJ2Zha2UgdGlsZSBlcnJvcicpKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIHByb21pc2UudGhlbigoYm9keSkgPT4ge1xuICAgICAgICAgICAgbGV0IHByb21pc2UgPSBVdGlscy5pbyh1cmwsIDYwICogMTAwMCwgdGhpcy5yZXNwb25zZV90eXBlKTtcbiAgICAgICAgICAgIHRpbGUucmVxdWVzdCA9IHByb21pc2UucmVxdWVzdDtcblxuICAgICAgICAgICAgcHJvbWlzZS50aGVuKChib2R5KSA9PiB7XG4gICAgICAgICAgICAgICAgc291cmNlLmRlYnVnLnJlc3BvbnNlX3NpemUgPSBib2R5Lmxlbmd0aCB8fCBib2R5LmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgc291cmNlLmRlYnVnLm5ldHdvcmsgPSArbmV3IERhdGUoKSAtIHNvdXJjZS5kZWJ1Zy5uZXR3b3JrO1xuICAgICAgICAgICAgICAgIHNvdXJjZS5kZWJ1Zy5wYXJzaW5nID0gK25ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVNvdXJjZURhdGEodGlsZSwgc291cmNlLCBib2R5KTtcbiAgICAgICAgICAgICAgICBzb3VyY2UuZGVidWcucGFyc2luZyA9ICtuZXcgRGF0ZSgpIC0gc291cmNlLmRlYnVnLnBhcnNpbmc7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aWxlKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHNvdXJjZS5lcnJvciA9IGVycm9yLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTdWItY2xhc3NlcyBtdXN0IGltcGxlbWVudCB0aGlzIG1ldGhvZDpcbiAgICBwYXJzZVNvdXJjZURhdGEgKHRpbGUsIHNvdXJjZSwgcmVwb25zZSkge1xuICAgICAgICB0aHJvdyBuZXcgTWV0aG9kTm90SW1wbGVtZW50ZWQoJ3BhcnNlVGlsZScpO1xuICAgIH1cbn1cblxuXG4vKipcbiBNYXB6ZW4vT1NNLlVTLXN0eWxlIEdlb0pTT04gdmVjdG9yIHRpbGVzXG4gQGNsYXNzIEdlb0pTT05UaWxlU291cmNlXG4qL1xuZXhwb3J0IGNsYXNzIEdlb0pTT05UaWxlU291cmNlIGV4dGVuZHMgTmV0d29ya1RpbGVTb3VyY2Uge1xuXG4gICAgY29uc3RydWN0b3IgKHNvdXJjZSkge1xuICAgICAgICBzdXBlcihzb3VyY2UpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnR2VvSlNPTlRpbGVTb3VyY2UnO1xuICAgIH1cblxuICAgIHBhcnNlU291cmNlRGF0YSAodGlsZSwgc291cmNlLCByZXNwb25zZSkge1xuXG4gICAgICAgIHNvdXJjZS5sYXllcnMgPSBKU09OLnBhcnNlKHJlc3BvbnNlKTtcblxuICAgICAgICBUaWxlU291cmNlLnByb2plY3REYXRhKHNvdXJjZSk7IC8vIG1lcmNhdG9yIHByb2plY3Rpb25cbiAgICAgICAgVGlsZVNvdXJjZS5zY2FsZURhdGEoc291cmNlLCB0aWxlKTsgLy8gcmUtc2NhbGUgZnJvbSBtZXRlcnMgdG8gbG9jYWwgdGlsZSBjb29yZHNcbiAgICB9XG59XG5cblxuLyoqKiBNYXB6ZW4vT1NNLlVTLXN0eWxlIFRvcG9KU09OIHZlY3RvciB0aWxlcyAqKiovXG5leHBvcnQgY2xhc3MgVG9wb0pTT05UaWxlU291cmNlIGV4dGVuZHMgTmV0d29ya1RpbGVTb3VyY2Uge1xuXG4gICAgY29uc3RydWN0b3IgKHNvdXJjZSkge1xuICAgICAgICBzdXBlcihzb3VyY2UpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnVG9wb0pTT05UaWxlU291cmNlJztcblxuICAgICAgICAvLyBMb2FkcyBUb3BvSlNPTiBsaWJyYXJ5IGZyb20gb2ZmaWNpYWwgRDMgc291cmNlIG9uIGRlbWFuZFxuICAgICAgICAvLyBOb3QgaW5jbHVkaW5nIGluIGJhc2UgbGlicmFyeSB0byBhdm9pZCB0aGUgZXh0cmEgd2VpZ2h0XG4gICAgICAgIGlmICh0eXBlb2YgdG9wb2pzb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGltcG9ydFNjcmlwdHMoJ2h0dHA6Ly9kM2pzLm9yZy90b3BvanNvbi52MS5taW4uanMnKTtcbiAgICAgICAgICAgICAgICBsb2cuaW5mbygnVG9wb0pTT05UaWxlU291cmNlOiBsb2FkZWQgdG9wb2pzb24gbGlicmFyeScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2cuZXJyb3IoJ1RvcG9KU09OVGlsZVNvdXJjZTogZmFpbGVkIHRvIGxvYWQgVG9wb0pTT04gbGlicmFyeSEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhcnNlU291cmNlRGF0YSAodGlsZSwgc291cmNlLCByZXNwb25zZSkge1xuICAgICAgICBpZiAodHlwZW9mIHRvcG9qc29uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGlsZS5sYXllcnMgPSB7fTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNvdXJjZS5sYXllcnMgPSBKU09OLnBhcnNlKHJlc3BvbnNlKTtcblxuICAgICAgICAvLyBTaW5nbGUgbGF5ZXJcbiAgICAgICAgaWYgKHNvdXJjZS5sYXllcnMub2JqZWN0cy52ZWN0aWxlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2UubGF5ZXJzID0gdG9wb2pzb24uZmVhdHVyZShzb3VyY2UubGF5ZXJzLCBzb3VyY2UubGF5ZXJzLm9iamVjdHMudmVjdGlsZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpcGxlIGxheWVyc1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsYXllcnMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIHQgaW4gc291cmNlLmxheWVycy5vYmplY3RzKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJzW3RdID0gdG9wb2pzb24uZmVhdHVyZShzb3VyY2UubGF5ZXJzLCBzb3VyY2UubGF5ZXJzLm9iamVjdHNbdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlLmxheWVycyA9IGxheWVycztcbiAgICAgICAgfVxuXG4gICAgICAgIFRpbGVTb3VyY2UucHJvamVjdERhdGEoc291cmNlKTsgLy8gbWVyY2F0b3IgcHJvamVjdGlvblxuICAgICAgICBUaWxlU291cmNlLnNjYWxlRGF0YShzb3VyY2UsIHRpbGUpOyAvLyByZS1zY2FsZSBmcm9tIG1ldGVycyB0byBsb2NhbCB0aWxlIGNvb3Jkc1xuICAgIH1cblxufVxuXG5cbi8qKiogTWFwYm94IHZlY3RvciB0aWxlcyAqKiovXG5cbmV4cG9ydCBjbGFzcyBNYXBib3hGb3JtYXRUaWxlU291cmNlIGV4dGVuZHMgTmV0d29ya1RpbGVTb3VyY2Uge1xuXG4gICAgY29uc3RydWN0b3IgKHNvdXJjZSkge1xuICAgICAgICBzdXBlcihzb3VyY2UpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnTWFwYm94Rm9ybWF0VGlsZVNvdXJjZSc7XG4gICAgICAgIHRoaXMucmVzcG9uc2VfdHlwZSA9IFwiYXJyYXlidWZmZXJcIjsgLy8gYmluYXJ5IGRhdGFcbiAgICAgICAgdGhpcy5Qcm90b2J1ZiA9IHJlcXVpcmUoJ3BiZicpO1xuICAgICAgICB0aGlzLlZlY3RvclRpbGUgPSByZXF1aXJlKCd2ZWN0b3ItdGlsZScpLlZlY3RvclRpbGU7IC8vIE1hcGJveCB2ZWN0b3IgdGlsZSBsaWJcbiAgICAgICAgdGhpcy5WZWN0b3JUaWxlRmVhdHVyZSA9IHJlcXVpcmUoJ3ZlY3Rvci10aWxlJykuVmVjdG9yVGlsZUZlYXR1cmU7XG5cbiAgICAgICAgdGhpcy5wYWRfc2NhbGUgPSBzb3VyY2UucGFkX3NjYWxlIHx8IDAuMDAxOyAvLyBzY2FsZSB0aWxlIHVwIGJ5IHRoaXMgZmFjdG9yICgwLjElKSB0byBjb3ZlciBzZWFtc1xuICAgIH1cblxuICAgIHBhcnNlU291cmNlRGF0YSAodGlsZSwgc291cmNlLCByZXNwb25zZSkge1xuICAgICAgICAvLyBDb252ZXJ0IE1hcGJveCB2ZWN0b3IgdGlsZSB0byBHZW9KU09OXG4gICAgICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpO1xuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IHRoaXMuUHJvdG9idWYoZGF0YSk7XG4gICAgICAgIHNvdXJjZS5kYXRhID0gbmV3IHRoaXMuVmVjdG9yVGlsZShidWZmZXIpO1xuICAgICAgICBzb3VyY2UubGF5ZXJzID0gdGhpcy50b0dlb0pTT04oc291cmNlLmRhdGEpO1xuICAgICAgICBkZWxldGUgc291cmNlLmRhdGE7IC8vIGNvbW1lbnQgb3V0IHRvIHNhdmUgcmF3IGRhdGEgZm9yIGRlYnVnZ2luZ1xuXG4gICAgICAgIC8vIFBvc3QtcHJvY2Vzc2luZ1xuICAgICAgICBmb3IgKHZhciB0IGluIHNvdXJjZS5sYXllcnMpIHtcbiAgICAgICAgICAgIHZhciBudW1fZmVhdHVyZXMgPSBzb3VyY2UubGF5ZXJzW3RdLmZlYXR1cmVzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGY9MDsgZiA8IG51bV9mZWF0dXJlczsgZisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBzb3VyY2UubGF5ZXJzW3RdLmZlYXR1cmVzW2ZdO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29weSBPU00gaWRcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMuaWQgPSBmZWF0dXJlLnByb3BlcnRpZXMub3NtX2lkO1xuICAgICAgICAgICAgICAgIEdlby50cmFuc2Zvcm1HZW9tZXRyeShmZWF0dXJlLmdlb21ldHJ5LCBjb29yZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNsaWdodGx5IHNjYWxlIHVwIHRpbGUgdG8gY292ZXIgc2VhbXNcbiAgICAgICAgICAgICAgICAgICAgY29vcmRbMF0gPSBNYXRoLnJvdW5kKGNvb3JkWzBdICogKDEgKyB0aGlzLnBhZF9zY2FsZSkgLSAoNDA5NiAqIHRoaXMucGFkX3NjYWxlLzIpKTtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRbMV0gPSBNYXRoLnJvdW5kKGNvb3JkWzFdICogKDEgKyB0aGlzLnBhZF9zY2FsZSkgLSAoNDA5NiAqIHRoaXMucGFkX3NjYWxlLzIpKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGbGlwIFkgY29vcmRcbiAgICAgICAgICAgICAgICAgICAgY29vcmRbMV0gPSAtY29vcmRbMV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMb29wIHRocm91Z2ggbGF5ZXJzL2ZlYXR1cmVzIHVzaW5nIE1hcGJveCBsaWIgQVBJLCBjb252ZXJ0IHRvIEdlb0pTT04gZmVhdHVyZXNcbiAgICAvLyBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGtleXMgZm9yIGVhY2ggbGF5ZXIsIGUuZy4geyBsYXllcjogZ2VvanNvbiB9XG4gICAgdG9HZW9KU09OICh0aWxlKSB7XG4gICAgICAgIHZhciBsYXllcnMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgbCBpbiB0aWxlLmxheWVycykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGlsZS5sYXllcnNbbF07XG4gICAgICAgICAgICB2YXIgbGF5ZXJfZ2VvanNvbiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgICAgICAgICAgIGZlYXR1cmVzOiBbXVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICh2YXIgZj0wOyBmIDwgbGF5ZXIubGVuZ3RoOyBmKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZSA9IGxheWVyLmZlYXR1cmUoZik7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmVfZ2VvanNvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeToge30sXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IGZlYXR1cmUucHJvcGVydGllc1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBmZWF0dXJlX2dlb2pzb24uZ2VvbWV0cnk7XG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gZmVhdHVyZS5sb2FkR2VvbWV0cnkoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByPTA7IHIgPCBjb29yZGluYXRlcy5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmluZyA9IGNvb3JkaW5hdGVzW3JdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjPTA7IGMgPCByaW5nLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaW5nW2NdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpbmdbY10ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaW5nW2NdLnlcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlcztcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLlZlY3RvclRpbGVGZWF0dXJlLnR5cGVzW2ZlYXR1cmUudHlwZV0gPT09ICdQb2ludCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkudHlwZSA9ICdQb2ludCc7XG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1bMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuVmVjdG9yVGlsZUZlYXR1cmUudHlwZXNbZmVhdHVyZS50eXBlXSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LnR5cGUgPSAnTGluZVN0cmluZyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5jb29yZGluYXRlcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkudHlwZSA9ICdNdWx0aUxpbmVTdHJpbmcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuVmVjdG9yVGlsZUZlYXR1cmUudHlwZXNbZmVhdHVyZS50eXBlXSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LnR5cGUgPSAnUG9seWdvbic7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGF5ZXJfZ2VvanNvbi5mZWF0dXJlcy5wdXNoKGZlYXR1cmVfZ2VvanNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXllcnNbbF0gPSBsYXllcl9nZW9qc29uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXllcnM7XG4gICAgfVxuXG59XG5cbiIsIlxuXG5leHBvcnQgY2xhc3MgTWV0aG9kTm90SW1wbGVtZW50ZWQgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kTmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgICAgPSAnTWV0aG9kTm90SW1wbGVtZW50ZWQnO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSAnTWV0aG9kICcgKyBtZXRob2ROYW1lICsgJyBtdXN0IGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzJztcbiAgICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzdWJzY3JpYmVNaXhpbiAodGFyZ2V0KSB7XG5cbiAgICAvLyBUT0RPOiB0ZW1wb3JhcmlseSBjb21tZW50aW5nIG91dCB1c2Ugb2YgRVM2IFNldCBkdWUgdG8gYXBwYXJlbnQgdHJhY2V1ciBidWcgb24gaU9TOCBtb2JpbGUgc2FmYXJpXG4gICAgLy8gbmVlZCB0byBkaWFnbm9zZSBmdXJ0aGVyIGFuZCByZXBvcnQgdG8gdHJhY2V1ciBpZiBjb25maXJtZWRcblxuICAgIC8vIHZhciBsaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGxpc3RlbmVycyA9IFtdO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB7XG5cbiAgICAgICAgc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAvLyBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1bnN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgICAgICAgICAgLy8gbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVuc3Vic2NyaWJlQWxsKCkge1xuICAgICAgICAgICAgLy8gbGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfSxcblxuICAgICAgICB0cmlnZ2VyKGV2ZW50LCAuLi5kYXRhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyW2V2ZW50XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcltldmVudF0oLi4uZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9KTtcblxufVxuIiwiLy8gTWlzY2VsbGFuZW91cyB1dGlsaXRpZXNcbi8qanNoaW50IHdvcmtlcjogdHJ1ZSovXG5cbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHlhbWwgZnJvbSAnanMteWFtbCc7XG5cbnZhciBVdGlscztcbmV4cG9ydCBkZWZhdWx0IFV0aWxzID0ge307XG5cbi8vIEFkZCB0aGUgY3VycmVudCBiYXNlIFVSTCBmb3Igc2NoZW1lbGVzcyBvciBwcm90b2NvbC1sZXNzIFVSTHNcbi8vIE1heWJlIHVzZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL1VSSS5qcyBpZiBtb3JlIHJvYnVzdCBmdW5jdGlvbmFsaXR5IGlzIG5lZWRlZFxuVXRpbHMuYWRkQmFzZVVSTCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICBpZiAoIXVybCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2NoZW1lbGVzcywgYWRkIHByb3RvY29sXG4gICAgaWYgKHVybC5zdWJzdHIoMCwgMikgPT09ICcvLycpIHtcbiAgICAgICAgdXJsID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgdXJsO1xuICAgIH1cbiAgICAvLyBObyBodHRwKHMpIG9yIGRhdGEsIGFkZCBiYXNlXG4gICAgZWxzZSBpZiAodXJsLnNlYXJjaCgvKGh0dHB8aHR0cHN8ZGF0YSk6XFwvXFwvLykgPCAwKSB7XG4gICAgICAgIHVybCA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB1cmw7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG59O1xuXG5VdGlscy5jYWNoZUJ1c3RlckZvclVybCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICByZXR1cm4gdXJsICsgJz8nICsgKCtuZXcgRGF0ZSgpKTtcbn07XG5cblV0aWxzLmlvID0gZnVuY3Rpb24gKHVybCwgdGltZW91dCA9IDYwMDAwLCByZXNwb25zZVR5cGUgPSAndGV4dCcsIG1ldGhvZCA9ICdHRVQnLCBoZWFkZXJzID0ge30pIHtcbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICByZXF1ZXN0Lm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgICAgICByZXF1ZXN0LnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIGlmIChbJ3RleHQnLCAnanNvbiddLmluZGV4T2YocmVxdWVzdC5yZXNwb25zZVR5cGUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KEVycm9yKCdSZXF1ZXN0IGVycm9yIHdpdGggYSBzdGF0dXMgb2YgJyArIHJlcXVlc3Quc3RhdHVzVGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICByZWplY3QoRXJyb3IoJ1RoZXJlIHdhcyBhIG5ldHdvcmsgZXJyb3InICsgZXZ0LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICByZWplY3QoRXJyb3IoJ3RpbWVvdXQgJysgZXZ0LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgJ3JlcXVlc3QnLCB7XG4gICAgICAgIHZhbHVlOiByZXF1ZXN0XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5cblV0aWxzLnBhcnNlUmVzb3VyY2UgPSBmdW5jdGlvbiAoYm9keSkge1xuICAgIHZhciBkYXRhID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICBldmFsKCdkYXRhID0gJyArIGJvZHkpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhID0geWFtbC5zYWZlTG9hZChib2R5KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nLmVycm9yKCdVdGlscy5wYXJzZVJlc291cmNlOiBmYWlsZWQgdG8gcGFyc2UnLCBlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59O1xuXG5VdGlscy5sb2FkUmVzb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBVdGlscy5pbyhVdGlscy5jYWNoZUJ1c3RlckZvclVybChzb3VyY2UpKS50aGVuKChib2R5KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBVdGlscy5wYXJzZVJlc291cmNlKGJvZHkpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vLyBOZWVkZWQgZm9yIG9sZGVyIGJyb3dzZXJzIHRoYXQgc3RpbGwgc3VwcG9ydCBXZWJHTCAoU2FmYXJpIDYgZXRjLilcblV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZVBvbHlmaWxsID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID1cbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgfHxcbiAgICAgICAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIDEwMDAgLzYwKTtcbiAgICAgICAgICAgIH07XG4gICAgfVxufTtcblxuLy8gU3RyaW5naWZ5IGFuIG9iamVjdCBpbnRvIEpTT04sIGJ1dCBjb252ZXJ0IGZ1bmN0aW9ucyB0byBzdHJpbmdzXG5VdGlscy5zZXJpYWxpemVXaXRoRnVuY3Rpb25zID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBzZXJpYWxpemVkID0gSlNPTi5zdHJpbmdpZnkob2JqLCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgIC8vIENvbnZlcnQgZnVuY3Rpb25zIHRvIHN0cmluZ3NcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdi50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59O1xuXG4vLyBQYXJzZSBhIEpTT04gc3RyaW5nLCBidXQgY29udmVydCBmdW5jdGlvbi1saWtlIHN0cmluZ3MgYmFjayBpbnRvIGZ1bmN0aW9uc1xuVXRpbHMuZGVzZXJpYWxpemVXaXRoRnVuY3Rpb25zID0gZnVuY3Rpb24oc2VyaWFsaXplZCwgd3JhcCkge1xuICAgIHZhciBvYmogPSBKU09OLnBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgIG9iaiA9IFV0aWxzLnN0cmluZ3NUb0Z1bmN0aW9ucyhvYmosIHdyYXApO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG4vLyBSZWN1cnNpdmVseSBwYXJzZSBhbiBvYmplY3QsIGF0dGVtcHRpbmcgdG8gY29udmVydCBzdHJpbmcgcHJvcGVydGllcyB0aGF0IGxvb2sgbGlrZSBmdW5jdGlvbnMgYmFjayBpbnRvIGZ1bmN0aW9uc1xuVXRpbHMuc3RyaW5nc1RvRnVuY3Rpb25zID0gZnVuY3Rpb24ob2JqLCB3cmFwKSB7XG4gICAgZm9yICh2YXIgcCBpbiBvYmopIHtcbiAgICAgICAgdmFyIHZhbCA9IG9ialtwXTtcblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBvYmpbcF0gPSBVdGlscy5zdHJpbmdzVG9GdW5jdGlvbnModmFsLCB3cmFwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0IHN0cmluZ3MgYmFjayBpbnRvIGZ1bmN0aW9uc1xuICAgICAgICAvLyBUT0RPOiBtYWtlIGZ1bmN0aW9uIG1hdGNoaW5nIHRvbGVyYW50IG9mIHdoaXRlc3BhY2UgYW5kIG11bHRpbGluZXNcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgdmFsLm1hdGNoKC9eZnVuY3Rpb24uKlxcKC4qXFwpLykgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGY7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd3JhcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBldmFsKCdmID0gJyArIHdyYXAodmFsKSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXZhbCgnZiA9ICcgKyB2YWwpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqW3BdID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gZmFsbC1iYWNrIHRvIG9yaWdpbmFsIHZhbHVlIGlmIHBhcnNpbmcgZmFpbGVkXG4gICAgICAgICAgICAgICAgb2JqW3BdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbi8vIE1hcmsgdGhyZWFkIGFzIG1haW4gb3Igd29ya2VyXG4oZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHdpbmRvdy5kb2N1bWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBVdGlscy5pc1dvcmtlclRocmVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgVXRpbHMuaXNNYWluVGhyZWFkICAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChzZWxmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFV0aWxzLmlzV29ya2VyVGhyZWFkID0gdHJ1ZTtcbiAgICAgICAgICAgIFV0aWxzLmlzTWFpblRocmVhZCAgID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59KSgpO1xuXG4vLyBHZXQgVVJMIHRoYXQgdGhlIGN1cnJlbnQgc2NyaXB0IHdhcyBsb2FkZWQgZnJvbVxuLy8gSWYgY3VycmVudFNjcmlwdCBpcyBub3QgYXZhaWxhYmxlLCBsb29wcyB0aHJvdWdoIDxzY3JpcHQ+IGVsZW1lbnRzIHNlYXJjaGluZyBmb3IgYSBsaXN0IG9mIHByb3ZpZGVkIHBhdGhzXG4vLyBlLmcuIFV0aWxzLmZpbmRDdXJyZW50VVJMKCd0YW5ncmFtLmRlYnVnLmpzJywgJ3RhbmdyYW0ubWluLmpzJyk7XG5VdGlscy5maW5kQ3VycmVudFVSTCA9IGZ1bmN0aW9uICguLi5wYXRocykge1xuICAgIC8vIEZpbmQgY3VycmVudGx5IGV4ZWN1dGluZyBzY3JpcHRcbiAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdDtcbiAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgIHJldHVybiBzY3JpcHQuc3JjO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhdGhzKSkge1xuICAgICAgICAvLyBGYWxsYmFjayBvbiBsb29waW5nIHRocm91Z2ggPHNjcmlwdD4gZWxlbWVudHMgaWYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICAgIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICAgICAgICBmb3IgKHZhciBzPTA7IHMgPCBzY3JpcHRzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjcmlwdHNbc10uc3JjLmluZGV4T2YocGF0aCkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgIHJldHVybiBzY3JpcHRzW3NdLnNyYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBVc2VkIGZvciBkaWZmZXJlbnRpYXRpbmcgYmV0d2VlbiBwb3dlci1vZi0yIGFuZCBub24tcG93ZXItb2YtMiB0ZXh0dXJlc1xuLy8gVmlhOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE5NzIyMjQ3L3dlYmdsLXdhaXQtZm9yLXRleHR1cmUtdG8tbG9hZFxuVXRpbHMuaXNQb3dlck9mMiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmICh2YWx1ZSAtIDEpKSA9PT0gMDtcbn07XG5cblV0aWxzLm5leHRQb3dlck9mMiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZzIodmFsdWUpKSk7XG59O1xuXG4vLyBJbnRlcnBvbGF0ZSAneCcgYWxvbmcgYSBzZXJpZXMgb2YgY29udHJvbCBwb2ludHNcbi8vICdwb2ludHMnIGlzIGFuIGFycmF5IG9mIGNvbnRyb2wgcG9pbnRzIGluIHRoZSBmb3JtIFt4LCB5XVxuLy9cbi8vIEV4YW1wbGU6XG4vLyAgICAgQ29udHJvbCBwb2ludHM6XG4vLyAgICAgICAgIFswLCA1XTogIHdoZW4geD0wLCB5PTVcbi8vICAgICAgICAgWzQsIDEwXTogd2hlbiB4PTQsIHk9MTBcbi8vXG4vLyAgICAgVXRpbHMuaW50ZXJwb2xhdGUoMiwgW1swLCA1XSwgWzQsIDEwXV0pO1xuLy8gICAgIC0+IGNvbXB1dGVzIHg9MiwgaGFsZndheSBiZXR3ZWVuIHg9MCBhbmQgeD00OiAoMTAgLSA1KSAvIDIgKzVcbi8vICAgICAtPiByZXR1cm5zIDcuNVxuLy9cbi8vIFRPRE86IGFkZCBvdGhlciBpbnRlcnBvbGF0aW9uIG1ldGhvZHMgYmVzaWRlcyBsaW5lYXJcbi8vXG5VdGlscy5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKHgsIHBvaW50cykge1xuICAgIC8vIElmIHRoaXMgZG9lc24ndCByZXNlbWJsZSBhIGxpc3Qgb2YgY29udHJvbCBwb2ludHMsIGp1c3QgcmV0dXJuIHRoZSBvcmlnaW5hbCB2YWx1ZVxuICAgIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpIHx8IHBvaW50cy5zb21lKHYgPT4geyByZXR1cm4gIUFycmF5LmlzQXJyYXkodik7IH0pKSB7XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBvaW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuXG4gICAgdmFyIHgxLCB4MiwgZCwgeTtcblxuICAgIC8vIE1pbiBib3VuZHNcbiAgICBpZiAoeCA8PSBwb2ludHNbMF1bMF0pIHtcbiAgICAgICAgeSA9IHBvaW50c1swXVsxXTtcbiAgICB9XG4gICAgLy8gTWF4IGJvdW5kc1xuICAgIGVsc2UgaWYgKHggPj0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMV1bMF0pIHtcbiAgICAgICAgeSA9IHBvaW50c1twb2ludHMubGVuZ3RoLTFdWzFdO1xuICAgIH1cbiAgICAvLyBGaW5kIHdoaWNoIGNvbnRyb2wgcG9pbnRzIHggaXMgYmV0d2VlblxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoeCA+PSBwb2ludHNbaV1bMF0gJiYgeCA8IHBvaW50c1tpKzFdWzBdKSB7XG4gICAgICAgICAgICAgICAgLy8gTGluZWFyIGludGVycG9sYXRpb25cbiAgICAgICAgICAgICAgICB4MSA9IHBvaW50c1tpXVswXTtcbiAgICAgICAgICAgICAgICB4MiA9IHBvaW50c1tpKzFdWzBdO1xuXG4gICAgICAgICAgICAgICAgLy8gTXVsdGlwbGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9pbnRzW2ldWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGM9MDsgYyA8IHBvaW50c1tpXVsxXS5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHBvaW50c1tpKzFdWzFdW2NdIC0gcG9pbnRzW2ldWzFdW2NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeVtjXSA9IGQgKiAoeCAtIHgxKSAvICh4MiAtIHgxKSArIHBvaW50c1tpXVsxXVtjXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTaW5nbGUgdmFsdWVcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IHBvaW50c1tpKzFdWzFdIC0gcG9pbnRzW2ldWzFdO1xuICAgICAgICAgICAgICAgICAgICB5ID0gZCAqICh4IC0geDEpIC8gKHgyIC0geDEpICsgcG9pbnRzW2ldWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geTtcbn07XG5cbi8vIEl0ZXJhdG9ycyAoRVM2IGdlbmVyYXRvcnMpXG5cbi8vIEl0ZXJhdG9yIGZvciBrZXkvdmFsdWUgcGFpcnMgb2YgYW4gb2JqZWN0XG5VdGlscy5lbnRyaWVzID0gZnVuY3Rpb24qIChvYmopIHtcbiAgICBmb3IgKHZhciBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgICB5aWVsZCBba2V5LCBvYmpba2V5XV07XG4gICAgfVxufTtcblxuLy8gSXRlcmF0b3IgZm9yIHZhbHVlcyBvZiBhbiBvYmplY3RcblV0aWxzLnZhbHVlcyA9IGZ1bmN0aW9uKiAob2JqKSB7XG4gICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgeWllbGQgb2JqW2tleV07XG4gICAgfVxufTtcblxuLy8gUmVjdXJzaXZlIGl0ZXJhdG9ycyBmb3IgYWxsIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LCBubyBtYXR0ZXIgaG93IGRlZXBseSBuZXN0ZWRcbi8vIFRPRE86IGZpeCBmb3IgY2lyY3VsYXIgc3RydWN0dXJlc1xuVXRpbHMucmVjdXJzZUVudHJpZXMgPSBmdW5jdGlvbiogKG9iaikge1xuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgaWYgKG9ialtrZXldKSB7XG4gICAgICAgICAgICB5aWVsZCBba2V5LCBvYmpba2V5XV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHlpZWxkKiBVdGlscy5yZWN1cnNlRW50cmllcyhvYmpba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5VdGlscy5yZWN1cnNlVmFsdWVzID0gZnVuY3Rpb24qIChvYmopIHtcbiAgICBpZiAoIW9iaikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG4gICAgICAgIGlmIChvYmpba2V5XSkge1xuICAgICAgICAgICAgeWllbGQgb2JqW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHlpZWxkKiBVdGlscy5yZWN1cnNlVmFsdWVzKG9ialtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblV0aWxzLnNjYWxlSW50MTYgPSBmdW5jdGlvbiAodmFsLCBtYXgpIHtcbiAgICByZXR1cm4gKHZhbCAvIG1heCkgKiAzMjc2ODtcbn07XG5cblV0aWxzLmRlZ1RvUmFkID0gZnVuY3Rpb24gKGRlZ3JlZXMpIHtcbiAgICByZXR1cm4gZGVncmVlcyAqIE1hdGguUEkgLyAxODA7XG59O1xuXG5VdGlscy5yYWRUb0RlZyA9IGZ1bmN0aW9uIChyYWRpYW5zKSB7XG4gICAgcmV0dXJuIHJhZGlhbnMgKiAxODAgLyBNYXRoLlBJO1xufTtcblxuVXRpbHMudG9DYW52YXNDb2xvciA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHJldHVybiAncmdiKCcgKyAgTWF0aC5yb3VuZChjb2xvclswXSAqIDI1NSkgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yWzFdICAqIDI1NSkgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yWzJdICogMjU1KSArICcpJztcbn07XG5cbiIsIi8qanNoaW50IHdvcmtlcjogdHJ1ZSovXG5cbi8vIFdvcmtlckJyb2tlciByb3V0ZXMgbWVzc2FnZXMgYmV0d2VlbiB3ZWIgd29ya2VycyBhbmQgdGhlIG1haW4gdGhyZWFkLCBhbGxvd2luZyBmb3Igc2ltcGxlclxuLy8gYXN5bmMgY29kZSB2aWEgcHJvbWlzZXMuIEV4YW1wbGUgdXNhZ2U6XG4vL1xuLy8gSW4gd2ViIHdvcmtlciwgZGVmaW5lIGEgbWV0aG9kOlxuLy9cbi8vICAgICBzZWxmLnNxdWFyZSA9IGZ1bmN0aW9uICh4KSB7XG4vLyAgICAgICAgIHJldHVybiB4ICogeDtcbi8vICAgICB9O1xuLy9cbi8vIEluIG1haW4gdGhyZWFkLCBpbnZva2UgdGhhdCBtZXRob2QgYW5kIHJlY2VpdmUgdGhlIHJlc3VsdCAoaWYgYW55KSBhcyBhIHByb21pc2U6XG4vL1xuLy8gICAgIHdvcmtlciA9IG5ldyBXb3JrZXIoLi4uKTtcbi8vICAgICBXb3JrZXJCcm9rZXIuYWRkV29ya2VyKHdvcmtlcik7XG4vL1xuLy8gICAgIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSh3b3JrZXIsICdzcXVhcmUnLCA1KS50aGVuKGZ1bmN0aW9uKHkpIHtcbi8vICAgICAgICAgY29uc29sZS5sb2coeSk7XG4vLyAgICAgfSk7XG4vL1xuLy8gICAgIC0+IHByaW50cyAyNVxuLy9cbi8vIEFzeW5jIGNvZGU6XG4vL1xuLy8gRm9yIHN5bmNocm9ub3VzIGNvZGUgdGhhdCBtdXN0IHBhc3MgYSByZXR1cm4gdmFsdWUgdG8gdGhlIG1haW4gdGhyZWFkLCB0aGUgZnVuY3Rpb24gY2FuIHNpbXBseVxuLy8gcmV0dXJuIGFuIGltbWVkaWF0ZSB2YWx1ZSAoc2VlIGV4YW1wbGUgYWJvdmUpLiBGb3IgY2FzZXMgd2hlcmUgdGhlIHdvcmtlciBtZXRob2QgbmVlZHMgdG8gcnVuXG4vLyBhc3luY2hyb25vdXMgY29kZSwgdGhlIGZ1bmN0aW9uIGNhbiByZXR1cm4gYSBwcm9taXNlLCBhbmQgdGhlIHJlc29sdmVkIG9yIHJlamVjdGVkIHZhbHVlIHdpbGxcbi8vIGJlIHNlbnQgYmFjayB0byB0aGUgbWFpbiB0aHJlYWQgd2hlbiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQuXG4vL1xuLy8gRXJyb3IgaGFuZGxpbmc6XG4vL1xuLy8gSWYgdGhlIHdvcmtlciBtZXRob2QgZWl0aGVyIHRocm93cyBhbiBlcnJvciwgb3IgcmV0dXJucyBhIHByb21pc2UgdGhhdCBpcyByZWplY3RlZCwgaXQgd2lsbCBiZVxuLy8gc2VudCBiYWNrIHRvIHRoZSBtYWluIHRocmVhZCBhcyBhIHByb21pc2UgcmVqZWN0aW9uLiBUaGVzZSB0d28gZXhhbXBsZXMgYXJlIGVxdWl2YWxlbnQ6XG4vL1xuLy8gICAgIEluIHdvcmtlciwgdGhyb3dpbmcgYW4gZXJyb3I6XG4vL1xuLy8gICAgICAgICBzZWxmLmJyb2tlbiA9IGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXJyb3IgaW4gd29ya2VyIScpO1xuLy8gICAgICAgICB9O1xuLy9cbi8vICAgICBJbiB3b3JrZXIsIHJldHVybmluZyBhIHJlamVjdGVkIHByb21pc2U6XG4vL1xuLy8gICAgICAgICBzZWxmLmJyb2tlbiA9IGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2Vycm9yIGluIHdvcmtlciEnKSk7XG4vLyAgICAgICAgIH07XG4vL1xuLy8gICAgIEluIG1haW4gdGhyZWFkLCBib3RoIGVycm9ycyBhcmUgcmVjZWl2ZWQgYXMgYSBwcm9taXNlIHJlamVjdGlvbjpcbi8vXG4vLyAgICAgICAgIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSh3b3JrZXIsICdicm9rZW4nKS50aGVuKFxuLy8gICAgICAgICAgICAgLy8gUHJvbWlzZSByZXNvbHZlZFxuLy8gICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3N1Y2Nlc3MhJyk7XG4vLyAgICAgICAgICAgICB9LFxuLy8gICAgICAgICAgICAgLy8gUHJvbWlzZSByZWplY3RlZFxuLy8gICAgICAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbi8vICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZXJyb3IhJywgZXJyb3IpO1xuLy8gICAgICAgICAgICAgfSk7XG4vL1xuLy8gICAgICAgICAtPiBwcmludHMgJ2Vycm9yISBlcnJvciBpbiB3b3JrZXInXG4vL1xuLy8gVE9ETzogYWRkIGRvY3VtZW50YXRpb24gZm9yIGludm9raW5nIG1haW4gdGhyZWFkIG1ldGhvZHMgZnJvbSBhIHdvcmtlciAoYmFzaWNhbGx5IHNhbWUgQVBJLCBidXQgaW4gcmV2ZXJzZSlcbmltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzJztcbnZhciBXb3JrZXJCcm9rZXI7XG5leHBvcnQgZGVmYXVsdCBXb3JrZXJCcm9rZXIgPSB7fTtcblxuLy8gR2xvYmFsIGxpc3Qgb2YgYWxsIHdvcmtlciBtZXNzYWdlc1xuLy8gVW5pcXVlbHkgdHJhY2tzIGV2ZXJ5IGNhbGwgbWFkZSBiZXR3ZWVuIG1haW4gdGhyZWFkIGFuZCBhIHdvcmtlclxudmFyIG1lc3NhZ2VfaWQgPSAwO1xudmFyIG1lc3NhZ2VzID0ge307XG5cbi8vIE1haW4gdGhyZWFkOlxuLy8gLSBTZW5kIG1lc3NhZ2VzIHRvIHdvcmtlcnMsIGFuZCBvcHRpb25hbGx5IHJlY2VpdmUgYW4gYXN5bmMgcmVzcG9uc2UgYXMgYSBwcm9taXNlXG4vLyAtIFJlY2VpdmUgbWVzc2FnZXMgZnJvbSB3b3JrZXJzLCBhbmQgb3B0aW9uYWxseSBzZW5kIGFuIGFzeW5jIHJlc3BvbnNlIGJhY2sgYXMgYSBwcm9taXNlXG5mdW5jdGlvbiBzZXR1cE1haW5UaHJlYWQgKCkge1xuXG4gICAgLy8gU2VuZCBhIG1lc3NhZ2UgdG8gYSB3b3JrZXIsIGFuZCBvcHRpb25hbGx5IGdldCBhbiBhc3luYyByZXNwb25zZVxuICAgIC8vIEFyZ3VtZW50czpcbiAgICAvLyAgIC0gd29ya2VyOiB0aGUgd2ViIHdvcmtlciBpbnN0YW5jZVxuICAgIC8vICAgLSBtZXRob2Q6IHRoZSBtZXRob2Qgd2l0aCB0aGlzIG5hbWUgd2lsbCBiZSBpbnZva2VkIGluIHRoZSB3b3JrZXJcbiAgICAvLyAgIC0gbWVzc2FnZTogd2lsbCBiZSBwYXNzZWQgdG8gdGhlIG1ldGhvZCBjYWxsIGluIHRoZSB3b3JrZXJcbiAgICAvLyBSZXR1cm5zOlxuICAgIC8vICAgLSBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCBpZiB0aGUgd29ya2VyIG1ldGhvZCByZXR1cm5zIGEgdmFsdWUgKGNvdWxkIGJlIGltbWVkaWF0ZWx5LCBvciBhc3luYylcbiAgICAvL1xuICAgIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uICh3b3JrZXIsIG1ldGhvZCwgLi4ubWVzc2FnZSkge1xuICAgICAgICAvLyBUcmFjayBzdGF0ZSBvZiB0aGlzIG1lc3NhZ2VcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBtZXNzYWdlc1ttZXNzYWdlX2lkXSA9IHsgbWV0aG9kLCBtZXNzYWdlLCByZXNvbHZlLCByZWplY3QgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdtYWluX3NlbmQnLCAgICAgIC8vIG1hcmsgbWVzc2FnZSBhcyBtZXRob2QgaW52b2NhdGlvbiBmcm9tIG1haW4gdGhyZWFkXG4gICAgICAgICAgICBtZXNzYWdlX2lkLCAgICAgICAgICAgICAvLyB1bmlxdWUgaWQgZm9yIHRoaXMgbWVzc2FnZSwgZm9yIGxpZmUgb2YgcHJvZ3JhbVxuICAgICAgICAgICAgbWV0aG9kLCAgICAgICAgICAgICAgICAgLy8gd2lsbCBkaXNwYXRjaCB0byBhIGZ1bmN0aW9uIG9mIHRoaXMgbmFtZSB3aXRoaW4gdGhlIHdvcmtlclxuICAgICAgICAgICAgbWVzc2FnZSAgICAgICAgICAgICAgICAgLy8gbWVzc2FnZSBwYXlsb2FkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1lc3NhZ2VfaWQrKztcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIC8vIEFkZCBhIHdvcmtlciB0byBjb21tdW5pY2F0ZSB3aXRoIC0gZWFjaCB3b3JrZXIgbXVzdCBiZSByZWdpc3RlcmVkIGZyb20gdGhlIG1haW4gdGhyZWFkXG4gICAgdmFyIHdvcmtlcl9pZCA9IDA7XG4gICAgdmFyIHdvcmtlcnMgPSB7fTtcblxuICAgIFdvcmtlckJyb2tlci5hZGRXb3JrZXIgPSBmdW5jdGlvbiAod29ya2VyKSB7XG5cbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBhbGwgcmVnaXN0ZXJlZCB3b3JrZXJzXG4gICAgICAgIC8vIFRPRE86IGFkZGluZyBhIHByb3BlcnR5IGRpcmVjdGx5IHRvIHRoZSB3b3JrZXIsIHdvdWxkIGJlIGJldHRlciB0byB0cmFjayBub24taW5zdHJ1c2l2ZWx5LFxuICAgICAgICAvLyBtYXliZSB3aXRoIGFuIEVTNiBNYXBcbiAgICAgICAgd29ya2VyLl93b3JrZXJfYnJva2VyX2lkID0gd29ya2VyX2lkKys7XG4gICAgICAgIHdvcmtlcnNbd29ya2VyLl93b3JrZXJfYnJva2VyX2lkXSA9IHdvcmtlcjtcblxuICAgICAgICAvLyBMaXN0ZW4gZm9yIG1lc3NhZ2VzIGNvbWluZyBiYWNrIGZyb20gdGhlIHdvcmtlciwgYW5kIGZ1bGZpbGwgdGhhdCBtZXNzYWdlJ3MgcHJvbWlzZVxuICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSAhPT0gJ3dvcmtlcl9yZXBseScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFBhc3MgdGhlIHJlc3VsdCB0byB0aGUgcHJvbWlzZVxuICAgICAgICAgICAgdmFyIGlkID0gZXZlbnQuZGF0YS5tZXNzYWdlX2lkO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2VzW2lkXSkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5kYXRhLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzW2lkXS5yZWplY3QoZXZlbnQuZGF0YS5lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1tpZF0ucmVzb2x2ZShldmVudC5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgbWVzc2FnZXNbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBMaXN0ZW4gZm9yIG1lc3NhZ2VzIGluaXRpYXRpbmcgYSBjYWxsIGZyb20gdGhlIHdvcmtlciwgZGlzcGF0Y2ggdGhlbSxcbiAgICAgICAgLy8gYW5kIHNlbmQgYW55IHJldHVybiB2YWx1ZSBiYWNrIHRvIHRoZSB3b3JrZXJcbiAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIFVuaXF1ZSBpZCBmb3IgdGhpcyBtZXNzYWdlICYgcmV0dXJuIGNhbGwgdG8gbWFpbiB0aHJlYWRcbiAgICAgICAgICAgIHZhciBpZCA9IGV2ZW50LmRhdGEubWVzc2FnZV9pZDtcbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhLnR5cGUgIT09ICd3b3JrZXJfc2VuZCcgfHwgaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsbCB0aGUgcmVxdWVzdGVkIG1ldGhvZCBhbmQgc2F2ZSB0aGUgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0c1tldmVudC5kYXRhLnRhcmdldF07XG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBXb3JrZXIgYnJva2VyIGNvdWxkIG5vdCBkaXNwYXRjaCBtZXNzYWdlIHR5cGUgJHtldmVudC5kYXRhLm1ldGhvZH0gb24gdGFyZ2V0ICR7ZXZlbnQuZGF0YS50YXJnZXR9IGJlY2F1c2Ugbm8gb2JqZWN0IHdpdGggdGhhdCBuYW1lIGlzIHJlZ2lzdGVyZWQgb24gbWFpbiB0aHJlYWRgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1ldGhvZCA9ICh0eXBlb2YgdGFyZ2V0W2V2ZW50LmRhdGEubWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykgJiYgdGFyZ2V0W2V2ZW50LmRhdGEubWV0aG9kXTtcbiAgICAgICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFdvcmtlciBicm9rZXIgY291bGQgbm90IGRpc3BhdGNoIG1lc3NhZ2UgdHlwZSAke2V2ZW50LmRhdGEubWV0aG9kfSBvbiB0YXJnZXQgJHtldmVudC5kYXRhLnRhcmdldH0gYmVjYXVzZSBvYmplY3QgaGFzIG5vIG1ldGhvZCB3aXRoIHRoYXQgbmFtZWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBlcnJvcjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KHRhcmdldCwgZXZlbnQuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaHJvd24gZXJyb3JzIHdpbGwgYmUgcGFzc2VkIGJhY2sgKGluIHN0cmluZyBmb3JtKSB0byB3b3JrZXJcbiAgICAgICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNlbmQgcmV0dXJuIHZhbHVlIHRvIHdvcmtlclxuICAgICAgICAgICAgLy8gQXN5bmMgcmVzdWx0XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ21haW5fcmVwbHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZV9pZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdtYWluX3JlcGx5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VfaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYCR7ZXJyb3IubWVzc2FnZX06ICR7ZXJyb3Iuc3RhY2t9YCA6IGVycm9yKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEltbWVkaWF0ZSByZXN1bHRcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdtYWluX3JlcGx5JyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZV9pZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYCR7ZXJyb3IubWVzc2FnZX06ICR7ZXJyb3Iuc3RhY2t9YCA6IGVycm9yKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH07XG5cbiAgICAvLyBSZWdpc3RlciBhbiBvYmplY3QgdG8gcmVjZWl2ZSBjYWxscyBmcm9tIHRoZSB3b3JrZXJcbiAgICB2YXIgdGFyZ2V0cyA9IHt9O1xuICAgIFdvcmtlckJyb2tlci5hZGRUYXJnZXQgPSBmdW5jdGlvbiAobmFtZSwgdGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldHNbbmFtZV0gPSB0YXJnZXQ7XG4gICAgfTtcblxuICAgIC8vIEV4cG9zZSBmb3IgZGVidWdnaW5nXG4gICAgV29ya2VyQnJva2VyLmdldE1lc3NhZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgfTtcblxuICAgIFdvcmtlckJyb2tlci5nZXRNZXNzYWdlSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlX2lkO1xuICAgIH07XG5cbn1cblxuLy8gV29ya2VyIHRocmVhZHM6XG4vLyAtIFJlY2VpdmUgbWVzc2FnZXMgZnJvbSBtYWluIHRocmVhZCwgYW5kIG9wdGlvbmFsbHkgc2VuZCBhbiBhc3luYyByZXNwb25zZSBiYWNrIGFzIGEgcHJvbWlzZVxuLy8gLSBTZW5kIG1lc3NhZ2VzIHRvIG1haW4gdGhyZWFkLCBhbmQgb3B0aW9uYWxseSByZWNlaXZlIGFuIGFzeW5jIHJlc3BvbnNlIGFzIGEgcHJvbWlzZVxuZnVuY3Rpb24gc2V0dXBXb3JrZXJUaHJlYWQgKCkge1xuXG4gICAgLy8gU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIG1haW4gdGhyZWFkLCBhbmQgb3B0aW9uYWxseSBnZXQgYW4gYXN5bmMgcmVzcG9uc2UgYXMgYSBwcm9taXNlXG4gICAgLy8gQXJndW1lbnRzOlxuICAgIC8vICAgLSB0YXJnZXQ6IHRoZSBuYW1lIG9mIHRoZSBvYmplY3QgaW4gdGhlIG1haW4gdGhyZWFkIHRvIGJlIGNhbGxlZFxuICAgIC8vICAgLSBtZXRob2Q6IHRoZSBtZXRob2Qgd2l0aCB0aGlzIG5hbWUgd2lsbCBiZSBpbnZva2VkIG9uIHRoZSBtYWluIHRocmVhZCB0YXJnZXQgb2JqZWN0XG4gICAgLy8gICAtIG1lc3NhZ2U6IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBtZXRob2QgY2FsbCBpbiB0aGUgbWFpbiB0aHJlYWRcbiAgICAvLyBSZXR1cm5zOlxuICAgIC8vICAgLSBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCBpZiB0aGUgbWFpbiB0aHJlYWQgbWV0aG9kIHJldHVybnMgYSB2YWx1ZSAoY291bGQgYmUgaW1tZWRpYXRlbHksIG9yIGFzeW5jKVxuICAgIC8vXG4gICAgV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24gKHRhcmdldCwgbWV0aG9kLCAuLi5tZXNzYWdlKSB7XG4gICAgICAgIC8vIFRyYWNrIHN0YXRlIG9mIHRoaXMgbWVzc2FnZVxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIG1lc3NhZ2VzW21lc3NhZ2VfaWRdID0geyB0YXJnZXQsIG1ldGhvZCwgbWVzc2FnZSwgcmVzb2x2ZSwgcmVqZWN0IH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ3dvcmtlcl9zZW5kJywgICAgLy8gbWFyayBtZXNzYWdlIGFzIG1ldGhvZCBpbnZvY2F0aW9uIGZyb20gd29ya2VyXG4gICAgICAgICAgICBtZXNzYWdlX2lkLCAgICAgICAgICAgICAvLyB1bmlxdWUgaWQgZm9yIHRoaXMgbWVzc2FnZSwgZm9yIGxpZmUgb2YgcHJvZ3JhbVxuICAgICAgICAgICAgdGFyZ2V0LCAgICAgICAgICAgICAgICAgLy8gbmFtZSBvZiB0aGUgb2JqZWN0IHRvIGJlIGNhbGxlZCBvbiBtYWluIHRocmVhZFxuICAgICAgICAgICAgbWV0aG9kLCAgICAgICAgICAgICAgICAgLy8gd2lsbCBkaXNwYXRjaCB0byBhIG1ldGhvZCBvZiB0aGlzIG5hbWUgb24gdGhlIG1haW4gdGhyZWFkXG4gICAgICAgICAgICBtZXNzYWdlICAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIHBheWxvYWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWVzc2FnZV9pZCsrO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgLy8gTGlzdGVuIGZvciBtZXNzYWdlcyBjb21pbmcgYmFjayBmcm9tIHRoZSBtYWluIHRocmVhZCwgYW5kIGZ1bGZpbGwgdGhhdCBtZXNzYWdlJ3MgcHJvbWlzZVxuICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YS50eXBlICE9PSAnbWFpbl9yZXBseScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhc3MgdGhlIHJlc3VsdCB0byB0aGUgcHJvbWlzZVxuICAgICAgICB2YXIgaWQgPSBldmVudC5kYXRhLm1lc3NhZ2VfaWQ7XG4gICAgICAgIGlmIChtZXNzYWdlc1tpZF0pIHtcbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZXNbaWRdLnJlamVjdChldmVudC5kYXRhLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzW2lkXS5yZXNvbHZlKGV2ZW50LmRhdGEubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgbWVzc2FnZXNbaWRdO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBSZWNlaXZlIG1lc3NhZ2VzIGZyb20gbWFpbiB0aHJlYWQsIGRpc3BhdGNoIHRoZW0sIGFuZCBzZW5kIGJhY2sgYSByZXBseVxuICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgICAvLyBVbmlxdWUgaWQgZm9yIHRoaXMgbWVzc2FnZSAmIHJldHVybiBjYWxsIHRvIG1haW4gdGhyZWFkXG4gICAgICAgIHZhciBpZCA9IGV2ZW50LmRhdGEubWVzc2FnZV9pZDtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSAhPT0gJ21haW5fc2VuZCcgfHwgaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsbCB0aGUgcmVxdWVzdGVkIHdvcmtlciBtZXRob2QgYW5kIHNhdmUgdGhlIHJldHVybiB2YWx1ZVxuICAgICAgICB2YXIgbWV0aG9kID0gKHR5cGVvZiBzZWxmW2V2ZW50LmRhdGEubWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykgJiYgc2VsZltldmVudC5kYXRhLm1ldGhvZF07XG4gICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgV29ya2VyIGJyb2tlciBjb3VsZCBub3QgZGlzcGF0Y2ggbWVzc2FnZSB0eXBlICR7ZXZlbnQuZGF0YS5tZXRob2R9IGJlY2F1c2Ugd29ya2VyIGhhcyBubyBtZXRob2Qgd2l0aCB0aGF0IG5hbWVgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQsIGVycm9yO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KHNlbGYsIGV2ZW50LmRhdGEubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgLy8gVGhyb3duIGVycm9ycyB3aWxsIGJlIHBhc3NlZCBiYWNrIChpbiBzdHJpbmcgZm9ybSkgdG8gbWFpbiB0aHJlYWRcbiAgICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbmQgcmV0dXJuIHZhbHVlIHRvIG1haW4gdGhyZWFkXG4gICAgICAgIC8vIEFzeW5jIHJlc3VsdFxuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmVzdWx0LnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd3b3JrZXJfcmVwbHknLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnd29ya2VyX3JlcGx5JyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZV9pZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGAke2Vycm9yLm1lc3NhZ2V9OiAke2Vycm9yLnN0YWNrfWAgOiBlcnJvcilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEltbWVkaWF0ZSByZXN1bHRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnd29ya2VyX3JlcGx5JyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBpZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYCR7ZXJyb3IubWVzc2FnZX06ICR7ZXJyb3Iuc3RhY2t9YCA6IGVycm9yKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxufVxuXG4vLyBTZXR1cCB0aGlzIHRocmVhZCBhcyBhcHByb3ByaWF0ZVxuaWYgKFV0aWxzLmlzTWFpblRocmVhZCkge1xuICAgIHNldHVwTWFpblRocmVhZCgpO1xufVxuXG5pZiAoVXRpbHMuaXNXb3JrZXJUaHJlYWQpIHtcbiAgICBzZXR1cFdvcmtlclRocmVhZCgpO1xufVxuIiwiLyoqKiBWZWN0b3IgZnVuY3Rpb25zIC0gdmVjdG9ycyBwcm92aWRlZCBhcyBbeCwgeSwgel0gYXJyYXlzICoqKi9cblxuZXhwb3J0IHZhciBWZWN0b3IgPSB7fTtcblxuVmVjdG9yLnNldCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIFYgPSBbXTtcbiAgICB2YXIgbGltID0gdi5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW07IGkrKykge1xuICAgICAgICBWW2ldID0gdltpXTtcbiAgICB9XG4gICAgcmV0dXJuIFY7XG59O1xuXG5WZWN0b3IubmVnID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgViA9IFtdO1xuICAgIHZhciBsaW0gPSB2Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbTsgaSsrKSB7XG4gICAgICAgIFZbaV0gPSB2W2ldICogLTE7XG4gICAgfVxuICAgIHJldHVybiBWO1xufTtcblxuLy8gQWRkaXRpb24gb2YgdHdvIHZlY3RvcnNcblZlY3Rvci5hZGQgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgdmFyIHYgPSBbXTtcbiAgICB2YXIgbGltID0gTWF0aC5taW4odjEubGVuZ3RoLHYyLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW07IGkrKykge1xuICAgICAgICB2W2ldID0gdjFbaV0gKyB2MltpXTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59O1xuXG4vLyBTdWJzdHJhY3Rpb24gb2YgdHdvIHZlY3RvcnNcblZlY3Rvci5zdWIgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgdmFyIHYgPSBbXTtcbiAgICB2YXIgbGltID0gTWF0aC5taW4odjEubGVuZ3RoLHYyLmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbTsgaSsrKSB7XG4gICAgICAgIHZbaV0gPSB2MVtpXSAtIHYyW2ldO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn07XG5cblZlY3Rvci5zaWduZWRfYXJlYSA9IGZ1bmN0aW9uICh2MSwgdjIsIHYzKSB7XG4gICAgcmV0dXJuICh2MlswXS12MVswXSkqKHYzWzFdLXYxWzFdKSAtICh2M1swXS12MVswXSkqKHYyWzFdLXYxWzFdKTtcbn07XG5cbi8vIE11bHRpcGxpY2F0aW9uIG9mIHR3byB2ZWN0b3JzXG5WZWN0b3IubXVsdCA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICB2YXIgdiA9IFtdLFxuICAgICAgICBsZW4gPSB2MS5sZW5ndGgsXG4gICAgICAgIGk7XG4gICAgXG4gICAgaWYgKHR5cGVvZiB2MiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gTXVsaXRwbHkgYnkgc2NhbGFyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdltpXSA9IHYxW2ldICogdjI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE11bHRpcGx5IHR3byB2ZWN0b3JzXG4gICAgICAgIGxlbiA9IE1hdGgubWluKHYxLmxlbmd0aCx2Mi5sZW5ndGgpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZbaV0gPSB2MVtpXSAqIHYyW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2O1xufTtcblxuLy8gRGl2aXNpb24gb2YgdHdvIHZlY3RvcnNcblZlY3Rvci5kaXYgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgdmFyIHYgPSBbXSwgXG4gICAgICAgIGk7XG4gICAgaWYodHlwZW9mIHYyID09PSAnbnVtYmVyJyl7XG4gICAgICAgIC8vIERpdmlkZSBieSBzY2FsYXJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHYxLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZbaV0gPSB2MVtpXSAvIHYyO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRGl2aWRlIHRvIHZlY3RvcnNcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKHYxLmxlbmd0aCx2Mi5sZW5ndGgpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZbaV0gPSB2MVtpXSAvIHYyW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2O1xufTtcbiBcbi8vIEdldCAyRCBwZXJwZW5kaWN1bGFyXG5WZWN0b3IucGVycCA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICByZXR1cm4gWyB2MlsxXSAtIHYxWzFdLCBcbiAgICAgICAgICAgICB2MVswXSAtIHYyWzBdIF07XG59O1xuXG4vLyBHZXQgMkQgdmVjdG9yIHJvdGF0ZWQgXG5WZWN0b3Iucm90ID0gZnVuY3Rpb24gKHYsIGEpIHtcbiAgICB2YXIgdnIgPSBWZWN0b3IubGVuZ3RoKHYpO1xuICAgIHZhciB2YSA9IFZlY3Rvci5hbmdsZSh2KTtcbiAgICByZXR1cm4gW3ZyICogTWF0aC5jb3ModmErYSksXG4gICAgICAgICAgICB2ciAqIE1hdGguc2luKHZhK2EpXTtcbn07XG5cbi8vIEdldCAyRCBoZWFkaW5nIGFuZ2xlXG5WZWN0b3IuYW5nbGUgPSBmdW5jdGlvbiAoW3gsIHldKSB7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeSx4KTtcbn07XG5cbi8vIENvbXBhcmUgdHdvIHBvaW50c1xuVmVjdG9yLmlzRXF1YWwgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgdmFyIGxlbiA9IHYxLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh2MVtpXSAhPT0gdjJbaV0pe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLy8gVmVjdG9yIGxlbmd0aCBzcXVhcmVkXG5WZWN0b3IubGVuZ3RoU3EgPSBmdW5jdGlvbiAodilcbntcbiAgICBpZiAodi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICh2WzBdKnZbMF0gKyB2WzFdKnZbMV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICh2WzBdKnZbMF0gKyB2WzFdKnZbMV0gKyB2WzJdKnZbMl0pO1xuICAgIH1cbn07XG5cbi8vIFZlY3RvciBsZW5ndGhcblZlY3Rvci5sZW5ndGggPSBmdW5jdGlvbiAodilcbntcbiAgICByZXR1cm4gTWF0aC5zcXJ0KFZlY3Rvci5sZW5ndGhTcSh2KSk7XG59O1xuXG4vLyBOb3JtYWxpemUgYSB2ZWN0b3JcblZlY3Rvci5ub3JtYWxpemUgPSBmdW5jdGlvbiAodilcbntcbiAgICB2YXIgZDtcbiAgICBpZiAodi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgZCA9IHZbMF0qdlswXSArIHZbMV0qdlsxXTtcbiAgICAgICAgZCA9IE1hdGguc3FydChkKTtcblxuICAgICAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFt2WzBdIC8gZCwgdlsxXSAvIGRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZCA9IHZbMF0qdlswXSArIHZbMV0qdlsxXSArIHZbMl0qdlsyXTtcbiAgICAgICAgZCA9IE1hdGguc3FydChkKTtcblxuICAgICAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFt2WzBdIC8gZCwgdlsxXSAvIGQsIHZbMl0gLyBkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWzAsIDAsIDBdO1xuICAgIH1cbn07XG5cbi8vIENyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcblZlY3Rvci5jcm9zcyAgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgKHYxWzFdICogdjJbMl0pIC0gKHYxWzJdICogdjJbMV0pLFxuICAgICAgICAodjFbMl0gKiB2MlswXSkgLSAodjFbMF0gKiB2MlsyXSksXG4gICAgICAgICh2MVswXSAqIHYyWzFdKSAtICh2MVsxXSAqIHYyWzBdKVxuICAgIF07XG59O1xuXG4vLyBEb3QgcHJvZHVjdCBvZiB0d28gdmVjdG9yc1xuVmVjdG9yLmRvdCA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICB2YXIgbiA9IDA7XG4gICAgdmFyIGxpbSA9IE1hdGgubWluKHYxLmxlbmd0aCwgdjIubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbTsgaSsrKSB7XG4gICAgICAgIG4gKz0gdjFbaV0gKiB2MltpXTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG59O1xuXG4vLyBGaW5kIHRoZSBpbnRlcnNlY3Rpb24gb2YgdHdvIGxpbmVzIHNwZWNpZmllZCBhcyBzZWdtZW50cyBmcm9tIHBvaW50cyAocDEsIHAyKSBhbmQgKHAzLCBwNClcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZS1saW5lX2ludGVyc2VjdGlvblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DcmFtZXInc19ydWxlXG5WZWN0b3IubGluZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChwMSwgcDIsIHAzLCBwNCwgcGFyYWxsZWxfdG9sZXJhbmNlKSB7XG4gICAgcGFyYWxsZWxfdG9sZXJhbmNlID0gcGFyYWxsZWxfdG9sZXJhbmNlIHx8IDAuMDE7XG5cbiAgICAvLyBhMSp4ICsgYjEqeSA9IGMxIGZvciBsaW5lICh4MSwgeTEpIHRvICh4MiwgeTIpXG4gICAgLy8gYTIqeCArIGIyKnkgPSBjMiBmb3IgbGluZSAoeDMsIHkzKSB0byAoeDQsIHk0KVxuICAgIHZhciBhMSA9IHAxWzFdIC0gcDJbMV07IC8vIHkxIC0geTJcbiAgICB2YXIgYjEgPSBwMVswXSAtIHAyWzBdOyAvLyB4MSAtIHgyXG4gICAgdmFyIGEyID0gcDNbMV0gLSBwNFsxXTsgLy8geTMgLSB5NFxuICAgIHZhciBiMiA9IHAzWzBdIC0gcDRbMF07IC8vIHgzIC0geDRcbiAgICB2YXIgYzEgPSAocDFbMF0gKiBwMlsxXSkgLSAocDFbMV0gKiBwMlswXSk7IC8vIHgxKnkyIC0geTEqeDJcbiAgICB2YXIgYzIgPSAocDNbMF0gKiBwNFsxXSkgLSAocDNbMV0gKiBwNFswXSk7IC8vIHgzKnk0IC0geTMqeDRcbiAgICB2YXIgZGVub20gPSAoYjEgKiBhMikgLSAoYTEgKiBiMik7XG5cbiAgICBpZiAoTWF0aC5hYnMoZGVub20pID4gcGFyYWxsZWxfdG9sZXJhbmNlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAoKGMxICogYjIpIC0gKGIxICogYzIpKSAvIGRlbm9tLFxuICAgICAgICAgICAgKChjMSAqIGEyKSAtIChhMSAqIGMyKSkgLyBkZW5vbVxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDsgLy8gcmV0dXJuIG51bGwgaWYgbGluZXMgYXJlIChjbG9zZSB0bykgcGFyYWxsZWxcbn07XG4iXX0=
