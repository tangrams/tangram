<!doctype html>
<!--
Vector maps with Canvas and WebGL

Demo of client-side map rendering, using GeoJSON vector tiles as the remote source,
and the HTML Canvas and WebGL APIs as the rendering engines. Uses Leaflet for standard slippy map functionality.

Brett Camper
-->
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Vector map</title>
<style>

body {
    margin: 0px;
    border: 0px;
    padding: 0px;
}

#map {
    background: rgba(0, 0, 0, 0);
    /*opacity: 0.5;*/
}

.label {
    width: 200px;
    margin-left: -100px;
    position: absolute;
    z-index: 1;
    text-align: center;
}

.labelInner {
    padding: 2px;
    background: white;
    opacity: 0.75;
}

</style>
<link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.6.4/leaflet.css" />
</head>

<body>

<div id="map"></div>
<canvas id="webgl-canvas" style="position: absolute; left: 0px; top: 0px; z-index: -1;"></canvas>

<script src="http://cdn.leafletjs.com/leaflet-0.6.4/leaflet.js"></script>
<!-- <script src="../libs/Leaflet/dist/leaflet.js"></script> -->
<script src="lib/TileLayer.DivGrid.js"></script>
<script src="lib/libtess.cat.js"></script>
<script src="triangulate.js"></script>
<script src="gl.js"></script>
<script src="canvas_renderer.js"></script>
<script src="gl_renderer.js"></script>

<script>

var tiles = {};

// Makeshift style-sheet
var styles = {
    water: {
        color: {
            default: [25, 150, 220]
        }
    },
    land: {
        color: {
            default: [32, 200, 125]
        }
    },
    buildings: {
        color: {
            default: [150, 150, 150]
        },
        border: [75, 75, 75],
        // dash: {
        //     default: [4, 2]
        // }
    },
    roads: {
        color: {
            'highway': [0, 0, 0],
            'major_road': [100, 100, 100],
            'minor_road': [150, 150, 150],
            'path': [255, 255, 255],
            'rail': [0, 0, 0]
        },
        size: {
            'highway': 5,
            'major_road': 2.5,
            'minor_road': 1.5,
            'path': 0.5,
            'rail': 0.5
        },
        dash: {
            // 'rail': [4, 2]
        }
    }
};

// Point
function Point (x, y)
{
    return {
        x: x,
        y: y
    };
}

Point.copy = function (p)
{
    if (p == null) {
        return null;
    }
    return { x: p.x, y: p.y };
};

// Projection constants
var tile_size = Point(256, 256);
var half_circumference_meters = 20037508.34;
var map_origin_meters = Point(-half_circumference_meters, half_circumference_meters);
var min_zoom_meters_per_pixel = 156543.0339;
var meters_per_pixel = [];
var max_zoom = 20;
for (var z=1; z <= max_zoom; z++) {
    meters_per_pixel[z] = min_zoom_meters_per_pixel / Math.pow(2, z);
}

// Convert tile location to mercator meters - multiply by pixels per tile, then by meters per pixel, adjust for map origin
function metersForTile (tile)
{
    return Point(
        (tile.x * tile_size.x * meters_per_pixel[tile.z]) + map_origin_meters.x,
        ((tile.y * tile_size.y * meters_per_pixel[tile.z]) * -1) + map_origin_meters.y
    );
}

// Convert mercator meters to lat-lng
function metersToLatLng (meters)
{
    var c = Point.copy(meters);

    c.x /= half_circumference_meters;
    c.y /= half_circumference_meters;

    c.y = (2 * Math.atan(Math.exp(c.y * Math.PI)) - (Math.PI / 2)) / Math.PI;

    c.x *= 180;
    c.y *= 180;

    return c;
}

// Convert lat-lng to mercator meters
function latLngToMeters (latlng)
{
    var c = Point.copy(latlng);

    // Latitude
    c.y = Math.log(Math.tan((c.y + 90) * Math.PI / 360)) / (Math.PI / 180);
    c.y = c.y * half_circumference_meters / 180;

    // Longitude
    c.x = c.x * half_circumference_meters / 180;

    return c;
}

// Run a transform function on each cooordinate in a GeoJSON geometry
function transformGeometry (geometry, transform)
{
    if (geometry.type == 'Point') {
        return transform(geometry.coordinates);
    }
    else if (geometry.type == 'LineString' || geometry.type == 'MultiPoint') {
        return geometry.coordinates.map(transform);
    }
    else if (geometry.type == 'Polygon' || geometry.type == 'MultiLineString') {
        return geometry.coordinates.map(function (coordinates) {
            return coordinates.map(transform);
        });
    }
    else if (geometry.type == 'MultiPolygon') {
        return geometry.coordinates.map(function (polygon) {
            return polygon.map(function (coordinates) {
                return coordinates.map(transform);
            });
        });
    }
    // TODO: support GeometryCollection
    return {};
}

// Renderers
var canvas_renderer = new CanvasRenderer();
var gl_renderer = new GLRenderer();

var renderers = [];
// renderers.push(canvas_renderer);
renderers.push(gl_renderer);

// Leaflet map
function resizeMap () {
    document.getElementById('map').style.width = window.innerWidth + 'px';
    document.getElementById('map').style.height = window.innerHeight + 'px';
}
window.addEventListener('resize', resizeMap);
resizeMap();

var map = L.map('map', { inertia: false });
map.attributionControl.setPrefix('');

// Get location from URL or use default
var locations = {
    'London': [51.508, -0.105],
    'New York': [40.7180764, -73.9790335],
    'Seattle': [47.609722, -122.333056]
};
var map_default_location = locations['London'];
var map_default_zoom = 15;
var url_latlng = window.location.hash.slice(1, window.location.hash.length).split(',');
if (url_latlng.length == 3) {
    map.setView([url_latlng[0], url_latlng[1]], url_latlng[2]);
}
else {
    map.setView(map_default_location, map_default_zoom);
}

map.on('moveend', function () {
    var map_latlng = map.getCenter();
    window.location.hash = [map_latlng.lat, map_latlng.lng, map.getZoom()].join(',');
});

// var layer = L.tileLayer.canvas({
var layer = L.tileLayer.divGrid({
    async: true,
    maxZoom: max_zoom,
    attribution: '<a href="https://github.com/bcamper/canvas-map">Source Code</a>',
    unloadInvisibleTiles: false,
    updateWhenIdle: false,
    preloadInvisibleTiles: 0
});

layer.on('tileunload', function (event) {
    var tile = event.tile;
    var key = tile.getAttribute('data-tile-key');
    console.log("unload " + key);
    if (key && tiles[key]) {
        renderers.forEach(function (renderer) { renderer.removeTile(tiles[key]); });
    }

    delete tiles[key];
});

// layer.drawTile = function(canvas, tilePoint, zoom) {
layer.drawTile = function(tileDiv, tilePoint, zoom) {
    // Load tile
    var single_layer = null; //'water-areas';
    // var tile_url = 'http://tile.openstreetmap.us/vectiles-' + (single_layer || 'all') + '/' + zoom + '/' + tilePoint.x + '/' + tilePoint.y + '.json';
    var tile_url = 'http://api-vector-test.mapzen.com/vector/' + (single_layer || 'all') + '/' + zoom + '/' + tilePoint.x + '/' + tilePoint.y + '.json';
    // var tile_url = 'http://localhost:8080/vector/' + (single_layer || 'all') + '/' + zoom + '/' + tilePoint.x + '/' + tilePoint.y + '.json';
    var req = new XMLHttpRequest();
    req.onload = function () {
        var tile = JSON.parse(req.response);
        if (single_layer != null) {
            var t = tile;
            tile = {};
            tile[single_layer] = t;
        }
        tile.key = [tilePoint.x, tilePoint.y, zoom].join('/');
        tileDiv.setAttribute('data-tile-key', tile.key); // tile info for debugging
        tileDiv.style.width = '256px';
        tileDiv.style.height = '256px';

        var debug_overlay = document.createElement('div');
        debug_overlay.textContent = tile.key;
        debug_overlay.style.position = 'absolute';
        debug_overlay.style.left = 0;
        debug_overlay.style.top = 0;
        debug_overlay.style.color = 'white';
        // tileDiv.appendChild(debug_overlay);

        // Mercator projection for geometry and bounds
        for (var t in tile) {
            if (tile.hasOwnProperty(t) && typeof tile[t] == 'object') {
                tile[t].features.forEach(function (feature) {
                    feature.geometry.coordinates = transformGeometry(feature.geometry, function (coordinates) {
                        var m = latLngToMeters(Point(coordinates[0], coordinates[1]));
                        return [m.x, m.y];
                    });
                });
            }
        }
        tile.min = metersForTile({ x: tilePoint.x, y: tilePoint.y, z: zoom });
        tile.max = metersForTile({ x: tilePoint.x + 1, y: tilePoint.y + 1, z: zoom });

        // Track and render
        tiles[tile.key] = {};
        tiles[tile.key].key = tile.key;
        renderers.forEach(function (renderer) { renderer.addTile(tile, tileDiv); });
        layer.tileDrawn(tileDiv);
    };
    req.open('GET', tile_url, true /* async flag */);
    req.send();
}

window.addEventListener('load', function () {
    requestAnimationFrameCompatibility();
    renderers.forEach(function (renderer) { renderer.init(); });
    layer.addTo(map);
    frame();
});

/***** Animation loop *****/

// Cross-browser compatibility for requestAnimationFrame
// (function requestAnimationFrameCompatibility ()
function requestAnimationFrameCompatibility ()
{
  if (window.requestAnimationFrame == undefined) {
      window.requestAnimationFrame =
          (function () {
              return (
                  window.requestAnimationFrame       ||
                  window.webkitRequestAnimationFrame ||
                  window.mozRequestAnimationFrame    ||
                  window.oRequestAnimationFrame      ||
                  window.msRequestAnimationFrame     ||
                  function (callback) {
                      window.setTimeout(callback, 1000 / 60);
                  }
              );
          })();
  }
}
// }());

function frame () {
    render();
    requestAnimationFrame(frame);
}

function render () {
    renderers.forEach(function (renderer) { renderer.render(); });
}

</script>

<script id="vertex-shader" type="x-shader/x-vertex">
    // precision highp float;

    uniform vec2 resolution;
    uniform vec2 map_center;
    uniform float map_zoom;

    attribute vec3 position;
    attribute vec3 color;

    varying vec3 fcolor;

    // Project lat-lng to mercator
    // vec2 latLngToMeters (vec2 coordinate) {
    //     const float pi = 3.1415926;
    //     const float half_circumference_meters = 20037508.34;
    //     vec2 projected;

    //     // Latitude
    //     projected.y = log(tan((coordinate.y + 90.0) * pi / 360.0)) / (pi / 180.0);
    //     projected.y = projected.y * half_circumference_meters / 180.0;

    //     // Longitude
    //     projected.x = coordinate.x * half_circumference_meters / 180.0;

    //     return projected;
    // }

    void main() {
        vec3 pos_trans = position;

        // Scale mercator meters to viewport
        const float min_zoom_meters_per_pixel = 156543.0339;
        float meters_per_pixel = min_zoom_meters_per_pixel / pow(2.0, map_zoom);
        vec2 meter_zoom = vec2(resolution.x / 2.0 * meters_per_pixel, resolution.y / 2.0 * meters_per_pixel);

        pos_trans.xy -= map_center;
        pos_trans.xy /= meter_zoom;

        // pos_trans.y *= abs(sin(pos_trans.x));

        pos_trans.z = (-pos_trans.z + 32768.0) / 65536.0; // reverse and scale to 0-1

        fcolor = color;

        gl_Position = vec4(pos_trans, 1.0);
    }

</script>

<script id="fragment-shader" type="x-shader/x-fragment">

    uniform vec2 resolution;
    // uniform vec2 map_center;

    varying vec3 fcolor;

    // http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
    // float rand (vec2 co) {
    //    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
    // }

    void main (void) {
        vec2 position = gl_FragCoord.xy / resolution.xy;    // scale coords to [0.0, 1.0]
        position = position * 2.0 - 1.0;                    // scale coords to [-1.0, 1.0]
        position.y *= resolution.y / resolution.x;          // correct aspect ratio

        vec3 color = fcolor;
        // vec3 color = fcolor * max(1.0 - distance(position, vec2(0.0, 0.0)), 0.15);
        // vec3 color = fcolor * (1.0 - dot(normalize(vec3(rand(gl_FragCoord.xy * 0.01) * 10.0, 0.0, -1.0)), vec3(0, 0, 1.0)));

        gl_FragColor = vec4(color, 1.0);
        // gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    }

</script>

</body>
</html>
