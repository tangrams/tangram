<!doctype html>
<!--
Vector maps with WebGL & Canvas

Demo of client-side map rendering, using GeoJSON vector tiles as the remote source,
and the HTML Canvas and WebGL APIs as the rendering engines. Uses Leaflet for standard slippy map functionality.

Brett Camper
-->
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Vector map</title>
<style>

body {
    margin: 0px;
    border: 0px;
    padding: 0px;
}

#map {
    background: rgba(0, 0, 0, 0);
    /*opacity: 0.5;*/
}

.label {
    width: 200px;
    margin-left: -100px;
    position: absolute;
    z-index: 1;
    text-align: center;
}

.labelInner {
    padding: 2px;
    background: white;
    opacity: 0.75;
}

</style>
<link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.6.4/leaflet.css" />
</head>

<body>

<div id="map"></div>
<canvas id="webgl-canvas" style="position: absolute; left: 0px; top: 0px; z-index: -1;"></canvas>

<script src="http://cdn.leafletjs.com/leaflet-0.6.4/leaflet.js"></script>
<!-- <script src="../libs/Leaflet/dist/leaflet.js"></script> -->
<script src="lib/TileLayer.DivGrid.js"></script>
<script src="lib/libtess.cat.js"></script>
<script src="gl.js"></script>
<script src="layers.js"></script>
<script src="vector_renderer.js"></script>
<script src="canvas_renderer.js"></script>
<script src="gl_renderer.js"></script>

<script>

// Makeshift style-sheet
var styles = {
    water: {
        color: {
            default: [25, 150, 220]
        }
    },
    land_unlabeled: {
        color: {
            default: [32, 200, 125]
        }
    },
    land_labeled: {
        color: {
            default: [2, 170, 95]
        }
        // border: {
        //     color: {
        //         default: [255, 255, 255]
        //     },
        //     size: {
        //         default: 1
        //     }
        // }
    },
    buildings: {
        color: {
            default: [150, 150, 150]
        },
        border: {
            color: {
                default: [75, 75, 75]
            },
            size: {
                default: 1
            }
        }
    },
    roads: {
        color: {
            'highway': [0, 0, 0],
            'major_road': [100, 100, 100],
            'minor_road': [150, 150, 150],
            'path': [255, 255, 255],
            'rail': [0, 0, 0]
        },
        size: {
            'highway': 5,
            'major_road': 2.5,
            'minor_road': 1.5,
            'path': 0.5,
            'rail': 0.5
        },
        dash: {
            // 'rail': [4, 2]
        }
    },
    road_labels: {
        size: {
            default: 15
        }
    },
    pois: {
        color: {
            default: [240, 0, 0]
        },
        size: {
            default: 5
        },
        border: {
            color: {
                default: [240, 240, 240]
            },
            size: {
                default: 2
            }
        }
    }
};

// Point
function Point (x, y)
{
    return {
        x: x,
        y: y
    };
}

Point.copy = function (p)
{
    if (p == null) {
        return null;
    }
    return { x: p.x, y: p.y };
};

// Projection constants
var tile_size = Point(256, 256);
var half_circumference_meters = 20037508.34;
var map_origin_meters = Point(-half_circumference_meters, half_circumference_meters);
var min_zoom_meters_per_pixel = 156543.0339;
var meters_per_pixel = [];
var max_zoom = 20;
for (var z=1; z <= max_zoom; z++) {
    meters_per_pixel[z] = min_zoom_meters_per_pixel / Math.pow(2, z);
}

// Convert tile location to mercator meters - multiply by pixels per tile, then by meters per pixel, adjust for map origin
function metersForTile (tile)
{
    return Point(
        (tile.x * tile_size.x * meters_per_pixel[tile.z]) + map_origin_meters.x,
        ((tile.y * tile_size.y * meters_per_pixel[tile.z]) * -1) + map_origin_meters.y
    );
}

// Convert mercator meters to lat-lng
function metersToLatLng (meters)
{
    var c = Point.copy(meters);

    c.x /= half_circumference_meters;
    c.y /= half_circumference_meters;

    c.y = (2 * Math.atan(Math.exp(c.y * Math.PI)) - (Math.PI / 2)) / Math.PI;

    c.x *= 180;
    c.y *= 180;

    return c;
}

// Convert lat-lng to mercator meters
function latLngToMeters (latlng)
{
    var c = Point.copy(latlng);

    // Latitude
    c.y = Math.log(Math.tan((c.y + 90) * Math.PI / 360)) / (Math.PI / 180);
    c.y = c.y * half_circumference_meters / 180;

    // Longitude
    c.x = c.x * half_circumference_meters / 180;

    return c;
}

// Run a transform function on each cooordinate in a GeoJSON geometry
function transformGeometry (geometry, transform)
{
    if (geometry.type == 'Point') {
        return transform(geometry.coordinates);
    }
    else if (geometry.type == 'LineString' || geometry.type == 'MultiPoint') {
        return geometry.coordinates.map(transform);
    }
    else if (geometry.type == 'Polygon' || geometry.type == 'MultiLineString') {
        return geometry.coordinates.map(function (coordinates) {
            return coordinates.map(transform);
        });
    }
    else if (geometry.type == 'MultiPolygon') {
        return geometry.coordinates.map(function (polygon) {
            return polygon.map(function (coordinates) {
                return coordinates.map(transform);
            });
        });
    }
    // TODO: support GeometryCollection
    return {};
}

// Resize map
function resizeMap () {
    document.getElementById('map').style.width = window.innerWidth + 'px';
    document.getElementById('map').style.height = window.innerHeight + 'px';
}
window.addEventListener('resize', resizeMap);
resizeMap();

// Leaflet map
var map = L.map('map', {
    inertia: false,
    keyboard: false
});
map.attributionControl.setPrefix('');

// Get location from URL or use default
var locations = {
    'London': [51.508, -0.105, 15],
    'New York': [40.70531887544228, -74.00976419448853, 16],
    'Seattle': [47.609722, -122.333056, 15]
};
var map_start_location = locations['New York'];

// URL hash pattern is one of:
// #[gl|canvas]
// #[gl|canvas],[lat],[lng],[zoom]
// #[gl|canvas],[location name]
var url_hash = window.location.hash.slice(1, window.location.hash.length).split(',');
if (url_hash.length == 4) {
    map_start_location = url_hash.slice(1, 4);
}
else if (url_hash.length == 2) {
    map_start_location = locations[url_hash[1]];
}
map.setView(map_start_location.slice(0, 2), map_start_location[2]);

map.on('moveend', function () {
    var map_latlng = map.getCenter();
    window.location.hash = [renderer_type, map_latlng.lat, map_latlng.lng, map.getZoom()].join(',');
});

var layer = L.tileLayer.divGrid({
    async: true,
    maxZoom: max_zoom,
    attribution: '<a href="https://github.com/bcamper/vector-map">Source Code</a>',
    unloadInvisibleTiles: false,
    updateWhenIdle: false,
    preloadInvisibleTiles: 0
});

layer.drawTile = function(tileDiv, tilePoint, zoom) {
    renderer.loadTile({ x: tilePoint.x, y: tilePoint.y, z: zoom }, tileDiv);
}

// Renderers
var renderer_type = (url_hash.length > 0 && url_hash[0] != '') ? url_hash[0] : 'gl';
var renderer;
if (renderer_type == 'gl') {
   renderer = new GLRenderer({ map: map, layer: layer }, gl_layers);
}
else {
    renderer = new CanvasRenderer({ map: map, layer: layer }, canvas_layers);
}

// Start render loop
window.addEventListener('load', function () {
    requestAnimationFrameCompatibility();
    renderer.init();
    layer.addTo(map);
    frameLoop();
});

/***** Animation loop *****/

// Cross-browser compatibility for requestAnimationFrame
// (function requestAnimationFrameCompatibility ()
function requestAnimationFrameCompatibility ()
{
  if (window.requestAnimationFrame == undefined) {
      window.requestAnimationFrame =
          (function () {
              return (
                  window.requestAnimationFrame       ||
                  window.webkitRequestAnimationFrame ||
                  window.mozRequestAnimationFrame    ||
                  window.oRequestAnimationFrame      ||
                  window.msRequestAnimationFrame     ||
                  function (callback) {
                      window.setTimeout(callback, 1000 / 60);
                  }
              );
          })();
  }
}
// }());

function frameLoop () {
    frame();
    requestAnimationFrame(frameLoop);
}

function frame () {
    renderer.render();
}

</script>
</body>
</html>
